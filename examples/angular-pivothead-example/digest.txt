Directory structure:
└── angular-pivothead-example/
    ├── README.md
    ├── angular.json
    ├── package.json
    ├── server.ts
    ├── tsconfig.app.json
    ├── tsconfig.json
    ├── tsconfig.spec.json
    ├── .editorconfig
    ├── src/
    │   ├── index.html
    │   ├── main.server.ts
    │   ├── main.ts
    │   ├── styles.css
    │   └── app/
    │       ├── app.component.css
    │       ├── app.component.html
    │       ├── app.component.ts
    │       ├── app.config.server.ts
    │       ├── app.config.ts
    │       ├── data.ts
    │       ├── options.ts
    │       └── minimal-mode/
    │           ├── minimal-mode.component.css
    │           ├── minimal-mode.component.html
    │           └── minimal-mode.component.ts
    └── .angular/
        └── cache/
            └── 18.2.20/
                └── angular-pivothead-example/
                    ├── angular-compiler.db
                    ├── angular-compiler.db-lock
                    ├── .tsbuildinfo
                    └── vite/
                        └── deps/
                            ├── @angular_common.js
                            ├── @angular_common_http.js
                            ├── @angular_core.js
                            ├── @angular_core_primitives_event-dispatch.js
                            ├── @angular_core_primitives_signals.js
                            ├── @mindfiredigital_pivothead-angular.js
                            ├── _metadata.json
                            ├── chunk-2VVDJA4L.js
                            ├── chunk-5NODSH2C.js
                            ├── chunk-HB2ZDJCU.js
                            ├── chunk-HHOT2EEL.js
                            ├── chunk-JBLJVEST.js
                            ├── chunk-LPUAGQXJ.js
                            ├── chunk-OVFEQSRS.js
                            ├── chunk-VKET2LIV.js
                            ├── chunk-WDMUDEB6.js
                            ├── html2canvas.esm-1a1724a1-JMHMFZKW.js
                            ├── index.es-980ec5f7-65FC5NO6.js
                            ├── package.json
                            ├── pivot-head-2VQXMX42.js
                            ├── purify.es-78c333b1-RMLJBMGN.js
                            ├── rxjs.js
                            └── rxjs_operators.js

================================================
FILE: README.md
================================================
# AngularPivotheadExample

This project was generated with [Angular CLI](https://github.com/angular/angular-cli) version 18.2.20.

## Development server

Run `ng serve` for a dev server. Navigate to `http://localhost:4200/`. The application will automatically reload if you change any of the source files.

## Code scaffolding

Run `ng generate component component-name` to generate a new component. You can also use `ng generate directive|pipe|service|class|guard|interface|enum|module`.

## Build

Run `ng build` to build the project. The build artifacts will be stored in the `dist/` directory.

## Running unit tests

Run `ng test` to execute the unit tests via [Karma](https://karma-runner.github.io).

## Running end-to-end tests

Run `ng e2e` to execute the end-to-end tests via a platform of your choice. To use this command, you need to first add a package that implements end-to-end testing capabilities.

## Further help

To get more help on the Angular CLI use `ng help` or go check out the [Angular CLI Overview and Command Reference](https://angular.dev/tools/cli) page.



================================================
FILE: angular.json
================================================
{
  "$schema": "./node_modules/@angular/cli/lib/config/schema.json",
  "version": 1,
  "cli": {
    "packageManager": "pnpm"
  },
  "newProjectRoot": "projects",
  "projects": {
    "angular-pivothead-example": {
      "projectType": "application",
      "schematics": {
        "@schematics/angular:class": {
          "skipTests": true
        },
        "@schematics/angular:component": {
          "skipTests": true
        },
        "@schematics/angular:directive": {
          "skipTests": true
        },
        "@schematics/angular:guard": {
          "skipTests": true
        },
        "@schematics/angular:interceptor": {
          "skipTests": true
        },
        "@schematics/angular:pipe": {
          "skipTests": true
        },
        "@schematics/angular:resolver": {
          "skipTests": true
        },
        "@schematics/angular:service": {
          "skipTests": true
        }
      },
      "root": "",
      "sourceRoot": "src",
      "prefix": "app",
      "architect": {
        "build": {
          "builder": "@angular-devkit/build-angular:application",
          "options": {
            "outputPath": "dist/angular-pivothead-example",
            "index": "src/index.html",
            "browser": "src/main.ts",
            "polyfills": [
              "zone.js"
            ],
            "tsConfig": "tsconfig.app.json",
            "assets": [
              {
                "glob": "**/*",
                "input": "public"
              }
            ],
            "styles": [
              "src/styles.css"
            ],
            "scripts": [],
            "preserveSymlinks": true
          },
          "configurations": {
            "production": {
              "budgets": [
                {
                  "type": "initial",
                  "maximumWarning": "500kB",
                  "maximumError": "1MB"
                },
                {
                  "type": "anyComponentStyle",
                  "maximumWarning": "2kB",
                  "maximumError": "4kB"
                }
              ],
              "outputHashing": "all"
            },
            "development": {
              "optimization": false,
              "extractLicenses": false,
              "sourceMap": true
            }
          },
          "defaultConfiguration": "production"
        },
        "serve": {
          "builder": "@angular-devkit/build-angular:dev-server",
          "configurations": {
            "production": {
              "buildTarget": "angular-pivothead-example:build:production"
            },
            "development": {
              "buildTarget": "angular-pivothead-example:build:development"
            }
          },
          "defaultConfiguration": "development"
        },
        "extract-i18n": {
          "builder": "@angular-devkit/build-angular:extract-i18n"
        },
        "test": {
          "builder": "@angular-devkit/build-angular:karma",
          "options": {
            "polyfills": [
              "zone.js",
              "zone.js/testing"
            ],
            "tsConfig": "tsconfig.spec.json",
            "assets": [
              {
                "glob": "**/*",
                "input": "public"
              }
            ],
            "styles": [
              "src/styles.css"
            ],
            "scripts": []
          }
        }
      }
    }
  }
}



================================================
FILE: package.json
================================================
{
  "name": "angular-pivothead-example",
  "version": "0.0.0",
  "scripts": {
    "ng": "ng",
    "start": "ng serve",
    "build": "ng build",
    "watch": "ng build --watch --configuration development",
    "test": "echo 'no tests'",
    "serve:ssr:angular-pivothead-example": "node dist/angular-pivothead-example/server/server.mjs",
    "dev": "ng serve --port 5189 --host 0.0.0.0 --open"
  },
  "private": true,
  "dependencies": {
    "@angular/animations": "^18.2.0",
    "@angular/common": "^18.2.0",
    "@angular/compiler": "^18.2.0",
    "@angular/core": "^18.2.0",
    "@angular/forms": "^18.2.0",
    "@angular/platform-browser": "^18.2.0",
    "@angular/platform-browser-dynamic": "^18.2.0",
    "@angular/platform-server": "^18.2.0",
    "@angular/router": "^18.2.0",
    "@angular/ssr": "^18.2.20",
    "express": "^4.18.2",
    "rxjs": "~7.8.0",
    "tslib": "^2.3.0",
    "zone.js": "~0.14.10",
    "@mindfiredigital/pivothead-angular": "workspace:*",
    "@mindfiredigital/pivothead-web-component": "workspace:*"
  },
  "devDependencies": {
    "@angular-devkit/build-angular": "^18.2.20",
    "@angular/cli": "^18.2.20",
    "@angular/compiler-cli": "^18.2.0",
    "@types/express": "^4.17.17",
    "@types/jasmine": "~5.1.0",
    "@types/node": "^18.18.0",
    "jasmine-core": "~5.2.0",
    "karma": "~6.4.0",
    "karma-chrome-launcher": "~3.2.0",
    "karma-coverage": "~2.2.0",
    "karma-jasmine": "~5.1.0",
    "karma-jasmine-html-reporter": "~2.1.0",
    "typescript": "~5.5.2"
  }
}


================================================
FILE: server.ts
================================================
import { APP_BASE_HREF } from '@angular/common';
import { CommonEngine } from '@angular/ssr';
import express from 'express';
import { fileURLToPath } from 'node:url';
import { dirname, join, resolve } from 'node:path';
import bootstrap from './src/main.server';

// The Express app is exported so that it can be used by serverless Functions.
export function app(): express.Express {
  const server = express();
  const serverDistFolder = dirname(fileURLToPath(import.meta.url));
  const browserDistFolder = resolve(serverDistFolder, '../browser');
  const indexHtml = join(serverDistFolder, 'index.server.html');

  const commonEngine = new CommonEngine();

  server.set('view engine', 'html');
  server.set('views', browserDistFolder);

  // Example Express Rest API endpoints
  // server.get('/api/**', (req, res) => { });
  // Serve static files from /browser
  server.get('**', express.static(browserDistFolder, {
    maxAge: '1y',
    index: 'index.html',
  }));

  // All regular routes use the Angular engine
  server.get('**', (req, res, next) => {
    const { protocol, originalUrl, baseUrl, headers } = req;

    commonEngine
      .render({
        bootstrap,
        documentFilePath: indexHtml,
        url: `${protocol}://${headers.host}${originalUrl}`,
        publicPath: browserDistFolder,
        providers: [{ provide: APP_BASE_HREF, useValue: baseUrl }],
      })
      .then((html) => res.send(html))
      .catch((err) => next(err));
  });

  return server;
}

function run(): void {
  const port = process.env['PORT'] || 4000;

  // Start up the Node server
  const server = app();
  server.listen(port, () => {
    console.log(`Node Express server listening on http://localhost:${port}`);
  });
}

run();



================================================
FILE: tsconfig.app.json
================================================
/* To learn more about Typescript configuration file: https://www.typescriptlang.org/docs/handbook/tsconfig-json.html. */
/* To learn more about Angular compiler options: https://angular.dev/reference/configs/angular-compiler-options. */
{
  "extends": "./tsconfig.json",
  "compilerOptions": {
    "outDir": "./out-tsc/app",
    "types": [
      "node"
    ]
  },
  "files": [
    "src/main.ts",
    "src/main.server.ts",
    "server.ts"
  ],
  "include": [
    "src/**/*.d.ts"
  ]
}



================================================
FILE: tsconfig.json
================================================
/* To learn more about Typescript configuration file: https://www.typescriptlang.org/docs/handbook/tsconfig-json.html. */
/* To learn more about Angular compiler options: https://angular.dev/reference/configs/angular-compiler-options. */
{
  "compileOnSave": false,
  "compilerOptions": {
    "outDir": "./dist/out-tsc",
    "strict": true,
    "noImplicitOverride": true,
    "noPropertyAccessFromIndexSignature": true,
    "noImplicitReturns": true,
    "noFallthroughCasesInSwitch": true,
    "skipLibCheck": true,
    "isolatedModules": true,
    "esModuleInterop": true,
    "sourceMap": true,
    "declaration": false,
    "experimentalDecorators": true,
    "moduleResolution": "bundler",
    "importHelpers": true,
    "target": "ES2022",
    "module": "ES2022",
    "lib": [
      "ES2022",
      "dom"
    ],
    "paths": {
      "@angular/*": [
        "./node_modules/@angular/*"
      ]
    }
  },
  "angularCompilerOptions": {
    "enableI18nLegacyMessageIdFormat": false,
    "strictInjectionParameters": true,
    "strictInputAccessModifiers": true,
    "strictTemplates": true
  }
}



================================================
FILE: tsconfig.spec.json
================================================
/* To learn more about Typescript configuration file: https://www.typescriptlang.org/docs/handbook/tsconfig-json.html. */
/* To learn more about Angular compiler options: https://angular.dev/reference/configs/angular-compiler-options. */
{
  "extends": "./tsconfig.json",
  "compilerOptions": {
    "outDir": "./out-tsc/spec",
    "types": [
      "jasmine"
    ]
  },
  "include": [
    "src/**/*.spec.ts",
    "src/**/*.d.ts"
  ]
}



================================================
FILE: .editorconfig
================================================
# Editor configuration, see https://editorconfig.org
root = true

[*]
charset = utf-8
indent_style = space
indent_size = 2
insert_final_newline = true
trim_trailing_whitespace = true

[*.ts]
quote_type = single
ij_typescript_use_double_quotes = false

[*.md]
max_line_length = off
trim_trailing_whitespace = false



================================================
FILE: src/index.html
================================================
<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>AngularPivotheadExample</title>
  <base href="/">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link rel="icon" type="image/x-icon" href="favicon.ico">
</head>
<body>
  <app-root></app-root>
</body>
</html>



================================================
FILE: src/main.server.ts
================================================
import { bootstrapApplication } from '@angular/platform-browser';
import { AppComponent } from './app/app.component';
import { config } from './app/app.config.server';

const bootstrap = () => bootstrapApplication(AppComponent, config);

export default bootstrap;



================================================
FILE: src/main.ts
================================================
import { bootstrapApplication } from '@angular/platform-browser';
import { appConfig } from './app/app.config';
import { AppComponent } from './app/app.component';

bootstrapApplication(AppComponent, appConfig)
  .catch((err) => console.error(err));



================================================
FILE: src/styles.css
================================================
/* You can add global styles to this file, and also import other style files */



================================================
FILE: src/app/app.component.css
================================================



================================================
FILE: src/app/app.component.html
================================================
<!-- * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * -->
<!-- * * * * * * * * * * * The content below * * * * * * * * * * * -->
<!-- * * * * * * * * * * is only a place  <div [ngStyle]="{'width': '100%', 'max-width': '1100px', 'margin': '2rem auto 0 auto'}">`older * * * * * * * * * * -->
<!-- * * * * * * * * * * and can be replaced.  * * * * * * * * * * -->
<!-- * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * -->
<!-- * * * * * * * * * Delete the template below * * * * * * * * * -->
<!-- * * * * * * * to get started with your project! * * * * * * * -->
<!-- * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * -->

<style>
  :host {
    --bright-blue: oklch(51.01% 0.274 263.83);
    --electric-violet: oklch(53.18% 0.28 296.97);
    --french-violet: oklch(47.66% 0.246 305.88);
    --vivid-pink: oklch(69.02% 0.277 332.77);
    --hot-red: oklch(61.42% 0.238 15.34);
    --orange-red: oklch(63.32% 0.24 31.68);

    --gray-900: oklch(19.37% 0.006 300.98);
    --gray-700: oklch(36.98% 0.014 302.71);
    --gray-400: oklch(70.9% 0.015 304.04);

    --red-to-pink-to-purple-vertical-gradient: linear-gradient(
      180deg,
      var(--orange-red) 0%,
      var(--vivid-pink) 50%,
      var(--electric-violet) 100%
    );

    --red-to-pink-to-purple-horizontal-gradient: linear-gradient(
      90deg,
      var(--orange-red) 0%,
      var(--vivid-pink) 50%,
      var(--electric-violet) 100%
    );

    --pill-accent: var(--bright-blue);

    font-family: "Inter", -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto,
      Helvetica, Arial, sans-serif, "Apple Color Emoji", "Segoe UI Emoji",
      "Segoe UI Symbol";
    box-sizing: border-box;
    -webkit-font-smoothing: antialiased;
    -moz-osx-font-smoothing: grayscale;
  }

  h1 {
    font-size: 3.125rem;
    color: var(--gray-900);
    font-weight: 500;
    line-height: 100%;
    letter-spacing: -0.125rem;
    margin: 0;
    font-family: "Inter Tight", -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto,
      Helvetica, Arial, sans-serif, "Apple Color Emoji", "Segoe UI Emoji",
      "Segoe UI Symbol";
  }

  p {
    margin: 0;
    color: var(--gray-700);
  }

  main {
    width: 100%;
    min-height: 100%;
    display: flex;
    justify-content: center;
    align-items: center;
    padding: 1rem;
    box-sizing: inherit;
    position: relative;
  }

  .angular-logo {
    max-width: 9.2rem;
  }

  .content {
    display: flex;
    justify-content: space-around;
    width: 100%;
    max-width: 700px;
    margin-bottom: 3rem;
  }

  .content h1 {
    margin-top: 1.75rem;
  }

  .content p {
    margin-top: 1.5rem;
  }

  .divider {
    width: 1px;
    background: var(--red-to-pink-to-purple-vertical-gradient);
    margin-inline: 0.5rem;
  }

  .pill-group {
    display: flex;
    flex-direction: column;
    align-items: start;
    flex-wrap: wrap;
    gap: 1.25rem;
  }

  .pill {
    display: flex;
    align-items: center;
    --pill-accent: var(--bright-blue);
    background: color-mix(in srgb, var(--pill-accent) 5%, transparent);
    color: var(--pill-accent);
    padding-inline: 0.75rem;
    padding-block: 0.375rem;
    border-radius: 2.75rem;
    border: 0;
    transition: background 0.3s ease;
    font-family: var(--inter-font);
    font-size: 0.875rem;
    font-style: normal;
    font-weight: 500;
    line-height: 1.4rem;
    letter-spacing: -0.00875rem;
    text-decoration: none;
  }

  .pill:hover {
    background: color-mix(in srgb, var(--pill-accent) 15%, transparent);
  }

  .pill-group .pill:nth-child(6n + 1) {
    --pill-accent: var(--bright-blue);
  }
  .pill-group .pill:nth-child(6n + 2) {
    --pill-accent: var(--french-violet);
  }
  .pill-group .pill:nth-child(6n + 3),
  .pill-group .pill:nth-child(6n + 4),
  .pill-group .pill:nth-child(6n + 5) {
    --pill-accent: var(--hot-red);
  }

  .pill-group svg {
    margin-inline-start: 0.25rem;
  }

  .social-links {
    display: flex;
    align-items: center;
    gap: 0.73rem;
    margin-top: 1.5rem;
  }

  .social-links path {
    transition: fill 0.3s ease;
    fill: var(--gray-400);
  }

  .social-links a:hover svg path {
    fill: var(--gray-900);
  }

  @media screen and (max-width: 650px) {
    .content {
      flex-direction: column;
      width: max-content;
    }

    .divider {
      height: 1px;
      width: 100%;
      background: var(--red-to-pink-to-purple-horizontal-gradient);
      margin-block: 1.5rem;
    }
  }
</style>

<main class="main">
  <!-- Remove Angular placeholder and social icons, show only Default and Minimal Mode demos -->
  <!-- Vertical layout: Default Mode above, Minimal Mode below -->
  <div style="width: 100%; max-width: 1100px; margin: 2rem auto 0 auto;">
    <div style="margin-bottom: 2.5rem;">
      <h2 style="font-size:2rem; font-weight:600; margin-bottom:1rem;">Default Mode</h2>
      <pivot-head-angular
        [mode]="'default'"
        [data]="data"
        [options]="options"
        [ngStyle]="{
          'display': 'block',
          'min-height': '340px',
          'border': '1px solid #ececec',
          'background': '#fff',
          'border-radius': '8px',
          'padding': '12px'
        }"
      ></pivot-head-angular>
    </div>
    <div>
      <h2 style="font-size:2rem; font-weight:600; margin-bottom:1rem;">Minimal Mode</h2>
      <app-minimal-mode [data]="data" [options]="options"></app-minimal-mode>
    </div>
  </div>
</main>

<!-- * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * -->
<!-- * * * * * * * * * * * The content above * * * * * * * * * * * * -->
<!-- * * * * * * * * * * is only a placeholder * * * * * * * * * * * -->
<!-- * * * * * * * * * * and can be replaced.  * * * * * * * * * * * -->
<!-- * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * -->
<!-- * * * * * * * * * * End of Placeholder  * * * * * * * * * * * * -->
<!-- * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * -->





================================================
FILE: src/app/app.component.ts
================================================
import { Component } from '@angular/core';
import { CommonModule } from '@angular/common';
import { demoData } from './data';
import { baseOptions } from './options';
import { CUSTOM_ELEMENTS_SCHEMA } from '@angular/core';
import { MinimalModeComponent } from './minimal-mode/minimal-mode.component';
import { PivotHeadModule } from '@mindfiredigital/pivothead-angular';

@Component({
  selector: 'app-root',
  standalone: true,
  imports: [CommonModule, MinimalModeComponent, PivotHeadModule],
  schemas: [CUSTOM_ELEMENTS_SCHEMA],
  templateUrl: './app.component.html',
  styleUrls: ['./app.component.css']
})
export class AppComponent {
  title = 'angular-pivothead-example';
  data = demoData;
  options = baseOptions;
}



================================================
FILE: src/app/app.config.server.ts
================================================
import { mergeApplicationConfig, ApplicationConfig } from '@angular/core';
import { provideServerRendering } from '@angular/platform-server';
import { appConfig } from './app.config';

const serverConfig: ApplicationConfig = {
  providers: [
    provideServerRendering()
  ]
};

export const config = mergeApplicationConfig(appConfig, serverConfig);



================================================
FILE: src/app/app.config.ts
================================================
import { ApplicationConfig, provideZoneChangeDetection } from '@angular/core';

export const appConfig: ApplicationConfig = {
  providers: [provideZoneChangeDetection({ eventCoalescing: true })]
};



================================================
FILE: src/app/data.ts
================================================
export type DataRecord = Record<string, unknown>;

export const demoData: DataRecord[] = [
  { country: 'Australia', category: 'Accessories', price: 174, discount: 23 },
  { country: 'Australia', category: 'Accessories', price: 680, discount: 80 },
  { country: 'Australia', category: 'Cars', price: 900, discount: 50 },
  { country: 'Australia', category: 'Electronics', price: 1200, discount: 120 },
  { country: 'Canada', category: 'Cars', price: 180, discount: 80 },
  { country: 'Canada', category: 'Electronics', price: 850, discount: 85 },
  { country: 'Canada', category: 'Accessories', price: 320, discount: 40 },
  { country: 'USA', category: 'Electronics', price: 1500, discount: 150 },
  { country: 'USA', category: 'Cars', price: 2200, discount: 220 },
  { country: 'USA', category: 'Accessories', price: 450, discount: 45 },
  { country: 'Germany', category: 'Cars', price: 1800, discount: 90 },
  { country: 'Germany', category: 'Electronics', price: 950, discount: 95 },
  { country: 'France', category: 'Accessories', price: 380, discount: 38 },
  { country: 'France', category: 'Cars', price: 1600, discount: 160 },
  { country: 'UK', category: 'Electronics', price: 1100, discount: 110 }
];



================================================
FILE: src/app/options.ts
================================================
export type PivotOptions = {
  rows?: unknown[];
  columns?: unknown[];
  measures?: unknown[];
  pageSize?: number;
  [k: string]: unknown;
};

export const baseOptions: PivotOptions = {
  rows: [{ uniqueName: 'country', caption: 'Country' }],
  columns: [{ uniqueName: 'category', caption: 'Category' }],
  measures: [
    { uniqueName: 'price', caption: 'Sum of Price', aggregation: 'sum' },
    { uniqueName: 'discount', caption: 'Sum of Discount', aggregation: 'sum' }
  ],
  pageSize: 10
};



================================================
FILE: src/app/minimal-mode/minimal-mode.component.css
================================================
.minimal-toolbar button{ padding:4px 8px; border:1px solid #e5e7eb; background:#f9fafb; border-radius:4px; cursor:pointer }
.minimal-toolbar select,.minimal-toolbar input{ border:1px solid #e5e7eb; border-radius:4px; padding:4px 6px }



================================================
FILE: src/app/minimal-mode/minimal-mode.component.html
================================================
<div style="border:1px solid #e5e7eb; border-radius:8px; padding:12px; background:#fff;">
  <pivot-head-angular
    #ph
    [mode]="'minimal'"
    [data]="data"
    [options]="options"
    (stateChange)="onStateChange($event)"
    (viewModeChange)="onViewMode($event)"
    (paginationChange)="onPagination($event)"
  ></pivot-head-angular>

  <div class="minimal-toolbar" style="display:flex; gap:8px; align-items:center; flex-wrap:wrap; margin-bottom:8px;">
    <label>Field
      <select [value]="filterFieldValue" (change)="onFilterFieldChange($event)" style="margin-left:6px;">
        <option value="" disabled [selected]="!filterFieldValue">Select</option>
        <option *ngFor="let f of fieldOptionsValue" [value]="f">{{ f }}</option>
      </select>
    </label>
    <label>Operator
      <select [value]="filterOperatorValue" (change)="onFilterOperatorChange($event)" style="margin-left:6px;">
        <option value="equals">Equals</option>
        <option value="contains">Contains</option>
        <option value="greaterThan">Greater Than</option>
        <option value="lessThan">Less Than</option>
      </select>
    </label>
    <input type="text" [value]="filterValueValue" (input)="onFilterValueInput($event)" placeholder="Value"/>
    <button (click)="applyFilter()">Apply</button>
    <button (click)="resetFilter()">Reset</button>
    <button (click)="showFormat()">Format</button>
    <button (click)="toggleViewMode()">Switch to {{ viewModeValue === 'processed' ? 'Raw' : 'Processed' }}</button>
    <span style="margin-left:auto"></span>
    <label>Page Size
      <select [value]="paginationValue.pageSize" (change)="onPageSizeChange($event)">
        <option [value]="10">10</option>
        <option [value]="25">25</option>
        <option [value]="50">50</option>
      </select>
    </label>
    <span>of {{ paginationValue.totalPages }}</span>
    <button (click)="prevPage()">Prev</button>
    <input type="number" [value]="paginationValue.currentPage" style="width:60px" (change)="onPageInputChange($event)"/>
    <button (click)="nextPage()">Next</button>
  </div>

  <table class="minimal-table" style="width:100%; border-collapse:collapse;">
    <thead>
      <tr>
        <th *ngFor="let col of state?.columns">{{ col.caption }}</th>
        <th *ngFor="let measure of state?.measures">{{ measure.caption }}</th>
      </tr>
    </thead>
    <tbody>
      <tr *ngFor="let row of state?.rows; let i = index">
        <td>{{ row.caption }}</td>
        <td *ngFor="let measure of state?.measures">{{ getCellValue(row.uniqueName, measure.uniqueName) }}</td>
      </tr>
    </tbody>
  </table>
</div>



================================================
FILE: src/app/minimal-mode/minimal-mode.component.ts
================================================
import { Component, CUSTOM_ELEMENTS_SCHEMA, ViewChild, ElementRef, Input } from '@angular/core';
import { CommonModule } from '@angular/common';
import type { PivotOptions } from '../options';
import type { DataRecord } from '../data';
import { PivotHeadModule } from '@mindfiredigital/pivothead-angular';
import type { PivotHeadEl, FilterConfig, PaginationConfig } from '@mindfiredigital/pivothead-angular';

// Narrowed shapes used locally
interface AxisField { uniqueName: string; caption: string }
interface MeasureField { uniqueName: string; caption: string; aggregation: string }
interface MinimalState {
  rows?: AxisField[];
  columns?: AxisField[];
  measures?: MeasureField[];
  rawData?: DataRecord[];
  data?: DataRecord[];
}

@Component({
  selector: 'app-minimal-mode',
  standalone: true,
  imports: [CommonModule, PivotHeadModule],
  schemas: [CUSTOM_ELEMENTS_SCHEMA],
  templateUrl: './minimal-mode.component.html',
  styleUrl: './minimal-mode.component.css'
})
export class MinimalModeComponent {
  @Input() data: DataRecord[] = [];
  @Input() options?: PivotOptions;

  // Local UI state properties
  viewMode: 'processed' | 'raw' = 'processed';
  filters: FilterConfig[] = [];
  pagination = { currentPage: 1, totalPages: 1, pageSize: 10 };

  // Derived fields for filter dropdown
  state: MinimalState | null = null;
  fieldOptions: string[] = [];
  filterField = '';
  filterOperator = 'equals';
  filterValue = '';

  @ViewChild('ph', { read: ElementRef }) phEl?: ElementRef<HTMLElement>;

  private get el(): PivotHeadEl | null {
    const host = this.phEl?.nativeElement as HTMLElement | undefined;
    if (!host) return null;
    if (host.tagName === 'PIVOT-HEAD') return host as unknown as PivotHeadEl;
    const child = host.querySelector?.('pivot-head');
    return (child as unknown as PivotHeadEl) || null;
  }

  onStateChange(e: any) {
    const detail = e?.detail ?? e;
    this.state = detail as MinimalState;
    this.syncPagination();
    this.syncFilterFields();
  }
  onViewMode(e: any) {
    const detail = e?.detail ?? e;
    this.viewMode = detail.mode;
    const st = this.el?.getState?.();
    if (st) this.state = st as MinimalState;
    this.syncPagination();
    this.syncFilterFields();
  }
  onPagination(e: any) {
    const detail = e?.detail ?? e;
    this.pagination = { currentPage: detail.currentPage, totalPages: detail.totalPages, pageSize: detail.pageSize };
  }

  applyFilter() {
    const field = this.filterField;
    const operator = this.filterOperator;
    const value = this.filterValue;
    if (!field) return;
    const next: FilterConfig[] = [{ field, operator, value } as FilterConfig];
    const el = this.el;
    if (!el) return;
    try { el.setAttribute('filters', JSON.stringify(next)); } catch (_err) { /* noop */ void 0; }
    try { (el as PivotHeadEl).filters = next as FilterConfig[]; } catch (_err) { /* noop */ void 0; }
    try { el.goToPage?.(1); } catch (_err) { /* noop */ void 0; }
  }
  resetFilter() {
    this.filterValue = '';
    const el = this.el;
    if (!el) return;
    try { el.setAttribute('filters', JSON.stringify([])); } catch (_err) { /* noop */ void 0; }
    try { (el as PivotHeadEl).filters = [] as FilterConfig[]; } catch (_err) { /* noop */ void 0; }
    try { el.goToPage?.(1); } catch (_err) { /* noop */ void 0; }
  }
  changePageSize(size: number) {
    const el = this.el;
    if (!el) return;
    try { el.setPageSize?.(size); } catch (_err) { /* noop */ void 0; }
  }
  goToPage(n: number) {
    const el = this.el;
    if (!el) return;
    try { el.goToPage?.(n); } catch (_err) { /* noop */ void 0; }
  }
  showFormat() { this.el?.showFormatPopup?.(); }

  private syncPagination() {
    const p = this.el?.getPagination?.();
    if (p) this.pagination = { currentPage: p.currentPage, totalPages: p.totalPages, pageSize: p.pageSize };
  }

  private syncFilterFields() {
    const st = this.state;
    if (!st) return;
    const opts: string[] = [];
    if (this.viewMode === 'processed') {
      st.rows?.forEach(r => opts.push(r.uniqueName));
      st.columns?.forEach(c => opts.push(c.uniqueName));
      st.measures?.forEach(m => opts.push(`${m.aggregation}_${m.uniqueName}`));
    } else {
      const rows = (st.rawData || st.data || []) as Array<Record<string, unknown>>;
      const keys = rows.length ? Object.keys(rows[0]) : [];
      opts.push(...keys);
    }
    this.fieldOptions = opts;
    if (!opts.length) return;
    if (!opts.includes(this.filterField)) this.filterField = opts[0];
  }

  getCellValue(rowKey: string, measureKey: string): string {
    const st = this.state;
    if (!st || !st.data) return '';
    const record = st.data.find((r: any) => r[rowKey] !== undefined);
    return record ? String(record[measureKey]) : '';
  }

  // Getters for template binding
  get viewModeValue() { return this.viewMode; }
  get filtersValue() { return this.filters; }
  get paginationValue() { return this.pagination; }
  get fieldOptionsValue() { return this.fieldOptions; }
  get filterFieldValue() { return this.filterField; }
  get filterOperatorValue() { return this.filterOperator; }
  get filterValueValue() { return this.filterValue; }

  onFilterFieldChange(event: Event) {
    const value = (event.target as HTMLSelectElement).value;
    this.filterField = value;
  }
  onFilterOperatorChange(event: Event) {
    const value = (event.target as HTMLSelectElement).value as 'equals' | 'contains' | 'greaterThan' | 'lessThan';
    this.filterOperator = value;
  }
  onFilterValueInput(event: Event) {
    const value = (event.target as HTMLInputElement).value;
    this.filterValue = value;
  }
  onPageSizeChange(event: Event) {
    const value = Number((event.target as HTMLSelectElement).value);
    this.changePageSize(value);
  }
  onPageInputChange(event: Event) {
    const value = Number((event.target as HTMLInputElement).value);
    this.goToPage(value);
  }
  prevPage() {
    this.goToPage(Math.max(1, this.pagination.currentPage - 1));
  }
  nextPage() {
    this.goToPage(Math.min(this.pagination.totalPages, this.pagination.currentPage + 1));
  }
  toggleViewMode() {
    this.viewMode = this.viewMode === 'processed' ? 'raw' : 'processed';
    const el = this.el;
    if (el) {
      try { el.setAttribute('mode', 'minimal'); } catch (_err) { /* noop */ void 0; }
      const st = el.getState?.();
      if (st) this.state = st as MinimalState;
      this.syncPagination();
      this.syncFilterFields();
    }
  }
}



================================================
FILE: .angular/cache/18.2.20/angular-pivothead-example/angular-compiler.db
================================================
[Non-text file]


================================================
FILE: .angular/cache/18.2.20/angular-pivothead-example/angular-compiler.db-lock
================================================
[Non-text file]


================================================
FILE: .angular/cache/18.2.20/angular-pivothead-example/.tsbuildinfo
================================================
{"program":{"fileNames":["../../../../../../node_modules/.pnpm/typescript@5.5.2/node_modules/typescript/lib/lib.es5.d.ts","../../../../../../node_modules/.pnpm/typescript@5.5.2/node_modules/typescript/lib/lib.es2015.d.ts","../../../../../../node_modules/.pnpm/typescript@5.5.2/node_modules/typescript/lib/lib.es2016.d.ts","../../../../../../node_modules/.pnpm/typescript@5.5.2/node_modules/typescript/lib/lib.es2017.d.ts","../../../../../../node_modules/.pnpm/typescript@5.5.2/node_modules/typescript/lib/lib.es2018.d.ts","../../../../../../node_modules/.pnpm/typescript@5.5.2/node_modules/typescript/lib/lib.es2019.d.ts","../../../../../../node_modules/.pnpm/typescript@5.5.2/node_modules/typescript/lib/lib.es2020.d.ts","../../../../../../node_modules/.pnpm/typescript@5.5.2/node_modules/typescript/lib/lib.es2021.d.ts","../../../../../../node_modules/.pnpm/typescript@5.5.2/node_modules/typescript/lib/lib.es2022.d.ts","../../../../../../node_modules/.pnpm/typescript@5.5.2/node_modules/typescript/lib/lib.dom.d.ts","../../../../../../node_modules/.pnpm/typescript@5.5.2/node_modules/typescript/lib/lib.es2015.core.d.ts","../../../../../../node_modules/.pnpm/typescript@5.5.2/node_modules/typescript/lib/lib.es2015.collection.d.ts","../../../../../../node_modules/.pnpm/typescript@5.5.2/node_modules/typescript/lib/lib.es2015.generator.d.ts","../../../../../../node_modules/.pnpm/typescript@5.5.2/node_modules/typescript/lib/lib.es2015.iterable.d.ts","../../../../../../node_modules/.pnpm/typescript@5.5.2/node_modules/typescript/lib/lib.es2015.promise.d.ts","../../../../../../node_modules/.pnpm/typescript@5.5.2/node_modules/typescript/lib/lib.es2015.proxy.d.ts","../../../../../../node_modules/.pnpm/typescript@5.5.2/node_modules/typescript/lib/lib.es2015.reflect.d.ts","../../../../../../node_modules/.pnpm/typescript@5.5.2/node_modules/typescript/lib/lib.es2015.symbol.d.ts","../../../../../../node_modules/.pnpm/typescript@5.5.2/node_modules/typescript/lib/lib.es2015.symbol.wellknown.d.ts","../../../../../../node_modules/.pnpm/typescript@5.5.2/node_modules/typescript/lib/lib.es2016.array.include.d.ts","../../../../../../node_modules/.pnpm/typescript@5.5.2/node_modules/typescript/lib/lib.es2016.intl.d.ts","../../../../../../node_modules/.pnpm/typescript@5.5.2/node_modules/typescript/lib/lib.es2017.date.d.ts","../../../../../../node_modules/.pnpm/typescript@5.5.2/node_modules/typescript/lib/lib.es2017.object.d.ts","../../../../../../node_modules/.pnpm/typescript@5.5.2/node_modules/typescript/lib/lib.es2017.sharedmemory.d.ts","../../../../../../node_modules/.pnpm/typescript@5.5.2/node_modules/typescript/lib/lib.es2017.string.d.ts","../../../../../../node_modules/.pnpm/typescript@5.5.2/node_modules/typescript/lib/lib.es2017.intl.d.ts","../../../../../../node_modules/.pnpm/typescript@5.5.2/node_modules/typescript/lib/lib.es2017.typedarrays.d.ts","../../../../../../node_modules/.pnpm/typescript@5.5.2/node_modules/typescript/lib/lib.es2018.asyncgenerator.d.ts","../../../../../../node_modules/.pnpm/typescript@5.5.2/node_modules/typescript/lib/lib.es2018.asynciterable.d.ts","../../../../../../node_modules/.pnpm/typescript@5.5.2/node_modules/typescript/lib/lib.es2018.intl.d.ts","../../../../../../node_modules/.pnpm/typescript@5.5.2/node_modules/typescript/lib/lib.es2018.promise.d.ts","../../../../../../node_modules/.pnpm/typescript@5.5.2/node_modules/typescript/lib/lib.es2018.regexp.d.ts","../../../../../../node_modules/.pnpm/typescript@5.5.2/node_modules/typescript/lib/lib.es2019.array.d.ts","../../../../../../node_modules/.pnpm/typescript@5.5.2/node_modules/typescript/lib/lib.es2019.object.d.ts","../../../../../../node_modules/.pnpm/typescript@5.5.2/node_modules/typescript/lib/lib.es2019.string.d.ts","../../../../../../node_modules/.pnpm/typescript@5.5.2/node_modules/typescript/lib/lib.es2019.symbol.d.ts","../../../../../../node_modules/.pnpm/typescript@5.5.2/node_modules/typescript/lib/lib.es2019.intl.d.ts","../../../../../../node_modules/.pnpm/typescript@5.5.2/node_modules/typescript/lib/lib.es2020.bigint.d.ts","../../../../../../node_modules/.pnpm/typescript@5.5.2/node_modules/typescript/lib/lib.es2020.date.d.ts","../../../../../../node_modules/.pnpm/typescript@5.5.2/node_modules/typescript/lib/lib.es2020.promise.d.ts","../../../../../../node_modules/.pnpm/typescript@5.5.2/node_modules/typescript/lib/lib.es2020.sharedmemory.d.ts","../../../../../../node_modules/.pnpm/typescript@5.5.2/node_modules/typescript/lib/lib.es2020.string.d.ts","../../../../../../node_modules/.pnpm/typescript@5.5.2/node_modules/typescript/lib/lib.es2020.symbol.wellknown.d.ts","../../../../../../node_modules/.pnpm/typescript@5.5.2/node_modules/typescript/lib/lib.es2020.intl.d.ts","../../../../../../node_modules/.pnpm/typescript@5.5.2/node_modules/typescript/lib/lib.es2020.number.d.ts","../../../../../../node_modules/.pnpm/typescript@5.5.2/node_modules/typescript/lib/lib.es2021.promise.d.ts","../../../../../../node_modules/.pnpm/typescript@5.5.2/node_modules/typescript/lib/lib.es2021.string.d.ts","../../../../../../node_modules/.pnpm/typescript@5.5.2/node_modules/typescript/lib/lib.es2021.weakref.d.ts","../../../../../../node_modules/.pnpm/typescript@5.5.2/node_modules/typescript/lib/lib.es2021.intl.d.ts","../../../../../../node_modules/.pnpm/typescript@5.5.2/node_modules/typescript/lib/lib.es2022.array.d.ts","../../../../../../node_modules/.pnpm/typescript@5.5.2/node_modules/typescript/lib/lib.es2022.error.d.ts","../../../../../../node_modules/.pnpm/typescript@5.5.2/node_modules/typescript/lib/lib.es2022.intl.d.ts","../../../../../../node_modules/.pnpm/typescript@5.5.2/node_modules/typescript/lib/lib.es2022.object.d.ts","../../../../../../node_modules/.pnpm/typescript@5.5.2/node_modules/typescript/lib/lib.es2022.sharedmemory.d.ts","../../../../../../node_modules/.pnpm/typescript@5.5.2/node_modules/typescript/lib/lib.es2022.string.d.ts","../../../../../../node_modules/.pnpm/typescript@5.5.2/node_modules/typescript/lib/lib.es2022.regexp.d.ts","../../../../../../node_modules/.pnpm/typescript@5.5.2/node_modules/typescript/lib/lib.esnext.intl.d.ts","../../../../../../node_modules/.pnpm/typescript@5.5.2/node_modules/typescript/lib/lib.decorators.d.ts","../../../../../../node_modules/.pnpm/typescript@5.5.2/node_modules/typescript/lib/lib.decorators.legacy.d.ts","../../../../node_modules/tslib/tslib.d.ts","../../../../src/main.ngtypecheck.ts","../../../../node_modules/rxjs/dist/types/internal/Subscription.d.ts","../../../../node_modules/rxjs/dist/types/internal/Subscriber.d.ts","../../../../node_modules/rxjs/dist/types/internal/Operator.d.ts","../../../../node_modules/rxjs/dist/types/internal/Observable.d.ts","../../../../node_modules/rxjs/dist/types/internal/types.d.ts","../../../../node_modules/rxjs/dist/types/internal/operators/audit.d.ts","../../../../node_modules/rxjs/dist/types/internal/operators/auditTime.d.ts","../../../../node_modules/rxjs/dist/types/internal/operators/buffer.d.ts","../../../../node_modules/rxjs/dist/types/internal/operators/bufferCount.d.ts","../../../../node_modules/rxjs/dist/types/internal/operators/bufferTime.d.ts","../../../../node_modules/rxjs/dist/types/internal/operators/bufferToggle.d.ts","../../../../node_modules/rxjs/dist/types/internal/operators/bufferWhen.d.ts","../../../../node_modules/rxjs/dist/types/internal/operators/catchError.d.ts","../../../../node_modules/rxjs/dist/types/internal/operators/combineLatestAll.d.ts","../../../../node_modules/rxjs/dist/types/internal/operators/combineAll.d.ts","../../../../node_modules/rxjs/dist/types/internal/operators/combineLatest.d.ts","../../../../node_modules/rxjs/dist/types/internal/operators/combineLatestWith.d.ts","../../../../node_modules/rxjs/dist/types/internal/operators/concat.d.ts","../../../../node_modules/rxjs/dist/types/internal/operators/concatAll.d.ts","../../../../node_modules/rxjs/dist/types/internal/operators/concatMap.d.ts","../../../../node_modules/rxjs/dist/types/internal/operators/concatMapTo.d.ts","../../../../node_modules/rxjs/dist/types/internal/operators/concatWith.d.ts","../../../../node_modules/rxjs/dist/types/internal/operators/connect.d.ts","../../../../node_modules/rxjs/dist/types/internal/operators/count.d.ts","../../../../node_modules/rxjs/dist/types/internal/operators/debounce.d.ts","../../../../node_modules/rxjs/dist/types/internal/operators/debounceTime.d.ts","../../../../node_modules/rxjs/dist/types/internal/operators/defaultIfEmpty.d.ts","../../../../node_modules/rxjs/dist/types/internal/operators/delay.d.ts","../../../../node_modules/rxjs/dist/types/internal/operators/delayWhen.d.ts","../../../../node_modules/rxjs/dist/types/internal/operators/dematerialize.d.ts","../../../../node_modules/rxjs/dist/types/internal/operators/distinct.d.ts","../../../../node_modules/rxjs/dist/types/internal/operators/distinctUntilChanged.d.ts","../../../../node_modules/rxjs/dist/types/internal/operators/distinctUntilKeyChanged.d.ts","../../../../node_modules/rxjs/dist/types/internal/operators/elementAt.d.ts","../../../../node_modules/rxjs/dist/types/internal/operators/endWith.d.ts","../../../../node_modules/rxjs/dist/types/internal/operators/every.d.ts","../../../../node_modules/rxjs/dist/types/internal/operators/exhaustAll.d.ts","../../../../node_modules/rxjs/dist/types/internal/operators/exhaust.d.ts","../../../../node_modules/rxjs/dist/types/internal/operators/exhaustMap.d.ts","../../../../node_modules/rxjs/dist/types/internal/operators/expand.d.ts","../../../../node_modules/rxjs/dist/types/internal/operators/filter.d.ts","../../../../node_modules/rxjs/dist/types/internal/operators/finalize.d.ts","../../../../node_modules/rxjs/dist/types/internal/operators/find.d.ts","../../../../node_modules/rxjs/dist/types/internal/operators/findIndex.d.ts","../../../../node_modules/rxjs/dist/types/internal/operators/first.d.ts","../../../../node_modules/rxjs/dist/types/internal/Subject.d.ts","../../../../node_modules/rxjs/dist/types/internal/operators/groupBy.d.ts","../../../../node_modules/rxjs/dist/types/internal/operators/ignoreElements.d.ts","../../../../node_modules/rxjs/dist/types/internal/operators/isEmpty.d.ts","../../../../node_modules/rxjs/dist/types/internal/operators/last.d.ts","../../../../node_modules/rxjs/dist/types/internal/operators/map.d.ts","../../../../node_modules/rxjs/dist/types/internal/operators/mapTo.d.ts","../../../../node_modules/rxjs/dist/types/internal/Notification.d.ts","../../../../node_modules/rxjs/dist/types/internal/operators/materialize.d.ts","../../../../node_modules/rxjs/dist/types/internal/operators/max.d.ts","../../../../node_modules/rxjs/dist/types/internal/operators/merge.d.ts","../../../../node_modules/rxjs/dist/types/internal/operators/mergeAll.d.ts","../../../../node_modules/rxjs/dist/types/internal/operators/mergeMap.d.ts","../../../../node_modules/rxjs/dist/types/internal/operators/flatMap.d.ts","../../../../node_modules/rxjs/dist/types/internal/operators/mergeMapTo.d.ts","../../../../node_modules/rxjs/dist/types/internal/operators/mergeScan.d.ts","../../../../node_modules/rxjs/dist/types/internal/operators/mergeWith.d.ts","../../../../node_modules/rxjs/dist/types/internal/operators/min.d.ts","../../../../node_modules/rxjs/dist/types/internal/observable/ConnectableObservable.d.ts","../../../../node_modules/rxjs/dist/types/internal/operators/multicast.d.ts","../../../../node_modules/rxjs/dist/types/internal/operators/observeOn.d.ts","../../../../node_modules/rxjs/dist/types/internal/operators/onErrorResumeNextWith.d.ts","../../../../node_modules/rxjs/dist/types/internal/operators/pairwise.d.ts","../../../../node_modules/rxjs/dist/types/internal/operators/partition.d.ts","../../../../node_modules/rxjs/dist/types/internal/operators/pluck.d.ts","../../../../node_modules/rxjs/dist/types/internal/operators/publish.d.ts","../../../../node_modules/rxjs/dist/types/internal/operators/publishBehavior.d.ts","../../../../node_modules/rxjs/dist/types/internal/operators/publishLast.d.ts","../../../../node_modules/rxjs/dist/types/internal/operators/publishReplay.d.ts","../../../../node_modules/rxjs/dist/types/internal/operators/race.d.ts","../../../../node_modules/rxjs/dist/types/internal/operators/raceWith.d.ts","../../../../node_modules/rxjs/dist/types/internal/operators/reduce.d.ts","../../../../node_modules/rxjs/dist/types/internal/operators/repeat.d.ts","../../../../node_modules/rxjs/dist/types/internal/operators/repeatWhen.d.ts","../../../../node_modules/rxjs/dist/types/internal/operators/retry.d.ts","../../../../node_modules/rxjs/dist/types/internal/operators/retryWhen.d.ts","../../../../node_modules/rxjs/dist/types/internal/operators/refCount.d.ts","../../../../node_modules/rxjs/dist/types/internal/operators/sample.d.ts","../../../../node_modules/rxjs/dist/types/internal/operators/sampleTime.d.ts","../../../../node_modules/rxjs/dist/types/internal/operators/scan.d.ts","../../../../node_modules/rxjs/dist/types/internal/operators/sequenceEqual.d.ts","../../../../node_modules/rxjs/dist/types/internal/operators/share.d.ts","../../../../node_modules/rxjs/dist/types/internal/operators/shareReplay.d.ts","../../../../node_modules/rxjs/dist/types/internal/operators/single.d.ts","../../../../node_modules/rxjs/dist/types/internal/operators/skip.d.ts","../../../../node_modules/rxjs/dist/types/internal/operators/skipLast.d.ts","../../../../node_modules/rxjs/dist/types/internal/operators/skipUntil.d.ts","../../../../node_modules/rxjs/dist/types/internal/operators/skipWhile.d.ts","../../../../node_modules/rxjs/dist/types/internal/operators/startWith.d.ts","../../../../node_modules/rxjs/dist/types/internal/operators/subscribeOn.d.ts","../../../../node_modules/rxjs/dist/types/internal/operators/switchAll.d.ts","../../../../node_modules/rxjs/dist/types/internal/operators/switchMap.d.ts","../../../../node_modules/rxjs/dist/types/internal/operators/switchMapTo.d.ts","../../../../node_modules/rxjs/dist/types/internal/operators/switchScan.d.ts","../../../../node_modules/rxjs/dist/types/internal/operators/take.d.ts","../../../../node_modules/rxjs/dist/types/internal/operators/takeLast.d.ts","../../../../node_modules/rxjs/dist/types/internal/operators/takeUntil.d.ts","../../../../node_modules/rxjs/dist/types/internal/operators/takeWhile.d.ts","../../../../node_modules/rxjs/dist/types/internal/operators/tap.d.ts","../../../../node_modules/rxjs/dist/types/internal/operators/throttle.d.ts","../../../../node_modules/rxjs/dist/types/internal/operators/throttleTime.d.ts","../../../../node_modules/rxjs/dist/types/internal/operators/throwIfEmpty.d.ts","../../../../node_modules/rxjs/dist/types/internal/operators/timeInterval.d.ts","../../../../node_modules/rxjs/dist/types/internal/operators/timeout.d.ts","../../../../node_modules/rxjs/dist/types/internal/operators/timeoutWith.d.ts","../../../../node_modules/rxjs/dist/types/internal/operators/timestamp.d.ts","../../../../node_modules/rxjs/dist/types/internal/operators/toArray.d.ts","../../../../node_modules/rxjs/dist/types/internal/operators/window.d.ts","../../../../node_modules/rxjs/dist/types/internal/operators/windowCount.d.ts","../../../../node_modules/rxjs/dist/types/internal/operators/windowTime.d.ts","../../../../node_modules/rxjs/dist/types/internal/operators/windowToggle.d.ts","../../../../node_modules/rxjs/dist/types/internal/operators/windowWhen.d.ts","../../../../node_modules/rxjs/dist/types/internal/operators/withLatestFrom.d.ts","../../../../node_modules/rxjs/dist/types/internal/operators/zip.d.ts","../../../../node_modules/rxjs/dist/types/internal/operators/zipAll.d.ts","../../../../node_modules/rxjs/dist/types/internal/operators/zipWith.d.ts","../../../../node_modules/rxjs/dist/types/operators/index.d.ts","../../../../node_modules/rxjs/dist/types/internal/scheduler/Action.d.ts","../../../../node_modules/rxjs/dist/types/internal/Scheduler.d.ts","../../../../node_modules/rxjs/dist/types/internal/testing/TestMessage.d.ts","../../../../node_modules/rxjs/dist/types/internal/testing/SubscriptionLog.d.ts","../../../../node_modules/rxjs/dist/types/internal/testing/SubscriptionLoggable.d.ts","../../../../node_modules/rxjs/dist/types/internal/testing/ColdObservable.d.ts","../../../../node_modules/rxjs/dist/types/internal/testing/HotObservable.d.ts","../../../../node_modules/rxjs/dist/types/internal/scheduler/AsyncScheduler.d.ts","../../../../node_modules/rxjs/dist/types/internal/scheduler/timerHandle.d.ts","../../../../node_modules/rxjs/dist/types/internal/scheduler/AsyncAction.d.ts","../../../../node_modules/rxjs/dist/types/internal/scheduler/VirtualTimeScheduler.d.ts","../../../../node_modules/rxjs/dist/types/internal/testing/TestScheduler.d.ts","../../../../node_modules/rxjs/dist/types/testing/index.d.ts","../../../../node_modules/rxjs/dist/types/internal/symbol/observable.d.ts","../../../../node_modules/rxjs/dist/types/internal/observable/dom/animationFrames.d.ts","../../../../node_modules/rxjs/dist/types/internal/BehaviorSubject.d.ts","../../../../node_modules/rxjs/dist/types/internal/ReplaySubject.d.ts","../../../../node_modules/rxjs/dist/types/internal/AsyncSubject.d.ts","../../../../node_modules/rxjs/dist/types/internal/scheduler/AsapScheduler.d.ts","../../../../node_modules/rxjs/dist/types/internal/scheduler/asap.d.ts","../../../../node_modules/rxjs/dist/types/internal/scheduler/async.d.ts","../../../../node_modules/rxjs/dist/types/internal/scheduler/QueueScheduler.d.ts","../../../../node_modules/rxjs/dist/types/internal/scheduler/queue.d.ts","../../../../node_modules/rxjs/dist/types/internal/scheduler/AnimationFrameScheduler.d.ts","../../../../node_modules/rxjs/dist/types/internal/scheduler/animationFrame.d.ts","../../../../node_modules/rxjs/dist/types/internal/util/identity.d.ts","../../../../node_modules/rxjs/dist/types/internal/util/pipe.d.ts","../../../../node_modules/rxjs/dist/types/internal/util/noop.d.ts","../../../../node_modules/rxjs/dist/types/internal/util/isObservable.d.ts","../../../../node_modules/rxjs/dist/types/internal/lastValueFrom.d.ts","../../../../node_modules/rxjs/dist/types/internal/firstValueFrom.d.ts","../../../../node_modules/rxjs/dist/types/internal/util/ArgumentOutOfRangeError.d.ts","../../../../node_modules/rxjs/dist/types/internal/util/EmptyError.d.ts","../../../../node_modules/rxjs/dist/types/internal/util/NotFoundError.d.ts","../../../../node_modules/rxjs/dist/types/internal/util/ObjectUnsubscribedError.d.ts","../../../../node_modules/rxjs/dist/types/internal/util/SequenceError.d.ts","../../../../node_modules/rxjs/dist/types/internal/util/UnsubscriptionError.d.ts","../../../../node_modules/rxjs/dist/types/internal/observable/bindCallback.d.ts","../../../../node_modules/rxjs/dist/types/internal/observable/bindNodeCallback.d.ts","../../../../node_modules/rxjs/dist/types/internal/AnyCatcher.d.ts","../../../../node_modules/rxjs/dist/types/internal/observable/combineLatest.d.ts","../../../../node_modules/rxjs/dist/types/internal/observable/concat.d.ts","../../../../node_modules/rxjs/dist/types/internal/observable/connectable.d.ts","../../../../node_modules/rxjs/dist/types/internal/observable/defer.d.ts","../../../../node_modules/rxjs/dist/types/internal/observable/empty.d.ts","../../../../node_modules/rxjs/dist/types/internal/observable/forkJoin.d.ts","../../../../node_modules/rxjs/dist/types/internal/observable/from.d.ts","../../../../node_modules/rxjs/dist/types/internal/observable/fromEvent.d.ts","../../../../node_modules/rxjs/dist/types/internal/observable/fromEventPattern.d.ts","../../../../node_modules/rxjs/dist/types/internal/observable/generate.d.ts","../../../../node_modules/rxjs/dist/types/internal/observable/iif.d.ts","../../../../node_modules/rxjs/dist/types/internal/observable/interval.d.ts","../../../../node_modules/rxjs/dist/types/internal/observable/merge.d.ts","../../../../node_modules/rxjs/dist/types/internal/observable/never.d.ts","../../../../node_modules/rxjs/dist/types/internal/observable/of.d.ts","../../../../node_modules/rxjs/dist/types/internal/observable/onErrorResumeNext.d.ts","../../../../node_modules/rxjs/dist/types/internal/observable/pairs.d.ts","../../../../node_modules/rxjs/dist/types/internal/observable/partition.d.ts","../../../../node_modules/rxjs/dist/types/internal/observable/race.d.ts","../../../../node_modules/rxjs/dist/types/internal/observable/range.d.ts","../../../../node_modules/rxjs/dist/types/internal/observable/throwError.d.ts","../../../../node_modules/rxjs/dist/types/internal/observable/timer.d.ts","../../../../node_modules/rxjs/dist/types/internal/observable/using.d.ts","../../../../node_modules/rxjs/dist/types/internal/observable/zip.d.ts","../../../../node_modules/rxjs/dist/types/internal/scheduled/scheduled.d.ts","../../../../node_modules/rxjs/dist/types/internal/config.d.ts","../../../../node_modules/rxjs/dist/types/index.d.ts","../../../../node_modules/@angular/core/primitives/event-dispatch/index.d.ts","../../../../node_modules/@angular/core/primitives/signals/index.d.ts","../../../../node_modules/@angular/core/index.d.ts","../../../../node_modules/@angular/common/index.d.ts","../../../../node_modules/@angular/common/http/index.d.ts","../../../../node_modules/@angular/platform-browser/index.d.ts","../../../../src/app/app.config.ngtypecheck.ts","../../../../src/app/app.config.ts","../../../../src/app/app.component.ngtypecheck.ts","../../../../src/app/data.ngtypecheck.ts","../../../../src/app/data.ts","../../../../src/app/options.ngtypecheck.ts","../../../../src/app/options.ts","../../../../src/app/minimal-mode/minimal-mode.component.ngtypecheck.ts","../../../../node_modules/@mindfiredigital/pivothead-angular/dist/types.d.ts","../../../../node_modules/@mindfiredigital/pivothead-angular/dist/pivot-head.component.d.ts","../../../../node_modules/@mindfiredigital/pivothead-angular/dist/pivot-head.directive.d.ts","../../../../node_modules/@mindfiredigital/pivothead-angular/dist/pivot-head.service.d.ts","../../../../node_modules/@mindfiredigital/pivothead-angular/dist/pivot-head.module.d.ts","../../../../node_modules/@mindfiredigital/pivothead-angular/dist/index.d.ts","../../../../src/app/minimal-mode/minimal-mode.component.ts","../../../../src/app/app.component.ts","../../../../src/main.ts","../../../../src/main.server.ngtypecheck.ts","../../../../src/app/app.config.server.ngtypecheck.ts","../../../../node_modules/@angular/animations/index.d.ts","../../../../node_modules/@angular/animations/browser/index.d.ts","../../../../node_modules/@angular/platform-browser/animations/index.d.ts","../../../../node_modules/@angular/platform-server/index.d.ts","../../../../src/app/app.config.server.ts","../../../../src/main.server.ts","../../../../server.ngtypecheck.ts","../../../../node_modules/@angular/ssr/index.d.ts","../../../../node_modules/@types/node/assert.d.ts","../../../../node_modules/@types/node/assert/strict.d.ts","../../../../node_modules/@types/node/globals.d.ts","../../../../node_modules/@types/node/async_hooks.d.ts","../../../../node_modules/@types/node/buffer.d.ts","../../../../node_modules/@types/node/child_process.d.ts","../../../../node_modules/@types/node/cluster.d.ts","../../../../node_modules/@types/node/console.d.ts","../../../../node_modules/@types/node/constants.d.ts","../../../../node_modules/@types/node/crypto.d.ts","../../../../node_modules/@types/node/dgram.d.ts","../../../../node_modules/@types/node/diagnostics_channel.d.ts","../../../../node_modules/@types/node/dns.d.ts","../../../../node_modules/@types/node/dns/promises.d.ts","../../../../node_modules/@types/node/domain.d.ts","../../../../node_modules/@types/node/dom-events.d.ts","../../../../node_modules/@types/node/events.d.ts","../../../../node_modules/@types/node/fs.d.ts","../../../../node_modules/@types/node/fs/promises.d.ts","../../../../node_modules/@types/node/http.d.ts","../../../../node_modules/@types/node/http2.d.ts","../../../../node_modules/@types/node/https.d.ts","../../../../node_modules/@types/node/inspector.d.ts","../../../../node_modules/@types/node/module.d.ts","../../../../node_modules/@types/node/net.d.ts","../../../../node_modules/@types/node/os.d.ts","../../../../node_modules/@types/node/path.d.ts","../../../../node_modules/@types/node/perf_hooks.d.ts","../../../../node_modules/@types/node/process.d.ts","../../../../node_modules/@types/node/punycode.d.ts","../../../../node_modules/@types/node/querystring.d.ts","../../../../node_modules/@types/node/readline.d.ts","../../../../node_modules/@types/node/readline/promises.d.ts","../../../../node_modules/@types/node/repl.d.ts","../../../../node_modules/@types/node/stream.d.ts","../../../../node_modules/@types/node/stream/promises.d.ts","../../../../node_modules/@types/node/stream/consumers.d.ts","../../../../node_modules/@types/node/stream/web.d.ts","../../../../node_modules/@types/node/string_decoder.d.ts","../../../../node_modules/@types/node/test.d.ts","../../../../node_modules/@types/node/timers.d.ts","../../../../node_modules/@types/node/timers/promises.d.ts","../../../../node_modules/@types/node/tls.d.ts","../../../../node_modules/@types/node/trace_events.d.ts","../../../../node_modules/@types/node/tty.d.ts","../../../../node_modules/@types/node/url.d.ts","../../../../node_modules/@types/node/util.d.ts","../../../../node_modules/@types/node/v8.d.ts","../../../../node_modules/@types/node/vm.d.ts","../../../../node_modules/@types/node/wasi.d.ts","../../../../node_modules/@types/node/worker_threads.d.ts","../../../../node_modules/@types/node/zlib.d.ts","../../../../node_modules/@types/node/globals.global.d.ts","../../../../node_modules/@types/node/index.d.ts","../../../../../../node_modules/@types/mime/index.d.ts","../../../../../../node_modules/@types/send/index.d.ts","../../../../../../node_modules/@types/qs/index.d.ts","../../../../../../node_modules/@types/range-parser/index.d.ts","../../../../../../node_modules/@types/express-serve-static-core/index.d.ts","../../../../../../node_modules/@types/http-errors/index.d.ts","../../../../../../node_modules/@types/serve-static/index.d.ts","../../../../../../node_modules/@types/connect/index.d.ts","../../../../../../node_modules/@types/body-parser/index.d.ts","../../../../node_modules/@types/express/index.d.ts","../../../../server.ts"],"fileInfos":[{"version":"44e584d4f6444f58791784f1d530875970993129442a847597db702a073ca68c","affectsGlobalScope":true},"45b7ab580deca34ae9729e97c13cfd999df04416a79116c3bfb483804f85ded4","3facaf05f0c5fc569c5649dd359892c98a85557e3e0c847964caeb67076f4d75","9a68c0c07ae2fa71b44384a839b7b8d81662a236d4b9ac30916718f7510b1b2d","5e1c4c362065a6b95ff952c0eab010f04dcd2c3494e813b493ecfd4fcb9fc0d8","68d73b4a11549f9c0b7d352d10e91e5dca8faa3322bfb77b661839c42b1ddec7","5efce4fc3c29ea84e8928f97adec086e3dc876365e0982cc8479a07954a3efd4","feecb1be483ed332fad555aff858affd90a48ab19ba7272ee084704eb7167569","5514e54f17d6d74ecefedc73c504eadffdeda79c7ea205cf9febead32d45c4bc",{"version":"4af6b0c727b7a2896463d512fafd23634229adf69ac7c00e2ae15a09cb084fad","affectsGlobalScope":true},{"version":"6920e1448680767498a0b77c6a00a8e77d14d62c3da8967b171f1ddffa3c18e4","affectsGlobalScope":true},{"version":"dc2df20b1bcdc8c2d34af4926e2c3ab15ffe1160a63e58b7e09833f616efff44","affectsGlobalScope":true},{"version":"4443e68b35f3332f753eacc66a04ac1d2053b8b035a0e0ac1d455392b5e243b3","affectsGlobalScope":true},{"version":"bc47685641087c015972a3f072480889f0d6c65515f12bd85222f49a98952ed7","affectsGlobalScope":true},{"version":"0dc1e7ceda9b8b9b455c3a2d67b0412feab00bd2f66656cd8850e8831b08b537","affectsGlobalScope":true},{"version":"ce691fb9e5c64efb9547083e4a34091bcbe5bdb41027e310ebba8f7d96a98671","affectsGlobalScope":true},{"version":"8d697a2a929a5fcb38b7a65594020fcef05ec1630804a33748829c5ff53640d0","affectsGlobalScope":true},{"version":"4ff2a353abf8a80ee399af572debb8faab2d33ad38c4b4474cff7f26e7653b8d","affectsGlobalScope":true},{"version":"93495ff27b8746f55d19fcbcdbaccc99fd95f19d057aed1bd2c0cafe1335fbf0","affectsGlobalScope":true},{"version":"6fc23bb8c3965964be8c597310a2878b53a0306edb71d4b5a4dfe760186bcc01","affectsGlobalScope":true},{"version":"ea011c76963fb15ef1cdd7ce6a6808b46322c527de2077b6cfdf23ae6f5f9ec7","affectsGlobalScope":true},{"version":"38f0219c9e23c915ef9790ab1d680440d95419ad264816fa15009a8851e79119","affectsGlobalScope":true},{"version":"bb42a7797d996412ecdc5b2787720de477103a0b2e53058569069a0e2bae6c7e","affectsGlobalScope":true},{"version":"4738f2420687fd85629c9efb470793bb753709c2379e5f85bc1815d875ceadcd","affectsGlobalScope":true},{"version":"2f11ff796926e0832f9ae148008138ad583bd181899ab7dd768a2666700b1893","affectsGlobalScope":true},{"version":"4de680d5bb41c17f7f68e0419412ca23c98d5749dcaaea1896172f06435891fc","affectsGlobalScope":true},{"version":"9fc46429fbe091ac5ad2608c657201eb68b6f1b8341bd6d670047d32ed0a88fa","affectsGlobalScope":true},{"version":"61c37c1de663cf4171e1192466e52c7a382afa58da01b1dc75058f032ddf0839","affectsGlobalScope":true},{"version":"b541a838a13f9234aba650a825393ffc2292dc0fc87681a5d81ef0c96d281e7a","affectsGlobalScope":true},{"version":"9e9fbd7030c440b33d021da145d3232984c8bb7916f277e8ffd3dc2e3eae2bdb","affectsGlobalScope":true},{"version":"811ec78f7fefcabbda4bfa93b3eb67d9ae166ef95f9bff989d964061cbf81a0c","affectsGlobalScope":true},{"version":"717937616a17072082152a2ef351cb51f98802fb4b2fdabd32399843875974ca","affectsGlobalScope":true},{"version":"d7e7d9b7b50e5f22c915b525acc5a49a7a6584cf8f62d0569e557c5cfc4b2ac2","affectsGlobalScope":true},{"version":"71c37f4c9543f31dfced6c7840e068c5a5aacb7b89111a4364b1d5276b852557","affectsGlobalScope":true},{"version":"576711e016cf4f1804676043e6a0a5414252560eb57de9faceee34d79798c850","affectsGlobalScope":true},{"version":"89c1b1281ba7b8a96efc676b11b264de7a8374c5ea1e6617f11880a13fc56dc6","affectsGlobalScope":true},{"version":"74f7fa2d027d5b33eb0471c8e82a6c87216223181ec31247c357a3e8e2fddc5b","affectsGlobalScope":true},{"version":"ae37d6ccd1560b0203ab88d46987393adaaa78c919e51acf32fb82c86502e98c","affectsGlobalScope":true},{"version":"063600664504610fe3e99b717a1223f8b1900087fab0b4cad1496a114744f8df","affectsGlobalScope":true},{"version":"934019d7e3c81950f9a8426d093458b65d5aff2c7c1511233c0fd5b941e608ab","affectsGlobalScope":true},{"version":"bf14a426dbbf1022d11bd08d6b8e709a2e9d246f0c6c1032f3b2edb9a902adbe","affectsGlobalScope":true},{"version":"5e07ed3809d48205d5b985642a59f2eba47c402374a7cf8006b686f79efadcbd","affectsGlobalScope":true},{"version":"2b72d528b2e2fe3c57889ca7baef5e13a56c957b946906d03767c642f386bbc3","affectsGlobalScope":true},{"version":"479553e3779be7d4f68e9f40cdb82d038e5ef7592010100410723ceced22a0f7","affectsGlobalScope":true},{"version":"368af93f74c9c932edd84c58883e736c9e3d53cec1fe24c0b0ff451f529ceab1","affectsGlobalScope":true},{"version":"af3dd424cf267428f30ccfc376f47a2c0114546b55c44d8c0f1d57d841e28d74","affectsGlobalScope":true},{"version":"995c005ab91a498455ea8dfb63aa9f83fa2ea793c3d8aa344be4a1678d06d399","affectsGlobalScope":true},{"version":"d3d7b04b45033f57351c8434f60b6be1ea71a2dfec2d0a0c3c83badbb0e3e693","affectsGlobalScope":true},{"version":"956d27abdea9652e8368ce029bb1e0b9174e9678a273529f426df4b3d90abd60","affectsGlobalScope":true},{"version":"4fa6ed14e98aa80b91f61b9805c653ee82af3502dc21c9da5268d3857772ca05","affectsGlobalScope":true},{"version":"e6633e05da3ff36e6da2ec170d0d03ccf33de50ca4dc6f5aeecb572cedd162fb","affectsGlobalScope":true},{"version":"d8670852241d4c6e03f2b89d67497a4bbefe29ecaa5a444e2c11a9b05e6fccc6","affectsGlobalScope":true},{"version":"8444af78980e3b20b49324f4a16ba35024fef3ee069a0eb67616ea6ca821c47a","affectsGlobalScope":true},{"version":"caccc56c72713969e1cfe5c3d44e5bab151544d9d2b373d7dbe5a1e4166652be","affectsGlobalScope":true},{"version":"3287d9d085fbd618c3971944b65b4be57859f5415f495b33a6adc994edd2f004","affectsGlobalScope":true},{"version":"b4b67b1a91182421f5df999988c690f14d813b9850b40acd06ed44691f6727ad","affectsGlobalScope":true},{"version":"811c71eee4aa0ac5f7adf713323a5c41b0cf6c4e17367a34fbce379e12bbf0a4","affectsGlobalScope":true},{"version":"33358442698bb565130f52ba79bfd3d4d484ac85fe33f3cb1759c54d18201393","affectsGlobalScope":true},{"version":"782dec38049b92d4e85c1585fbea5474a219c6984a35b004963b00beb1aab538","affectsGlobalScope":true},"12f4cfe2fe60b810c3174537bc2ddb20c1067b7768643d12cb1266fd183afb75","ddd578018a259d1c494c834bdd8707769d07d1eb64f87f5217560cd2181b9e93","ecf5cb089ea438f2545e04b6c52828c68d0b0f4bfaa661986faf36da273e9892","95444fb6292d5e2f7050d7021383b719c0252bf5f88854973977db9e3e3d8006","241bd4add06f06f0699dcd58f3b334718d85e3045d9e9d4fa556f11f4d1569c1","06540a9f3f2f88375ada0b89712de1c4310f7398d821c4c10ab5c6477dafb4bc",{"version":"c0ed4fcaf919e6990f53a966d329ef058499696e3d97a8a076dc9254dfe20228","affectsGlobalScope":true},"b8bff8a60af0173430b18d9c3e5c443eaa3c515617210c0c7b3d2e1743c19ecb","97bdf234f5db52085d99c6842db560bca133f8a0413ff76bf830f5f38f088ce3","a76ebdf2579e68e4cfe618269c47e5a12a4e045c2805ed7f7ab37af8daa6b091","b493ff8a5175cbbb4e6e8bcfa9506c08f5a7318b2278365cfca3b397c9710ebc","e59d36b7b6e8ba2dd36d032a5f5c279d2460968c8b4e691ca384f118fb09b52a","e96885c0684c9042ec72a9a43ef977f6b4b4a2728f4b9e737edcbaa0c74e5bf6","303ee143a869e8f605e7b1d12be6c7269d4cab90d230caba792495be595d4f56","89e061244da3fc21b7330f4bd32f47c1813dd4d7f1dc3d0883d88943f035b993","e46558c2e04d06207b080138678020448e7fc201f3d69c2601b0d1456105f29a","71549375db52b1163411dba383b5f4618bdf35dc57fa327a1c7d135cf9bf67d1","7e6b2d61d6215a4e82ea75bc31a80ebb8ad0c2b37a60c10c70dd671e8d9d6d5d","78bea05df2896083cca28ed75784dde46d4b194984e8fc559123b56873580a23","5dd04ced37b7ea09f29d277db11f160df7fd73ba8b9dba86cb25552e0653a637","f74b81712e06605677ae1f061600201c425430151f95b5ef4d04387ad7617e6a","9a72847fcf4ac937e352d40810f7b7aec7422d9178451148296cf1aa19467620","3ae18f60e0b96fa1e025059b7d25b3247ba4dcb5f4372f6d6e67ce2adac74eac","2b9260f44a2e071450ae82c110f5dc8f330c9e5c3e85567ed97248330f2bf639","4f196e13684186bda6f5115fc4677a87cf84a0c9c4fc17b8f51e0984f3697b6d","61419f2c5822b28c1ea483258437c1faab87d00c6f84481aa22afb3380d8e9a4","64479aee03812264e421c0bf5104a953ca7b02740ba80090aead1330d0effe91","a5eb4835ab561c140ffc4634bb039387d5d0cceebb86918f1696c7ac156d26fd","c5570e504be103e255d80c60b56c367bf45d502ca52ee35c55dec882f6563b5c","4252b852dd791305da39f6e1242694c2e560d5e46f9bb26e2aca77252057c026","0520b5093712c10c6ef23b5fea2f833bf5481771977112500045e5ea7e8e2b69","5c3cf26654cf762ac4d7fd7b83f09acfe08eef88d2d6983b9a5a423cb4004ca3","e60fa19cf7911c1623b891155d7eb6b7e844e9afdf5738e3b46f3b687730a2bd","b1fd72ff2bb0ba91bb588f3e5329f8fc884eb859794f1c4657a2bfa122ae54d0","6cf42a4f3cfec648545925d43afaa8bb364ac10a839ffed88249da109361b275","ba13c7d46a560f3d4df8ffb1110e2bbec5801449af3b1240a718514b5576156e","6df52b70d7f7702202f672541a5f4a424d478ee5be51a9d37b8ccbe1dbf3c0f2","0ca7f997e9a4d8985e842b7c882e521b6f63233c4086e9fe79dd7a9dc4742b5e","ebc8936ed464874fcceb0ded3b8728695aa356a21890238e9076887ec0722a54","db5704fdad56c74dfc5941283c1182ed471bd17598209d3ac4a49faa72e43cfc","758e8e89559b02b81bc0f8fd395b17ad5aff75490c862cbe369bb1a3d1577c40","2ee64342c077b1868f1834c063f575063051edd6e2964257d34aad032d6b657c","6f6b4b3d670b6a5f0e24ea001c1b3d36453c539195e875687950a178f1730fa7","05c4e2a992bb83066a3a648bad1c310cecd4d0628d7e19545bb107ac9596103a","b48b83a86dd9cfe36f8776b3ff52fcd45b0e043c0538dc4a4b149ba45fe367b9","792de5c062444bd2ee0413fb766e57e03cce7cdaebbfc52fc0c7c8e95069c96b","a79e3e81094c7a04a885bad9b049c519aace53300fb8a0fe4f26727cb5a746ce","dd6c3362aaaec60be028b4ba292806da8e7020eef7255c7414ce4a5c3a7138ef","8a4e89564d8ea66ad87ee3762e07540f9f0656a62043c910d819b4746fc429c5","b9011d99942889a0f95e120d06b698c628b0b6fdc3e6b7ecb459b97ed7d5bcc6","4d639cbbcc2f8f9ce6d55d5d503830d6c2556251df332dc5255d75af53c8a0e7","cdb48277f600ab5f429ecf1c5ea046683bc6b9f73f3deab9a100adac4b34969c","75be84956a29040a1afbe864c0a7a369dfdb739380072484eff153905ef867ee","b06b4adc2ae03331a92abd1b19af8eb91ec2bf8541747ee355887a167d53145e","3114b315cd0687aad8b57cff36f9c8c51f5b1bc6254f1b1e8446ae583d8e2474","0d417c15c5c635384d5f1819cc253a540fe786cc3fda32f6a2ae266671506a21","af733cb878419f3012f0d4df36f918a69ba38d73f3232ba1ab46ef9ede6cb29c","cb59317243a11379a101eb2f27b9df1022674c3df1df0727360a0a3f963f523b","0a01b0b5a9e87d04737084731212106add30f63ec640169f1462ba2e44b6b3a8","06b8a7d46195b6b3980e523ef59746702fd210b71681a83a5cf73799623621f9","860e4405959f646c101b8005a191298b2381af8f33716dc5f42097e4620608f8","f7e32adf714b8f25d3c1783473abec3f2e82d5724538d8dcf6f51baaaff1ca7a","e07d62a8a9a3bb65433a62e9bbf400c6bfd2df4de60652af4d738303ee3670a1","bfbf80f9cd4558af2d7b2006065340aaaced15947d590045253ded50aabb9bc5","851e8d57d6dd17c71e9fa0319abd20ab2feb3fb674d0801611a09b7a25fd281c","c3bd2b94e4298f81743d92945b80e9b56c1cdfb2bef43c149b7106a2491b1fc9","a246cce57f558f9ebaffd55c1e5673da44ea603b4da3b2b47eb88915d30a9181","d993eacc103c5a065227153c9aae8acea3a4322fe1a169ee7c70b77015bf0bb2","fc2b03d0c042aa1627406e753a26a1eaad01b3c496510a78016822ef8d456bb6","063c7ebbe756f0155a8b453f410ca6b76ffa1bbc1048735bcaf9c7c81a1ce35f","748e79252a7f476f8f28923612d7696b214e270cc909bc685afefaac8f052af0","9669075ac38ce36b638b290ba468233980d9f38bdc62f0519213b2fd3e2552ec","4d123de012c24e2f373925100be73d50517ac490f9ed3578ac82d0168bfbd303","656c9af789629aa36b39092bee3757034009620439d9a39912f587538033ce28","3ac3f4bdb8c0905d4c3035d6f7fb20118c21e8a17bee46d3735195b0c2a9f39f","1f453e6798ed29c86f703e9b41662640d4f2e61337007f27ac1c616f20093f69","af43b7871ff21c62bf1a54ec5c488e31a8d3408d5b51ff2e9f8581b6c55f2fc7","70550511d25cbb0b6a64dcac7fffc3c1397fd4cbeb6b23ccc7f9b794ab8a6954","af0fbf08386603a62f2a78c42d998c90353b1f1d22e05a384545f7accf881e0a","c3f32a185cd27ac232d3428a8d9b362c3f7b4892a58adaaa022828a7dcd13eed","3139c3e5e09251feec7a87f457084bee383717f3626a7f1459d053db2f34eb76","4888fd2bcfee9a0ce89d0df860d233e0cee8ee9c479b6bd5a5d5f9aae98342fe","3be870c8e17ec14f1c18fc248f5d2c4669e576404744ff5c63e6dafcf05b97ea","56654d2c5923598384e71cb808fac2818ca3f07dd23bb018988a39d5e64f268b","8b6719d3b9e65863da5390cb26994602c10a315aa16e7d70778a63fee6c4c079","6ab380571d87bd1d6f644fb6ab7837239d54b59f07dc84347b1341f866194214","547d3c406a21b30e2b78629ecc0b2ddaf652d9e0bdb2d59ceebce5612906df33","b3a4f9385279443c3a5568ec914a9492b59a723386161fd5ef0619d9f8982f97","3fe66aba4fbe0c3ba196a4f9ed2a776fe99dc4d1567a558fb11693e9fcc4e6ed","140eef237c7db06fc5adcb5df434ee21e81ee3a6fd57e1a75b8b3750aa2df2d8","0944ec553e4744efae790c68807a461720cff9f3977d4911ac0d918a17c9dd99","7c9ed7ffdc6f843ab69e5b2a3e7f667b050dd8d24d0052db81e35480f6d4e15d","7c7d9e116fe51100ff766703e6b5e4424f51ad8977fe474ddd8d0959aa6de257","af70a2567e586be0083df3938b6a6792e6821363d8ef559ad8d721a33a5bcdaf","006cff3a8bcb92d77953f49a94cd7d5272fef4ab488b9052ef82b6a1260d870b","7d44bfdc8ee5e9af70738ff652c622ae3ad81815e63ab49bdc593d34cb3a68e5","339814517abd4dbc7b5f013dfd3b5e37ef0ea914a8bbe65413ecffd668792bc6","34d5bc0a6958967ec237c99f980155b5145b76e6eb927c9ffc57d8680326b5d8","9eae79b70c9d8288032cbe1b21d0941f6bd4f315e14786b2c1d10bccc634e897","18ce015ed308ea469b13b17f99ce53bbb97975855b2a09b86c052eefa4aa013a","5a931bc4106194e474be141e0bc1046629510dc95b9a0e4b02a3783847222965","5e5f371bf23d5ced2212a5ff56675aefbd0c9b3f4d4fdda1b6123ac6e28f058c","907c17ad5a05eecb29b42b36cc8fec6437be27cc4986bb3a218e4f74f606911c","3656f0584d5a7ee0d0f2cc2b9cffbb43af92e80186b2ce160ebd4421d1506655","a726ad2d0a98bfffbe8bc1cd2d90b6d831638c0adc750ce73103a471eb9a891c","ce871684a7cb81d6a89630e0c6b4a064f876f7ec1d352917ace027b3fc3e537f","354582b26ecec449c94c71f76227102aad8a3aa7a113810a6b932c2421ddc050","42f8ed746d486725017ead628c6589fe13d6d6f5fa1517f978b3ccfcd7b46860","b03aa292cfdcd4edc3af00a7dbd71136dd067ec70a7536b655b82f4dd444e857","90f690a1c5fcb4c2d19c80fea05c8ab590d8f6534c4c296d70af6293ede67366","be95e987818530082c43909be722a838315a0fc5deb6043de0a76f5221cbad24","9ed5b799c50467b0c9f81ddf544b6bcda3e34d92076d6cab183c84511e45c39f","b4fa87cc1833839e51c49f20de71230e259c15b2c9c3e89e4814acc1d1ef10de","e90ac9e4ac0326faa1bc39f37af38ace0f9d4a655cd6d147713c653139cf4928","ea27110249d12e072956473a86fd1965df8e1be985f3b686b4e277afefdde584","1f6058d60eaa8825f59d4b76bbf6cc0e6ad9770948be58de68587b0931da00cc","5666075052877fe2fdddd5b16de03168076cf0f03fbca5c1d4a3b8f43cba570c","50100b1a91f61d81ca3329a98e64b7f05cddc5e3cb26b3411adc137c9c631aca","11aceaee5663b4ed597544567d6e6a5a94b66857d7ebd62a9875ea061018cd2c","6e30d0b5a1441d831d19fe02300ab3d83726abd5141cbcc0e2993fa0efd33db4","423f28126b2fc8d8d6fa558035309000a1297ed24473c595b7dec52e5c7ebae5","fb30734f82083d4790775dae393cd004924ebcbfde49849d9430bf0f0229dd16","2c92b04a7a4a1cd9501e1be338bf435738964130fb2ad5bd6c339ee41224ac4c","94ff6974e4afe28061d44732ecb889bb2296cf98c52022e8ebaf99ba8e9e5d62","669b754ec246dd7471e19b655b73bda6c2ca5bb7ccb1a4dff44a9ae45b6a716a","4bb6035e906946163ecfaec982389d0247ceeac6bdee7f1d07c03d9c224db3aa","8a44b424edee7bb17dc35a558cc15f92555f14a0441205613e0e50452ab3a602","24a00d0f98b799e6f628373249ece352b328089c3383b5606214357e9107e7d5","33637e3bc64edd2075d4071c55d60b32bdb0d243652977c66c964021b6fc8066","0f0ad9f14dedfdca37260931fac1edf0f6b951c629e84027255512f06a6ebc4c","16ad86c48bf950f5a480dc812b64225ca4a071827d3d18ffc5ec1ae176399e36","8cbf55a11ff59fd2b8e39a4aa08e25c5ddce46e3af0ed71fb51610607a13c505","d5bc4544938741f5daf8f3a339bfbf0d880da9e89e79f44a6383aaf056fe0159","c82857a876075e665bbcc78213abfe9e9b0206d502379576d7abd481ade3a569","4f71d883ed6f398ba8fe11fcd003b44bb5f220f840b3eac3c395ad91304e4620","5229c3934f58413f34f1b26c01323c93a5a65a2d9f2a565f216590dfbed1fe32","9fd7466b77020847dbc9d2165829796bf7ea00895b2520ff3752ffdcff53564b","fbfc12d54a4488c2eb166ed63bab0fb34413e97069af273210cf39da5280c8d6","85a84240002b7cf577cec637167f0383409d086e3c4443852ca248fc6e16711e","4c754b03f36ff35fc539f9ebb5f024adbb73ec2d3e4bfb35b385a05abb36a50e","59507446213e73654d6979f3b82dadc4efb0ed177425ae052d96a3f5a5be0d35","a914be97ca7a5be670d1545fc0691ac3fbabd023d7d084b338f6934349798a1f","8f62cbd3afbd6a07bb8c934294b6bfbe437021b89e53a4da7de2648ecfc7af25","62c3621d34fb2567c17a2c4b89914ebefbfbd1b1b875b070391a7d4f722e55dc","c05ac811542e0b59cb9c2e8f60e983461f0b0e39cea93e320fad447ff8e474f3","8e7a5b8f867b99cc8763c0b024068fb58e09f7da2c4810c12833e1ca6eb11c4f","132351cbd8437a463757d3510258d0fa98fd3ebef336f56d6f359cf3e177a3ce","df877050b04c29b9f8409aa10278d586825f511f0841d1ec41b6554f8362092b","33d1888c3c27d3180b7fd20bac84e97ecad94b49830d5dd306f9e770213027d1","ee942c58036a0de88505ffd7c129f86125b783888288c2389330168677d6347f","a3f317d500c30ea56d41501632cdcc376dae6d24770563a5e59c039e1c2a08ec","eb21ddc3a8136a12e69176531197def71dc28ffaf357b74d4bf83407bd845991","0c1651a159995dfa784c57b4ea9944f16bdf8d924ed2d8b3db5c25d25749a343","aaa13958e03409d72e179b5d7f6ec5c6cc666b7be14773ae7b6b5ee4921e52db","0a86e049843ad02977a94bb9cdfec287a6c5a0a4b6b5391a6648b1a122072c5a","87437ca9dabab3a41d483441696ff9220a19e713f58e0b6a99f1731af10776d7","26c5dfa9aa4e6428f4bb7d14cbf72917ace69f738fa92480b9749eebce933370","8e94328e7ca1a7a517d1aa3c569eac0f6a44f67473f6e22c2c4aff5f9f4a9b38","d604d413aff031f4bfbdae1560e54ebf503d374464d76d50a2c6ded4df525712","299f0af797897d77685d606502be72846b3d1f0dc6a2d8c964e9ea3ccbacf5bc","12bfd290936824373edda13f48a4094adee93239b9a73432db603127881a300d","340ceb3ea308f8e98264988a663640e567c553b8d6dc7d5e43a8f3b64f780374","c5a769564e530fba3ec696d0a5cff1709b9095a0bdf5b0826d940d2fc9786413","7124ef724c3fc833a17896f2d994c368230a8d4b235baed39aa8037db31de54f","5de1c0759a76e7710f76899dcae601386424eab11fb2efaf190f2b0f09c3d3d3","9c5ee8f7e581f045b6be979f062a61bf076d362bf89c7f966b993a23424e8b0d","1a11df987948a86aa1ec4867907c59bdf431f13ed2270444bf47f788a5c7f92d","3c97b5ea66276cf463525a6aa9d5bb086bf5e05beac70a0597cda2575503b57b","b756781cd40d465da57d1fc6a442c34ae61fe8c802d752aace24f6a43fedacee","0fe76167c87289ea094e01616dcbab795c11b56bad23e1ef8aba9aa37e93432a","3a45029dba46b1f091e8dc4d784e7be970e209cd7d4ff02bd15270a98a9ba24b","032c1581f921f8874cf42966f27fd04afcabbb7878fa708a8251cac5415a2a06","69c68ed9652842ce4b8e495d63d2cd425862104c9fb7661f72e7aa8a9ef836f8","a31383256374723b47d8b5497a9558bbbcf95bcecfb586a36caf7bfd3693eb0e","06f62a14599a68bcde148d1efd60c2e52e8fa540cc7dcfa4477af132bb3de271","64aa66c7458cbfd0f48f88070b08c2f66ae94aba099dac981f17c2322d147c06","11f19ce32d21222419cecab448fa335017ebebf4f9e5457c4fa9df42fa2dcca7","2e8ee2cbb5e9159764e2189cf5547aebd0e6b0d9a64d479397bb051cd1991744","1b0471d75f5adb7f545c1a97c02a0f825851b95fe6e069ac6ecaa461b8bb321d","1d157c31a02b1e5cca9bc495b3d8d39f4b42b409da79f863fb953fbe3c7d4884","07baaceaec03d88a4b78cb0651b25f1ae0322ac1aa0b555ae3749a79a41cba86","619a132f634b4ebe5b4b4179ea5870f62f2cb09916a25957bff17b408de8b56d","f60fa446a397eb1aead9c4e568faf2df8068b4d0306ebc075fb4be16ed26b741","f3cb784be4d9e91f966a0b5052a098d9b53b0af0d341f690585b0cc05c6ca412","350f63439f8fe2e06c97368ddc7fb6d6c676d54f59520966f7dbbe6a4586014e","eba613b9b357ac8c50a925fa31dc7e65ff3b95a07efbaa684b624f143d8d34ba","9814545517193cf51127d7fbdc3b7335688206ec04ee3a46bba2ee036bd0dcac","0f6199602df09bdb12b95b5434f5d7474b1490d2cd8cc036364ab3ba6fd24263","c8ca7fd9ec7a3ec82185bfc8213e4a7f63ae748fd6fced931741d23ef4ea3c0f","5c6a8a3c2a8d059f0592d4eab59b062210a1c871117968b10797dee36d991ef7","7acee2009eb9f4c6b17245edc555c7d5c9404343ea1b0cf8adae3b66292c1527","4bdd3ba9fd67c1fc87d151e9b2117a007b0da212b592eeaebd93f493eec2d02b","898019b62d0e37381efeef5203e3a7ffc8dfe81ea64ddc5ad170cd4785c2dd62","c87a6faa28497adefc814beded5fe87cd77de361b8183cca3fa4481782f5bf15","160398542929c6a4040ec9b42eae8a6666c85d597e79c6da2f46058a7f3c5e5f","a90f12b29e52208f6d29a5123e5b3c281e1942d88c350db7a1a3a820e6e48b83","e81e95b4460c337769dbaea3e8ec5eb9226d71f389d2dfec7bb0f7f66e200699","ddd578018a259d1c494c834bdd8707769d07d1eb64f87f5217560cd2181b9e93","9600c2ff6a955ddb67330116fa8a59e3f391691bbda84d7380a72c97056b9420",{"version":"ddd578018a259d1c494c834bdd8707769d07d1eb64f87f5217560cd2181b9e93","signature":"da14a67372982ca6e605fea114900b492b3316618581634e0ce72afbcb09baca"},"ddd578018a259d1c494c834bdd8707769d07d1eb64f87f5217560cd2181b9e93","b1d6944584f80fc85083e038f6216b388997161d1c29158f6887416e36a51e8e","ddd578018a259d1c494c834bdd8707769d07d1eb64f87f5217560cd2181b9e93","53b47f56da9769b8d54b9b667ee5d5ea8212ad6b1c877763711465f4b6508343",{"version":"ddd578018a259d1c494c834bdd8707769d07d1eb64f87f5217560cd2181b9e93","signature":"da14a67372982ca6e605fea114900b492b3316618581634e0ce72afbcb09baca"},"7f1cfc92e8896e7e5e39daef120a2df1f5b90144e7b31e005480bc813f35358b","d7066762974bcf1acc956914918235abce8e12720c03acae729a6834cc79ee50","2dbe59c128e6e19d0bb2ac04a5516ef77a2e89decae9fee5e8cdfe8615dd1b19","84c4cb51a1f0ec5e4b0007781b6c41f7496bbe3d241bd805e1201b30bece62dd","3b7ca7a85a7c2e45c202c518404b06b6b70b15eceb10504cf0ff856bc79c4a3c","378160f52d5cdbec6df67b83316883ace4918878fec525980bad33b32ad4a45c","b6cd011f8209dd27e9071f209923c2e7288e6c34d095d81bc5f268277a460343","31514a58bd1e824147335e994eaa95f67b447a57ff653b4b8d4b59be55c1d594","98f31b67b543962dfae3f3e55e5fbd56c77d1bc6835a5c317dd92fa7d4a022c8","ddd578018a259d1c494c834bdd8707769d07d1eb64f87f5217560cd2181b9e93","ddd578018a259d1c494c834bdd8707769d07d1eb64f87f5217560cd2181b9e93","9c7535de172de7504db86ce34deec12dd9eed370b9ae1b2b0d6ab513bdd1ab7c","4fb4eb300d75606b60fa437d8ff6ac92aa24678b938d3b0aaa99c19fb152f413","62604560c0ec59b6c7e4c735d03903d371507bd9d8e1ae697956f764ba6752ac","b8932dc425ed0310b26b0a6b400a34a0a215fbf719be319dfa872c13aa3c32a0","187f8eb60ad38d6154426da013f33ee48e8bf82b86d77dd2368970b8106bc8f0","185b2a171da126f5c6c53ce0812588d3ba46575eeba352368c5414b6e5c0f1de","ddd578018a259d1c494c834bdd8707769d07d1eb64f87f5217560cd2181b9e93","955133b47df2272da61dbb50fda84b0e0732d96f5614a373718719b4bc429641","9004b6757fde33f153c3a7694c15b017531a0261fafb99e0542a8a6f61be1708","7394959e5a741b185456e1ef5d64599c36c60a323207450991e7a42e08911419",{"version":"32465ea19404cb188e84cf08c6b1f6b12d739140436402cdbc184a3fd20a7d81","affectsGlobalScope":true},"39b1a50d543770780b0409a4caacb87f3ff1d510aedfeb7dc06ed44188256f89",{"version":"da5afd11bfce6e59d63f28fcf1ce25cd099188de33c08f9fad297186713fb17c","affectsGlobalScope":true},"1f2d8573577ad731813e4358b913b667923a94e6456f645918fba11134040d13","fe39ceafa361b6d339b518936275eff89a77e7dfe92f2efa5fb97abf9a95ca49",{"version":"815c751d4afee4651d61edf6204187372a55ca8e0126a906986b4859ec51f192","affectsGlobalScope":true},"a40826e8476694e90da94aa008283a7de50d1dafd37beada623863f1901cb7fb","8a67dc9edddace374b1a96852ab5bbb87b631d439a928e6df326587d1f4fe9f0","fbcf2c3cde728761b05dbf8e7a9b8be1f5514dc324c6f83b87ba5c0668119b98","7eb0662b995994db248290a0f0a1d8ed685991a162ff9eb4dee36f099cccd0d9","16bbaee4dd96ec8b67026329a4f5fdef6313e42a5c305ddeb498c3d65fb557b8","37a36483218b24a50be2548a71557603e01ce38154c9f3f635c6c8275abd9fb1","c6cf9428f45f3d78b07df7d7aab1569994c177d36549e3a962f952d89f026bc4",{"version":"2c71199d1fc83bf17636ad5bf63a945633406b7b94887612bba4ef027c662b3e","affectsGlobalScope":true},{"version":"d30c9292ff36b2af594109d4413f34b952b1258c50b0361a3db1f7d94ec1e193","affectsGlobalScope":true},"d617229425b25df2046a9c1e321dd1b50825abc8e3b38048453345483f8601e1","badd4f5fe0cca51915ef597852d07598ca490f6d1d9d68d505a159f18cde792d","4b846e4951415068e2cf1bdb8bfb8d6373b2815ba72b1986c95bac3aec37bca7","e6d2e297c73016fc98095238b25428591d129481c50eb1b6e575d35f3f8c621e","e3baa0c5780c2c805ec33a999722a2f740b572eb3746fd0a5f93a0a5c3dbf7f6","7e5307e29dfd5d5b827203b85cb665d8d5bf932a6c6f393457da8e9ed1906761",{"version":"e492737de7f023b47ff14ca54b9635ba3dcd64816ed3316c9f3a784cf5897173","affectsGlobalScope":true},"40798238bc2e17ee787a815dbce4f2c89c161e5ad2fde062fb50454c093fa433","30b15efd2b52c7e5f0f7c1e360afc43f487a2cffad5c01756f06eb323eee3efd","323506ce173f7f865f42f493885ee3dacd18db6359ea1141d57676d3781ce10c",{"version":"e7391fb34deecd321ae15af659cbfb0b9abc995c5ed4b3d703ba768e44b89670","affectsGlobalScope":true},{"version":"0900d10c17bae29648b266c0ae7cef0c95ebb2a1d81541b833833ed0996ac85a","affectsGlobalScope":true},"58520d6ae3a339cd22ffc528b50b21e4e8f5247a87913eb1c697c1af62eb0395","186614c0f9ca0ec3cfa988f1dc01c6f392a798710072ff4bdf20ce56e09a6dfd","2de7a21c92226fb8abbeed7a0a9bd8aa6d37e4c68a8c7ff7938c644267e9fcc1","6d6070c5c81ba0bfe58988c69e3ba3149fc86421fd383f253aeb071cbf29cd41","48dab0d6e633b8052e7eaa0efb0bb3d58a733777b248765eafcb0b0349439834","6e4b2642721462bf62d19593770659f268a6ca1e9fd15543747efb3ac471cee3","269929a24b2816343a178008ac9ae9248304d92a8ba8e233055e0ed6dbe6ef71","8258e69a3b0de494ea55eeea7a4d3216ac112c12006c74dfd381c0d5e42a2607","cdaaf046791d7d588f28f32197c5d6acc43343e62540a67eed194c9c20535fdc","4b1ff655bd8edd879dd4f04f15338ce0109f58ccb424165d44fa07e7ea39c4bf",{"version":"6fa3d3f427475a5d21fed826d6457e7f9ee3a0abeb3124fc41f385f112368d2e","affectsGlobalScope":true},{"version":"b85e57e102a1df14980b46d745c9fe8e16a9b0a69a98fb1a2c558c9137ab30d6","affectsGlobalScope":true},"4e228e78c1e9b0a75c70588d59288f63a6258e8b1fe4a67b0c53fe03461421d9","e5ce801ce5e85d7281807d8a65a21ee9767c122c87da262891582b4afead5ec0","76a89af04f2ba1807309320dab5169c0d1243b80738b4a2005989e40a136733e","c045b664abf3fc2a4750fa96117ab2735e4ed45ddd571b2a6a91b9917e231a02",{"version":"057d7f56aacd575a6240838d2684d34a340acde815f84190ea5e9afd611aeee6","affectsGlobalScope":true},{"version":"40ed27386f21a739bd0d2e2cfed563760588f2aeaa7ad149c1bf1454a7ec743a","affectsGlobalScope":true},"d1ef1d8516286380fd0a6f498f1650d374a8cb5f03d91633b6124e4fb8fb131d","6244a29671c12a54fc5b1393dde60bac655bd778d84758a4db847f684d4da3a5","8bc733ffd630d49d495663bfecf590281c8f5412b33657430ab471b558206705",{"version":"171c1840775746917e7b813c9df0fc0b84876f96623a6cfef3b3de7ea816b8c5","affectsGlobalScope":true},"f2b9440f98d6f94c8105883a2b65aee2fce0248f71f41beafd0a80636f3a565d",{"version":"ab9b9a36e5284fd8d3bf2f7d5fcbc60052f25f27e4d20954782099282c60d23e","affectsGlobalScope":true},"872201e32a629152e8bc7118e8977ac37a1a62ab6756c2ac3e6b53859f0a8fa1","d3f2d715f57df3f04bf7b16dde01dec10366f64fce44503c92b8f78f614c1769","b78cd10245a90e27e62d0558564f5d9a16576294eee724a59ae21b91f9269e4a","baac9896d29bcc55391d769e408ff400d61273d832dd500f21de766205255acb","2f5747b1508ccf83fad0c251ba1e5da2f5a30b78b09ffa1cfaf633045160afed",{"version":"a45c25e77c911c1f2a04cade78f6f42b4d7d896a3882d4e226efd3a3fcd5f2c4","affectsGlobalScope":true},"b71c603a539078a5e3a039b20f2b0a0d1708967530cf97dec8850a9ca45baa2b","0e13570a7e86c6d83dd92e81758a930f63747483e2cd34ef36fcdb47d1f9726a","104c67f0da1bdf0d94865419247e20eded83ce7f9911a1aa75fc675c077ca66e","cc0d0b339f31ce0ab3b7a5b714d8e578ce698f1e13d7f8c60bfb766baeb1d35c","43cdd474c5aa3340da4816bb8f1ae7f3b1bcf9e70d997afc36a0f2c432378c84","577f7bc87c16bd10bac499e228ef24d23dc4dd516e469b5db3eefae4edcf6345"],"root":[61,273,274,281,282,348],"options":{"declaration":false,"declarationMap":false,"esModuleInterop":true,"experimentalDecorators":true,"importHelpers":true,"inlineSourceMap":true,"inlineSources":true,"module":7,"noEmitOnError":false,"noFallthroughCasesInSwitch":true,"noImplicitOverride":true,"noImplicitReturns":true,"noPropertyAccessFromIndexSignature":true,"outDir":"../../../..","skipLibCheck":true,"strict":true,"target":9,"tsBuildInfoFile":"./.tsbuildinfo"},"fileIdsList":[[253,276,330],[253,330],[250,253,254,330],[250,253,330],[250,251,252,253,330],[330],[253,256,277,330],[253,254,255,330],[253,255,256,278,330],[265,266,267,268,269,330],[253,265,330],[253,254,266,267,330],[265,330],[330,340,342,344,346],[284,330],[287,330],[288,293,321,330],[289,300,301,308,318,329,330],[289,290,300,308,330],[291,330],[292,293,301,309,330],[293,318,326,330],[294,296,300,308,330],[295,330],[296,297,330],[300,330],[298,300,330],[300,301,302,318,329,330],[300,301,302,315,318,321,330],[330,334],[296,300,303,308,318,329,330],[300,301,303,304,308,318,326,329,330],[303,305,318,326,329,330],[284,285,286,287,288,289,290,291,292,293,294,295,296,297,298,299,300,301,302,303,304,305,306,307,308,309,310,311,312,313,314,315,316,317,318,319,320,321,322,323,324,325,326,327,328,329,330,331,332,333,334,335,336],[300,306,330],[307,329,330,334],[296,300,308,318,330],[309,330],[310,330],[287,311,330],[312,328,330,334],[313,330],[314,330],[300,315,316,330],[315,317,330,332],[288,300,318,319,320,321,330],[288,318,320,330],[318,319,330],[321,330],[322,330],[287,318,330],[300,324,325,330],[324,325,330],[293,308,318,326,330],[327,330],[308,328,330],[288,303,314,329,330],[293,330],[318,330,331],[307,330,332],[330,333],[288,293,300,302,311,318,329,330,332,334],[318,330,335],[62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,78,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,116,118,119,120,121,122,123,124,125,126,127,128,129,131,132,133,134,135,137,138,139,140,141,142,143,144,145,146,147,148,149,150,151,152,153,154,155,156,157,158,159,160,161,162,163,164,165,166,167,168,169,170,171,172,173,174,175,176,177,178,179,181,182,183,185,194,196,197,198,199,200,201,203,204,206,208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,224,225,226,227,228,229,230,231,232,233,234,235,236,237,238,239,240,241,242,243,244,245,246,247,248,249,330],[107,330],[65,66,330],[62,63,64,66,330],[63,66,330],[66,107,330],[62,66,184,330],[64,65,66,330],[62,66,330],[66,330],[65,330],[62,65,107,330],[63,65,66,223,330],[65,66,223,330],[65,231,330],[63,65,66,330],[75,330],[98,330],[119,330],[65,66,107,330],[66,114,330],[65,66,107,125,330],[65,66,125,330],[66,166,330],[62,66,185,330],[191,193,330],[62,66,184,191,192,330],[184,185,193,330],[191,330],[62,66,191,192,193,330],[207,330],[202,330],[205,330],[63,65,185,186,187,188,330],[107,185,186,187,188,330],[185,187,330],[65,186,187,189,190,194,330],[62,65,330],[66,209,330],[67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,100,101,102,103,104,105,106,108,109,110,111,112,113,115,116,117,118,119,120,121,122,123,124,126,127,128,129,130,131,132,133,134,135,136,137,138,139,140,141,142,143,144,145,146,147,148,149,150,151,152,153,154,155,156,157,158,159,160,161,162,163,164,165,166,167,168,169,170,171,172,173,174,175,176,177,178,179,180,181,182,330],[195,330],[60,330],[60,254,281,282,283,310,329,330,347],[60,253,254,259,261,263,270,271,330],[60,253,258,275,279,330],[60,253,257,330],[60,260,330],[60,253,254,261,263,264,270,330],[60,262,330],[60,256,272,274,280,330],[60,61,256,258,272,330],[303,330,337,345],[303,330,337],[300,303,330,337,339,340,341],[301,318,330,337,338],[303,330,337,339,343]],"referencedMap":[[277,1],[276,2],[255,3],[254,4],[253,5],[251,6],[252,6],[278,7],[256,8],[279,9],[283,2],[270,10],[266,11],[267,11],[269,12],[268,13],[265,6],[347,14],[284,15],[285,15],[287,16],[288,17],[289,18],[290,19],[291,20],[292,21],[293,22],[294,23],[295,24],[296,25],[297,25],[299,26],[298,27],[300,26],[301,28],[302,29],[286,30],[336,6],[303,31],[304,32],[305,33],[337,34],[306,35],[307,36],[308,37],[309,38],[310,39],[311,40],[312,41],[313,42],[314,43],[315,44],[316,44],[317,45],[318,46],[320,47],[319,48],[321,49],[322,50],[323,51],[324,52],[325,53],[326,54],[327,55],[328,56],[329,57],[330,58],[331,59],[332,60],[333,61],[334,62],[335,63],[250,64],[223,6],[201,65],[199,65],[114,66],[65,67],[64,68],[200,69],[185,70],[107,71],[63,72],[62,73],[249,68],[214,74],[213,74],[125,75],[221,66],[222,66],[224,76],[225,66],[226,73],[227,66],[198,66],[228,66],[229,77],[230,66],[231,74],[232,78],[233,66],[234,66],[235,66],[236,66],[237,74],[238,66],[239,66],[240,66],[241,66],[242,79],[243,66],[244,66],[245,66],[246,66],[247,66],[67,73],[68,73],[69,73],[70,73],[71,73],[72,73],[73,73],[74,66],[76,80],[77,73],[75,73],[78,73],[79,73],[80,73],[81,73],[82,73],[83,73],[84,66],[85,73],[86,73],[87,73],[88,73],[89,73],[90,66],[91,73],[92,73],[93,73],[94,73],[95,73],[96,73],[97,66],[99,81],[98,73],[100,73],[101,73],[102,73],[103,73],[104,79],[105,66],[106,66],[120,82],[108,83],[109,73],[110,73],[111,66],[112,73],[113,73],[115,84],[116,73],[117,73],[118,73],[119,73],[121,73],[122,73],[123,73],[124,73],[126,85],[127,73],[128,73],[129,73],[130,66],[131,73],[132,86],[133,86],[134,86],[135,66],[136,73],[137,73],[138,73],[143,73],[139,73],[140,66],[141,73],[142,66],[144,73],[145,73],[146,73],[147,73],[148,73],[149,73],[150,66],[151,73],[152,73],[153,73],[154,73],[155,73],[156,73],[157,73],[158,73],[159,73],[160,73],[161,73],[162,73],[163,73],[164,73],[165,73],[166,73],[167,87],[168,73],[169,73],[170,73],[171,73],[172,73],[173,73],[174,66],[175,66],[176,66],[177,66],[178,66],[179,73],[180,73],[181,73],[182,73],[248,66],[184,88],[207,89],[202,89],[193,90],[191,91],[205,92],[194,93],[208,94],[203,95],[204,92],[206,96],[192,6],[197,6],[189,97],[190,98],[187,6],[188,99],[186,73],[195,100],[66,101],[215,6],[216,6],[217,6],[218,6],[219,6],[220,6],[209,6],[212,74],[211,6],[210,102],[183,103],[196,104],[60,6],[282,105],[348,106],[259,105],[272,107],[257,105],[275,105],[280,108],[258,109],[260,105],[261,110],[264,105],[271,111],[262,105],[263,112],[61,105],[274,105],[281,113],[273,114],[58,6],[59,6],[10,6],[12,6],[11,6],[2,6],[13,6],[14,6],[15,6],[16,6],[17,6],[18,6],[19,6],[20,6],[3,6],[21,6],[4,6],[22,6],[26,6],[23,6],[24,6],[25,6],[27,6],[28,6],[29,6],[5,6],[30,6],[31,6],[32,6],[33,6],[6,6],[37,6],[34,6],[35,6],[36,6],[38,6],[7,6],[39,6],[44,6],[45,6],[40,6],[41,6],[42,6],[43,6],[8,6],[49,6],[46,6],[47,6],[48,6],[50,6],[9,6],[51,6],[52,6],[53,6],[56,6],[54,6],[55,6],[1,6],[57,6],[346,115],[345,116],[342,117],[343,6],[338,6],[340,6],[341,6],[339,118],[344,119]],"semanticDiagnosticsPerFile":[61,257,259,260,262,264,271,272,273,274,275,281,282,348]},"version":"5.5.2"}


================================================
FILE: .angular/cache/18.2.20/angular-pivothead-example/vite/deps/@angular_common.js
================================================
import {
  APP_BASE_HREF,
  AsyncPipe,
  BrowserPlatformLocation,
  CommonModule,
  CurrencyPipe,
  DATE_PIPE_DEFAULT_OPTIONS,
  DATE_PIPE_DEFAULT_TIMEZONE,
  DOCUMENT,
  DatePipe,
  DecimalPipe,
  DomAdapter,
  FormStyle,
  FormatWidth,
  HashLocationStrategy,
  I18nPluralPipe,
  I18nSelectPipe,
  IMAGE_LOADER,
  JsonPipe,
  KeyValuePipe,
  LOCATION_INITIALIZED,
  Location,
  LocationStrategy,
  LowerCasePipe,
  NgClass,
  NgComponentOutlet,
  NgForOf,
  NgForOfContext,
  NgIf,
  NgIfContext,
  NgLocaleLocalization,
  NgLocalization,
  NgOptimizedImage,
  NgPlural,
  NgPluralCase,
  NgStyle,
  NgSwitch,
  NgSwitchCase,
  NgSwitchDefault,
  NgTemplateOutlet,
  NullViewportScroller,
  NumberFormatStyle,
  NumberSymbol,
  PLATFORM_BROWSER_ID,
  PLATFORM_SERVER_ID,
  PRECONNECT_CHECK_BLOCKLIST,
  PathLocationStrategy,
  PercentPipe,
  PlatformLocation,
  PlatformNavigation,
  Plural,
  SlicePipe,
  TitleCasePipe,
  TranslationWidth,
  UpperCasePipe,
  VERSION,
  ViewportScroller,
  WeekDay,
  XhrFactory,
  formatCurrency,
  formatDate,
  formatNumber,
  formatPercent,
  getCurrencySymbol,
  getDOM,
  getLocaleCurrencyCode,
  getLocaleCurrencyName,
  getLocaleCurrencySymbol,
  getLocaleDateFormat,
  getLocaleDateTimeFormat,
  getLocaleDayNames,
  getLocaleDayPeriods,
  getLocaleDirection,
  getLocaleEraNames,
  getLocaleExtraDayPeriodRules,
  getLocaleExtraDayPeriods,
  getLocaleFirstDayOfWeek,
  getLocaleId,
  getLocaleMonthNames,
  getLocaleNumberFormat,
  getLocaleNumberSymbol,
  getLocalePluralCase,
  getLocaleTimeFormat,
  getLocaleWeekEndRange,
  getNumberOfCurrencyDigits,
  isPlatformBrowser,
  isPlatformServer,
  normalizeQueryParams,
  parseCookieValue,
  provideCloudflareLoader,
  provideCloudinaryLoader,
  provideImageKitLoader,
  provideImgixLoader,
  provideNetlifyLoader,
  registerLocaleData,
  setRootDomAdapter
} from "./chunk-HB2ZDJCU.js";
import {
  IMAGE_CONFIG
} from "./chunk-2VVDJA4L.js";
import "./chunk-VKET2LIV.js";
import "./chunk-HHOT2EEL.js";
import "./chunk-5NODSH2C.js";
import "./chunk-LPUAGQXJ.js";
import "./chunk-OVFEQSRS.js";
import "./chunk-WDMUDEB6.js";
export {
  APP_BASE_HREF,
  AsyncPipe,
  BrowserPlatformLocation,
  CommonModule,
  CurrencyPipe,
  DATE_PIPE_DEFAULT_OPTIONS,
  DATE_PIPE_DEFAULT_TIMEZONE,
  DOCUMENT,
  DatePipe,
  DecimalPipe,
  FormStyle,
  FormatWidth,
  HashLocationStrategy,
  I18nPluralPipe,
  I18nSelectPipe,
  IMAGE_CONFIG,
  IMAGE_LOADER,
  JsonPipe,
  KeyValuePipe,
  LOCATION_INITIALIZED,
  Location,
  LocationStrategy,
  LowerCasePipe,
  NgClass,
  NgComponentOutlet,
  NgForOf as NgFor,
  NgForOf,
  NgForOfContext,
  NgIf,
  NgIfContext,
  NgLocaleLocalization,
  NgLocalization,
  NgOptimizedImage,
  NgPlural,
  NgPluralCase,
  NgStyle,
  NgSwitch,
  NgSwitchCase,
  NgSwitchDefault,
  NgTemplateOutlet,
  NumberFormatStyle,
  NumberSymbol,
  PRECONNECT_CHECK_BLOCKLIST,
  PathLocationStrategy,
  PercentPipe,
  PlatformLocation,
  Plural,
  SlicePipe,
  TitleCasePipe,
  TranslationWidth,
  UpperCasePipe,
  VERSION,
  ViewportScroller,
  WeekDay,
  XhrFactory,
  formatCurrency,
  formatDate,
  formatNumber,
  formatPercent,
  getCurrencySymbol,
  getLocaleCurrencyCode,
  getLocaleCurrencyName,
  getLocaleCurrencySymbol,
  getLocaleDateFormat,
  getLocaleDateTimeFormat,
  getLocaleDayNames,
  getLocaleDayPeriods,
  getLocaleDirection,
  getLocaleEraNames,
  getLocaleExtraDayPeriodRules,
  getLocaleExtraDayPeriods,
  getLocaleFirstDayOfWeek,
  getLocaleId,
  getLocaleMonthNames,
  getLocaleNumberFormat,
  getLocaleNumberSymbol,
  getLocalePluralCase,
  getLocaleTimeFormat,
  getLocaleWeekEndRange,
  getNumberOfCurrencyDigits,
  isPlatformBrowser,
  isPlatformServer,
  provideCloudflareLoader,
  provideCloudinaryLoader,
  provideImageKitLoader,
  provideImgixLoader,
  provideNetlifyLoader,
  registerLocaleData,
  DomAdapter as ɵDomAdapter,
  NullViewportScroller as ɵNullViewportScroller,
  PLATFORM_BROWSER_ID as ɵPLATFORM_BROWSER_ID,
  PLATFORM_SERVER_ID as ɵPLATFORM_SERVER_ID,
  PlatformNavigation as ɵPlatformNavigation,
  getDOM as ɵgetDOM,
  normalizeQueryParams as ɵnormalizeQueryParams,
  parseCookieValue as ɵparseCookieValue,
  setRootDomAdapter as ɵsetRootDomAdapter
};
//# sourceMappingURL=@angular_common.js.map



================================================
FILE: .angular/cache/18.2.20/angular-pivothead-example/vite/deps/@angular_common_http.js
================================================
import {
  DOCUMENT,
  XhrFactory,
  isPlatformServer,
  parseCookieValue
} from "./chunk-HB2ZDJCU.js";
import {
  APP_BOOTSTRAP_LISTENER,
  ApplicationRef,
  Console,
  EnvironmentInjector,
  Inject,
  Injectable,
  InjectionToken,
  NgModule,
  NgZone,
  PLATFORM_ID,
  PendingTasks,
  RuntimeError,
  TransferState,
  formatRuntimeError,
  inject,
  makeEnvironmentProviders,
  makeStateKey,
  performanceMarkFeature,
  runInInjectionContext,
  setClassMetadata,
  truncateMiddle,
  whenStable,
  ɵɵdefineInjectable,
  ɵɵdefineInjector,
  ɵɵdefineNgModule,
  ɵɵinject
} from "./chunk-2VVDJA4L.js";
import "./chunk-VKET2LIV.js";
import "./chunk-HHOT2EEL.js";
import "./chunk-5NODSH2C.js";
import "./chunk-LPUAGQXJ.js";
import {
  Observable,
  concatMap,
  filter,
  finalize,
  from,
  map,
  of,
  switchMap,
  tap
} from "./chunk-OVFEQSRS.js";
import {
  __async,
  __objRest,
  __spreadValues
} from "./chunk-WDMUDEB6.js";

// node_modules/@angular/common/fesm2022/http.mjs
var HttpHandler = class {
};
var HttpBackend = class {
};
var HttpHeaders = class _HttpHeaders {
  /**  Constructs a new HTTP header object with the given values.*/
  constructor(headers) {
    this.normalizedNames = /* @__PURE__ */ new Map();
    this.lazyUpdate = null;
    if (!headers) {
      this.headers = /* @__PURE__ */ new Map();
    } else if (typeof headers === "string") {
      this.lazyInit = () => {
        this.headers = /* @__PURE__ */ new Map();
        headers.split("\n").forEach((line) => {
          const index = line.indexOf(":");
          if (index > 0) {
            const name = line.slice(0, index);
            const key = name.toLowerCase();
            const value = line.slice(index + 1).trim();
            this.maybeSetNormalizedName(name, key);
            if (this.headers.has(key)) {
              this.headers.get(key).push(value);
            } else {
              this.headers.set(key, [value]);
            }
          }
        });
      };
    } else if (typeof Headers !== "undefined" && headers instanceof Headers) {
      this.headers = /* @__PURE__ */ new Map();
      headers.forEach((values, name) => {
        this.setHeaderEntries(name, values);
      });
    } else {
      this.lazyInit = () => {
        if (typeof ngDevMode === "undefined" || ngDevMode) {
          assertValidHeaders(headers);
        }
        this.headers = /* @__PURE__ */ new Map();
        Object.entries(headers).forEach(([name, values]) => {
          this.setHeaderEntries(name, values);
        });
      };
    }
  }
  /**
   * Checks for existence of a given header.
   *
   * @param name The header name to check for existence.
   *
   * @returns True if the header exists, false otherwise.
   */
  has(name) {
    this.init();
    return this.headers.has(name.toLowerCase());
  }
  /**
   * Retrieves the first value of a given header.
   *
   * @param name The header name.
   *
   * @returns The value string if the header exists, null otherwise
   */
  get(name) {
    this.init();
    const values = this.headers.get(name.toLowerCase());
    return values && values.length > 0 ? values[0] : null;
  }
  /**
   * Retrieves the names of the headers.
   *
   * @returns A list of header names.
   */
  keys() {
    this.init();
    return Array.from(this.normalizedNames.values());
  }
  /**
   * Retrieves a list of values for a given header.
   *
   * @param name The header name from which to retrieve values.
   *
   * @returns A string of values if the header exists, null otherwise.
   */
  getAll(name) {
    this.init();
    return this.headers.get(name.toLowerCase()) || null;
  }
  /**
   * Appends a new value to the existing set of values for a header
   * and returns them in a clone of the original instance.
   *
   * @param name The header name for which to append the values.
   * @param value The value to append.
   *
   * @returns A clone of the HTTP headers object with the value appended to the given header.
   */
  append(name, value) {
    return this.clone({
      name,
      value,
      op: "a"
    });
  }
  /**
   * Sets or modifies a value for a given header in a clone of the original instance.
   * If the header already exists, its value is replaced with the given value
   * in the returned object.
   *
   * @param name The header name.
   * @param value The value or values to set or override for the given header.
   *
   * @returns A clone of the HTTP headers object with the newly set header value.
   */
  set(name, value) {
    return this.clone({
      name,
      value,
      op: "s"
    });
  }
  /**
   * Deletes values for a given header in a clone of the original instance.
   *
   * @param name The header name.
   * @param value The value or values to delete for the given header.
   *
   * @returns A clone of the HTTP headers object with the given value deleted.
   */
  delete(name, value) {
    return this.clone({
      name,
      value,
      op: "d"
    });
  }
  maybeSetNormalizedName(name, lcName) {
    if (!this.normalizedNames.has(lcName)) {
      this.normalizedNames.set(lcName, name);
    }
  }
  init() {
    if (!!this.lazyInit) {
      if (this.lazyInit instanceof _HttpHeaders) {
        this.copyFrom(this.lazyInit);
      } else {
        this.lazyInit();
      }
      this.lazyInit = null;
      if (!!this.lazyUpdate) {
        this.lazyUpdate.forEach((update) => this.applyUpdate(update));
        this.lazyUpdate = null;
      }
    }
  }
  copyFrom(other) {
    other.init();
    Array.from(other.headers.keys()).forEach((key) => {
      this.headers.set(key, other.headers.get(key));
      this.normalizedNames.set(key, other.normalizedNames.get(key));
    });
  }
  clone(update) {
    const clone = new _HttpHeaders();
    clone.lazyInit = !!this.lazyInit && this.lazyInit instanceof _HttpHeaders ? this.lazyInit : this;
    clone.lazyUpdate = (this.lazyUpdate || []).concat([update]);
    return clone;
  }
  applyUpdate(update) {
    const key = update.name.toLowerCase();
    switch (update.op) {
      case "a":
      case "s":
        let value = update.value;
        if (typeof value === "string") {
          value = [value];
        }
        if (value.length === 0) {
          return;
        }
        this.maybeSetNormalizedName(update.name, key);
        const base = (update.op === "a" ? this.headers.get(key) : void 0) || [];
        base.push(...value);
        this.headers.set(key, base);
        break;
      case "d":
        const toDelete = update.value;
        if (!toDelete) {
          this.headers.delete(key);
          this.normalizedNames.delete(key);
        } else {
          let existing = this.headers.get(key);
          if (!existing) {
            return;
          }
          existing = existing.filter((value2) => toDelete.indexOf(value2) === -1);
          if (existing.length === 0) {
            this.headers.delete(key);
            this.normalizedNames.delete(key);
          } else {
            this.headers.set(key, existing);
          }
        }
        break;
    }
  }
  setHeaderEntries(name, values) {
    const headerValues = (Array.isArray(values) ? values : [values]).map((value) => value.toString());
    const key = name.toLowerCase();
    this.headers.set(key, headerValues);
    this.maybeSetNormalizedName(name, key);
  }
  /**
   * @internal
   */
  forEach(fn) {
    this.init();
    Array.from(this.normalizedNames.keys()).forEach((key) => fn(this.normalizedNames.get(key), this.headers.get(key)));
  }
};
function assertValidHeaders(headers) {
  for (const [key, value] of Object.entries(headers)) {
    if (!(typeof value === "string" || typeof value === "number") && !Array.isArray(value)) {
      throw new Error(`Unexpected value of the \`${key}\` header provided. Expecting either a string, a number or an array, but got: \`${value}\`.`);
    }
  }
}
var HttpUrlEncodingCodec = class {
  /**
   * Encodes a key name for a URL parameter or query-string.
   * @param key The key name.
   * @returns The encoded key name.
   */
  encodeKey(key) {
    return standardEncoding(key);
  }
  /**
   * Encodes the value of a URL parameter or query-string.
   * @param value The value.
   * @returns The encoded value.
   */
  encodeValue(value) {
    return standardEncoding(value);
  }
  /**
   * Decodes an encoded URL parameter or query-string key.
   * @param key The encoded key name.
   * @returns The decoded key name.
   */
  decodeKey(key) {
    return decodeURIComponent(key);
  }
  /**
   * Decodes an encoded URL parameter or query-string value.
   * @param value The encoded value.
   * @returns The decoded value.
   */
  decodeValue(value) {
    return decodeURIComponent(value);
  }
};
function paramParser(rawParams, codec) {
  const map2 = /* @__PURE__ */ new Map();
  if (rawParams.length > 0) {
    const params = rawParams.replace(/^\?/, "").split("&");
    params.forEach((param) => {
      const eqIdx = param.indexOf("=");
      const [key, val] = eqIdx == -1 ? [codec.decodeKey(param), ""] : [codec.decodeKey(param.slice(0, eqIdx)), codec.decodeValue(param.slice(eqIdx + 1))];
      const list = map2.get(key) || [];
      list.push(val);
      map2.set(key, list);
    });
  }
  return map2;
}
var STANDARD_ENCODING_REGEX = /%(\d[a-f0-9])/gi;
var STANDARD_ENCODING_REPLACEMENTS = {
  "40": "@",
  "3A": ":",
  "24": "$",
  "2C": ",",
  "3B": ";",
  "3D": "=",
  "3F": "?",
  "2F": "/"
};
function standardEncoding(v) {
  return encodeURIComponent(v).replace(STANDARD_ENCODING_REGEX, (s, t) => STANDARD_ENCODING_REPLACEMENTS[t] ?? s);
}
function valueToString(value) {
  return `${value}`;
}
var HttpParams = class _HttpParams {
  constructor(options = {}) {
    this.updates = null;
    this.cloneFrom = null;
    this.encoder = options.encoder || new HttpUrlEncodingCodec();
    if (!!options.fromString) {
      if (!!options.fromObject) {
        throw new Error(`Cannot specify both fromString and fromObject.`);
      }
      this.map = paramParser(options.fromString, this.encoder);
    } else if (!!options.fromObject) {
      this.map = /* @__PURE__ */ new Map();
      Object.keys(options.fromObject).forEach((key) => {
        const value = options.fromObject[key];
        const values = Array.isArray(value) ? value.map(valueToString) : [valueToString(value)];
        this.map.set(key, values);
      });
    } else {
      this.map = null;
    }
  }
  /**
   * Reports whether the body includes one or more values for a given parameter.
   * @param param The parameter name.
   * @returns True if the parameter has one or more values,
   * false if it has no value or is not present.
   */
  has(param) {
    this.init();
    return this.map.has(param);
  }
  /**
   * Retrieves the first value for a parameter.
   * @param param The parameter name.
   * @returns The first value of the given parameter,
   * or `null` if the parameter is not present.
   */
  get(param) {
    this.init();
    const res = this.map.get(param);
    return !!res ? res[0] : null;
  }
  /**
   * Retrieves all values for a  parameter.
   * @param param The parameter name.
   * @returns All values in a string array,
   * or `null` if the parameter not present.
   */
  getAll(param) {
    this.init();
    return this.map.get(param) || null;
  }
  /**
   * Retrieves all the parameters for this body.
   * @returns The parameter names in a string array.
   */
  keys() {
    this.init();
    return Array.from(this.map.keys());
  }
  /**
   * Appends a new value to existing values for a parameter.
   * @param param The parameter name.
   * @param value The new value to add.
   * @return A new body with the appended value.
   */
  append(param, value) {
    return this.clone({
      param,
      value,
      op: "a"
    });
  }
  /**
   * Constructs a new body with appended values for the given parameter name.
   * @param params parameters and values
   * @return A new body with the new value.
   */
  appendAll(params) {
    const updates = [];
    Object.keys(params).forEach((param) => {
      const value = params[param];
      if (Array.isArray(value)) {
        value.forEach((_value) => {
          updates.push({
            param,
            value: _value,
            op: "a"
          });
        });
      } else {
        updates.push({
          param,
          value,
          op: "a"
        });
      }
    });
    return this.clone(updates);
  }
  /**
   * Replaces the value for a parameter.
   * @param param The parameter name.
   * @param value The new value.
   * @return A new body with the new value.
   */
  set(param, value) {
    return this.clone({
      param,
      value,
      op: "s"
    });
  }
  /**
   * Removes a given value or all values from a parameter.
   * @param param The parameter name.
   * @param value The value to remove, if provided.
   * @return A new body with the given value removed, or with all values
   * removed if no value is specified.
   */
  delete(param, value) {
    return this.clone({
      param,
      value,
      op: "d"
    });
  }
  /**
   * Serializes the body to an encoded string, where key-value pairs (separated by `=`) are
   * separated by `&`s.
   */
  toString() {
    this.init();
    return this.keys().map((key) => {
      const eKey = this.encoder.encodeKey(key);
      return this.map.get(key).map((value) => eKey + "=" + this.encoder.encodeValue(value)).join("&");
    }).filter((param) => param !== "").join("&");
  }
  clone(update) {
    const clone = new _HttpParams({
      encoder: this.encoder
    });
    clone.cloneFrom = this.cloneFrom || this;
    clone.updates = (this.updates || []).concat(update);
    return clone;
  }
  init() {
    if (this.map === null) {
      this.map = /* @__PURE__ */ new Map();
    }
    if (this.cloneFrom !== null) {
      this.cloneFrom.init();
      this.cloneFrom.keys().forEach((key) => this.map.set(key, this.cloneFrom.map.get(key)));
      this.updates.forEach((update) => {
        switch (update.op) {
          case "a":
          case "s":
            const base = (update.op === "a" ? this.map.get(update.param) : void 0) || [];
            base.push(valueToString(update.value));
            this.map.set(update.param, base);
            break;
          case "d":
            if (update.value !== void 0) {
              let base2 = this.map.get(update.param) || [];
              const idx = base2.indexOf(valueToString(update.value));
              if (idx !== -1) {
                base2.splice(idx, 1);
              }
              if (base2.length > 0) {
                this.map.set(update.param, base2);
              } else {
                this.map.delete(update.param);
              }
            } else {
              this.map.delete(update.param);
              break;
            }
        }
      });
      this.cloneFrom = this.updates = null;
    }
  }
};
var HttpContextToken = class {
  constructor(defaultValue) {
    this.defaultValue = defaultValue;
  }
};
var HttpContext = class {
  constructor() {
    this.map = /* @__PURE__ */ new Map();
  }
  /**
   * Store a value in the context. If a value is already present it will be overwritten.
   *
   * @param token The reference to an instance of `HttpContextToken`.
   * @param value The value to store.
   *
   * @returns A reference to itself for easy chaining.
   */
  set(token, value) {
    this.map.set(token, value);
    return this;
  }
  /**
   * Retrieve the value associated with the given token.
   *
   * @param token The reference to an instance of `HttpContextToken`.
   *
   * @returns The stored value or default if one is defined.
   */
  get(token) {
    if (!this.map.has(token)) {
      this.map.set(token, token.defaultValue());
    }
    return this.map.get(token);
  }
  /**
   * Delete the value associated with the given token.
   *
   * @param token The reference to an instance of `HttpContextToken`.
   *
   * @returns A reference to itself for easy chaining.
   */
  delete(token) {
    this.map.delete(token);
    return this;
  }
  /**
   * Checks for existence of a given token.
   *
   * @param token The reference to an instance of `HttpContextToken`.
   *
   * @returns True if the token exists, false otherwise.
   */
  has(token) {
    return this.map.has(token);
  }
  /**
   * @returns a list of tokens currently stored in the context.
   */
  keys() {
    return this.map.keys();
  }
};
function mightHaveBody(method) {
  switch (method) {
    case "DELETE":
    case "GET":
    case "HEAD":
    case "OPTIONS":
    case "JSONP":
      return false;
    default:
      return true;
  }
}
function isArrayBuffer(value) {
  return typeof ArrayBuffer !== "undefined" && value instanceof ArrayBuffer;
}
function isBlob(value) {
  return typeof Blob !== "undefined" && value instanceof Blob;
}
function isFormData(value) {
  return typeof FormData !== "undefined" && value instanceof FormData;
}
function isUrlSearchParams(value) {
  return typeof URLSearchParams !== "undefined" && value instanceof URLSearchParams;
}
var HttpRequest = class _HttpRequest {
  constructor(method, url, third, fourth) {
    this.url = url;
    this.body = null;
    this.reportProgress = false;
    this.withCredentials = false;
    this.responseType = "json";
    this.method = method.toUpperCase();
    let options;
    if (mightHaveBody(this.method) || !!fourth) {
      this.body = third !== void 0 ? third : null;
      options = fourth;
    } else {
      options = third;
    }
    if (options) {
      this.reportProgress = !!options.reportProgress;
      this.withCredentials = !!options.withCredentials;
      if (!!options.responseType) {
        this.responseType = options.responseType;
      }
      if (!!options.headers) {
        this.headers = options.headers;
      }
      if (!!options.context) {
        this.context = options.context;
      }
      if (!!options.params) {
        this.params = options.params;
      }
      this.transferCache = options.transferCache;
    }
    this.headers ??= new HttpHeaders();
    this.context ??= new HttpContext();
    if (!this.params) {
      this.params = new HttpParams();
      this.urlWithParams = url;
    } else {
      const params = this.params.toString();
      if (params.length === 0) {
        this.urlWithParams = url;
      } else {
        const qIdx = url.indexOf("?");
        const sep = qIdx === -1 ? "?" : qIdx < url.length - 1 ? "&" : "";
        this.urlWithParams = url + sep + params;
      }
    }
  }
  /**
   * Transform the free-form body into a serialized format suitable for
   * transmission to the server.
   */
  serializeBody() {
    if (this.body === null) {
      return null;
    }
    if (typeof this.body === "string" || isArrayBuffer(this.body) || isBlob(this.body) || isFormData(this.body) || isUrlSearchParams(this.body)) {
      return this.body;
    }
    if (this.body instanceof HttpParams) {
      return this.body.toString();
    }
    if (typeof this.body === "object" || typeof this.body === "boolean" || Array.isArray(this.body)) {
      return JSON.stringify(this.body);
    }
    return this.body.toString();
  }
  /**
   * Examine the body and attempt to infer an appropriate MIME type
   * for it.
   *
   * If no such type can be inferred, this method will return `null`.
   */
  detectContentTypeHeader() {
    if (this.body === null) {
      return null;
    }
    if (isFormData(this.body)) {
      return null;
    }
    if (isBlob(this.body)) {
      return this.body.type || null;
    }
    if (isArrayBuffer(this.body)) {
      return null;
    }
    if (typeof this.body === "string") {
      return "text/plain";
    }
    if (this.body instanceof HttpParams) {
      return "application/x-www-form-urlencoded;charset=UTF-8";
    }
    if (typeof this.body === "object" || typeof this.body === "number" || typeof this.body === "boolean") {
      return "application/json";
    }
    return null;
  }
  clone(update = {}) {
    const method = update.method || this.method;
    const url = update.url || this.url;
    const responseType = update.responseType || this.responseType;
    const transferCache = update.transferCache ?? this.transferCache;
    const body = update.body !== void 0 ? update.body : this.body;
    const withCredentials = update.withCredentials ?? this.withCredentials;
    const reportProgress = update.reportProgress ?? this.reportProgress;
    let headers = update.headers || this.headers;
    let params = update.params || this.params;
    const context = update.context ?? this.context;
    if (update.setHeaders !== void 0) {
      headers = Object.keys(update.setHeaders).reduce((headers2, name) => headers2.set(name, update.setHeaders[name]), headers);
    }
    if (update.setParams) {
      params = Object.keys(update.setParams).reduce((params2, param) => params2.set(param, update.setParams[param]), params);
    }
    return new _HttpRequest(method, url, body, {
      params,
      headers,
      context,
      reportProgress,
      responseType,
      withCredentials,
      transferCache
    });
  }
};
var HttpEventType;
(function(HttpEventType2) {
  HttpEventType2[HttpEventType2["Sent"] = 0] = "Sent";
  HttpEventType2[HttpEventType2["UploadProgress"] = 1] = "UploadProgress";
  HttpEventType2[HttpEventType2["ResponseHeader"] = 2] = "ResponseHeader";
  HttpEventType2[HttpEventType2["DownloadProgress"] = 3] = "DownloadProgress";
  HttpEventType2[HttpEventType2["Response"] = 4] = "Response";
  HttpEventType2[HttpEventType2["User"] = 5] = "User";
})(HttpEventType || (HttpEventType = {}));
var HttpResponseBase = class {
  /**
   * Super-constructor for all responses.
   *
   * The single parameter accepted is an initialization hash. Any properties
   * of the response passed there will override the default values.
   */
  constructor(init, defaultStatus = 200, defaultStatusText = "OK") {
    this.headers = init.headers || new HttpHeaders();
    this.status = init.status !== void 0 ? init.status : defaultStatus;
    this.statusText = init.statusText || defaultStatusText;
    this.url = init.url || null;
    this.ok = this.status >= 200 && this.status < 300;
  }
};
var HttpHeaderResponse = class _HttpHeaderResponse extends HttpResponseBase {
  /**
   * Create a new `HttpHeaderResponse` with the given parameters.
   */
  constructor(init = {}) {
    super(init);
    this.type = HttpEventType.ResponseHeader;
  }
  /**
   * Copy this `HttpHeaderResponse`, overriding its contents with the
   * given parameter hash.
   */
  clone(update = {}) {
    return new _HttpHeaderResponse({
      headers: update.headers || this.headers,
      status: update.status !== void 0 ? update.status : this.status,
      statusText: update.statusText || this.statusText,
      url: update.url || this.url || void 0
    });
  }
};
var HttpResponse = class _HttpResponse extends HttpResponseBase {
  /**
   * Construct a new `HttpResponse`.
   */
  constructor(init = {}) {
    super(init);
    this.type = HttpEventType.Response;
    this.body = init.body !== void 0 ? init.body : null;
  }
  clone(update = {}) {
    return new _HttpResponse({
      body: update.body !== void 0 ? update.body : this.body,
      headers: update.headers || this.headers,
      status: update.status !== void 0 ? update.status : this.status,
      statusText: update.statusText || this.statusText,
      url: update.url || this.url || void 0
    });
  }
};
var HttpErrorResponse = class extends HttpResponseBase {
  constructor(init) {
    super(init, 0, "Unknown Error");
    this.name = "HttpErrorResponse";
    this.ok = false;
    if (this.status >= 200 && this.status < 300) {
      this.message = `Http failure during parsing for ${init.url || "(unknown url)"}`;
    } else {
      this.message = `Http failure response for ${init.url || "(unknown url)"}: ${init.status} ${init.statusText}`;
    }
    this.error = init.error || null;
  }
};
var HTTP_STATUS_CODE_OK = 200;
var HTTP_STATUS_CODE_NO_CONTENT = 204;
var HttpStatusCode;
(function(HttpStatusCode2) {
  HttpStatusCode2[HttpStatusCode2["Continue"] = 100] = "Continue";
  HttpStatusCode2[HttpStatusCode2["SwitchingProtocols"] = 101] = "SwitchingProtocols";
  HttpStatusCode2[HttpStatusCode2["Processing"] = 102] = "Processing";
  HttpStatusCode2[HttpStatusCode2["EarlyHints"] = 103] = "EarlyHints";
  HttpStatusCode2[HttpStatusCode2["Ok"] = 200] = "Ok";
  HttpStatusCode2[HttpStatusCode2["Created"] = 201] = "Created";
  HttpStatusCode2[HttpStatusCode2["Accepted"] = 202] = "Accepted";
  HttpStatusCode2[HttpStatusCode2["NonAuthoritativeInformation"] = 203] = "NonAuthoritativeInformation";
  HttpStatusCode2[HttpStatusCode2["NoContent"] = 204] = "NoContent";
  HttpStatusCode2[HttpStatusCode2["ResetContent"] = 205] = "ResetContent";
  HttpStatusCode2[HttpStatusCode2["PartialContent"] = 206] = "PartialContent";
  HttpStatusCode2[HttpStatusCode2["MultiStatus"] = 207] = "MultiStatus";
  HttpStatusCode2[HttpStatusCode2["AlreadyReported"] = 208] = "AlreadyReported";
  HttpStatusCode2[HttpStatusCode2["ImUsed"] = 226] = "ImUsed";
  HttpStatusCode2[HttpStatusCode2["MultipleChoices"] = 300] = "MultipleChoices";
  HttpStatusCode2[HttpStatusCode2["MovedPermanently"] = 301] = "MovedPermanently";
  HttpStatusCode2[HttpStatusCode2["Found"] = 302] = "Found";
  HttpStatusCode2[HttpStatusCode2["SeeOther"] = 303] = "SeeOther";
  HttpStatusCode2[HttpStatusCode2["NotModified"] = 304] = "NotModified";
  HttpStatusCode2[HttpStatusCode2["UseProxy"] = 305] = "UseProxy";
  HttpStatusCode2[HttpStatusCode2["Unused"] = 306] = "Unused";
  HttpStatusCode2[HttpStatusCode2["TemporaryRedirect"] = 307] = "TemporaryRedirect";
  HttpStatusCode2[HttpStatusCode2["PermanentRedirect"] = 308] = "PermanentRedirect";
  HttpStatusCode2[HttpStatusCode2["BadRequest"] = 400] = "BadRequest";
  HttpStatusCode2[HttpStatusCode2["Unauthorized"] = 401] = "Unauthorized";
  HttpStatusCode2[HttpStatusCode2["PaymentRequired"] = 402] = "PaymentRequired";
  HttpStatusCode2[HttpStatusCode2["Forbidden"] = 403] = "Forbidden";
  HttpStatusCode2[HttpStatusCode2["NotFound"] = 404] = "NotFound";
  HttpStatusCode2[HttpStatusCode2["MethodNotAllowed"] = 405] = "MethodNotAllowed";
  HttpStatusCode2[HttpStatusCode2["NotAcceptable"] = 406] = "NotAcceptable";
  HttpStatusCode2[HttpStatusCode2["ProxyAuthenticationRequired"] = 407] = "ProxyAuthenticationRequired";
  HttpStatusCode2[HttpStatusCode2["RequestTimeout"] = 408] = "RequestTimeout";
  HttpStatusCode2[HttpStatusCode2["Conflict"] = 409] = "Conflict";
  HttpStatusCode2[HttpStatusCode2["Gone"] = 410] = "Gone";
  HttpStatusCode2[HttpStatusCode2["LengthRequired"] = 411] = "LengthRequired";
  HttpStatusCode2[HttpStatusCode2["PreconditionFailed"] = 412] = "PreconditionFailed";
  HttpStatusCode2[HttpStatusCode2["PayloadTooLarge"] = 413] = "PayloadTooLarge";
  HttpStatusCode2[HttpStatusCode2["UriTooLong"] = 414] = "UriTooLong";
  HttpStatusCode2[HttpStatusCode2["UnsupportedMediaType"] = 415] = "UnsupportedMediaType";
  HttpStatusCode2[HttpStatusCode2["RangeNotSatisfiable"] = 416] = "RangeNotSatisfiable";
  HttpStatusCode2[HttpStatusCode2["ExpectationFailed"] = 417] = "ExpectationFailed";
  HttpStatusCode2[HttpStatusCode2["ImATeapot"] = 418] = "ImATeapot";
  HttpStatusCode2[HttpStatusCode2["MisdirectedRequest"] = 421] = "MisdirectedRequest";
  HttpStatusCode2[HttpStatusCode2["UnprocessableEntity"] = 422] = "UnprocessableEntity";
  HttpStatusCode2[HttpStatusCode2["Locked"] = 423] = "Locked";
  HttpStatusCode2[HttpStatusCode2["FailedDependency"] = 424] = "FailedDependency";
  HttpStatusCode2[HttpStatusCode2["TooEarly"] = 425] = "TooEarly";
  HttpStatusCode2[HttpStatusCode2["UpgradeRequired"] = 426] = "UpgradeRequired";
  HttpStatusCode2[HttpStatusCode2["PreconditionRequired"] = 428] = "PreconditionRequired";
  HttpStatusCode2[HttpStatusCode2["TooManyRequests"] = 429] = "TooManyRequests";
  HttpStatusCode2[HttpStatusCode2["RequestHeaderFieldsTooLarge"] = 431] = "RequestHeaderFieldsTooLarge";
  HttpStatusCode2[HttpStatusCode2["UnavailableForLegalReasons"] = 451] = "UnavailableForLegalReasons";
  HttpStatusCode2[HttpStatusCode2["InternalServerError"] = 500] = "InternalServerError";
  HttpStatusCode2[HttpStatusCode2["NotImplemented"] = 501] = "NotImplemented";
  HttpStatusCode2[HttpStatusCode2["BadGateway"] = 502] = "BadGateway";
  HttpStatusCode2[HttpStatusCode2["ServiceUnavailable"] = 503] = "ServiceUnavailable";
  HttpStatusCode2[HttpStatusCode2["GatewayTimeout"] = 504] = "GatewayTimeout";
  HttpStatusCode2[HttpStatusCode2["HttpVersionNotSupported"] = 505] = "HttpVersionNotSupported";
  HttpStatusCode2[HttpStatusCode2["VariantAlsoNegotiates"] = 506] = "VariantAlsoNegotiates";
  HttpStatusCode2[HttpStatusCode2["InsufficientStorage"] = 507] = "InsufficientStorage";
  HttpStatusCode2[HttpStatusCode2["LoopDetected"] = 508] = "LoopDetected";
  HttpStatusCode2[HttpStatusCode2["NotExtended"] = 510] = "NotExtended";
  HttpStatusCode2[HttpStatusCode2["NetworkAuthenticationRequired"] = 511] = "NetworkAuthenticationRequired";
})(HttpStatusCode || (HttpStatusCode = {}));
function addBody(options, body) {
  return {
    body,
    headers: options.headers,
    context: options.context,
    observe: options.observe,
    params: options.params,
    reportProgress: options.reportProgress,
    responseType: options.responseType,
    withCredentials: options.withCredentials,
    transferCache: options.transferCache
  };
}
var HttpClient = class _HttpClient {
  constructor(handler) {
    this.handler = handler;
  }
  /**
   * Constructs an observable for a generic HTTP request that, when subscribed,
   * fires the request through the chain of registered interceptors and on to the
   * server.
   *
   * You can pass an `HttpRequest` directly as the only parameter. In this case,
   * the call returns an observable of the raw `HttpEvent` stream.
   *
   * Alternatively you can pass an HTTP method as the first parameter,
   * a URL string as the second, and an options hash containing the request body as the third.
   * See `addBody()`. In this case, the specified `responseType` and `observe` options determine the
   * type of returned observable.
   *   * The `responseType` value determines how a successful response body is parsed.
   *   * If `responseType` is the default `json`, you can pass a type interface for the resulting
   * object as a type parameter to the call.
   *
   * The `observe` value determines the return type, according to what you are interested in
   * observing.
   *   * An `observe` value of events returns an observable of the raw `HttpEvent` stream, including
   * progress events by default.
   *   * An `observe` value of response returns an observable of `HttpResponse<T>`,
   * where the `T` parameter depends on the `responseType` and any optionally provided type
   * parameter.
   *   * An `observe` value of body returns an observable of `<T>` with the same `T` body type.
   *
   */
  request(first, url, options = {}) {
    let req;
    if (first instanceof HttpRequest) {
      req = first;
    } else {
      let headers = void 0;
      if (options.headers instanceof HttpHeaders) {
        headers = options.headers;
      } else {
        headers = new HttpHeaders(options.headers);
      }
      let params = void 0;
      if (!!options.params) {
        if (options.params instanceof HttpParams) {
          params = options.params;
        } else {
          params = new HttpParams({
            fromObject: options.params
          });
        }
      }
      req = new HttpRequest(first, url, options.body !== void 0 ? options.body : null, {
        headers,
        context: options.context,
        params,
        reportProgress: options.reportProgress,
        // By default, JSON is assumed to be returned for all calls.
        responseType: options.responseType || "json",
        withCredentials: options.withCredentials,
        transferCache: options.transferCache
      });
    }
    const events$ = of(req).pipe(concatMap((req2) => this.handler.handle(req2)));
    if (first instanceof HttpRequest || options.observe === "events") {
      return events$;
    }
    const res$ = events$.pipe(filter((event) => event instanceof HttpResponse));
    switch (options.observe || "body") {
      case "body":
        switch (req.responseType) {
          case "arraybuffer":
            return res$.pipe(map((res) => {
              if (res.body !== null && !(res.body instanceof ArrayBuffer)) {
                throw new Error("Response is not an ArrayBuffer.");
              }
              return res.body;
            }));
          case "blob":
            return res$.pipe(map((res) => {
              if (res.body !== null && !(res.body instanceof Blob)) {
                throw new Error("Response is not a Blob.");
              }
              return res.body;
            }));
          case "text":
            return res$.pipe(map((res) => {
              if (res.body !== null && typeof res.body !== "string") {
                throw new Error("Response is not a string.");
              }
              return res.body;
            }));
          case "json":
          default:
            return res$.pipe(map((res) => res.body));
        }
      case "response":
        return res$;
      default:
        throw new Error(`Unreachable: unhandled observe type ${options.observe}}`);
    }
  }
  /**
   * Constructs an observable that, when subscribed, causes the configured
   * `DELETE` request to execute on the server. See the individual overloads for
   * details on the return type.
   *
   * @param url     The endpoint URL.
   * @param options The HTTP options to send with the request.
   *
   */
  delete(url, options = {}) {
    return this.request("DELETE", url, options);
  }
  /**
   * Constructs an observable that, when subscribed, causes the configured
   * `GET` request to execute on the server. See the individual overloads for
   * details on the return type.
   */
  get(url, options = {}) {
    return this.request("GET", url, options);
  }
  /**
   * Constructs an observable that, when subscribed, causes the configured
   * `HEAD` request to execute on the server. The `HEAD` method returns
   * meta information about the resource without transferring the
   * resource itself. See the individual overloads for
   * details on the return type.
   */
  head(url, options = {}) {
    return this.request("HEAD", url, options);
  }
  /**
   * Constructs an `Observable` that, when subscribed, causes a request with the special method
   * `JSONP` to be dispatched via the interceptor pipeline.
   * The [JSONP pattern](https://en.wikipedia.org/wiki/JSONP) works around limitations of certain
   * API endpoints that don't support newer,
   * and preferable [CORS](https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS) protocol.
   * JSONP treats the endpoint API as a JavaScript file and tricks the browser to process the
   * requests even if the API endpoint is not located on the same domain (origin) as the client-side
   * application making the request.
   * The endpoint API must support JSONP callback for JSONP requests to work.
   * The resource API returns the JSON response wrapped in a callback function.
   * You can pass the callback function name as one of the query parameters.
   * Note that JSONP requests can only be used with `GET` requests.
   *
   * @param url The resource URL.
   * @param callbackParam The callback function name.
   *
   */
  jsonp(url, callbackParam) {
    return this.request("JSONP", url, {
      params: new HttpParams().append(callbackParam, "JSONP_CALLBACK"),
      observe: "body",
      responseType: "json"
    });
  }
  /**
   * Constructs an `Observable` that, when subscribed, causes the configured
   * `OPTIONS` request to execute on the server. This method allows the client
   * to determine the supported HTTP methods and other capabilities of an endpoint,
   * without implying a resource action. See the individual overloads for
   * details on the return type.
   */
  options(url, options = {}) {
    return this.request("OPTIONS", url, options);
  }
  /**
   * Constructs an observable that, when subscribed, causes the configured
   * `PATCH` request to execute on the server. See the individual overloads for
   * details on the return type.
   */
  patch(url, body, options = {}) {
    return this.request("PATCH", url, addBody(options, body));
  }
  /**
   * Constructs an observable that, when subscribed, causes the configured
   * `POST` request to execute on the server. The server responds with the location of
   * the replaced resource. See the individual overloads for
   * details on the return type.
   */
  post(url, body, options = {}) {
    return this.request("POST", url, addBody(options, body));
  }
  /**
   * Constructs an observable that, when subscribed, causes the configured
   * `PUT` request to execute on the server. The `PUT` method replaces an existing resource
   * with a new set of values.
   * See the individual overloads for details on the return type.
   */
  put(url, body, options = {}) {
    return this.request("PUT", url, addBody(options, body));
  }
  static {
    this.ɵfac = function HttpClient_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _HttpClient)(ɵɵinject(HttpHandler));
    };
  }
  static {
    this.ɵprov = ɵɵdefineInjectable({
      token: _HttpClient,
      factory: _HttpClient.ɵfac
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(HttpClient, [{
    type: Injectable
  }], () => [{
    type: HttpHandler
  }], null);
})();
var XSSI_PREFIX$1 = /^\)\]\}',?\n/;
var REQUEST_URL_HEADER = `X-Request-URL`;
function getResponseUrl$1(response) {
  if (response.url) {
    return response.url;
  }
  const xRequestUrl = REQUEST_URL_HEADER.toLocaleLowerCase();
  return response.headers.get(xRequestUrl);
}
var FetchBackend = class _FetchBackend {
  constructor() {
    this.fetchImpl = inject(FetchFactory, {
      optional: true
    })?.fetch ?? fetch.bind(globalThis);
    this.ngZone = inject(NgZone);
  }
  handle(request) {
    return new Observable((observer) => {
      const aborter = new AbortController();
      this.doRequest(request, aborter.signal, observer).then(noop, (error) => observer.error(new HttpErrorResponse({
        error
      })));
      return () => aborter.abort();
    });
  }
  doRequest(request, signal, observer) {
    return __async(this, null, function* () {
      const init = this.createRequestInit(request);
      let response;
      try {
        const fetchPromise = this.ngZone.runOutsideAngular(() => this.fetchImpl(request.urlWithParams, __spreadValues({
          signal
        }, init)));
        silenceSuperfluousUnhandledPromiseRejection(fetchPromise);
        observer.next({
          type: HttpEventType.Sent
        });
        response = yield fetchPromise;
      } catch (error) {
        observer.error(new HttpErrorResponse({
          error,
          status: error.status ?? 0,
          statusText: error.statusText,
          url: request.urlWithParams,
          headers: error.headers
        }));
        return;
      }
      const headers = new HttpHeaders(response.headers);
      const statusText = response.statusText;
      const url = getResponseUrl$1(response) ?? request.urlWithParams;
      let status = response.status;
      let body = null;
      if (request.reportProgress) {
        observer.next(new HttpHeaderResponse({
          headers,
          status,
          statusText,
          url
        }));
      }
      if (response.body) {
        const contentLength = response.headers.get("content-length");
        const chunks = [];
        const reader = response.body.getReader();
        let receivedLength = 0;
        let decoder;
        let partialText;
        const reqZone = typeof Zone !== "undefined" && Zone.current;
        yield this.ngZone.runOutsideAngular(() => __async(this, null, function* () {
          while (true) {
            const {
              done,
              value
            } = yield reader.read();
            if (done) {
              break;
            }
            chunks.push(value);
            receivedLength += value.length;
            if (request.reportProgress) {
              partialText = request.responseType === "text" ? (partialText ?? "") + (decoder ??= new TextDecoder()).decode(value, {
                stream: true
              }) : void 0;
              const reportProgress = () => observer.next({
                type: HttpEventType.DownloadProgress,
                total: contentLength ? +contentLength : void 0,
                loaded: receivedLength,
                partialText
              });
              reqZone ? reqZone.run(reportProgress) : reportProgress();
            }
          }
        }));
        const chunksAll = this.concatChunks(chunks, receivedLength);
        try {
          const contentType = response.headers.get("Content-Type") ?? "";
          body = this.parseBody(request, chunksAll, contentType);
        } catch (error) {
          observer.error(new HttpErrorResponse({
            error,
            headers: new HttpHeaders(response.headers),
            status: response.status,
            statusText: response.statusText,
            url: getResponseUrl$1(response) ?? request.urlWithParams
          }));
          return;
        }
      }
      if (status === 0) {
        status = body ? HTTP_STATUS_CODE_OK : 0;
      }
      const ok = status >= 200 && status < 300;
      if (ok) {
        observer.next(new HttpResponse({
          body,
          headers,
          status,
          statusText,
          url
        }));
        observer.complete();
      } else {
        observer.error(new HttpErrorResponse({
          error: body,
          headers,
          status,
          statusText,
          url
        }));
      }
    });
  }
  parseBody(request, binContent, contentType) {
    switch (request.responseType) {
      case "json":
        const text = new TextDecoder().decode(binContent).replace(XSSI_PREFIX$1, "");
        return text === "" ? null : JSON.parse(text);
      case "text":
        return new TextDecoder().decode(binContent);
      case "blob":
        return new Blob([binContent], {
          type: contentType
        });
      case "arraybuffer":
        return binContent.buffer;
    }
  }
  createRequestInit(req) {
    const headers = {};
    const credentials = req.withCredentials ? "include" : void 0;
    req.headers.forEach((name, values) => headers[name] = values.join(","));
    if (!req.headers.has("Accept")) {
      headers["Accept"] = "application/json, text/plain, */*";
    }
    if (!req.headers.has("Content-Type")) {
      const detectedType = req.detectContentTypeHeader();
      if (detectedType !== null) {
        headers["Content-Type"] = detectedType;
      }
    }
    return {
      body: req.serializeBody(),
      method: req.method,
      headers,
      credentials
    };
  }
  concatChunks(chunks, totalLength) {
    const chunksAll = new Uint8Array(totalLength);
    let position = 0;
    for (const chunk of chunks) {
      chunksAll.set(chunk, position);
      position += chunk.length;
    }
    return chunksAll;
  }
  static {
    this.ɵfac = function FetchBackend_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _FetchBackend)();
    };
  }
  static {
    this.ɵprov = ɵɵdefineInjectable({
      token: _FetchBackend,
      factory: _FetchBackend.ɵfac
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(FetchBackend, [{
    type: Injectable
  }], null, null);
})();
var FetchFactory = class {
};
function noop() {
}
function silenceSuperfluousUnhandledPromiseRejection(promise) {
  promise.then(noop, noop);
}
function interceptorChainEndFn(req, finalHandlerFn) {
  return finalHandlerFn(req);
}
function adaptLegacyInterceptorToChain(chainTailFn, interceptor) {
  return (initialRequest, finalHandlerFn) => interceptor.intercept(initialRequest, {
    handle: (downstreamRequest) => chainTailFn(downstreamRequest, finalHandlerFn)
  });
}
function chainedInterceptorFn(chainTailFn, interceptorFn, injector) {
  return (initialRequest, finalHandlerFn) => runInInjectionContext(injector, () => interceptorFn(initialRequest, (downstreamRequest) => chainTailFn(downstreamRequest, finalHandlerFn)));
}
var HTTP_INTERCEPTORS = new InjectionToken(ngDevMode ? "HTTP_INTERCEPTORS" : "");
var HTTP_INTERCEPTOR_FNS = new InjectionToken(ngDevMode ? "HTTP_INTERCEPTOR_FNS" : "");
var HTTP_ROOT_INTERCEPTOR_FNS = new InjectionToken(ngDevMode ? "HTTP_ROOT_INTERCEPTOR_FNS" : "");
var REQUESTS_CONTRIBUTE_TO_STABILITY = new InjectionToken(ngDevMode ? "REQUESTS_CONTRIBUTE_TO_STABILITY" : "", {
  providedIn: "root",
  factory: () => true
});
function legacyInterceptorFnFactory() {
  let chain = null;
  return (req, handler) => {
    if (chain === null) {
      const interceptors = inject(HTTP_INTERCEPTORS, {
        optional: true
      }) ?? [];
      chain = interceptors.reduceRight(adaptLegacyInterceptorToChain, interceptorChainEndFn);
    }
    const pendingTasks = inject(PendingTasks);
    const contributeToStability = inject(REQUESTS_CONTRIBUTE_TO_STABILITY);
    if (contributeToStability) {
      const taskId = pendingTasks.add();
      return chain(req, handler).pipe(finalize(() => pendingTasks.remove(taskId)));
    } else {
      return chain(req, handler);
    }
  };
}
var fetchBackendWarningDisplayed = false;
var HttpInterceptorHandler = class _HttpInterceptorHandler extends HttpHandler {
  constructor(backend, injector) {
    super();
    this.backend = backend;
    this.injector = injector;
    this.chain = null;
    this.pendingTasks = inject(PendingTasks);
    this.contributeToStability = inject(REQUESTS_CONTRIBUTE_TO_STABILITY);
    if ((typeof ngDevMode === "undefined" || ngDevMode) && !fetchBackendWarningDisplayed) {
      const isServer = isPlatformServer(injector.get(PLATFORM_ID));
      if (isServer && !(this.backend instanceof FetchBackend)) {
        fetchBackendWarningDisplayed = true;
        injector.get(Console).warn(formatRuntimeError(2801, "Angular detected that `HttpClient` is not configured to use `fetch` APIs. It's strongly recommended to enable `fetch` for applications that use Server-Side Rendering for better performance and compatibility. To enable `fetch`, add the `withFetch()` to the `provideHttpClient()` call at the root of the application."));
      }
    }
  }
  handle(initialRequest) {
    if (this.chain === null) {
      const dedupedInterceptorFns = Array.from(/* @__PURE__ */ new Set([...this.injector.get(HTTP_INTERCEPTOR_FNS), ...this.injector.get(HTTP_ROOT_INTERCEPTOR_FNS, [])]));
      this.chain = dedupedInterceptorFns.reduceRight((nextSequencedFn, interceptorFn) => chainedInterceptorFn(nextSequencedFn, interceptorFn, this.injector), interceptorChainEndFn);
    }
    if (this.contributeToStability) {
      const taskId = this.pendingTasks.add();
      return this.chain(initialRequest, (downstreamRequest) => this.backend.handle(downstreamRequest)).pipe(finalize(() => this.pendingTasks.remove(taskId)));
    } else {
      return this.chain(initialRequest, (downstreamRequest) => this.backend.handle(downstreamRequest));
    }
  }
  static {
    this.ɵfac = function HttpInterceptorHandler_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _HttpInterceptorHandler)(ɵɵinject(HttpBackend), ɵɵinject(EnvironmentInjector));
    };
  }
  static {
    this.ɵprov = ɵɵdefineInjectable({
      token: _HttpInterceptorHandler,
      factory: _HttpInterceptorHandler.ɵfac
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(HttpInterceptorHandler, [{
    type: Injectable
  }], () => [{
    type: HttpBackend
  }, {
    type: EnvironmentInjector
  }], null);
})();
var nextRequestId = 0;
var foreignDocument;
var JSONP_ERR_NO_CALLBACK = "JSONP injected script did not invoke callback.";
var JSONP_ERR_WRONG_METHOD = "JSONP requests must use JSONP request method.";
var JSONP_ERR_WRONG_RESPONSE_TYPE = "JSONP requests must use Json response type.";
var JSONP_ERR_HEADERS_NOT_SUPPORTED = "JSONP requests do not support headers.";
var JsonpCallbackContext = class {
};
function jsonpCallbackContext() {
  if (typeof window === "object") {
    return window;
  }
  return {};
}
var JsonpClientBackend = class _JsonpClientBackend {
  constructor(callbackMap, document) {
    this.callbackMap = callbackMap;
    this.document = document;
    this.resolvedPromise = Promise.resolve();
  }
  /**
   * Get the name of the next callback method, by incrementing the global `nextRequestId`.
   */
  nextCallback() {
    return `ng_jsonp_callback_${nextRequestId++}`;
  }
  /**
   * Processes a JSONP request and returns an event stream of the results.
   * @param req The request object.
   * @returns An observable of the response events.
   *
   */
  handle(req) {
    if (req.method !== "JSONP") {
      throw new Error(JSONP_ERR_WRONG_METHOD);
    } else if (req.responseType !== "json") {
      throw new Error(JSONP_ERR_WRONG_RESPONSE_TYPE);
    }
    if (req.headers.keys().length > 0) {
      throw new Error(JSONP_ERR_HEADERS_NOT_SUPPORTED);
    }
    return new Observable((observer) => {
      const callback = this.nextCallback();
      const url = req.urlWithParams.replace(/=JSONP_CALLBACK(&|$)/, `=${callback}$1`);
      const node = this.document.createElement("script");
      node.src = url;
      let body = null;
      let finished = false;
      this.callbackMap[callback] = (data) => {
        delete this.callbackMap[callback];
        body = data;
        finished = true;
      };
      const cleanup = () => {
        node.remove();
        delete this.callbackMap[callback];
      };
      const onLoad = (event) => {
        this.resolvedPromise.then(() => {
          cleanup();
          if (!finished) {
            observer.error(new HttpErrorResponse({
              url,
              status: 0,
              statusText: "JSONP Error",
              error: new Error(JSONP_ERR_NO_CALLBACK)
            }));
            return;
          }
          observer.next(new HttpResponse({
            body,
            status: HTTP_STATUS_CODE_OK,
            statusText: "OK",
            url
          }));
          observer.complete();
        });
      };
      const onError = (error) => {
        cleanup();
        observer.error(new HttpErrorResponse({
          error,
          status: 0,
          statusText: "JSONP Error",
          url
        }));
      };
      node.addEventListener("load", onLoad);
      node.addEventListener("error", onError);
      this.document.body.appendChild(node);
      observer.next({
        type: HttpEventType.Sent
      });
      return () => {
        if (!finished) {
          this.removeListeners(node);
        }
        cleanup();
      };
    });
  }
  removeListeners(script) {
    foreignDocument ??= this.document.implementation.createHTMLDocument();
    foreignDocument.adoptNode(script);
  }
  static {
    this.ɵfac = function JsonpClientBackend_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _JsonpClientBackend)(ɵɵinject(JsonpCallbackContext), ɵɵinject(DOCUMENT));
    };
  }
  static {
    this.ɵprov = ɵɵdefineInjectable({
      token: _JsonpClientBackend,
      factory: _JsonpClientBackend.ɵfac
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(JsonpClientBackend, [{
    type: Injectable
  }], () => [{
    type: JsonpCallbackContext
  }, {
    type: void 0,
    decorators: [{
      type: Inject,
      args: [DOCUMENT]
    }]
  }], null);
})();
function jsonpInterceptorFn(req, next) {
  if (req.method === "JSONP") {
    return inject(JsonpClientBackend).handle(req);
  }
  return next(req);
}
var JsonpInterceptor = class _JsonpInterceptor {
  constructor(injector) {
    this.injector = injector;
  }
  /**
   * Identifies and handles a given JSONP request.
   * @param initialRequest The outgoing request object to handle.
   * @param next The next interceptor in the chain, or the backend
   * if no interceptors remain in the chain.
   * @returns An observable of the event stream.
   */
  intercept(initialRequest, next) {
    return runInInjectionContext(this.injector, () => jsonpInterceptorFn(initialRequest, (downstreamRequest) => next.handle(downstreamRequest)));
  }
  static {
    this.ɵfac = function JsonpInterceptor_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _JsonpInterceptor)(ɵɵinject(EnvironmentInjector));
    };
  }
  static {
    this.ɵprov = ɵɵdefineInjectable({
      token: _JsonpInterceptor,
      factory: _JsonpInterceptor.ɵfac
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(JsonpInterceptor, [{
    type: Injectable
  }], () => [{
    type: EnvironmentInjector
  }], null);
})();
var XSSI_PREFIX = /^\)\]\}',?\n/;
function getResponseUrl(xhr) {
  if ("responseURL" in xhr && xhr.responseURL) {
    return xhr.responseURL;
  }
  if (/^X-Request-URL:/m.test(xhr.getAllResponseHeaders())) {
    return xhr.getResponseHeader("X-Request-URL");
  }
  return null;
}
var HttpXhrBackend = class _HttpXhrBackend {
  constructor(xhrFactory) {
    this.xhrFactory = xhrFactory;
  }
  /**
   * Processes a request and returns a stream of response events.
   * @param req The request object.
   * @returns An observable of the response events.
   */
  handle(req) {
    if (req.method === "JSONP") {
      throw new RuntimeError(-2800, (typeof ngDevMode === "undefined" || ngDevMode) && `Cannot make a JSONP request without JSONP support. To fix the problem, either add the \`withJsonpSupport()\` call (if \`provideHttpClient()\` is used) or import the \`HttpClientJsonpModule\` in the root NgModule.`);
    }
    const xhrFactory = this.xhrFactory;
    const source = xhrFactory.ɵloadImpl ? from(xhrFactory.ɵloadImpl()) : of(null);
    return source.pipe(switchMap(() => {
      return new Observable((observer) => {
        const xhr = xhrFactory.build();
        xhr.open(req.method, req.urlWithParams);
        if (req.withCredentials) {
          xhr.withCredentials = true;
        }
        req.headers.forEach((name, values) => xhr.setRequestHeader(name, values.join(",")));
        if (!req.headers.has("Accept")) {
          xhr.setRequestHeader("Accept", "application/json, text/plain, */*");
        }
        if (!req.headers.has("Content-Type")) {
          const detectedType = req.detectContentTypeHeader();
          if (detectedType !== null) {
            xhr.setRequestHeader("Content-Type", detectedType);
          }
        }
        if (req.responseType) {
          const responseType = req.responseType.toLowerCase();
          xhr.responseType = responseType !== "json" ? responseType : "text";
        }
        const reqBody = req.serializeBody();
        let headerResponse = null;
        const partialFromXhr = () => {
          if (headerResponse !== null) {
            return headerResponse;
          }
          const statusText = xhr.statusText || "OK";
          const headers = new HttpHeaders(xhr.getAllResponseHeaders());
          const url = getResponseUrl(xhr) || req.url;
          headerResponse = new HttpHeaderResponse({
            headers,
            status: xhr.status,
            statusText,
            url
          });
          return headerResponse;
        };
        const onLoad = () => {
          let {
            headers,
            status,
            statusText,
            url
          } = partialFromXhr();
          let body = null;
          if (status !== HTTP_STATUS_CODE_NO_CONTENT) {
            body = typeof xhr.response === "undefined" ? xhr.responseText : xhr.response;
          }
          if (status === 0) {
            status = !!body ? HTTP_STATUS_CODE_OK : 0;
          }
          let ok = status >= 200 && status < 300;
          if (req.responseType === "json" && typeof body === "string") {
            const originalBody = body;
            body = body.replace(XSSI_PREFIX, "");
            try {
              body = body !== "" ? JSON.parse(body) : null;
            } catch (error) {
              body = originalBody;
              if (ok) {
                ok = false;
                body = {
                  error,
                  text: body
                };
              }
            }
          }
          if (ok) {
            observer.next(new HttpResponse({
              body,
              headers,
              status,
              statusText,
              url: url || void 0
            }));
            observer.complete();
          } else {
            observer.error(new HttpErrorResponse({
              // The error in this case is the response body (error from the server).
              error: body,
              headers,
              status,
              statusText,
              url: url || void 0
            }));
          }
        };
        const onError = (error) => {
          const {
            url
          } = partialFromXhr();
          const res = new HttpErrorResponse({
            error,
            status: xhr.status || 0,
            statusText: xhr.statusText || "Unknown Error",
            url: url || void 0
          });
          observer.error(res);
        };
        let sentHeaders = false;
        const onDownProgress = (event) => {
          if (!sentHeaders) {
            observer.next(partialFromXhr());
            sentHeaders = true;
          }
          let progressEvent = {
            type: HttpEventType.DownloadProgress,
            loaded: event.loaded
          };
          if (event.lengthComputable) {
            progressEvent.total = event.total;
          }
          if (req.responseType === "text" && !!xhr.responseText) {
            progressEvent.partialText = xhr.responseText;
          }
          observer.next(progressEvent);
        };
        const onUpProgress = (event) => {
          let progress = {
            type: HttpEventType.UploadProgress,
            loaded: event.loaded
          };
          if (event.lengthComputable) {
            progress.total = event.total;
          }
          observer.next(progress);
        };
        xhr.addEventListener("load", onLoad);
        xhr.addEventListener("error", onError);
        xhr.addEventListener("timeout", onError);
        xhr.addEventListener("abort", onError);
        if (req.reportProgress) {
          xhr.addEventListener("progress", onDownProgress);
          if (reqBody !== null && xhr.upload) {
            xhr.upload.addEventListener("progress", onUpProgress);
          }
        }
        xhr.send(reqBody);
        observer.next({
          type: HttpEventType.Sent
        });
        return () => {
          xhr.removeEventListener("error", onError);
          xhr.removeEventListener("abort", onError);
          xhr.removeEventListener("load", onLoad);
          xhr.removeEventListener("timeout", onError);
          if (req.reportProgress) {
            xhr.removeEventListener("progress", onDownProgress);
            if (reqBody !== null && xhr.upload) {
              xhr.upload.removeEventListener("progress", onUpProgress);
            }
          }
          if (xhr.readyState !== xhr.DONE) {
            xhr.abort();
          }
        };
      });
    }));
  }
  static {
    this.ɵfac = function HttpXhrBackend_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _HttpXhrBackend)(ɵɵinject(XhrFactory));
    };
  }
  static {
    this.ɵprov = ɵɵdefineInjectable({
      token: _HttpXhrBackend,
      factory: _HttpXhrBackend.ɵfac
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(HttpXhrBackend, [{
    type: Injectable
  }], () => [{
    type: XhrFactory
  }], null);
})();
var XSRF_ENABLED = new InjectionToken(ngDevMode ? "XSRF_ENABLED" : "");
var XSRF_DEFAULT_COOKIE_NAME = "XSRF-TOKEN";
var XSRF_COOKIE_NAME = new InjectionToken(ngDevMode ? "XSRF_COOKIE_NAME" : "", {
  providedIn: "root",
  factory: () => XSRF_DEFAULT_COOKIE_NAME
});
var XSRF_DEFAULT_HEADER_NAME = "X-XSRF-TOKEN";
var XSRF_HEADER_NAME = new InjectionToken(ngDevMode ? "XSRF_HEADER_NAME" : "", {
  providedIn: "root",
  factory: () => XSRF_DEFAULT_HEADER_NAME
});
var HttpXsrfTokenExtractor = class {
};
var HttpXsrfCookieExtractor = class _HttpXsrfCookieExtractor {
  constructor(doc, platform, cookieName) {
    this.doc = doc;
    this.platform = platform;
    this.cookieName = cookieName;
    this.lastCookieString = "";
    this.lastToken = null;
    this.parseCount = 0;
  }
  getToken() {
    if (this.platform === "server") {
      return null;
    }
    const cookieString = this.doc.cookie || "";
    if (cookieString !== this.lastCookieString) {
      this.parseCount++;
      this.lastToken = parseCookieValue(cookieString, this.cookieName);
      this.lastCookieString = cookieString;
    }
    return this.lastToken;
  }
  static {
    this.ɵfac = function HttpXsrfCookieExtractor_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _HttpXsrfCookieExtractor)(ɵɵinject(DOCUMENT), ɵɵinject(PLATFORM_ID), ɵɵinject(XSRF_COOKIE_NAME));
    };
  }
  static {
    this.ɵprov = ɵɵdefineInjectable({
      token: _HttpXsrfCookieExtractor,
      factory: _HttpXsrfCookieExtractor.ɵfac
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(HttpXsrfCookieExtractor, [{
    type: Injectable
  }], () => [{
    type: void 0,
    decorators: [{
      type: Inject,
      args: [DOCUMENT]
    }]
  }, {
    type: void 0,
    decorators: [{
      type: Inject,
      args: [PLATFORM_ID]
    }]
  }, {
    type: void 0,
    decorators: [{
      type: Inject,
      args: [XSRF_COOKIE_NAME]
    }]
  }], null);
})();
function xsrfInterceptorFn(req, next) {
  const lcUrl = req.url.toLowerCase();
  if (!inject(XSRF_ENABLED) || req.method === "GET" || req.method === "HEAD" || lcUrl.startsWith("http://") || lcUrl.startsWith("https://")) {
    return next(req);
  }
  const token = inject(HttpXsrfTokenExtractor).getToken();
  const headerName = inject(XSRF_HEADER_NAME);
  if (token != null && !req.headers.has(headerName)) {
    req = req.clone({
      headers: req.headers.set(headerName, token)
    });
  }
  return next(req);
}
var HttpXsrfInterceptor = class _HttpXsrfInterceptor {
  constructor(injector) {
    this.injector = injector;
  }
  intercept(initialRequest, next) {
    return runInInjectionContext(this.injector, () => xsrfInterceptorFn(initialRequest, (downstreamRequest) => next.handle(downstreamRequest)));
  }
  static {
    this.ɵfac = function HttpXsrfInterceptor_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _HttpXsrfInterceptor)(ɵɵinject(EnvironmentInjector));
    };
  }
  static {
    this.ɵprov = ɵɵdefineInjectable({
      token: _HttpXsrfInterceptor,
      factory: _HttpXsrfInterceptor.ɵfac
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(HttpXsrfInterceptor, [{
    type: Injectable
  }], () => [{
    type: EnvironmentInjector
  }], null);
})();
var HttpFeatureKind;
(function(HttpFeatureKind2) {
  HttpFeatureKind2[HttpFeatureKind2["Interceptors"] = 0] = "Interceptors";
  HttpFeatureKind2[HttpFeatureKind2["LegacyInterceptors"] = 1] = "LegacyInterceptors";
  HttpFeatureKind2[HttpFeatureKind2["CustomXsrfConfiguration"] = 2] = "CustomXsrfConfiguration";
  HttpFeatureKind2[HttpFeatureKind2["NoXsrfProtection"] = 3] = "NoXsrfProtection";
  HttpFeatureKind2[HttpFeatureKind2["JsonpSupport"] = 4] = "JsonpSupport";
  HttpFeatureKind2[HttpFeatureKind2["RequestsMadeViaParent"] = 5] = "RequestsMadeViaParent";
  HttpFeatureKind2[HttpFeatureKind2["Fetch"] = 6] = "Fetch";
})(HttpFeatureKind || (HttpFeatureKind = {}));
function makeHttpFeature(kind, providers) {
  return {
    ɵkind: kind,
    ɵproviders: providers
  };
}
function provideHttpClient(...features) {
  if (ngDevMode) {
    const featureKinds = new Set(features.map((f) => f.ɵkind));
    if (featureKinds.has(HttpFeatureKind.NoXsrfProtection) && featureKinds.has(HttpFeatureKind.CustomXsrfConfiguration)) {
      throw new Error(ngDevMode ? `Configuration error: found both withXsrfConfiguration() and withNoXsrfProtection() in the same call to provideHttpClient(), which is a contradiction.` : "");
    }
  }
  const providers = [HttpClient, HttpXhrBackend, HttpInterceptorHandler, {
    provide: HttpHandler,
    useExisting: HttpInterceptorHandler
  }, {
    provide: HttpBackend,
    useFactory: () => {
      return inject(FetchBackend, {
        optional: true
      }) ?? inject(HttpXhrBackend);
    }
  }, {
    provide: HTTP_INTERCEPTOR_FNS,
    useValue: xsrfInterceptorFn,
    multi: true
  }, {
    provide: XSRF_ENABLED,
    useValue: true
  }, {
    provide: HttpXsrfTokenExtractor,
    useClass: HttpXsrfCookieExtractor
  }];
  for (const feature of features) {
    providers.push(...feature.ɵproviders);
  }
  return makeEnvironmentProviders(providers);
}
function withInterceptors(interceptorFns) {
  return makeHttpFeature(HttpFeatureKind.Interceptors, interceptorFns.map((interceptorFn) => {
    return {
      provide: HTTP_INTERCEPTOR_FNS,
      useValue: interceptorFn,
      multi: true
    };
  }));
}
var LEGACY_INTERCEPTOR_FN = new InjectionToken(ngDevMode ? "LEGACY_INTERCEPTOR_FN" : "");
function withInterceptorsFromDi() {
  return makeHttpFeature(HttpFeatureKind.LegacyInterceptors, [{
    provide: LEGACY_INTERCEPTOR_FN,
    useFactory: legacyInterceptorFnFactory
  }, {
    provide: HTTP_INTERCEPTOR_FNS,
    useExisting: LEGACY_INTERCEPTOR_FN,
    multi: true
  }]);
}
function withXsrfConfiguration({
  cookieName,
  headerName
}) {
  const providers = [];
  if (cookieName !== void 0) {
    providers.push({
      provide: XSRF_COOKIE_NAME,
      useValue: cookieName
    });
  }
  if (headerName !== void 0) {
    providers.push({
      provide: XSRF_HEADER_NAME,
      useValue: headerName
    });
  }
  return makeHttpFeature(HttpFeatureKind.CustomXsrfConfiguration, providers);
}
function withNoXsrfProtection() {
  return makeHttpFeature(HttpFeatureKind.NoXsrfProtection, [{
    provide: XSRF_ENABLED,
    useValue: false
  }]);
}
function withJsonpSupport() {
  return makeHttpFeature(HttpFeatureKind.JsonpSupport, [JsonpClientBackend, {
    provide: JsonpCallbackContext,
    useFactory: jsonpCallbackContext
  }, {
    provide: HTTP_INTERCEPTOR_FNS,
    useValue: jsonpInterceptorFn,
    multi: true
  }]);
}
function withRequestsMadeViaParent() {
  return makeHttpFeature(HttpFeatureKind.RequestsMadeViaParent, [{
    provide: HttpBackend,
    useFactory: () => {
      const handlerFromParent = inject(HttpHandler, {
        skipSelf: true,
        optional: true
      });
      if (ngDevMode && handlerFromParent === null) {
        throw new Error("withRequestsMadeViaParent() can only be used when the parent injector also configures HttpClient");
      }
      return handlerFromParent;
    }
  }]);
}
function withFetch() {
  return makeHttpFeature(HttpFeatureKind.Fetch, [FetchBackend, {
    provide: HttpBackend,
    useExisting: FetchBackend
  }]);
}
var HttpClientXsrfModule = class _HttpClientXsrfModule {
  /**
   * Disable the default XSRF protection.
   */
  static disable() {
    return {
      ngModule: _HttpClientXsrfModule,
      providers: [withNoXsrfProtection().ɵproviders]
    };
  }
  /**
   * Configure XSRF protection.
   * @param options An object that can specify either or both
   * cookie name or header name.
   * - Cookie name default is `XSRF-TOKEN`.
   * - Header name default is `X-XSRF-TOKEN`.
   *
   */
  static withOptions(options = {}) {
    return {
      ngModule: _HttpClientXsrfModule,
      providers: withXsrfConfiguration(options).ɵproviders
    };
  }
  static {
    this.ɵfac = function HttpClientXsrfModule_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _HttpClientXsrfModule)();
    };
  }
  static {
    this.ɵmod = ɵɵdefineNgModule({
      type: _HttpClientXsrfModule
    });
  }
  static {
    this.ɵinj = ɵɵdefineInjector({
      providers: [HttpXsrfInterceptor, {
        provide: HTTP_INTERCEPTORS,
        useExisting: HttpXsrfInterceptor,
        multi: true
      }, {
        provide: HttpXsrfTokenExtractor,
        useClass: HttpXsrfCookieExtractor
      }, withXsrfConfiguration({
        cookieName: XSRF_DEFAULT_COOKIE_NAME,
        headerName: XSRF_DEFAULT_HEADER_NAME
      }).ɵproviders, {
        provide: XSRF_ENABLED,
        useValue: true
      }]
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(HttpClientXsrfModule, [{
    type: NgModule,
    args: [{
      providers: [HttpXsrfInterceptor, {
        provide: HTTP_INTERCEPTORS,
        useExisting: HttpXsrfInterceptor,
        multi: true
      }, {
        provide: HttpXsrfTokenExtractor,
        useClass: HttpXsrfCookieExtractor
      }, withXsrfConfiguration({
        cookieName: XSRF_DEFAULT_COOKIE_NAME,
        headerName: XSRF_DEFAULT_HEADER_NAME
      }).ɵproviders, {
        provide: XSRF_ENABLED,
        useValue: true
      }]
    }]
  }], null, null);
})();
var HttpClientModule = class _HttpClientModule {
  static {
    this.ɵfac = function HttpClientModule_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _HttpClientModule)();
    };
  }
  static {
    this.ɵmod = ɵɵdefineNgModule({
      type: _HttpClientModule
    });
  }
  static {
    this.ɵinj = ɵɵdefineInjector({
      providers: [provideHttpClient(withInterceptorsFromDi())]
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(HttpClientModule, [{
    type: NgModule,
    args: [{
      /**
       * Configures the dependency injector where it is imported
       * with supporting services for HTTP communications.
       */
      providers: [provideHttpClient(withInterceptorsFromDi())]
    }]
  }], null, null);
})();
var HttpClientJsonpModule = class _HttpClientJsonpModule {
  static {
    this.ɵfac = function HttpClientJsonpModule_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _HttpClientJsonpModule)();
    };
  }
  static {
    this.ɵmod = ɵɵdefineNgModule({
      type: _HttpClientJsonpModule
    });
  }
  static {
    this.ɵinj = ɵɵdefineInjector({
      providers: [withJsonpSupport().ɵproviders]
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(HttpClientJsonpModule, [{
    type: NgModule,
    args: [{
      providers: [withJsonpSupport().ɵproviders]
    }]
  }], null, null);
})();
var HTTP_TRANSFER_CACHE_ORIGIN_MAP = new InjectionToken(ngDevMode ? "HTTP_TRANSFER_CACHE_ORIGIN_MAP" : "");
var BODY = "b";
var HEADERS = "h";
var STATUS = "s";
var STATUS_TEXT = "st";
var REQ_URL = "u";
var RESPONSE_TYPE = "rt";
var CACHE_OPTIONS = new InjectionToken(ngDevMode ? "HTTP_TRANSFER_STATE_CACHE_OPTIONS" : "");
var ALLOWED_METHODS = ["GET", "HEAD"];
function transferCacheInterceptorFn(req, next) {
  const _a = inject(CACHE_OPTIONS), {
    isCacheActive
  } = _a, globalOptions = __objRest(_a, [
    "isCacheActive"
  ]);
  const {
    transferCache: requestOptions,
    method: requestMethod
  } = req;
  if (!isCacheActive || requestOptions === false || // POST requests are allowed either globally or at request level
  requestMethod === "POST" && !globalOptions.includePostRequests && !requestOptions || requestMethod !== "POST" && !ALLOWED_METHODS.includes(requestMethod) || // Do not cache request that require authorization when includeRequestsWithAuthHeaders is falsey
  !globalOptions.includeRequestsWithAuthHeaders && hasAuthHeaders(req) || globalOptions.filter?.(req) === false) {
    return next(req);
  }
  const transferState = inject(TransferState);
  const originMap = inject(HTTP_TRANSFER_CACHE_ORIGIN_MAP, {
    optional: true
  });
  const isServer = isPlatformServer(inject(PLATFORM_ID));
  if (originMap && !isServer) {
    throw new RuntimeError(2803, ngDevMode && "Angular detected that the `HTTP_TRANSFER_CACHE_ORIGIN_MAP` token is configured and present in the client side code. Please ensure that this token is only provided in the server code of the application.");
  }
  const requestUrl = isServer && originMap ? mapRequestOriginUrl(req.url, originMap) : req.url;
  const storeKey = makeCacheKey(req, requestUrl);
  const response = transferState.get(storeKey, null);
  let headersToInclude = globalOptions.includeHeaders;
  if (typeof requestOptions === "object" && requestOptions.includeHeaders) {
    headersToInclude = requestOptions.includeHeaders;
  }
  if (response) {
    const {
      [BODY]: undecodedBody,
      [RESPONSE_TYPE]: responseType,
      [HEADERS]: httpHeaders,
      [STATUS]: status,
      [STATUS_TEXT]: statusText,
      [REQ_URL]: url
    } = response;
    let body = undecodedBody;
    switch (responseType) {
      case "arraybuffer":
        body = new TextEncoder().encode(undecodedBody).buffer;
        break;
      case "blob":
        body = new Blob([undecodedBody]);
        break;
    }
    let headers = new HttpHeaders(httpHeaders);
    if (typeof ngDevMode === "undefined" || ngDevMode) {
      headers = appendMissingHeadersDetection(req.url, headers, headersToInclude ?? []);
    }
    return of(new HttpResponse({
      body,
      headers,
      status,
      statusText,
      url
    }));
  }
  return next(req).pipe(tap((event) => {
    if (event instanceof HttpResponse && isServer) {
      transferState.set(storeKey, {
        [BODY]: event.body,
        [HEADERS]: getFilteredHeaders(event.headers, headersToInclude),
        [STATUS]: event.status,
        [STATUS_TEXT]: event.statusText,
        [REQ_URL]: requestUrl,
        [RESPONSE_TYPE]: req.responseType
      });
    }
  }));
}
function hasAuthHeaders(req) {
  return req.headers.has("authorization") || req.headers.has("proxy-authorization");
}
function getFilteredHeaders(headers, includeHeaders) {
  if (!includeHeaders) {
    return {};
  }
  const headersMap = {};
  for (const key of includeHeaders) {
    const values = headers.getAll(key);
    if (values !== null) {
      headersMap[key] = values;
    }
  }
  return headersMap;
}
function sortAndConcatParams(params) {
  return [...params.keys()].sort().map((k) => `${k}=${params.getAll(k)}`).join("&");
}
function makeCacheKey(request, mappedRequestUrl) {
  const {
    params,
    method,
    responseType
  } = request;
  const encodedParams = sortAndConcatParams(params);
  let serializedBody = request.serializeBody();
  if (serializedBody instanceof URLSearchParams) {
    serializedBody = sortAndConcatParams(serializedBody);
  } else if (typeof serializedBody !== "string") {
    serializedBody = "";
  }
  const key = [method, responseType, mappedRequestUrl, serializedBody, encodedParams].join("|");
  const hash = generateHash(key);
  return makeStateKey(hash);
}
function generateHash(value) {
  let hash = 0;
  for (const char of value) {
    hash = Math.imul(31, hash) + char.charCodeAt(0) << 0;
  }
  hash += 2147483647 + 1;
  return hash.toString();
}
function withHttpTransferCache(cacheOptions) {
  return [{
    provide: CACHE_OPTIONS,
    useFactory: () => {
      performanceMarkFeature("NgHttpTransferCache");
      return __spreadValues({
        isCacheActive: true
      }, cacheOptions);
    }
  }, {
    provide: HTTP_ROOT_INTERCEPTOR_FNS,
    useValue: transferCacheInterceptorFn,
    multi: true,
    deps: [TransferState, CACHE_OPTIONS]
  }, {
    provide: APP_BOOTSTRAP_LISTENER,
    multi: true,
    useFactory: () => {
      const appRef = inject(ApplicationRef);
      const cacheState = inject(CACHE_OPTIONS);
      return () => {
        whenStable(appRef).then(() => {
          cacheState.isCacheActive = false;
        });
      };
    }
  }];
}
function appendMissingHeadersDetection(url, headers, headersToInclude) {
  const warningProduced = /* @__PURE__ */ new Set();
  return new Proxy(headers, {
    get(target, prop) {
      const value = Reflect.get(target, prop);
      const methods = /* @__PURE__ */ new Set(["get", "has", "getAll"]);
      if (typeof value !== "function" || !methods.has(prop)) {
        return value;
      }
      return (headerName) => {
        const key = (prop + ":" + headerName).toLowerCase();
        if (!headersToInclude.includes(headerName) && !warningProduced.has(key)) {
          warningProduced.add(key);
          const truncatedUrl = truncateMiddle(url);
          console.warn(formatRuntimeError(2802, `Angular detected that the \`${headerName}\` header is accessed, but the value of the header was not transferred from the server to the client by the HttpTransferCache. To include the value of the \`${headerName}\` header for the \`${truncatedUrl}\` request, use the \`includeHeaders\` list. The \`includeHeaders\` can be defined either on a request level by adding the \`transferCache\` parameter, or on an application level by adding the \`httpCacheTransfer.includeHeaders\` argument to the \`provideClientHydration()\` call. `));
        }
        return value.apply(target, [headerName]);
      };
    }
  });
}
function mapRequestOriginUrl(url, originMap) {
  const origin = new URL(url, "resolve://").origin;
  const mappedOrigin = originMap[origin];
  if (!mappedOrigin) {
    return url;
  }
  if (typeof ngDevMode === "undefined" || ngDevMode) {
    verifyMappedOrigin(mappedOrigin);
  }
  return url.replace(origin, mappedOrigin);
}
function verifyMappedOrigin(url) {
  if (new URL(url, "resolve://").pathname !== "/") {
    throw new RuntimeError(2804, `Angular detected a URL with a path segment in the value provided for the \`HTTP_TRANSFER_CACHE_ORIGIN_MAP\` token: ${url}. The map should only contain origins without any other segments.`);
  }
}
export {
  FetchBackend,
  HTTP_INTERCEPTORS,
  HTTP_TRANSFER_CACHE_ORIGIN_MAP,
  HttpBackend,
  HttpClient,
  HttpClientJsonpModule,
  HttpClientModule,
  HttpClientXsrfModule,
  HttpContext,
  HttpContextToken,
  HttpErrorResponse,
  HttpEventType,
  HttpFeatureKind,
  HttpHandler,
  HttpHeaderResponse,
  HttpHeaders,
  HttpParams,
  HttpRequest,
  HttpResponse,
  HttpResponseBase,
  HttpStatusCode,
  HttpUrlEncodingCodec,
  HttpXhrBackend,
  HttpXsrfTokenExtractor,
  JsonpClientBackend,
  JsonpInterceptor,
  provideHttpClient,
  withFetch,
  withInterceptors,
  withInterceptorsFromDi,
  withJsonpSupport,
  withNoXsrfProtection,
  withRequestsMadeViaParent,
  withXsrfConfiguration,
  HTTP_ROOT_INTERCEPTOR_FNS as ɵHTTP_ROOT_INTERCEPTOR_FNS,
  HttpInterceptorHandler as ɵHttpInterceptingHandler,
  HttpInterceptorHandler as ɵHttpInterceptorHandler,
  REQUESTS_CONTRIBUTE_TO_STABILITY as ɵREQUESTS_CONTRIBUTE_TO_STABILITY,
  withHttpTransferCache as ɵwithHttpTransferCache
};
/*! Bundled license information:

@angular/common/fesm2022/http.mjs:
  (**
   * @license Angular v18.2.0
   * (c) 2010-2024 Google LLC. https://angular.io/
   * License: MIT
   *)
*/
//# sourceMappingURL=@angular_common_http.js.map



================================================
FILE: .angular/cache/18.2.20/angular-pivothead-example/vite/deps/@angular_core.js
================================================
import {
  ALLOW_MULTIPLE_PLATFORMS,
  ANIMATION_MODULE_TYPE,
  APP_BOOTSTRAP_LISTENER,
  APP_ID,
  APP_INITIALIZER,
  AfterRenderEventManager,
  AfterRenderPhase,
  ApplicationInitStatus,
  ApplicationModule,
  ApplicationRef,
  Attribute,
  COMPILER_OPTIONS,
  CONTAINER_HEADER_OFFSET,
  CSP_NONCE,
  CUSTOM_ELEMENTS_SCHEMA,
  ChangeDetectionScheduler,
  ChangeDetectionSchedulerImpl,
  ChangeDetectionStrategy,
  ChangeDetectorRef,
  Compiler,
  CompilerFactory,
  Component,
  ComponentFactory,
  ComponentFactory$1,
  ComponentFactoryResolver$1,
  ComponentRef,
  ComponentRef$1,
  Console,
  ContentChild,
  ContentChildren,
  DEFAULT_CURRENCY_CODE,
  DEFAULT_LOCALE_ID,
  DEFER_BLOCK_CONFIG,
  DEFER_BLOCK_DEPENDENCY_INTERCEPTOR,
  DebugElement,
  DebugEventListener,
  DebugNode,
  DefaultIterableDiffer,
  DeferBlockBehavior,
  DeferBlockState,
  DestroyRef,
  Directive,
  ENVIRONMENT_INITIALIZER,
  EffectScheduler,
  ElementRef,
  EmbeddedViewRef,
  EnvironmentInjector,
  ErrorHandler,
  EventEmitter,
  ExperimentalPendingTasks,
  FactoryTarget,
  GLOBAL_EVENT_DELEGATION,
  HOST_TAG_NAME,
  Host,
  HostAttributeToken,
  HostBinding,
  HostListener,
  IMAGE_CONFIG,
  IMAGE_CONFIG_DEFAULTS,
  INJECTOR$1,
  INJECTOR_SCOPE,
  INTERNAL_APPLICATION_ERROR_HANDLER,
  IS_HYDRATION_DOM_REUSE_ENABLED,
  Inject,
  InjectFlags,
  Injectable,
  InjectionToken,
  Injector,
  Input,
  IterableDiffers,
  JSACTION_EVENT_CONTRACT,
  KeyValueDiffers,
  LContext,
  LOCALE_ID,
  LifecycleHooksFeature,
  LocaleDataIndex,
  MissingTranslationStrategy,
  ModuleWithComponentFactories,
  NG_COMP_DEF,
  NG_DIR_DEF,
  NG_ELEMENT_ID,
  NG_INJ_DEF,
  NG_MOD_DEF,
  NG_PIPE_DEF,
  NG_PROV_DEF,
  NOT_FOUND_CHECK_ONLY_ELEMENT_INJECTOR,
  NO_CHANGE,
  NO_ERRORS_SCHEMA,
  NgModule,
  NgModuleFactory,
  NgModuleFactory$1,
  NgModuleRef,
  NgModuleRef$1,
  NgProbeToken,
  NgZone,
  NoopNgZone,
  Optional,
  Output,
  OutputEmitterRef,
  PACKAGE_ROOT_URL,
  PLATFORM_ID,
  PLATFORM_INITIALIZER,
  PROVIDED_NG_ZONE,
  PendingTasks,
  Pipe,
  PlatformRef,
  Query,
  QueryList,
  ReflectionCapabilities,
  Renderer2,
  RendererFactory2,
  RendererStyleFlags2,
  RuntimeError,
  SSR_CONTENT_INTEGRITY_MARKER,
  Sanitizer,
  SecurityContext,
  Self,
  SimpleChange,
  SkipSelf,
  TESTABILITY,
  TESTABILITY_GETTER,
  TRANSLATIONS,
  TRANSLATIONS_FORMAT,
  TemplateRef,
  Testability,
  TestabilityRegistry,
  TransferState,
  Type,
  USE_RUNTIME_DEPS_TRACKER_FOR_JIT,
  VERSION,
  Version,
  ViewChild,
  ViewChildren,
  ViewContainerRef,
  ViewEncapsulation$1,
  ViewRef,
  ViewRef$1,
  XSS_SECURITY_URL,
  ZONELESS_ENABLED,
  _global,
  _sanitizeHtml,
  _sanitizeUrl,
  afterNextRender,
  afterRender,
  allowSanitizationBypassAndThrow,
  annotateForHydration,
  asNativeElements,
  assertInInjectionContext,
  assertNotInReactiveContext,
  assertPlatform,
  booleanAttribute,
  bypassSanitizationTrustHtml,
  bypassSanitizationTrustResourceUrl,
  bypassSanitizationTrustScript,
  bypassSanitizationTrustStyle,
  bypassSanitizationTrustUrl,
  clearResolutionOfComponentResourcesQueue,
  compileComponent,
  compileDirective,
  compileNgModule,
  compileNgModuleDefs,
  compileNgModuleFactory,
  compilePipe,
  computed,
  contentChild,
  contentChildren,
  convertToBitFlags,
  createComponent,
  createEnvironmentInjector,
  createInjector,
  createNgModule,
  createNgModuleRef,
  createPlatform,
  createPlatformFactory,
  defaultIterableDiffers,
  defaultKeyValueDiffers,
  defineInjectable,
  depsTracker,
  destroyPlatform,
  detectChangesInViewIfRequired,
  devModeEqual,
  effect,
  enableProdMode,
  findLocaleData,
  flushModuleScopingQueueAsMuchAsPossible,
  formatRuntimeError,
  forwardRef,
  generateStandaloneInDeclarationsError,
  getAsyncClassMetadataFn,
  getDebugNode,
  getDeferBlocks,
  getDirectives,
  getHostElement,
  getInjectableDef,
  getLContext,
  getLocaleCurrencyCode,
  getLocalePluralCase,
  getModuleFactory,
  getNgModuleById,
  getOutputDestroyRef,
  getPlatform,
  getSanitizationBypassType,
  importProvidersFrom,
  inject,
  injectChangeDetectorRef,
  input,
  internalAfterNextRender,
  internalCreateApplication,
  internalProvideZoneChangeDetection,
  isBoundToModule,
  isComponentDefPendingResolution,
  isDevMode,
  isEnvironmentProviders,
  isInjectable,
  isNgModule,
  isPromise,
  isSignal,
  isStandalone,
  isSubscribable,
  makeEnvironmentProviders,
  makeStateKey,
  mergeApplicationConfig,
  model,
  noSideEffects,
  numberAttribute,
  output,
  patchComponentDefWithScope,
  performanceMarkFeature,
  platformCore,
  provideExperimentalCheckNoChangesForDebug,
  provideExperimentalZonelessChangeDetection,
  provideGlobalEventDelegation,
  provideZoneChangeDetection,
  queueStateUpdate,
  readHydrationInfo,
  reflectComponentType,
  registerLocaleData,
  registerNgModuleType,
  renderDeferBlockState,
  resetCompiledComponents,
  resetJitOptions,
  resolveComponentResources,
  resolveForwardRef,
  restoreComponentResolutionQueue,
  runInInjectionContext,
  setAllowDuplicateNgModuleIdsForTest,
  setAlternateWeakRefImpl,
  setClassMetadata,
  setClassMetadataAsync,
  setCurrentInjector,
  setDocument,
  setInjectorProfilerContext,
  setLocaleId,
  setTestabilityGetter,
  signal,
  store,
  stringify,
  transitiveScopesFor,
  triggerResourceLoading,
  truncateMiddle,
  unregisterAllLocaleData,
  untracked,
  unwrapSafeValue,
  viewChild,
  viewChildren,
  whenStable,
  withDomHydration,
  withEventReplay,
  withI18nSupport,
  ɵINPUT_SIGNAL_BRAND_WRITE_TYPE,
  ɵgetUnknownElementStrictMode,
  ɵgetUnknownPropertyStrictMode,
  ɵsetClassDebugInfo,
  ɵsetUnknownElementStrictMode,
  ɵsetUnknownPropertyStrictMode,
  ɵunwrapWritableSignal,
  ɵɵCopyDefinitionFeature,
  ɵɵHostDirectivesFeature,
  ɵɵInheritDefinitionFeature,
  ɵɵInputTransformsFeature,
  ɵɵNgOnChangesFeature,
  ɵɵProvidersFeature,
  ɵɵStandaloneFeature,
  ɵɵadvance,
  ɵɵattribute,
  ɵɵattributeInterpolate1,
  ɵɵattributeInterpolate2,
  ɵɵattributeInterpolate3,
  ɵɵattributeInterpolate4,
  ɵɵattributeInterpolate5,
  ɵɵattributeInterpolate6,
  ɵɵattributeInterpolate7,
  ɵɵattributeInterpolate8,
  ɵɵattributeInterpolateV,
  ɵɵclassMap,
  ɵɵclassMapInterpolate1,
  ɵɵclassMapInterpolate2,
  ɵɵclassMapInterpolate3,
  ɵɵclassMapInterpolate4,
  ɵɵclassMapInterpolate5,
  ɵɵclassMapInterpolate6,
  ɵɵclassMapInterpolate7,
  ɵɵclassMapInterpolate8,
  ɵɵclassMapInterpolateV,
  ɵɵclassProp,
  ɵɵcomponentInstance,
  ɵɵconditional,
  ɵɵcontentQuery,
  ɵɵcontentQuerySignal,
  ɵɵdeclareLet,
  ɵɵdefer,
  ɵɵdeferEnableTimerScheduling,
  ɵɵdeferOnHover,
  ɵɵdeferOnIdle,
  ɵɵdeferOnImmediate,
  ɵɵdeferOnInteraction,
  ɵɵdeferOnTimer,
  ɵɵdeferOnViewport,
  ɵɵdeferPrefetchOnHover,
  ɵɵdeferPrefetchOnIdle,
  ɵɵdeferPrefetchOnImmediate,
  ɵɵdeferPrefetchOnInteraction,
  ɵɵdeferPrefetchOnTimer,
  ɵɵdeferPrefetchOnViewport,
  ɵɵdeferPrefetchWhen,
  ɵɵdeferWhen,
  ɵɵdefineComponent,
  ɵɵdefineDirective,
  ɵɵdefineInjectable,
  ɵɵdefineInjector,
  ɵɵdefineNgModule,
  ɵɵdefinePipe,
  ɵɵdirectiveInject,
  ɵɵdisableBindings,
  ɵɵelement,
  ɵɵelementContainer,
  ɵɵelementContainerEnd,
  ɵɵelementContainerStart,
  ɵɵelementEnd,
  ɵɵelementStart,
  ɵɵenableBindings,
  ɵɵgetComponentDepsFactory,
  ɵɵgetCurrentView,
  ɵɵgetInheritedFactory,
  ɵɵhostProperty,
  ɵɵi18n,
  ɵɵi18nApply,
  ɵɵi18nAttributes,
  ɵɵi18nEnd,
  ɵɵi18nExp,
  ɵɵi18nPostprocess,
  ɵɵi18nStart,
  ɵɵinject,
  ɵɵinjectAttribute,
  ɵɵinvalidFactory,
  ɵɵinvalidFactoryDep,
  ɵɵlistener,
  ɵɵloadQuery,
  ɵɵnamespaceHTML,
  ɵɵnamespaceMathML,
  ɵɵnamespaceSVG,
  ɵɵnextContext,
  ɵɵngDeclareClassMetadata,
  ɵɵngDeclareClassMetadataAsync,
  ɵɵngDeclareComponent,
  ɵɵngDeclareDirective,
  ɵɵngDeclareFactory,
  ɵɵngDeclareInjectable,
  ɵɵngDeclareInjector,
  ɵɵngDeclareNgModule,
  ɵɵngDeclarePipe,
  ɵɵpipe,
  ɵɵpipeBind1,
  ɵɵpipeBind2,
  ɵɵpipeBind3,
  ɵɵpipeBind4,
  ɵɵpipeBindV,
  ɵɵprojection,
  ɵɵprojectionDef,
  ɵɵproperty,
  ɵɵpropertyInterpolate,
  ɵɵpropertyInterpolate1,
  ɵɵpropertyInterpolate2,
  ɵɵpropertyInterpolate3,
  ɵɵpropertyInterpolate4,
  ɵɵpropertyInterpolate5,
  ɵɵpropertyInterpolate6,
  ɵɵpropertyInterpolate7,
  ɵɵpropertyInterpolate8,
  ɵɵpropertyInterpolateV,
  ɵɵpureFunction0,
  ɵɵpureFunction1,
  ɵɵpureFunction2,
  ɵɵpureFunction3,
  ɵɵpureFunction4,
  ɵɵpureFunction5,
  ɵɵpureFunction6,
  ɵɵpureFunction7,
  ɵɵpureFunction8,
  ɵɵpureFunctionV,
  ɵɵqueryAdvance,
  ɵɵqueryRefresh,
  ɵɵreadContextLet,
  ɵɵreference,
  ɵɵrepeater,
  ɵɵrepeaterCreate,
  ɵɵrepeaterTrackByIdentity,
  ɵɵrepeaterTrackByIndex,
  ɵɵresetView,
  ɵɵresolveBody,
  ɵɵresolveDocument,
  ɵɵresolveWindow,
  ɵɵrestoreView,
  ɵɵsanitizeHtml,
  ɵɵsanitizeResourceUrl,
  ɵɵsanitizeScript,
  ɵɵsanitizeStyle,
  ɵɵsanitizeUrl,
  ɵɵsanitizeUrlOrResourceUrl,
  ɵɵsetComponentScope,
  ɵɵsetNgModuleScope,
  ɵɵstoreLet,
  ɵɵstyleMap,
  ɵɵstyleMapInterpolate1,
  ɵɵstyleMapInterpolate2,
  ɵɵstyleMapInterpolate3,
  ɵɵstyleMapInterpolate4,
  ɵɵstyleMapInterpolate5,
  ɵɵstyleMapInterpolate6,
  ɵɵstyleMapInterpolate7,
  ɵɵstyleMapInterpolate8,
  ɵɵstyleMapInterpolateV,
  ɵɵstyleProp,
  ɵɵstylePropInterpolate1,
  ɵɵstylePropInterpolate2,
  ɵɵstylePropInterpolate3,
  ɵɵstylePropInterpolate4,
  ɵɵstylePropInterpolate5,
  ɵɵstylePropInterpolate6,
  ɵɵstylePropInterpolate7,
  ɵɵstylePropInterpolate8,
  ɵɵstylePropInterpolateV,
  ɵɵsyntheticHostListener,
  ɵɵsyntheticHostProperty,
  ɵɵtemplate,
  ɵɵtemplateRefExtractor,
  ɵɵtext,
  ɵɵtextInterpolate,
  ɵɵtextInterpolate1,
  ɵɵtextInterpolate2,
  ɵɵtextInterpolate3,
  ɵɵtextInterpolate4,
  ɵɵtextInterpolate5,
  ɵɵtextInterpolate6,
  ɵɵtextInterpolate7,
  ɵɵtextInterpolate8,
  ɵɵtextInterpolateV,
  ɵɵtrustConstantHtml,
  ɵɵtrustConstantResourceUrl,
  ɵɵtwoWayBindingSet,
  ɵɵtwoWayListener,
  ɵɵtwoWayProperty,
  ɵɵvalidateIframeAttribute,
  ɵɵviewQuery,
  ɵɵviewQuerySignal
} from "./chunk-2VVDJA4L.js";
import "./chunk-VKET2LIV.js";
import "./chunk-HHOT2EEL.js";
import "./chunk-5NODSH2C.js";
import "./chunk-LPUAGQXJ.js";
import "./chunk-OVFEQSRS.js";
import "./chunk-WDMUDEB6.js";
export {
  ANIMATION_MODULE_TYPE,
  APP_BOOTSTRAP_LISTENER,
  APP_ID,
  APP_INITIALIZER,
  AfterRenderPhase,
  ApplicationInitStatus,
  ApplicationModule,
  ApplicationRef,
  Attribute,
  COMPILER_OPTIONS,
  CSP_NONCE,
  CUSTOM_ELEMENTS_SCHEMA,
  ChangeDetectionStrategy,
  ChangeDetectorRef,
  Compiler,
  CompilerFactory,
  Component,
  ComponentFactory$1 as ComponentFactory,
  ComponentFactoryResolver$1 as ComponentFactoryResolver,
  ComponentRef$1 as ComponentRef,
  ContentChild,
  ContentChildren,
  DEFAULT_CURRENCY_CODE,
  DebugElement,
  DebugEventListener,
  DebugNode,
  DefaultIterableDiffer,
  DestroyRef,
  Directive,
  ENVIRONMENT_INITIALIZER,
  ElementRef,
  EmbeddedViewRef,
  EnvironmentInjector,
  ErrorHandler,
  EventEmitter,
  ExperimentalPendingTasks,
  HOST_TAG_NAME,
  Host,
  HostAttributeToken,
  HostBinding,
  HostListener,
  INJECTOR$1 as INJECTOR,
  Inject,
  InjectFlags,
  Injectable,
  InjectionToken,
  Injector,
  Input,
  IterableDiffers,
  KeyValueDiffers,
  LOCALE_ID,
  MissingTranslationStrategy,
  ModuleWithComponentFactories,
  NO_ERRORS_SCHEMA,
  NgModule,
  NgModuleFactory$1 as NgModuleFactory,
  NgModuleRef$1 as NgModuleRef,
  NgProbeToken,
  NgZone,
  Optional,
  Output,
  OutputEmitterRef,
  PACKAGE_ROOT_URL,
  PLATFORM_ID,
  PLATFORM_INITIALIZER,
  Pipe,
  PlatformRef,
  Query,
  QueryList,
  Renderer2,
  RendererFactory2,
  RendererStyleFlags2,
  Sanitizer,
  SecurityContext,
  Self,
  SimpleChange,
  SkipSelf,
  TRANSLATIONS,
  TRANSLATIONS_FORMAT,
  TemplateRef,
  Testability,
  TestabilityRegistry,
  TransferState,
  Type,
  VERSION,
  Version,
  ViewChild,
  ViewChildren,
  ViewContainerRef,
  ViewEncapsulation$1 as ViewEncapsulation,
  ViewRef,
  afterNextRender,
  afterRender,
  asNativeElements,
  assertInInjectionContext,
  assertNotInReactiveContext,
  assertPlatform,
  booleanAttribute,
  computed,
  contentChild,
  contentChildren,
  createComponent,
  createEnvironmentInjector,
  createNgModule,
  createNgModuleRef,
  createPlatform,
  createPlatformFactory,
  defineInjectable,
  destroyPlatform,
  effect,
  enableProdMode,
  forwardRef,
  getDebugNode,
  getModuleFactory,
  getNgModuleById,
  getPlatform,
  importProvidersFrom,
  inject,
  input,
  isDevMode,
  isSignal,
  isStandalone,
  makeEnvironmentProviders,
  makeStateKey,
  mergeApplicationConfig,
  model,
  numberAttribute,
  output,
  platformCore,
  provideExperimentalCheckNoChangesForDebug,
  provideExperimentalZonelessChangeDetection,
  provideZoneChangeDetection,
  reflectComponentType,
  resolveForwardRef,
  runInInjectionContext,
  setTestabilityGetter,
  signal,
  untracked,
  viewChild,
  viewChildren,
  ALLOW_MULTIPLE_PLATFORMS as ɵALLOW_MULTIPLE_PLATFORMS,
  AfterRenderEventManager as ɵAfterRenderEventManager,
  CONTAINER_HEADER_OFFSET as ɵCONTAINER_HEADER_OFFSET,
  ChangeDetectionScheduler as ɵChangeDetectionScheduler,
  ChangeDetectionSchedulerImpl as ɵChangeDetectionSchedulerImpl,
  ComponentFactory$1 as ɵComponentFactory,
  Console as ɵConsole,
  DEFAULT_LOCALE_ID as ɵDEFAULT_LOCALE_ID,
  DEFER_BLOCK_CONFIG as ɵDEFER_BLOCK_CONFIG,
  DEFER_BLOCK_DEPENDENCY_INTERCEPTOR as ɵDEFER_BLOCK_DEPENDENCY_INTERCEPTOR,
  DeferBlockBehavior as ɵDeferBlockBehavior,
  DeferBlockState as ɵDeferBlockState,
  EffectScheduler as ɵEffectScheduler,
  GLOBAL_EVENT_DELEGATION as ɵGLOBAL_EVENT_DELEGATION,
  IMAGE_CONFIG as ɵIMAGE_CONFIG,
  IMAGE_CONFIG_DEFAULTS as ɵIMAGE_CONFIG_DEFAULTS,
  INJECTOR_SCOPE as ɵINJECTOR_SCOPE,
  ɵINPUT_SIGNAL_BRAND_WRITE_TYPE,
  INTERNAL_APPLICATION_ERROR_HANDLER as ɵINTERNAL_APPLICATION_ERROR_HANDLER,
  IS_HYDRATION_DOM_REUSE_ENABLED as ɵIS_HYDRATION_DOM_REUSE_ENABLED,
  JSACTION_EVENT_CONTRACT as ɵJSACTION_EVENT_CONTRACT,
  LContext as ɵLContext,
  LifecycleHooksFeature as ɵLifecycleHooksFeature,
  LocaleDataIndex as ɵLocaleDataIndex,
  NG_COMP_DEF as ɵNG_COMP_DEF,
  NG_DIR_DEF as ɵNG_DIR_DEF,
  NG_ELEMENT_ID as ɵNG_ELEMENT_ID,
  NG_INJ_DEF as ɵNG_INJ_DEF,
  NG_MOD_DEF as ɵNG_MOD_DEF,
  NG_PIPE_DEF as ɵNG_PIPE_DEF,
  NG_PROV_DEF as ɵNG_PROV_DEF,
  NOT_FOUND_CHECK_ONLY_ELEMENT_INJECTOR as ɵNOT_FOUND_CHECK_ONLY_ELEMENT_INJECTOR,
  NO_CHANGE as ɵNO_CHANGE,
  NgModuleFactory as ɵNgModuleFactory,
  NoopNgZone as ɵNoopNgZone,
  PROVIDED_NG_ZONE as ɵPROVIDED_NG_ZONE,
  PendingTasks as ɵPendingTasks,
  ReflectionCapabilities as ɵReflectionCapabilities,
  ComponentFactory as ɵRender3ComponentFactory,
  ComponentRef as ɵRender3ComponentRef,
  NgModuleRef as ɵRender3NgModuleRef,
  RuntimeError as ɵRuntimeError,
  SSR_CONTENT_INTEGRITY_MARKER as ɵSSR_CONTENT_INTEGRITY_MARKER,
  TESTABILITY as ɵTESTABILITY,
  TESTABILITY_GETTER as ɵTESTABILITY_GETTER,
  USE_RUNTIME_DEPS_TRACKER_FOR_JIT as ɵUSE_RUNTIME_DEPS_TRACKER_FOR_JIT,
  ViewRef$1 as ɵViewRef,
  XSS_SECURITY_URL as ɵXSS_SECURITY_URL,
  ZONELESS_ENABLED as ɵZONELESS_ENABLED,
  _sanitizeHtml as ɵ_sanitizeHtml,
  _sanitizeUrl as ɵ_sanitizeUrl,
  allowSanitizationBypassAndThrow as ɵallowSanitizationBypassAndThrow,
  annotateForHydration as ɵannotateForHydration,
  bypassSanitizationTrustHtml as ɵbypassSanitizationTrustHtml,
  bypassSanitizationTrustResourceUrl as ɵbypassSanitizationTrustResourceUrl,
  bypassSanitizationTrustScript as ɵbypassSanitizationTrustScript,
  bypassSanitizationTrustStyle as ɵbypassSanitizationTrustStyle,
  bypassSanitizationTrustUrl as ɵbypassSanitizationTrustUrl,
  clearResolutionOfComponentResourcesQueue as ɵclearResolutionOfComponentResourcesQueue,
  compileComponent as ɵcompileComponent,
  compileDirective as ɵcompileDirective,
  compileNgModule as ɵcompileNgModule,
  compileNgModuleDefs as ɵcompileNgModuleDefs,
  compileNgModuleFactory as ɵcompileNgModuleFactory,
  compilePipe as ɵcompilePipe,
  convertToBitFlags as ɵconvertToBitFlags,
  createInjector as ɵcreateInjector,
  defaultIterableDiffers as ɵdefaultIterableDiffers,
  defaultKeyValueDiffers as ɵdefaultKeyValueDiffers,
  depsTracker as ɵdepsTracker,
  detectChangesInViewIfRequired as ɵdetectChangesInViewIfRequired,
  devModeEqual as ɵdevModeEqual,
  findLocaleData as ɵfindLocaleData,
  flushModuleScopingQueueAsMuchAsPossible as ɵflushModuleScopingQueueAsMuchAsPossible,
  formatRuntimeError as ɵformatRuntimeError,
  generateStandaloneInDeclarationsError as ɵgenerateStandaloneInDeclarationsError,
  getAsyncClassMetadataFn as ɵgetAsyncClassMetadataFn,
  getDebugNode as ɵgetDebugNode,
  getDeferBlocks as ɵgetDeferBlocks,
  getDirectives as ɵgetDirectives,
  getHostElement as ɵgetHostElement,
  getInjectableDef as ɵgetInjectableDef,
  getLContext as ɵgetLContext,
  getLocaleCurrencyCode as ɵgetLocaleCurrencyCode,
  getLocalePluralCase as ɵgetLocalePluralCase,
  getOutputDestroyRef as ɵgetOutputDestroyRef,
  getSanitizationBypassType as ɵgetSanitizationBypassType,
  ɵgetUnknownElementStrictMode,
  ɵgetUnknownPropertyStrictMode,
  _global as ɵglobal,
  injectChangeDetectorRef as ɵinjectChangeDetectorRef,
  internalAfterNextRender as ɵinternalAfterNextRender,
  internalCreateApplication as ɵinternalCreateApplication,
  internalProvideZoneChangeDetection as ɵinternalProvideZoneChangeDetection,
  isBoundToModule as ɵisBoundToModule,
  isComponentDefPendingResolution as ɵisComponentDefPendingResolution,
  isEnvironmentProviders as ɵisEnvironmentProviders,
  isInjectable as ɵisInjectable,
  isNgModule as ɵisNgModule,
  isPromise as ɵisPromise,
  isSubscribable as ɵisSubscribable,
  noSideEffects as ɵnoSideEffects,
  patchComponentDefWithScope as ɵpatchComponentDefWithScope,
  performanceMarkFeature as ɵperformanceMarkFeature,
  provideGlobalEventDelegation as ɵprovideGlobalEventDelegation,
  queueStateUpdate as ɵqueueStateUpdate,
  readHydrationInfo as ɵreadHydrationInfo,
  registerLocaleData as ɵregisterLocaleData,
  renderDeferBlockState as ɵrenderDeferBlockState,
  resetCompiledComponents as ɵresetCompiledComponents,
  resetJitOptions as ɵresetJitOptions,
  resolveComponentResources as ɵresolveComponentResources,
  restoreComponentResolutionQueue as ɵrestoreComponentResolutionQueue,
  setAllowDuplicateNgModuleIdsForTest as ɵsetAllowDuplicateNgModuleIdsForTest,
  setAlternateWeakRefImpl as ɵsetAlternateWeakRefImpl,
  ɵsetClassDebugInfo,
  setClassMetadata as ɵsetClassMetadata,
  setClassMetadataAsync as ɵsetClassMetadataAsync,
  setCurrentInjector as ɵsetCurrentInjector,
  setDocument as ɵsetDocument,
  setInjectorProfilerContext as ɵsetInjectorProfilerContext,
  setLocaleId as ɵsetLocaleId,
  ɵsetUnknownElementStrictMode,
  ɵsetUnknownPropertyStrictMode,
  store as ɵstore,
  stringify as ɵstringify,
  transitiveScopesFor as ɵtransitiveScopesFor,
  triggerResourceLoading as ɵtriggerResourceLoading,
  truncateMiddle as ɵtruncateMiddle,
  unregisterAllLocaleData as ɵunregisterLocaleData,
  unwrapSafeValue as ɵunwrapSafeValue,
  ɵunwrapWritableSignal,
  whenStable as ɵwhenStable,
  withDomHydration as ɵwithDomHydration,
  withEventReplay as ɵwithEventReplay,
  withI18nSupport as ɵwithI18nSupport,
  ɵɵCopyDefinitionFeature,
  FactoryTarget as ɵɵFactoryTarget,
  ɵɵHostDirectivesFeature,
  ɵɵInheritDefinitionFeature,
  ɵɵInputTransformsFeature,
  ɵɵNgOnChangesFeature,
  ɵɵProvidersFeature,
  ɵɵStandaloneFeature,
  ɵɵadvance,
  ɵɵattribute,
  ɵɵattributeInterpolate1,
  ɵɵattributeInterpolate2,
  ɵɵattributeInterpolate3,
  ɵɵattributeInterpolate4,
  ɵɵattributeInterpolate5,
  ɵɵattributeInterpolate6,
  ɵɵattributeInterpolate7,
  ɵɵattributeInterpolate8,
  ɵɵattributeInterpolateV,
  ɵɵclassMap,
  ɵɵclassMapInterpolate1,
  ɵɵclassMapInterpolate2,
  ɵɵclassMapInterpolate3,
  ɵɵclassMapInterpolate4,
  ɵɵclassMapInterpolate5,
  ɵɵclassMapInterpolate6,
  ɵɵclassMapInterpolate7,
  ɵɵclassMapInterpolate8,
  ɵɵclassMapInterpolateV,
  ɵɵclassProp,
  ɵɵcomponentInstance,
  ɵɵconditional,
  ɵɵcontentQuery,
  ɵɵcontentQuerySignal,
  ɵɵdeclareLet,
  ɵɵdefer,
  ɵɵdeferEnableTimerScheduling,
  ɵɵdeferOnHover,
  ɵɵdeferOnIdle,
  ɵɵdeferOnImmediate,
  ɵɵdeferOnInteraction,
  ɵɵdeferOnTimer,
  ɵɵdeferOnViewport,
  ɵɵdeferPrefetchOnHover,
  ɵɵdeferPrefetchOnIdle,
  ɵɵdeferPrefetchOnImmediate,
  ɵɵdeferPrefetchOnInteraction,
  ɵɵdeferPrefetchOnTimer,
  ɵɵdeferPrefetchOnViewport,
  ɵɵdeferPrefetchWhen,
  ɵɵdeferWhen,
  ɵɵdefineComponent,
  ɵɵdefineDirective,
  ɵɵdefineInjectable,
  ɵɵdefineInjector,
  ɵɵdefineNgModule,
  ɵɵdefinePipe,
  ɵɵdirectiveInject,
  ɵɵdisableBindings,
  ɵɵelement,
  ɵɵelementContainer,
  ɵɵelementContainerEnd,
  ɵɵelementContainerStart,
  ɵɵelementEnd,
  ɵɵelementStart,
  ɵɵenableBindings,
  ɵɵgetComponentDepsFactory,
  ɵɵgetCurrentView,
  ɵɵgetInheritedFactory,
  ɵɵhostProperty,
  ɵɵi18n,
  ɵɵi18nApply,
  ɵɵi18nAttributes,
  ɵɵi18nEnd,
  ɵɵi18nExp,
  ɵɵi18nPostprocess,
  ɵɵi18nStart,
  ɵɵinject,
  ɵɵinjectAttribute,
  ɵɵinvalidFactory,
  ɵɵinvalidFactoryDep,
  ɵɵlistener,
  ɵɵloadQuery,
  ɵɵnamespaceHTML,
  ɵɵnamespaceMathML,
  ɵɵnamespaceSVG,
  ɵɵnextContext,
  ɵɵngDeclareClassMetadata,
  ɵɵngDeclareClassMetadataAsync,
  ɵɵngDeclareComponent,
  ɵɵngDeclareDirective,
  ɵɵngDeclareFactory,
  ɵɵngDeclareInjectable,
  ɵɵngDeclareInjector,
  ɵɵngDeclareNgModule,
  ɵɵngDeclarePipe,
  ɵɵpipe,
  ɵɵpipeBind1,
  ɵɵpipeBind2,
  ɵɵpipeBind3,
  ɵɵpipeBind4,
  ɵɵpipeBindV,
  ɵɵprojection,
  ɵɵprojectionDef,
  ɵɵproperty,
  ɵɵpropertyInterpolate,
  ɵɵpropertyInterpolate1,
  ɵɵpropertyInterpolate2,
  ɵɵpropertyInterpolate3,
  ɵɵpropertyInterpolate4,
  ɵɵpropertyInterpolate5,
  ɵɵpropertyInterpolate6,
  ɵɵpropertyInterpolate7,
  ɵɵpropertyInterpolate8,
  ɵɵpropertyInterpolateV,
  ɵɵpureFunction0,
  ɵɵpureFunction1,
  ɵɵpureFunction2,
  ɵɵpureFunction3,
  ɵɵpureFunction4,
  ɵɵpureFunction5,
  ɵɵpureFunction6,
  ɵɵpureFunction7,
  ɵɵpureFunction8,
  ɵɵpureFunctionV,
  ɵɵqueryAdvance,
  ɵɵqueryRefresh,
  ɵɵreadContextLet,
  ɵɵreference,
  registerNgModuleType as ɵɵregisterNgModuleType,
  ɵɵrepeater,
  ɵɵrepeaterCreate,
  ɵɵrepeaterTrackByIdentity,
  ɵɵrepeaterTrackByIndex,
  ɵɵresetView,
  ɵɵresolveBody,
  ɵɵresolveDocument,
  ɵɵresolveWindow,
  ɵɵrestoreView,
  ɵɵsanitizeHtml,
  ɵɵsanitizeResourceUrl,
  ɵɵsanitizeScript,
  ɵɵsanitizeStyle,
  ɵɵsanitizeUrl,
  ɵɵsanitizeUrlOrResourceUrl,
  ɵɵsetComponentScope,
  ɵɵsetNgModuleScope,
  ɵɵstoreLet,
  ɵɵstyleMap,
  ɵɵstyleMapInterpolate1,
  ɵɵstyleMapInterpolate2,
  ɵɵstyleMapInterpolate3,
  ɵɵstyleMapInterpolate4,
  ɵɵstyleMapInterpolate5,
  ɵɵstyleMapInterpolate6,
  ɵɵstyleMapInterpolate7,
  ɵɵstyleMapInterpolate8,
  ɵɵstyleMapInterpolateV,
  ɵɵstyleProp,
  ɵɵstylePropInterpolate1,
  ɵɵstylePropInterpolate2,
  ɵɵstylePropInterpolate3,
  ɵɵstylePropInterpolate4,
  ɵɵstylePropInterpolate5,
  ɵɵstylePropInterpolate6,
  ɵɵstylePropInterpolate7,
  ɵɵstylePropInterpolate8,
  ɵɵstylePropInterpolateV,
  ɵɵsyntheticHostListener,
  ɵɵsyntheticHostProperty,
  ɵɵtemplate,
  ɵɵtemplateRefExtractor,
  ɵɵtext,
  ɵɵtextInterpolate,
  ɵɵtextInterpolate1,
  ɵɵtextInterpolate2,
  ɵɵtextInterpolate3,
  ɵɵtextInterpolate4,
  ɵɵtextInterpolate5,
  ɵɵtextInterpolate6,
  ɵɵtextInterpolate7,
  ɵɵtextInterpolate8,
  ɵɵtextInterpolateV,
  ɵɵtrustConstantHtml,
  ɵɵtrustConstantResourceUrl,
  ɵɵtwoWayBindingSet,
  ɵɵtwoWayListener,
  ɵɵtwoWayProperty,
  ɵɵvalidateIframeAttribute,
  ɵɵviewQuery,
  ɵɵviewQuerySignal
};
//# sourceMappingURL=@angular_core.js.map



================================================
FILE: .angular/cache/18.2.20/angular-pivothead-example/vite/deps/@angular_core_primitives_event-dispatch.js
================================================
import {
  Attribute,
  EventContract,
  EventContractContainer,
  EventDispatcher,
  EventInfoWrapper,
  EventPhase,
  bootstrapAppScopedEarlyEventContract,
  clearAppScopedEarlyEventContract,
  getAppScopedQueuedEventInfos,
  getDefaulted,
  isCaptureEventType,
  isEarlyEventType,
  registerAppScopedDispatcher,
  registerDispatcher$1,
  removeAllAppScopedEventListeners
} from "./chunk-VKET2LIV.js";
import "./chunk-WDMUDEB6.js";
export {
  Attribute,
  EventContract,
  EventContractContainer,
  EventDispatcher,
  EventInfoWrapper,
  EventPhase,
  bootstrapAppScopedEarlyEventContract,
  clearAppScopedEarlyEventContract,
  getDefaulted as getActionCache,
  getAppScopedQueuedEventInfos,
  isCaptureEventType,
  isEarlyEventType,
  registerAppScopedDispatcher,
  registerDispatcher$1 as registerDispatcher,
  removeAllAppScopedEventListeners
};
//# sourceMappingURL=@angular_core_primitives_event-dispatch.js.map



================================================
FILE: .angular/cache/18.2.20/angular-pivothead-example/vite/deps/@angular_core_primitives_signals.js
================================================
import {
  REACTIVE_NODE,
  SIGNAL,
  SIGNAL_NODE,
  consumerAfterComputation,
  consumerBeforeComputation,
  consumerDestroy,
  consumerMarkDirty,
  consumerPollProducersForChange,
  createComputed,
  createSignal,
  createWatch,
  defaultEquals,
  getActiveConsumer,
  isInNotificationPhase,
  isReactive,
  producerAccessed,
  producerIncrementEpoch,
  producerNotifyConsumers,
  producerUpdateValueVersion,
  producerUpdatesAllowed,
  runPostSignalSetFn,
  setActiveConsumer,
  setAlternateWeakRefImpl,
  setPostSignalSetFn,
  setThrowInvalidWriteToSignalError,
  signalSetFn,
  signalUpdateFn
} from "./chunk-5NODSH2C.js";
import "./chunk-WDMUDEB6.js";
export {
  REACTIVE_NODE,
  SIGNAL,
  SIGNAL_NODE,
  consumerAfterComputation,
  consumerBeforeComputation,
  consumerDestroy,
  consumerMarkDirty,
  consumerPollProducersForChange,
  createComputed,
  createSignal,
  createWatch,
  defaultEquals,
  getActiveConsumer,
  isInNotificationPhase,
  isReactive,
  producerAccessed,
  producerIncrementEpoch,
  producerNotifyConsumers,
  producerUpdateValueVersion,
  producerUpdatesAllowed,
  runPostSignalSetFn,
  setActiveConsumer,
  setAlternateWeakRefImpl,
  setPostSignalSetFn,
  setThrowInvalidWriteToSignalError,
  signalSetFn,
  signalUpdateFn
};
//# sourceMappingURL=@angular_core_primitives_signals.js.map



================================================
FILE: .angular/cache/18.2.20/angular-pivothead-example/vite/deps/@mindfiredigital_pivothead-angular.js
================================================
import "./chunk-HHOT2EEL.js";
import "./chunk-LPUAGQXJ.js";
import {
  BehaviorSubject,
  Subject,
  Subscription,
  __decorate,
  first,
  map
} from "./chunk-OVFEQSRS.js";
import {
  __async,
  __spreadProps,
  __spreadValues
} from "./chunk-WDMUDEB6.js";

// node_modules/@mindfiredigital/pivothead-angular/node_modules/@angular/core/fesm2022/primitives/signals.mjs
function defaultEquals(a, b) {
  return Object.is(a, b);
}
var activeConsumer = null;
var inNotificationPhase = false;
var epoch = 1;
var SIGNAL = Symbol("SIGNAL");
function setActiveConsumer(consumer) {
  const prev = activeConsumer;
  activeConsumer = consumer;
  return prev;
}
function getActiveConsumer() {
  return activeConsumer;
}
var REACTIVE_NODE = {
  version: 0,
  lastCleanEpoch: 0,
  dirty: false,
  producerNode: void 0,
  producerLastReadVersion: void 0,
  producerIndexOfThis: void 0,
  nextProducerIndex: 0,
  liveConsumerNode: void 0,
  liveConsumerIndexOfThis: void 0,
  consumerAllowSignalWrites: false,
  consumerIsAlwaysLive: false,
  producerMustRecompute: () => false,
  producerRecomputeValue: () => {
  },
  consumerMarkedDirty: () => {
  },
  consumerOnSignalRead: () => {
  }
};
function producerAccessed(node) {
  if (inNotificationPhase) {
    throw new Error(typeof ngDevMode !== "undefined" && ngDevMode ? `Assertion error: signal read during notification phase` : "");
  }
  if (activeConsumer === null) {
    return;
  }
  activeConsumer.consumerOnSignalRead(node);
  const idx = activeConsumer.nextProducerIndex++;
  assertConsumerNode(activeConsumer);
  if (idx < activeConsumer.producerNode.length && activeConsumer.producerNode[idx] !== node) {
    if (consumerIsLive(activeConsumer)) {
      const staleProducer = activeConsumer.producerNode[idx];
      producerRemoveLiveConsumerAtIndex(staleProducer, activeConsumer.producerIndexOfThis[idx]);
    }
  }
  if (activeConsumer.producerNode[idx] !== node) {
    activeConsumer.producerNode[idx] = node;
    activeConsumer.producerIndexOfThis[idx] = consumerIsLive(activeConsumer) ? producerAddLiveConsumer(node, activeConsumer, idx) : 0;
  }
  activeConsumer.producerLastReadVersion[idx] = node.version;
}
function producerIncrementEpoch() {
  epoch++;
}
function producerUpdateValueVersion(node) {
  if (consumerIsLive(node) && !node.dirty) {
    return;
  }
  if (!node.dirty && node.lastCleanEpoch === epoch) {
    return;
  }
  if (!node.producerMustRecompute(node) && !consumerPollProducersForChange(node)) {
    node.dirty = false;
    node.lastCleanEpoch = epoch;
    return;
  }
  node.producerRecomputeValue(node);
  node.dirty = false;
  node.lastCleanEpoch = epoch;
}
function producerNotifyConsumers(node) {
  if (node.liveConsumerNode === void 0) {
    return;
  }
  const prev = inNotificationPhase;
  inNotificationPhase = true;
  try {
    for (const consumer of node.liveConsumerNode) {
      if (!consumer.dirty) {
        consumerMarkDirty(consumer);
      }
    }
  } finally {
    inNotificationPhase = prev;
  }
}
function producerUpdatesAllowed() {
  return activeConsumer?.consumerAllowSignalWrites !== false;
}
function consumerMarkDirty(node) {
  node.dirty = true;
  producerNotifyConsumers(node);
  node.consumerMarkedDirty?.(node);
}
function consumerBeforeComputation(node) {
  node && (node.nextProducerIndex = 0);
  return setActiveConsumer(node);
}
function consumerAfterComputation(node, prevConsumer) {
  setActiveConsumer(prevConsumer);
  if (!node || node.producerNode === void 0 || node.producerIndexOfThis === void 0 || node.producerLastReadVersion === void 0) {
    return;
  }
  if (consumerIsLive(node)) {
    for (let i = node.nextProducerIndex; i < node.producerNode.length; i++) {
      producerRemoveLiveConsumerAtIndex(node.producerNode[i], node.producerIndexOfThis[i]);
    }
  }
  while (node.producerNode.length > node.nextProducerIndex) {
    node.producerNode.pop();
    node.producerLastReadVersion.pop();
    node.producerIndexOfThis.pop();
  }
}
function consumerPollProducersForChange(node) {
  assertConsumerNode(node);
  for (let i = 0; i < node.producerNode.length; i++) {
    const producer = node.producerNode[i];
    const seenVersion = node.producerLastReadVersion[i];
    if (seenVersion !== producer.version) {
      return true;
    }
    producerUpdateValueVersion(producer);
    if (seenVersion !== producer.version) {
      return true;
    }
  }
  return false;
}
function consumerDestroy(node) {
  assertConsumerNode(node);
  if (consumerIsLive(node)) {
    for (let i = 0; i < node.producerNode.length; i++) {
      producerRemoveLiveConsumerAtIndex(node.producerNode[i], node.producerIndexOfThis[i]);
    }
  }
  node.producerNode.length = node.producerLastReadVersion.length = node.producerIndexOfThis.length = 0;
  if (node.liveConsumerNode) {
    node.liveConsumerNode.length = node.liveConsumerIndexOfThis.length = 0;
  }
}
function producerAddLiveConsumer(node, consumer, indexOfThis) {
  assertProducerNode(node);
  if (node.liveConsumerNode.length === 0 && isConsumerNode(node)) {
    for (let i = 0; i < node.producerNode.length; i++) {
      node.producerIndexOfThis[i] = producerAddLiveConsumer(node.producerNode[i], node, i);
    }
  }
  node.liveConsumerIndexOfThis.push(indexOfThis);
  return node.liveConsumerNode.push(consumer) - 1;
}
function producerRemoveLiveConsumerAtIndex(node, idx) {
  assertProducerNode(node);
  if (typeof ngDevMode !== "undefined" && ngDevMode && idx >= node.liveConsumerNode.length) {
    throw new Error(`Assertion error: active consumer index ${idx} is out of bounds of ${node.liveConsumerNode.length} consumers)`);
  }
  if (node.liveConsumerNode.length === 1 && isConsumerNode(node)) {
    for (let i = 0; i < node.producerNode.length; i++) {
      producerRemoveLiveConsumerAtIndex(node.producerNode[i], node.producerIndexOfThis[i]);
    }
  }
  const lastIdx = node.liveConsumerNode.length - 1;
  node.liveConsumerNode[idx] = node.liveConsumerNode[lastIdx];
  node.liveConsumerIndexOfThis[idx] = node.liveConsumerIndexOfThis[lastIdx];
  node.liveConsumerNode.length--;
  node.liveConsumerIndexOfThis.length--;
  if (idx < node.liveConsumerNode.length) {
    const idxProducer = node.liveConsumerIndexOfThis[idx];
    const consumer = node.liveConsumerNode[idx];
    assertConsumerNode(consumer);
    consumer.producerIndexOfThis[idxProducer] = idx;
  }
}
function consumerIsLive(node) {
  return node.consumerIsAlwaysLive || (node?.liveConsumerNode?.length ?? 0) > 0;
}
function assertConsumerNode(node) {
  node.producerNode ??= [];
  node.producerIndexOfThis ??= [];
  node.producerLastReadVersion ??= [];
}
function assertProducerNode(node) {
  node.liveConsumerNode ??= [];
  node.liveConsumerIndexOfThis ??= [];
}
function isConsumerNode(node) {
  return node.producerNode !== void 0;
}
function createComputed(computation) {
  const node = Object.create(COMPUTED_NODE);
  node.computation = computation;
  const computed = () => {
    producerUpdateValueVersion(node);
    producerAccessed(node);
    if (node.value === ERRORED) {
      throw node.error;
    }
    return node.value;
  };
  computed[SIGNAL] = node;
  return computed;
}
var UNSET = Symbol("UNSET");
var COMPUTING = Symbol("COMPUTING");
var ERRORED = Symbol("ERRORED");
var COMPUTED_NODE = (() => {
  return __spreadProps(__spreadValues({}, REACTIVE_NODE), {
    value: UNSET,
    dirty: true,
    error: null,
    equal: defaultEquals,
    producerMustRecompute(node) {
      return node.value === UNSET || node.value === COMPUTING;
    },
    producerRecomputeValue(node) {
      if (node.value === COMPUTING) {
        throw new Error("Detected cycle in computations.");
      }
      const oldValue = node.value;
      node.value = COMPUTING;
      const prevConsumer = consumerBeforeComputation(node);
      let newValue;
      try {
        newValue = node.computation();
      } catch (err) {
        newValue = ERRORED;
        node.error = err;
      } finally {
        consumerAfterComputation(node, prevConsumer);
      }
      if (oldValue !== UNSET && oldValue !== ERRORED && newValue !== ERRORED && node.equal(oldValue, newValue)) {
        node.value = oldValue;
        return;
      }
      node.value = newValue;
      node.version++;
    }
  });
})();
function defaultThrowError() {
  throw new Error();
}
var throwInvalidWriteToSignalErrorFn = defaultThrowError;
function throwInvalidWriteToSignalError() {
  throwInvalidWriteToSignalErrorFn();
}
function setThrowInvalidWriteToSignalError(fn) {
  throwInvalidWriteToSignalErrorFn = fn;
}
var postSignalSetFn = null;
function createSignal(initialValue) {
  const node = Object.create(SIGNAL_NODE);
  node.value = initialValue;
  const getter = () => {
    producerAccessed(node);
    return node.value;
  };
  getter[SIGNAL] = node;
  return getter;
}
function signalSetFn(node, newValue) {
  if (!producerUpdatesAllowed()) {
    throwInvalidWriteToSignalError();
  }
  if (!node.equal(node.value, newValue)) {
    node.value = newValue;
    signalValueChanged(node);
  }
}
function signalUpdateFn(node, updater) {
  if (!producerUpdatesAllowed()) {
    throwInvalidWriteToSignalError();
  }
  signalSetFn(node, updater(node.value));
}
var SIGNAL_NODE = (() => {
  return __spreadProps(__spreadValues({}, REACTIVE_NODE), {
    equal: defaultEquals,
    value: void 0
  });
})();
function signalValueChanged(node) {
  node.version++;
  producerIncrementEpoch();
  producerNotifyConsumers(node);
  postSignalSetFn?.();
}
var NOOP_CLEANUP_FN = () => {
};
var WATCH_NODE = (() => {
  return __spreadProps(__spreadValues({}, REACTIVE_NODE), {
    consumerIsAlwaysLive: true,
    consumerAllowSignalWrites: false,
    consumerMarkedDirty: (node) => {
      if (node.schedule !== null) {
        node.schedule(node.ref);
      }
    },
    hasRun: false,
    cleanupFn: NOOP_CLEANUP_FN
  });
})();

// node_modules/@mindfiredigital/pivothead-angular/node_modules/@angular/core/fesm2022/primitives/event-dispatch.mjs
var Property = {
  /**
   * The parsed value of the jsaction attribute is stored in this
   * property on the DOM node. The parsed value is an Object. The
   * property names of the object are the events; the values are the
   * names of the actions. This property is attached even on nodes
   * that don't have a jsaction attribute as an optimization, because
   * property lookup is faster than attribute access.
   */
  JSACTION: "__jsaction",
  /**
   * The owner property references an a logical owner for a DOM node. JSAction
   * will follow this reference instead of parentNode when traversing the DOM
   * to find jsaction attributes. This allows overlaying a logical structure
   * over a document where the DOM structure can't reflect that structure.
   */
  OWNER: "__owner"
};
function get(element) {
  return element[Property.JSACTION];
}
function getDefaulted(element) {
  const cache = get(element) ?? {};
  set(element, cache);
  return cache;
}
function set(element, actionMap) {
  element[Property.JSACTION] = actionMap;
}
var EventType = {
  /**
   * Mouse middle click, introduced in Chrome 55 and not yet supported on
   * other browsers.
   */
  AUXCLICK: "auxclick",
  /**
   * The change event fired by browsers when the `value` attribute of input,
   * select, and textarea elements are changed.
   */
  CHANGE: "change",
  /**
   * The click event. In addEvent() refers to all click events, in the
   * jsaction attribute it refers to the unmodified click and Enter/Space
   * keypress events.  In the latter case, a jsaction click will be triggered,
   * for accessibility reasons.  See clickmod and clickonly, below.
   */
  CLICK: "click",
  /**
   * Specifies the jsaction for a modified click event (i.e. a mouse
   * click with the modifier key Cmd/Ctrl pressed). This event isn't
   * separately enabled in addEvent(), because in the DOM, it's just a
   * click event.
   */
  CLICKMOD: "clickmod",
  /**
   * Specifies the jsaction for a click-only event.  Click-only doesn't take
   * into account the case where an element with focus receives an Enter/Space
   * keypress.  This event isn't separately enabled in addEvent().
   */
  CLICKONLY: "clickonly",
  /**
   * The dblclick event.
   */
  DBLCLICK: "dblclick",
  /**
   * Focus doesn't bubble, but you can use it in addEvent() and
   * jsaction anyway. EventContract does the right thing under the
   * hood.
   */
  FOCUS: "focus",
  /**
   * This event only exists in IE. For addEvent() and jsaction, use
   * focus instead; EventContract does the right thing even though
   * focus doesn't bubble.
   */
  FOCUSIN: "focusin",
  /**
   * Analog to focus.
   */
  BLUR: "blur",
  /**
   * Analog to focusin.
   */
  FOCUSOUT: "focusout",
  /**
   * Submit doesn't bubble, so it cannot be used with event
   * contract. However, the browser helpfully fires a click event on
   * the submit button of a form (even if the form is not submitted by
   * a click on the submit button). So you should handle click on the
   * submit button instead.
   */
  SUBMIT: "submit",
  /**
   * The keydown event. In addEvent() and non-click jsaction it represents the
   * regular DOM keydown event. It represents click actions in non-Gecko
   * browsers.
   */
  KEYDOWN: "keydown",
  /**
   * The keypress event. In addEvent() and non-click jsaction it represents the
   * regular DOM keypress event. It represents click actions in Gecko browsers.
   */
  KEYPRESS: "keypress",
  /**
   * The keyup event. In addEvent() and non-click jsaction it represents the
   * regular DOM keyup event. It represents click actions in non-Gecko
   * browsers.
   */
  KEYUP: "keyup",
  /**
   * The mouseup event. Can either be used directly or used implicitly to
   * capture mouseup events. In addEvent(), it represents a regular DOM
   * mouseup event.
   */
  MOUSEUP: "mouseup",
  /**
   * The mousedown event. Can either be used directly or used implicitly to
   * capture mouseenter events. In addEvent(), it represents a regular DOM
   * mouseover event.
   */
  MOUSEDOWN: "mousedown",
  /**
   * The mouseover event. Can either be used directly or used implicitly to
   * capture mouseenter events. In addEvent(), it represents a regular DOM
   * mouseover event.
   */
  MOUSEOVER: "mouseover",
  /**
   * The mouseout event. Can either be used directly or used implicitly to
   * capture mouseover events. In addEvent(), it represents a regular DOM
   * mouseout event.
   */
  MOUSEOUT: "mouseout",
  /**
   * The mouseenter event. Does not bubble and fires individually on each
   * element being entered within a DOM tree.
   */
  MOUSEENTER: "mouseenter",
  /**
   * The mouseleave event. Does not bubble and fires individually on each
   * element being entered within a DOM tree.
   */
  MOUSELEAVE: "mouseleave",
  /**
   * The mousemove event.
   */
  MOUSEMOVE: "mousemove",
  /**
   * The pointerup event. Can either be used directly or used implicitly to
   * capture pointerup events. In addEvent(), it represents a regular DOM
   * pointerup event.
   */
  POINTERUP: "pointerup",
  /**
   * The pointerdown event. Can either be used directly or used implicitly to
   * capture pointerenter events. In addEvent(), it represents a regular DOM
   * mouseover event.
   */
  POINTERDOWN: "pointerdown",
  /**
   * The pointerover event. Can either be used directly or used implicitly to
   * capture pointerenter events. In addEvent(), it represents a regular DOM
   * pointerover event.
   */
  POINTEROVER: "pointerover",
  /**
   * The pointerout event. Can either be used directly or used implicitly to
   * capture pointerover events. In addEvent(), it represents a regular DOM
   * pointerout event.
   */
  POINTEROUT: "pointerout",
  /**
   * The pointerenter event. Does not bubble and fires individually on each
   * element being entered within a DOM tree.
   */
  POINTERENTER: "pointerenter",
  /**
   * The pointerleave event. Does not bubble and fires individually on each
   * element being entered within a DOM tree.
   */
  POINTERLEAVE: "pointerleave",
  /**
   * The pointermove event.
   */
  POINTERMOVE: "pointermove",
  /**
   * The pointercancel event.
   */
  POINTERCANCEL: "pointercancel",
  /**
   * The gotpointercapture event is fired when
   * Element.setPointerCapture(pointerId) is called on a mouse input, or
   * implicitly when a touch input begins.
   */
  GOTPOINTERCAPTURE: "gotpointercapture",
  /**
   * The lostpointercapture event is fired when
   * Element.releasePointerCapture(pointerId) is called, or implicitly after a
   * touch input ends.
   */
  LOSTPOINTERCAPTURE: "lostpointercapture",
  /**
   * The error event. The error event doesn't bubble, but you can use it in
   * addEvent() and jsaction anyway. EventContract does the right thing under
   * the hood (except in IE8 which does not use error events).
   */
  ERROR: "error",
  /**
   * The load event. The load event doesn't bubble, but you can use it in
   * addEvent() and jsaction anyway. EventContract does the right thing
   * under the hood.
   */
  LOAD: "load",
  /**
   * The unload event.
   */
  UNLOAD: "unload",
  /**
   * The touchstart event. Bubbles, will only ever fire in browsers with
   * touch support.
   */
  TOUCHSTART: "touchstart",
  /**
   * The touchend event. Bubbles, will only ever fire in browsers with
   * touch support.
   */
  TOUCHEND: "touchend",
  /**
   * The touchmove event. Bubbles, will only ever fire in browsers with
   * touch support.
   */
  TOUCHMOVE: "touchmove",
  /**
   * The input event.
   */
  INPUT: "input",
  /**
   * The scroll event.
   */
  SCROLL: "scroll",
  /**
   * The toggle event. The toggle event doesn't bubble, but you can use it in
   * addEvent() and jsaction anyway. EventContract does the right thing
   * under the hood.
   */
  TOGGLE: "toggle",
  /**
   * A custom event. The actual custom event type is declared as the 'type'
   * field in the event details. Supported in Firefox 6+, IE 9+, and all Chrome
   * versions.
   *
   * This is an internal name. Users should use jsaction's fireCustomEvent to
   * fire custom events instead of relying on this type to create them.
   */
  CUSTOM: "_custom"
};
var MOUSE_SPECIAL_EVENT_TYPES = [EventType.MOUSEENTER, EventType.MOUSELEAVE, "pointerenter", "pointerleave"];
var BUBBLE_EVENT_TYPES = [
  EventType.CLICK,
  EventType.DBLCLICK,
  EventType.FOCUSIN,
  EventType.FOCUSOUT,
  EventType.KEYDOWN,
  EventType.KEYUP,
  EventType.KEYPRESS,
  EventType.MOUSEOVER,
  EventType.MOUSEOUT,
  EventType.SUBMIT,
  EventType.TOUCHSTART,
  EventType.TOUCHEND,
  EventType.TOUCHMOVE,
  "touchcancel",
  "auxclick",
  "change",
  "compositionstart",
  "compositionupdate",
  "compositionend",
  "beforeinput",
  "input",
  "select",
  "copy",
  "cut",
  "paste",
  "mousedown",
  "mouseup",
  "wheel",
  "contextmenu",
  "dragover",
  "dragenter",
  "dragleave",
  "drop",
  "dragstart",
  "dragend",
  "pointerdown",
  "pointermove",
  "pointerup",
  "pointercancel",
  "pointerover",
  "pointerout",
  "gotpointercapture",
  "lostpointercapture",
  // Video events.
  "ended",
  "loadedmetadata",
  // Page visibility events.
  "pagehide",
  "pageshow",
  "visibilitychange",
  // Content visibility events.
  "beforematch"
];
var CAPTURE_EVENT_TYPES = [EventType.FOCUS, EventType.BLUR, EventType.ERROR, EventType.LOAD, EventType.TOGGLE];
var EARLY_EVENT_TYPES = BUBBLE_EVENT_TYPES.concat(CAPTURE_EVENT_TYPES);
var isEarlyEventType = (eventType) => EARLY_EVENT_TYPES.indexOf(eventType) >= 0;
var MAC_ENTER = 3;
var ENTER = 13;
var SPACE = 32;
var KeyCode = {
  MAC_ENTER,
  ENTER,
  SPACE
};
function getBrowserEventType(eventType) {
  if (eventType === EventType.MOUSEENTER) {
    return EventType.MOUSEOVER;
  } else if (eventType === EventType.MOUSELEAVE) {
    return EventType.MOUSEOUT;
  } else if (eventType === EventType.POINTERENTER) {
    return EventType.POINTEROVER;
  } else if (eventType === EventType.POINTERLEAVE) {
    return EventType.POINTEROUT;
  }
  return eventType;
}
var isMac = typeof navigator !== "undefined" && /Macintosh/.test(navigator.userAgent);
var isWebKit = typeof navigator !== "undefined" && !/Opera/.test(navigator.userAgent) && /WebKit/.test(navigator.userAgent);
var isIe = typeof navigator !== "undefined" && (/MSIE/.test(navigator.userAgent) || /Trident/.test(navigator.userAgent));
var isGecko = typeof navigator !== "undefined" && !/Opera|WebKit/.test(navigator.userAgent) && /Gecko/.test(navigator.product);
var ACTION_KEY_TO_KEYCODE = {
  "Enter": KeyCode.ENTER,
  " ": KeyCode.SPACE
};
var IDENTIFIER_TO_KEY_TRIGGER_MAPPING = {
  "A": KeyCode.ENTER,
  "BUTTON": 0,
  "CHECKBOX": KeyCode.SPACE,
  "COMBOBOX": KeyCode.ENTER,
  "FILE": 0,
  "GRIDCELL": KeyCode.ENTER,
  "LINK": KeyCode.ENTER,
  "LISTBOX": KeyCode.ENTER,
  "MENU": 0,
  "MENUBAR": 0,
  "MENUITEM": 0,
  "MENUITEMCHECKBOX": 0,
  "MENUITEMRADIO": 0,
  "OPTION": 0,
  "RADIO": KeyCode.SPACE,
  "RADIOGROUP": KeyCode.SPACE,
  "RESET": 0,
  "SUBMIT": 0,
  "SWITCH": KeyCode.SPACE,
  "TAB": 0,
  "TREE": KeyCode.ENTER,
  "TREEITEM": KeyCode.ENTER
};
var isIos = typeof navigator !== "undefined" && /iPhone|iPad|iPod/.test(navigator.userAgent);
function setEventType(eventInfo, eventType) {
  eventInfo.eventType = eventType;
}
function setIsReplay(eventInfo, replay) {
  eventInfo.eirp = replay;
}
function cloneEventInfo(eventInfo) {
  return {
    eventType: eventInfo.eventType,
    event: eventInfo.event,
    targetElement: eventInfo.targetElement,
    eic: eventInfo.eic,
    eia: eventInfo.eia,
    timeStamp: eventInfo.timeStamp,
    eirp: eventInfo.eirp,
    eiack: eventInfo.eiack,
    eir: eventInfo.eir
  };
}
function createEventInfoFromParameters(eventType, event, targetElement, container, timestamp, action, isReplay, a11yClickKey) {
  return {
    eventType,
    event,
    targetElement,
    eic: container,
    timeStamp: timestamp,
    eia: action,
    eirp: isReplay,
    eiack: a11yClickKey
  };
}
var DEFAULT_EVENT_TYPE = EventType.CLICK;
var Restriction;
(function(Restriction2) {
  Restriction2[Restriction2["I_AM_THE_JSACTION_FRAMEWORK"] = 0] = "I_AM_THE_JSACTION_FRAMEWORK";
})(Restriction || (Restriction = {}));
var PROPAGATION_STOPPED_SYMBOL = Symbol.for("propagationStopped");
function removeAllEventListeners(earlyJsactionData) {
  if (!earlyJsactionData) {
    return;
  }
  removeEventListeners(earlyJsactionData.c, earlyJsactionData.et, earlyJsactionData.h);
  removeEventListeners(earlyJsactionData.c, earlyJsactionData.etc, earlyJsactionData.h, true);
}
function removeEventListeners(container, eventTypes, earlyEventHandler, capture) {
  for (let i = 0; i < eventTypes.length; i++) {
    container.removeEventListener(
      eventTypes[i],
      earlyEventHandler,
      /* useCapture */
      capture
    );
  }
}
var MOUSE_SPECIAL_SUPPORT = false;
var EventContract = class _EventContract {
  static {
    this.MOUSE_SPECIAL_SUPPORT = MOUSE_SPECIAL_SUPPORT;
  }
  constructor(containerManager) {
    this.eventHandlers = {};
    this.browserEventTypeToExtraEventTypes = {};
    this.dispatcher = null;
    this.queuedEventInfos = [];
    this.containerManager = containerManager;
  }
  handleEvent(eventType, event, container) {
    const eventInfo = createEventInfoFromParameters(
      /* eventType= */
      eventType,
      /* event= */
      event,
      /* targetElement= */
      event.target,
      /* container= */
      container,
      /* timestamp= */
      Date.now()
    );
    this.handleEventInfo(eventInfo);
  }
  /**
   * Handle an `EventInfo`.
   */
  handleEventInfo(eventInfo) {
    if (!this.dispatcher) {
      setIsReplay(eventInfo, true);
      this.queuedEventInfos?.push(eventInfo);
      return;
    }
    this.dispatcher(eventInfo);
  }
  /**
   * Enables jsaction handlers to be called for the event type given by
   * name.
   *
   * If the event is already registered, this does nothing.
   *
   * @param prefixedEventType If supplied, this event is used in
   *     the actual browser event registration instead of the name that is
   *     exposed to jsaction. Use this if you e.g. want users to be able
   *     to subscribe to jsaction="transitionEnd:foo" while the underlying
   *     event is webkitTransitionEnd in one browser and mozTransitionEnd
   *     in another.
   */
  addEvent(eventType, prefixedEventType) {
    if (eventType in this.eventHandlers || !this.containerManager) {
      return;
    }
    if (!_EventContract.MOUSE_SPECIAL_SUPPORT && MOUSE_SPECIAL_EVENT_TYPES.indexOf(eventType) >= 0) {
      return;
    }
    const eventHandler = (eventType2, event, container) => {
      this.handleEvent(eventType2, event, container);
    };
    this.eventHandlers[eventType] = eventHandler;
    const browserEventType = getBrowserEventType(prefixedEventType || eventType);
    if (browserEventType !== eventType) {
      const eventTypes = this.browserEventTypeToExtraEventTypes[browserEventType] || [];
      eventTypes.push(eventType);
      this.browserEventTypeToExtraEventTypes[browserEventType] = eventTypes;
    }
    this.containerManager.addEventListener(browserEventType, (element) => {
      return (event) => {
        eventHandler(eventType, event, element);
      };
    });
  }
  /**
   * Gets the queued early events and replay them using the appropriate handler
   * in the provided event contract. Once all the events are replayed, it cleans
   * up the early contract.
   */
  replayEarlyEvents(earlyJsactionData = window._ejsa) {
    if (!earlyJsactionData) {
      return;
    }
    this.replayEarlyEventInfos(earlyJsactionData.q);
    removeAllEventListeners(earlyJsactionData);
    delete window._ejsa;
  }
  /**
   * Replays all the early `EventInfo` objects, dispatching them through the normal
   * `EventContract` flow.
   */
  replayEarlyEventInfos(earlyEventInfos) {
    for (let i = 0; i < earlyEventInfos.length; i++) {
      const earlyEventInfo = earlyEventInfos[i];
      const eventTypes = this.getEventTypesForBrowserEventType(earlyEventInfo.eventType);
      for (let j = 0; j < eventTypes.length; j++) {
        const eventInfo = cloneEventInfo(earlyEventInfo);
        setEventType(eventInfo, eventTypes[j]);
        this.handleEventInfo(eventInfo);
      }
    }
  }
  /**
   * Returns all JSAction event types that have been registered for a given
   * browser event type.
   */
  getEventTypesForBrowserEventType(browserEventType) {
    const eventTypes = [];
    if (this.eventHandlers[browserEventType]) {
      eventTypes.push(browserEventType);
    }
    if (this.browserEventTypeToExtraEventTypes[browserEventType]) {
      eventTypes.push(...this.browserEventTypeToExtraEventTypes[browserEventType]);
    }
    return eventTypes;
  }
  /**
   * Returns the event handler function for a given event type.
   */
  handler(eventType) {
    return this.eventHandlers[eventType];
  }
  /**
   * Cleans up the event contract. This resets all of the `EventContract`'s
   * internal state. Users are responsible for not using this `EventContract`
   * after it has been cleaned up.
   */
  cleanUp() {
    this.containerManager.cleanUp();
    this.containerManager = null;
    this.eventHandlers = {};
    this.browserEventTypeToExtraEventTypes = {};
    this.dispatcher = null;
    this.queuedEventInfos = [];
  }
  /**
   * Register a dispatcher function. Event info of each event mapped to
   * a jsaction is passed for handling to this callback. The queued
   * events are passed as well to the dispatcher for later replaying
   * once the dispatcher is registered. Clears the event queue to null.
   *
   * @param dispatcher The dispatcher function.
   * @param restriction
   */
  registerDispatcher(dispatcher, restriction) {
    this.ecrd(dispatcher, restriction);
  }
  /**
   * Unrenamed alias for registerDispatcher. Necessary for any codebases that
   * split the `EventContract` and `Dispatcher` code into different compilation
   * units.
   */
  ecrd(dispatcher, restriction) {
    this.dispatcher = dispatcher;
    if (this.queuedEventInfos?.length) {
      for (let i = 0; i < this.queuedEventInfos.length; i++) {
        this.handleEventInfo(this.queuedEventInfos[i]);
      }
      this.queuedEventInfos = null;
    }
  }
};

// node_modules/@mindfiredigital/pivothead-angular/node_modules/@angular/core/fesm2022/core.mjs
var ERROR_DETAILS_PAGE_BASE_URL = "https://angular.dev/errors";
var XSS_SECURITY_URL = "https://g.co/ng/security#xss";
var RuntimeError = class extends Error {
  constructor(code, message) {
    super(formatRuntimeError(code, message));
    this.code = code;
  }
};
function formatRuntimeError(code, message) {
  const fullCode = `NG0${Math.abs(code)}`;
  let errorMessage = `${fullCode}${message ? ": " + message : ""}`;
  if (ngDevMode && code < 0) {
    const addPeriodSeparator = !errorMessage.match(/[.,;!?\n]$/);
    const separator = addPeriodSeparator ? "." : "";
    errorMessage = `${errorMessage}${separator} Find more at ${ERROR_DETAILS_PAGE_BASE_URL}/${fullCode}`;
  }
  return errorMessage;
}
var REQUIRED_UNSET_VALUE = Symbol("InputSignalNode#UNSET");
var INPUT_SIGNAL_NODE = (() => {
  return __spreadProps(__spreadValues({}, SIGNAL_NODE), {
    transformFn: void 0,
    applyValueToInputSignal(node, value) {
      signalSetFn(node, value);
    }
  });
})();
var ɵINPUT_SIGNAL_BRAND_READ_TYPE = Symbol();
var ɵINPUT_SIGNAL_BRAND_WRITE_TYPE = Symbol();
function createInputSignal(initialValue, options) {
  const node = Object.create(INPUT_SIGNAL_NODE);
  node.value = initialValue;
  node.transformFn = options?.transform;
  function inputValueFn() {
    producerAccessed(node);
    if (node.value === REQUIRED_UNSET_VALUE) {
      throw new RuntimeError(-950, ngDevMode && "Input is required but no value is available yet.");
    }
    return node.value;
  }
  inputValueFn[SIGNAL] = node;
  if (ngDevMode) {
    inputValueFn.toString = () => `[Input Signal: ${inputValueFn()}]`;
  }
  return inputValueFn;
}
function noSideEffects(fn) {
  return {
    toString: fn
  }.toString();
}
var ANNOTATIONS = "__annotations__";
var PARAMETERS = "__parameters__";
var PROP_METADATA = "__prop__metadata__";
function makeDecorator(name, props, parentClass, additionalProcessing, typeFn) {
  return noSideEffects(() => {
    const metaCtor = makeMetadataCtor(props);
    function DecoratorFactory(...args) {
      if (this instanceof DecoratorFactory) {
        metaCtor.call(this, ...args);
        return this;
      }
      const annotationInstance = new DecoratorFactory(...args);
      return function TypeDecorator(cls) {
        if (typeFn) typeFn(cls, ...args);
        const annotations = cls.hasOwnProperty(ANNOTATIONS) ? cls[ANNOTATIONS] : Object.defineProperty(cls, ANNOTATIONS, {
          value: []
        })[ANNOTATIONS];
        annotations.push(annotationInstance);
        if (additionalProcessing) additionalProcessing(cls);
        return cls;
      };
    }
    if (parentClass) {
      DecoratorFactory.prototype = Object.create(parentClass.prototype);
    }
    DecoratorFactory.prototype.ngMetadataName = name;
    DecoratorFactory.annotationCls = DecoratorFactory;
    return DecoratorFactory;
  });
}
function makeMetadataCtor(props) {
  return function ctor(...args) {
    if (props) {
      const values = props(...args);
      for (const propName in values) {
        this[propName] = values[propName];
      }
    }
  };
}
function makeParamDecorator(name, props, parentClass) {
  return noSideEffects(() => {
    const metaCtor = makeMetadataCtor(props);
    function ParamDecoratorFactory(...args) {
      if (this instanceof ParamDecoratorFactory) {
        metaCtor.apply(this, args);
        return this;
      }
      const annotationInstance = new ParamDecoratorFactory(...args);
      ParamDecorator.annotation = annotationInstance;
      return ParamDecorator;
      function ParamDecorator(cls, unusedKey, index) {
        const parameters = cls.hasOwnProperty(PARAMETERS) ? cls[PARAMETERS] : Object.defineProperty(cls, PARAMETERS, {
          value: []
        })[PARAMETERS];
        while (parameters.length <= index) {
          parameters.push(null);
        }
        (parameters[index] = parameters[index] || []).push(annotationInstance);
        return cls;
      }
    }
    if (parentClass) {
      ParamDecoratorFactory.prototype = Object.create(parentClass.prototype);
    }
    ParamDecoratorFactory.prototype.ngMetadataName = name;
    ParamDecoratorFactory.annotationCls = ParamDecoratorFactory;
    return ParamDecoratorFactory;
  });
}
function makePropDecorator(name, props, parentClass, additionalProcessing) {
  return noSideEffects(() => {
    const metaCtor = makeMetadataCtor(props);
    function PropDecoratorFactory(...args) {
      if (this instanceof PropDecoratorFactory) {
        metaCtor.apply(this, args);
        return this;
      }
      const decoratorInstance = new PropDecoratorFactory(...args);
      function PropDecorator(target, name2) {
        if (target === void 0) {
          throw new Error("Standard Angular field decorators are not supported in JIT mode.");
        }
        const constructor = target.constructor;
        const meta = constructor.hasOwnProperty(PROP_METADATA) ? constructor[PROP_METADATA] : Object.defineProperty(constructor, PROP_METADATA, {
          value: {}
        })[PROP_METADATA];
        meta[name2] = meta.hasOwnProperty(name2) && meta[name2] || [];
        meta[name2].unshift(decoratorInstance);
        if (additionalProcessing) additionalProcessing(target, name2, ...args);
      }
      return PropDecorator;
    }
    if (parentClass) {
      PropDecoratorFactory.prototype = Object.create(parentClass.prototype);
    }
    PropDecoratorFactory.prototype.ngMetadataName = name;
    PropDecoratorFactory.annotationCls = PropDecoratorFactory;
    return PropDecoratorFactory;
  });
}
var _global = globalThis;
function ngDevModeResetPerfCounters() {
  const locationString = typeof location !== "undefined" ? location.toString() : "";
  const newCounters = {
    namedConstructors: locationString.indexOf("ngDevMode=namedConstructors") != -1,
    firstCreatePass: 0,
    tNode: 0,
    tView: 0,
    rendererCreateTextNode: 0,
    rendererSetText: 0,
    rendererCreateElement: 0,
    rendererAddEventListener: 0,
    rendererSetAttribute: 0,
    rendererRemoveAttribute: 0,
    rendererSetProperty: 0,
    rendererSetClassName: 0,
    rendererAddClass: 0,
    rendererRemoveClass: 0,
    rendererSetStyle: 0,
    rendererRemoveStyle: 0,
    rendererDestroy: 0,
    rendererDestroyNode: 0,
    rendererMoveNode: 0,
    rendererRemoveNode: 0,
    rendererAppendChild: 0,
    rendererInsertBefore: 0,
    rendererCreateComment: 0,
    hydratedNodes: 0,
    hydratedComponents: 0,
    dehydratedViewsRemoved: 0,
    dehydratedViewsCleanupRuns: 0,
    componentsSkippedHydration: 0
  };
  const allowNgDevModeTrue = locationString.indexOf("ngDevMode=false") === -1;
  if (!allowNgDevModeTrue) {
    _global["ngDevMode"] = false;
  } else {
    if (typeof _global["ngDevMode"] !== "object") {
      _global["ngDevMode"] = {};
    }
    Object.assign(_global["ngDevMode"], newCounters);
  }
  return newCounters;
}
function initNgDevMode() {
  if (typeof ngDevMode === "undefined" || ngDevMode) {
    if (typeof ngDevMode !== "object" || Object.keys(ngDevMode).length === 0) {
      ngDevModeResetPerfCounters();
    }
    return typeof ngDevMode !== "undefined" && !!ngDevMode;
  }
  return false;
}
function getClosureSafeProperty(objWithPropertyToExtract) {
  for (let key in objWithPropertyToExtract) {
    if (objWithPropertyToExtract[key] === getClosureSafeProperty) {
      return key;
    }
  }
  throw Error("Could not find renamed property on target object.");
}
function fillProperties(target, source) {
  for (const key in source) {
    if (source.hasOwnProperty(key) && !target.hasOwnProperty(key)) {
      target[key] = source[key];
    }
  }
}
function stringify(token) {
  if (typeof token === "string") {
    return token;
  }
  if (Array.isArray(token)) {
    return "[" + token.map(stringify).join(", ") + "]";
  }
  if (token == null) {
    return "" + token;
  }
  if (token.overriddenName) {
    return `${token.overriddenName}`;
  }
  if (token.name) {
    return `${token.name}`;
  }
  const res = token.toString();
  if (res == null) {
    return "" + res;
  }
  const newLineIndex = res.indexOf("\n");
  return newLineIndex === -1 ? res : res.substring(0, newLineIndex);
}
function concatStringsWithSpace(before, after) {
  return before == null || before === "" ? after === null ? "" : after : after == null || after === "" ? before : before + " " + after;
}
var __forward_ref__ = getClosureSafeProperty({
  __forward_ref__: getClosureSafeProperty
});
function forwardRef(forwardRefFn) {
  forwardRefFn.__forward_ref__ = forwardRef;
  forwardRefFn.toString = function() {
    return stringify(this());
  };
  return forwardRefFn;
}
function resolveForwardRef(type) {
  return isForwardRef(type) ? type() : type;
}
function isForwardRef(fn) {
  return typeof fn === "function" && fn.hasOwnProperty(__forward_ref__) && fn.__forward_ref__ === forwardRef;
}
function assertNumber(actual, msg) {
  if (!(typeof actual === "number")) {
    throwError(msg, typeof actual, "number", "===");
  }
}
function assertNumberInRange(actual, minInclusive, maxInclusive) {
  assertNumber(actual, "Expected a number");
  assertLessThanOrEqual(actual, maxInclusive, "Expected number to be less than or equal to");
  assertGreaterThanOrEqual(actual, minInclusive, "Expected number to be greater than or equal to");
}
function assertString(actual, msg) {
  if (!(typeof actual === "string")) {
    throwError(msg, actual === null ? "null" : typeof actual, "string", "===");
  }
}
function assertFunction(actual, msg) {
  if (!(typeof actual === "function")) {
    throwError(msg, actual === null ? "null" : typeof actual, "function", "===");
  }
}
function assertEqual(actual, expected, msg) {
  if (!(actual == expected)) {
    throwError(msg, actual, expected, "==");
  }
}
function assertNotEqual(actual, expected, msg) {
  if (!(actual != expected)) {
    throwError(msg, actual, expected, "!=");
  }
}
function assertSame(actual, expected, msg) {
  if (!(actual === expected)) {
    throwError(msg, actual, expected, "===");
  }
}
function assertNotSame(actual, expected, msg) {
  if (!(actual !== expected)) {
    throwError(msg, actual, expected, "!==");
  }
}
function assertLessThan(actual, expected, msg) {
  if (!(actual < expected)) {
    throwError(msg, actual, expected, "<");
  }
}
function assertLessThanOrEqual(actual, expected, msg) {
  if (!(actual <= expected)) {
    throwError(msg, actual, expected, "<=");
  }
}
function assertGreaterThan(actual, expected, msg) {
  if (!(actual > expected)) {
    throwError(msg, actual, expected, ">");
  }
}
function assertGreaterThanOrEqual(actual, expected, msg) {
  if (!(actual >= expected)) {
    throwError(msg, actual, expected, ">=");
  }
}
function assertDefined(actual, msg) {
  if (actual == null) {
    throwError(msg, actual, null, "!=");
  }
}
function throwError(msg, actual, expected, comparison) {
  throw new Error(`ASSERTION ERROR: ${msg}` + (comparison == null ? "" : ` [Expected=> ${expected} ${comparison} ${actual} <=Actual]`));
}
function assertDomNode(node) {
  if (!(node instanceof Node)) {
    throwError(`The provided value must be an instance of a DOM Node but got ${stringify(node)}`);
  }
}
function assertElement(node) {
  if (!(node instanceof Element)) {
    throwError(`The provided value must be an element but got ${stringify(node)}`);
  }
}
function assertIndexInRange(arr, index) {
  assertDefined(arr, "Array must be defined.");
  const maxLen = arr.length;
  if (index < 0 || index >= maxLen) {
    throwError(`Index expected to be less than ${maxLen} but got ${index}`);
  }
}
function assertOneOf(value, ...validValues) {
  if (validValues.indexOf(value) !== -1) return true;
  throwError(`Expected value to be one of ${JSON.stringify(validValues)} but was ${JSON.stringify(value)}.`);
}
function assertNotReactive(fn) {
  if (getActiveConsumer() !== null) {
    throwError(`${fn}() should never be called in a reactive context.`);
  }
}
function ɵɵdefineInjectable(opts) {
  return {
    token: opts.token,
    providedIn: opts.providedIn || null,
    factory: opts.factory,
    value: void 0
  };
}
function ɵɵdefineInjector(options) {
  return {
    providers: options.providers || [],
    imports: options.imports || []
  };
}
function getInjectableDef(type) {
  return getOwnDefinition(type, NG_PROV_DEF) || getOwnDefinition(type, NG_INJECTABLE_DEF);
}
function getOwnDefinition(type, field) {
  return type.hasOwnProperty(field) ? type[field] : null;
}
function getInheritedInjectableDef(type) {
  const def = type && (type[NG_PROV_DEF] || type[NG_INJECTABLE_DEF]);
  if (def) {
    ngDevMode && console.warn(`DEPRECATED: DI is instantiating a token "${type.name}" that inherits its @Injectable decorator but does not provide one itself.
This will become an error in a future version of Angular. Please add @Injectable() to the "${type.name}" class.`);
    return def;
  } else {
    return null;
  }
}
function getInjectorDef(type) {
  return type && (type.hasOwnProperty(NG_INJ_DEF) || type.hasOwnProperty(NG_INJECTOR_DEF)) ? type[NG_INJ_DEF] : null;
}
var NG_PROV_DEF = getClosureSafeProperty({
  ɵprov: getClosureSafeProperty
});
var NG_INJ_DEF = getClosureSafeProperty({
  ɵinj: getClosureSafeProperty
});
var NG_INJECTABLE_DEF = getClosureSafeProperty({
  ngInjectableDef: getClosureSafeProperty
});
var NG_INJECTOR_DEF = getClosureSafeProperty({
  ngInjectorDef: getClosureSafeProperty
});
var InjectionToken = class {
  /**
   * @param _desc   Description for the token,
   *                used only for debugging purposes,
   *                it should but does not need to be unique
   * @param options Options for the token's usage, as described above
   */
  constructor(_desc, options) {
    this._desc = _desc;
    this.ngMetadataName = "InjectionToken";
    this.ɵprov = void 0;
    if (typeof options == "number") {
      (typeof ngDevMode === "undefined" || ngDevMode) && assertLessThan(options, 0, "Only negative numbers are supported here");
      this.__NG_ELEMENT_ID__ = options;
    } else if (options !== void 0) {
      this.ɵprov = ɵɵdefineInjectable({
        token: this,
        providedIn: options.providedIn || "root",
        factory: options.factory
      });
    }
  }
  /**
   * @internal
   */
  get multi() {
    return this;
  }
  toString() {
    return `InjectionToken ${this._desc}`;
  }
};
var _injectorProfilerContext;
function getInjectorProfilerContext() {
  !ngDevMode && throwError("getInjectorProfilerContext should never be called in production mode");
  return _injectorProfilerContext;
}
function setInjectorProfilerContext(context) {
  !ngDevMode && throwError("setInjectorProfilerContext should never be called in production mode");
  const previous = _injectorProfilerContext;
  _injectorProfilerContext = context;
  return previous;
}
var injectorProfilerCallback = null;
var setInjectorProfiler = (injectorProfiler2) => {
  !ngDevMode && throwError("setInjectorProfiler should never be called in production mode");
  injectorProfilerCallback = injectorProfiler2;
};
function injectorProfiler(event) {
  !ngDevMode && throwError("Injector profiler should never be called in production mode");
  if (injectorProfilerCallback != null) {
    injectorProfilerCallback(event);
  }
}
function emitProviderConfiguredEvent(eventProvider, isViewProvider = false) {
  !ngDevMode && throwError("Injector profiler should never be called in production mode");
  let token;
  if (typeof eventProvider === "function") {
    token = eventProvider;
  } else if (eventProvider instanceof InjectionToken) {
    token = eventProvider;
  } else {
    token = resolveForwardRef(eventProvider.provide);
  }
  let provider = eventProvider;
  if (eventProvider instanceof InjectionToken) {
    provider = eventProvider.ɵprov || eventProvider;
  }
  injectorProfiler({
    type: 2,
    context: getInjectorProfilerContext(),
    providerRecord: {
      token,
      provider,
      isViewProvider
    }
  });
}
function emitInstanceCreatedByInjectorEvent(instance) {
  !ngDevMode && throwError("Injector profiler should never be called in production mode");
  injectorProfiler({
    type: 1,
    context: getInjectorProfilerContext(),
    instance: {
      value: instance
    }
  });
}
function emitInjectEvent(token, value, flags) {
  !ngDevMode && throwError("Injector profiler should never be called in production mode");
  injectorProfiler({
    type: 0,
    context: getInjectorProfilerContext(),
    service: {
      token,
      value,
      flags
    }
  });
}
function runInInjectorProfilerContext(injector, token, callback) {
  !ngDevMode && throwError("runInInjectorProfilerContext should never be called in production mode");
  const prevInjectContext = setInjectorProfilerContext({
    injector,
    token
  });
  try {
    callback();
  } finally {
    setInjectorProfilerContext(prevInjectContext);
  }
}
function isEnvironmentProviders(value) {
  return value && !!value.ɵproviders;
}
var NG_COMP_DEF = getClosureSafeProperty({
  ɵcmp: getClosureSafeProperty
});
var NG_DIR_DEF = getClosureSafeProperty({
  ɵdir: getClosureSafeProperty
});
var NG_PIPE_DEF = getClosureSafeProperty({
  ɵpipe: getClosureSafeProperty
});
var NG_MOD_DEF = getClosureSafeProperty({
  ɵmod: getClosureSafeProperty
});
var NG_FACTORY_DEF = getClosureSafeProperty({
  ɵfac: getClosureSafeProperty
});
var NG_ELEMENT_ID = getClosureSafeProperty({
  __NG_ELEMENT_ID__: getClosureSafeProperty
});
var NG_ENV_ID = getClosureSafeProperty({
  __NG_ENV_ID__: getClosureSafeProperty
});
function renderStringify(value) {
  if (typeof value === "string") return value;
  if (value == null) return "";
  return String(value);
}
function stringifyForError(value) {
  if (typeof value === "function") return value.name || value.toString();
  if (typeof value === "object" && value != null && typeof value.type === "function") {
    return value.type.name || value.type.toString();
  }
  return renderStringify(value);
}
function debugStringifyTypeForError(type) {
  let componentDef = type[NG_COMP_DEF] || null;
  if (componentDef !== null && componentDef.debugInfo) {
    return stringifyTypeFromDebugInfo(componentDef.debugInfo);
  }
  return stringifyForError(type);
}
function stringifyTypeFromDebugInfo(debugInfo) {
  if (!debugInfo.filePath || !debugInfo.lineNumber) {
    return debugInfo.className;
  } else {
    return `${debugInfo.className} (at ${debugInfo.filePath}:${debugInfo.lineNumber})`;
  }
}
function throwCyclicDependencyError(token, path) {
  const depPath = path ? `. Dependency path: ${path.join(" > ")} > ${token}` : "";
  throw new RuntimeError(-200, ngDevMode ? `Circular dependency in DI detected for ${token}${depPath}` : token);
}
function throwMixedMultiProviderError() {
  throw new Error(`Cannot mix multi providers and regular providers`);
}
function throwInvalidProviderError(ngModuleType, providers, provider) {
  if (ngModuleType && providers) {
    const providerDetail = providers.map((v) => v == provider ? "?" + provider + "?" : "...");
    throw new Error(`Invalid provider for the NgModule '${stringify(ngModuleType)}' - only instances of Provider and Type are allowed, got: [${providerDetail.join(", ")}]`);
  } else if (isEnvironmentProviders(provider)) {
    if (provider.ɵfromNgModule) {
      throw new RuntimeError(207, `Invalid providers from 'importProvidersFrom' present in a non-environment injector. 'importProvidersFrom' can't be used for component providers.`);
    } else {
      throw new RuntimeError(207, `Invalid providers present in a non-environment injector. 'EnvironmentProviders' can't be used for component providers.`);
    }
  } else {
    throw new Error("Invalid provider");
  }
}
function throwProviderNotFoundError(token, injectorName) {
  const errorMessage = ngDevMode && `No provider for ${stringifyForError(token)} found${injectorName ? ` in ${injectorName}` : ""}`;
  throw new RuntimeError(-201, errorMessage);
}
var InjectFlags;
(function(InjectFlags2) {
  InjectFlags2[InjectFlags2["Default"] = 0] = "Default";
  InjectFlags2[InjectFlags2["Host"] = 1] = "Host";
  InjectFlags2[InjectFlags2["Self"] = 2] = "Self";
  InjectFlags2[InjectFlags2["SkipSelf"] = 4] = "SkipSelf";
  InjectFlags2[InjectFlags2["Optional"] = 8] = "Optional";
})(InjectFlags || (InjectFlags = {}));
var _injectImplementation;
function getInjectImplementation() {
  return _injectImplementation;
}
function setInjectImplementation(impl) {
  const previous = _injectImplementation;
  _injectImplementation = impl;
  return previous;
}
function injectRootLimpMode(token, notFoundValue, flags) {
  const injectableDef = getInjectableDef(token);
  if (injectableDef && injectableDef.providedIn == "root") {
    return injectableDef.value === void 0 ? injectableDef.value = injectableDef.factory() : injectableDef.value;
  }
  if (flags & InjectFlags.Optional) return null;
  if (notFoundValue !== void 0) return notFoundValue;
  throwProviderNotFoundError(token, "Injector");
}
function assertInjectImplementationNotEqual(fn) {
  ngDevMode && assertNotEqual(_injectImplementation, fn, "Calling ɵɵinject would cause infinite recursion");
}
var _THROW_IF_NOT_FOUND = {};
var THROW_IF_NOT_FOUND = _THROW_IF_NOT_FOUND;
var DI_DECORATOR_FLAG = "__NG_DI_FLAG__";
var NG_TEMP_TOKEN_PATH = "ngTempTokenPath";
var NG_TOKEN_PATH = "ngTokenPath";
var NEW_LINE = /\n/gm;
var NO_NEW_LINE = "ɵ";
var SOURCE = "__source";
var _currentInjector = void 0;
function getCurrentInjector() {
  return _currentInjector;
}
function setCurrentInjector(injector) {
  const former = _currentInjector;
  _currentInjector = injector;
  return former;
}
function injectInjectorOnly(token, flags = InjectFlags.Default) {
  if (_currentInjector === void 0) {
    throw new RuntimeError(-203, ngDevMode && `inject() must be called from an injection context such as a constructor, a factory function, a field initializer, or a function used with \`runInInjectionContext\`.`);
  } else if (_currentInjector === null) {
    return injectRootLimpMode(token, void 0, flags);
  } else {
    const value = _currentInjector.get(token, flags & InjectFlags.Optional ? null : void 0, flags);
    ngDevMode && emitInjectEvent(token, value, flags);
    return value;
  }
}
function ɵɵinject(token, flags = InjectFlags.Default) {
  return (getInjectImplementation() || injectInjectorOnly)(resolveForwardRef(token), flags);
}
function ɵɵinvalidFactoryDep(index) {
  throw new RuntimeError(202, ngDevMode && `This constructor is not compatible with Angular Dependency Injection because its dependency at index ${index} of the parameter list is invalid.
This can happen if the dependency type is a primitive like a string or if an ancestor of this class is missing an Angular decorator.

Please check that 1) the type for the parameter at index ${index} is correct and 2) the correct Angular decorators are defined for this class and its ancestors.`);
}
function inject(token, flags = InjectFlags.Default) {
  return ɵɵinject(token, convertToBitFlags(flags));
}
function convertToBitFlags(flags) {
  if (typeof flags === "undefined" || typeof flags === "number") {
    return flags;
  }
  return 0 | // comment to force a line break in the formatter
  (flags.optional && 8) | (flags.host && 1) | (flags.self && 2) | (flags.skipSelf && 4);
}
function injectArgs(types) {
  const args = [];
  for (let i = 0; i < types.length; i++) {
    const arg = resolveForwardRef(types[i]);
    if (Array.isArray(arg)) {
      if (arg.length === 0) {
        throw new RuntimeError(900, ngDevMode && "Arguments array must have arguments.");
      }
      let type = void 0;
      let flags = InjectFlags.Default;
      for (let j = 0; j < arg.length; j++) {
        const meta = arg[j];
        const flag = getInjectFlag(meta);
        if (typeof flag === "number") {
          if (flag === -1) {
            type = meta.token;
          } else {
            flags |= flag;
          }
        } else {
          type = meta;
        }
      }
      args.push(ɵɵinject(type, flags));
    } else {
      args.push(ɵɵinject(arg));
    }
  }
  return args;
}
function attachInjectFlag(decorator, flag) {
  decorator[DI_DECORATOR_FLAG] = flag;
  decorator.prototype[DI_DECORATOR_FLAG] = flag;
  return decorator;
}
function getInjectFlag(token) {
  return token[DI_DECORATOR_FLAG];
}
function catchInjectorError(e, token, injectorErrorName, source) {
  const tokenPath = e[NG_TEMP_TOKEN_PATH];
  if (token[SOURCE]) {
    tokenPath.unshift(token[SOURCE]);
  }
  e.message = formatError("\n" + e.message, tokenPath, injectorErrorName, source);
  e[NG_TOKEN_PATH] = tokenPath;
  e[NG_TEMP_TOKEN_PATH] = null;
  throw e;
}
function formatError(text, obj, injectorErrorName, source = null) {
  text = text && text.charAt(0) === "\n" && text.charAt(1) == NO_NEW_LINE ? text.slice(2) : text;
  let context = stringify(obj);
  if (Array.isArray(obj)) {
    context = obj.map(stringify).join(" -> ");
  } else if (typeof obj === "object") {
    let parts = [];
    for (let key in obj) {
      if (obj.hasOwnProperty(key)) {
        let value = obj[key];
        parts.push(key + ":" + (typeof value === "string" ? JSON.stringify(value) : stringify(value)));
      }
    }
    context = `{${parts.join(", ")}}`;
  }
  return `${injectorErrorName}${source ? "(" + source + ")" : ""}[${context}]: ${text.replace(NEW_LINE, "\n  ")}`;
}
var Inject = attachInjectFlag(
  // Disable tslint because `DecoratorFlags` is a const enum which gets inlined.
  makeParamDecorator("Inject", (token) => ({
    token
  })),
  -1
  /* DecoratorFlags.Inject */
);
var Optional = (
  // Disable tslint because `InternalInjectFlags` is a const enum which gets inlined.
  // tslint:disable-next-line: no-toplevel-property-access
  attachInjectFlag(
    makeParamDecorator("Optional"),
    8
    /* InternalInjectFlags.Optional */
  )
);
var Self = (
  // Disable tslint because `InternalInjectFlags` is a const enum which gets inlined.
  // tslint:disable-next-line: no-toplevel-property-access
  attachInjectFlag(
    makeParamDecorator("Self"),
    2
    /* InternalInjectFlags.Self */
  )
);
var SkipSelf = (
  // Disable tslint because `InternalInjectFlags` is a const enum which gets inlined.
  // tslint:disable-next-line: no-toplevel-property-access
  attachInjectFlag(
    makeParamDecorator("SkipSelf"),
    4
    /* InternalInjectFlags.SkipSelf */
  )
);
var Host = (
  // Disable tslint because `InternalInjectFlags` is a const enum which gets inlined.
  // tslint:disable-next-line: no-toplevel-property-access
  attachInjectFlag(
    makeParamDecorator("Host"),
    1
    /* InternalInjectFlags.Host */
  )
);
function getFactoryDef(type, throwNotFound) {
  const hasFactoryDef = type.hasOwnProperty(NG_FACTORY_DEF);
  if (!hasFactoryDef && throwNotFound === true && ngDevMode) {
    throw new Error(`Type ${stringify(type)} does not have 'ɵfac' property.`);
  }
  return hasFactoryDef ? type[NG_FACTORY_DEF] : null;
}
function arrayEquals(a, b, identityAccessor) {
  if (a.length !== b.length) return false;
  for (let i = 0; i < a.length; i++) {
    let valueA = a[i];
    let valueB = b[i];
    if (identityAccessor) {
      valueA = identityAccessor(valueA);
      valueB = identityAccessor(valueB);
    }
    if (valueB !== valueA) {
      return false;
    }
  }
  return true;
}
function flatten(list) {
  return list.flat(Number.POSITIVE_INFINITY);
}
function deepForEach(input2, fn) {
  input2.forEach((value) => Array.isArray(value) ? deepForEach(value, fn) : fn(value));
}
function addToArray(arr, index, value) {
  if (index >= arr.length) {
    arr.push(value);
  } else {
    arr.splice(index, 0, value);
  }
}
function removeFromArray(arr, index) {
  if (index >= arr.length - 1) {
    return arr.pop();
  } else {
    return arr.splice(index, 1)[0];
  }
}
function newArray(size, value) {
  const list = [];
  for (let i = 0; i < size; i++) {
    list.push(value);
  }
  return list;
}
function arraySplice(array, index, count) {
  const length = array.length - count;
  while (index < length) {
    array[index] = array[index + count];
    index++;
  }
  while (count--) {
    array.pop();
  }
}
function arrayInsert2(array, index, value1, value2) {
  ngDevMode && assertLessThanOrEqual(index, array.length, "Can't insert past array end.");
  let end = array.length;
  if (end == index) {
    array.push(value1, value2);
  } else if (end === 1) {
    array.push(value2, array[0]);
    array[0] = value1;
  } else {
    end--;
    array.push(array[end - 1], array[end]);
    while (end > index) {
      const previousEnd = end - 2;
      array[end] = array[previousEnd];
      end--;
    }
    array[index] = value1;
    array[index + 1] = value2;
  }
}
function keyValueArraySet(keyValueArray, key, value) {
  let index = keyValueArrayIndexOf(keyValueArray, key);
  if (index >= 0) {
    keyValueArray[index | 1] = value;
  } else {
    index = ~index;
    arrayInsert2(keyValueArray, index, key, value);
  }
  return index;
}
function keyValueArrayGet(keyValueArray, key) {
  const index = keyValueArrayIndexOf(keyValueArray, key);
  if (index >= 0) {
    return keyValueArray[index | 1];
  }
  return void 0;
}
function keyValueArrayIndexOf(keyValueArray, key) {
  return _arrayIndexOfSorted(keyValueArray, key, 1);
}
function _arrayIndexOfSorted(array, value, shift) {
  ngDevMode && assertEqual(Array.isArray(array), true, "Expecting an array");
  let start = 0;
  let end = array.length >> shift;
  while (end !== start) {
    const middle = start + (end - start >> 1);
    const current = array[middle << shift];
    if (value === current) {
      return middle << shift;
    } else if (current > value) {
      end = middle;
    } else {
      start = middle + 1;
    }
  }
  return ~(end << shift);
}
var EMPTY_OBJ = {};
var EMPTY_ARRAY = [];
if ((typeof ngDevMode === "undefined" || ngDevMode) && initNgDevMode()) {
  Object.freeze(EMPTY_OBJ);
  Object.freeze(EMPTY_ARRAY);
}
var ENVIRONMENT_INITIALIZER = new InjectionToken(ngDevMode ? "ENVIRONMENT_INITIALIZER" : "");
var INJECTOR$1 = new InjectionToken(
  ngDevMode ? "INJECTOR" : "",
  // Disable tslint because this is const enum which gets inlined not top level prop access.
  // tslint:disable-next-line: no-toplevel-property-access
  -1
  /* InjectorMarkers.Injector */
);
var INJECTOR_DEF_TYPES = new InjectionToken(ngDevMode ? "INJECTOR_DEF_TYPES" : "");
var NullInjector = class {
  get(token, notFoundValue = THROW_IF_NOT_FOUND) {
    if (notFoundValue === THROW_IF_NOT_FOUND) {
      const error = new Error(`NullInjectorError: No provider for ${stringify(token)}!`);
      error.name = "NullInjectorError";
      throw error;
    }
    return notFoundValue;
  }
};
var ChangeDetectionStrategy;
(function(ChangeDetectionStrategy2) {
  ChangeDetectionStrategy2[ChangeDetectionStrategy2["OnPush"] = 0] = "OnPush";
  ChangeDetectionStrategy2[ChangeDetectionStrategy2["Default"] = 1] = "Default";
})(ChangeDetectionStrategy || (ChangeDetectionStrategy = {}));
var ViewEncapsulation$1;
(function(ViewEncapsulation2) {
  ViewEncapsulation2[ViewEncapsulation2["Emulated"] = 0] = "Emulated";
  ViewEncapsulation2[ViewEncapsulation2["None"] = 2] = "None";
  ViewEncapsulation2[ViewEncapsulation2["ShadowDom"] = 3] = "ShadowDom";
})(ViewEncapsulation$1 || (ViewEncapsulation$1 = {}));
var InputFlags;
(function(InputFlags2) {
  InputFlags2[InputFlags2["None"] = 0] = "None";
  InputFlags2[InputFlags2["SignalBased"] = 1] = "SignalBased";
  InputFlags2[InputFlags2["HasDecoratorInputTransform"] = 2] = "HasDecoratorInputTransform";
})(InputFlags || (InputFlags = {}));
function classIndexOf(className, classToSearch, startingIndex) {
  ngDevMode && assertNotEqual(classToSearch, "", 'can not look for "" string.');
  let end = className.length;
  while (true) {
    const foundIndex = className.indexOf(classToSearch, startingIndex);
    if (foundIndex === -1) return foundIndex;
    if (foundIndex === 0 || className.charCodeAt(foundIndex - 1) <= 32) {
      const length = classToSearch.length;
      if (foundIndex + length === end || className.charCodeAt(foundIndex + length) <= 32) {
        return foundIndex;
      }
    }
    startingIndex = foundIndex + 1;
  }
}
function setUpAttributes(renderer, native, attrs) {
  let i = 0;
  while (i < attrs.length) {
    const value = attrs[i];
    if (typeof value === "number") {
      if (value !== 0) {
        break;
      }
      i++;
      const namespaceURI = attrs[i++];
      const attrName = attrs[i++];
      const attrVal = attrs[i++];
      ngDevMode && ngDevMode.rendererSetAttribute++;
      renderer.setAttribute(native, attrName, attrVal, namespaceURI);
    } else {
      const attrName = value;
      const attrVal = attrs[++i];
      ngDevMode && ngDevMode.rendererSetAttribute++;
      if (isAnimationProp(attrName)) {
        renderer.setProperty(native, attrName, attrVal);
      } else {
        renderer.setAttribute(native, attrName, attrVal);
      }
      i++;
    }
  }
  return i;
}
function isNameOnlyAttributeMarker(marker) {
  return marker === 3 || marker === 4 || marker === 6;
}
function isAnimationProp(name) {
  return name.charCodeAt(0) === 64;
}
function mergeHostAttrs(dst, src) {
  if (src === null || src.length === 0) {
  } else if (dst === null || dst.length === 0) {
    dst = src.slice();
  } else {
    let srcMarker = -1;
    for (let i = 0; i < src.length; i++) {
      const item = src[i];
      if (typeof item === "number") {
        srcMarker = item;
      } else {
        if (srcMarker === 0) {
        } else if (srcMarker === -1 || srcMarker === 2) {
          mergeHostAttribute(dst, srcMarker, item, null, src[++i]);
        } else {
          mergeHostAttribute(dst, srcMarker, item, null, null);
        }
      }
    }
  }
  return dst;
}
function mergeHostAttribute(dst, marker, key1, key2, value) {
  let i = 0;
  let markerInsertPosition = dst.length;
  if (marker === -1) {
    markerInsertPosition = -1;
  } else {
    while (i < dst.length) {
      const dstValue = dst[i++];
      if (typeof dstValue === "number") {
        if (dstValue === marker) {
          markerInsertPosition = -1;
          break;
        } else if (dstValue > marker) {
          markerInsertPosition = i - 1;
          break;
        }
      }
    }
  }
  while (i < dst.length) {
    const item = dst[i];
    if (typeof item === "number") {
      break;
    } else if (item === key1) {
      if (key2 === null) {
        if (value !== null) {
          dst[i + 1] = value;
        }
        return;
      } else if (key2 === dst[i + 1]) {
        dst[i + 2] = value;
        return;
      }
    }
    i++;
    if (key2 !== null) i++;
    if (value !== null) i++;
  }
  if (markerInsertPosition !== -1) {
    dst.splice(markerInsertPosition, 0, marker);
    i = markerInsertPosition + 1;
  }
  dst.splice(i++, 0, key1);
  if (key2 !== null) {
    dst.splice(i++, 0, key2);
  }
  if (value !== null) {
    dst.splice(i++, 0, value);
  }
}
var NG_TEMPLATE_SELECTOR = "ng-template";
function isCssClassMatching(tNode, attrs, cssClassToMatch, isProjectionMode) {
  ngDevMode && assertEqual(cssClassToMatch, cssClassToMatch.toLowerCase(), "Class name expected to be lowercase.");
  let i = 0;
  if (isProjectionMode) {
    for (; i < attrs.length && typeof attrs[i] === "string"; i += 2) {
      if (attrs[i] === "class" && classIndexOf(attrs[i + 1].toLowerCase(), cssClassToMatch, 0) !== -1) {
        return true;
      }
    }
  } else if (isInlineTemplate(tNode)) {
    return false;
  }
  i = attrs.indexOf(1, i);
  if (i > -1) {
    let item;
    while (++i < attrs.length && typeof (item = attrs[i]) === "string") {
      if (item.toLowerCase() === cssClassToMatch) {
        return true;
      }
    }
  }
  return false;
}
function isInlineTemplate(tNode) {
  return tNode.type === 4 && tNode.value !== NG_TEMPLATE_SELECTOR;
}
function hasTagAndTypeMatch(tNode, currentSelector, isProjectionMode) {
  const tagNameToCompare = tNode.type === 4 && !isProjectionMode ? NG_TEMPLATE_SELECTOR : tNode.value;
  return currentSelector === tagNameToCompare;
}
function isNodeMatchingSelector(tNode, selector, isProjectionMode) {
  ngDevMode && assertDefined(selector[0], "Selector should have a tag name");
  let mode = 4;
  const nodeAttrs = tNode.attrs;
  const nameOnlyMarkerIdx = nodeAttrs !== null ? getNameOnlyMarkerIndex(nodeAttrs) : 0;
  let skipToNextSelector = false;
  for (let i = 0; i < selector.length; i++) {
    const current = selector[i];
    if (typeof current === "number") {
      if (!skipToNextSelector && !isPositive(mode) && !isPositive(current)) {
        return false;
      }
      if (skipToNextSelector && isPositive(current)) continue;
      skipToNextSelector = false;
      mode = current | mode & 1;
      continue;
    }
    if (skipToNextSelector) continue;
    if (mode & 4) {
      mode = 2 | mode & 1;
      if (current !== "" && !hasTagAndTypeMatch(tNode, current, isProjectionMode) || current === "" && selector.length === 1) {
        if (isPositive(mode)) return false;
        skipToNextSelector = true;
      }
    } else if (mode & 8) {
      if (nodeAttrs === null || !isCssClassMatching(tNode, nodeAttrs, current, isProjectionMode)) {
        if (isPositive(mode)) return false;
        skipToNextSelector = true;
      }
    } else {
      const selectorAttrValue = selector[++i];
      const attrIndexInNode = findAttrIndexInNode(current, nodeAttrs, isInlineTemplate(tNode), isProjectionMode);
      if (attrIndexInNode === -1) {
        if (isPositive(mode)) return false;
        skipToNextSelector = true;
        continue;
      }
      if (selectorAttrValue !== "") {
        let nodeAttrValue;
        if (attrIndexInNode > nameOnlyMarkerIdx) {
          nodeAttrValue = "";
        } else {
          ngDevMode && assertNotEqual(nodeAttrs[attrIndexInNode], 0, "We do not match directives on namespaced attributes");
          nodeAttrValue = nodeAttrs[attrIndexInNode + 1].toLowerCase();
        }
        if (mode & 2 && selectorAttrValue !== nodeAttrValue) {
          if (isPositive(mode)) return false;
          skipToNextSelector = true;
        }
      }
    }
  }
  return isPositive(mode) || skipToNextSelector;
}
function isPositive(mode) {
  return (mode & 1) === 0;
}
function findAttrIndexInNode(name, attrs, isInlineTemplate2, isProjectionMode) {
  if (attrs === null) return -1;
  let i = 0;
  if (isProjectionMode || !isInlineTemplate2) {
    let bindingsMode = false;
    while (i < attrs.length) {
      const maybeAttrName = attrs[i];
      if (maybeAttrName === name) {
        return i;
      } else if (maybeAttrName === 3 || maybeAttrName === 6) {
        bindingsMode = true;
      } else if (maybeAttrName === 1 || maybeAttrName === 2) {
        let value = attrs[++i];
        while (typeof value === "string") {
          value = attrs[++i];
        }
        continue;
      } else if (maybeAttrName === 4) {
        break;
      } else if (maybeAttrName === 0) {
        i += 4;
        continue;
      }
      i += bindingsMode ? 1 : 2;
    }
    return -1;
  } else {
    return matchTemplateAttribute(attrs, name);
  }
}
function isNodeMatchingSelectorList(tNode, selector, isProjectionMode = false) {
  for (let i = 0; i < selector.length; i++) {
    if (isNodeMatchingSelector(tNode, selector[i], isProjectionMode)) {
      return true;
    }
  }
  return false;
}
function getProjectAsAttrValue(tNode) {
  const nodeAttrs = tNode.attrs;
  if (nodeAttrs != null) {
    const ngProjectAsAttrIdx = nodeAttrs.indexOf(
      5
      /* AttributeMarker.ProjectAs */
    );
    if ((ngProjectAsAttrIdx & 1) === 0) {
      return nodeAttrs[ngProjectAsAttrIdx + 1];
    }
  }
  return null;
}
function getNameOnlyMarkerIndex(nodeAttrs) {
  for (let i = 0; i < nodeAttrs.length; i++) {
    const nodeAttr = nodeAttrs[i];
    if (isNameOnlyAttributeMarker(nodeAttr)) {
      return i;
    }
  }
  return nodeAttrs.length;
}
function matchTemplateAttribute(attrs, name) {
  let i = attrs.indexOf(
    4
    /* AttributeMarker.Template */
  );
  if (i > -1) {
    i++;
    while (i < attrs.length) {
      const attr = attrs[i];
      if (typeof attr === "number") return -1;
      if (attr === name) return i;
      i++;
    }
  }
  return -1;
}
function isSelectorInSelectorList(selector, list) {
  selectorListLoop: for (let i = 0; i < list.length; i++) {
    const currentSelectorInList = list[i];
    if (selector.length !== currentSelectorInList.length) {
      continue;
    }
    for (let j = 0; j < selector.length; j++) {
      if (selector[j] !== currentSelectorInList[j]) {
        continue selectorListLoop;
      }
    }
    return true;
  }
  return false;
}
function maybeWrapInNotSelector(isNegativeMode, chunk) {
  return isNegativeMode ? ":not(" + chunk.trim() + ")" : chunk;
}
function stringifyCSSSelector(selector) {
  let result = selector[0];
  let i = 1;
  let mode = 2;
  let currentChunk = "";
  let isNegativeMode = false;
  while (i < selector.length) {
    let valueOrMarker = selector[i];
    if (typeof valueOrMarker === "string") {
      if (mode & 2) {
        const attrValue = selector[++i];
        currentChunk += "[" + valueOrMarker + (attrValue.length > 0 ? '="' + attrValue + '"' : "") + "]";
      } else if (mode & 8) {
        currentChunk += "." + valueOrMarker;
      } else if (mode & 4) {
        currentChunk += " " + valueOrMarker;
      }
    } else {
      if (currentChunk !== "" && !isPositive(valueOrMarker)) {
        result += maybeWrapInNotSelector(isNegativeMode, currentChunk);
        currentChunk = "";
      }
      mode = valueOrMarker;
      isNegativeMode = isNegativeMode || !isPositive(mode);
    }
    i++;
  }
  if (currentChunk !== "") {
    result += maybeWrapInNotSelector(isNegativeMode, currentChunk);
  }
  return result;
}
function stringifyCSSSelectorList(selectorList) {
  return selectorList.map(stringifyCSSSelector).join(",");
}
function extractAttrsAndClassesFromSelector(selector) {
  const attrs = [];
  const classes = [];
  let i = 1;
  let mode = 2;
  while (i < selector.length) {
    let valueOrMarker = selector[i];
    if (typeof valueOrMarker === "string") {
      if (mode === 2) {
        if (valueOrMarker !== "") {
          attrs.push(valueOrMarker, selector[++i]);
        }
      } else if (mode === 8) {
        classes.push(valueOrMarker);
      }
    } else {
      if (!isPositive(mode)) break;
      mode = valueOrMarker;
    }
    i++;
  }
  return {
    attrs,
    classes
  };
}
function ɵɵdefineComponent(componentDefinition) {
  return noSideEffects(() => {
    (typeof ngDevMode === "undefined" || ngDevMode) && initNgDevMode();
    const baseDef = getNgDirectiveDef(componentDefinition);
    const def = __spreadProps(__spreadValues({}, baseDef), {
      decls: componentDefinition.decls,
      vars: componentDefinition.vars,
      template: componentDefinition.template,
      consts: componentDefinition.consts || null,
      ngContentSelectors: componentDefinition.ngContentSelectors,
      onPush: componentDefinition.changeDetection === ChangeDetectionStrategy.OnPush,
      directiveDefs: null,
      // assigned in noSideEffects
      pipeDefs: null,
      // assigned in noSideEffects
      dependencies: baseDef.standalone && componentDefinition.dependencies || null,
      getStandaloneInjector: null,
      signals: componentDefinition.signals ?? false,
      data: componentDefinition.data || {},
      encapsulation: componentDefinition.encapsulation || ViewEncapsulation$1.Emulated,
      styles: componentDefinition.styles || EMPTY_ARRAY,
      _: null,
      schemas: componentDefinition.schemas || null,
      tView: null,
      id: ""
    });
    initFeatures(def);
    const dependencies = componentDefinition.dependencies;
    def.directiveDefs = extractDefListOrFactory(
      dependencies,
      /* pipeDef */
      false
    );
    def.pipeDefs = extractDefListOrFactory(
      dependencies,
      /* pipeDef */
      true
    );
    def.id = getComponentId(def);
    return def;
  });
}
function extractDirectiveDef(type) {
  return getComponentDef(type) || getDirectiveDef(type);
}
function nonNull(value) {
  return value !== null;
}
function ɵɵdefineNgModule(def) {
  return noSideEffects(() => {
    const res = {
      type: def.type,
      bootstrap: def.bootstrap || EMPTY_ARRAY,
      declarations: def.declarations || EMPTY_ARRAY,
      imports: def.imports || EMPTY_ARRAY,
      exports: def.exports || EMPTY_ARRAY,
      transitiveCompileScopes: null,
      schemas: def.schemas || null,
      id: def.id || null
    };
    return res;
  });
}
function parseAndConvertBindingsForDefinition(obj, declaredInputs) {
  if (obj == null) return EMPTY_OBJ;
  const newLookup = {};
  for (const minifiedKey in obj) {
    if (obj.hasOwnProperty(minifiedKey)) {
      const value = obj[minifiedKey];
      let publicName;
      let declaredName;
      let inputFlags = InputFlags.None;
      if (Array.isArray(value)) {
        inputFlags = value[0];
        publicName = value[1];
        declaredName = value[2] ?? publicName;
      } else {
        publicName = value;
        declaredName = value;
      }
      if (declaredInputs) {
        newLookup[publicName] = inputFlags !== InputFlags.None ? [minifiedKey, inputFlags] : minifiedKey;
        declaredInputs[publicName] = declaredName;
      } else {
        newLookup[publicName] = minifiedKey;
      }
    }
  }
  return newLookup;
}
function ɵɵdefineDirective(directiveDefinition) {
  return noSideEffects(() => {
    const def = getNgDirectiveDef(directiveDefinition);
    initFeatures(def);
    return def;
  });
}
function ɵɵdefinePipe(pipeDef) {
  return {
    type: pipeDef.type,
    name: pipeDef.name,
    factory: null,
    pure: pipeDef.pure !== false,
    standalone: pipeDef.standalone === true,
    onDestroy: pipeDef.type.prototype.ngOnDestroy || null
  };
}
function getComponentDef(type) {
  return type[NG_COMP_DEF] || null;
}
function getDirectiveDef(type) {
  return type[NG_DIR_DEF] || null;
}
function getPipeDef$1(type) {
  return type[NG_PIPE_DEF] || null;
}
function isStandalone(type) {
  const def = getComponentDef(type) || getDirectiveDef(type) || getPipeDef$1(type);
  return def !== null ? def.standalone : false;
}
function getNgModuleDef(type, throwNotFound) {
  const ngModuleDef = type[NG_MOD_DEF] || null;
  if (!ngModuleDef && throwNotFound === true) {
    throw new Error(`Type ${stringify(type)} does not have 'ɵmod' property.`);
  }
  return ngModuleDef;
}
function getNgDirectiveDef(directiveDefinition) {
  const declaredInputs = {};
  return {
    type: directiveDefinition.type,
    providersResolver: null,
    factory: null,
    hostBindings: directiveDefinition.hostBindings || null,
    hostVars: directiveDefinition.hostVars || 0,
    hostAttrs: directiveDefinition.hostAttrs || null,
    contentQueries: directiveDefinition.contentQueries || null,
    declaredInputs,
    inputTransforms: null,
    inputConfig: directiveDefinition.inputs || EMPTY_OBJ,
    exportAs: directiveDefinition.exportAs || null,
    standalone: directiveDefinition.standalone === true,
    signals: directiveDefinition.signals === true,
    selectors: directiveDefinition.selectors || EMPTY_ARRAY,
    viewQuery: directiveDefinition.viewQuery || null,
    features: directiveDefinition.features || null,
    setInput: null,
    findHostDirectiveDefs: null,
    hostDirectives: null,
    inputs: parseAndConvertBindingsForDefinition(directiveDefinition.inputs, declaredInputs),
    outputs: parseAndConvertBindingsForDefinition(directiveDefinition.outputs),
    debugInfo: null
  };
}
function initFeatures(definition) {
  definition.features?.forEach((fn) => fn(definition));
}
function extractDefListOrFactory(dependencies, pipeDef) {
  if (!dependencies) {
    return null;
  }
  const defExtractor = pipeDef ? getPipeDef$1 : extractDirectiveDef;
  return () => (typeof dependencies === "function" ? dependencies() : dependencies).map((dep) => defExtractor(dep)).filter(nonNull);
}
var GENERATED_COMP_IDS = /* @__PURE__ */ new Map();
function getComponentId(componentDef) {
  let hash = 0;
  const hashSelectors = [
    componentDef.selectors,
    componentDef.ngContentSelectors,
    componentDef.hostVars,
    componentDef.hostAttrs,
    componentDef.consts,
    componentDef.vars,
    componentDef.decls,
    componentDef.encapsulation,
    componentDef.standalone,
    componentDef.signals,
    componentDef.exportAs,
    JSON.stringify(componentDef.inputs),
    JSON.stringify(componentDef.outputs),
    // We cannot use 'componentDef.type.name' as the name of the symbol will change and will not
    // match in the server and browser bundles.
    Object.getOwnPropertyNames(componentDef.type.prototype),
    !!componentDef.contentQueries,
    !!componentDef.viewQuery
  ].join("|");
  for (const char of hashSelectors) {
    hash = Math.imul(31, hash) + char.charCodeAt(0) << 0;
  }
  hash += 2147483647 + 1;
  const compId = "c" + hash;
  if (typeof ngDevMode === "undefined" || ngDevMode) {
    if (GENERATED_COMP_IDS.has(compId)) {
      const previousCompDefType = GENERATED_COMP_IDS.get(compId);
      if (previousCompDefType !== componentDef.type) {
        console.warn(formatRuntimeError(-912, `Component ID generation collision detected. Components '${previousCompDefType.name}' and '${componentDef.type.name}' with selector '${stringifyCSSSelectorList(componentDef.selectors)}' generated the same component ID. To fix this, you can change the selector of one of those components or add an extra host attribute to force a different ID.`));
      }
    } else {
      GENERATED_COMP_IDS.set(compId, componentDef.type);
    }
  }
  return compId;
}
function importProvidersFrom(...sources) {
  return {
    ɵproviders: internalImportProvidersFrom(true, sources),
    ɵfromNgModule: true
  };
}
function internalImportProvidersFrom(checkForStandaloneCmp, ...sources) {
  const providersOut = [];
  const dedup = /* @__PURE__ */ new Set();
  let injectorTypesWithProviders;
  const collectProviders = (provider) => {
    providersOut.push(provider);
  };
  deepForEach(sources, (source) => {
    if ((typeof ngDevMode === "undefined" || ngDevMode) && checkForStandaloneCmp) {
      const cmpDef = getComponentDef(source);
      if (cmpDef?.standalone) {
        throw new RuntimeError(800, `Importing providers supports NgModule or ModuleWithProviders but got a standalone component "${stringifyForError(source)}"`);
      }
    }
    const internalSource = source;
    if (walkProviderTree(internalSource, collectProviders, [], dedup)) {
      injectorTypesWithProviders ||= [];
      injectorTypesWithProviders.push(internalSource);
    }
  });
  if (injectorTypesWithProviders !== void 0) {
    processInjectorTypesWithProviders(injectorTypesWithProviders, collectProviders);
  }
  return providersOut;
}
function processInjectorTypesWithProviders(typesWithProviders, visitor) {
  for (let i = 0; i < typesWithProviders.length; i++) {
    const {
      ngModule,
      providers
    } = typesWithProviders[i];
    deepForEachProvider(providers, (provider) => {
      ngDevMode && validateProvider(provider, providers || EMPTY_ARRAY, ngModule);
      visitor(provider, ngModule);
    });
  }
}
function walkProviderTree(container, visitor, parents, dedup) {
  container = resolveForwardRef(container);
  if (!container) return false;
  let defType = null;
  let injDef = getInjectorDef(container);
  const cmpDef = !injDef && getComponentDef(container);
  if (!injDef && !cmpDef) {
    const ngModule = container.ngModule;
    injDef = getInjectorDef(ngModule);
    if (injDef) {
      defType = ngModule;
    } else {
      return false;
    }
  } else if (cmpDef && !cmpDef.standalone) {
    return false;
  } else {
    defType = container;
  }
  if (ngDevMode && parents.indexOf(defType) !== -1) {
    const defName = stringify(defType);
    const path = parents.map(stringify);
    throwCyclicDependencyError(defName, path);
  }
  const isDuplicate = dedup.has(defType);
  if (cmpDef) {
    if (isDuplicate) {
      return false;
    }
    dedup.add(defType);
    if (cmpDef.dependencies) {
      const deps = typeof cmpDef.dependencies === "function" ? cmpDef.dependencies() : cmpDef.dependencies;
      for (const dep of deps) {
        walkProviderTree(dep, visitor, parents, dedup);
      }
    }
  } else if (injDef) {
    if (injDef.imports != null && !isDuplicate) {
      ngDevMode && parents.push(defType);
      dedup.add(defType);
      let importTypesWithProviders;
      try {
        deepForEach(injDef.imports, (imported) => {
          if (walkProviderTree(imported, visitor, parents, dedup)) {
            importTypesWithProviders ||= [];
            importTypesWithProviders.push(imported);
          }
        });
      } finally {
        ngDevMode && parents.pop();
      }
      if (importTypesWithProviders !== void 0) {
        processInjectorTypesWithProviders(importTypesWithProviders, visitor);
      }
    }
    if (!isDuplicate) {
      const factory = getFactoryDef(defType) || (() => new defType());
      visitor({
        provide: defType,
        useFactory: factory,
        deps: EMPTY_ARRAY
      }, defType);
      visitor({
        provide: INJECTOR_DEF_TYPES,
        useValue: defType,
        multi: true
      }, defType);
      visitor({
        provide: ENVIRONMENT_INITIALIZER,
        useValue: () => ɵɵinject(defType),
        multi: true
      }, defType);
    }
    const defProviders = injDef.providers;
    if (defProviders != null && !isDuplicate) {
      const injectorType = container;
      deepForEachProvider(defProviders, (provider) => {
        ngDevMode && validateProvider(provider, defProviders, injectorType);
        visitor(provider, injectorType);
      });
    }
  } else {
    return false;
  }
  return defType !== container && container.providers !== void 0;
}
function validateProvider(provider, providers, containerType) {
  if (isTypeProvider(provider) || isValueProvider(provider) || isFactoryProvider(provider) || isExistingProvider(provider)) {
    return;
  }
  const classRef = resolveForwardRef(provider && (provider.useClass || provider.provide));
  if (!classRef) {
    throwInvalidProviderError(containerType, providers, provider);
  }
}
function deepForEachProvider(providers, fn) {
  for (let provider of providers) {
    if (isEnvironmentProviders(provider)) {
      provider = provider.ɵproviders;
    }
    if (Array.isArray(provider)) {
      deepForEachProvider(provider, fn);
    } else {
      fn(provider);
    }
  }
}
var USE_VALUE$1 = getClosureSafeProperty({
  provide: String,
  useValue: getClosureSafeProperty
});
function isValueProvider(value) {
  return value !== null && typeof value == "object" && USE_VALUE$1 in value;
}
function isExistingProvider(value) {
  return !!(value && value.useExisting);
}
function isFactoryProvider(value) {
  return !!(value && value.useFactory);
}
function isTypeProvider(value) {
  return typeof value === "function";
}
function isClassProvider(value) {
  return !!value.useClass;
}
var INJECTOR_SCOPE = new InjectionToken(ngDevMode ? "Set Injector scope." : "");
var NOT_YET = {};
var CIRCULAR = {};
var NULL_INJECTOR = void 0;
function getNullInjector() {
  if (NULL_INJECTOR === void 0) {
    NULL_INJECTOR = new NullInjector();
  }
  return NULL_INJECTOR;
}
var EnvironmentInjector = class {
};
var R3Injector = class extends EnvironmentInjector {
  /**
   * Flag indicating that this injector was previously destroyed.
   */
  get destroyed() {
    return this._destroyed;
  }
  constructor(providers, parent, source, scopes) {
    super();
    this.parent = parent;
    this.source = source;
    this.scopes = scopes;
    this.records = /* @__PURE__ */ new Map();
    this._ngOnDestroyHooks = /* @__PURE__ */ new Set();
    this._onDestroyHooks = [];
    this._destroyed = false;
    forEachSingleProvider(providers, (provider) => this.processProvider(provider));
    this.records.set(INJECTOR$1, makeRecord(void 0, this));
    if (scopes.has("environment")) {
      this.records.set(EnvironmentInjector, makeRecord(void 0, this));
    }
    const record = this.records.get(INJECTOR_SCOPE);
    if (record != null && typeof record.value === "string") {
      this.scopes.add(record.value);
    }
    this.injectorDefTypes = new Set(this.get(INJECTOR_DEF_TYPES, EMPTY_ARRAY, InjectFlags.Self));
  }
  /**
   * Destroy the injector and release references to every instance or provider associated with it.
   *
   * Also calls the `OnDestroy` lifecycle hooks of every instance that was created for which a
   * hook was found.
   */
  destroy() {
    this.assertNotDestroyed();
    this._destroyed = true;
    const prevConsumer = setActiveConsumer(null);
    try {
      for (const service of this._ngOnDestroyHooks) {
        service.ngOnDestroy();
      }
      const onDestroyHooks = this._onDestroyHooks;
      this._onDestroyHooks = [];
      for (const hook of onDestroyHooks) {
        hook();
      }
    } finally {
      this.records.clear();
      this._ngOnDestroyHooks.clear();
      this.injectorDefTypes.clear();
      setActiveConsumer(prevConsumer);
    }
  }
  onDestroy(callback) {
    this.assertNotDestroyed();
    this._onDestroyHooks.push(callback);
    return () => this.removeOnDestroy(callback);
  }
  runInContext(fn) {
    this.assertNotDestroyed();
    const previousInjector = setCurrentInjector(this);
    const previousInjectImplementation = setInjectImplementation(void 0);
    let prevInjectContext;
    if (ngDevMode) {
      prevInjectContext = setInjectorProfilerContext({
        injector: this,
        token: null
      });
    }
    try {
      return fn();
    } finally {
      setCurrentInjector(previousInjector);
      setInjectImplementation(previousInjectImplementation);
      ngDevMode && setInjectorProfilerContext(prevInjectContext);
    }
  }
  get(token, notFoundValue = THROW_IF_NOT_FOUND, flags = InjectFlags.Default) {
    this.assertNotDestroyed();
    if (token.hasOwnProperty(NG_ENV_ID)) {
      return token[NG_ENV_ID](this);
    }
    flags = convertToBitFlags(flags);
    let prevInjectContext;
    if (ngDevMode) {
      prevInjectContext = setInjectorProfilerContext({
        injector: this,
        token
      });
    }
    const previousInjector = setCurrentInjector(this);
    const previousInjectImplementation = setInjectImplementation(void 0);
    try {
      if (!(flags & InjectFlags.SkipSelf)) {
        let record = this.records.get(token);
        if (record === void 0) {
          const def = couldBeInjectableType(token) && getInjectableDef(token);
          if (def && this.injectableDefInScope(def)) {
            if (ngDevMode) {
              runInInjectorProfilerContext(this, token, () => {
                emitProviderConfiguredEvent(token);
              });
            }
            record = makeRecord(injectableDefOrInjectorDefFactory(token), NOT_YET);
          } else {
            record = null;
          }
          this.records.set(token, record);
        }
        if (record != null) {
          return this.hydrate(token, record);
        }
      }
      const nextInjector = !(flags & InjectFlags.Self) ? this.parent : getNullInjector();
      notFoundValue = flags & InjectFlags.Optional && notFoundValue === THROW_IF_NOT_FOUND ? null : notFoundValue;
      return nextInjector.get(token, notFoundValue);
    } catch (e) {
      if (e.name === "NullInjectorError") {
        const path = e[NG_TEMP_TOKEN_PATH] = e[NG_TEMP_TOKEN_PATH] || [];
        path.unshift(stringify(token));
        if (previousInjector) {
          throw e;
        } else {
          return catchInjectorError(e, token, "R3InjectorError", this.source);
        }
      } else {
        throw e;
      }
    } finally {
      setInjectImplementation(previousInjectImplementation);
      setCurrentInjector(previousInjector);
      ngDevMode && setInjectorProfilerContext(prevInjectContext);
    }
  }
  /** @internal */
  resolveInjectorInitializers() {
    const prevConsumer = setActiveConsumer(null);
    const previousInjector = setCurrentInjector(this);
    const previousInjectImplementation = setInjectImplementation(void 0);
    let prevInjectContext;
    if (ngDevMode) {
      prevInjectContext = setInjectorProfilerContext({
        injector: this,
        token: null
      });
    }
    try {
      const initializers = this.get(ENVIRONMENT_INITIALIZER, EMPTY_ARRAY, InjectFlags.Self);
      if (ngDevMode && !Array.isArray(initializers)) {
        throw new RuntimeError(-209, `Unexpected type of the \`ENVIRONMENT_INITIALIZER\` token value (expected an array, but got ${typeof initializers}). Please check that the \`ENVIRONMENT_INITIALIZER\` token is configured as a \`multi: true\` provider.`);
      }
      for (const initializer of initializers) {
        initializer();
      }
    } finally {
      setCurrentInjector(previousInjector);
      setInjectImplementation(previousInjectImplementation);
      ngDevMode && setInjectorProfilerContext(prevInjectContext);
      setActiveConsumer(prevConsumer);
    }
  }
  toString() {
    const tokens = [];
    const records = this.records;
    for (const token of records.keys()) {
      tokens.push(stringify(token));
    }
    return `R3Injector[${tokens.join(", ")}]`;
  }
  assertNotDestroyed() {
    if (this._destroyed) {
      throw new RuntimeError(205, ngDevMode && "Injector has already been destroyed.");
    }
  }
  /**
   * Process a `SingleProvider` and add it.
   */
  processProvider(provider) {
    provider = resolveForwardRef(provider);
    let token = isTypeProvider(provider) ? provider : resolveForwardRef(provider && provider.provide);
    const record = providerToRecord(provider);
    if (ngDevMode) {
      runInInjectorProfilerContext(this, token, () => {
        if (isValueProvider(provider)) {
          emitInstanceCreatedByInjectorEvent(provider.useValue);
        }
        emitProviderConfiguredEvent(provider);
      });
    }
    if (!isTypeProvider(provider) && provider.multi === true) {
      let multiRecord = this.records.get(token);
      if (multiRecord) {
        if (ngDevMode && multiRecord.multi === void 0) {
          throwMixedMultiProviderError();
        }
      } else {
        multiRecord = makeRecord(void 0, NOT_YET, true);
        multiRecord.factory = () => injectArgs(multiRecord.multi);
        this.records.set(token, multiRecord);
      }
      token = provider;
      multiRecord.multi.push(provider);
    } else {
      if (ngDevMode) {
        const existing = this.records.get(token);
        if (existing && existing.multi !== void 0) {
          throwMixedMultiProviderError();
        }
      }
    }
    this.records.set(token, record);
  }
  hydrate(token, record) {
    const prevConsumer = setActiveConsumer(null);
    try {
      if (ngDevMode && record.value === CIRCULAR) {
        throwCyclicDependencyError(stringify(token));
      } else if (record.value === NOT_YET) {
        record.value = CIRCULAR;
        if (ngDevMode) {
          runInInjectorProfilerContext(this, token, () => {
            record.value = record.factory();
            emitInstanceCreatedByInjectorEvent(record.value);
          });
        } else {
          record.value = record.factory();
        }
      }
      if (typeof record.value === "object" && record.value && hasOnDestroy(record.value)) {
        this._ngOnDestroyHooks.add(record.value);
      }
      return record.value;
    } finally {
      setActiveConsumer(prevConsumer);
    }
  }
  injectableDefInScope(def) {
    if (!def.providedIn) {
      return false;
    }
    const providedIn = resolveForwardRef(def.providedIn);
    if (typeof providedIn === "string") {
      return providedIn === "any" || this.scopes.has(providedIn);
    } else {
      return this.injectorDefTypes.has(providedIn);
    }
  }
  removeOnDestroy(callback) {
    const destroyCBIdx = this._onDestroyHooks.indexOf(callback);
    if (destroyCBIdx !== -1) {
      this._onDestroyHooks.splice(destroyCBIdx, 1);
    }
  }
};
function injectableDefOrInjectorDefFactory(token) {
  const injectableDef = getInjectableDef(token);
  const factory = injectableDef !== null ? injectableDef.factory : getFactoryDef(token);
  if (factory !== null) {
    return factory;
  }
  if (token instanceof InjectionToken) {
    throw new RuntimeError(204, ngDevMode && `Token ${stringify(token)} is missing a ɵprov definition.`);
  }
  if (token instanceof Function) {
    return getUndecoratedInjectableFactory(token);
  }
  throw new RuntimeError(204, ngDevMode && "unreachable");
}
function getUndecoratedInjectableFactory(token) {
  const paramLength = token.length;
  if (paramLength > 0) {
    throw new RuntimeError(204, ngDevMode && `Can't resolve all parameters for ${stringify(token)}: (${newArray(paramLength, "?").join(", ")}).`);
  }
  const inheritedInjectableDef = getInheritedInjectableDef(token);
  if (inheritedInjectableDef !== null) {
    return () => inheritedInjectableDef.factory(token);
  } else {
    return () => new token();
  }
}
function providerToRecord(provider) {
  if (isValueProvider(provider)) {
    return makeRecord(void 0, provider.useValue);
  } else {
    const factory = providerToFactory(provider);
    return makeRecord(factory, NOT_YET);
  }
}
function providerToFactory(provider, ngModuleType, providers) {
  let factory = void 0;
  if (ngDevMode && isEnvironmentProviders(provider)) {
    throwInvalidProviderError(void 0, providers, provider);
  }
  if (isTypeProvider(provider)) {
    const unwrappedProvider = resolveForwardRef(provider);
    return getFactoryDef(unwrappedProvider) || injectableDefOrInjectorDefFactory(unwrappedProvider);
  } else {
    if (isValueProvider(provider)) {
      factory = () => resolveForwardRef(provider.useValue);
    } else if (isFactoryProvider(provider)) {
      factory = () => provider.useFactory(...injectArgs(provider.deps || []));
    } else if (isExistingProvider(provider)) {
      factory = () => ɵɵinject(resolveForwardRef(provider.useExisting));
    } else {
      const classRef = resolveForwardRef(provider && (provider.useClass || provider.provide));
      if (ngDevMode && !classRef) {
        throwInvalidProviderError(ngModuleType, providers, provider);
      }
      if (hasDeps(provider)) {
        factory = () => new classRef(...injectArgs(provider.deps));
      } else {
        return getFactoryDef(classRef) || injectableDefOrInjectorDefFactory(classRef);
      }
    }
  }
  return factory;
}
function makeRecord(factory, value, multi = false) {
  return {
    factory,
    value,
    multi: multi ? [] : void 0
  };
}
function hasDeps(value) {
  return !!value.deps;
}
function hasOnDestroy(value) {
  return value !== null && typeof value === "object" && typeof value.ngOnDestroy === "function";
}
function couldBeInjectableType(value) {
  return typeof value === "function" || typeof value === "object" && value instanceof InjectionToken;
}
function forEachSingleProvider(providers, fn) {
  for (const provider of providers) {
    if (Array.isArray(provider)) {
      forEachSingleProvider(provider, fn);
    } else if (provider && isEnvironmentProviders(provider)) {
      forEachSingleProvider(provider.ɵproviders, fn);
    } else {
      fn(provider);
    }
  }
}
function isInInjectionContext() {
  return getInjectImplementation() !== void 0 || getCurrentInjector() != null;
}
function assertInInjectionContext(debugFn) {
  if (!isInInjectionContext()) {
    throw new RuntimeError(-203, ngDevMode && debugFn.name + "() can only be used within an injection context such as a constructor, a factory function, a field initializer, or a function used with `runInInjectionContext`");
  }
}
var FactoryTarget;
(function(FactoryTarget2) {
  FactoryTarget2[FactoryTarget2["Directive"] = 0] = "Directive";
  FactoryTarget2[FactoryTarget2["Component"] = 1] = "Component";
  FactoryTarget2[FactoryTarget2["Injectable"] = 2] = "Injectable";
  FactoryTarget2[FactoryTarget2["Pipe"] = 3] = "Pipe";
  FactoryTarget2[FactoryTarget2["NgModule"] = 4] = "NgModule";
})(FactoryTarget || (FactoryTarget = {}));
var R3TemplateDependencyKind;
(function(R3TemplateDependencyKind2) {
  R3TemplateDependencyKind2[R3TemplateDependencyKind2["Directive"] = 0] = "Directive";
  R3TemplateDependencyKind2[R3TemplateDependencyKind2["Pipe"] = 1] = "Pipe";
  R3TemplateDependencyKind2[R3TemplateDependencyKind2["NgModule"] = 2] = "NgModule";
})(R3TemplateDependencyKind || (R3TemplateDependencyKind = {}));
var ViewEncapsulation;
(function(ViewEncapsulation2) {
  ViewEncapsulation2[ViewEncapsulation2["Emulated"] = 0] = "Emulated";
  ViewEncapsulation2[ViewEncapsulation2["None"] = 2] = "None";
  ViewEncapsulation2[ViewEncapsulation2["ShadowDom"] = 3] = "ShadowDom";
})(ViewEncapsulation || (ViewEncapsulation = {}));
function getCompilerFacade(request) {
  const globalNg = _global["ng"];
  if (globalNg && globalNg.ɵcompilerFacade) {
    return globalNg.ɵcompilerFacade;
  }
  if (typeof ngDevMode === "undefined" || ngDevMode) {
    console.error(`JIT compilation failed for ${request.kind}`, request.type);
    let message = `The ${request.kind} '${request.type.name}' needs to be compiled using the JIT compiler, but '@angular/compiler' is not available.

`;
    if (request.usage === 1) {
      message += `The ${request.kind} is part of a library that has been partially compiled.
`;
      message += `However, the Angular Linker has not processed the library such that JIT compilation is used as fallback.
`;
      message += "\n";
      message += `Ideally, the library is processed using the Angular Linker to become fully AOT compiled.
`;
    } else {
      message += `JIT compilation is discouraged for production use-cases! Consider using AOT mode instead.
`;
    }
    message += `Alternatively, the JIT compiler should be loaded by bootstrapping using '@angular/platform-browser-dynamic' or '@angular/platform-server',
`;
    message += `or manually provide the compiler with 'import "@angular/compiler";' before bootstrapping.`;
    throw new Error(message);
  } else {
    throw new Error("JIT compiler unavailable");
  }
}
var angularCoreDiEnv = {
  "ɵɵdefineInjectable": ɵɵdefineInjectable,
  "ɵɵdefineInjector": ɵɵdefineInjector,
  "ɵɵinject": ɵɵinject,
  "ɵɵinvalidFactoryDep": ɵɵinvalidFactoryDep,
  "resolveForwardRef": resolveForwardRef
};
var Type = Function;
function isType(v) {
  return typeof v === "function";
}
var ES5_DELEGATE_CTOR = /^function\s+\S+\(\)\s*{[\s\S]+\.apply\(this,\s*(arguments|(?:[^()]+\(\[\],)?[^()]+\(arguments\).*)\)/;
var ES2015_INHERITED_CLASS = /^class\s+[A-Za-z\d$_]*\s*extends\s+[^{]+{/;
var ES2015_INHERITED_CLASS_WITH_CTOR = /^class\s+[A-Za-z\d$_]*\s*extends\s+[^{]+{[\s\S]*constructor\s*\(/;
var ES2015_INHERITED_CLASS_WITH_DELEGATE_CTOR = /^class\s+[A-Za-z\d$_]*\s*extends\s+[^{]+{[\s\S]*constructor\s*\(\)\s*{[^}]*super\(\.\.\.arguments\)/;
function isDelegateCtor(typeStr) {
  return ES5_DELEGATE_CTOR.test(typeStr) || ES2015_INHERITED_CLASS_WITH_DELEGATE_CTOR.test(typeStr) || ES2015_INHERITED_CLASS.test(typeStr) && !ES2015_INHERITED_CLASS_WITH_CTOR.test(typeStr);
}
var ReflectionCapabilities = class {
  constructor(reflect) {
    this._reflect = reflect || _global["Reflect"];
  }
  factory(t) {
    return (...args) => new t(...args);
  }
  /** @internal */
  _zipTypesAndAnnotations(paramTypes, paramAnnotations) {
    let result;
    if (typeof paramTypes === "undefined") {
      result = newArray(paramAnnotations.length);
    } else {
      result = newArray(paramTypes.length);
    }
    for (let i = 0; i < result.length; i++) {
      if (typeof paramTypes === "undefined") {
        result[i] = [];
      } else if (paramTypes[i] && paramTypes[i] != Object) {
        result[i] = [paramTypes[i]];
      } else {
        result[i] = [];
      }
      if (paramAnnotations && paramAnnotations[i] != null) {
        result[i] = result[i].concat(paramAnnotations[i]);
      }
    }
    return result;
  }
  _ownParameters(type, parentCtor) {
    const typeStr = type.toString();
    if (isDelegateCtor(typeStr)) {
      return null;
    }
    if (type.parameters && type.parameters !== parentCtor.parameters) {
      return type.parameters;
    }
    const tsickleCtorParams = type.ctorParameters;
    if (tsickleCtorParams && tsickleCtorParams !== parentCtor.ctorParameters) {
      const ctorParameters = typeof tsickleCtorParams === "function" ? tsickleCtorParams() : tsickleCtorParams;
      const paramTypes2 = ctorParameters.map((ctorParam) => ctorParam && ctorParam.type);
      const paramAnnotations2 = ctorParameters.map((ctorParam) => ctorParam && convertTsickleDecoratorIntoMetadata(ctorParam.decorators));
      return this._zipTypesAndAnnotations(paramTypes2, paramAnnotations2);
    }
    const paramAnnotations = type.hasOwnProperty(PARAMETERS) && type[PARAMETERS];
    const paramTypes = this._reflect && this._reflect.getOwnMetadata && this._reflect.getOwnMetadata("design:paramtypes", type);
    if (paramTypes || paramAnnotations) {
      return this._zipTypesAndAnnotations(paramTypes, paramAnnotations);
    }
    return newArray(type.length);
  }
  parameters(type) {
    if (!isType(type)) {
      return [];
    }
    const parentCtor = getParentCtor(type);
    let parameters = this._ownParameters(type, parentCtor);
    if (!parameters && parentCtor !== Object) {
      parameters = this.parameters(parentCtor);
    }
    return parameters || [];
  }
  _ownAnnotations(typeOrFunc, parentCtor) {
    if (typeOrFunc.annotations && typeOrFunc.annotations !== parentCtor.annotations) {
      let annotations = typeOrFunc.annotations;
      if (typeof annotations === "function" && annotations.annotations) {
        annotations = annotations.annotations;
      }
      return annotations;
    }
    if (typeOrFunc.decorators && typeOrFunc.decorators !== parentCtor.decorators) {
      return convertTsickleDecoratorIntoMetadata(typeOrFunc.decorators);
    }
    if (typeOrFunc.hasOwnProperty(ANNOTATIONS)) {
      return typeOrFunc[ANNOTATIONS];
    }
    return null;
  }
  annotations(typeOrFunc) {
    if (!isType(typeOrFunc)) {
      return [];
    }
    const parentCtor = getParentCtor(typeOrFunc);
    const ownAnnotations = this._ownAnnotations(typeOrFunc, parentCtor) || [];
    const parentAnnotations = parentCtor !== Object ? this.annotations(parentCtor) : [];
    return parentAnnotations.concat(ownAnnotations);
  }
  _ownPropMetadata(typeOrFunc, parentCtor) {
    if (typeOrFunc.propMetadata && typeOrFunc.propMetadata !== parentCtor.propMetadata) {
      let propMetadata = typeOrFunc.propMetadata;
      if (typeof propMetadata === "function" && propMetadata.propMetadata) {
        propMetadata = propMetadata.propMetadata;
      }
      return propMetadata;
    }
    if (typeOrFunc.propDecorators && typeOrFunc.propDecorators !== parentCtor.propDecorators) {
      const propDecorators = typeOrFunc.propDecorators;
      const propMetadata = {};
      Object.keys(propDecorators).forEach((prop) => {
        propMetadata[prop] = convertTsickleDecoratorIntoMetadata(propDecorators[prop]);
      });
      return propMetadata;
    }
    if (typeOrFunc.hasOwnProperty(PROP_METADATA)) {
      return typeOrFunc[PROP_METADATA];
    }
    return null;
  }
  propMetadata(typeOrFunc) {
    if (!isType(typeOrFunc)) {
      return {};
    }
    const parentCtor = getParentCtor(typeOrFunc);
    const propMetadata = {};
    if (parentCtor !== Object) {
      const parentPropMetadata = this.propMetadata(parentCtor);
      Object.keys(parentPropMetadata).forEach((propName) => {
        propMetadata[propName] = parentPropMetadata[propName];
      });
    }
    const ownPropMetadata = this._ownPropMetadata(typeOrFunc, parentCtor);
    if (ownPropMetadata) {
      Object.keys(ownPropMetadata).forEach((propName) => {
        const decorators = [];
        if (propMetadata.hasOwnProperty(propName)) {
          decorators.push(...propMetadata[propName]);
        }
        decorators.push(...ownPropMetadata[propName]);
        propMetadata[propName] = decorators;
      });
    }
    return propMetadata;
  }
  ownPropMetadata(typeOrFunc) {
    if (!isType(typeOrFunc)) {
      return {};
    }
    return this._ownPropMetadata(typeOrFunc, getParentCtor(typeOrFunc)) || {};
  }
  hasLifecycleHook(type, lcProperty) {
    return type instanceof Type && lcProperty in type.prototype;
  }
};
function convertTsickleDecoratorIntoMetadata(decoratorInvocations) {
  if (!decoratorInvocations) {
    return [];
  }
  return decoratorInvocations.map((decoratorInvocation) => {
    const decoratorType = decoratorInvocation.type;
    const annotationCls = decoratorType.annotationCls;
    const annotationArgs = decoratorInvocation.args ? decoratorInvocation.args : [];
    return new annotationCls(...annotationArgs);
  });
}
function getParentCtor(ctor) {
  const parentProto = ctor.prototype ? Object.getPrototypeOf(ctor.prototype) : null;
  const parentCtor = parentProto ? parentProto.constructor : null;
  return parentCtor || Object;
}
var HOST = 0;
var TVIEW = 1;
var FLAGS = 2;
var PARENT = 3;
var NEXT = 4;
var T_HOST = 5;
var HYDRATION = 6;
var CLEANUP = 7;
var CONTEXT = 8;
var INJECTOR = 9;
var ENVIRONMENT = 10;
var RENDERER = 11;
var CHILD_HEAD = 12;
var CHILD_TAIL = 13;
var DECLARATION_VIEW = 14;
var DECLARATION_COMPONENT_VIEW = 15;
var DECLARATION_LCONTAINER = 16;
var PREORDER_HOOK_FLAGS = 17;
var QUERIES = 18;
var ID = 19;
var EMBEDDED_VIEW_INJECTOR = 20;
var ON_DESTROY_HOOKS = 21;
var EFFECTS_TO_SCHEDULE = 22;
var REACTIVE_TEMPLATE_CONSUMER = 23;
var HEADER_OFFSET = 25;
var TYPE = 1;
var NATIVE = 7;
var VIEW_REFS = 8;
var MOVED_VIEWS = 9;
var CONTAINER_HEADER_OFFSET = 10;
var LContainerFlags;
(function(LContainerFlags2) {
  LContainerFlags2[LContainerFlags2["None"] = 0] = "None";
  LContainerFlags2[LContainerFlags2["HasTransplantedViews"] = 2] = "HasTransplantedViews";
})(LContainerFlags || (LContainerFlags = {}));
function isLView(value) {
  return Array.isArray(value) && typeof value[TYPE] === "object";
}
function isLContainer(value) {
  return Array.isArray(value) && value[TYPE] === true;
}
function isContentQueryHost(tNode) {
  return (tNode.flags & 4) !== 0;
}
function isComponentHost(tNode) {
  return tNode.componentOffset > -1;
}
function isDirectiveHost(tNode) {
  return (tNode.flags & 1) === 1;
}
function isComponentDef(def) {
  return !!def.template;
}
function isRootView(target) {
  return (target[FLAGS] & 512) !== 0;
}
function isDestroyed(lView) {
  return (lView[FLAGS] & 256) === 256;
}
function assertTNodeForLView(tNode, lView) {
  assertTNodeForTView(tNode, lView[TVIEW]);
}
function assertTNodeForTView(tNode, tView) {
  assertTNode(tNode);
  const tData = tView.data;
  for (let i = HEADER_OFFSET; i < tData.length; i++) {
    if (tData[i] === tNode) {
      return;
    }
  }
  throwError("This TNode does not belong to this TView.");
}
function assertTNode(tNode) {
  assertDefined(tNode, "TNode must be defined");
  if (!(tNode && typeof tNode === "object" && tNode.hasOwnProperty("directiveStylingLast"))) {
    throwError("Not of type TNode, got: " + tNode);
  }
}
function assertTIcu(tIcu) {
  assertDefined(tIcu, "Expected TIcu to be defined");
  if (!(typeof tIcu.currentCaseLViewIndex === "number")) {
    throwError("Object is not of TIcu type.");
  }
}
function assertComponentType(actual, msg = "Type passed in is not ComponentType, it does not have 'ɵcmp' property.") {
  if (!getComponentDef(actual)) {
    throwError(msg);
  }
}
function assertNgModuleType(actual, msg = "Type passed in is not NgModuleType, it does not have 'ɵmod' property.") {
  if (!getNgModuleDef(actual)) {
    throwError(msg);
  }
}
function assertHasParent(tNode) {
  assertDefined(tNode, "currentTNode should exist!");
  assertDefined(tNode.parent, "currentTNode should have a parent");
}
function assertLContainer(value) {
  assertDefined(value, "LContainer must be defined");
  assertEqual(isLContainer(value), true, "Expecting LContainer");
}
function assertLViewOrUndefined(value) {
  value && assertEqual(isLView(value), true, "Expecting LView or undefined or null");
}
function assertLView(value) {
  assertDefined(value, "LView must be defined");
  assertEqual(isLView(value), true, "Expecting LView");
}
function assertFirstCreatePass(tView, errMessage) {
  assertEqual(tView.firstCreatePass, true, errMessage || "Should only be called in first create pass.");
}
function assertFirstUpdatePass(tView, errMessage) {
  assertEqual(tView.firstUpdatePass, true, errMessage || "Should only be called in first update pass.");
}
function assertDirectiveDef(obj) {
  if (obj.type === void 0 || obj.selectors == void 0 || obj.inputs === void 0) {
    throwError(`Expected a DirectiveDef/ComponentDef and this object does not seem to have the expected shape.`);
  }
}
function assertIndexInDeclRange(tView, index) {
  assertBetween(HEADER_OFFSET, tView.bindingStartIndex, index);
}
function assertIndexInExpandoRange(lView, index) {
  const tView = lView[1];
  assertBetween(tView.expandoStartIndex, lView.length, index);
}
function assertBetween(lower, upper, index) {
  if (!(lower <= index && index < upper)) {
    throwError(`Index out of range (expecting ${lower} <= ${index} < ${upper})`);
  }
}
function assertProjectionSlots(lView, errMessage) {
  assertDefined(lView[DECLARATION_COMPONENT_VIEW], "Component views should exist.");
  assertDefined(lView[DECLARATION_COMPONENT_VIEW][T_HOST].projection, errMessage || "Components with projection nodes (<ng-content>) must have projection slots defined.");
}
function assertParentView(lView, errMessage) {
  assertDefined(lView, errMessage || "Component views should always have a parent view (component's host view)");
}
function assertNoDuplicateDirectives(directives) {
  if (directives.length < 2) {
    return;
  }
  const seenDirectives = /* @__PURE__ */ new Set();
  for (const current of directives) {
    if (seenDirectives.has(current)) {
      throw new RuntimeError(309, `Directive ${current.type.name} matches multiple times on the same element. Directives can only match an element once.`);
    }
    seenDirectives.add(current);
  }
}
function assertNodeInjector(lView, injectorIndex) {
  assertIndexInExpandoRange(lView, injectorIndex);
  assertIndexInExpandoRange(
    lView,
    injectorIndex + 8
    /* NodeInjectorOffset.PARENT */
  );
  assertNumber(lView[injectorIndex + 0], "injectorIndex should point to a bloom filter");
  assertNumber(lView[injectorIndex + 1], "injectorIndex should point to a bloom filter");
  assertNumber(lView[injectorIndex + 2], "injectorIndex should point to a bloom filter");
  assertNumber(lView[injectorIndex + 3], "injectorIndex should point to a bloom filter");
  assertNumber(lView[injectorIndex + 4], "injectorIndex should point to a bloom filter");
  assertNumber(lView[injectorIndex + 5], "injectorIndex should point to a bloom filter");
  assertNumber(lView[injectorIndex + 6], "injectorIndex should point to a bloom filter");
  assertNumber(lView[injectorIndex + 7], "injectorIndex should point to a bloom filter");
  assertNumber(lView[
    injectorIndex + 8
    /* NodeInjectorOffset.PARENT */
  ], "injectorIndex should point to parent injector");
}
var SimpleChange = class {
  constructor(previousValue, currentValue, firstChange) {
    this.previousValue = previousValue;
    this.currentValue = currentValue;
    this.firstChange = firstChange;
  }
  /**
   * Check whether the new value is the first value assigned.
   */
  isFirstChange() {
    return this.firstChange;
  }
};
function applyValueToInputField(instance, inputSignalNode, privateName, value) {
  if (inputSignalNode !== null) {
    inputSignalNode.applyValueToInputSignal(inputSignalNode, value);
  } else {
    instance[privateName] = value;
  }
}
function ɵɵNgOnChangesFeature() {
  return NgOnChangesFeatureImpl;
}
function NgOnChangesFeatureImpl(definition) {
  if (definition.type.prototype.ngOnChanges) {
    definition.setInput = ngOnChangesSetInput;
  }
  return rememberChangeHistoryAndInvokeOnChangesHook;
}
ɵɵNgOnChangesFeature.ngInherit = true;
function rememberChangeHistoryAndInvokeOnChangesHook() {
  const simpleChangesStore = getSimpleChangesStore(this);
  const current = simpleChangesStore?.current;
  if (current) {
    const previous = simpleChangesStore.previous;
    if (previous === EMPTY_OBJ) {
      simpleChangesStore.previous = current;
    } else {
      for (let key in current) {
        previous[key] = current[key];
      }
    }
    simpleChangesStore.current = null;
    this.ngOnChanges(current);
  }
}
function ngOnChangesSetInput(instance, inputSignalNode, value, publicName, privateName) {
  const declaredName = this.declaredInputs[publicName];
  ngDevMode && assertString(declaredName, "Name of input in ngOnChanges has to be a string");
  const simpleChangesStore = getSimpleChangesStore(instance) || setSimpleChangesStore(instance, {
    previous: EMPTY_OBJ,
    current: null
  });
  const current = simpleChangesStore.current || (simpleChangesStore.current = {});
  const previous = simpleChangesStore.previous;
  const previousChange = previous[declaredName];
  current[declaredName] = new SimpleChange(previousChange && previousChange.currentValue, value, previous === EMPTY_OBJ);
  applyValueToInputField(instance, inputSignalNode, privateName, value);
}
var SIMPLE_CHANGES_STORE = "__ngSimpleChanges__";
function getSimpleChangesStore(instance) {
  return instance[SIMPLE_CHANGES_STORE] || null;
}
function setSimpleChangesStore(instance, store2) {
  return instance[SIMPLE_CHANGES_STORE] = store2;
}
var profilerCallback = null;
var setProfiler = (profiler2) => {
  profilerCallback = profiler2;
};
var profiler = function(event, instance, hookOrListener) {
  if (profilerCallback != null) {
    profilerCallback(event, instance, hookOrListener);
  }
};
var SVG_NAMESPACE = "svg";
var MATH_ML_NAMESPACE = "math";
function unwrapRNode(value) {
  while (Array.isArray(value)) {
    value = value[HOST];
  }
  return value;
}
function unwrapLView(value) {
  while (Array.isArray(value)) {
    if (typeof value[TYPE] === "object") return value;
    value = value[HOST];
  }
  return null;
}
function getNativeByIndex(index, lView) {
  ngDevMode && assertIndexInRange(lView, index);
  ngDevMode && assertGreaterThanOrEqual(index, HEADER_OFFSET, "Expected to be past HEADER_OFFSET");
  return unwrapRNode(lView[index]);
}
function getNativeByTNode(tNode, lView) {
  ngDevMode && assertTNodeForLView(tNode, lView);
  ngDevMode && assertIndexInRange(lView, tNode.index);
  const node = unwrapRNode(lView[tNode.index]);
  return node;
}
function getTNode(tView, index) {
  ngDevMode && assertGreaterThan(index, -1, "wrong index for TNode");
  ngDevMode && assertLessThan(index, tView.data.length, "wrong index for TNode");
  const tNode = tView.data[index];
  ngDevMode && tNode !== null && assertTNode(tNode);
  return tNode;
}
function load(view, index) {
  ngDevMode && assertIndexInRange(view, index);
  return view[index];
}
function getComponentLViewByIndex(nodeIndex, hostView) {
  ngDevMode && assertIndexInRange(hostView, nodeIndex);
  const slotValue = hostView[nodeIndex];
  const lView = isLView(slotValue) ? slotValue : slotValue[HOST];
  return lView;
}
function isCreationMode(view) {
  return (view[FLAGS] & 4) === 4;
}
function viewAttachedToChangeDetector(view) {
  return (view[FLAGS] & 128) === 128;
}
function viewAttachedToContainer(view) {
  return isLContainer(view[PARENT]);
}
function getConstant(consts, index) {
  if (index === null || index === void 0) return null;
  ngDevMode && assertIndexInRange(consts, index);
  return consts[index];
}
function resetPreOrderHookFlags(lView) {
  lView[PREORDER_HOOK_FLAGS] = 0;
}
function markViewForRefresh(lView) {
  if (lView[FLAGS] & 1024) {
    return;
  }
  lView[FLAGS] |= 1024;
  if (viewAttachedToChangeDetector(lView)) {
    markAncestorsForTraversal(lView);
  }
}
function walkUpViews(nestingLevel, currentView) {
  while (nestingLevel > 0) {
    ngDevMode && assertDefined(currentView[DECLARATION_VIEW], "Declaration view should be defined if nesting level is greater than 0.");
    currentView = currentView[DECLARATION_VIEW];
    nestingLevel--;
  }
  return currentView;
}
function requiresRefreshOrTraversal(lView) {
  return !!(lView[FLAGS] & (1024 | 8192) || lView[REACTIVE_TEMPLATE_CONSUMER]?.dirty);
}
function updateAncestorTraversalFlagsOnAttach(lView) {
  lView[ENVIRONMENT].changeDetectionScheduler?.notify(
    7
    /* NotificationSource.ViewAttached */
  );
  if (lView[FLAGS] & 64) {
    lView[FLAGS] |= 1024;
  }
  if (requiresRefreshOrTraversal(lView)) {
    markAncestorsForTraversal(lView);
  }
}
function markAncestorsForTraversal(lView) {
  lView[ENVIRONMENT].changeDetectionScheduler?.notify(
    0
    /* NotificationSource.MarkAncestorsForTraversal */
  );
  let parent = getLViewParent(lView);
  while (parent !== null) {
    if (parent[FLAGS] & 8192) {
      break;
    }
    parent[FLAGS] |= 8192;
    if (!viewAttachedToChangeDetector(parent)) {
      break;
    }
    parent = getLViewParent(parent);
  }
}
function storeLViewOnDestroy(lView, onDestroyCallback) {
  if ((lView[FLAGS] & 256) === 256) {
    throw new RuntimeError(911, ngDevMode && "View has already been destroyed.");
  }
  if (lView[ON_DESTROY_HOOKS] === null) {
    lView[ON_DESTROY_HOOKS] = [];
  }
  lView[ON_DESTROY_HOOKS].push(onDestroyCallback);
}
function removeLViewOnDestroy(lView, onDestroyCallback) {
  if (lView[ON_DESTROY_HOOKS] === null) return;
  const destroyCBIdx = lView[ON_DESTROY_HOOKS].indexOf(onDestroyCallback);
  if (destroyCBIdx !== -1) {
    lView[ON_DESTROY_HOOKS].splice(destroyCBIdx, 1);
  }
}
function getLViewParent(lView) {
  ngDevMode && assertLView(lView);
  const parent = lView[PARENT];
  return isLContainer(parent) ? parent[PARENT] : parent;
}
var instructionState = {
  lFrame: createLFrame(null),
  bindingsEnabled: true,
  skipHydrationRootTNode: null
};
var CheckNoChangesMode;
(function(CheckNoChangesMode2) {
  CheckNoChangesMode2[CheckNoChangesMode2["Off"] = 0] = "Off";
  CheckNoChangesMode2[CheckNoChangesMode2["Exhaustive"] = 1] = "Exhaustive";
  CheckNoChangesMode2[CheckNoChangesMode2["OnlyDirtyViews"] = 2] = "OnlyDirtyViews";
})(CheckNoChangesMode || (CheckNoChangesMode = {}));
var _checkNoChangesMode = 0;
var _isRefreshingViews = false;
function getElementDepthCount() {
  return instructionState.lFrame.elementDepthCount;
}
function increaseElementDepthCount() {
  instructionState.lFrame.elementDepthCount++;
}
function decreaseElementDepthCount() {
  instructionState.lFrame.elementDepthCount--;
}
function getBindingsEnabled() {
  return instructionState.bindingsEnabled;
}
function isInSkipHydrationBlock$1() {
  return instructionState.skipHydrationRootTNode !== null;
}
function isSkipHydrationRootTNode(tNode) {
  return instructionState.skipHydrationRootTNode === tNode;
}
function ɵɵenableBindings() {
  instructionState.bindingsEnabled = true;
}
function ɵɵdisableBindings() {
  instructionState.bindingsEnabled = false;
}
function leaveSkipHydrationBlock() {
  instructionState.skipHydrationRootTNode = null;
}
function getLView() {
  return instructionState.lFrame.lView;
}
function getTView() {
  return instructionState.lFrame.tView;
}
function ɵɵrestoreView(viewToRestore) {
  instructionState.lFrame.contextLView = viewToRestore;
  return viewToRestore[CONTEXT];
}
function ɵɵresetView(value) {
  instructionState.lFrame.contextLView = null;
  return value;
}
function getCurrentTNode() {
  let currentTNode = getCurrentTNodePlaceholderOk();
  while (currentTNode !== null && currentTNode.type === 64) {
    currentTNode = currentTNode.parent;
  }
  return currentTNode;
}
function getCurrentTNodePlaceholderOk() {
  return instructionState.lFrame.currentTNode;
}
function getCurrentParentTNode() {
  const lFrame = instructionState.lFrame;
  const currentTNode = lFrame.currentTNode;
  return lFrame.isParent ? currentTNode : currentTNode.parent;
}
function setCurrentTNode(tNode, isParent) {
  ngDevMode && tNode && assertTNodeForTView(tNode, instructionState.lFrame.tView);
  const lFrame = instructionState.lFrame;
  lFrame.currentTNode = tNode;
  lFrame.isParent = isParent;
}
function isCurrentTNodeParent() {
  return instructionState.lFrame.isParent;
}
function setCurrentTNodeAsNotParent() {
  instructionState.lFrame.isParent = false;
}
function getContextLView() {
  const contextLView = instructionState.lFrame.contextLView;
  ngDevMode && assertDefined(contextLView, "contextLView must be defined.");
  return contextLView;
}
function isInCheckNoChangesMode() {
  !ngDevMode && throwError("Must never be called in production mode");
  return _checkNoChangesMode !== CheckNoChangesMode.Off;
}
function isExhaustiveCheckNoChanges() {
  !ngDevMode && throwError("Must never be called in production mode");
  return _checkNoChangesMode === CheckNoChangesMode.Exhaustive;
}
function setIsInCheckNoChangesMode(mode) {
  !ngDevMode && throwError("Must never be called in production mode");
  _checkNoChangesMode = mode;
}
function isRefreshingViews() {
  return _isRefreshingViews;
}
function setIsRefreshingViews(mode) {
  _isRefreshingViews = mode;
}
function getBindingRoot() {
  const lFrame = instructionState.lFrame;
  let index = lFrame.bindingRootIndex;
  if (index === -1) {
    index = lFrame.bindingRootIndex = lFrame.tView.bindingStartIndex;
  }
  return index;
}
function getBindingIndex() {
  return instructionState.lFrame.bindingIndex;
}
function setBindingIndex(value) {
  return instructionState.lFrame.bindingIndex = value;
}
function nextBindingIndex() {
  return instructionState.lFrame.bindingIndex++;
}
function incrementBindingIndex(count) {
  const lFrame = instructionState.lFrame;
  const index = lFrame.bindingIndex;
  lFrame.bindingIndex = lFrame.bindingIndex + count;
  return index;
}
function isInI18nBlock() {
  return instructionState.lFrame.inI18n;
}
function setInI18nBlock(isInI18nBlock2) {
  instructionState.lFrame.inI18n = isInI18nBlock2;
}
function setBindingRootForHostBindings(bindingRootIndex, currentDirectiveIndex) {
  const lFrame = instructionState.lFrame;
  lFrame.bindingIndex = lFrame.bindingRootIndex = bindingRootIndex;
  setCurrentDirectiveIndex(currentDirectiveIndex);
}
function getCurrentDirectiveIndex() {
  return instructionState.lFrame.currentDirectiveIndex;
}
function setCurrentDirectiveIndex(currentDirectiveIndex) {
  instructionState.lFrame.currentDirectiveIndex = currentDirectiveIndex;
}
function getCurrentDirectiveDef(tData) {
  const currentDirectiveIndex = instructionState.lFrame.currentDirectiveIndex;
  return currentDirectiveIndex === -1 ? null : tData[currentDirectiveIndex];
}
function getCurrentQueryIndex() {
  return instructionState.lFrame.currentQueryIndex;
}
function setCurrentQueryIndex(value) {
  instructionState.lFrame.currentQueryIndex = value;
}
function getDeclarationTNode(lView) {
  const tView = lView[TVIEW];
  if (tView.type === 2) {
    ngDevMode && assertDefined(tView.declTNode, "Embedded TNodes should have declaration parents.");
    return tView.declTNode;
  }
  if (tView.type === 1) {
    return lView[T_HOST];
  }
  return null;
}
function enterDI(lView, tNode, flags) {
  ngDevMode && assertLViewOrUndefined(lView);
  if (flags & InjectFlags.SkipSelf) {
    ngDevMode && assertTNodeForTView(tNode, lView[TVIEW]);
    let parentTNode = tNode;
    let parentLView = lView;
    while (true) {
      ngDevMode && assertDefined(parentTNode, "Parent TNode should be defined");
      parentTNode = parentTNode.parent;
      if (parentTNode === null && !(flags & InjectFlags.Host)) {
        parentTNode = getDeclarationTNode(parentLView);
        if (parentTNode === null) break;
        ngDevMode && assertDefined(parentLView, "Parent LView should be defined");
        parentLView = parentLView[DECLARATION_VIEW];
        if (parentTNode.type & (2 | 8)) {
          break;
        }
      } else {
        break;
      }
    }
    if (parentTNode === null) {
      return false;
    } else {
      tNode = parentTNode;
      lView = parentLView;
    }
  }
  ngDevMode && assertTNodeForLView(tNode, lView);
  const lFrame = instructionState.lFrame = allocLFrame();
  lFrame.currentTNode = tNode;
  lFrame.lView = lView;
  return true;
}
function enterView(newView) {
  ngDevMode && assertNotEqual(newView[0], newView[1], "????");
  ngDevMode && assertLViewOrUndefined(newView);
  const newLFrame = allocLFrame();
  if (ngDevMode) {
    assertEqual(newLFrame.isParent, true, "Expected clean LFrame");
    assertEqual(newLFrame.lView, null, "Expected clean LFrame");
    assertEqual(newLFrame.tView, null, "Expected clean LFrame");
    assertEqual(newLFrame.selectedIndex, -1, "Expected clean LFrame");
    assertEqual(newLFrame.elementDepthCount, 0, "Expected clean LFrame");
    assertEqual(newLFrame.currentDirectiveIndex, -1, "Expected clean LFrame");
    assertEqual(newLFrame.currentNamespace, null, "Expected clean LFrame");
    assertEqual(newLFrame.bindingRootIndex, -1, "Expected clean LFrame");
    assertEqual(newLFrame.currentQueryIndex, 0, "Expected clean LFrame");
  }
  const tView = newView[TVIEW];
  instructionState.lFrame = newLFrame;
  ngDevMode && tView.firstChild && assertTNodeForTView(tView.firstChild, tView);
  newLFrame.currentTNode = tView.firstChild;
  newLFrame.lView = newView;
  newLFrame.tView = tView;
  newLFrame.contextLView = newView;
  newLFrame.bindingIndex = tView.bindingStartIndex;
  newLFrame.inI18n = false;
}
function allocLFrame() {
  const currentLFrame = instructionState.lFrame;
  const childLFrame = currentLFrame === null ? null : currentLFrame.child;
  const newLFrame = childLFrame === null ? createLFrame(currentLFrame) : childLFrame;
  return newLFrame;
}
function createLFrame(parent) {
  const lFrame = {
    currentTNode: null,
    isParent: true,
    lView: null,
    tView: null,
    selectedIndex: -1,
    contextLView: null,
    elementDepthCount: 0,
    currentNamespace: null,
    currentDirectiveIndex: -1,
    bindingRootIndex: -1,
    bindingIndex: -1,
    currentQueryIndex: 0,
    parent,
    child: null,
    inI18n: false
  };
  parent !== null && (parent.child = lFrame);
  return lFrame;
}
function leaveViewLight() {
  const oldLFrame = instructionState.lFrame;
  instructionState.lFrame = oldLFrame.parent;
  oldLFrame.currentTNode = null;
  oldLFrame.lView = null;
  return oldLFrame;
}
var leaveDI = leaveViewLight;
function leaveView() {
  const oldLFrame = leaveViewLight();
  oldLFrame.isParent = true;
  oldLFrame.tView = null;
  oldLFrame.selectedIndex = -1;
  oldLFrame.contextLView = null;
  oldLFrame.elementDepthCount = 0;
  oldLFrame.currentDirectiveIndex = -1;
  oldLFrame.currentNamespace = null;
  oldLFrame.bindingRootIndex = -1;
  oldLFrame.bindingIndex = -1;
  oldLFrame.currentQueryIndex = 0;
}
function nextContextImpl(level) {
  const contextLView = instructionState.lFrame.contextLView = walkUpViews(level, instructionState.lFrame.contextLView);
  return contextLView[CONTEXT];
}
function getSelectedIndex() {
  return instructionState.lFrame.selectedIndex;
}
function setSelectedIndex(index) {
  ngDevMode && index !== -1 && assertGreaterThanOrEqual(index, HEADER_OFFSET, "Index must be past HEADER_OFFSET (or -1).");
  ngDevMode && assertLessThan(index, instructionState.lFrame.lView.length, "Can't set index passed end of LView");
  instructionState.lFrame.selectedIndex = index;
}
function getSelectedTNode() {
  const lFrame = instructionState.lFrame;
  return getTNode(lFrame.tView, lFrame.selectedIndex);
}
function ɵɵnamespaceSVG() {
  instructionState.lFrame.currentNamespace = SVG_NAMESPACE;
}
function ɵɵnamespaceMathML() {
  instructionState.lFrame.currentNamespace = MATH_ML_NAMESPACE;
}
function ɵɵnamespaceHTML() {
  namespaceHTMLInternal();
}
function namespaceHTMLInternal() {
  instructionState.lFrame.currentNamespace = null;
}
function getNamespace$1() {
  return instructionState.lFrame.currentNamespace;
}
var _wasLastNodeCreated = true;
function wasLastNodeCreated() {
  return _wasLastNodeCreated;
}
function lastNodeWasCreated(flag) {
  _wasLastNodeCreated = flag;
}
function registerPreOrderHooks(directiveIndex, directiveDef, tView) {
  ngDevMode && assertFirstCreatePass(tView);
  const {
    ngOnChanges,
    ngOnInit,
    ngDoCheck
  } = directiveDef.type.prototype;
  if (ngOnChanges) {
    const wrappedOnChanges = NgOnChangesFeatureImpl(directiveDef);
    (tView.preOrderHooks ??= []).push(directiveIndex, wrappedOnChanges);
    (tView.preOrderCheckHooks ??= []).push(directiveIndex, wrappedOnChanges);
  }
  if (ngOnInit) {
    (tView.preOrderHooks ??= []).push(0 - directiveIndex, ngOnInit);
  }
  if (ngDoCheck) {
    (tView.preOrderHooks ??= []).push(directiveIndex, ngDoCheck);
    (tView.preOrderCheckHooks ??= []).push(directiveIndex, ngDoCheck);
  }
}
function registerPostOrderHooks(tView, tNode) {
  ngDevMode && assertFirstCreatePass(tView);
  for (let i = tNode.directiveStart, end = tNode.directiveEnd; i < end; i++) {
    const directiveDef = tView.data[i];
    ngDevMode && assertDefined(directiveDef, "Expecting DirectiveDef");
    const lifecycleHooks = directiveDef.type.prototype;
    const {
      ngAfterContentInit,
      ngAfterContentChecked,
      ngAfterViewInit,
      ngAfterViewChecked,
      ngOnDestroy
    } = lifecycleHooks;
    if (ngAfterContentInit) {
      (tView.contentHooks ??= []).push(-i, ngAfterContentInit);
    }
    if (ngAfterContentChecked) {
      (tView.contentHooks ??= []).push(i, ngAfterContentChecked);
      (tView.contentCheckHooks ??= []).push(i, ngAfterContentChecked);
    }
    if (ngAfterViewInit) {
      (tView.viewHooks ??= []).push(-i, ngAfterViewInit);
    }
    if (ngAfterViewChecked) {
      (tView.viewHooks ??= []).push(i, ngAfterViewChecked);
      (tView.viewCheckHooks ??= []).push(i, ngAfterViewChecked);
    }
    if (ngOnDestroy != null) {
      (tView.destroyHooks ??= []).push(i, ngOnDestroy);
    }
  }
}
function executeCheckHooks(lView, hooks, nodeIndex) {
  callHooks(lView, hooks, 3, nodeIndex);
}
function executeInitAndCheckHooks(lView, hooks, initPhase, nodeIndex) {
  ngDevMode && assertNotEqual(initPhase, 3, "Init pre-order hooks should not be called more than once");
  if ((lView[FLAGS] & 3) === initPhase) {
    callHooks(lView, hooks, initPhase, nodeIndex);
  }
}
function incrementInitPhaseFlags(lView, initPhase) {
  ngDevMode && assertNotEqual(initPhase, 3, "Init hooks phase should not be incremented after all init hooks have been run.");
  let flags = lView[FLAGS];
  if ((flags & 3) === initPhase) {
    flags &= 16383;
    flags += 1;
    lView[FLAGS] = flags;
  }
}
function callHooks(currentView, arr, initPhase, currentNodeIndex) {
  ngDevMode && assertEqual(isInCheckNoChangesMode(), false, "Hooks should never be run when in check no changes mode.");
  const startIndex = currentNodeIndex !== void 0 ? currentView[PREORDER_HOOK_FLAGS] & 65535 : 0;
  const nodeIndexLimit = currentNodeIndex != null ? currentNodeIndex : -1;
  const max = arr.length - 1;
  let lastNodeIndexFound = 0;
  for (let i = startIndex; i < max; i++) {
    const hook = arr[i + 1];
    if (typeof hook === "number") {
      lastNodeIndexFound = arr[i];
      if (currentNodeIndex != null && lastNodeIndexFound >= currentNodeIndex) {
        break;
      }
    } else {
      const isInitHook = arr[i] < 0;
      if (isInitHook) {
        currentView[PREORDER_HOOK_FLAGS] += 65536;
      }
      if (lastNodeIndexFound < nodeIndexLimit || nodeIndexLimit == -1) {
        callHook(currentView, initPhase, arr, i);
        currentView[PREORDER_HOOK_FLAGS] = (currentView[PREORDER_HOOK_FLAGS] & 4294901760) + i + 2;
      }
      i++;
    }
  }
}
function callHookInternal(directive, hook) {
  profiler(4, directive, hook);
  const prevConsumer = setActiveConsumer(null);
  try {
    hook.call(directive);
  } finally {
    setActiveConsumer(prevConsumer);
    profiler(5, directive, hook);
  }
}
function callHook(currentView, initPhase, arr, i) {
  const isInitHook = arr[i] < 0;
  const hook = arr[i + 1];
  const directiveIndex = isInitHook ? -arr[i] : arr[i];
  const directive = currentView[directiveIndex];
  if (isInitHook) {
    const indexWithintInitPhase = currentView[FLAGS] >> 14;
    if (indexWithintInitPhase < currentView[PREORDER_HOOK_FLAGS] >> 16 && (currentView[FLAGS] & 3) === initPhase) {
      currentView[FLAGS] += 16384;
      callHookInternal(directive, hook);
    }
  } else {
    callHookInternal(directive, hook);
  }
}
var NO_PARENT_INJECTOR = -1;
var NodeInjectorFactory = class {
  constructor(factory, isViewProvider, injectImplementation) {
    this.factory = factory;
    this.resolving = false;
    ngDevMode && assertDefined(factory, "Factory not specified");
    ngDevMode && assertEqual(typeof factory, "function", "Expected factory function.");
    this.canSeeViewProviders = isViewProvider;
    this.injectImpl = injectImplementation;
  }
};
function isFactory(obj) {
  return obj instanceof NodeInjectorFactory;
}
function toTNodeTypeAsString(tNodeType) {
  let text = "";
  tNodeType & 1 && (text += "|Text");
  tNodeType & 2 && (text += "|Element");
  tNodeType & 4 && (text += "|Container");
  tNodeType & 8 && (text += "|ElementContainer");
  tNodeType & 16 && (text += "|Projection");
  tNodeType & 32 && (text += "|IcuContainer");
  tNodeType & 64 && (text += "|Placeholder");
  tNodeType & 128 && (text += "|LetDeclaration");
  return text.length > 0 ? text.substring(1) : text;
}
function hasClassInput(tNode) {
  return (tNode.flags & 8) !== 0;
}
function hasStyleInput(tNode) {
  return (tNode.flags & 16) !== 0;
}
function assertTNodeType(tNode, expectedTypes, message) {
  assertDefined(tNode, "should be called with a TNode");
  if ((tNode.type & expectedTypes) === 0) {
    throwError(message || `Expected [${toTNodeTypeAsString(expectedTypes)}] but got ${toTNodeTypeAsString(tNode.type)}.`);
  }
}
function assertPureTNodeType(type) {
  if (!(type === 2 || type === 1 || type === 4 || type === 8 || type === 32 || type === 16 || type === 64 || type === 128)) {
    throwError(`Expected TNodeType to have only a single type selected, but got ${toTNodeTypeAsString(type)}.`);
  }
}
var NOT_FOUND_CHECK_ONLY_ELEMENT_INJECTOR = {};
var ChainedInjector = class {
  constructor(injector, parentInjector) {
    this.injector = injector;
    this.parentInjector = parentInjector;
  }
  get(token, notFoundValue, flags) {
    flags = convertToBitFlags(flags);
    const value = this.injector.get(token, NOT_FOUND_CHECK_ONLY_ELEMENT_INJECTOR, flags);
    if (value !== NOT_FOUND_CHECK_ONLY_ELEMENT_INJECTOR || notFoundValue === NOT_FOUND_CHECK_ONLY_ELEMENT_INJECTOR) {
      return value;
    }
    return this.parentInjector.get(token, notFoundValue, flags);
  }
};
function hasParentInjector(parentLocation) {
  return parentLocation !== NO_PARENT_INJECTOR;
}
function getParentInjectorIndex(parentLocation) {
  if (ngDevMode) {
    assertNumber(parentLocation, "Number expected");
    assertNotEqual(parentLocation, -1, "Not a valid state.");
    const parentInjectorIndex = parentLocation & 32767;
    assertGreaterThan(parentInjectorIndex, HEADER_OFFSET, "Parent injector must be pointing past HEADER_OFFSET.");
  }
  return parentLocation & 32767;
}
function getParentInjectorViewOffset(parentLocation) {
  return parentLocation >> 16;
}
function getParentInjectorView(location2, startView) {
  let viewOffset = getParentInjectorViewOffset(location2);
  let parentView = startView;
  while (viewOffset > 0) {
    parentView = parentView[DECLARATION_VIEW];
    viewOffset--;
  }
  return parentView;
}
function isRouterOutletInjector(currentInjector) {
  return currentInjector instanceof ChainedInjector && typeof currentInjector.injector.__ngOutletInjector === "function";
}
var includeViewProviders = true;
function setIncludeViewProviders(v) {
  const oldValue = includeViewProviders;
  includeViewProviders = v;
  return oldValue;
}
var BLOOM_SIZE = 256;
var BLOOM_MASK = BLOOM_SIZE - 1;
var BLOOM_BUCKET_BITS = 5;
var nextNgElementId = 0;
var NOT_FOUND = {};
function bloomAdd(injectorIndex, tView, type) {
  ngDevMode && assertEqual(tView.firstCreatePass, true, "expected firstCreatePass to be true");
  let id;
  if (typeof type === "string") {
    id = type.charCodeAt(0) || 0;
  } else if (type.hasOwnProperty(NG_ELEMENT_ID)) {
    id = type[NG_ELEMENT_ID];
  }
  if (id == null) {
    id = type[NG_ELEMENT_ID] = nextNgElementId++;
  }
  const bloomHash = id & BLOOM_MASK;
  const mask = 1 << bloomHash;
  tView.data[injectorIndex + (bloomHash >> BLOOM_BUCKET_BITS)] |= mask;
}
function getOrCreateNodeInjectorForNode(tNode, lView) {
  const existingInjectorIndex = getInjectorIndex(tNode, lView);
  if (existingInjectorIndex !== -1) {
    return existingInjectorIndex;
  }
  const tView = lView[TVIEW];
  if (tView.firstCreatePass) {
    tNode.injectorIndex = lView.length;
    insertBloom(tView.data, tNode);
    insertBloom(lView, null);
    insertBloom(tView.blueprint, null);
  }
  const parentLoc = getParentInjectorLocation(tNode, lView);
  const injectorIndex = tNode.injectorIndex;
  if (hasParentInjector(parentLoc)) {
    const parentIndex = getParentInjectorIndex(parentLoc);
    const parentLView = getParentInjectorView(parentLoc, lView);
    const parentData = parentLView[TVIEW].data;
    for (let i = 0; i < 8; i++) {
      lView[injectorIndex + i] = parentLView[parentIndex + i] | parentData[parentIndex + i];
    }
  }
  lView[
    injectorIndex + 8
    /* NodeInjectorOffset.PARENT */
  ] = parentLoc;
  return injectorIndex;
}
function insertBloom(arr, footer) {
  arr.push(0, 0, 0, 0, 0, 0, 0, 0, footer);
}
function getInjectorIndex(tNode, lView) {
  if (tNode.injectorIndex === -1 || // If the injector index is the same as its parent's injector index, then the index has been
  // copied down from the parent node. No injector has been created yet on this node.
  tNode.parent && tNode.parent.injectorIndex === tNode.injectorIndex || // After the first template pass, the injector index might exist but the parent values
  // might not have been calculated yet for this instance
  lView[
    tNode.injectorIndex + 8
    /* NodeInjectorOffset.PARENT */
  ] === null) {
    return -1;
  } else {
    ngDevMode && assertIndexInRange(lView, tNode.injectorIndex);
    return tNode.injectorIndex;
  }
}
function getParentInjectorLocation(tNode, lView) {
  if (tNode.parent && tNode.parent.injectorIndex !== -1) {
    return tNode.parent.injectorIndex;
  }
  let declarationViewOffset = 0;
  let parentTNode = null;
  let lViewCursor = lView;
  while (lViewCursor !== null) {
    parentTNode = getTNodeFromLView(lViewCursor);
    if (parentTNode === null) {
      return NO_PARENT_INJECTOR;
    }
    ngDevMode && parentTNode && assertTNodeForLView(parentTNode, lViewCursor[DECLARATION_VIEW]);
    declarationViewOffset++;
    lViewCursor = lViewCursor[DECLARATION_VIEW];
    if (parentTNode.injectorIndex !== -1) {
      return parentTNode.injectorIndex | declarationViewOffset << 16;
    }
  }
  return NO_PARENT_INJECTOR;
}
function diPublicInInjector(injectorIndex, tView, token) {
  bloomAdd(injectorIndex, tView, token);
}
function injectAttributeImpl(tNode, attrNameToInject) {
  ngDevMode && assertTNodeType(
    tNode,
    12 | 3
    /* TNodeType.AnyRNode */
  );
  ngDevMode && assertDefined(tNode, "expecting tNode");
  if (attrNameToInject === "class") {
    return tNode.classes;
  }
  if (attrNameToInject === "style") {
    return tNode.styles;
  }
  const attrs = tNode.attrs;
  if (attrs) {
    const attrsLength = attrs.length;
    let i = 0;
    while (i < attrsLength) {
      const value = attrs[i];
      if (isNameOnlyAttributeMarker(value)) break;
      if (value === 0) {
        i = i + 2;
      } else if (typeof value === "number") {
        i++;
        while (i < attrsLength && typeof attrs[i] === "string") {
          i++;
        }
      } else if (value === attrNameToInject) {
        return attrs[i + 1];
      } else {
        i = i + 2;
      }
    }
  }
  return null;
}
function notFoundValueOrThrow(notFoundValue, token, flags) {
  if (flags & InjectFlags.Optional || notFoundValue !== void 0) {
    return notFoundValue;
  } else {
    throwProviderNotFoundError(token, "NodeInjector");
  }
}
function lookupTokenUsingModuleInjector(lView, token, flags, notFoundValue) {
  if (flags & InjectFlags.Optional && notFoundValue === void 0) {
    notFoundValue = null;
  }
  if ((flags & (InjectFlags.Self | InjectFlags.Host)) === 0) {
    const moduleInjector = lView[INJECTOR];
    const previousInjectImplementation = setInjectImplementation(void 0);
    try {
      if (moduleInjector) {
        return moduleInjector.get(token, notFoundValue, flags & InjectFlags.Optional);
      } else {
        return injectRootLimpMode(token, notFoundValue, flags & InjectFlags.Optional);
      }
    } finally {
      setInjectImplementation(previousInjectImplementation);
    }
  }
  return notFoundValueOrThrow(notFoundValue, token, flags);
}
function getOrCreateInjectable(tNode, lView, token, flags = InjectFlags.Default, notFoundValue) {
  if (tNode !== null) {
    if (lView[FLAGS] & 2048 && // The token must be present on the current node injector when the `Self`
    // flag is set, so the lookup on embedded view injector(s) can be skipped.
    !(flags & InjectFlags.Self)) {
      const embeddedInjectorValue = lookupTokenUsingEmbeddedInjector(tNode, lView, token, flags, NOT_FOUND);
      if (embeddedInjectorValue !== NOT_FOUND) {
        return embeddedInjectorValue;
      }
    }
    const value = lookupTokenUsingNodeInjector(tNode, lView, token, flags, NOT_FOUND);
    if (value !== NOT_FOUND) {
      return value;
    }
  }
  return lookupTokenUsingModuleInjector(lView, token, flags, notFoundValue);
}
function lookupTokenUsingNodeInjector(tNode, lView, token, flags, notFoundValue) {
  const bloomHash = bloomHashBitOrFactory(token);
  if (typeof bloomHash === "function") {
    if (!enterDI(lView, tNode, flags)) {
      return flags & InjectFlags.Host ? notFoundValueOrThrow(notFoundValue, token, flags) : lookupTokenUsingModuleInjector(lView, token, flags, notFoundValue);
    }
    try {
      let value;
      if (ngDevMode) {
        runInInjectorProfilerContext(new NodeInjector(getCurrentTNode(), getLView()), token, () => {
          value = bloomHash(flags);
          if (value != null) {
            emitInstanceCreatedByInjectorEvent(value);
          }
        });
      } else {
        value = bloomHash(flags);
      }
      if (value == null && !(flags & InjectFlags.Optional)) {
        throwProviderNotFoundError(token);
      } else {
        return value;
      }
    } finally {
      leaveDI();
    }
  } else if (typeof bloomHash === "number") {
    let previousTView = null;
    let injectorIndex = getInjectorIndex(tNode, lView);
    let parentLocation = NO_PARENT_INJECTOR;
    let hostTElementNode = flags & InjectFlags.Host ? lView[DECLARATION_COMPONENT_VIEW][T_HOST] : null;
    if (injectorIndex === -1 || flags & InjectFlags.SkipSelf) {
      parentLocation = injectorIndex === -1 ? getParentInjectorLocation(tNode, lView) : lView[
        injectorIndex + 8
        /* NodeInjectorOffset.PARENT */
      ];
      if (parentLocation === NO_PARENT_INJECTOR || !shouldSearchParent(flags, false)) {
        injectorIndex = -1;
      } else {
        previousTView = lView[TVIEW];
        injectorIndex = getParentInjectorIndex(parentLocation);
        lView = getParentInjectorView(parentLocation, lView);
      }
    }
    while (injectorIndex !== -1) {
      ngDevMode && assertNodeInjector(lView, injectorIndex);
      const tView = lView[TVIEW];
      ngDevMode && assertTNodeForLView(tView.data[
        injectorIndex + 8
        /* NodeInjectorOffset.TNODE */
      ], lView);
      if (bloomHasToken(bloomHash, injectorIndex, tView.data)) {
        const instance = searchTokensOnInjector(injectorIndex, lView, token, previousTView, flags, hostTElementNode);
        if (instance !== NOT_FOUND) {
          return instance;
        }
      }
      parentLocation = lView[
        injectorIndex + 8
        /* NodeInjectorOffset.PARENT */
      ];
      if (parentLocation !== NO_PARENT_INJECTOR && shouldSearchParent(flags, lView[TVIEW].data[
        injectorIndex + 8
        /* NodeInjectorOffset.TNODE */
      ] === hostTElementNode) && bloomHasToken(bloomHash, injectorIndex, lView)) {
        previousTView = tView;
        injectorIndex = getParentInjectorIndex(parentLocation);
        lView = getParentInjectorView(parentLocation, lView);
      } else {
        injectorIndex = -1;
      }
    }
  }
  return notFoundValue;
}
function searchTokensOnInjector(injectorIndex, lView, token, previousTView, flags, hostTElementNode) {
  const currentTView = lView[TVIEW];
  const tNode = currentTView.data[
    injectorIndex + 8
    /* NodeInjectorOffset.TNODE */
  ];
  const canAccessViewProviders = previousTView == null ? (
    // 1) This is the first invocation `previousTView == null` which means that we are at the
    // `TNode` of where injector is starting to look. In such a case the only time we are allowed
    // to look into the ViewProviders is if:
    // - we are on a component
    // - AND the injector set `includeViewProviders` to true (implying that the token can see
    // ViewProviders because it is the Component or a Service which itself was declared in
    // ViewProviders)
    isComponentHost(tNode) && includeViewProviders
  ) : (
    // 2) `previousTView != null` which means that we are now walking across the parent nodes.
    // In such a case we are only allowed to look into the ViewProviders if:
    // - We just crossed from child View to Parent View `previousTView != currentTView`
    // - AND the parent TNode is an Element.
    // This means that we just came from the Component's View and therefore are allowed to see
    // into the ViewProviders.
    previousTView != currentTView && (tNode.type & 3) !== 0
  );
  const isHostSpecialCase = flags & InjectFlags.Host && hostTElementNode === tNode;
  const injectableIdx = locateDirectiveOrProvider(tNode, currentTView, token, canAccessViewProviders, isHostSpecialCase);
  if (injectableIdx !== null) {
    return getNodeInjectable(lView, currentTView, injectableIdx, tNode);
  } else {
    return NOT_FOUND;
  }
}
function locateDirectiveOrProvider(tNode, tView, token, canAccessViewProviders, isHostSpecialCase) {
  const nodeProviderIndexes = tNode.providerIndexes;
  const tInjectables = tView.data;
  const injectablesStart = nodeProviderIndexes & 1048575;
  const directivesStart = tNode.directiveStart;
  const directiveEnd = tNode.directiveEnd;
  const cptViewProvidersCount = nodeProviderIndexes >> 20;
  const startingIndex = canAccessViewProviders ? injectablesStart : injectablesStart + cptViewProvidersCount;
  const endIndex = isHostSpecialCase ? injectablesStart + cptViewProvidersCount : directiveEnd;
  for (let i = startingIndex; i < endIndex; i++) {
    const providerTokenOrDef = tInjectables[i];
    if (i < directivesStart && token === providerTokenOrDef || i >= directivesStart && providerTokenOrDef.type === token) {
      return i;
    }
  }
  if (isHostSpecialCase) {
    const dirDef = tInjectables[directivesStart];
    if (dirDef && isComponentDef(dirDef) && dirDef.type === token) {
      return directivesStart;
    }
  }
  return null;
}
function getNodeInjectable(lView, tView, index, tNode) {
  let value = lView[index];
  const tData = tView.data;
  if (isFactory(value)) {
    const factory = value;
    if (factory.resolving) {
      throwCyclicDependencyError(stringifyForError(tData[index]));
    }
    const previousIncludeViewProviders = setIncludeViewProviders(factory.canSeeViewProviders);
    factory.resolving = true;
    let prevInjectContext;
    if (ngDevMode) {
      const token = tData[index].type || tData[index];
      const injector = new NodeInjector(tNode, lView);
      prevInjectContext = setInjectorProfilerContext({
        injector,
        token
      });
    }
    const previousInjectImplementation = factory.injectImpl ? setInjectImplementation(factory.injectImpl) : null;
    const success = enterDI(lView, tNode, InjectFlags.Default);
    ngDevMode && assertEqual(success, true, "Because flags do not contain `SkipSelf' we expect this to always succeed.");
    try {
      value = lView[index] = factory.factory(void 0, tData, lView, tNode);
      ngDevMode && emitInstanceCreatedByInjectorEvent(value);
      if (tView.firstCreatePass && index >= tNode.directiveStart) {
        ngDevMode && assertDirectiveDef(tData[index]);
        registerPreOrderHooks(index, tData[index], tView);
      }
    } finally {
      ngDevMode && setInjectorProfilerContext(prevInjectContext);
      previousInjectImplementation !== null && setInjectImplementation(previousInjectImplementation);
      setIncludeViewProviders(previousIncludeViewProviders);
      factory.resolving = false;
      leaveDI();
    }
  }
  return value;
}
function bloomHashBitOrFactory(token) {
  ngDevMode && assertDefined(token, "token must be defined");
  if (typeof token === "string") {
    return token.charCodeAt(0) || 0;
  }
  const tokenId = (
    // First check with `hasOwnProperty` so we don't get an inherited ID.
    token.hasOwnProperty(NG_ELEMENT_ID) ? token[NG_ELEMENT_ID] : void 0
  );
  if (typeof tokenId === "number") {
    if (tokenId >= 0) {
      return tokenId & BLOOM_MASK;
    } else {
      ngDevMode && assertEqual(tokenId, -1, "Expecting to get Special Injector Id");
      return createNodeInjector;
    }
  } else {
    return tokenId;
  }
}
function bloomHasToken(bloomHash, injectorIndex, injectorView) {
  const mask = 1 << bloomHash;
  const value = injectorView[injectorIndex + (bloomHash >> BLOOM_BUCKET_BITS)];
  return !!(value & mask);
}
function shouldSearchParent(flags, isFirstHostTNode) {
  return !(flags & InjectFlags.Self) && !(flags & InjectFlags.Host && isFirstHostTNode);
}
function getNodeInjectorLView(nodeInjector) {
  return nodeInjector._lView;
}
function getNodeInjectorTNode(nodeInjector) {
  return nodeInjector._tNode;
}
var NodeInjector = class {
  constructor(_tNode, _lView) {
    this._tNode = _tNode;
    this._lView = _lView;
  }
  get(token, notFoundValue, flags) {
    return getOrCreateInjectable(this._tNode, this._lView, token, convertToBitFlags(flags), notFoundValue);
  }
};
function createNodeInjector() {
  return new NodeInjector(getCurrentTNode(), getLView());
}
function ɵɵgetInheritedFactory(type) {
  return noSideEffects(() => {
    const ownConstructor = type.prototype.constructor;
    const ownFactory = ownConstructor[NG_FACTORY_DEF] || getFactoryOf(ownConstructor);
    const objectPrototype = Object.prototype;
    let parent = Object.getPrototypeOf(type.prototype).constructor;
    while (parent && parent !== objectPrototype) {
      const factory = parent[NG_FACTORY_DEF] || getFactoryOf(parent);
      if (factory && factory !== ownFactory) {
        return factory;
      }
      parent = Object.getPrototypeOf(parent);
    }
    return (t) => new t();
  });
}
function getFactoryOf(type) {
  if (isForwardRef(type)) {
    return () => {
      const factory = getFactoryOf(resolveForwardRef(type));
      return factory && factory();
    };
  }
  return getFactoryDef(type);
}
function lookupTokenUsingEmbeddedInjector(tNode, lView, token, flags, notFoundValue) {
  let currentTNode = tNode;
  let currentLView = lView;
  while (currentTNode !== null && currentLView !== null && currentLView[FLAGS] & 2048 && !(currentLView[FLAGS] & 512)) {
    ngDevMode && assertTNodeForLView(currentTNode, currentLView);
    const nodeInjectorValue = lookupTokenUsingNodeInjector(currentTNode, currentLView, token, flags | InjectFlags.Self, NOT_FOUND);
    if (nodeInjectorValue !== NOT_FOUND) {
      return nodeInjectorValue;
    }
    let parentTNode = currentTNode.parent;
    if (!parentTNode) {
      const embeddedViewInjector = currentLView[EMBEDDED_VIEW_INJECTOR];
      if (embeddedViewInjector) {
        const embeddedViewInjectorValue = embeddedViewInjector.get(token, NOT_FOUND, flags);
        if (embeddedViewInjectorValue !== NOT_FOUND) {
          return embeddedViewInjectorValue;
        }
      }
      parentTNode = getTNodeFromLView(currentLView);
      currentLView = currentLView[DECLARATION_VIEW];
    }
    currentTNode = parentTNode;
  }
  return notFoundValue;
}
function getTNodeFromLView(lView) {
  const tView = lView[TVIEW];
  const tViewType = tView.type;
  if (tViewType === 2) {
    ngDevMode && assertDefined(tView.declTNode, "Embedded TNodes should have declaration parents.");
    return tView.declTNode;
  } else if (tViewType === 1) {
    return lView[T_HOST];
  }
  return null;
}
function ɵɵinjectAttribute(attrNameToInject) {
  return injectAttributeImpl(getCurrentTNode(), attrNameToInject);
}
var Attribute2 = makeParamDecorator("Attribute", (attributeName) => ({
  attributeName,
  __NG_ELEMENT_ID__: () => ɵɵinjectAttribute(attributeName)
}));
var _reflect = null;
function getReflect() {
  return _reflect = _reflect || new ReflectionCapabilities();
}
function reflectDependencies(type) {
  return convertDependencies(getReflect().parameters(type));
}
function convertDependencies(deps) {
  return deps.map((dep) => reflectDependency(dep));
}
function reflectDependency(dep) {
  const meta = {
    token: null,
    attribute: null,
    host: false,
    optional: false,
    self: false,
    skipSelf: false
  };
  if (Array.isArray(dep) && dep.length > 0) {
    for (let j = 0; j < dep.length; j++) {
      const param = dep[j];
      if (param === void 0) {
        continue;
      }
      const proto = Object.getPrototypeOf(param);
      if (param instanceof Optional || proto.ngMetadataName === "Optional") {
        meta.optional = true;
      } else if (param instanceof SkipSelf || proto.ngMetadataName === "SkipSelf") {
        meta.skipSelf = true;
      } else if (param instanceof Self || proto.ngMetadataName === "Self") {
        meta.self = true;
      } else if (param instanceof Host || proto.ngMetadataName === "Host") {
        meta.host = true;
      } else if (param instanceof Inject) {
        meta.token = param.token;
      } else if (param instanceof Attribute2) {
        if (param.attributeName === void 0) {
          throw new RuntimeError(204, ngDevMode && `Attribute name must be defined.`);
        }
        meta.attribute = param.attributeName;
      } else {
        meta.token = param;
      }
    }
  } else if (dep === void 0 || Array.isArray(dep) && dep.length === 0) {
    meta.token = null;
  } else {
    meta.token = dep;
  }
  return meta;
}
function compileInjectable(type, meta) {
  let ngInjectableDef = null;
  let ngFactoryDef = null;
  if (!type.hasOwnProperty(NG_PROV_DEF)) {
    Object.defineProperty(type, NG_PROV_DEF, {
      get: () => {
        if (ngInjectableDef === null) {
          const compiler = getCompilerFacade({
            usage: 0,
            kind: "injectable",
            type
          });
          ngInjectableDef = compiler.compileInjectable(angularCoreDiEnv, `ng:///${type.name}/ɵprov.js`, getInjectableMetadata(type, meta));
        }
        return ngInjectableDef;
      }
    });
  }
  if (!type.hasOwnProperty(NG_FACTORY_DEF)) {
    Object.defineProperty(type, NG_FACTORY_DEF, {
      get: () => {
        if (ngFactoryDef === null) {
          const compiler = getCompilerFacade({
            usage: 0,
            kind: "injectable",
            type
          });
          ngFactoryDef = compiler.compileFactory(angularCoreDiEnv, `ng:///${type.name}/ɵfac.js`, {
            name: type.name,
            type,
            typeArgumentCount: 0,
            // In JIT mode types are not available nor used.
            deps: reflectDependencies(type),
            target: compiler.FactoryTarget.Injectable
          });
        }
        return ngFactoryDef;
      },
      // Leave this configurable so that the factories from directives or pipes can take precedence.
      configurable: true
    });
  }
}
var USE_VALUE = getClosureSafeProperty({
  provide: String,
  useValue: getClosureSafeProperty
});
function isUseClassProvider(meta) {
  return meta.useClass !== void 0;
}
function isUseValueProvider(meta) {
  return USE_VALUE in meta;
}
function isUseFactoryProvider(meta) {
  return meta.useFactory !== void 0;
}
function isUseExistingProvider(meta) {
  return meta.useExisting !== void 0;
}
function getInjectableMetadata(type, srcMeta) {
  const meta = srcMeta || {
    providedIn: null
  };
  const compilerMeta = {
    name: type.name,
    type,
    typeArgumentCount: 0,
    providedIn: meta.providedIn
  };
  if ((isUseClassProvider(meta) || isUseFactoryProvider(meta)) && meta.deps !== void 0) {
    compilerMeta.deps = convertDependencies(meta.deps);
  }
  if (isUseClassProvider(meta)) {
    compilerMeta.useClass = meta.useClass;
  } else if (isUseValueProvider(meta)) {
    compilerMeta.useValue = meta.useValue;
  } else if (isUseFactoryProvider(meta)) {
    compilerMeta.useFactory = meta.useFactory;
  } else if (isUseExistingProvider(meta)) {
    compilerMeta.useExisting = meta.useExisting;
  }
  return compilerMeta;
}
var Injectable = makeDecorator("Injectable", void 0, void 0, void 0, (type, meta) => compileInjectable(type, meta));
function createInjector(defType, parent = null, additionalProviders = null, name) {
  const injector = createInjectorWithoutInjectorInstances(defType, parent, additionalProviders, name);
  injector.resolveInjectorInitializers();
  return injector;
}
function createInjectorWithoutInjectorInstances(defType, parent = null, additionalProviders = null, name, scopes = /* @__PURE__ */ new Set()) {
  const providers = [additionalProviders || EMPTY_ARRAY, importProvidersFrom(defType)];
  name = name || (typeof defType === "object" ? void 0 : stringify(defType));
  return new R3Injector(providers, parent || getNullInjector(), name || null, scopes);
}
var Injector = class _Injector {
  static {
    this.THROW_IF_NOT_FOUND = THROW_IF_NOT_FOUND;
  }
  static {
    this.NULL = new NullInjector();
  }
  static create(options, parent) {
    if (Array.isArray(options)) {
      return createInjector({
        name: ""
      }, parent, options, "");
    } else {
      const name = options.name ?? "";
      return createInjector({
        name
      }, options.parent, options.providers, name);
    }
  }
  static {
    this.ɵprov = ɵɵdefineInjectable({
      token: _Injector,
      providedIn: "any",
      factory: () => ɵɵinject(INJECTOR$1)
    });
  }
  static {
    this.__NG_ELEMENT_ID__ = -1;
  }
};
var HOST_TAG_NAME = new InjectionToken(ngDevMode ? "HOST_TAG_NAME" : "");
HOST_TAG_NAME.__NG_ELEMENT_ID__ = (flags) => {
  const tNode = getCurrentTNode();
  if (tNode === null) {
    throw new RuntimeError(204, ngDevMode && "HOST_TAG_NAME can only be injected in directives and components during construction time (in a class constructor or as a class field initializer)");
  }
  if (tNode.type & 2) {
    return tNode.value;
  }
  if (flags & InjectFlags.Optional) {
    return null;
  }
  throw new RuntimeError(204, ngDevMode && `HOST_TAG_NAME was used on ${getDevModeNodeName(tNode)} which doesn't have an underlying element in the DOM. This is invalid, and so the dependency should be marked as optional.`);
};
function getDevModeNodeName(tNode) {
  if (tNode.type & 8) {
    return "an <ng-container>";
  } else if (tNode.type & 4) {
    return "an <ng-template>";
  } else if (tNode.type & 128) {
    return "an @let declaration";
  } else {
    return "a node";
  }
}
var ERROR_ORIGINAL_ERROR = "ngOriginalError";
function getOriginalError(error) {
  return error[ERROR_ORIGINAL_ERROR];
}
var DestroyRef = class {
  static {
    this.__NG_ELEMENT_ID__ = injectDestroyRef;
  }
  static {
    this.__NG_ENV_ID__ = (injector) => injector;
  }
};
var NodeInjectorDestroyRef = class extends DestroyRef {
  constructor(_lView) {
    super();
    this._lView = _lView;
  }
  onDestroy(callback) {
    storeLViewOnDestroy(this._lView, callback);
    return () => removeLViewOnDestroy(this._lView, callback);
  }
};
function injectDestroyRef() {
  return new NodeInjectorDestroyRef(getLView());
}
var PendingTasks = class _PendingTasks {
  constructor() {
    this.taskId = 0;
    this.pendingTasks = /* @__PURE__ */ new Set();
    this.hasPendingTasks = new BehaviorSubject(false);
  }
  get _hasPendingTasks() {
    return this.hasPendingTasks.value;
  }
  add() {
    if (!this._hasPendingTasks) {
      this.hasPendingTasks.next(true);
    }
    const taskId = this.taskId++;
    this.pendingTasks.add(taskId);
    return taskId;
  }
  remove(taskId) {
    this.pendingTasks.delete(taskId);
    if (this.pendingTasks.size === 0 && this._hasPendingTasks) {
      this.hasPendingTasks.next(false);
    }
  }
  ngOnDestroy() {
    this.pendingTasks.clear();
    if (this._hasPendingTasks) {
      this.hasPendingTasks.next(false);
    }
  }
  static {
    this.ɵprov = ɵɵdefineInjectable({
      token: _PendingTasks,
      providedIn: "root",
      factory: () => new _PendingTasks()
    });
  }
};
var ExperimentalPendingTasks = class _ExperimentalPendingTasks {
  constructor() {
    this.internalPendingTasks = inject(PendingTasks);
  }
  /**
   * Adds a new task that should block application's stability.
   * @returns A cleanup function that removes a task when called.
   */
  add() {
    const taskId = this.internalPendingTasks.add();
    return () => this.internalPendingTasks.remove(taskId);
  }
  static {
    this.ɵprov = ɵɵdefineInjectable({
      token: _ExperimentalPendingTasks,
      providedIn: "root",
      factory: () => new _ExperimentalPendingTasks()
    });
  }
};
var EventEmitter_ = class extends Subject {
  constructor(isAsync = false) {
    super();
    this.destroyRef = void 0;
    this.pendingTasks = void 0;
    this.__isAsync = isAsync;
    if (isInInjectionContext()) {
      this.destroyRef = inject(DestroyRef, {
        optional: true
      }) ?? void 0;
      this.pendingTasks = inject(PendingTasks, {
        optional: true
      }) ?? void 0;
    }
  }
  emit(value) {
    const prevConsumer = setActiveConsumer(null);
    try {
      super.next(value);
    } finally {
      setActiveConsumer(prevConsumer);
    }
  }
  subscribe(observerOrNext, error, complete) {
    let nextFn = observerOrNext;
    let errorFn = error || (() => null);
    let completeFn = complete;
    if (observerOrNext && typeof observerOrNext === "object") {
      const observer = observerOrNext;
      nextFn = observer.next?.bind(observer);
      errorFn = observer.error?.bind(observer);
      completeFn = observer.complete?.bind(observer);
    }
    if (this.__isAsync) {
      errorFn = this.wrapInTimeout(errorFn);
      if (nextFn) {
        nextFn = this.wrapInTimeout(nextFn);
      }
      if (completeFn) {
        completeFn = this.wrapInTimeout(completeFn);
      }
    }
    const sink = super.subscribe({
      next: nextFn,
      error: errorFn,
      complete: completeFn
    });
    if (observerOrNext instanceof Subscription) {
      observerOrNext.add(sink);
    }
    return sink;
  }
  wrapInTimeout(fn) {
    return (value) => {
      const taskId = this.pendingTasks?.add();
      setTimeout(() => {
        fn(value);
        if (taskId !== void 0) {
          this.pendingTasks?.remove(taskId);
        }
      });
    };
  }
};
var EventEmitter = EventEmitter_;
function noop(...args) {
}
function scheduleCallbackWithRafRace(callback) {
  let timeoutId;
  let animationFrameId;
  function cleanup() {
    callback = noop;
    try {
      if (animationFrameId !== void 0 && typeof cancelAnimationFrame === "function") {
        cancelAnimationFrame(animationFrameId);
      }
      if (timeoutId !== void 0) {
        clearTimeout(timeoutId);
      }
    } catch {
    }
  }
  timeoutId = setTimeout(() => {
    callback();
    cleanup();
  });
  if (typeof requestAnimationFrame === "function") {
    animationFrameId = requestAnimationFrame(() => {
      callback();
      cleanup();
    });
  }
  return () => cleanup();
}
function scheduleCallbackWithMicrotask(callback) {
  queueMicrotask(() => callback());
  return () => {
    callback = noop;
  };
}
var AsyncStackTaggingZoneSpec = class {
  constructor(namePrefix, consoleAsyncStackTaggingImpl = console) {
    this.name = "asyncStackTagging for " + namePrefix;
    this.createTask = consoleAsyncStackTaggingImpl?.createTask ?? (() => null);
  }
  onScheduleTask(delegate, _current, target, task) {
    task.consoleTask = this.createTask(`Zone - ${task.source || task.type}`);
    return delegate.scheduleTask(target, task);
  }
  onInvokeTask(delegate, _currentZone, targetZone, task, applyThis, applyArgs) {
    let ret;
    if (task.consoleTask) {
      ret = task.consoleTask.run(() => delegate.invokeTask(targetZone, task, applyThis, applyArgs));
    } else {
      ret = delegate.invokeTask(targetZone, task, applyThis, applyArgs);
    }
    return ret;
  }
};
var isAngularZoneProperty = "isAngularZone";
var angularZoneInstanceIdProperty = isAngularZoneProperty + "_ID";
var ngZoneInstanceId = 0;
var NgZone = class _NgZone {
  constructor({
    enableLongStackTrace = false,
    shouldCoalesceEventChangeDetection = false,
    shouldCoalesceRunChangeDetection = false
  }) {
    this.hasPendingMacrotasks = false;
    this.hasPendingMicrotasks = false;
    this.isStable = true;
    this.onUnstable = new EventEmitter(false);
    this.onMicrotaskEmpty = new EventEmitter(false);
    this.onStable = new EventEmitter(false);
    this.onError = new EventEmitter(false);
    if (typeof Zone == "undefined") {
      throw new RuntimeError(908, ngDevMode && `In this configuration Angular requires Zone.js`);
    }
    Zone.assertZonePatched();
    const self = this;
    self._nesting = 0;
    self._outer = self._inner = Zone.current;
    if (ngDevMode) {
      self._inner = self._inner.fork(new AsyncStackTaggingZoneSpec("Angular"));
    }
    if (Zone["TaskTrackingZoneSpec"]) {
      self._inner = self._inner.fork(new Zone["TaskTrackingZoneSpec"]());
    }
    if (enableLongStackTrace && Zone["longStackTraceZoneSpec"]) {
      self._inner = self._inner.fork(Zone["longStackTraceZoneSpec"]);
    }
    self.shouldCoalesceEventChangeDetection = !shouldCoalesceRunChangeDetection && shouldCoalesceEventChangeDetection;
    self.shouldCoalesceRunChangeDetection = shouldCoalesceRunChangeDetection;
    self.callbackScheduled = false;
    forkInnerZoneWithAngularBehavior(self);
  }
  /**
    This method checks whether the method call happens within an Angular Zone instance.
  */
  static isInAngularZone() {
    return typeof Zone !== "undefined" && Zone.current.get(isAngularZoneProperty) === true;
  }
  /**
    Assures that the method is called within the Angular Zone, otherwise throws an error.
  */
  static assertInAngularZone() {
    if (!_NgZone.isInAngularZone()) {
      throw new RuntimeError(909, ngDevMode && "Expected to be in Angular Zone, but it is not!");
    }
  }
  /**
    Assures that the method is called outside of the Angular Zone, otherwise throws an error.
  */
  static assertNotInAngularZone() {
    if (_NgZone.isInAngularZone()) {
      throw new RuntimeError(909, ngDevMode && "Expected to not be in Angular Zone, but it is!");
    }
  }
  /**
   * Executes the `fn` function synchronously within the Angular zone and returns value returned by
   * the function.
   *
   * Running functions via `run` allows you to reenter Angular zone from a task that was executed
   * outside of the Angular zone (typically started via {@link #runOutsideAngular}).
   *
   * Any future tasks or microtasks scheduled from within this function will continue executing from
   * within the Angular zone.
   *
   * If a synchronous error happens it will be rethrown and not reported via `onError`.
   */
  run(fn, applyThis, applyArgs) {
    return this._inner.run(fn, applyThis, applyArgs);
  }
  /**
   * Executes the `fn` function synchronously within the Angular zone as a task and returns value
   * returned by the function.
   *
   * Running functions via `run` allows you to reenter Angular zone from a task that was executed
   * outside of the Angular zone (typically started via {@link #runOutsideAngular}).
   *
   * Any future tasks or microtasks scheduled from within this function will continue executing from
   * within the Angular zone.
   *
   * If a synchronous error happens it will be rethrown and not reported via `onError`.
   */
  runTask(fn, applyThis, applyArgs, name) {
    const zone = this._inner;
    const task = zone.scheduleEventTask("NgZoneEvent: " + name, fn, EMPTY_PAYLOAD, noop, noop);
    try {
      return zone.runTask(task, applyThis, applyArgs);
    } finally {
      zone.cancelTask(task);
    }
  }
  /**
   * Same as `run`, except that synchronous errors are caught and forwarded via `onError` and not
   * rethrown.
   */
  runGuarded(fn, applyThis, applyArgs) {
    return this._inner.runGuarded(fn, applyThis, applyArgs);
  }
  /**
   * Executes the `fn` function synchronously in Angular's parent zone and returns value returned by
   * the function.
   *
   * Running functions via {@link #runOutsideAngular} allows you to escape Angular's zone and do
   * work that
   * doesn't trigger Angular change-detection or is subject to Angular's error handling.
   *
   * Any future tasks or microtasks scheduled from within this function will continue executing from
   * outside of the Angular zone.
   *
   * Use {@link #run} to reenter the Angular zone and do work that updates the application model.
   */
  runOutsideAngular(fn) {
    return this._outer.run(fn);
  }
};
var EMPTY_PAYLOAD = {};
function checkStable(zone) {
  if (zone._nesting == 0 && !zone.hasPendingMicrotasks && !zone.isStable) {
    try {
      zone._nesting++;
      zone.onMicrotaskEmpty.emit(null);
    } finally {
      zone._nesting--;
      if (!zone.hasPendingMicrotasks) {
        try {
          zone.runOutsideAngular(() => zone.onStable.emit(null));
        } finally {
          zone.isStable = true;
        }
      }
    }
  }
}
function delayChangeDetectionForEvents(zone) {
  if (zone.isCheckStableRunning || zone.callbackScheduled) {
    return;
  }
  zone.callbackScheduled = true;
  Zone.root.run(() => {
    scheduleCallbackWithRafRace(() => {
      zone.callbackScheduled = false;
      updateMicroTaskStatus(zone);
      zone.isCheckStableRunning = true;
      checkStable(zone);
      zone.isCheckStableRunning = false;
    });
  });
  updateMicroTaskStatus(zone);
}
function forkInnerZoneWithAngularBehavior(zone) {
  const delayChangeDetectionForEventsDelegate = () => {
    delayChangeDetectionForEvents(zone);
  };
  const instanceId = ngZoneInstanceId++;
  zone._inner = zone._inner.fork({
    name: "angular",
    properties: {
      [isAngularZoneProperty]: true,
      [angularZoneInstanceIdProperty]: instanceId,
      [angularZoneInstanceIdProperty + instanceId]: true
    },
    onInvokeTask: (delegate, current, target, task, applyThis, applyArgs) => {
      if (shouldBeIgnoredByZone(applyArgs)) {
        return delegate.invokeTask(target, task, applyThis, applyArgs);
      }
      try {
        onEnter(zone);
        return delegate.invokeTask(target, task, applyThis, applyArgs);
      } finally {
        if (zone.shouldCoalesceEventChangeDetection && task.type === "eventTask" || zone.shouldCoalesceRunChangeDetection) {
          delayChangeDetectionForEventsDelegate();
        }
        onLeave(zone);
      }
    },
    onInvoke: (delegate, current, target, callback, applyThis, applyArgs, source) => {
      try {
        onEnter(zone);
        return delegate.invoke(target, callback, applyThis, applyArgs, source);
      } finally {
        if (zone.shouldCoalesceRunChangeDetection && // Do not delay change detection when the task is the scheduler's tick.
        // We need to synchronously trigger the stability logic so that the
        // zone-based scheduler can prevent a duplicate ApplicationRef.tick
        // by first checking if the scheduler tick is running. This does seem a bit roundabout,
        // but we _do_ still want to trigger all the correct events when we exit the zone.run
        // (`onMicrotaskEmpty` and `onStable` _should_ emit; developers can have code which
        // relies on these events happening after change detection runs).
        // Note: `zone.callbackScheduled` is already in delayChangeDetectionForEventsDelegate
        // but is added here as well to prevent reads of applyArgs when not necessary
        !zone.callbackScheduled && !isSchedulerTick(applyArgs)) {
          delayChangeDetectionForEventsDelegate();
        }
        onLeave(zone);
      }
    },
    onHasTask: (delegate, current, target, hasTaskState) => {
      delegate.hasTask(target, hasTaskState);
      if (current === target) {
        if (hasTaskState.change == "microTask") {
          zone._hasPendingMicrotasks = hasTaskState.microTask;
          updateMicroTaskStatus(zone);
          checkStable(zone);
        } else if (hasTaskState.change == "macroTask") {
          zone.hasPendingMacrotasks = hasTaskState.macroTask;
        }
      }
    },
    onHandleError: (delegate, current, target, error) => {
      delegate.handleError(target, error);
      zone.runOutsideAngular(() => zone.onError.emit(error));
      return false;
    }
  });
}
function updateMicroTaskStatus(zone) {
  if (zone._hasPendingMicrotasks || (zone.shouldCoalesceEventChangeDetection || zone.shouldCoalesceRunChangeDetection) && zone.callbackScheduled === true) {
    zone.hasPendingMicrotasks = true;
  } else {
    zone.hasPendingMicrotasks = false;
  }
}
function onEnter(zone) {
  zone._nesting++;
  if (zone.isStable) {
    zone.isStable = false;
    zone.onUnstable.emit(null);
  }
}
function onLeave(zone) {
  zone._nesting--;
  checkStable(zone);
}
var NoopNgZone = class {
  constructor() {
    this.hasPendingMicrotasks = false;
    this.hasPendingMacrotasks = false;
    this.isStable = true;
    this.onUnstable = new EventEmitter();
    this.onMicrotaskEmpty = new EventEmitter();
    this.onStable = new EventEmitter();
    this.onError = new EventEmitter();
  }
  run(fn, applyThis, applyArgs) {
    return fn.apply(applyThis, applyArgs);
  }
  runGuarded(fn, applyThis, applyArgs) {
    return fn.apply(applyThis, applyArgs);
  }
  runOutsideAngular(fn) {
    return fn();
  }
  runTask(fn, applyThis, applyArgs, name) {
    return fn.apply(applyThis, applyArgs);
  }
};
function shouldBeIgnoredByZone(applyArgs) {
  return hasApplyArgsData(applyArgs, "__ignore_ng_zone__");
}
function isSchedulerTick(applyArgs) {
  return hasApplyArgsData(applyArgs, "__scheduler_tick__");
}
function hasApplyArgsData(applyArgs, key) {
  if (!Array.isArray(applyArgs)) {
    return false;
  }
  if (applyArgs.length !== 1) {
    return false;
  }
  return applyArgs[0]?.data?.[key] === true;
}
function getNgZone(ngZoneToUse = "zone.js", options) {
  if (ngZoneToUse === "noop") {
    return new NoopNgZone();
  }
  if (ngZoneToUse === "zone.js") {
    return new NgZone(options);
  }
  return ngZoneToUse;
}
var ErrorHandler = class {
  constructor() {
    this._console = console;
  }
  handleError(error) {
    const originalError = this._findOriginalError(error);
    this._console.error("ERROR", error);
    if (originalError) {
      this._console.error("ORIGINAL ERROR", originalError);
    }
  }
  /** @internal */
  _findOriginalError(error) {
    let e = error && getOriginalError(error);
    while (e && getOriginalError(e)) {
      e = getOriginalError(e);
    }
    return e || null;
  }
};
var INTERNAL_APPLICATION_ERROR_HANDLER = new InjectionToken(typeof ngDevMode === "undefined" || ngDevMode ? "internal error handler" : "", {
  providedIn: "root",
  factory: () => {
    const zone = inject(NgZone);
    const userErrorHandler = inject(ErrorHandler);
    return (e) => zone.runOutsideAngular(() => userErrorHandler.handleError(e));
  }
});
var OutputEmitterRef = class {
  constructor() {
    this.destroyed = false;
    this.listeners = null;
    this.errorHandler = inject(ErrorHandler, {
      optional: true
    });
    this.destroyRef = inject(DestroyRef);
    this.destroyRef.onDestroy(() => {
      this.destroyed = true;
      this.listeners = null;
    });
  }
  subscribe(callback) {
    if (this.destroyed) {
      throw new RuntimeError(953, ngDevMode && "Unexpected subscription to destroyed `OutputRef`. The owning directive/component is destroyed.");
    }
    (this.listeners ??= []).push(callback);
    return {
      unsubscribe: () => {
        const idx = this.listeners?.indexOf(callback);
        if (idx !== void 0 && idx !== -1) {
          this.listeners?.splice(idx, 1);
        }
      }
    };
  }
  /** Emits a new value to the output. */
  emit(value) {
    if (this.destroyed) {
      throw new RuntimeError(953, ngDevMode && "Unexpected emit for destroyed `OutputRef`. The owning directive/component is destroyed.");
    }
    if (this.listeners === null) {
      return;
    }
    const previousConsumer = setActiveConsumer(null);
    try {
      for (const listenerFn of this.listeners) {
        try {
          listenerFn(value);
        } catch (err) {
          this.errorHandler?.handleError(err);
        }
      }
    } finally {
      setActiveConsumer(previousConsumer);
    }
  }
};
function inputFunction(initialValue, opts) {
  ngDevMode && assertInInjectionContext(input);
  return createInputSignal(initialValue, opts);
}
function inputRequiredFunction(opts) {
  ngDevMode && assertInInjectionContext(input);
  return createInputSignal(REQUIRED_UNSET_VALUE, opts);
}
var input = (() => {
  inputFunction.required = inputRequiredFunction;
  return inputFunction;
})();
function injectElementRef() {
  return createElementRef(getCurrentTNode(), getLView());
}
function createElementRef(tNode, lView) {
  return new ElementRef(getNativeByTNode(tNode, lView));
}
var ElementRef = class {
  constructor(nativeElement) {
    this.nativeElement = nativeElement;
  }
  static {
    this.__NG_ELEMENT_ID__ = injectElementRef;
  }
};
function unwrapElementRef(value) {
  return value instanceof ElementRef ? value.nativeElement : value;
}
function symbolIterator() {
  return this._results[Symbol.iterator]();
}
var QueryList = class _QueryList {
  static {
    Symbol.iterator;
  }
  /**
   * Returns `Observable` of `QueryList` notifying the subscriber of changes.
   */
  get changes() {
    return this._changes ??= new EventEmitter();
  }
  /**
   * @param emitDistinctChangesOnly Whether `QueryList.changes` should fire only when actual change
   *     has occurred. Or if it should fire when query is recomputed. (recomputing could resolve in
   *     the same result)
   */
  constructor(_emitDistinctChangesOnly = false) {
    this._emitDistinctChangesOnly = _emitDistinctChangesOnly;
    this.dirty = true;
    this._onDirty = void 0;
    this._results = [];
    this._changesDetected = false;
    this._changes = void 0;
    this.length = 0;
    this.first = void 0;
    this.last = void 0;
    const proto = _QueryList.prototype;
    if (!proto[Symbol.iterator]) proto[Symbol.iterator] = symbolIterator;
  }
  /**
   * Returns the QueryList entry at `index`.
   */
  get(index) {
    return this._results[index];
  }
  /**
   * See
   * [Array.map](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map)
   */
  map(fn) {
    return this._results.map(fn);
  }
  filter(fn) {
    return this._results.filter(fn);
  }
  /**
   * See
   * [Array.find](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/find)
   */
  find(fn) {
    return this._results.find(fn);
  }
  /**
   * See
   * [Array.reduce](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce)
   */
  reduce(fn, init) {
    return this._results.reduce(fn, init);
  }
  /**
   * See
   * [Array.forEach](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach)
   */
  forEach(fn) {
    this._results.forEach(fn);
  }
  /**
   * See
   * [Array.some](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/some)
   */
  some(fn) {
    return this._results.some(fn);
  }
  /**
   * Returns a copy of the internal results list as an Array.
   */
  toArray() {
    return this._results.slice();
  }
  toString() {
    return this._results.toString();
  }
  /**
   * Updates the stored data of the query list, and resets the `dirty` flag to `false`, so that
   * on change detection, it will not notify of changes to the queries, unless a new change
   * occurs.
   *
   * @param resultsTree The query results to store
   * @param identityAccessor Optional function for extracting stable object identity from a value
   *    in the array. This function is executed for each element of the query result list while
   *    comparing current query list with the new one (provided as a first argument of the `reset`
   *    function) to detect if the lists are different. If the function is not provided, elements
   *    are compared as is (without any pre-processing).
   */
  reset(resultsTree, identityAccessor) {
    this.dirty = false;
    const newResultFlat = flatten(resultsTree);
    if (this._changesDetected = !arrayEquals(this._results, newResultFlat, identityAccessor)) {
      this._results = newResultFlat;
      this.length = newResultFlat.length;
      this.last = newResultFlat[this.length - 1];
      this.first = newResultFlat[0];
    }
  }
  /**
   * Triggers a change event by emitting on the `changes` {@link EventEmitter}.
   */
  notifyOnChanges() {
    if (this._changes !== void 0 && (this._changesDetected || !this._emitDistinctChangesOnly)) this._changes.emit(this);
  }
  /** @internal */
  onDirty(cb) {
    this._onDirty = cb;
  }
  /** internal */
  setDirty() {
    this.dirty = true;
    this._onDirty?.();
  }
  /** internal */
  destroy() {
    if (this._changes !== void 0) {
      this._changes.complete();
      this._changes.unsubscribe();
    }
  }
};
function hasInSkipHydrationBlockFlag(tNode) {
  return (tNode.flags & 128) === 128;
}
var TRACKED_LVIEWS = /* @__PURE__ */ new Map();
var uniqueIdCounter = 0;
function getUniqueLViewId() {
  return uniqueIdCounter++;
}
function registerLView(lView) {
  ngDevMode && assertNumber(lView[ID], "LView must have an ID in order to be registered");
  TRACKED_LVIEWS.set(lView[ID], lView);
}
function getLViewById(id) {
  ngDevMode && assertNumber(id, "ID used for LView lookup must be a number");
  return TRACKED_LVIEWS.get(id) || null;
}
function unregisterLView(lView) {
  ngDevMode && assertNumber(lView[ID], "Cannot stop tracking an LView that does not have an ID");
  TRACKED_LVIEWS.delete(lView[ID]);
}
var LContext = class {
  /** Component's parent view data. */
  get lView() {
    return getLViewById(this.lViewId);
  }
  constructor(lViewId, nodeIndex, native) {
    this.lViewId = lViewId;
    this.nodeIndex = nodeIndex;
    this.native = native;
  }
};
function getLContext(target) {
  let mpValue = readPatchedData(target);
  if (mpValue) {
    if (isLView(mpValue)) {
      const lView = mpValue;
      let nodeIndex;
      let component = void 0;
      let directives = void 0;
      if (isComponentInstance(target)) {
        nodeIndex = findViaComponent(lView, target);
        if (nodeIndex == -1) {
          throw new Error("The provided component was not found in the application");
        }
        component = target;
      } else if (isDirectiveInstance(target)) {
        nodeIndex = findViaDirective(lView, target);
        if (nodeIndex == -1) {
          throw new Error("The provided directive was not found in the application");
        }
        directives = getDirectivesAtNodeIndex(nodeIndex, lView);
      } else {
        nodeIndex = findViaNativeElement(lView, target);
        if (nodeIndex == -1) {
          return null;
        }
      }
      const native = unwrapRNode(lView[nodeIndex]);
      const existingCtx = readPatchedData(native);
      const context = existingCtx && !Array.isArray(existingCtx) ? existingCtx : createLContext(lView, nodeIndex, native);
      if (component && context.component === void 0) {
        context.component = component;
        attachPatchData(context.component, context);
      }
      if (directives && context.directives === void 0) {
        context.directives = directives;
        for (let i = 0; i < directives.length; i++) {
          attachPatchData(directives[i], context);
        }
      }
      attachPatchData(context.native, context);
      mpValue = context;
    }
  } else {
    const rElement = target;
    ngDevMode && assertDomNode(rElement);
    let parent = rElement;
    while (parent = parent.parentNode) {
      const parentContext = readPatchedData(parent);
      if (parentContext) {
        const lView = Array.isArray(parentContext) ? parentContext : parentContext.lView;
        if (!lView) {
          return null;
        }
        const index = findViaNativeElement(lView, rElement);
        if (index >= 0) {
          const native = unwrapRNode(lView[index]);
          const context = createLContext(lView, index, native);
          attachPatchData(native, context);
          mpValue = context;
          break;
        }
      }
    }
  }
  return mpValue || null;
}
function createLContext(lView, nodeIndex, native) {
  return new LContext(lView[ID], nodeIndex, native);
}
function getComponentViewByInstance(componentInstance) {
  let patchedData = readPatchedData(componentInstance);
  let lView;
  if (isLView(patchedData)) {
    const contextLView = patchedData;
    const nodeIndex = findViaComponent(contextLView, componentInstance);
    lView = getComponentLViewByIndex(nodeIndex, contextLView);
    const context = createLContext(contextLView, nodeIndex, lView[HOST]);
    context.component = componentInstance;
    attachPatchData(componentInstance, context);
    attachPatchData(context.native, context);
  } else {
    const context = patchedData;
    const contextLView = context.lView;
    ngDevMode && assertLView(contextLView);
    lView = getComponentLViewByIndex(context.nodeIndex, contextLView);
  }
  return lView;
}
var MONKEY_PATCH_KEY_NAME = "__ngContext__";
function attachPatchData(target, data) {
  ngDevMode && assertDefined(target, "Target expected");
  if (isLView(data)) {
    target[MONKEY_PATCH_KEY_NAME] = data[ID];
    registerLView(data);
  } else {
    target[MONKEY_PATCH_KEY_NAME] = data;
  }
}
function readPatchedData(target) {
  ngDevMode && assertDefined(target, "Target expected");
  const data = target[MONKEY_PATCH_KEY_NAME];
  return typeof data === "number" ? getLViewById(data) : data || null;
}
function readPatchedLView(target) {
  const value = readPatchedData(target);
  if (value) {
    return isLView(value) ? value : value.lView;
  }
  return null;
}
function isComponentInstance(instance) {
  return instance && instance.constructor && instance.constructor.ɵcmp;
}
function isDirectiveInstance(instance) {
  return instance && instance.constructor && instance.constructor.ɵdir;
}
function findViaNativeElement(lView, target) {
  const tView = lView[TVIEW];
  for (let i = HEADER_OFFSET; i < tView.bindingStartIndex; i++) {
    if (unwrapRNode(lView[i]) === target) {
      return i;
    }
  }
  return -1;
}
function traverseNextElement(tNode) {
  if (tNode.child) {
    return tNode.child;
  } else if (tNode.next) {
    return tNode.next;
  } else {
    while (tNode.parent && !tNode.parent.next) {
      tNode = tNode.parent;
    }
    return tNode.parent && tNode.parent.next;
  }
}
function findViaComponent(lView, componentInstance) {
  const componentIndices = lView[TVIEW].components;
  if (componentIndices) {
    for (let i = 0; i < componentIndices.length; i++) {
      const elementComponentIndex = componentIndices[i];
      const componentView = getComponentLViewByIndex(elementComponentIndex, lView);
      if (componentView[CONTEXT] === componentInstance) {
        return elementComponentIndex;
      }
    }
  } else {
    const rootComponentView = getComponentLViewByIndex(HEADER_OFFSET, lView);
    const rootComponent = rootComponentView[CONTEXT];
    if (rootComponent === componentInstance) {
      return HEADER_OFFSET;
    }
  }
  return -1;
}
function findViaDirective(lView, directiveInstance) {
  let tNode = lView[TVIEW].firstChild;
  while (tNode) {
    const directiveIndexStart = tNode.directiveStart;
    const directiveIndexEnd = tNode.directiveEnd;
    for (let i = directiveIndexStart; i < directiveIndexEnd; i++) {
      if (lView[i] === directiveInstance) {
        return tNode.index;
      }
    }
    tNode = traverseNextElement(tNode);
  }
  return -1;
}
function getDirectivesAtNodeIndex(nodeIndex, lView) {
  const tNode = lView[TVIEW].data[nodeIndex];
  if (tNode.directiveStart === 0) return EMPTY_ARRAY;
  const results = [];
  for (let i = tNode.directiveStart; i < tNode.directiveEnd; i++) {
    const directiveInstance = lView[i];
    if (!isComponentInstance(directiveInstance)) {
      results.push(directiveInstance);
    }
  }
  return results;
}
function getComponentAtNodeIndex(nodeIndex, lView) {
  const tNode = lView[TVIEW].data[nodeIndex];
  const {
    directiveStart,
    componentOffset
  } = tNode;
  return componentOffset > -1 ? lView[directiveStart + componentOffset] : null;
}
function getRootView(componentOrLView) {
  ngDevMode && assertDefined(componentOrLView, "component");
  let lView = isLView(componentOrLView) ? componentOrLView : readPatchedLView(componentOrLView);
  while (lView && !(lView[FLAGS] & 512)) {
    lView = getLViewParent(lView);
  }
  ngDevMode && assertLView(lView);
  return lView;
}
function getRootContext(viewOrComponent) {
  const rootView = getRootView(viewOrComponent);
  ngDevMode && assertDefined(rootView[CONTEXT], "Root view has no context. Perhaps it is disconnected?");
  return rootView[CONTEXT];
}
function getFirstLContainer(lView) {
  return getNearestLContainer(lView[CHILD_HEAD]);
}
function getNextLContainer(container) {
  return getNearestLContainer(container[NEXT]);
}
function getNearestLContainer(viewOrContainer) {
  while (viewOrContainer !== null && !isLContainer(viewOrContainer)) {
    viewOrContainer = viewOrContainer[NEXT];
  }
  return viewOrContainer;
}
function getComponent$1(element) {
  ngDevMode && assertDomElement(element);
  const context = getLContext(element);
  if (context === null) return null;
  if (context.component === void 0) {
    const lView = context.lView;
    if (lView === null) {
      return null;
    }
    context.component = getComponentAtNodeIndex(context.nodeIndex, lView);
  }
  return context.component;
}
function getContext(element) {
  assertDomElement(element);
  const context = getLContext(element);
  const lView = context ? context.lView : null;
  return lView === null ? null : lView[CONTEXT];
}
function getOwningComponent(elementOrDir) {
  const context = getLContext(elementOrDir);
  let lView = context ? context.lView : null;
  if (lView === null) return null;
  let parent;
  while (lView[TVIEW].type === 2 && (parent = getLViewParent(lView))) {
    lView = parent;
  }
  return lView[FLAGS] & 512 ? null : lView[CONTEXT];
}
function getRootComponents(elementOrDir) {
  const lView = readPatchedLView(elementOrDir);
  return lView !== null ? [getRootContext(lView)] : [];
}
function getInjector(elementOrDir) {
  const context = getLContext(elementOrDir);
  const lView = context ? context.lView : null;
  if (lView === null) return Injector.NULL;
  const tNode = lView[TVIEW].data[context.nodeIndex];
  return new NodeInjector(tNode, lView);
}
function getDirectives(node) {
  if (node instanceof Text) {
    return [];
  }
  const context = getLContext(node);
  const lView = context ? context.lView : null;
  if (lView === null) {
    return [];
  }
  const tView = lView[TVIEW];
  const nodeIndex = context.nodeIndex;
  if (!tView?.data[nodeIndex]) {
    return [];
  }
  if (context.directives === void 0) {
    context.directives = getDirectivesAtNodeIndex(nodeIndex, lView);
  }
  return context.directives === null ? [] : [...context.directives];
}
function getDirectiveMetadata$1(directiveOrComponentInstance) {
  const {
    constructor
  } = directiveOrComponentInstance;
  if (!constructor) {
    throw new Error("Unable to find the instance constructor");
  }
  const componentDef = getComponentDef(constructor);
  if (componentDef) {
    const inputs = extractInputDebugMetadata(componentDef.inputs);
    return {
      inputs,
      outputs: componentDef.outputs,
      encapsulation: componentDef.encapsulation,
      changeDetection: componentDef.onPush ? ChangeDetectionStrategy.OnPush : ChangeDetectionStrategy.Default
    };
  }
  const directiveDef = getDirectiveDef(constructor);
  if (directiveDef) {
    const inputs = extractInputDebugMetadata(directiveDef.inputs);
    return {
      inputs,
      outputs: directiveDef.outputs
    };
  }
  return null;
}
function getHostElement(componentOrDirective) {
  return getLContext(componentOrDirective).native;
}
function getListeners(element) {
  ngDevMode && assertDomElement(element);
  const lContext = getLContext(element);
  const lView = lContext === null ? null : lContext.lView;
  if (lView === null) return [];
  const tView = lView[TVIEW];
  const lCleanup = lView[CLEANUP];
  const tCleanup = tView.cleanup;
  const listeners = [];
  if (tCleanup && lCleanup) {
    for (let i = 0; i < tCleanup.length; ) {
      const firstParam = tCleanup[i++];
      const secondParam = tCleanup[i++];
      if (typeof firstParam === "string") {
        const name = firstParam;
        const listenerElement = unwrapRNode(lView[secondParam]);
        const callback = lCleanup[tCleanup[i++]];
        const useCaptureOrIndx = tCleanup[i++];
        const type = typeof useCaptureOrIndx === "boolean" || useCaptureOrIndx >= 0 ? "dom" : "output";
        const useCapture = typeof useCaptureOrIndx === "boolean" ? useCaptureOrIndx : false;
        if (element == listenerElement) {
          listeners.push({
            element,
            name,
            callback,
            useCapture,
            type
          });
        }
      }
    }
  }
  listeners.sort(sortListeners);
  return listeners;
}
function sortListeners(a, b) {
  if (a.name == b.name) return 0;
  return a.name < b.name ? -1 : 1;
}
function assertDomElement(value) {
  if (typeof Element !== "undefined" && !(value instanceof Element)) {
    throw new Error("Expecting instance of DOM Element");
  }
}
function extractInputDebugMetadata(inputs) {
  const res = {};
  for (const key in inputs) {
    if (!inputs.hasOwnProperty(key)) {
      continue;
    }
    const value = inputs[key];
    if (value === void 0) {
      continue;
    }
    let minifiedName;
    if (Array.isArray(value)) {
      minifiedName = value[0];
    } else {
      minifiedName = value;
    }
    res[key] = minifiedName;
  }
  return res;
}
var DOCUMENT = void 0;
function getDocument() {
  if (DOCUMENT !== void 0) {
    return DOCUMENT;
  } else if (typeof document !== "undefined") {
    return document;
  }
  throw new RuntimeError(210, (typeof ngDevMode === "undefined" || ngDevMode) && `The document object is not available in this context. Make sure the DOCUMENT injection token is provided.`);
}
var APP_ID = new InjectionToken(ngDevMode ? "AppId" : "", {
  providedIn: "root",
  factory: () => DEFAULT_APP_ID
});
var DEFAULT_APP_ID = "ng";
var PLATFORM_INITIALIZER = new InjectionToken(ngDevMode ? "Platform Initializer" : "");
var PLATFORM_ID = new InjectionToken(ngDevMode ? "Platform ID" : "", {
  providedIn: "platform",
  factory: () => "unknown"
  // set a default platform name, when none set explicitly
});
var PACKAGE_ROOT_URL = new InjectionToken(ngDevMode ? "Application Packages Root URL" : "");
var ANIMATION_MODULE_TYPE = new InjectionToken(ngDevMode ? "AnimationModuleType" : "");
var CSP_NONCE = new InjectionToken(ngDevMode ? "CSP nonce" : "", {
  providedIn: "root",
  factory: () => {
    return getDocument().body?.querySelector("[ngCspNonce]")?.getAttribute("ngCspNonce") || null;
  }
});
var IMAGE_CONFIG_DEFAULTS = {
  breakpoints: [16, 32, 48, 64, 96, 128, 256, 384, 640, 750, 828, 1080, 1200, 1920, 2048, 3840],
  placeholderResolution: 30,
  disableImageSizeWarning: false,
  disableImageLazyLoadWarning: false
};
var IMAGE_CONFIG = new InjectionToken(ngDevMode ? "ImageConfig" : "", {
  providedIn: "root",
  factory: () => IMAGE_CONFIG_DEFAULTS
});
function makeStateKey(key) {
  return key;
}
function initTransferState() {
  const transferState = new TransferState();
  if (inject(PLATFORM_ID) === "browser") {
    transferState.store = retrieveTransferredState(getDocument(), inject(APP_ID));
  }
  return transferState;
}
var TransferState = class _TransferState {
  constructor() {
    this.store = {};
    this.onSerializeCallbacks = {};
  }
  static {
    this.ɵprov = ɵɵdefineInjectable({
      token: _TransferState,
      providedIn: "root",
      factory: initTransferState
    });
  }
  /**
   * Get the value corresponding to a key. Return `defaultValue` if key is not found.
   */
  get(key, defaultValue) {
    return this.store[key] !== void 0 ? this.store[key] : defaultValue;
  }
  /**
   * Set the value corresponding to a key.
   */
  set(key, value) {
    this.store[key] = value;
  }
  /**
   * Remove a key from the store.
   */
  remove(key) {
    delete this.store[key];
  }
  /**
   * Test whether a key exists in the store.
   */
  hasKey(key) {
    return this.store.hasOwnProperty(key);
  }
  /**
   * Indicates whether the state is empty.
   */
  get isEmpty() {
    return Object.keys(this.store).length === 0;
  }
  /**
   * Register a callback to provide the value for a key when `toJson` is called.
   */
  onSerialize(key, callback) {
    this.onSerializeCallbacks[key] = callback;
  }
  /**
   * Serialize the current state of the store to JSON.
   */
  toJson() {
    for (const key in this.onSerializeCallbacks) {
      if (this.onSerializeCallbacks.hasOwnProperty(key)) {
        try {
          this.store[key] = this.onSerializeCallbacks[key]();
        } catch (e) {
          console.warn("Exception in onSerialize callback: ", e);
        }
      }
    }
    return JSON.stringify(this.store).replace(/</g, "\\u003C");
  }
};
function retrieveTransferredState(doc, appId) {
  const script = doc.getElementById(appId + "-state");
  if (script?.textContent) {
    try {
      return JSON.parse(script.textContent);
    } catch (e) {
      console.warn("Exception while restoring TransferState for app " + appId, e);
    }
  }
  return {};
}
var REFERENCE_NODE_HOST = "h";
var REFERENCE_NODE_BODY = "b";
var NodeNavigationStep;
(function(NodeNavigationStep2) {
  NodeNavigationStep2["FirstChild"] = "f";
  NodeNavigationStep2["NextSibling"] = "n";
})(NodeNavigationStep || (NodeNavigationStep = {}));
var TRANSFER_STATE_TOKEN_ID = "__nghData__";
var NGH_DATA_KEY = makeStateKey(TRANSFER_STATE_TOKEN_ID);
var _retrieveHydrationInfoImpl = () => null;
function retrieveHydrationInfo(rNode, injector, isRootView2 = false) {
  return _retrieveHydrationInfoImpl(rNode, injector, isRootView2);
}
var HydrationStatus;
(function(HydrationStatus2) {
  HydrationStatus2["Hydrated"] = "hydrated";
  HydrationStatus2["Skipped"] = "skipped";
  HydrationStatus2["Mismatched"] = "mismatched";
})(HydrationStatus || (HydrationStatus = {}));
var IS_HYDRATION_DOM_REUSE_ENABLED = new InjectionToken(typeof ngDevMode === "undefined" || !!ngDevMode ? "IS_HYDRATION_DOM_REUSE_ENABLED" : "");
var PRESERVE_HOST_CONTENT_DEFAULT = false;
var PRESERVE_HOST_CONTENT = new InjectionToken(typeof ngDevMode === "undefined" || !!ngDevMode ? "PRESERVE_HOST_CONTENT" : "", {
  providedIn: "root",
  factory: () => PRESERVE_HOST_CONTENT_DEFAULT
});
var IS_I18N_HYDRATION_ENABLED = new InjectionToken(typeof ngDevMode === "undefined" || !!ngDevMode ? "IS_I18N_HYDRATION_ENABLED" : "");
var IS_EVENT_REPLAY_ENABLED = new InjectionToken(typeof ngDevMode === "undefined" || !!ngDevMode ? "IS_EVENT_REPLAY_ENABLED" : "");
var IS_GLOBAL_EVENT_DELEGATION_ENABLED = new InjectionToken(typeof ngDevMode === "undefined" || !!ngDevMode ? "IS_GLOBAL_EVENT_DELEGATION_ENABLED" : "");
var policy$1;
function getPolicy$1() {
  if (policy$1 === void 0) {
    policy$1 = null;
    if (_global.trustedTypes) {
      try {
        policy$1 = _global.trustedTypes.createPolicy("angular", {
          createHTML: (s) => s,
          createScript: (s) => s,
          createScriptURL: (s) => s
        });
      } catch {
      }
    }
  }
  return policy$1;
}
function trustedHTMLFromString(html) {
  return getPolicy$1()?.createHTML(html) || html;
}
function trustedScriptURLFromString(url) {
  return getPolicy$1()?.createScriptURL(url) || url;
}
var policy;
function getPolicy() {
  if (policy === void 0) {
    policy = null;
    if (_global.trustedTypes) {
      try {
        policy = _global.trustedTypes.createPolicy("angular#unsafe-bypass", {
          createHTML: (s) => s,
          createScript: (s) => s,
          createScriptURL: (s) => s
        });
      } catch {
      }
    }
  }
  return policy;
}
function trustedHTMLFromStringBypass(html) {
  return getPolicy()?.createHTML(html) || html;
}
function trustedScriptFromStringBypass(script) {
  return getPolicy()?.createScript(script) || script;
}
function trustedScriptURLFromStringBypass(url) {
  return getPolicy()?.createScriptURL(url) || url;
}
var SafeValueImpl = class {
  constructor(changingThisBreaksApplicationSecurity) {
    this.changingThisBreaksApplicationSecurity = changingThisBreaksApplicationSecurity;
  }
  toString() {
    return `SafeValue must use [property]=binding: ${this.changingThisBreaksApplicationSecurity} (see ${XSS_SECURITY_URL})`;
  }
};
function unwrapSafeValue(value) {
  return value instanceof SafeValueImpl ? value.changingThisBreaksApplicationSecurity : value;
}
function allowSanitizationBypassAndThrow(value, type) {
  const actualType = getSanitizationBypassType(value);
  if (actualType != null && actualType !== type) {
    if (actualType === "ResourceURL" && type === "URL") return true;
    throw new Error(`Required a safe ${type}, got a ${actualType} (see ${XSS_SECURITY_URL})`);
  }
  return actualType === type;
}
function getSanitizationBypassType(value) {
  return value instanceof SafeValueImpl && value.getTypeName() || null;
}
function getInertBodyHelper(defaultDoc) {
  const inertDocumentHelper = new InertDocumentHelper(defaultDoc);
  return isDOMParserAvailable() ? new DOMParserHelper(inertDocumentHelper) : inertDocumentHelper;
}
var DOMParserHelper = class {
  constructor(inertDocumentHelper) {
    this.inertDocumentHelper = inertDocumentHelper;
  }
  getInertBodyElement(html) {
    html = "<body><remove></remove>" + html;
    try {
      const body = new window.DOMParser().parseFromString(trustedHTMLFromString(html), "text/html").body;
      if (body === null) {
        return this.inertDocumentHelper.getInertBodyElement(html);
      }
      body.firstChild?.remove();
      return body;
    } catch {
      return null;
    }
  }
};
var InertDocumentHelper = class {
  constructor(defaultDoc) {
    this.defaultDoc = defaultDoc;
    this.inertDocument = this.defaultDoc.implementation.createHTMLDocument("sanitization-inert");
  }
  getInertBodyElement(html) {
    const templateEl = this.inertDocument.createElement("template");
    templateEl.innerHTML = trustedHTMLFromString(html);
    return templateEl;
  }
};
function isDOMParserAvailable() {
  try {
    return !!new window.DOMParser().parseFromString(trustedHTMLFromString(""), "text/html");
  } catch {
    return false;
  }
}
var SAFE_URL_PATTERN = /^(?!javascript:)(?:[a-z0-9+.-]+:|[^&:\/?#]*(?:[\/?#]|$))/i;
function _sanitizeUrl(url) {
  url = String(url);
  if (url.match(SAFE_URL_PATTERN)) return url;
  if (typeof ngDevMode === "undefined" || ngDevMode) {
    console.warn(`WARNING: sanitizing unsafe URL value ${url} (see ${XSS_SECURITY_URL})`);
  }
  return "unsafe:" + url;
}
function tagSet(tags) {
  const res = {};
  for (const t of tags.split(",")) res[t] = true;
  return res;
}
function merge(...sets) {
  const res = {};
  for (const s of sets) {
    for (const v in s) {
      if (s.hasOwnProperty(v)) res[v] = true;
    }
  }
  return res;
}
var VOID_ELEMENTS = tagSet("area,br,col,hr,img,wbr");
var OPTIONAL_END_TAG_BLOCK_ELEMENTS = tagSet("colgroup,dd,dt,li,p,tbody,td,tfoot,th,thead,tr");
var OPTIONAL_END_TAG_INLINE_ELEMENTS = tagSet("rp,rt");
var OPTIONAL_END_TAG_ELEMENTS = merge(OPTIONAL_END_TAG_INLINE_ELEMENTS, OPTIONAL_END_TAG_BLOCK_ELEMENTS);
var BLOCK_ELEMENTS = merge(OPTIONAL_END_TAG_BLOCK_ELEMENTS, tagSet("address,article,aside,blockquote,caption,center,del,details,dialog,dir,div,dl,figure,figcaption,footer,h1,h2,h3,h4,h5,h6,header,hgroup,hr,ins,main,map,menu,nav,ol,pre,section,summary,table,ul"));
var INLINE_ELEMENTS = merge(OPTIONAL_END_TAG_INLINE_ELEMENTS, tagSet("a,abbr,acronym,audio,b,bdi,bdo,big,br,cite,code,del,dfn,em,font,i,img,ins,kbd,label,map,mark,picture,q,ruby,rp,rt,s,samp,small,source,span,strike,strong,sub,sup,time,track,tt,u,var,video"));
var VALID_ELEMENTS = merge(VOID_ELEMENTS, BLOCK_ELEMENTS, INLINE_ELEMENTS, OPTIONAL_END_TAG_ELEMENTS);
var URI_ATTRS = tagSet("background,cite,href,itemtype,longdesc,poster,src,xlink:href");
var HTML_ATTRS = tagSet("abbr,accesskey,align,alt,autoplay,axis,bgcolor,border,cellpadding,cellspacing,class,clear,color,cols,colspan,compact,controls,coords,datetime,default,dir,download,face,headers,height,hidden,hreflang,hspace,ismap,itemscope,itemprop,kind,label,lang,language,loop,media,muted,nohref,nowrap,open,preload,rel,rev,role,rows,rowspan,rules,scope,scrolling,shape,size,sizes,span,srclang,srcset,start,summary,tabindex,target,title,translate,type,usemap,valign,value,vspace,width");
var ARIA_ATTRS = tagSet("aria-activedescendant,aria-atomic,aria-autocomplete,aria-busy,aria-checked,aria-colcount,aria-colindex,aria-colspan,aria-controls,aria-current,aria-describedby,aria-details,aria-disabled,aria-dropeffect,aria-errormessage,aria-expanded,aria-flowto,aria-grabbed,aria-haspopup,aria-hidden,aria-invalid,aria-keyshortcuts,aria-label,aria-labelledby,aria-level,aria-live,aria-modal,aria-multiline,aria-multiselectable,aria-orientation,aria-owns,aria-placeholder,aria-posinset,aria-pressed,aria-readonly,aria-relevant,aria-required,aria-roledescription,aria-rowcount,aria-rowindex,aria-rowspan,aria-selected,aria-setsize,aria-sort,aria-valuemax,aria-valuemin,aria-valuenow,aria-valuetext");
var VALID_ATTRS = merge(URI_ATTRS, HTML_ATTRS, ARIA_ATTRS);
var SKIP_TRAVERSING_CONTENT_IF_INVALID_ELEMENTS = tagSet("script,style,template");
var SanitizingHtmlSerializer = class {
  constructor() {
    this.sanitizedSomething = false;
    this.buf = [];
  }
  sanitizeChildren(el) {
    let current = el.firstChild;
    let traverseContent = true;
    let parentNodes = [];
    while (current) {
      if (current.nodeType === Node.ELEMENT_NODE) {
        traverseContent = this.startElement(current);
      } else if (current.nodeType === Node.TEXT_NODE) {
        this.chars(current.nodeValue);
      } else {
        this.sanitizedSomething = true;
      }
      if (traverseContent && current.firstChild) {
        parentNodes.push(current);
        current = getFirstChild(current);
        continue;
      }
      while (current) {
        if (current.nodeType === Node.ELEMENT_NODE) {
          this.endElement(current);
        }
        let next = getNextSibling(current);
        if (next) {
          current = next;
          break;
        }
        current = parentNodes.pop();
      }
    }
    return this.buf.join("");
  }
  /**
   * Sanitizes an opening element tag (if valid) and returns whether the element's contents should
   * be traversed. Element content must always be traversed (even if the element itself is not
   * valid/safe), unless the element is one of `SKIP_TRAVERSING_CONTENT_IF_INVALID_ELEMENTS`.
   *
   * @param element The element to sanitize.
   * @return True if the element's contents should be traversed.
   */
  startElement(element) {
    const tagName = getNodeName(element).toLowerCase();
    if (!VALID_ELEMENTS.hasOwnProperty(tagName)) {
      this.sanitizedSomething = true;
      return !SKIP_TRAVERSING_CONTENT_IF_INVALID_ELEMENTS.hasOwnProperty(tagName);
    }
    this.buf.push("<");
    this.buf.push(tagName);
    const elAttrs = element.attributes;
    for (let i = 0; i < elAttrs.length; i++) {
      const elAttr = elAttrs.item(i);
      const attrName = elAttr.name;
      const lower = attrName.toLowerCase();
      if (!VALID_ATTRS.hasOwnProperty(lower)) {
        this.sanitizedSomething = true;
        continue;
      }
      let value = elAttr.value;
      if (URI_ATTRS[lower]) value = _sanitizeUrl(value);
      this.buf.push(" ", attrName, '="', encodeEntities(value), '"');
    }
    this.buf.push(">");
    return true;
  }
  endElement(current) {
    const tagName = getNodeName(current).toLowerCase();
    if (VALID_ELEMENTS.hasOwnProperty(tagName) && !VOID_ELEMENTS.hasOwnProperty(tagName)) {
      this.buf.push("</");
      this.buf.push(tagName);
      this.buf.push(">");
    }
  }
  chars(chars) {
    this.buf.push(encodeEntities(chars));
  }
};
function isClobberedElement(parentNode, childNode) {
  return (parentNode.compareDocumentPosition(childNode) & Node.DOCUMENT_POSITION_CONTAINED_BY) !== Node.DOCUMENT_POSITION_CONTAINED_BY;
}
function getNextSibling(node) {
  const nextSibling = node.nextSibling;
  if (nextSibling && node !== nextSibling.previousSibling) {
    throw clobberedElementError(nextSibling);
  }
  return nextSibling;
}
function getFirstChild(node) {
  const firstChild = node.firstChild;
  if (firstChild && isClobberedElement(node, firstChild)) {
    throw clobberedElementError(firstChild);
  }
  return firstChild;
}
function getNodeName(node) {
  const nodeName = node.nodeName;
  return typeof nodeName === "string" ? nodeName : "FORM";
}
function clobberedElementError(node) {
  return new Error(`Failed to sanitize html because the element is clobbered: ${node.outerHTML}`);
}
var SURROGATE_PAIR_REGEXP = /[\uD800-\uDBFF][\uDC00-\uDFFF]/g;
var NON_ALPHANUMERIC_REGEXP = /([^\#-~ |!])/g;
function encodeEntities(value) {
  return value.replace(/&/g, "&amp;").replace(SURROGATE_PAIR_REGEXP, function(match) {
    const hi = match.charCodeAt(0);
    const low = match.charCodeAt(1);
    return "&#" + ((hi - 55296) * 1024 + (low - 56320) + 65536) + ";";
  }).replace(NON_ALPHANUMERIC_REGEXP, function(match) {
    return "&#" + match.charCodeAt(0) + ";";
  }).replace(/</g, "&lt;").replace(/>/g, "&gt;");
}
var inertBodyHelper;
function _sanitizeHtml(defaultDoc, unsafeHtmlInput) {
  let inertBodyElement = null;
  try {
    inertBodyHelper = inertBodyHelper || getInertBodyHelper(defaultDoc);
    let unsafeHtml = unsafeHtmlInput ? String(unsafeHtmlInput) : "";
    inertBodyElement = inertBodyHelper.getInertBodyElement(unsafeHtml);
    let mXSSAttempts = 5;
    let parsedHtml = unsafeHtml;
    do {
      if (mXSSAttempts === 0) {
        throw new Error("Failed to sanitize html because the input is unstable");
      }
      mXSSAttempts--;
      unsafeHtml = parsedHtml;
      parsedHtml = inertBodyElement.innerHTML;
      inertBodyElement = inertBodyHelper.getInertBodyElement(unsafeHtml);
    } while (unsafeHtml !== parsedHtml);
    const sanitizer = new SanitizingHtmlSerializer();
    const safeHtml = sanitizer.sanitizeChildren(getTemplateContent(inertBodyElement) || inertBodyElement);
    if ((typeof ngDevMode === "undefined" || ngDevMode) && sanitizer.sanitizedSomething) {
      console.warn(`WARNING: sanitizing HTML stripped some content, see ${XSS_SECURITY_URL}`);
    }
    return trustedHTMLFromString(safeHtml);
  } finally {
    if (inertBodyElement) {
      const parent = getTemplateContent(inertBodyElement) || inertBodyElement;
      while (parent.firstChild) {
        parent.firstChild.remove();
      }
    }
  }
}
function getTemplateContent(el) {
  return "content" in el && isTemplateElement(el) ? el.content : null;
}
function isTemplateElement(el) {
  return el.nodeType === Node.ELEMENT_NODE && el.nodeName === "TEMPLATE";
}
var SecurityContext;
(function(SecurityContext2) {
  SecurityContext2[SecurityContext2["NONE"] = 0] = "NONE";
  SecurityContext2[SecurityContext2["HTML"] = 1] = "HTML";
  SecurityContext2[SecurityContext2["STYLE"] = 2] = "STYLE";
  SecurityContext2[SecurityContext2["SCRIPT"] = 3] = "SCRIPT";
  SecurityContext2[SecurityContext2["URL"] = 4] = "URL";
  SecurityContext2[SecurityContext2["RESOURCE_URL"] = 5] = "RESOURCE_URL";
})(SecurityContext || (SecurityContext = {}));
function ɵɵsanitizeHtml(unsafeHtml) {
  const sanitizer = getSanitizer();
  if (sanitizer) {
    return trustedHTMLFromStringBypass(sanitizer.sanitize(SecurityContext.HTML, unsafeHtml) || "");
  }
  if (allowSanitizationBypassAndThrow(
    unsafeHtml,
    "HTML"
    /* BypassType.Html */
  )) {
    return trustedHTMLFromStringBypass(unwrapSafeValue(unsafeHtml));
  }
  return _sanitizeHtml(getDocument(), renderStringify(unsafeHtml));
}
function ɵɵsanitizeStyle(unsafeStyle) {
  const sanitizer = getSanitizer();
  if (sanitizer) {
    return sanitizer.sanitize(SecurityContext.STYLE, unsafeStyle) || "";
  }
  if (allowSanitizationBypassAndThrow(
    unsafeStyle,
    "Style"
    /* BypassType.Style */
  )) {
    return unwrapSafeValue(unsafeStyle);
  }
  return renderStringify(unsafeStyle);
}
function ɵɵsanitizeUrl(unsafeUrl) {
  const sanitizer = getSanitizer();
  if (sanitizer) {
    return sanitizer.sanitize(SecurityContext.URL, unsafeUrl) || "";
  }
  if (allowSanitizationBypassAndThrow(
    unsafeUrl,
    "URL"
    /* BypassType.Url */
  )) {
    return unwrapSafeValue(unsafeUrl);
  }
  return _sanitizeUrl(renderStringify(unsafeUrl));
}
function ɵɵsanitizeResourceUrl(unsafeResourceUrl) {
  const sanitizer = getSanitizer();
  if (sanitizer) {
    return trustedScriptURLFromStringBypass(sanitizer.sanitize(SecurityContext.RESOURCE_URL, unsafeResourceUrl) || "");
  }
  if (allowSanitizationBypassAndThrow(
    unsafeResourceUrl,
    "ResourceURL"
    /* BypassType.ResourceUrl */
  )) {
    return trustedScriptURLFromStringBypass(unwrapSafeValue(unsafeResourceUrl));
  }
  throw new RuntimeError(904, ngDevMode && `unsafe value used in a resource URL context (see ${XSS_SECURITY_URL})`);
}
function ɵɵsanitizeScript(unsafeScript) {
  const sanitizer = getSanitizer();
  if (sanitizer) {
    return trustedScriptFromStringBypass(sanitizer.sanitize(SecurityContext.SCRIPT, unsafeScript) || "");
  }
  if (allowSanitizationBypassAndThrow(
    unsafeScript,
    "Script"
    /* BypassType.Script */
  )) {
    return trustedScriptFromStringBypass(unwrapSafeValue(unsafeScript));
  }
  throw new RuntimeError(905, ngDevMode && "unsafe value used in a script context");
}
function ɵɵtrustConstantHtml(html) {
  if (ngDevMode && (!Array.isArray(html) || !Array.isArray(html.raw) || html.length !== 1)) {
    throw new Error(`Unexpected interpolation in trusted HTML constant: ${html.join("?")}`);
  }
  return trustedHTMLFromString(html[0]);
}
function ɵɵtrustConstantResourceUrl(url) {
  if (ngDevMode && (!Array.isArray(url) || !Array.isArray(url.raw) || url.length !== 1)) {
    throw new Error(`Unexpected interpolation in trusted URL constant: ${url.join("?")}`);
  }
  return trustedScriptURLFromString(url[0]);
}
function getUrlSanitizer(tag, prop) {
  if (prop === "src" && (tag === "embed" || tag === "frame" || tag === "iframe" || tag === "media" || tag === "script") || prop === "href" && (tag === "base" || tag === "link")) {
    return ɵɵsanitizeResourceUrl;
  }
  return ɵɵsanitizeUrl;
}
function ɵɵsanitizeUrlOrResourceUrl(unsafeUrl, tag, prop) {
  return getUrlSanitizer(tag, prop)(unsafeUrl);
}
function validateAgainstEventProperties(name) {
  if (name.toLowerCase().startsWith("on")) {
    const errorMessage = `Binding to event property '${name}' is disallowed for security reasons, please use (${name.slice(2)})=...
If '${name}' is a directive input, make sure the directive is imported by the current module.`;
    throw new RuntimeError(306, errorMessage);
  }
}
function validateAgainstEventAttributes(name) {
  if (name.toLowerCase().startsWith("on")) {
    const errorMessage = `Binding to event attribute '${name}' is disallowed for security reasons, please use (${name.slice(2)})=...`;
    throw new RuntimeError(306, errorMessage);
  }
}
function getSanitizer() {
  const lView = getLView();
  return lView && lView[ENVIRONMENT].sanitizer;
}
var COMMENT_DISALLOWED = /^>|^->|<!--|-->|--!>|<!-$/g;
var COMMENT_DELIMITER = /(<|>)/g;
var COMMENT_DELIMITER_ESCAPED = "​$1​";
function escapeCommentText(value) {
  return value.replace(COMMENT_DISALLOWED, (text) => text.replace(COMMENT_DELIMITER, COMMENT_DELIMITER_ESCAPED));
}
function normalizeDebugBindingName(name) {
  name = camelCaseToDashCase(name.replace(/[$@]/g, "_"));
  return `ng-reflect-${name}`;
}
var CAMEL_CASE_REGEXP = /([A-Z])/g;
function camelCaseToDashCase(input2) {
  return input2.replace(CAMEL_CASE_REGEXP, (...m) => "-" + m[1].toLowerCase());
}
function normalizeDebugBindingValue(value) {
  try {
    return value != null ? value.toString().slice(0, 30) : value;
  } catch (e) {
    return "[ERROR] Exception while trying to serialize the value";
  }
}
var CUSTOM_ELEMENTS_SCHEMA = {
  name: "custom-elements"
};
var NO_ERRORS_SCHEMA = {
  name: "no-errors-schema"
};
var shouldThrowErrorOnUnknownElement = false;
var shouldThrowErrorOnUnknownProperty = false;
function validateElementIsKnown(element, lView, tagName, schemas, hasDirectives) {
  if (schemas === null) return;
  if (!hasDirectives && tagName !== null) {
    const isUnknown = (
      // Note that we can't check for `typeof HTMLUnknownElement === 'function'` because
      // Domino doesn't expose HTMLUnknownElement globally.
      typeof HTMLUnknownElement !== "undefined" && HTMLUnknownElement && element instanceof HTMLUnknownElement || typeof customElements !== "undefined" && tagName.indexOf("-") > -1 && !customElements.get(tagName)
    );
    if (isUnknown && !matchingSchemas(schemas, tagName)) {
      const isHostStandalone = isHostComponentStandalone(lView);
      const templateLocation = getTemplateLocationDetails(lView);
      const schemas2 = `'${isHostStandalone ? "@Component" : "@NgModule"}.schemas'`;
      let message = `'${tagName}' is not a known element${templateLocation}:
`;
      message += `1. If '${tagName}' is an Angular component, then verify that it is ${isHostStandalone ? "included in the '@Component.imports' of this component" : "a part of an @NgModule where this component is declared"}.
`;
      if (tagName && tagName.indexOf("-") > -1) {
        message += `2. If '${tagName}' is a Web Component then add 'CUSTOM_ELEMENTS_SCHEMA' to the ${schemas2} of this component to suppress this message.`;
      } else {
        message += `2. To allow any element add 'NO_ERRORS_SCHEMA' to the ${schemas2} of this component.`;
      }
      if (shouldThrowErrorOnUnknownElement) {
        throw new RuntimeError(304, message);
      } else {
        console.error(formatRuntimeError(304, message));
      }
    }
  }
}
function isPropertyValid(element, propName, tagName, schemas) {
  if (schemas === null) return true;
  if (matchingSchemas(schemas, tagName) || propName in element || isAnimationProp(propName)) {
    return true;
  }
  return typeof Node === "undefined" || Node === null || !(element instanceof Node);
}
function handleUnknownPropertyError(propName, tagName, nodeType, lView) {
  if (!tagName && nodeType === 4) {
    tagName = "ng-template";
  }
  const isHostStandalone = isHostComponentStandalone(lView);
  const templateLocation = getTemplateLocationDetails(lView);
  let message = `Can't bind to '${propName}' since it isn't a known property of '${tagName}'${templateLocation}.`;
  const schemas = `'${isHostStandalone ? "@Component" : "@NgModule"}.schemas'`;
  const importLocation = isHostStandalone ? "included in the '@Component.imports' of this component" : "a part of an @NgModule where this component is declared";
  if (KNOWN_CONTROL_FLOW_DIRECTIVES.has(propName)) {
    const correspondingImport = KNOWN_CONTROL_FLOW_DIRECTIVES.get(propName);
    message += `
If the '${propName}' is an Angular control flow directive, please make sure that either the '${correspondingImport}' directive or the 'CommonModule' is ${importLocation}.`;
  } else {
    message += `
1. If '${tagName}' is an Angular component and it has the '${propName}' input, then verify that it is ${importLocation}.`;
    if (tagName && tagName.indexOf("-") > -1) {
      message += `
2. If '${tagName}' is a Web Component then add 'CUSTOM_ELEMENTS_SCHEMA' to the ${schemas} of this component to suppress this message.`;
      message += `
3. To allow any property add 'NO_ERRORS_SCHEMA' to the ${schemas} of this component.`;
    } else {
      message += `
2. To allow any property add 'NO_ERRORS_SCHEMA' to the ${schemas} of this component.`;
    }
  }
  reportUnknownPropertyError(message);
}
function reportUnknownPropertyError(message) {
  if (shouldThrowErrorOnUnknownProperty) {
    throw new RuntimeError(303, message);
  } else {
    console.error(formatRuntimeError(303, message));
  }
}
function getDeclarationComponentDef(lView) {
  !ngDevMode && throwError("Must never be called in production mode");
  const declarationLView = lView[DECLARATION_COMPONENT_VIEW];
  const context = declarationLView[CONTEXT];
  if (!context) return null;
  return context.constructor ? getComponentDef(context.constructor) : null;
}
function isHostComponentStandalone(lView) {
  !ngDevMode && throwError("Must never be called in production mode");
  const componentDef = getDeclarationComponentDef(lView);
  return !!componentDef?.standalone;
}
function getTemplateLocationDetails(lView) {
  !ngDevMode && throwError("Must never be called in production mode");
  const hostComponentDef = getDeclarationComponentDef(lView);
  const componentClassName = hostComponentDef?.type?.name;
  return componentClassName ? ` (used in the '${componentClassName}' component template)` : "";
}
var KNOWN_CONTROL_FLOW_DIRECTIVES = /* @__PURE__ */ new Map([["ngIf", "NgIf"], ["ngFor", "NgFor"], ["ngSwitchCase", "NgSwitchCase"], ["ngSwitchDefault", "NgSwitchDefault"]]);
function matchingSchemas(schemas, tagName) {
  if (schemas !== null) {
    for (let i = 0; i < schemas.length; i++) {
      const schema = schemas[i];
      if (schema === NO_ERRORS_SCHEMA || schema === CUSTOM_ELEMENTS_SCHEMA && tagName && tagName.indexOf("-") > -1) {
        return true;
      }
    }
  }
  return false;
}
function ɵɵresolveWindow(element) {
  return element.ownerDocument.defaultView;
}
function ɵɵresolveDocument(element) {
  return element.ownerDocument;
}
function ɵɵresolveBody(element) {
  return element.ownerDocument.body;
}
var INTERPOLATION_DELIMITER = `�`;
function maybeUnwrapFn(value) {
  if (value instanceof Function) {
    return value();
  } else {
    return value;
  }
}
function isPlatformBrowser(injector) {
  return (injector ?? inject(Injector)).get(PLATFORM_ID) === "browser";
}
var VALUE_STRING_LENGTH_LIMIT = 200;
function throwMultipleComponentError(tNode, first2, second) {
  throw new RuntimeError(-300, `Multiple components match node with tagname ${tNode.value}: ${stringifyForError(first2)} and ${stringifyForError(second)}`);
}
function throwErrorIfNoChangesMode(creationMode, oldValue, currValue, propName, lView) {
  const hostComponentDef = getDeclarationComponentDef(lView);
  const componentClassName = hostComponentDef?.type?.name;
  const field = propName ? ` for '${propName}'` : "";
  let msg = `ExpressionChangedAfterItHasBeenCheckedError: Expression has changed after it was checked. Previous value${field}: '${formatValue(oldValue)}'. Current value: '${formatValue(currValue)}'.${componentClassName ? ` Expression location: ${componentClassName} component` : ""}`;
  if (creationMode) {
    msg += ` It seems like the view has been created after its parent and its children have been dirty checked. Has it been created in a change detection hook?`;
  }
  throw new RuntimeError(-100, msg);
}
function formatValue(value) {
  let strValue = String(value);
  try {
    if (Array.isArray(value) || strValue === "[object Object]") {
      strValue = JSON.stringify(value);
    }
  } catch (error) {
  }
  return strValue.length > VALUE_STRING_LENGTH_LIMIT ? strValue.substring(0, VALUE_STRING_LENGTH_LIMIT) + "…" : strValue;
}
function constructDetailsForInterpolation(lView, rootIndex, expressionIndex, meta, changedValue) {
  const [propName, prefix, ...chunks] = meta.split(INTERPOLATION_DELIMITER);
  let oldValue = prefix, newValue = prefix;
  for (let i = 0; i < chunks.length; i++) {
    const slotIdx = rootIndex + i;
    oldValue += `${lView[slotIdx]}${chunks[i]}`;
    newValue += `${slotIdx === expressionIndex ? changedValue : lView[slotIdx]}${chunks[i]}`;
  }
  return {
    propName,
    oldValue,
    newValue
  };
}
function getExpressionChangedErrorDetails(lView, bindingIndex, oldValue, newValue) {
  const tData = lView[TVIEW].data;
  const metadata = tData[bindingIndex];
  if (typeof metadata === "string") {
    if (metadata.indexOf(INTERPOLATION_DELIMITER) > -1) {
      return constructDetailsForInterpolation(lView, bindingIndex, bindingIndex, metadata, newValue);
    }
    return {
      propName: metadata,
      oldValue,
      newValue
    };
  }
  if (metadata === null) {
    let idx = bindingIndex - 1;
    while (typeof tData[idx] !== "string" && tData[idx + 1] === null) {
      idx--;
    }
    const meta = tData[idx];
    if (typeof meta === "string") {
      const matches = meta.match(new RegExp(INTERPOLATION_DELIMITER, "g"));
      if (matches && matches.length - 1 > bindingIndex - idx) {
        return constructDetailsForInterpolation(lView, idx, bindingIndex, meta, newValue);
      }
    }
  }
  return {
    propName: void 0,
    oldValue,
    newValue
  };
}
var RendererStyleFlags2;
(function(RendererStyleFlags22) {
  RendererStyleFlags22[RendererStyleFlags22["Important"] = 1] = "Important";
  RendererStyleFlags22[RendererStyleFlags22["DashCase"] = 2] = "DashCase";
})(RendererStyleFlags2 || (RendererStyleFlags2 = {}));
var _icuContainerIterate;
function icuContainerIterate(tIcuContainerNode, lView) {
  return _icuContainerIterate(tIcuContainerNode, lView);
}
function ensureIcuContainerVisitorLoaded(loader) {
  if (_icuContainerIterate === void 0) {
    _icuContainerIterate = loader();
  }
}
function applyToElementOrContainer(action, renderer, parent, lNodeToHandle, beforeNode) {
  if (lNodeToHandle != null) {
    let lContainer;
    let isComponent2 = false;
    if (isLContainer(lNodeToHandle)) {
      lContainer = lNodeToHandle;
    } else if (isLView(lNodeToHandle)) {
      isComponent2 = true;
      ngDevMode && assertDefined(lNodeToHandle[HOST], "HOST must be defined for a component LView");
      lNodeToHandle = lNodeToHandle[HOST];
    }
    const rNode = unwrapRNode(lNodeToHandle);
    if (action === 0 && parent !== null) {
      if (beforeNode == null) {
        nativeAppendChild(renderer, parent, rNode);
      } else {
        nativeInsertBefore(renderer, parent, rNode, beforeNode || null, true);
      }
    } else if (action === 1 && parent !== null) {
      nativeInsertBefore(renderer, parent, rNode, beforeNode || null, true);
    } else if (action === 2) {
      nativeRemoveNode(renderer, rNode, isComponent2);
    } else if (action === 3) {
      ngDevMode && ngDevMode.rendererDestroyNode++;
      renderer.destroyNode(rNode);
    }
    if (lContainer != null) {
      applyContainer(renderer, action, lContainer, parent, beforeNode);
    }
  }
}
function createTextNode(renderer, value) {
  ngDevMode && ngDevMode.rendererCreateTextNode++;
  ngDevMode && ngDevMode.rendererSetText++;
  return renderer.createText(value);
}
function updateTextNode(renderer, rNode, value) {
  ngDevMode && ngDevMode.rendererSetText++;
  renderer.setValue(rNode, value);
}
function createCommentNode(renderer, value) {
  ngDevMode && ngDevMode.rendererCreateComment++;
  return renderer.createComment(escapeCommentText(value));
}
function createElementNode(renderer, name, namespace) {
  ngDevMode && ngDevMode.rendererCreateElement++;
  return renderer.createElement(name, namespace);
}
function removeViewFromDOM(tView, lView) {
  detachViewFromDOM(tView, lView);
  lView[HOST] = null;
  lView[T_HOST] = null;
}
function addViewToDOM(tView, parentTNode, renderer, lView, parentNativeNode, beforeNode) {
  lView[HOST] = parentNativeNode;
  lView[T_HOST] = parentTNode;
  applyView(tView, lView, renderer, 1, parentNativeNode, beforeNode);
}
function detachViewFromDOM(tView, lView) {
  lView[ENVIRONMENT].changeDetectionScheduler?.notify(
    8
    /* NotificationSource.ViewDetachedFromDOM */
  );
  applyView(tView, lView, lView[RENDERER], 2, null, null);
}
function destroyViewTree(rootView) {
  let lViewOrLContainer = rootView[CHILD_HEAD];
  if (!lViewOrLContainer) {
    return cleanUpView(rootView[TVIEW], rootView);
  }
  while (lViewOrLContainer) {
    let next = null;
    if (isLView(lViewOrLContainer)) {
      next = lViewOrLContainer[CHILD_HEAD];
    } else {
      ngDevMode && assertLContainer(lViewOrLContainer);
      const firstView = lViewOrLContainer[CONTAINER_HEADER_OFFSET];
      if (firstView) next = firstView;
    }
    if (!next) {
      while (lViewOrLContainer && !lViewOrLContainer[NEXT] && lViewOrLContainer !== rootView) {
        if (isLView(lViewOrLContainer)) {
          cleanUpView(lViewOrLContainer[TVIEW], lViewOrLContainer);
        }
        lViewOrLContainer = lViewOrLContainer[PARENT];
      }
      if (lViewOrLContainer === null) lViewOrLContainer = rootView;
      if (isLView(lViewOrLContainer)) {
        cleanUpView(lViewOrLContainer[TVIEW], lViewOrLContainer);
      }
      next = lViewOrLContainer && lViewOrLContainer[NEXT];
    }
    lViewOrLContainer = next;
  }
}
function insertView(tView, lView, lContainer, index) {
  ngDevMode && assertLView(lView);
  ngDevMode && assertLContainer(lContainer);
  const indexInContainer = CONTAINER_HEADER_OFFSET + index;
  const containerLength = lContainer.length;
  if (index > 0) {
    lContainer[indexInContainer - 1][NEXT] = lView;
  }
  if (index < containerLength - CONTAINER_HEADER_OFFSET) {
    lView[NEXT] = lContainer[indexInContainer];
    addToArray(lContainer, CONTAINER_HEADER_OFFSET + index, lView);
  } else {
    lContainer.push(lView);
    lView[NEXT] = null;
  }
  lView[PARENT] = lContainer;
  const declarationLContainer = lView[DECLARATION_LCONTAINER];
  if (declarationLContainer !== null && lContainer !== declarationLContainer) {
    trackMovedView(declarationLContainer, lView);
  }
  const lQueries = lView[QUERIES];
  if (lQueries !== null) {
    lQueries.insertView(tView);
  }
  updateAncestorTraversalFlagsOnAttach(lView);
  lView[FLAGS] |= 128;
}
function trackMovedView(declarationContainer, lView) {
  ngDevMode && assertDefined(lView, "LView required");
  ngDevMode && assertLContainer(declarationContainer);
  const movedViews = declarationContainer[MOVED_VIEWS];
  const parent = lView[PARENT];
  ngDevMode && assertDefined(parent, "missing parent");
  if (isLView(parent)) {
    declarationContainer[FLAGS] |= LContainerFlags.HasTransplantedViews;
  } else {
    const insertedComponentLView = parent[PARENT][DECLARATION_COMPONENT_VIEW];
    ngDevMode && assertDefined(insertedComponentLView, "Missing insertedComponentLView");
    const declaredComponentLView = lView[DECLARATION_COMPONENT_VIEW];
    ngDevMode && assertDefined(declaredComponentLView, "Missing declaredComponentLView");
    if (declaredComponentLView !== insertedComponentLView) {
      declarationContainer[FLAGS] |= LContainerFlags.HasTransplantedViews;
    }
  }
  if (movedViews === null) {
    declarationContainer[MOVED_VIEWS] = [lView];
  } else {
    movedViews.push(lView);
  }
}
function detachMovedView(declarationContainer, lView) {
  ngDevMode && assertLContainer(declarationContainer);
  ngDevMode && assertDefined(declarationContainer[MOVED_VIEWS], "A projected view should belong to a non-empty projected views collection");
  const movedViews = declarationContainer[MOVED_VIEWS];
  const declarationViewIndex = movedViews.indexOf(lView);
  movedViews.splice(declarationViewIndex, 1);
}
function detachView(lContainer, removeIndex) {
  if (lContainer.length <= CONTAINER_HEADER_OFFSET) return;
  const indexInContainer = CONTAINER_HEADER_OFFSET + removeIndex;
  const viewToDetach = lContainer[indexInContainer];
  if (viewToDetach) {
    const declarationLContainer = viewToDetach[DECLARATION_LCONTAINER];
    if (declarationLContainer !== null && declarationLContainer !== lContainer) {
      detachMovedView(declarationLContainer, viewToDetach);
    }
    if (removeIndex > 0) {
      lContainer[indexInContainer - 1][NEXT] = viewToDetach[NEXT];
    }
    const removedLView = removeFromArray(lContainer, CONTAINER_HEADER_OFFSET + removeIndex);
    removeViewFromDOM(viewToDetach[TVIEW], viewToDetach);
    const lQueries = removedLView[QUERIES];
    if (lQueries !== null) {
      lQueries.detachView(removedLView[TVIEW]);
    }
    viewToDetach[PARENT] = null;
    viewToDetach[NEXT] = null;
    viewToDetach[FLAGS] &= ~128;
  }
  return viewToDetach;
}
function destroyLView(tView, lView) {
  if (!(lView[FLAGS] & 256)) {
    const renderer = lView[RENDERER];
    if (renderer.destroyNode) {
      applyView(tView, lView, renderer, 3, null, null);
    }
    destroyViewTree(lView);
  }
}
function cleanUpView(tView, lView) {
  if (lView[FLAGS] & 256) {
    return;
  }
  const prevConsumer = setActiveConsumer(null);
  try {
    lView[FLAGS] &= ~128;
    lView[FLAGS] |= 256;
    lView[REACTIVE_TEMPLATE_CONSUMER] && consumerDestroy(lView[REACTIVE_TEMPLATE_CONSUMER]);
    executeOnDestroys(tView, lView);
    processCleanups(tView, lView);
    if (lView[TVIEW].type === 1) {
      ngDevMode && ngDevMode.rendererDestroy++;
      lView[RENDERER].destroy();
    }
    const declarationContainer = lView[DECLARATION_LCONTAINER];
    if (declarationContainer !== null && isLContainer(lView[PARENT])) {
      if (declarationContainer !== lView[PARENT]) {
        detachMovedView(declarationContainer, lView);
      }
      const lQueries = lView[QUERIES];
      if (lQueries !== null) {
        lQueries.detachView(tView);
      }
    }
    unregisterLView(lView);
  } finally {
    setActiveConsumer(prevConsumer);
  }
}
function processCleanups(tView, lView) {
  ngDevMode && assertNotReactive(processCleanups.name);
  const tCleanup = tView.cleanup;
  const lCleanup = lView[CLEANUP];
  if (tCleanup !== null) {
    for (let i = 0; i < tCleanup.length - 1; i += 2) {
      if (typeof tCleanup[i] === "string") {
        const targetIdx = tCleanup[i + 3];
        ngDevMode && assertNumber(targetIdx, "cleanup target must be a number");
        if (targetIdx >= 0) {
          lCleanup[targetIdx]();
        } else {
          lCleanup[-targetIdx].unsubscribe();
        }
        i += 2;
      } else {
        const context = lCleanup[tCleanup[i + 1]];
        tCleanup[i].call(context);
      }
    }
  }
  if (lCleanup !== null) {
    lView[CLEANUP] = null;
  }
  const destroyHooks = lView[ON_DESTROY_HOOKS];
  if (destroyHooks !== null) {
    lView[ON_DESTROY_HOOKS] = null;
    for (let i = 0; i < destroyHooks.length; i++) {
      const destroyHooksFn = destroyHooks[i];
      ngDevMode && assertFunction(destroyHooksFn, "Expecting destroy hook to be a function.");
      destroyHooksFn();
    }
  }
}
function executeOnDestroys(tView, lView) {
  ngDevMode && assertNotReactive(executeOnDestroys.name);
  let destroyHooks;
  if (tView != null && (destroyHooks = tView.destroyHooks) != null) {
    for (let i = 0; i < destroyHooks.length; i += 2) {
      const context = lView[destroyHooks[i]];
      if (!(context instanceof NodeInjectorFactory)) {
        const toCall = destroyHooks[i + 1];
        if (Array.isArray(toCall)) {
          for (let j = 0; j < toCall.length; j += 2) {
            const callContext = context[toCall[j]];
            const hook = toCall[j + 1];
            profiler(4, callContext, hook);
            try {
              hook.call(callContext);
            } finally {
              profiler(5, callContext, hook);
            }
          }
        } else {
          profiler(4, context, toCall);
          try {
            toCall.call(context);
          } finally {
            profiler(5, context, toCall);
          }
        }
      }
    }
  }
}
function getParentRElement(tView, tNode, lView) {
  return getClosestRElement(tView, tNode.parent, lView);
}
function getClosestRElement(tView, tNode, lView) {
  let parentTNode = tNode;
  while (parentTNode !== null && parentTNode.type & (8 | 32 | 128)) {
    tNode = parentTNode;
    parentTNode = tNode.parent;
  }
  if (parentTNode === null) {
    return lView[HOST];
  } else {
    ngDevMode && assertTNodeType(
      parentTNode,
      3 | 4
      /* TNodeType.Container */
    );
    const {
      componentOffset
    } = parentTNode;
    if (componentOffset > -1) {
      ngDevMode && assertTNodeForLView(parentTNode, lView);
      const {
        encapsulation
      } = tView.data[parentTNode.directiveStart + componentOffset];
      if (encapsulation === ViewEncapsulation$1.None || encapsulation === ViewEncapsulation$1.Emulated) {
        return null;
      }
    }
    return getNativeByTNode(parentTNode, lView);
  }
}
function nativeInsertBefore(renderer, parent, child, beforeNode, isMove) {
  ngDevMode && ngDevMode.rendererInsertBefore++;
  renderer.insertBefore(parent, child, beforeNode, isMove);
}
function nativeAppendChild(renderer, parent, child) {
  ngDevMode && ngDevMode.rendererAppendChild++;
  ngDevMode && assertDefined(parent, "parent node must be defined");
  renderer.appendChild(parent, child);
}
function nativeAppendOrInsertBefore(renderer, parent, child, beforeNode, isMove) {
  if (beforeNode !== null) {
    nativeInsertBefore(renderer, parent, child, beforeNode, isMove);
  } else {
    nativeAppendChild(renderer, parent, child);
  }
}
function nativeParentNode(renderer, node) {
  return renderer.parentNode(node);
}
function nativeNextSibling(renderer, node) {
  return renderer.nextSibling(node);
}
function getInsertInFrontOfRNode(parentTNode, currentTNode, lView) {
  return _getInsertInFrontOfRNodeWithI18n(parentTNode, currentTNode, lView);
}
function getInsertInFrontOfRNodeWithNoI18n(parentTNode, currentTNode, lView) {
  if (parentTNode.type & (8 | 32)) {
    return getNativeByTNode(parentTNode, lView);
  }
  return null;
}
var _getInsertInFrontOfRNodeWithI18n = getInsertInFrontOfRNodeWithNoI18n;
var _processI18nInsertBefore;
function setI18nHandling(getInsertInFrontOfRNodeWithI18n2, processI18nInsertBefore2) {
  _getInsertInFrontOfRNodeWithI18n = getInsertInFrontOfRNodeWithI18n2;
  _processI18nInsertBefore = processI18nInsertBefore2;
}
function appendChild(tView, lView, childRNode, childTNode) {
  const parentRNode = getParentRElement(tView, childTNode, lView);
  const renderer = lView[RENDERER];
  const parentTNode = childTNode.parent || lView[T_HOST];
  const anchorNode = getInsertInFrontOfRNode(parentTNode, childTNode, lView);
  if (parentRNode != null) {
    if (Array.isArray(childRNode)) {
      for (let i = 0; i < childRNode.length; i++) {
        nativeAppendOrInsertBefore(renderer, parentRNode, childRNode[i], anchorNode, false);
      }
    } else {
      nativeAppendOrInsertBefore(renderer, parentRNode, childRNode, anchorNode, false);
    }
  }
  _processI18nInsertBefore !== void 0 && _processI18nInsertBefore(renderer, childTNode, lView, childRNode, parentRNode);
}
function getFirstNativeNode(lView, tNode) {
  if (tNode !== null) {
    ngDevMode && assertTNodeType(
      tNode,
      3 | 12 | 32 | 16 | 128
      /* TNodeType.LetDeclaration */
    );
    const tNodeType = tNode.type;
    if (tNodeType & 3) {
      return getNativeByTNode(tNode, lView);
    } else if (tNodeType & 4) {
      return getBeforeNodeForView(-1, lView[tNode.index]);
    } else if (tNodeType & 8) {
      const elIcuContainerChild = tNode.child;
      if (elIcuContainerChild !== null) {
        return getFirstNativeNode(lView, elIcuContainerChild);
      } else {
        const rNodeOrLContainer = lView[tNode.index];
        if (isLContainer(rNodeOrLContainer)) {
          return getBeforeNodeForView(-1, rNodeOrLContainer);
        } else {
          return unwrapRNode(rNodeOrLContainer);
        }
      }
    } else if (tNodeType & 128) {
      return getFirstNativeNode(lView, tNode.next);
    } else if (tNodeType & 32) {
      let nextRNode = icuContainerIterate(tNode, lView);
      let rNode = nextRNode();
      return rNode || unwrapRNode(lView[tNode.index]);
    } else {
      const projectionNodes = getProjectionNodes(lView, tNode);
      if (projectionNodes !== null) {
        if (Array.isArray(projectionNodes)) {
          return projectionNodes[0];
        }
        const parentView = getLViewParent(lView[DECLARATION_COMPONENT_VIEW]);
        ngDevMode && assertParentView(parentView);
        return getFirstNativeNode(parentView, projectionNodes);
      } else {
        return getFirstNativeNode(lView, tNode.next);
      }
    }
  }
  return null;
}
function getProjectionNodes(lView, tNode) {
  if (tNode !== null) {
    const componentView = lView[DECLARATION_COMPONENT_VIEW];
    const componentHost = componentView[T_HOST];
    const slotIdx = tNode.projection;
    ngDevMode && assertProjectionSlots(lView);
    return componentHost.projection[slotIdx];
  }
  return null;
}
function getBeforeNodeForView(viewIndexInContainer, lContainer) {
  const nextViewIndex = CONTAINER_HEADER_OFFSET + viewIndexInContainer + 1;
  if (nextViewIndex < lContainer.length) {
    const lView = lContainer[nextViewIndex];
    const firstTNodeOfView = lView[TVIEW].firstChild;
    if (firstTNodeOfView !== null) {
      return getFirstNativeNode(lView, firstTNodeOfView);
    }
  }
  return lContainer[NATIVE];
}
function nativeRemoveNode(renderer, rNode, isHostElement) {
  ngDevMode && ngDevMode.rendererRemoveNode++;
  renderer.removeChild(null, rNode, isHostElement);
}
function applyNodes(renderer, action, tNode, lView, parentRElement, beforeNode, isProjection) {
  while (tNode != null) {
    ngDevMode && assertTNodeForLView(tNode, lView);
    if (tNode.type === 128) {
      tNode = tNode.next;
      continue;
    }
    ngDevMode && assertTNodeType(
      tNode,
      3 | 12 | 16 | 32
      /* TNodeType.Icu */
    );
    const rawSlotValue = lView[tNode.index];
    const tNodeType = tNode.type;
    if (isProjection) {
      if (action === 0) {
        rawSlotValue && attachPatchData(unwrapRNode(rawSlotValue), lView);
        tNode.flags |= 2;
      }
    }
    if ((tNode.flags & 32) !== 32) {
      if (tNodeType & 8) {
        applyNodes(renderer, action, tNode.child, lView, parentRElement, beforeNode, false);
        applyToElementOrContainer(action, renderer, parentRElement, rawSlotValue, beforeNode);
      } else if (tNodeType & 32) {
        const nextRNode = icuContainerIterate(tNode, lView);
        let rNode;
        while (rNode = nextRNode()) {
          applyToElementOrContainer(action, renderer, parentRElement, rNode, beforeNode);
        }
        applyToElementOrContainer(action, renderer, parentRElement, rawSlotValue, beforeNode);
      } else if (tNodeType & 16) {
        applyProjectionRecursive(renderer, action, lView, tNode, parentRElement, beforeNode);
      } else {
        ngDevMode && assertTNodeType(
          tNode,
          3 | 4
          /* TNodeType.Container */
        );
        applyToElementOrContainer(action, renderer, parentRElement, rawSlotValue, beforeNode);
      }
    }
    tNode = isProjection ? tNode.projectionNext : tNode.next;
  }
}
function applyView(tView, lView, renderer, action, parentRElement, beforeNode) {
  applyNodes(renderer, action, tView.firstChild, lView, parentRElement, beforeNode, false);
}
function applyProjection(tView, lView, tProjectionNode) {
  const renderer = lView[RENDERER];
  const parentRNode = getParentRElement(tView, tProjectionNode, lView);
  const parentTNode = tProjectionNode.parent || lView[T_HOST];
  let beforeNode = getInsertInFrontOfRNode(parentTNode, tProjectionNode, lView);
  applyProjectionRecursive(renderer, 0, lView, tProjectionNode, parentRNode, beforeNode);
}
function applyProjectionRecursive(renderer, action, lView, tProjectionNode, parentRElement, beforeNode) {
  const componentLView = lView[DECLARATION_COMPONENT_VIEW];
  const componentNode = componentLView[T_HOST];
  ngDevMode && assertEqual(typeof tProjectionNode.projection, "number", "expecting projection index");
  const nodeToProjectOrRNodes = componentNode.projection[tProjectionNode.projection];
  if (Array.isArray(nodeToProjectOrRNodes)) {
    for (let i = 0; i < nodeToProjectOrRNodes.length; i++) {
      const rNode = nodeToProjectOrRNodes[i];
      applyToElementOrContainer(action, renderer, parentRElement, rNode, beforeNode);
    }
  } else {
    let nodeToProject = nodeToProjectOrRNodes;
    const projectedComponentLView = componentLView[PARENT];
    if (hasInSkipHydrationBlockFlag(tProjectionNode)) {
      nodeToProject.flags |= 128;
    }
    applyNodes(renderer, action, nodeToProject, projectedComponentLView, parentRElement, beforeNode, true);
  }
}
function applyContainer(renderer, action, lContainer, parentRElement, beforeNode) {
  ngDevMode && assertLContainer(lContainer);
  const anchor = lContainer[NATIVE];
  const native = unwrapRNode(lContainer);
  if (anchor !== native) {
    applyToElementOrContainer(action, renderer, parentRElement, anchor, beforeNode);
  }
  for (let i = CONTAINER_HEADER_OFFSET; i < lContainer.length; i++) {
    const lView = lContainer[i];
    applyView(lView[TVIEW], lView, renderer, action, parentRElement, anchor);
  }
}
function applyStyling(renderer, isClassBased, rNode, prop, value) {
  if (isClassBased) {
    if (!value) {
      ngDevMode && ngDevMode.rendererRemoveClass++;
      renderer.removeClass(rNode, prop);
    } else {
      ngDevMode && ngDevMode.rendererAddClass++;
      renderer.addClass(rNode, prop);
    }
  } else {
    let flags = prop.indexOf("-") === -1 ? void 0 : RendererStyleFlags2.DashCase;
    if (value == null) {
      ngDevMode && ngDevMode.rendererRemoveStyle++;
      renderer.removeStyle(rNode, prop, flags);
    } else {
      const isImportant = typeof value === "string" ? value.endsWith("!important") : false;
      if (isImportant) {
        value = value.slice(0, -10);
        flags |= RendererStyleFlags2.Important;
      }
      ngDevMode && ngDevMode.rendererSetStyle++;
      renderer.setStyle(rNode, prop, value, flags);
    }
  }
}
function writeDirectStyle(renderer, element, newValue) {
  ngDevMode && assertString(newValue, "'newValue' should be a string");
  renderer.setAttribute(element, "style", newValue);
  ngDevMode && ngDevMode.rendererSetStyle++;
}
function writeDirectClass(renderer, element, newValue) {
  ngDevMode && assertString(newValue, "'newValue' should be a string");
  if (newValue === "") {
    renderer.removeAttribute(element, "class");
  } else {
    renderer.setAttribute(element, "class", newValue);
  }
  ngDevMode && ngDevMode.rendererSetClassName++;
}
function setupStaticAttributes(renderer, element, tNode) {
  const {
    mergedAttrs,
    classes,
    styles
  } = tNode;
  if (mergedAttrs !== null) {
    setUpAttributes(renderer, element, mergedAttrs);
  }
  if (classes !== null) {
    writeDirectClass(renderer, element, classes);
  }
  if (styles !== null) {
    writeDirectStyle(renderer, element, styles);
  }
}
var NO_CHANGE = typeof ngDevMode === "undefined" || ngDevMode ? {
  __brand__: "NO_CHANGE"
} : {};
function ɵɵadvance(delta = 1) {
  ngDevMode && assertGreaterThan(delta, 0, "Can only advance forward");
  selectIndexInternal(getTView(), getLView(), getSelectedIndex() + delta, !!ngDevMode && isInCheckNoChangesMode());
}
function selectIndexInternal(tView, lView, index, checkNoChangesMode) {
  ngDevMode && assertIndexInDeclRange(lView[TVIEW], index);
  if (!checkNoChangesMode) {
    const hooksInitPhaseCompleted = (lView[FLAGS] & 3) === 3;
    if (hooksInitPhaseCompleted) {
      const preOrderCheckHooks = tView.preOrderCheckHooks;
      if (preOrderCheckHooks !== null) {
        executeCheckHooks(lView, preOrderCheckHooks, index);
      }
    } else {
      const preOrderHooks = tView.preOrderHooks;
      if (preOrderHooks !== null) {
        executeInitAndCheckHooks(lView, preOrderHooks, 0, index);
      }
    }
  }
  setSelectedIndex(index);
}
function ɵɵdirectiveInject(token, flags = InjectFlags.Default) {
  const lView = getLView();
  if (lView === null) {
    ngDevMode && assertInjectImplementationNotEqual(ɵɵdirectiveInject);
    return ɵɵinject(token, flags);
  }
  const tNode = getCurrentTNode();
  const value = getOrCreateInjectable(tNode, lView, resolveForwardRef(token), flags);
  ngDevMode && emitInjectEvent(token, value, flags);
  return value;
}
function ɵɵinvalidFactory() {
  const msg = ngDevMode ? `This constructor was not compatible with Dependency Injection.` : "invalid";
  throw new Error(msg);
}
function writeToDirectiveInput(def, instance, publicName, privateName, flags, value) {
  const prevConsumer = setActiveConsumer(null);
  try {
    let inputSignalNode = null;
    if ((flags & InputFlags.SignalBased) !== 0) {
      const field = instance[privateName];
      inputSignalNode = field[SIGNAL];
    }
    if (inputSignalNode !== null && inputSignalNode.transformFn !== void 0) {
      value = inputSignalNode.transformFn(value);
    }
    if ((flags & InputFlags.HasDecoratorInputTransform) !== 0) {
      value = def.inputTransforms[privateName].call(instance, value);
    }
    if (def.setInput !== null) {
      def.setInput(instance, inputSignalNode, value, publicName, privateName);
    } else {
      applyValueToInputField(instance, inputSignalNode, privateName, value);
    }
  } finally {
    setActiveConsumer(prevConsumer);
  }
}
function processHostBindingOpCodes(tView, lView) {
  const hostBindingOpCodes = tView.hostBindingOpCodes;
  if (hostBindingOpCodes === null) return;
  try {
    for (let i = 0; i < hostBindingOpCodes.length; i++) {
      const opCode = hostBindingOpCodes[i];
      if (opCode < 0) {
        setSelectedIndex(~opCode);
      } else {
        const directiveIdx = opCode;
        const bindingRootIndx = hostBindingOpCodes[++i];
        const hostBindingFn = hostBindingOpCodes[++i];
        setBindingRootForHostBindings(bindingRootIndx, directiveIdx);
        const context = lView[directiveIdx];
        hostBindingFn(2, context);
      }
    }
  } finally {
    setSelectedIndex(-1);
  }
}
function createLView(parentLView, tView, context, flags, host, tHostNode, environment, renderer, injector, embeddedViewInjector, hydrationInfo) {
  const lView = tView.blueprint.slice();
  lView[HOST] = host;
  lView[FLAGS] = flags | 4 | 128 | 8 | 64;
  if (embeddedViewInjector !== null || parentLView && parentLView[FLAGS] & 2048) {
    lView[FLAGS] |= 2048;
  }
  resetPreOrderHookFlags(lView);
  ngDevMode && tView.declTNode && parentLView && assertTNodeForLView(tView.declTNode, parentLView);
  lView[PARENT] = lView[DECLARATION_VIEW] = parentLView;
  lView[CONTEXT] = context;
  lView[ENVIRONMENT] = environment || parentLView && parentLView[ENVIRONMENT];
  ngDevMode && assertDefined(lView[ENVIRONMENT], "LViewEnvironment is required");
  lView[RENDERER] = renderer || parentLView && parentLView[RENDERER];
  ngDevMode && assertDefined(lView[RENDERER], "Renderer is required");
  lView[INJECTOR] = injector || parentLView && parentLView[INJECTOR] || null;
  lView[T_HOST] = tHostNode;
  lView[ID] = getUniqueLViewId();
  lView[HYDRATION] = hydrationInfo;
  lView[EMBEDDED_VIEW_INJECTOR] = embeddedViewInjector;
  ngDevMode && assertEqual(tView.type == 2 ? parentLView !== null : true, true, "Embedded views must have parentLView");
  lView[DECLARATION_COMPONENT_VIEW] = tView.type == 2 ? parentLView[DECLARATION_COMPONENT_VIEW] : lView;
  return lView;
}
function getOrCreateTNode(tView, index, type, name, attrs) {
  ngDevMode && index !== 0 && // 0 are bogus nodes and they are OK. See `createContainerRef` in
  // `view_engine_compatibility` for additional context.
  assertGreaterThanOrEqual(index, HEADER_OFFSET, "TNodes can't be in the LView header.");
  ngDevMode && assertPureTNodeType(type);
  let tNode = tView.data[index];
  if (tNode === null) {
    tNode = createTNodeAtIndex(tView, index, type, name, attrs);
    if (isInI18nBlock()) {
      tNode.flags |= 32;
    }
  } else if (tNode.type & 64) {
    tNode.type = type;
    tNode.value = name;
    tNode.attrs = attrs;
    const parent = getCurrentParentTNode();
    tNode.injectorIndex = parent === null ? -1 : parent.injectorIndex;
    ngDevMode && assertTNodeForTView(tNode, tView);
    ngDevMode && assertEqual(index, tNode.index, "Expecting same index");
  }
  setCurrentTNode(tNode, true);
  return tNode;
}
function createTNodeAtIndex(tView, index, type, name, attrs) {
  const currentTNode = getCurrentTNodePlaceholderOk();
  const isParent = isCurrentTNodeParent();
  const parent = isParent ? currentTNode : currentTNode && currentTNode.parent;
  const tNode = tView.data[index] = createTNode(tView, parent, type, index, name, attrs);
  if (tView.firstChild === null) {
    tView.firstChild = tNode;
  }
  if (currentTNode !== null) {
    if (isParent) {
      if (currentTNode.child == null && tNode.parent !== null) {
        currentTNode.child = tNode;
      }
    } else {
      if (currentTNode.next === null) {
        currentTNode.next = tNode;
        tNode.prev = currentTNode;
      }
    }
  }
  return tNode;
}
function allocExpando(tView, lView, numSlotsToAlloc, initialValue) {
  if (numSlotsToAlloc === 0) return -1;
  if (ngDevMode) {
    assertFirstCreatePass(tView);
    assertSame(tView, lView[TVIEW], "`LView` must be associated with `TView`!");
    assertEqual(tView.data.length, lView.length, "Expecting LView to be same size as TView");
    assertEqual(tView.data.length, tView.blueprint.length, "Expecting Blueprint to be same size as TView");
    assertFirstUpdatePass(tView);
  }
  const allocIdx = lView.length;
  for (let i = 0; i < numSlotsToAlloc; i++) {
    lView.push(initialValue);
    tView.blueprint.push(initialValue);
    tView.data.push(null);
  }
  return allocIdx;
}
function executeTemplate(tView, lView, templateFn, rf, context) {
  const prevSelectedIndex = getSelectedIndex();
  const isUpdatePhase = rf & 2;
  try {
    setSelectedIndex(-1);
    if (isUpdatePhase && lView.length > HEADER_OFFSET) {
      selectIndexInternal(tView, lView, HEADER_OFFSET, !!ngDevMode && isInCheckNoChangesMode());
    }
    const preHookType = isUpdatePhase ? 2 : 0;
    profiler(preHookType, context);
    templateFn(rf, context);
  } finally {
    setSelectedIndex(prevSelectedIndex);
    const postHookType = isUpdatePhase ? 3 : 1;
    profiler(postHookType, context);
  }
}
function executeContentQueries(tView, tNode, lView) {
  if (isContentQueryHost(tNode)) {
    const prevConsumer = setActiveConsumer(null);
    try {
      const start = tNode.directiveStart;
      const end = tNode.directiveEnd;
      for (let directiveIndex = start; directiveIndex < end; directiveIndex++) {
        const def = tView.data[directiveIndex];
        if (def.contentQueries) {
          const directiveInstance = lView[directiveIndex];
          ngDevMode && assertDefined(directiveIndex, "Incorrect reference to a directive defining a content query");
          def.contentQueries(1, directiveInstance, directiveIndex);
        }
      }
    } finally {
      setActiveConsumer(prevConsumer);
    }
  }
}
function createDirectivesInstances(tView, lView, tNode) {
  if (!getBindingsEnabled()) return;
  instantiateAllDirectives(tView, lView, tNode, getNativeByTNode(tNode, lView));
  if ((tNode.flags & 64) === 64) {
    invokeDirectivesHostBindings(tView, lView, tNode);
  }
}
function saveResolvedLocalsInData(viewData, tNode, localRefExtractor = getNativeByTNode) {
  const localNames = tNode.localNames;
  if (localNames !== null) {
    let localIndex = tNode.index + 1;
    for (let i = 0; i < localNames.length; i += 2) {
      const index = localNames[i + 1];
      const value = index === -1 ? localRefExtractor(tNode, viewData) : viewData[index];
      viewData[localIndex++] = value;
    }
  }
}
function getOrCreateComponentTView(def) {
  const tView = def.tView;
  if (tView === null || tView.incompleteFirstPass) {
    const declTNode = null;
    return def.tView = createTView(1, declTNode, def.template, def.decls, def.vars, def.directiveDefs, def.pipeDefs, def.viewQuery, def.schemas, def.consts, def.id);
  }
  return tView;
}
function createTView(type, declTNode, templateFn, decls, vars, directives, pipes, viewQuery, schemas, constsOrFactory, ssrId) {
  ngDevMode && ngDevMode.tView++;
  const bindingStartIndex = HEADER_OFFSET + decls;
  const initialViewLength = bindingStartIndex + vars;
  const blueprint = createViewBlueprint(bindingStartIndex, initialViewLength);
  const consts = typeof constsOrFactory === "function" ? constsOrFactory() : constsOrFactory;
  const tView = blueprint[TVIEW] = {
    type,
    blueprint,
    template: templateFn,
    queries: null,
    viewQuery,
    declTNode,
    data: blueprint.slice().fill(null, bindingStartIndex),
    bindingStartIndex,
    expandoStartIndex: initialViewLength,
    hostBindingOpCodes: null,
    firstCreatePass: true,
    firstUpdatePass: true,
    staticViewQueries: false,
    staticContentQueries: false,
    preOrderHooks: null,
    preOrderCheckHooks: null,
    contentHooks: null,
    contentCheckHooks: null,
    viewHooks: null,
    viewCheckHooks: null,
    destroyHooks: null,
    cleanup: null,
    contentQueries: null,
    components: null,
    directiveRegistry: typeof directives === "function" ? directives() : directives,
    pipeRegistry: typeof pipes === "function" ? pipes() : pipes,
    firstChild: null,
    schemas,
    consts,
    incompleteFirstPass: false,
    ssrId
  };
  if (ngDevMode) {
    Object.seal(tView);
  }
  return tView;
}
function createViewBlueprint(bindingStartIndex, initialViewLength) {
  const blueprint = [];
  for (let i = 0; i < initialViewLength; i++) {
    blueprint.push(i < bindingStartIndex ? null : NO_CHANGE);
  }
  return blueprint;
}
function locateHostElement(renderer, elementOrSelector, encapsulation, injector) {
  const preserveHostContent = injector.get(PRESERVE_HOST_CONTENT, PRESERVE_HOST_CONTENT_DEFAULT);
  const preserveContent = preserveHostContent || encapsulation === ViewEncapsulation$1.ShadowDom;
  const rootElement = renderer.selectRootElement(elementOrSelector, preserveContent);
  applyRootElementTransform(rootElement);
  return rootElement;
}
function applyRootElementTransform(rootElement) {
  _applyRootElementTransformImpl(rootElement);
}
var _applyRootElementTransformImpl = () => null;
function storeCleanupWithContext(tView, lView, context, cleanupFn) {
  const lCleanup = getOrCreateLViewCleanup(lView);
  ngDevMode && assertDefined(context, "Cleanup context is mandatory when registering framework-level destroy hooks");
  lCleanup.push(context);
  if (tView.firstCreatePass) {
    getOrCreateTViewCleanup(tView).push(cleanupFn, lCleanup.length - 1);
  } else {
    if (ngDevMode) {
      Object.freeze(getOrCreateTViewCleanup(tView));
    }
  }
}
function createTNode(tView, tParent, type, index, value, attrs) {
  ngDevMode && index !== 0 && // 0 are bogus nodes and they are OK. See `createContainerRef` in
  // `view_engine_compatibility` for additional context.
  assertGreaterThanOrEqual(index, HEADER_OFFSET, "TNodes can't be in the LView header.");
  ngDevMode && assertNotSame(attrs, void 0, "'undefined' is not valid value for 'attrs'");
  ngDevMode && ngDevMode.tNode++;
  ngDevMode && tParent && assertTNodeForTView(tParent, tView);
  let injectorIndex = tParent ? tParent.injectorIndex : -1;
  let flags = 0;
  if (isInSkipHydrationBlock$1()) {
    flags |= 128;
  }
  const tNode = {
    type,
    index,
    insertBeforeIndex: null,
    injectorIndex,
    directiveStart: -1,
    directiveEnd: -1,
    directiveStylingLast: -1,
    componentOffset: -1,
    propertyBindings: null,
    flags,
    providerIndexes: 0,
    value,
    attrs,
    mergedAttrs: null,
    localNames: null,
    initialInputs: void 0,
    inputs: null,
    outputs: null,
    tView: null,
    next: null,
    prev: null,
    projectionNext: null,
    child: null,
    parent: tParent,
    projection: null,
    styles: null,
    stylesWithoutHost: null,
    residualStyles: void 0,
    classes: null,
    classesWithoutHost: null,
    residualClasses: void 0,
    classBindings: 0,
    styleBindings: 0
  };
  if (ngDevMode) {
    Object.seal(tNode);
  }
  return tNode;
}
function captureNodeBindings(mode, aliasMap, directiveIndex, bindingsResult, hostDirectiveAliasMap) {
  for (let publicName in aliasMap) {
    if (!aliasMap.hasOwnProperty(publicName)) {
      continue;
    }
    const value = aliasMap[publicName];
    if (value === void 0) {
      continue;
    }
    bindingsResult ??= {};
    let internalName;
    let inputFlags = InputFlags.None;
    if (Array.isArray(value)) {
      internalName = value[0];
      inputFlags = value[1];
    } else {
      internalName = value;
    }
    let finalPublicName = publicName;
    if (hostDirectiveAliasMap !== null) {
      if (!hostDirectiveAliasMap.hasOwnProperty(publicName)) {
        continue;
      }
      finalPublicName = hostDirectiveAliasMap[publicName];
    }
    if (mode === 0) {
      addPropertyBinding(bindingsResult, directiveIndex, finalPublicName, internalName, inputFlags);
    } else {
      addPropertyBinding(bindingsResult, directiveIndex, finalPublicName, internalName);
    }
  }
  return bindingsResult;
}
function addPropertyBinding(bindings, directiveIndex, publicName, internalName, inputFlags) {
  let values;
  if (bindings.hasOwnProperty(publicName)) {
    (values = bindings[publicName]).push(directiveIndex, internalName);
  } else {
    values = bindings[publicName] = [directiveIndex, internalName];
  }
  if (inputFlags !== void 0) {
    values.push(inputFlags);
  }
}
function initializeInputAndOutputAliases(tView, tNode, hostDirectiveDefinitionMap) {
  ngDevMode && assertFirstCreatePass(tView);
  const start = tNode.directiveStart;
  const end = tNode.directiveEnd;
  const tViewData = tView.data;
  const tNodeAttrs = tNode.attrs;
  const inputsFromAttrs = [];
  let inputsStore = null;
  let outputsStore = null;
  for (let directiveIndex = start; directiveIndex < end; directiveIndex++) {
    const directiveDef = tViewData[directiveIndex];
    const aliasData = hostDirectiveDefinitionMap ? hostDirectiveDefinitionMap.get(directiveDef) : null;
    const aliasedInputs = aliasData ? aliasData.inputs : null;
    const aliasedOutputs = aliasData ? aliasData.outputs : null;
    inputsStore = captureNodeBindings(0, directiveDef.inputs, directiveIndex, inputsStore, aliasedInputs);
    outputsStore = captureNodeBindings(1, directiveDef.outputs, directiveIndex, outputsStore, aliasedOutputs);
    const initialInputs = inputsStore !== null && tNodeAttrs !== null && !isInlineTemplate(tNode) ? generateInitialInputs(inputsStore, directiveIndex, tNodeAttrs) : null;
    inputsFromAttrs.push(initialInputs);
  }
  if (inputsStore !== null) {
    if (inputsStore.hasOwnProperty("class")) {
      tNode.flags |= 8;
    }
    if (inputsStore.hasOwnProperty("style")) {
      tNode.flags |= 16;
    }
  }
  tNode.initialInputs = inputsFromAttrs;
  tNode.inputs = inputsStore;
  tNode.outputs = outputsStore;
}
function mapPropName(name) {
  if (name === "class") return "className";
  if (name === "for") return "htmlFor";
  if (name === "formaction") return "formAction";
  if (name === "innerHtml") return "innerHTML";
  if (name === "readonly") return "readOnly";
  if (name === "tabindex") return "tabIndex";
  return name;
}
function elementPropertyInternal(tView, tNode, lView, propName, value, renderer, sanitizer, nativeOnly) {
  ngDevMode && assertNotSame(value, NO_CHANGE, "Incoming value should never be NO_CHANGE.");
  const element = getNativeByTNode(tNode, lView);
  let inputData = tNode.inputs;
  let dataValue;
  if (!nativeOnly && inputData != null && (dataValue = inputData[propName])) {
    setInputsForProperty(tView, lView, dataValue, propName, value);
    if (isComponentHost(tNode)) markDirtyIfOnPush(lView, tNode.index);
    if (ngDevMode) {
      setNgReflectProperties(lView, element, tNode.type, dataValue, value);
    }
  } else if (tNode.type & 3) {
    propName = mapPropName(propName);
    if (ngDevMode) {
      validateAgainstEventProperties(propName);
      if (!isPropertyValid(element, propName, tNode.value, tView.schemas)) {
        handleUnknownPropertyError(propName, tNode.value, tNode.type, lView);
      }
      ngDevMode.rendererSetProperty++;
    }
    value = sanitizer != null ? sanitizer(value, tNode.value || "", propName) : value;
    renderer.setProperty(element, propName, value);
  } else if (tNode.type & 12) {
    if (ngDevMode && !matchingSchemas(tView.schemas, tNode.value)) {
      handleUnknownPropertyError(propName, tNode.value, tNode.type, lView);
    }
  }
}
function markDirtyIfOnPush(lView, viewIndex) {
  ngDevMode && assertLView(lView);
  const childComponentLView = getComponentLViewByIndex(viewIndex, lView);
  if (!(childComponentLView[FLAGS] & 16)) {
    childComponentLView[FLAGS] |= 64;
  }
}
function setNgReflectProperty(lView, element, type, attrName, value) {
  const renderer = lView[RENDERER];
  attrName = normalizeDebugBindingName(attrName);
  const debugValue = normalizeDebugBindingValue(value);
  if (type & 3) {
    if (value == null) {
      renderer.removeAttribute(element, attrName);
    } else {
      renderer.setAttribute(element, attrName, debugValue);
    }
  } else {
    const textContent = escapeCommentText(`bindings=${JSON.stringify({
      [attrName]: debugValue
    }, null, 2)}`);
    renderer.setValue(element, textContent);
  }
}
function setNgReflectProperties(lView, element, type, dataValue, value) {
  if (type & (3 | 4)) {
    for (let i = 0; i < dataValue.length; i += 3) {
      setNgReflectProperty(lView, element, type, dataValue[i + 1], value);
    }
  }
}
function resolveDirectives(tView, lView, tNode, localRefs) {
  ngDevMode && assertFirstCreatePass(tView);
  if (getBindingsEnabled()) {
    const exportsMap = localRefs === null ? null : {
      "": -1
    };
    const matchResult = findDirectiveDefMatches(tView, tNode);
    let directiveDefs;
    let hostDirectiveDefs;
    if (matchResult === null) {
      directiveDefs = hostDirectiveDefs = null;
    } else {
      [directiveDefs, hostDirectiveDefs] = matchResult;
    }
    if (directiveDefs !== null) {
      initializeDirectives(tView, lView, tNode, directiveDefs, exportsMap, hostDirectiveDefs);
    }
    if (exportsMap) cacheMatchingLocalNames(tNode, localRefs, exportsMap);
  }
  tNode.mergedAttrs = mergeHostAttrs(tNode.mergedAttrs, tNode.attrs);
}
function initializeDirectives(tView, lView, tNode, directives, exportsMap, hostDirectiveDefs) {
  ngDevMode && assertFirstCreatePass(tView);
  for (let i = 0; i < directives.length; i++) {
    diPublicInInjector(getOrCreateNodeInjectorForNode(tNode, lView), tView, directives[i].type);
  }
  initTNodeFlags(tNode, tView.data.length, directives.length);
  for (let i = 0; i < directives.length; i++) {
    const def = directives[i];
    if (def.providersResolver) def.providersResolver(def);
  }
  let preOrderHooksFound = false;
  let preOrderCheckHooksFound = false;
  let directiveIdx = allocExpando(tView, lView, directives.length, null);
  ngDevMode && assertSame(directiveIdx, tNode.directiveStart, "TNode.directiveStart should point to just allocated space");
  for (let i = 0; i < directives.length; i++) {
    const def = directives[i];
    tNode.mergedAttrs = mergeHostAttrs(tNode.mergedAttrs, def.hostAttrs);
    configureViewWithDirective(tView, tNode, lView, directiveIdx, def);
    saveNameToExportMap(directiveIdx, def, exportsMap);
    if (def.contentQueries !== null) tNode.flags |= 4;
    if (def.hostBindings !== null || def.hostAttrs !== null || def.hostVars !== 0) tNode.flags |= 64;
    const lifeCycleHooks = def.type.prototype;
    if (!preOrderHooksFound && (lifeCycleHooks.ngOnChanges || lifeCycleHooks.ngOnInit || lifeCycleHooks.ngDoCheck)) {
      (tView.preOrderHooks ??= []).push(tNode.index);
      preOrderHooksFound = true;
    }
    if (!preOrderCheckHooksFound && (lifeCycleHooks.ngOnChanges || lifeCycleHooks.ngDoCheck)) {
      (tView.preOrderCheckHooks ??= []).push(tNode.index);
      preOrderCheckHooksFound = true;
    }
    directiveIdx++;
  }
  initializeInputAndOutputAliases(tView, tNode, hostDirectiveDefs);
}
function registerHostBindingOpCodes(tView, tNode, directiveIdx, directiveVarsIdx, def) {
  ngDevMode && assertFirstCreatePass(tView);
  const hostBindings = def.hostBindings;
  if (hostBindings) {
    let hostBindingOpCodes = tView.hostBindingOpCodes;
    if (hostBindingOpCodes === null) {
      hostBindingOpCodes = tView.hostBindingOpCodes = [];
    }
    const elementIndx = ~tNode.index;
    if (lastSelectedElementIdx(hostBindingOpCodes) != elementIndx) {
      hostBindingOpCodes.push(elementIndx);
    }
    hostBindingOpCodes.push(directiveIdx, directiveVarsIdx, hostBindings);
  }
}
function lastSelectedElementIdx(hostBindingOpCodes) {
  let i = hostBindingOpCodes.length;
  while (i > 0) {
    const value = hostBindingOpCodes[--i];
    if (typeof value === "number" && value < 0) {
      return value;
    }
  }
  return 0;
}
function instantiateAllDirectives(tView, lView, tNode, native) {
  const start = tNode.directiveStart;
  const end = tNode.directiveEnd;
  if (isComponentHost(tNode)) {
    ngDevMode && assertTNodeType(
      tNode,
      3
      /* TNodeType.AnyRNode */
    );
    addComponentLogic(lView, tNode, tView.data[start + tNode.componentOffset]);
  }
  if (!tView.firstCreatePass) {
    getOrCreateNodeInjectorForNode(tNode, lView);
  }
  attachPatchData(native, lView);
  const initialInputs = tNode.initialInputs;
  for (let i = start; i < end; i++) {
    const def = tView.data[i];
    const directive = getNodeInjectable(lView, tView, i, tNode);
    attachPatchData(directive, lView);
    if (initialInputs !== null) {
      setInputsFromAttrs(lView, i - start, directive, def, tNode, initialInputs);
    }
    if (isComponentDef(def)) {
      const componentView = getComponentLViewByIndex(tNode.index, lView);
      componentView[CONTEXT] = getNodeInjectable(lView, tView, i, tNode);
    }
  }
}
function invokeDirectivesHostBindings(tView, lView, tNode) {
  const start = tNode.directiveStart;
  const end = tNode.directiveEnd;
  const elementIndex = tNode.index;
  const currentDirectiveIndex = getCurrentDirectiveIndex();
  try {
    setSelectedIndex(elementIndex);
    for (let dirIndex = start; dirIndex < end; dirIndex++) {
      const def = tView.data[dirIndex];
      const directive = lView[dirIndex];
      setCurrentDirectiveIndex(dirIndex);
      if (def.hostBindings !== null || def.hostVars !== 0 || def.hostAttrs !== null) {
        invokeHostBindingsInCreationMode(def, directive);
      }
    }
  } finally {
    setSelectedIndex(-1);
    setCurrentDirectiveIndex(currentDirectiveIndex);
  }
}
function invokeHostBindingsInCreationMode(def, directive) {
  if (def.hostBindings !== null) {
    def.hostBindings(1, directive);
  }
}
function findDirectiveDefMatches(tView, tNode) {
  ngDevMode && assertFirstCreatePass(tView);
  ngDevMode && assertTNodeType(
    tNode,
    3 | 12
    /* TNodeType.AnyContainer */
  );
  const registry = tView.directiveRegistry;
  let matches = null;
  let hostDirectiveDefs = null;
  if (registry) {
    for (let i = 0; i < registry.length; i++) {
      const def = registry[i];
      if (isNodeMatchingSelectorList(
        tNode,
        def.selectors,
        /* isProjectionMode */
        false
      )) {
        matches || (matches = []);
        if (isComponentDef(def)) {
          if (ngDevMode) {
            assertTNodeType(tNode, 2, `"${tNode.value}" tags cannot be used as component hosts. Please use a different tag to activate the ${stringify(def.type)} component.`);
            if (isComponentHost(tNode)) {
              throwMultipleComponentError(tNode, matches.find(isComponentDef).type, def.type);
            }
          }
          if (def.findHostDirectiveDefs !== null) {
            const hostDirectiveMatches = [];
            hostDirectiveDefs = hostDirectiveDefs || /* @__PURE__ */ new Map();
            def.findHostDirectiveDefs(def, hostDirectiveMatches, hostDirectiveDefs);
            matches.unshift(...hostDirectiveMatches, def);
            const componentOffset = hostDirectiveMatches.length;
            markAsComponentHost(tView, tNode, componentOffset);
          } else {
            matches.unshift(def);
            markAsComponentHost(tView, tNode, 0);
          }
        } else {
          hostDirectiveDefs = hostDirectiveDefs || /* @__PURE__ */ new Map();
          def.findHostDirectiveDefs?.(def, matches, hostDirectiveDefs);
          matches.push(def);
        }
      }
    }
  }
  ngDevMode && matches !== null && assertNoDuplicateDirectives(matches);
  return matches === null ? null : [matches, hostDirectiveDefs];
}
function markAsComponentHost(tView, hostTNode, componentOffset) {
  ngDevMode && assertFirstCreatePass(tView);
  ngDevMode && assertGreaterThan(componentOffset, -1, "componentOffset must be great than -1");
  hostTNode.componentOffset = componentOffset;
  (tView.components ??= []).push(hostTNode.index);
}
function cacheMatchingLocalNames(tNode, localRefs, exportsMap) {
  if (localRefs) {
    const localNames = tNode.localNames = [];
    for (let i = 0; i < localRefs.length; i += 2) {
      const index = exportsMap[localRefs[i + 1]];
      if (index == null) throw new RuntimeError(-301, ngDevMode && `Export of name '${localRefs[i + 1]}' not found!`);
      localNames.push(localRefs[i], index);
    }
  }
}
function saveNameToExportMap(directiveIdx, def, exportsMap) {
  if (exportsMap) {
    if (def.exportAs) {
      for (let i = 0; i < def.exportAs.length; i++) {
        exportsMap[def.exportAs[i]] = directiveIdx;
      }
    }
    if (isComponentDef(def)) exportsMap[""] = directiveIdx;
  }
}
function initTNodeFlags(tNode, index, numberOfDirectives) {
  ngDevMode && assertNotEqual(numberOfDirectives, tNode.directiveEnd - tNode.directiveStart, "Reached the max number of directives");
  tNode.flags |= 1;
  tNode.directiveStart = index;
  tNode.directiveEnd = index + numberOfDirectives;
  tNode.providerIndexes = index;
}
function configureViewWithDirective(tView, tNode, lView, directiveIndex, def) {
  ngDevMode && assertGreaterThanOrEqual(directiveIndex, HEADER_OFFSET, "Must be in Expando section");
  tView.data[directiveIndex] = def;
  const directiveFactory = def.factory || (def.factory = getFactoryDef(def.type, true));
  const nodeInjectorFactory = new NodeInjectorFactory(directiveFactory, isComponentDef(def), ɵɵdirectiveInject);
  tView.blueprint[directiveIndex] = nodeInjectorFactory;
  lView[directiveIndex] = nodeInjectorFactory;
  registerHostBindingOpCodes(tView, tNode, directiveIndex, allocExpando(tView, lView, def.hostVars, NO_CHANGE), def);
}
function addComponentLogic(lView, hostTNode, def) {
  const native = getNativeByTNode(hostTNode, lView);
  const tView = getOrCreateComponentTView(def);
  const rendererFactory = lView[ENVIRONMENT].rendererFactory;
  let lViewFlags = 16;
  if (def.signals) {
    lViewFlags = 4096;
  } else if (def.onPush) {
    lViewFlags = 64;
  }
  const componentView = addToViewTree(lView, createLView(lView, tView, null, lViewFlags, native, hostTNode, null, rendererFactory.createRenderer(native, def), null, null, null));
  lView[hostTNode.index] = componentView;
}
function elementAttributeInternal(tNode, lView, name, value, sanitizer, namespace) {
  if (ngDevMode) {
    assertNotSame(value, NO_CHANGE, "Incoming value should never be NO_CHANGE.");
    validateAgainstEventAttributes(name);
    assertTNodeType(tNode, 2, `Attempted to set attribute \`${name}\` on a container node. Host bindings are not valid on ng-container or ng-template.`);
  }
  const element = getNativeByTNode(tNode, lView);
  setElementAttribute(lView[RENDERER], element, namespace, tNode.value, name, value, sanitizer);
}
function setElementAttribute(renderer, element, namespace, tagName, name, value, sanitizer) {
  if (value == null) {
    ngDevMode && ngDevMode.rendererRemoveAttribute++;
    renderer.removeAttribute(element, name, namespace);
  } else {
    ngDevMode && ngDevMode.rendererSetAttribute++;
    const strValue = sanitizer == null ? renderStringify(value) : sanitizer(value, tagName || "", name);
    renderer.setAttribute(element, name, strValue, namespace);
  }
}
function setInputsFromAttrs(lView, directiveIndex, instance, def, tNode, initialInputData) {
  const initialInputs = initialInputData[directiveIndex];
  if (initialInputs !== null) {
    for (let i = 0; i < initialInputs.length; ) {
      const publicName = initialInputs[i++];
      const privateName = initialInputs[i++];
      const flags = initialInputs[i++];
      const value = initialInputs[i++];
      writeToDirectiveInput(def, instance, publicName, privateName, flags, value);
      if (ngDevMode) {
        const nativeElement = getNativeByTNode(tNode, lView);
        setNgReflectProperty(lView, nativeElement, tNode.type, privateName, value);
      }
    }
  }
}
function generateInitialInputs(inputs, directiveIndex, attrs) {
  let inputsToStore = null;
  let i = 0;
  while (i < attrs.length) {
    const attrName = attrs[i];
    if (attrName === 0) {
      i += 4;
      continue;
    } else if (attrName === 5) {
      i += 2;
      continue;
    }
    if (typeof attrName === "number") break;
    if (inputs.hasOwnProperty(attrName)) {
      if (inputsToStore === null) inputsToStore = [];
      const inputConfig = inputs[attrName];
      for (let j = 0; j < inputConfig.length; j += 3) {
        if (inputConfig[j] === directiveIndex) {
          inputsToStore.push(attrName, inputConfig[j + 1], inputConfig[j + 2], attrs[i + 1]);
          break;
        }
      }
    }
    i += 2;
  }
  return inputsToStore;
}
function createLContainer(hostNative, currentView, native, tNode) {
  ngDevMode && assertLView(currentView);
  const lContainer = [
    hostNative,
    // host native
    true,
    // Boolean `true` in this position signifies that this is an `LContainer`
    0,
    // flags
    currentView,
    // parent
    null,
    // next
    tNode,
    // t_host
    null,
    // dehydrated views
    native,
    // native,
    null,
    // view refs
    null
    // moved views
  ];
  ngDevMode && assertEqual(lContainer.length, CONTAINER_HEADER_OFFSET, "Should allocate correct number of slots for LContainer header.");
  return lContainer;
}
function refreshContentQueries(tView, lView) {
  const contentQueries = tView.contentQueries;
  if (contentQueries !== null) {
    const prevConsumer = setActiveConsumer(null);
    try {
      for (let i = 0; i < contentQueries.length; i += 2) {
        const queryStartIdx = contentQueries[i];
        const directiveDefIdx = contentQueries[i + 1];
        if (directiveDefIdx !== -1) {
          const directiveDef = tView.data[directiveDefIdx];
          ngDevMode && assertDefined(directiveDef, "DirectiveDef not found.");
          ngDevMode && assertDefined(directiveDef.contentQueries, "contentQueries function should be defined");
          setCurrentQueryIndex(queryStartIdx);
          directiveDef.contentQueries(2, lView[directiveDefIdx], directiveDefIdx);
        }
      }
    } finally {
      setActiveConsumer(prevConsumer);
    }
  }
}
function addToViewTree(lView, lViewOrLContainer) {
  if (lView[CHILD_HEAD]) {
    lView[CHILD_TAIL][NEXT] = lViewOrLContainer;
  } else {
    lView[CHILD_HEAD] = lViewOrLContainer;
  }
  lView[CHILD_TAIL] = lViewOrLContainer;
  return lViewOrLContainer;
}
function executeViewQueryFn(flags, viewQueryFn, component) {
  ngDevMode && assertDefined(viewQueryFn, "View queries function to execute must be defined.");
  setCurrentQueryIndex(0);
  const prevConsumer = setActiveConsumer(null);
  try {
    viewQueryFn(flags, component);
  } finally {
    setActiveConsumer(prevConsumer);
  }
}
function storePropertyBindingMetadata(tData, tNode, propertyName, bindingIndex, ...interpolationParts) {
  if (tData[bindingIndex] === null) {
    if (tNode.inputs == null || !tNode.inputs[propertyName]) {
      const propBindingIdxs = tNode.propertyBindings || (tNode.propertyBindings = []);
      propBindingIdxs.push(bindingIndex);
      let bindingMetadata = propertyName;
      if (interpolationParts.length > 0) {
        bindingMetadata += INTERPOLATION_DELIMITER + interpolationParts.join(INTERPOLATION_DELIMITER);
      }
      tData[bindingIndex] = bindingMetadata;
    }
  }
}
function getOrCreateLViewCleanup(view) {
  return view[CLEANUP] ??= [];
}
function getOrCreateTViewCleanup(tView) {
  return tView.cleanup ??= [];
}
function loadComponentRenderer(currentDef, tNode, lView) {
  if (currentDef === null || isComponentDef(currentDef)) {
    lView = unwrapLView(lView[tNode.index]);
  }
  return lView[RENDERER];
}
function handleError(lView, error) {
  const injector = lView[INJECTOR];
  const errorHandler = injector ? injector.get(ErrorHandler, null) : null;
  errorHandler && errorHandler.handleError(error);
}
function setInputsForProperty(tView, lView, inputs, publicName, value) {
  for (let i = 0; i < inputs.length; ) {
    const index = inputs[i++];
    const privateName = inputs[i++];
    const flags = inputs[i++];
    const instance = lView[index];
    ngDevMode && assertIndexInRange(lView, index);
    const def = tView.data[index];
    writeToDirectiveInput(def, instance, publicName, privateName, flags, value);
  }
}
function textBindingInternal(lView, index, value) {
  ngDevMode && assertString(value, "Value should be a string");
  ngDevMode && assertNotSame(value, NO_CHANGE, "value should not be NO_CHANGE");
  ngDevMode && assertIndexInRange(lView, index);
  const element = getNativeByIndex(index, lView);
  ngDevMode && assertDefined(element, "native element should exist");
  updateTextNode(lView[RENDERER], element, value);
}
function renderComponent(hostLView, componentHostIdx) {
  ngDevMode && assertEqual(isCreationMode(hostLView), true, "Should be run in creation mode");
  const componentView = getComponentLViewByIndex(componentHostIdx, hostLView);
  const componentTView = componentView[TVIEW];
  syncViewWithBlueprint(componentTView, componentView);
  const hostRNode = componentView[HOST];
  if (hostRNode !== null && componentView[HYDRATION] === null) {
    componentView[HYDRATION] = retrieveHydrationInfo(hostRNode, componentView[INJECTOR]);
  }
  renderView(componentTView, componentView, componentView[CONTEXT]);
}
function syncViewWithBlueprint(tView, lView) {
  for (let i = lView.length; i < tView.blueprint.length; i++) {
    lView.push(tView.blueprint[i]);
  }
}
function renderView(tView, lView, context) {
  ngDevMode && assertEqual(isCreationMode(lView), true, "Should be run in creation mode");
  ngDevMode && assertNotReactive(renderView.name);
  enterView(lView);
  try {
    const viewQuery = tView.viewQuery;
    if (viewQuery !== null) {
      executeViewQueryFn(1, viewQuery, context);
    }
    const templateFn = tView.template;
    if (templateFn !== null) {
      executeTemplate(tView, lView, templateFn, 1, context);
    }
    if (tView.firstCreatePass) {
      tView.firstCreatePass = false;
    }
    lView[QUERIES]?.finishViewCreation(tView);
    if (tView.staticContentQueries) {
      refreshContentQueries(tView, lView);
    }
    if (tView.staticViewQueries) {
      executeViewQueryFn(2, tView.viewQuery, context);
    }
    const components = tView.components;
    if (components !== null) {
      renderChildComponents(lView, components);
    }
  } catch (error) {
    if (tView.firstCreatePass) {
      tView.incompleteFirstPass = true;
      tView.firstCreatePass = false;
    }
    throw error;
  } finally {
    lView[FLAGS] &= ~4;
    leaveView();
  }
}
function renderChildComponents(hostLView, components) {
  for (let i = 0; i < components.length; i++) {
    renderComponent(hostLView, components[i]);
  }
}
function createAndRenderEmbeddedLView(declarationLView, templateTNode, context, options) {
  const prevConsumer = setActiveConsumer(null);
  try {
    const embeddedTView = templateTNode.tView;
    ngDevMode && assertDefined(embeddedTView, "TView must be defined for a template node.");
    ngDevMode && assertTNodeForLView(templateTNode, declarationLView);
    const isSignalView = declarationLView[FLAGS] & 4096;
    const viewFlags = isSignalView ? 4096 : 16;
    const embeddedLView = createLView(declarationLView, embeddedTView, context, viewFlags, null, templateTNode, null, null, options?.injector ?? null, options?.embeddedViewInjector ?? null, options?.dehydratedView ?? null);
    const declarationLContainer = declarationLView[templateTNode.index];
    ngDevMode && assertLContainer(declarationLContainer);
    embeddedLView[DECLARATION_LCONTAINER] = declarationLContainer;
    const declarationViewLQueries = declarationLView[QUERIES];
    if (declarationViewLQueries !== null) {
      embeddedLView[QUERIES] = declarationViewLQueries.createEmbeddedView(embeddedTView);
    }
    renderView(embeddedTView, embeddedLView, context);
    return embeddedLView;
  } finally {
    setActiveConsumer(prevConsumer);
  }
}
function getLViewFromLContainer(lContainer, index) {
  const adjustedIndex = CONTAINER_HEADER_OFFSET + index;
  if (adjustedIndex < lContainer.length) {
    const lView = lContainer[adjustedIndex];
    ngDevMode && assertLView(lView);
    return lView;
  }
  return void 0;
}
function shouldAddViewToDom(tNode, dehydratedView) {
  return !dehydratedView || dehydratedView.firstChild === null || hasInSkipHydrationBlockFlag(tNode);
}
function addLViewToLContainer(lContainer, lView, index, addToDOM = true) {
  const tView = lView[TVIEW];
  insertView(tView, lView, lContainer, index);
  if (addToDOM) {
    const beforeNode = getBeforeNodeForView(index, lContainer);
    const renderer = lView[RENDERER];
    const parentRNode = nativeParentNode(renderer, lContainer[NATIVE]);
    if (parentRNode !== null) {
      addViewToDOM(tView, lContainer[T_HOST], renderer, lView, parentRNode, beforeNode);
    }
  }
  const hydrationInfo = lView[HYDRATION];
  if (hydrationInfo !== null && hydrationInfo.firstChild !== null) {
    hydrationInfo.firstChild = null;
  }
}
function removeLViewFromLContainer(lContainer, index) {
  const lView = detachView(lContainer, index);
  if (lView !== void 0) {
    destroyLView(lView[TVIEW], lView);
  }
  return lView;
}
function collectNativeNodes(tView, lView, tNode, result, isProjection = false) {
  while (tNode !== null) {
    if (tNode.type === 128) {
      tNode = isProjection ? tNode.projectionNext : tNode.next;
      continue;
    }
    ngDevMode && assertTNodeType(
      tNode,
      3 | 12 | 16 | 32
      /* TNodeType.Icu */
    );
    const lNode = lView[tNode.index];
    if (lNode !== null) {
      result.push(unwrapRNode(lNode));
    }
    if (isLContainer(lNode)) {
      collectNativeNodesInLContainer(lNode, result);
    }
    const tNodeType = tNode.type;
    if (tNodeType & 8) {
      collectNativeNodes(tView, lView, tNode.child, result);
    } else if (tNodeType & 32) {
      const nextRNode = icuContainerIterate(tNode, lView);
      let rNode;
      while (rNode = nextRNode()) {
        result.push(rNode);
      }
    } else if (tNodeType & 16) {
      const nodesInSlot = getProjectionNodes(lView, tNode);
      if (Array.isArray(nodesInSlot)) {
        result.push(...nodesInSlot);
      } else {
        const parentView = getLViewParent(lView[DECLARATION_COMPONENT_VIEW]);
        ngDevMode && assertParentView(parentView);
        collectNativeNodes(parentView[TVIEW], parentView, nodesInSlot, result, true);
      }
    }
    tNode = isProjection ? tNode.projectionNext : tNode.next;
  }
  return result;
}
function collectNativeNodesInLContainer(lContainer, result) {
  for (let i = CONTAINER_HEADER_OFFSET; i < lContainer.length; i++) {
    const lViewInAContainer = lContainer[i];
    const lViewFirstChildTNode = lViewInAContainer[TVIEW].firstChild;
    if (lViewFirstChildTNode !== null) {
      collectNativeNodes(lViewInAContainer[TVIEW], lViewInAContainer, lViewFirstChildTNode, result);
    }
  }
  if (lContainer[NATIVE] !== lContainer[HOST]) {
    result.push(lContainer[NATIVE]);
  }
}
var freeConsumers = [];
function getOrBorrowReactiveLViewConsumer(lView) {
  return lView[REACTIVE_TEMPLATE_CONSUMER] ?? borrowReactiveLViewConsumer(lView);
}
function borrowReactiveLViewConsumer(lView) {
  const consumer = freeConsumers.pop() ?? Object.create(REACTIVE_LVIEW_CONSUMER_NODE);
  consumer.lView = lView;
  return consumer;
}
function maybeReturnReactiveLViewConsumer(consumer) {
  if (consumer.lView[REACTIVE_TEMPLATE_CONSUMER] === consumer) {
    return;
  }
  consumer.lView = null;
  freeConsumers.push(consumer);
}
var REACTIVE_LVIEW_CONSUMER_NODE = __spreadProps(__spreadValues({}, REACTIVE_NODE), {
  consumerIsAlwaysLive: true,
  consumerMarkedDirty: (node) => {
    markAncestorsForTraversal(node.lView);
  },
  consumerOnSignalRead() {
    this.lView[REACTIVE_TEMPLATE_CONSUMER] = this;
  }
});
function getOrCreateTemporaryConsumer(lView) {
  const consumer = lView[REACTIVE_TEMPLATE_CONSUMER] ?? Object.create(TEMPORARY_CONSUMER_NODE);
  consumer.lView = lView;
  return consumer;
}
var TEMPORARY_CONSUMER_NODE = __spreadProps(__spreadValues({}, REACTIVE_NODE), {
  consumerIsAlwaysLive: true,
  consumerMarkedDirty: (node) => {
    let parent = getLViewParent(node.lView);
    while (parent && !viewShouldHaveReactiveConsumer(parent[TVIEW])) {
      parent = getLViewParent(parent);
    }
    if (!parent) {
      return;
    }
    markViewForRefresh(parent);
  },
  consumerOnSignalRead() {
    this.lView[REACTIVE_TEMPLATE_CONSUMER] = this;
  }
});
function viewShouldHaveReactiveConsumer(tView) {
  return tView.type !== 2;
}
var MAXIMUM_REFRESH_RERUNS$1 = 100;
function detectChangesInternal(lView, notifyErrorHandler = true, mode = 0) {
  const environment = lView[ENVIRONMENT];
  const rendererFactory = environment.rendererFactory;
  const checkNoChangesMode = !!ngDevMode && isInCheckNoChangesMode();
  if (!checkNoChangesMode) {
    rendererFactory.begin?.();
  }
  try {
    detectChangesInViewWhileDirty(lView, mode);
  } catch (error) {
    if (notifyErrorHandler) {
      handleError(lView, error);
    }
    throw error;
  } finally {
    if (!checkNoChangesMode) {
      rendererFactory.end?.();
      environment.inlineEffectRunner?.flush();
    }
  }
}
function detectChangesInViewWhileDirty(lView, mode) {
  const lastIsRefreshingViewsValue = isRefreshingViews();
  try {
    setIsRefreshingViews(true);
    detectChangesInView(lView, mode);
    if (ngDevMode && isExhaustiveCheckNoChanges()) {
      return;
    }
    let retries = 0;
    while (requiresRefreshOrTraversal(lView)) {
      if (retries === MAXIMUM_REFRESH_RERUNS$1) {
        throw new RuntimeError(103, ngDevMode && "Infinite change detection while trying to refresh views. There may be components which each cause the other to require a refresh, causing an infinite loop.");
      }
      retries++;
      detectChangesInView(
        lView,
        1
        /* ChangeDetectionMode.Targeted */
      );
    }
  } finally {
    setIsRefreshingViews(lastIsRefreshingViewsValue);
  }
}
function checkNoChangesInternal(lView, mode, notifyErrorHandler = true) {
  setIsInCheckNoChangesMode(mode);
  try {
    detectChangesInternal(lView, notifyErrorHandler);
  } finally {
    setIsInCheckNoChangesMode(CheckNoChangesMode.Off);
  }
}
function refreshView(tView, lView, templateFn, context) {
  ngDevMode && assertEqual(isCreationMode(lView), false, "Should be run in update mode");
  const flags = lView[FLAGS];
  if ((flags & 256) === 256) return;
  const isInCheckNoChangesPass = ngDevMode && isInCheckNoChangesMode();
  const isInExhaustiveCheckNoChangesPass = ngDevMode && isExhaustiveCheckNoChanges();
  !isInCheckNoChangesPass && lView[ENVIRONMENT].inlineEffectRunner?.flush();
  enterView(lView);
  let returnConsumerToPool = true;
  let prevConsumer = null;
  let currentConsumer = null;
  if (!isInCheckNoChangesPass) {
    if (viewShouldHaveReactiveConsumer(tView)) {
      currentConsumer = getOrBorrowReactiveLViewConsumer(lView);
      prevConsumer = consumerBeforeComputation(currentConsumer);
    } else if (getActiveConsumer() === null) {
      returnConsumerToPool = false;
      currentConsumer = getOrCreateTemporaryConsumer(lView);
      prevConsumer = consumerBeforeComputation(currentConsumer);
    } else if (lView[REACTIVE_TEMPLATE_CONSUMER]) {
      consumerDestroy(lView[REACTIVE_TEMPLATE_CONSUMER]);
      lView[REACTIVE_TEMPLATE_CONSUMER] = null;
    }
  }
  try {
    resetPreOrderHookFlags(lView);
    setBindingIndex(tView.bindingStartIndex);
    if (templateFn !== null) {
      executeTemplate(tView, lView, templateFn, 2, context);
    }
    const hooksInitPhaseCompleted = (flags & 3) === 3;
    if (!isInCheckNoChangesPass) {
      if (hooksInitPhaseCompleted) {
        const preOrderCheckHooks = tView.preOrderCheckHooks;
        if (preOrderCheckHooks !== null) {
          executeCheckHooks(lView, preOrderCheckHooks, null);
        }
      } else {
        const preOrderHooks = tView.preOrderHooks;
        if (preOrderHooks !== null) {
          executeInitAndCheckHooks(lView, preOrderHooks, 0, null);
        }
        incrementInitPhaseFlags(
          lView,
          0
          /* InitPhaseState.OnInitHooksToBeRun */
        );
      }
    }
    if (!isInExhaustiveCheckNoChangesPass) {
      markTransplantedViewsForRefresh(lView);
    }
    detectChangesInEmbeddedViews(
      lView,
      0
      /* ChangeDetectionMode.Global */
    );
    if (tView.contentQueries !== null) {
      refreshContentQueries(tView, lView);
    }
    if (!isInCheckNoChangesPass) {
      if (hooksInitPhaseCompleted) {
        const contentCheckHooks = tView.contentCheckHooks;
        if (contentCheckHooks !== null) {
          executeCheckHooks(lView, contentCheckHooks);
        }
      } else {
        const contentHooks = tView.contentHooks;
        if (contentHooks !== null) {
          executeInitAndCheckHooks(
            lView,
            contentHooks,
            1
            /* InitPhaseState.AfterContentInitHooksToBeRun */
          );
        }
        incrementInitPhaseFlags(
          lView,
          1
          /* InitPhaseState.AfterContentInitHooksToBeRun */
        );
      }
    }
    processHostBindingOpCodes(tView, lView);
    const components = tView.components;
    if (components !== null) {
      detectChangesInChildComponents(
        lView,
        components,
        0
        /* ChangeDetectionMode.Global */
      );
    }
    const viewQuery = tView.viewQuery;
    if (viewQuery !== null) {
      executeViewQueryFn(2, viewQuery, context);
    }
    if (!isInCheckNoChangesPass) {
      if (hooksInitPhaseCompleted) {
        const viewCheckHooks = tView.viewCheckHooks;
        if (viewCheckHooks !== null) {
          executeCheckHooks(lView, viewCheckHooks);
        }
      } else {
        const viewHooks = tView.viewHooks;
        if (viewHooks !== null) {
          executeInitAndCheckHooks(
            lView,
            viewHooks,
            2
            /* InitPhaseState.AfterViewInitHooksToBeRun */
          );
        }
        incrementInitPhaseFlags(
          lView,
          2
          /* InitPhaseState.AfterViewInitHooksToBeRun */
        );
      }
    }
    if (tView.firstUpdatePass === true) {
      tView.firstUpdatePass = false;
    }
    if (lView[EFFECTS_TO_SCHEDULE]) {
      for (const notifyEffect of lView[EFFECTS_TO_SCHEDULE]) {
        notifyEffect();
      }
      lView[EFFECTS_TO_SCHEDULE] = null;
    }
    if (!isInCheckNoChangesPass) {
      lView[FLAGS] &= ~(64 | 8);
    }
  } catch (e) {
    if (!isInCheckNoChangesPass) {
      markAncestorsForTraversal(lView);
    }
    throw e;
  } finally {
    if (currentConsumer !== null) {
      consumerAfterComputation(currentConsumer, prevConsumer);
      if (returnConsumerToPool) {
        maybeReturnReactiveLViewConsumer(currentConsumer);
      }
    }
    leaveView();
  }
}
function detectChangesInEmbeddedViews(lView, mode) {
  for (let lContainer = getFirstLContainer(lView); lContainer !== null; lContainer = getNextLContainer(lContainer)) {
    for (let i = CONTAINER_HEADER_OFFSET; i < lContainer.length; i++) {
      const embeddedLView = lContainer[i];
      detectChangesInViewIfAttached(embeddedLView, mode);
    }
  }
}
function markTransplantedViewsForRefresh(lView) {
  for (let lContainer = getFirstLContainer(lView); lContainer !== null; lContainer = getNextLContainer(lContainer)) {
    if (!(lContainer[FLAGS] & LContainerFlags.HasTransplantedViews)) continue;
    const movedViews = lContainer[MOVED_VIEWS];
    ngDevMode && assertDefined(movedViews, "Transplanted View flags set but missing MOVED_VIEWS");
    for (let i = 0; i < movedViews.length; i++) {
      const movedLView = movedViews[i];
      markViewForRefresh(movedLView);
    }
  }
}
function detectChangesInComponent(hostLView, componentHostIdx, mode) {
  ngDevMode && assertEqual(isCreationMode(hostLView), false, "Should be run in update mode");
  const componentView = getComponentLViewByIndex(componentHostIdx, hostLView);
  detectChangesInViewIfAttached(componentView, mode);
}
function detectChangesInViewIfAttached(lView, mode) {
  if (!viewAttachedToChangeDetector(lView)) {
    return;
  }
  detectChangesInView(lView, mode);
}
function detectChangesInView(lView, mode) {
  const isInCheckNoChangesPass = ngDevMode && isInCheckNoChangesMode();
  const tView = lView[TVIEW];
  const flags = lView[FLAGS];
  const consumer = lView[REACTIVE_TEMPLATE_CONSUMER];
  let shouldRefreshView = !!(mode === 0 && flags & 16);
  shouldRefreshView ||= !!(flags & 64 && mode === 0 && !isInCheckNoChangesPass);
  shouldRefreshView ||= !!(flags & 1024);
  shouldRefreshView ||= !!(consumer?.dirty && consumerPollProducersForChange(consumer));
  shouldRefreshView ||= !!(ngDevMode && isExhaustiveCheckNoChanges());
  if (consumer) {
    consumer.dirty = false;
  }
  lView[FLAGS] &= ~(8192 | 1024);
  if (shouldRefreshView) {
    refreshView(tView, lView, tView.template, lView[CONTEXT]);
  } else if (flags & 8192) {
    detectChangesInEmbeddedViews(
      lView,
      1
      /* ChangeDetectionMode.Targeted */
    );
    const components = tView.components;
    if (components !== null) {
      detectChangesInChildComponents(
        lView,
        components,
        1
        /* ChangeDetectionMode.Targeted */
      );
    }
  }
}
function detectChangesInChildComponents(hostLView, components, mode) {
  for (let i = 0; i < components.length; i++) {
    detectChangesInComponent(hostLView, components[i], mode);
  }
}
function markViewDirty(lView, source) {
  const dirtyBitsToUse = isRefreshingViews() ? (
    // When we are actively refreshing views, we only use the `Dirty` bit to mark a view
    64
  ) : (
    // When we are not actively refreshing a view tree, it is absolutely
    // valid to update state and mark views dirty. We use the `RefreshView` flag in this
    // case to allow synchronously rerunning change detection. This applies today to
    // afterRender hooks as well as animation listeners which execute after detecting
    // changes in a view when the render factory flushes.
    1024 | 64
  );
  lView[ENVIRONMENT].changeDetectionScheduler?.notify(source);
  while (lView) {
    lView[FLAGS] |= dirtyBitsToUse;
    const parent = getLViewParent(lView);
    if (isRootView(lView) && !parent) {
      return lView;
    }
    lView = parent;
  }
  return null;
}
var ViewRef$1 = class {
  get rootNodes() {
    const lView = this._lView;
    const tView = lView[TVIEW];
    return collectNativeNodes(tView, lView, tView.firstChild, []);
  }
  constructor(_lView, _cdRefInjectingView, notifyErrorHandler = true) {
    this._lView = _lView;
    this._cdRefInjectingView = _cdRefInjectingView;
    this.notifyErrorHandler = notifyErrorHandler;
    this._appRef = null;
    this._attachedToViewContainer = false;
  }
  get context() {
    return this._lView[CONTEXT];
  }
  /**
   * @deprecated Replacing the full context object is not supported. Modify the context
   *   directly, or consider using a `Proxy` if you need to replace the full object.
   * // TODO(devversion): Remove this.
   */
  set context(value) {
    if (ngDevMode) {
      console.warn("Angular: Replacing the `context` object of an `EmbeddedViewRef` is deprecated.");
    }
    this._lView[CONTEXT] = value;
  }
  get destroyed() {
    return (this._lView[FLAGS] & 256) === 256;
  }
  destroy() {
    if (this._appRef) {
      this._appRef.detachView(this);
    } else if (this._attachedToViewContainer) {
      const parent = this._lView[PARENT];
      if (isLContainer(parent)) {
        const viewRefs = parent[VIEW_REFS];
        const index = viewRefs ? viewRefs.indexOf(this) : -1;
        if (index > -1) {
          ngDevMode && assertEqual(index, parent.indexOf(this._lView) - CONTAINER_HEADER_OFFSET, "An attached view should be in the same position within its container as its ViewRef in the VIEW_REFS array.");
          detachView(parent, index);
          removeFromArray(viewRefs, index);
        }
      }
      this._attachedToViewContainer = false;
    }
    destroyLView(this._lView[TVIEW], this._lView);
  }
  onDestroy(callback) {
    storeLViewOnDestroy(this._lView, callback);
  }
  /**
   * Marks a view and all of its ancestors dirty.
   *
   * This can be used to ensure an {@link ChangeDetectionStrategy#OnPush} component is
   * checked when it needs to be re-rendered but the two normal triggers haven't marked it
   * dirty (i.e. inputs haven't changed and events haven't fired in the view).
   *
   * <!-- TODO: Add a link to a chapter on OnPush components -->
   *
   * @usageNotes
   * ### Example
   *
   * ```typescript
   * @Component({
   *   selector: 'app-root',
   *   template: `Number of ticks: {{numberOfTicks}}`
   *   changeDetection: ChangeDetectionStrategy.OnPush,
   * })
   * class AppComponent {
   *   numberOfTicks = 0;
   *
   *   constructor(private ref: ChangeDetectorRef) {
   *     setInterval(() => {
   *       this.numberOfTicks++;
   *       // the following is required, otherwise the view will not be updated
   *       this.ref.markForCheck();
   *     }, 1000);
   *   }
   * }
   * ```
   */
  markForCheck() {
    markViewDirty(
      this._cdRefInjectingView || this._lView,
      4
      /* NotificationSource.MarkForCheck */
    );
  }
  /**
   * Detaches the view from the change detection tree.
   *
   * Detached views will not be checked during change detection runs until they are
   * re-attached, even if they are dirty. `detach` can be used in combination with
   * {@link ChangeDetectorRef#detectChanges} to implement local change
   * detection checks.
   *
   * <!-- TODO: Add a link to a chapter on detach/reattach/local digest -->
   * <!-- TODO: Add a live demo once ref.detectChanges is merged into master -->
   *
   * @usageNotes
   * ### Example
   *
   * The following example defines a component with a large list of readonly data.
   * Imagine the data changes constantly, many times per second. For performance reasons,
   * we want to check and update the list every five seconds. We can do that by detaching
   * the component's change detector and doing a local check every five seconds.
   *
   * ```typescript
   * class DataProvider {
   *   // in a real application the returned data will be different every time
   *   get data() {
   *     return [1,2,3,4,5];
   *   }
   * }
   *
   * @Component({
   *   selector: 'giant-list',
   *   template: `
   *     <li *ngFor="let d of dataProvider.data">Data {{d}}</li>
   *   `,
   * })
   * class GiantList {
   *   constructor(private ref: ChangeDetectorRef, private dataProvider: DataProvider) {
   *     ref.detach();
   *     setInterval(() => {
   *       this.ref.detectChanges();
   *     }, 5000);
   *   }
   * }
   *
   * @Component({
   *   selector: 'app',
   *   providers: [DataProvider],
   *   template: `
   *     <giant-list><giant-list>
   *   `,
   * })
   * class App {
   * }
   * ```
   */
  detach() {
    this._lView[FLAGS] &= ~128;
  }
  /**
   * Re-attaches a view to the change detection tree.
   *
   * This can be used to re-attach views that were previously detached from the tree
   * using {@link ChangeDetectorRef#detach}. Views are attached to the tree by default.
   *
   * <!-- TODO: Add a link to a chapter on detach/reattach/local digest -->
   *
   * @usageNotes
   * ### Example
   *
   * The following example creates a component displaying `live` data. The component will detach
   * its change detector from the main change detector tree when the component's live property
   * is set to false.
   *
   * ```typescript
   * class DataProvider {
   *   data = 1;
   *
   *   constructor() {
   *     setInterval(() => {
   *       this.data = this.data * 2;
   *     }, 500);
   *   }
   * }
   *
   * @Component({
   *   selector: 'live-data',
   *   inputs: ['live'],
   *   template: 'Data: {{dataProvider.data}}'
   * })
   * class LiveData {
   *   constructor(private ref: ChangeDetectorRef, private dataProvider: DataProvider) {}
   *
   *   set live(value) {
   *     if (value) {
   *       this.ref.reattach();
   *     } else {
   *       this.ref.detach();
   *     }
   *   }
   * }
   *
   * @Component({
   *   selector: 'app-root',
   *   providers: [DataProvider],
   *   template: `
   *     Live Update: <input type="checkbox" [(ngModel)]="live">
   *     <live-data [live]="live"><live-data>
   *   `,
   * })
   * class AppComponent {
   *   live = true;
   * }
   * ```
   */
  reattach() {
    updateAncestorTraversalFlagsOnAttach(this._lView);
    this._lView[FLAGS] |= 128;
  }
  /**
   * Checks the view and its children.
   *
   * This can also be used in combination with {@link ChangeDetectorRef#detach} to implement
   * local change detection checks.
   *
   * <!-- TODO: Add a link to a chapter on detach/reattach/local digest -->
   * <!-- TODO: Add a live demo once ref.detectChanges is merged into master -->
   *
   * @usageNotes
   * ### Example
   *
   * The following example defines a component with a large list of readonly data.
   * Imagine, the data changes constantly, many times per second. For performance reasons,
   * we want to check and update the list every five seconds.
   *
   * We can do that by detaching the component's change detector and doing a local change detection
   * check every five seconds.
   *
   * See {@link ChangeDetectorRef#detach} for more information.
   */
  detectChanges() {
    this._lView[FLAGS] |= 1024;
    detectChangesInternal(this._lView, this.notifyErrorHandler);
  }
  /**
   * Checks the change detector and its children, and throws if any changes are detected.
   *
   * This is used in development mode to verify that running change detection doesn't
   * introduce other changes.
   */
  checkNoChanges() {
    if (ngDevMode) {
      checkNoChangesInternal(this._lView, CheckNoChangesMode.OnlyDirtyViews, this.notifyErrorHandler);
    }
  }
  attachToViewContainerRef() {
    if (this._appRef) {
      throw new RuntimeError(902, ngDevMode && "This view is already attached directly to the ApplicationRef!");
    }
    this._attachedToViewContainer = true;
  }
  detachFromAppRef() {
    this._appRef = null;
    const isRoot = isRootView(this._lView);
    const declarationContainer = this._lView[DECLARATION_LCONTAINER];
    if (declarationContainer !== null && !isRoot) {
      detachMovedView(declarationContainer, this._lView);
    }
    detachViewFromDOM(this._lView[TVIEW], this._lView);
  }
  attachToAppRef(appRef) {
    if (this._attachedToViewContainer) {
      throw new RuntimeError(902, ngDevMode && "This view is already attached to a ViewContainer!");
    }
    this._appRef = appRef;
    const isRoot = isRootView(this._lView);
    const declarationContainer = this._lView[DECLARATION_LCONTAINER];
    if (declarationContainer !== null && !isRoot) {
      trackMovedView(declarationContainer, this._lView);
    }
    updateAncestorTraversalFlagsOnAttach(this._lView);
  }
};
var TemplateRef = class {
  static {
    this.__NG_ELEMENT_ID__ = injectTemplateRef;
  }
};
var ViewEngineTemplateRef = TemplateRef;
var R3TemplateRef = class TemplateRef2 extends ViewEngineTemplateRef {
  constructor(_declarationLView, _declarationTContainer, elementRef) {
    super();
    this._declarationLView = _declarationLView;
    this._declarationTContainer = _declarationTContainer;
    this.elementRef = elementRef;
  }
  /**
   * Returns an `ssrId` associated with a TView, which was used to
   * create this instance of the `TemplateRef`.
   *
   * @internal
   */
  get ssrId() {
    return this._declarationTContainer.tView?.ssrId || null;
  }
  createEmbeddedView(context, injector) {
    return this.createEmbeddedViewImpl(context, injector);
  }
  /**
   * @internal
   */
  createEmbeddedViewImpl(context, injector, dehydratedView) {
    const embeddedLView = createAndRenderEmbeddedLView(this._declarationLView, this._declarationTContainer, context, {
      embeddedViewInjector: injector,
      dehydratedView
    });
    return new ViewRef$1(embeddedLView);
  }
};
function injectTemplateRef() {
  return createTemplateRef(getCurrentTNode(), getLView());
}
function createTemplateRef(hostTNode, hostLView) {
  if (hostTNode.type & 4) {
    ngDevMode && assertDefined(hostTNode.tView, "TView must be allocated");
    return new R3TemplateRef(hostLView, hostTNode, createElementRef(hostTNode, hostLView));
  }
  return null;
}
function getInsertInFrontOfRNodeWithI18n(parentTNode, currentTNode, lView) {
  const tNodeInsertBeforeIndex = currentTNode.insertBeforeIndex;
  const insertBeforeIndex = Array.isArray(tNodeInsertBeforeIndex) ? tNodeInsertBeforeIndex[0] : tNodeInsertBeforeIndex;
  if (insertBeforeIndex === null) {
    return getInsertInFrontOfRNodeWithNoI18n(parentTNode, currentTNode, lView);
  } else {
    ngDevMode && assertIndexInRange(lView, insertBeforeIndex);
    return unwrapRNode(lView[insertBeforeIndex]);
  }
}
function processI18nInsertBefore(renderer, childTNode, lView, childRNode, parentRElement) {
  const tNodeInsertBeforeIndex = childTNode.insertBeforeIndex;
  if (Array.isArray(tNodeInsertBeforeIndex)) {
    ngDevMode && assertDomNode(childRNode);
    let i18nParent = childRNode;
    let anchorRNode = null;
    if (!(childTNode.type & 3)) {
      anchorRNode = i18nParent;
      i18nParent = parentRElement;
    }
    if (i18nParent !== null && childTNode.componentOffset === -1) {
      for (let i = 1; i < tNodeInsertBeforeIndex.length; i++) {
        const i18nChild = lView[tNodeInsertBeforeIndex[i]];
        nativeInsertBefore(renderer, i18nParent, i18nChild, anchorRNode, false);
      }
    }
  }
}
function addTNodeAndUpdateInsertBeforeIndex(previousTNodes, newTNode) {
  ngDevMode && assertEqual(newTNode.insertBeforeIndex, null, "We expect that insertBeforeIndex is not set");
  previousTNodes.push(newTNode);
  if (previousTNodes.length > 1) {
    for (let i = previousTNodes.length - 2; i >= 0; i--) {
      const existingTNode = previousTNodes[i];
      if (!isI18nText(existingTNode)) {
        if (isNewTNodeCreatedBefore(existingTNode, newTNode) && getInsertBeforeIndex(existingTNode) === null) {
          setInsertBeforeIndex(existingTNode, newTNode.index);
        }
      }
    }
  }
}
function isI18nText(tNode) {
  return !(tNode.type & 64);
}
function isNewTNodeCreatedBefore(existingTNode, newTNode) {
  return isI18nText(newTNode) || existingTNode.index > newTNode.index;
}
function getInsertBeforeIndex(tNode) {
  const index = tNode.insertBeforeIndex;
  return Array.isArray(index) ? index[0] : index;
}
function setInsertBeforeIndex(tNode, value) {
  const index = tNode.insertBeforeIndex;
  if (Array.isArray(index)) {
    index[0] = value;
  } else {
    setI18nHandling(getInsertInFrontOfRNodeWithI18n, processI18nInsertBefore);
    tNode.insertBeforeIndex = value;
  }
}
function getTIcu(tView, index) {
  const value = tView.data[index];
  if (value === null || typeof value === "string") return null;
  if (ngDevMode && !(value.hasOwnProperty("tView") || value.hasOwnProperty("currentCaseLViewIndex"))) {
    throwError("We expect to get 'null'|'TIcu'|'TIcuContainer', but got: " + value);
  }
  const tIcu = value.hasOwnProperty("currentCaseLViewIndex") ? value : value.value;
  ngDevMode && assertTIcu(tIcu);
  return tIcu;
}
function setTIcu(tView, index, tIcu) {
  const tNode = tView.data[index];
  ngDevMode && assertEqual(tNode === null || tNode.hasOwnProperty("tView"), true, "We expect to get 'null'|'TIcuContainer'");
  if (tNode === null) {
    tView.data[index] = tIcu;
  } else {
    ngDevMode && assertTNodeType(
      tNode,
      32
      /* TNodeType.Icu */
    );
    tNode.value = tIcu;
  }
}
function setTNodeInsertBeforeIndex(tNode, index) {
  ngDevMode && assertTNode(tNode);
  let insertBeforeIndex = tNode.insertBeforeIndex;
  if (insertBeforeIndex === null) {
    setI18nHandling(getInsertInFrontOfRNodeWithI18n, processI18nInsertBefore);
    insertBeforeIndex = tNode.insertBeforeIndex = [null, index];
  } else {
    assertEqual(Array.isArray(insertBeforeIndex), true, "Expecting array here");
    insertBeforeIndex.push(index);
  }
}
function createTNodePlaceholder(tView, previousTNodes, index) {
  const tNode = createTNodeAtIndex(tView, index, 64, null, null);
  addTNodeAndUpdateInsertBeforeIndex(previousTNodes, tNode);
  return tNode;
}
function getCurrentICUCaseIndex(tIcu, lView) {
  const currentCase = lView[tIcu.currentCaseLViewIndex];
  return currentCase === null ? currentCase : currentCase < 0 ? ~currentCase : currentCase;
}
function getParentFromIcuCreateOpCode(mergedCode) {
  return mergedCode >>> 17;
}
function getRefFromIcuCreateOpCode(mergedCode) {
  return (mergedCode & 131070) >>> 1;
}
function getInstructionFromIcuCreateOpCode(mergedCode) {
  return mergedCode & 1;
}
function icuCreateOpCode(opCode, parentIdx, refIdx) {
  ngDevMode && assertGreaterThanOrEqual(parentIdx, 0, "Missing parent index");
  ngDevMode && assertGreaterThan(refIdx, 0, "Missing ref index");
  return opCode | parentIdx << 17 | refIdx << 1;
}
function isRootTemplateMessage(subTemplateIndex) {
  return subTemplateIndex === -1;
}
function enterIcu(state, tIcu, lView) {
  state.index = 0;
  const currentCase = getCurrentICUCaseIndex(tIcu, lView);
  if (currentCase !== null) {
    ngDevMode && assertNumberInRange(currentCase, 0, tIcu.cases.length - 1);
    state.removes = tIcu.remove[currentCase];
  } else {
    state.removes = EMPTY_ARRAY;
  }
}
function icuContainerIteratorNext(state) {
  if (state.index < state.removes.length) {
    const removeOpCode = state.removes[state.index++];
    ngDevMode && assertNumber(removeOpCode, "Expecting OpCode number");
    if (removeOpCode > 0) {
      const rNode = state.lView[removeOpCode];
      ngDevMode && assertDomNode(rNode);
      return rNode;
    } else {
      state.stack.push(state.index, state.removes);
      const tIcuIndex = ~removeOpCode;
      const tIcu = state.lView[TVIEW].data[tIcuIndex];
      ngDevMode && assertTIcu(tIcu);
      enterIcu(state, tIcu, state.lView);
      return icuContainerIteratorNext(state);
    }
  } else {
    if (state.stack.length === 0) {
      return null;
    } else {
      state.removes = state.stack.pop();
      state.index = state.stack.pop();
      return icuContainerIteratorNext(state);
    }
  }
}
function loadIcuContainerVisitor() {
  const _state = {
    stack: [],
    index: -1
  };
  function icuContainerIteratorStart(tIcuContainerNode, lView) {
    _state.lView = lView;
    while (_state.stack.length) _state.stack.pop();
    ngDevMode && assertTNodeForLView(tIcuContainerNode, lView);
    enterIcu(_state, tIcuContainerNode.value, lView);
    return icuContainerIteratorNext.bind(null, _state);
  }
  return icuContainerIteratorStart;
}
var REF_EXTRACTOR_REGEXP = new RegExp(`^(\\d+)*(${REFERENCE_NODE_BODY}|${REFERENCE_NODE_HOST})*(.*)`);
var _prepareI18nBlockForHydrationImpl = () => {
};
function prepareI18nBlockForHydration(lView, index, parentTNode, subTemplateIndex) {
  _prepareI18nBlockForHydrationImpl(lView, index, parentTNode, subTemplateIndex);
}
var _claimDehydratedIcuCaseImpl = () => {
};
function claimDehydratedIcuCase(lView, icuIndex, caseIndex) {
  _claimDehydratedIcuCaseImpl(lView, icuIndex, caseIndex);
}
var _findMatchingDehydratedViewImpl = () => null;
function findMatchingDehydratedView(lContainer, template) {
  return _findMatchingDehydratedViewImpl(lContainer, template);
}
var ChangeDetectionScheduler = class {
};
var ZONELESS_ENABLED = new InjectionToken(typeof ngDevMode === "undefined" || ngDevMode ? "Zoneless enabled" : "", {
  providedIn: "root",
  factory: () => false
});
var PROVIDED_ZONELESS = new InjectionToken(typeof ngDevMode === "undefined" || ngDevMode ? "Zoneless provided" : "", {
  providedIn: "root",
  factory: () => false
});
var ZONELESS_SCHEDULER_DISABLED = new InjectionToken(typeof ngDevMode === "undefined" || ngDevMode ? "scheduler disabled" : "");
var ComponentRef$1 = class {
};
var ComponentFactory$1 = class {
};
function noComponentFactoryError(component) {
  const error = Error(`No component factory found for ${stringify(component)}.`);
  error[ERROR_COMPONENT] = component;
  return error;
}
var ERROR_COMPONENT = "ngComponent";
var _NullComponentFactoryResolver = class {
  resolveComponentFactory(component) {
    throw noComponentFactoryError(component);
  }
};
var ComponentFactoryResolver$1 = class {
  static {
    this.NULL = new _NullComponentFactoryResolver();
  }
};
var RendererFactory2 = class {
};
var Renderer2 = class {
  constructor() {
    this.destroyNode = null;
  }
  static {
    this.__NG_ELEMENT_ID__ = () => injectRenderer2();
  }
};
function injectRenderer2() {
  const lView = getLView();
  const tNode = getCurrentTNode();
  const nodeAtIndex = getComponentLViewByIndex(tNode.index, lView);
  return (isLView(nodeAtIndex) ? nodeAtIndex : lView)[RENDERER];
}
var Sanitizer = class _Sanitizer {
  static {
    this.ɵprov = ɵɵdefineInjectable({
      token: _Sanitizer,
      providedIn: "root",
      factory: () => null
    });
  }
};
var markedFeatures = /* @__PURE__ */ new Set();
function performanceMarkFeature(feature) {
  if (markedFeatures.has(feature)) {
    return;
  }
  markedFeatures.add(feature);
  performance?.mark?.("mark_feature_usage", {
    detail: {
      feature
    }
  });
}
var AfterRenderPhase;
(function(AfterRenderPhase2) {
  AfterRenderPhase2[AfterRenderPhase2["EarlyRead"] = 0] = "EarlyRead";
  AfterRenderPhase2[AfterRenderPhase2["Write"] = 1] = "Write";
  AfterRenderPhase2[AfterRenderPhase2["MixedReadWrite"] = 2] = "MixedReadWrite";
  AfterRenderPhase2[AfterRenderPhase2["Read"] = 3] = "Read";
})(AfterRenderPhase || (AfterRenderPhase = {}));
function internalAfterNextRender(callback, options) {
  const injector = options?.injector ?? inject(Injector);
  if (!options?.runOnServer && !isPlatformBrowser(injector)) return;
  const afterRenderEventManager = injector.get(AfterRenderEventManager);
  afterRenderEventManager.internalCallbacks.push(callback);
}
var AfterRenderEventManager = class _AfterRenderEventManager {
  constructor() {
    this.handler = null;
    this.internalCallbacks = [];
  }
  /**
   * Executes internal and user-provided callbacks.
   */
  execute() {
    this.executeInternalCallbacks();
    this.handler?.execute();
  }
  executeInternalCallbacks() {
    const callbacks = [...this.internalCallbacks];
    this.internalCallbacks.length = 0;
    for (const callback of callbacks) {
      callback();
    }
  }
  ngOnDestroy() {
    this.handler?.destroy();
    this.handler = null;
    this.internalCallbacks.length = 0;
  }
  static {
    this.ɵprov = ɵɵdefineInjectable({
      token: _AfterRenderEventManager,
      providedIn: "root",
      factory: () => new _AfterRenderEventManager()
    });
  }
};
function isModuleWithProviders(value) {
  return value.ngModule !== void 0;
}
function isNgModule(value) {
  return !!getNgModuleDef(value);
}
function isPipe(value) {
  return !!getPipeDef$1(value);
}
function isDirective(value) {
  return !!getDirectiveDef(value);
}
function isComponent(value) {
  return !!getComponentDef(value);
}
function getDependencyTypeForError(type) {
  if (getComponentDef(type)) return "component";
  if (getDirectiveDef(type)) return "directive";
  if (getPipeDef$1(type)) return "pipe";
  return "type";
}
function verifyStandaloneImport(depType, importingType) {
  if (isForwardRef(depType)) {
    depType = resolveForwardRef(depType);
    if (!depType) {
      throw new Error(`Expected forwardRef function, imported from "${stringifyForError(importingType)}", to return a standalone entity or NgModule but got "${stringifyForError(depType) || depType}".`);
    }
  }
  if (getNgModuleDef(depType) == null) {
    const def = getComponentDef(depType) || getDirectiveDef(depType) || getPipeDef$1(depType);
    if (def != null) {
      if (!def.standalone) {
        throw new Error(`The "${stringifyForError(depType)}" ${getDependencyTypeForError(depType)}, imported from "${stringifyForError(importingType)}", is not standalone. Did you forget to add the standalone: true flag?`);
      }
    } else {
      if (isModuleWithProviders(depType)) {
        throw new Error(`A module with providers was imported from "${stringifyForError(importingType)}". Modules with providers are not supported in standalone components imports.`);
      } else {
        throw new Error(`The "${stringifyForError(depType)}" type, imported from "${stringifyForError(importingType)}", must be a standalone component / directive / pipe or an NgModule. Did you forget to add the required @Component / @Directive / @Pipe or @NgModule annotation?`);
      }
    }
  }
}
var USE_RUNTIME_DEPS_TRACKER_FOR_JIT = true;
var DepsTracker = class {
  constructor() {
    this.ownerNgModule = /* @__PURE__ */ new Map();
    this.ngModulesWithSomeUnresolvedDecls = /* @__PURE__ */ new Set();
    this.ngModulesScopeCache = /* @__PURE__ */ new Map();
    this.standaloneComponentsScopeCache = /* @__PURE__ */ new Map();
  }
  /**
   * Attempts to resolve ng module's forward ref declarations as much as possible and add them to
   * the `ownerNgModule` map. This method normally should be called after the initial parsing when
   * all the forward refs are resolved (e.g., when trying to render a component)
   */
  resolveNgModulesDecls() {
    if (this.ngModulesWithSomeUnresolvedDecls.size === 0) {
      return;
    }
    for (const moduleType of this.ngModulesWithSomeUnresolvedDecls) {
      const def = getNgModuleDef(moduleType);
      if (def?.declarations) {
        for (const decl of maybeUnwrapFn(def.declarations)) {
          if (isComponent(decl)) {
            this.ownerNgModule.set(decl, moduleType);
          }
        }
      }
    }
    this.ngModulesWithSomeUnresolvedDecls.clear();
  }
  /** @override */
  getComponentDependencies(type, rawImports) {
    this.resolveNgModulesDecls();
    const def = getComponentDef(type);
    if (def === null) {
      throw new Error(`Attempting to get component dependencies for a type that is not a component: ${type}`);
    }
    if (def.standalone) {
      const scope = this.getStandaloneComponentScope(type, rawImports);
      if (scope.compilation.isPoisoned) {
        return {
          dependencies: []
        };
      }
      return {
        dependencies: [...scope.compilation.directives, ...scope.compilation.pipes, ...scope.compilation.ngModules]
      };
    } else {
      if (!this.ownerNgModule.has(type)) {
        return {
          dependencies: []
        };
      }
      const scope = this.getNgModuleScope(this.ownerNgModule.get(type));
      if (scope.compilation.isPoisoned) {
        return {
          dependencies: []
        };
      }
      return {
        dependencies: [...scope.compilation.directives, ...scope.compilation.pipes]
      };
    }
  }
  /**
   * @override
   * This implementation does not make use of param scopeInfo since it assumes the scope info is
   * already added to the type itself through methods like {@link ɵɵsetNgModuleScope}
   */
  registerNgModule(type, scopeInfo) {
    if (!isNgModule(type)) {
      throw new Error(`Attempting to register a Type which is not NgModule as NgModule: ${type}`);
    }
    this.ngModulesWithSomeUnresolvedDecls.add(type);
  }
  /** @override */
  clearScopeCacheFor(type) {
    this.ngModulesScopeCache.delete(type);
    this.standaloneComponentsScopeCache.delete(type);
  }
  /** @override */
  getNgModuleScope(type) {
    if (this.ngModulesScopeCache.has(type)) {
      return this.ngModulesScopeCache.get(type);
    }
    const scope = this.computeNgModuleScope(type);
    this.ngModulesScopeCache.set(type, scope);
    return scope;
  }
  /** Compute NgModule scope afresh. */
  computeNgModuleScope(type) {
    const def = getNgModuleDef(type, true);
    const scope = {
      exported: {
        directives: /* @__PURE__ */ new Set(),
        pipes: /* @__PURE__ */ new Set()
      },
      compilation: {
        directives: /* @__PURE__ */ new Set(),
        pipes: /* @__PURE__ */ new Set()
      }
    };
    for (const imported of maybeUnwrapFn(def.imports)) {
      if (isNgModule(imported)) {
        const importedScope = this.getNgModuleScope(imported);
        addSet(importedScope.exported.directives, scope.compilation.directives);
        addSet(importedScope.exported.pipes, scope.compilation.pipes);
      } else if (isStandalone(imported)) {
        if (isDirective(imported) || isComponent(imported)) {
          scope.compilation.directives.add(imported);
        } else if (isPipe(imported)) {
          scope.compilation.pipes.add(imported);
        } else {
          throw new RuntimeError(1e3, "The standalone imported type is neither a component nor a directive nor a pipe");
        }
      } else {
        scope.compilation.isPoisoned = true;
        break;
      }
    }
    if (!scope.compilation.isPoisoned) {
      for (const decl of maybeUnwrapFn(def.declarations)) {
        if (isNgModule(decl) || isStandalone(decl)) {
          scope.compilation.isPoisoned = true;
          break;
        }
        if (isPipe(decl)) {
          scope.compilation.pipes.add(decl);
        } else {
          scope.compilation.directives.add(decl);
        }
      }
    }
    for (const exported of maybeUnwrapFn(def.exports)) {
      if (isNgModule(exported)) {
        const exportedScope = this.getNgModuleScope(exported);
        addSet(exportedScope.exported.directives, scope.exported.directives);
        addSet(exportedScope.exported.pipes, scope.exported.pipes);
        addSet(exportedScope.exported.directives, scope.compilation.directives);
        addSet(exportedScope.exported.pipes, scope.compilation.pipes);
      } else if (isPipe(exported)) {
        scope.exported.pipes.add(exported);
      } else {
        scope.exported.directives.add(exported);
      }
    }
    return scope;
  }
  /** @override */
  getStandaloneComponentScope(type, rawImports) {
    if (this.standaloneComponentsScopeCache.has(type)) {
      return this.standaloneComponentsScopeCache.get(type);
    }
    const ans = this.computeStandaloneComponentScope(type, rawImports);
    this.standaloneComponentsScopeCache.set(type, ans);
    return ans;
  }
  computeStandaloneComponentScope(type, rawImports) {
    const ans = {
      compilation: {
        // Standalone components are always able to self-reference.
        directives: /* @__PURE__ */ new Set([type]),
        pipes: /* @__PURE__ */ new Set(),
        ngModules: /* @__PURE__ */ new Set()
      }
    };
    for (const rawImport of flatten(rawImports ?? [])) {
      const imported = resolveForwardRef(rawImport);
      try {
        verifyStandaloneImport(imported, type);
      } catch (e) {
        ans.compilation.isPoisoned = true;
        return ans;
      }
      if (isNgModule(imported)) {
        ans.compilation.ngModules.add(imported);
        const importedScope = this.getNgModuleScope(imported);
        if (importedScope.exported.isPoisoned) {
          ans.compilation.isPoisoned = true;
          return ans;
        }
        addSet(importedScope.exported.directives, ans.compilation.directives);
        addSet(importedScope.exported.pipes, ans.compilation.pipes);
      } else if (isPipe(imported)) {
        ans.compilation.pipes.add(imported);
      } else if (isDirective(imported) || isComponent(imported)) {
        ans.compilation.directives.add(imported);
      } else {
        ans.compilation.isPoisoned = true;
        return ans;
      }
    }
    return ans;
  }
  /** @override */
  isOrphanComponent(cmp) {
    const def = getComponentDef(cmp);
    if (!def || def.standalone) {
      return false;
    }
    this.resolveNgModulesDecls();
    return !this.ownerNgModule.has(cmp);
  }
};
function addSet(sourceSet, targetSet) {
  for (const m of sourceSet) {
    targetSet.add(m);
  }
}
var depsTracker = new DepsTracker();
function computeStaticStyling(tNode, attrs, writeToHost) {
  ngDevMode && assertFirstCreatePass(getTView(), "Expecting to be called in first template pass only");
  let styles = writeToHost ? tNode.styles : null;
  let classes = writeToHost ? tNode.classes : null;
  let mode = 0;
  if (attrs !== null) {
    for (let i = 0; i < attrs.length; i++) {
      const value = attrs[i];
      if (typeof value === "number") {
        mode = value;
      } else if (mode == 1) {
        classes = concatStringsWithSpace(classes, value);
      } else if (mode == 2) {
        const style = value;
        const styleValue = attrs[++i];
        styles = concatStringsWithSpace(styles, style + ": " + styleValue + ";");
      }
    }
  }
  writeToHost ? tNode.styles = styles : tNode.stylesWithoutHost = styles;
  writeToHost ? tNode.classes = classes : tNode.classesWithoutHost = classes;
}
var ComponentFactoryResolver = class extends ComponentFactoryResolver$1 {
  /**
   * @param ngModule The NgModuleRef to which all resolved factories are bound.
   */
  constructor(ngModule) {
    super();
    this.ngModule = ngModule;
  }
  resolveComponentFactory(component) {
    ngDevMode && assertComponentType(component);
    const componentDef = getComponentDef(component);
    return new ComponentFactory(componentDef, this.ngModule);
  }
};
function toRefArray(map2, isInputMap) {
  const array = [];
  for (const publicName in map2) {
    if (!map2.hasOwnProperty(publicName)) {
      continue;
    }
    const value = map2[publicName];
    if (value === void 0) {
      continue;
    }
    const isArray = Array.isArray(value);
    const propName = isArray ? value[0] : value;
    const flags = isArray ? value[1] : InputFlags.None;
    if (isInputMap) {
      array.push({
        propName,
        templateName: publicName,
        isSignal: (flags & InputFlags.SignalBased) !== 0
      });
    } else {
      array.push({
        propName,
        templateName: publicName
      });
    }
  }
  return array;
}
function getNamespace(elementName) {
  const name = elementName.toLowerCase();
  return name === "svg" ? SVG_NAMESPACE : name === "math" ? MATH_ML_NAMESPACE : null;
}
var ComponentFactory = class extends ComponentFactory$1 {
  get inputs() {
    const componentDef = this.componentDef;
    const inputTransforms = componentDef.inputTransforms;
    const refArray = toRefArray(componentDef.inputs, true);
    if (inputTransforms !== null) {
      for (const input2 of refArray) {
        if (inputTransforms.hasOwnProperty(input2.propName)) {
          input2.transform = inputTransforms[input2.propName];
        }
      }
    }
    return refArray;
  }
  get outputs() {
    return toRefArray(this.componentDef.outputs, false);
  }
  /**
   * @param componentDef The component definition.
   * @param ngModule The NgModuleRef to which the factory is bound.
   */
  constructor(componentDef, ngModule) {
    super();
    this.componentDef = componentDef;
    this.ngModule = ngModule;
    this.componentType = componentDef.type;
    this.selector = stringifyCSSSelectorList(componentDef.selectors);
    this.ngContentSelectors = componentDef.ngContentSelectors ? componentDef.ngContentSelectors : [];
    this.isBoundToModule = !!ngModule;
  }
  create(injector, projectableNodes, rootSelectorOrNode, environmentInjector) {
    const prevConsumer = setActiveConsumer(null);
    try {
      if (ngDevMode && (typeof ngJitMode === "undefined" || ngJitMode) && this.componentDef.debugInfo?.forbidOrphanRendering) {
        if (depsTracker.isOrphanComponent(this.componentType)) {
          throw new RuntimeError(1001, `Orphan component found! Trying to render the component ${debugStringifyTypeForError(this.componentType)} without first loading the NgModule that declares it. It is recommended to make this component standalone in order to avoid this error. If this is not possible now, import the component's NgModule in the appropriate NgModule, or the standalone component in which you are trying to render this component. If this is a lazy import, load the NgModule lazily as well and use its module injector.`);
        }
      }
      environmentInjector = environmentInjector || this.ngModule;
      let realEnvironmentInjector = environmentInjector instanceof EnvironmentInjector ? environmentInjector : environmentInjector?.injector;
      if (realEnvironmentInjector && this.componentDef.getStandaloneInjector !== null) {
        realEnvironmentInjector = this.componentDef.getStandaloneInjector(realEnvironmentInjector) || realEnvironmentInjector;
      }
      const rootViewInjector = realEnvironmentInjector ? new ChainedInjector(injector, realEnvironmentInjector) : injector;
      const rendererFactory = rootViewInjector.get(RendererFactory2, null);
      if (rendererFactory === null) {
        throw new RuntimeError(407, ngDevMode && "Angular was not able to inject a renderer (RendererFactory2). Likely this is due to a broken DI hierarchy. Make sure that any injector used to create this component has a correct parent.");
      }
      const sanitizer = rootViewInjector.get(Sanitizer, null);
      const afterRenderEventManager = rootViewInjector.get(AfterRenderEventManager, null);
      const changeDetectionScheduler = rootViewInjector.get(ChangeDetectionScheduler, null);
      const environment = {
        rendererFactory,
        sanitizer,
        // We don't use inline effects (yet).
        inlineEffectRunner: null,
        afterRenderEventManager,
        changeDetectionScheduler
      };
      const hostRenderer = rendererFactory.createRenderer(null, this.componentDef);
      const elementName = this.componentDef.selectors[0][0] || "div";
      const hostRNode = rootSelectorOrNode ? locateHostElement(hostRenderer, rootSelectorOrNode, this.componentDef.encapsulation, rootViewInjector) : createElementNode(hostRenderer, elementName, getNamespace(elementName));
      let rootFlags = 512;
      if (this.componentDef.signals) {
        rootFlags |= 4096;
      } else if (!this.componentDef.onPush) {
        rootFlags |= 16;
      }
      let hydrationInfo = null;
      if (hostRNode !== null) {
        hydrationInfo = retrieveHydrationInfo(
          hostRNode,
          rootViewInjector,
          true
          /* isRootView */
        );
      }
      const rootTView = createTView(0, null, null, 1, 0, null, null, null, null, null, null);
      const rootLView = createLView(null, rootTView, null, rootFlags, null, null, environment, hostRenderer, rootViewInjector, null, hydrationInfo);
      enterView(rootLView);
      let component;
      let tElementNode;
      try {
        const rootComponentDef = this.componentDef;
        let rootDirectives;
        let hostDirectiveDefs = null;
        if (rootComponentDef.findHostDirectiveDefs) {
          rootDirectives = [];
          hostDirectiveDefs = /* @__PURE__ */ new Map();
          rootComponentDef.findHostDirectiveDefs(rootComponentDef, rootDirectives, hostDirectiveDefs);
          rootDirectives.push(rootComponentDef);
          ngDevMode && assertNoDuplicateDirectives(rootDirectives);
        } else {
          rootDirectives = [rootComponentDef];
        }
        const hostTNode = createRootComponentTNode(rootLView, hostRNode);
        const componentView = createRootComponentView(hostTNode, hostRNode, rootComponentDef, rootDirectives, rootLView, environment, hostRenderer);
        tElementNode = getTNode(rootTView, HEADER_OFFSET);
        if (hostRNode) {
          setRootNodeAttributes(hostRenderer, rootComponentDef, hostRNode, rootSelectorOrNode);
        }
        if (projectableNodes !== void 0) {
          projectNodes(tElementNode, this.ngContentSelectors, projectableNodes);
        }
        component = createRootComponent(componentView, rootComponentDef, rootDirectives, hostDirectiveDefs, rootLView, [LifecycleHooksFeature]);
        renderView(rootTView, rootLView, null);
      } finally {
        leaveView();
      }
      return new ComponentRef(this.componentType, component, createElementRef(tElementNode, rootLView), rootLView, tElementNode);
    } finally {
      setActiveConsumer(prevConsumer);
    }
  }
};
var ComponentRef = class extends ComponentRef$1 {
  constructor(componentType, instance, location2, _rootLView, _tNode) {
    super();
    this.location = location2;
    this._rootLView = _rootLView;
    this._tNode = _tNode;
    this.previousInputValues = null;
    this.instance = instance;
    this.hostView = this.changeDetectorRef = new ViewRef$1(
      _rootLView,
      void 0,
      false
      /* notifyErrorHandler */
    );
    this.componentType = componentType;
  }
  setInput(name, value) {
    const inputData = this._tNode.inputs;
    let dataValue;
    if (inputData !== null && (dataValue = inputData[name])) {
      this.previousInputValues ??= /* @__PURE__ */ new Map();
      if (this.previousInputValues.has(name) && Object.is(this.previousInputValues.get(name), value)) {
        return;
      }
      const lView = this._rootLView;
      setInputsForProperty(lView[TVIEW], lView, dataValue, name, value);
      this.previousInputValues.set(name, value);
      const childComponentLView = getComponentLViewByIndex(this._tNode.index, lView);
      markViewDirty(
        childComponentLView,
        1
        /* NotificationSource.SetInput */
      );
    } else {
      if (ngDevMode) {
        const cmpNameForError = stringifyForError(this.componentType);
        let message = `Can't set value of the '${name}' input on the '${cmpNameForError}' component. `;
        message += `Make sure that the '${name}' property is annotated with @Input() or a mapped @Input('${name}') exists.`;
        reportUnknownPropertyError(message);
      }
    }
  }
  get injector() {
    return new NodeInjector(this._tNode, this._rootLView);
  }
  destroy() {
    this.hostView.destroy();
  }
  onDestroy(callback) {
    this.hostView.onDestroy(callback);
  }
};
function createRootComponentTNode(lView, rNode) {
  const tView = lView[TVIEW];
  const index = HEADER_OFFSET;
  ngDevMode && assertIndexInRange(lView, index);
  lView[index] = rNode;
  return getOrCreateTNode(tView, index, 2, "#host", null);
}
function createRootComponentView(tNode, hostRNode, rootComponentDef, rootDirectives, rootView, environment, hostRenderer) {
  const tView = rootView[TVIEW];
  applyRootComponentStyling(rootDirectives, tNode, hostRNode, hostRenderer);
  let hydrationInfo = null;
  if (hostRNode !== null) {
    hydrationInfo = retrieveHydrationInfo(hostRNode, rootView[INJECTOR]);
  }
  const viewRenderer = environment.rendererFactory.createRenderer(hostRNode, rootComponentDef);
  let lViewFlags = 16;
  if (rootComponentDef.signals) {
    lViewFlags = 4096;
  } else if (rootComponentDef.onPush) {
    lViewFlags = 64;
  }
  const componentView = createLView(rootView, getOrCreateComponentTView(rootComponentDef), null, lViewFlags, rootView[tNode.index], tNode, environment, viewRenderer, null, null, hydrationInfo);
  if (tView.firstCreatePass) {
    markAsComponentHost(tView, tNode, rootDirectives.length - 1);
  }
  addToViewTree(rootView, componentView);
  return rootView[tNode.index] = componentView;
}
function applyRootComponentStyling(rootDirectives, tNode, rNode, hostRenderer) {
  for (const def of rootDirectives) {
    tNode.mergedAttrs = mergeHostAttrs(tNode.mergedAttrs, def.hostAttrs);
  }
  if (tNode.mergedAttrs !== null) {
    computeStaticStyling(tNode, tNode.mergedAttrs, true);
    if (rNode !== null) {
      setupStaticAttributes(hostRenderer, rNode, tNode);
    }
  }
}
function createRootComponent(componentView, rootComponentDef, rootDirectives, hostDirectiveDefs, rootLView, hostFeatures) {
  const rootTNode = getCurrentTNode();
  ngDevMode && assertDefined(rootTNode, "tNode should have been already created");
  const tView = rootLView[TVIEW];
  const native = getNativeByTNode(rootTNode, rootLView);
  initializeDirectives(tView, rootLView, rootTNode, rootDirectives, null, hostDirectiveDefs);
  for (let i = 0; i < rootDirectives.length; i++) {
    const directiveIndex = rootTNode.directiveStart + i;
    const directiveInstance = getNodeInjectable(rootLView, tView, directiveIndex, rootTNode);
    attachPatchData(directiveInstance, rootLView);
  }
  invokeDirectivesHostBindings(tView, rootLView, rootTNode);
  if (native) {
    attachPatchData(native, rootLView);
  }
  ngDevMode && assertGreaterThan(rootTNode.componentOffset, -1, "componentOffset must be great than -1");
  const component = getNodeInjectable(rootLView, tView, rootTNode.directiveStart + rootTNode.componentOffset, rootTNode);
  componentView[CONTEXT] = rootLView[CONTEXT] = component;
  if (hostFeatures !== null) {
    for (const feature of hostFeatures) {
      feature(component, rootComponentDef);
    }
  }
  executeContentQueries(tView, rootTNode, rootLView);
  return component;
}
function setRootNodeAttributes(hostRenderer, componentDef, hostRNode, rootSelectorOrNode) {
  if (rootSelectorOrNode) {
    setUpAttributes(hostRenderer, hostRNode, ["ng-version", "18.2.0"]);
  } else {
    const {
      attrs,
      classes
    } = extractAttrsAndClassesFromSelector(componentDef.selectors[0]);
    if (attrs) {
      setUpAttributes(hostRenderer, hostRNode, attrs);
    }
    if (classes && classes.length > 0) {
      writeDirectClass(hostRenderer, hostRNode, classes.join(" "));
    }
  }
}
function projectNodes(tNode, ngContentSelectors, projectableNodes) {
  const projection = tNode.projection = [];
  for (let i = 0; i < ngContentSelectors.length; i++) {
    const nodesforSlot = projectableNodes[i];
    projection.push(nodesforSlot != null ? Array.from(nodesforSlot) : null);
  }
}
function LifecycleHooksFeature() {
  const tNode = getCurrentTNode();
  ngDevMode && assertDefined(tNode, "TNode is required");
  registerPostOrderHooks(getLView()[TVIEW], tNode);
}
var ViewContainerRef = class {
  static {
    this.__NG_ELEMENT_ID__ = injectViewContainerRef;
  }
};
function injectViewContainerRef() {
  const previousTNode = getCurrentTNode();
  return createContainerRef(previousTNode, getLView());
}
var VE_ViewContainerRef = ViewContainerRef;
var R3ViewContainerRef = class ViewContainerRef2 extends VE_ViewContainerRef {
  constructor(_lContainer, _hostTNode, _hostLView) {
    super();
    this._lContainer = _lContainer;
    this._hostTNode = _hostTNode;
    this._hostLView = _hostLView;
  }
  get element() {
    return createElementRef(this._hostTNode, this._hostLView);
  }
  get injector() {
    return new NodeInjector(this._hostTNode, this._hostLView);
  }
  /** @deprecated No replacement */
  get parentInjector() {
    const parentLocation = getParentInjectorLocation(this._hostTNode, this._hostLView);
    if (hasParentInjector(parentLocation)) {
      const parentView = getParentInjectorView(parentLocation, this._hostLView);
      const injectorIndex = getParentInjectorIndex(parentLocation);
      ngDevMode && assertNodeInjector(parentView, injectorIndex);
      const parentTNode = parentView[TVIEW].data[
        injectorIndex + 8
        /* NodeInjectorOffset.TNODE */
      ];
      return new NodeInjector(parentTNode, parentView);
    } else {
      return new NodeInjector(null, this._hostLView);
    }
  }
  clear() {
    while (this.length > 0) {
      this.remove(this.length - 1);
    }
  }
  get(index) {
    const viewRefs = getViewRefs(this._lContainer);
    return viewRefs !== null && viewRefs[index] || null;
  }
  get length() {
    return this._lContainer.length - CONTAINER_HEADER_OFFSET;
  }
  createEmbeddedView(templateRef, context, indexOrOptions) {
    let index;
    let injector;
    if (typeof indexOrOptions === "number") {
      index = indexOrOptions;
    } else if (indexOrOptions != null) {
      index = indexOrOptions.index;
      injector = indexOrOptions.injector;
    }
    const dehydratedView = findMatchingDehydratedView(this._lContainer, templateRef.ssrId);
    const viewRef = templateRef.createEmbeddedViewImpl(context || {}, injector, dehydratedView);
    this.insertImpl(viewRef, index, shouldAddViewToDom(this._hostTNode, dehydratedView));
    return viewRef;
  }
  createComponent(componentFactoryOrType, indexOrOptions, injector, projectableNodes, environmentInjector) {
    const isComponentFactory = componentFactoryOrType && !isType(componentFactoryOrType);
    let index;
    if (isComponentFactory) {
      if (ngDevMode) {
        assertEqual(typeof indexOrOptions !== "object", true, "It looks like Component factory was provided as the first argument and an options object as the second argument. This combination of arguments is incompatible. You can either change the first argument to provide Component type or change the second argument to be a number (representing an index at which to insert the new component's host view into this container)");
      }
      index = indexOrOptions;
    } else {
      if (ngDevMode) {
        assertDefined(getComponentDef(componentFactoryOrType), `Provided Component class doesn't contain Component definition. Please check whether provided class has @Component decorator.`);
        assertEqual(typeof indexOrOptions !== "number", true, "It looks like Component type was provided as the first argument and a number (representing an index at which to insert the new component's host view into this container as the second argument. This combination of arguments is incompatible. Please use an object as the second argument instead.");
      }
      const options = indexOrOptions || {};
      if (ngDevMode && options.environmentInjector && options.ngModuleRef) {
        throwError(`Cannot pass both environmentInjector and ngModuleRef options to createComponent().`);
      }
      index = options.index;
      injector = options.injector;
      projectableNodes = options.projectableNodes;
      environmentInjector = options.environmentInjector || options.ngModuleRef;
    }
    const componentFactory = isComponentFactory ? componentFactoryOrType : new ComponentFactory(getComponentDef(componentFactoryOrType));
    const contextInjector = injector || this.parentInjector;
    if (!environmentInjector && componentFactory.ngModule == null) {
      const _injector = isComponentFactory ? contextInjector : this.parentInjector;
      const result = _injector.get(EnvironmentInjector, null);
      if (result) {
        environmentInjector = result;
      }
    }
    const componentDef = getComponentDef(componentFactory.componentType ?? {});
    const dehydratedView = findMatchingDehydratedView(this._lContainer, componentDef?.id ?? null);
    const rNode = dehydratedView?.firstChild ?? null;
    const componentRef = componentFactory.create(contextInjector, projectableNodes, rNode, environmentInjector);
    this.insertImpl(componentRef.hostView, index, shouldAddViewToDom(this._hostTNode, dehydratedView));
    return componentRef;
  }
  insert(viewRef, index) {
    return this.insertImpl(viewRef, index, true);
  }
  insertImpl(viewRef, index, addToDOM) {
    const lView = viewRef._lView;
    if (ngDevMode && viewRef.destroyed) {
      throw new Error("Cannot insert a destroyed View in a ViewContainer!");
    }
    if (viewAttachedToContainer(lView)) {
      const prevIdx = this.indexOf(viewRef);
      if (prevIdx !== -1) {
        this.detach(prevIdx);
      } else {
        const prevLContainer = lView[PARENT];
        ngDevMode && assertEqual(isLContainer(prevLContainer), true, "An attached view should have its PARENT point to a container.");
        const prevVCRef = new R3ViewContainerRef(prevLContainer, prevLContainer[T_HOST], prevLContainer[PARENT]);
        prevVCRef.detach(prevVCRef.indexOf(viewRef));
      }
    }
    const adjustedIdx = this._adjustIndex(index);
    const lContainer = this._lContainer;
    addLViewToLContainer(lContainer, lView, adjustedIdx, addToDOM);
    viewRef.attachToViewContainerRef();
    addToArray(getOrCreateViewRefs(lContainer), adjustedIdx, viewRef);
    return viewRef;
  }
  move(viewRef, newIndex) {
    if (ngDevMode && viewRef.destroyed) {
      throw new Error("Cannot move a destroyed View in a ViewContainer!");
    }
    return this.insert(viewRef, newIndex);
  }
  indexOf(viewRef) {
    const viewRefsArr = getViewRefs(this._lContainer);
    return viewRefsArr !== null ? viewRefsArr.indexOf(viewRef) : -1;
  }
  remove(index) {
    const adjustedIdx = this._adjustIndex(index, -1);
    const detachedView = detachView(this._lContainer, adjustedIdx);
    if (detachedView) {
      removeFromArray(getOrCreateViewRefs(this._lContainer), adjustedIdx);
      destroyLView(detachedView[TVIEW], detachedView);
    }
  }
  detach(index) {
    const adjustedIdx = this._adjustIndex(index, -1);
    const view = detachView(this._lContainer, adjustedIdx);
    const wasDetached = view && removeFromArray(getOrCreateViewRefs(this._lContainer), adjustedIdx) != null;
    return wasDetached ? new ViewRef$1(view) : null;
  }
  _adjustIndex(index, shift = 0) {
    if (index == null) {
      return this.length + shift;
    }
    if (ngDevMode) {
      assertGreaterThan(index, -1, `ViewRef index must be positive, got ${index}`);
      assertLessThan(index, this.length + 1 + shift, "index");
    }
    return index;
  }
};
function getViewRefs(lContainer) {
  return lContainer[VIEW_REFS];
}
function getOrCreateViewRefs(lContainer) {
  return lContainer[VIEW_REFS] || (lContainer[VIEW_REFS] = []);
}
function createContainerRef(hostTNode, hostLView) {
  ngDevMode && assertTNodeType(
    hostTNode,
    12 | 3
    /* TNodeType.AnyRNode */
  );
  let lContainer;
  const slotValue = hostLView[hostTNode.index];
  if (isLContainer(slotValue)) {
    lContainer = slotValue;
  } else {
    lContainer = createLContainer(slotValue, hostLView, null, hostTNode);
    hostLView[hostTNode.index] = lContainer;
    addToViewTree(hostLView, lContainer);
  }
  _locateOrCreateAnchorNode(lContainer, hostLView, hostTNode, slotValue);
  return new R3ViewContainerRef(lContainer, hostTNode, hostLView);
}
function insertAnchorNode(hostLView, hostTNode) {
  const renderer = hostLView[RENDERER];
  ngDevMode && ngDevMode.rendererCreateComment++;
  const commentNode = renderer.createComment(ngDevMode ? "container" : "");
  const hostNative = getNativeByTNode(hostTNode, hostLView);
  const parentOfHostNative = nativeParentNode(renderer, hostNative);
  nativeInsertBefore(renderer, parentOfHostNative, commentNode, nativeNextSibling(renderer, hostNative), false);
  return commentNode;
}
var _locateOrCreateAnchorNode = createAnchorNode;
var _populateDehydratedViewsInLContainer = () => false;
function populateDehydratedViewsInLContainer(lContainer, tNode, hostLView) {
  return _populateDehydratedViewsInLContainer(lContainer, tNode, hostLView);
}
function createAnchorNode(lContainer, hostLView, hostTNode, slotValue) {
  if (lContainer[NATIVE]) return;
  let commentNode;
  if (hostTNode.type & 8) {
    commentNode = unwrapRNode(slotValue);
  } else {
    commentNode = insertAnchorNode(hostLView, hostTNode);
  }
  lContainer[NATIVE] = commentNode;
}
var LQuery_ = class _LQuery_ {
  constructor(queryList) {
    this.queryList = queryList;
    this.matches = null;
  }
  clone() {
    return new _LQuery_(this.queryList);
  }
  setDirty() {
    this.queryList.setDirty();
  }
};
var LQueries_ = class _LQueries_ {
  constructor(queries = []) {
    this.queries = queries;
  }
  createEmbeddedView(tView) {
    const tQueries = tView.queries;
    if (tQueries !== null) {
      const noOfInheritedQueries = tView.contentQueries !== null ? tView.contentQueries[0] : tQueries.length;
      const viewLQueries = [];
      for (let i = 0; i < noOfInheritedQueries; i++) {
        const tQuery = tQueries.getByIndex(i);
        const parentLQuery = this.queries[tQuery.indexInDeclarationView];
        viewLQueries.push(parentLQuery.clone());
      }
      return new _LQueries_(viewLQueries);
    }
    return null;
  }
  insertView(tView) {
    this.dirtyQueriesWithMatches(tView);
  }
  detachView(tView) {
    this.dirtyQueriesWithMatches(tView);
  }
  finishViewCreation(tView) {
    this.dirtyQueriesWithMatches(tView);
  }
  dirtyQueriesWithMatches(tView) {
    for (let i = 0; i < this.queries.length; i++) {
      if (getTQuery(tView, i).matches !== null) {
        this.queries[i].setDirty();
      }
    }
  }
};
var TQueryMetadata_ = class {
  constructor(predicate, flags, read = null) {
    this.flags = flags;
    this.read = read;
    if (typeof predicate === "string") {
      this.predicate = splitQueryMultiSelectors(predicate);
    } else {
      this.predicate = predicate;
    }
  }
};
var TQueries_ = class _TQueries_ {
  constructor(queries = []) {
    this.queries = queries;
  }
  elementStart(tView, tNode) {
    ngDevMode && assertFirstCreatePass(tView, "Queries should collect results on the first template pass only");
    for (let i = 0; i < this.queries.length; i++) {
      this.queries[i].elementStart(tView, tNode);
    }
  }
  elementEnd(tNode) {
    for (let i = 0; i < this.queries.length; i++) {
      this.queries[i].elementEnd(tNode);
    }
  }
  embeddedTView(tNode) {
    let queriesForTemplateRef = null;
    for (let i = 0; i < this.length; i++) {
      const childQueryIndex = queriesForTemplateRef !== null ? queriesForTemplateRef.length : 0;
      const tqueryClone = this.getByIndex(i).embeddedTView(tNode, childQueryIndex);
      if (tqueryClone) {
        tqueryClone.indexInDeclarationView = i;
        if (queriesForTemplateRef !== null) {
          queriesForTemplateRef.push(tqueryClone);
        } else {
          queriesForTemplateRef = [tqueryClone];
        }
      }
    }
    return queriesForTemplateRef !== null ? new _TQueries_(queriesForTemplateRef) : null;
  }
  template(tView, tNode) {
    ngDevMode && assertFirstCreatePass(tView, "Queries should collect results on the first template pass only");
    for (let i = 0; i < this.queries.length; i++) {
      this.queries[i].template(tView, tNode);
    }
  }
  getByIndex(index) {
    ngDevMode && assertIndexInRange(this.queries, index);
    return this.queries[index];
  }
  get length() {
    return this.queries.length;
  }
  track(tquery) {
    this.queries.push(tquery);
  }
};
var TQuery_ = class _TQuery_ {
  constructor(metadata, nodeIndex = -1) {
    this.metadata = metadata;
    this.matches = null;
    this.indexInDeclarationView = -1;
    this.crossesNgTemplate = false;
    this._appliesToNextNode = true;
    this._declarationNodeIndex = nodeIndex;
  }
  elementStart(tView, tNode) {
    if (this.isApplyingToNode(tNode)) {
      this.matchTNode(tView, tNode);
    }
  }
  elementEnd(tNode) {
    if (this._declarationNodeIndex === tNode.index) {
      this._appliesToNextNode = false;
    }
  }
  template(tView, tNode) {
    this.elementStart(tView, tNode);
  }
  embeddedTView(tNode, childQueryIndex) {
    if (this.isApplyingToNode(tNode)) {
      this.crossesNgTemplate = true;
      this.addMatch(-tNode.index, childQueryIndex);
      return new _TQuery_(this.metadata);
    }
    return null;
  }
  isApplyingToNode(tNode) {
    if (this._appliesToNextNode && (this.metadata.flags & 1) !== 1) {
      const declarationNodeIdx = this._declarationNodeIndex;
      let parent = tNode.parent;
      while (parent !== null && parent.type & 8 && parent.index !== declarationNodeIdx) {
        parent = parent.parent;
      }
      return declarationNodeIdx === (parent !== null ? parent.index : -1);
    }
    return this._appliesToNextNode;
  }
  matchTNode(tView, tNode) {
    const predicate = this.metadata.predicate;
    if (Array.isArray(predicate)) {
      for (let i = 0; i < predicate.length; i++) {
        const name = predicate[i];
        this.matchTNodeWithReadOption(tView, tNode, getIdxOfMatchingSelector(tNode, name));
        this.matchTNodeWithReadOption(tView, tNode, locateDirectiveOrProvider(tNode, tView, name, false, false));
      }
    } else {
      if (predicate === TemplateRef) {
        if (tNode.type & 4) {
          this.matchTNodeWithReadOption(tView, tNode, -1);
        }
      } else {
        this.matchTNodeWithReadOption(tView, tNode, locateDirectiveOrProvider(tNode, tView, predicate, false, false));
      }
    }
  }
  matchTNodeWithReadOption(tView, tNode, nodeMatchIdx) {
    if (nodeMatchIdx !== null) {
      const read = this.metadata.read;
      if (read !== null) {
        if (read === ElementRef || read === ViewContainerRef || read === TemplateRef && tNode.type & 4) {
          this.addMatch(tNode.index, -2);
        } else {
          const directiveOrProviderIdx = locateDirectiveOrProvider(tNode, tView, read, false, false);
          if (directiveOrProviderIdx !== null) {
            this.addMatch(tNode.index, directiveOrProviderIdx);
          }
        }
      } else {
        this.addMatch(tNode.index, nodeMatchIdx);
      }
    }
  }
  addMatch(tNodeIdx, matchIdx) {
    if (this.matches === null) {
      this.matches = [tNodeIdx, matchIdx];
    } else {
      this.matches.push(tNodeIdx, matchIdx);
    }
  }
};
function getIdxOfMatchingSelector(tNode, selector) {
  const localNames = tNode.localNames;
  if (localNames !== null) {
    for (let i = 0; i < localNames.length; i += 2) {
      if (localNames[i] === selector) {
        return localNames[i + 1];
      }
    }
  }
  return null;
}
function createResultByTNodeType(tNode, currentView) {
  if (tNode.type & (3 | 8)) {
    return createElementRef(tNode, currentView);
  } else if (tNode.type & 4) {
    return createTemplateRef(tNode, currentView);
  }
  return null;
}
function createResultForNode(lView, tNode, matchingIdx, read) {
  if (matchingIdx === -1) {
    return createResultByTNodeType(tNode, lView);
  } else if (matchingIdx === -2) {
    return createSpecialToken(lView, tNode, read);
  } else {
    return getNodeInjectable(lView, lView[TVIEW], matchingIdx, tNode);
  }
}
function createSpecialToken(lView, tNode, read) {
  if (read === ElementRef) {
    return createElementRef(tNode, lView);
  } else if (read === TemplateRef) {
    return createTemplateRef(tNode, lView);
  } else if (read === ViewContainerRef) {
    ngDevMode && assertTNodeType(
      tNode,
      3 | 12
      /* TNodeType.AnyContainer */
    );
    return createContainerRef(tNode, lView);
  } else {
    ngDevMode && throwError(`Special token to read should be one of ElementRef, TemplateRef or ViewContainerRef but got ${stringify(read)}.`);
  }
}
function materializeViewResults(tView, lView, tQuery, queryIndex) {
  const lQuery = lView[QUERIES].queries[queryIndex];
  if (lQuery.matches === null) {
    const tViewData = tView.data;
    const tQueryMatches = tQuery.matches;
    const result = [];
    for (let i = 0; tQueryMatches !== null && i < tQueryMatches.length; i += 2) {
      const matchedNodeIdx = tQueryMatches[i];
      if (matchedNodeIdx < 0) {
        result.push(null);
      } else {
        ngDevMode && assertIndexInRange(tViewData, matchedNodeIdx);
        const tNode = tViewData[matchedNodeIdx];
        result.push(createResultForNode(lView, tNode, tQueryMatches[i + 1], tQuery.metadata.read));
      }
    }
    lQuery.matches = result;
  }
  return lQuery.matches;
}
function collectQueryResults(tView, lView, queryIndex, result) {
  const tQuery = tView.queries.getByIndex(queryIndex);
  const tQueryMatches = tQuery.matches;
  if (tQueryMatches !== null) {
    const lViewResults = materializeViewResults(tView, lView, tQuery, queryIndex);
    for (let i = 0; i < tQueryMatches.length; i += 2) {
      const tNodeIdx = tQueryMatches[i];
      if (tNodeIdx > 0) {
        result.push(lViewResults[i / 2]);
      } else {
        const childQueryIndex = tQueryMatches[i + 1];
        const declarationLContainer = lView[-tNodeIdx];
        ngDevMode && assertLContainer(declarationLContainer);
        for (let i2 = CONTAINER_HEADER_OFFSET; i2 < declarationLContainer.length; i2++) {
          const embeddedLView = declarationLContainer[i2];
          if (embeddedLView[DECLARATION_LCONTAINER] === embeddedLView[PARENT]) {
            collectQueryResults(embeddedLView[TVIEW], embeddedLView, childQueryIndex, result);
          }
        }
        if (declarationLContainer[MOVED_VIEWS] !== null) {
          const embeddedLViews = declarationLContainer[MOVED_VIEWS];
          for (let i2 = 0; i2 < embeddedLViews.length; i2++) {
            const embeddedLView = embeddedLViews[i2];
            collectQueryResults(embeddedLView[TVIEW], embeddedLView, childQueryIndex, result);
          }
        }
      }
    }
  }
  return result;
}
function loadQueryInternal(lView, queryIndex) {
  ngDevMode && assertDefined(lView[QUERIES], "LQueries should be defined when trying to load a query");
  ngDevMode && assertIndexInRange(lView[QUERIES].queries, queryIndex);
  return lView[QUERIES].queries[queryIndex].queryList;
}
function createLQuery(tView, lView, flags) {
  const queryList = new QueryList(
    (flags & 4) === 4
    /* QueryFlags.emitDistinctChangesOnly */
  );
  storeCleanupWithContext(tView, lView, queryList, queryList.destroy);
  const lQueries = (lView[QUERIES] ??= new LQueries_()).queries;
  return lQueries.push(new LQuery_(queryList)) - 1;
}
function createViewQuery(predicate, flags, read) {
  ngDevMode && assertNumber(flags, "Expecting flags");
  const tView = getTView();
  if (tView.firstCreatePass) {
    createTQuery(tView, new TQueryMetadata_(predicate, flags, read), -1);
    if ((flags & 2) === 2) {
      tView.staticViewQueries = true;
    }
  }
  return createLQuery(tView, getLView(), flags);
}
function createContentQuery(directiveIndex, predicate, flags, read) {
  ngDevMode && assertNumber(flags, "Expecting flags");
  const tView = getTView();
  if (tView.firstCreatePass) {
    const tNode = getCurrentTNode();
    createTQuery(tView, new TQueryMetadata_(predicate, flags, read), tNode.index);
    saveContentQueryAndDirectiveIndex(tView, directiveIndex);
    if ((flags & 2) === 2) {
      tView.staticContentQueries = true;
    }
  }
  return createLQuery(tView, getLView(), flags);
}
function splitQueryMultiSelectors(locator) {
  return locator.split(",").map((s) => s.trim());
}
function createTQuery(tView, metadata, nodeIndex) {
  if (tView.queries === null) tView.queries = new TQueries_();
  tView.queries.track(new TQuery_(metadata, nodeIndex));
}
function saveContentQueryAndDirectiveIndex(tView, directiveIndex) {
  const tViewContentQueries = tView.contentQueries || (tView.contentQueries = []);
  const lastSavedDirectiveIndex = tViewContentQueries.length ? tViewContentQueries[tViewContentQueries.length - 1] : -1;
  if (directiveIndex !== lastSavedDirectiveIndex) {
    tViewContentQueries.push(tView.queries.length - 1, directiveIndex);
  }
}
function getTQuery(tView, index) {
  ngDevMode && assertDefined(tView.queries, "TQueries must be defined to retrieve a TQuery");
  return tView.queries.getByIndex(index);
}
function getQueryResults(lView, queryIndex) {
  const tView = lView[TVIEW];
  const tQuery = getTQuery(tView, queryIndex);
  return tQuery.crossesNgTemplate ? collectQueryResults(tView, lView, queryIndex, []) : materializeViewResults(tView, lView, tQuery, queryIndex);
}
function isSignal(value) {
  return typeof value === "function" && value[SIGNAL] !== void 0;
}
var ɵWRITABLE_SIGNAL = Symbol("WRITABLE_SIGNAL");
function signal(initialValue, options) {
  performanceMarkFeature("NgSignals");
  const signalFn = createSignal(initialValue);
  const node = signalFn[SIGNAL];
  if (options?.equal) {
    node.equal = options.equal;
  }
  signalFn.set = (newValue) => signalSetFn(node, newValue);
  signalFn.update = (updateFn) => signalUpdateFn(node, updateFn);
  signalFn.asReadonly = signalAsReadonlyFn.bind(signalFn);
  if (ngDevMode) {
    signalFn.toString = () => `[Signal: ${signalFn()}]`;
  }
  return signalFn;
}
function signalAsReadonlyFn() {
  const node = this[SIGNAL];
  if (node.readonlyFn === void 0) {
    const readonlyFn = () => this();
    readonlyFn[SIGNAL] = node;
    node.readonlyFn = readonlyFn;
  }
  return node.readonlyFn;
}
function isWritableSignal(value) {
  return isSignal(value) && typeof value.set === "function";
}
function createQuerySignalFn(firstOnly, required) {
  let node;
  const signalFn = createComputed(() => {
    node._dirtyCounter();
    const value = refreshSignalQuery(node, firstOnly);
    if (required && value === void 0) {
      throw new RuntimeError(-951, ngDevMode && "Child query result is required but no value is available.");
    }
    return value;
  });
  node = signalFn[SIGNAL];
  node._dirtyCounter = signal(0);
  node._flatValue = void 0;
  if (ngDevMode) {
    signalFn.toString = () => `[Query Signal]`;
  }
  return signalFn;
}
function createSingleResultOptionalQuerySignalFn() {
  return createQuerySignalFn(
    /* firstOnly */
    true,
    /* required */
    false
  );
}
function createSingleResultRequiredQuerySignalFn() {
  return createQuerySignalFn(
    /* firstOnly */
    true,
    /* required */
    true
  );
}
function createMultiResultQuerySignalFn() {
  return createQuerySignalFn(
    /* firstOnly */
    false,
    /* required */
    false
  );
}
function bindQueryToSignal(target, queryIndex) {
  const node = target[SIGNAL];
  node._lView = getLView();
  node._queryIndex = queryIndex;
  node._queryList = loadQueryInternal(node._lView, queryIndex);
  node._queryList.onDirty(() => node._dirtyCounter.update((v) => v + 1));
}
function refreshSignalQuery(node, firstOnly) {
  const lView = node._lView;
  const queryIndex = node._queryIndex;
  if (lView === void 0 || queryIndex === void 0 || lView[FLAGS] & 4) {
    return firstOnly ? void 0 : EMPTY_ARRAY;
  }
  const queryList = loadQueryInternal(lView, queryIndex);
  const results = getQueryResults(lView, queryIndex);
  queryList.reset(results, unwrapElementRef);
  if (firstOnly) {
    return queryList.first;
  } else {
    const resultChanged = queryList._changesDetected;
    if (resultChanged || node._flatValue === void 0) {
      return node._flatValue = queryList.toArray();
    }
    return node._flatValue;
  }
}
function viewChildFn(locator, opts) {
  ngDevMode && assertInInjectionContext(viewChild);
  return createSingleResultOptionalQuerySignalFn();
}
function viewChildRequiredFn(locator, opts) {
  ngDevMode && assertInInjectionContext(viewChild);
  return createSingleResultRequiredQuerySignalFn();
}
var viewChild = (() => {
  viewChildFn.required = viewChildRequiredFn;
  return viewChildFn;
})();
function contentChildFn(locator, opts) {
  ngDevMode && assertInInjectionContext(contentChild);
  return createSingleResultOptionalQuerySignalFn();
}
function contentChildRequiredFn(locator, opts) {
  ngDevMode && assertInInjectionContext(contentChildren);
  return createSingleResultRequiredQuerySignalFn();
}
var contentChild = (() => {
  contentChildFn.required = contentChildRequiredFn;
  return contentChildFn;
})();
function contentChildren(locator, opts) {
  return createMultiResultQuerySignalFn();
}
function createModelSignal(initialValue) {
  const node = Object.create(INPUT_SIGNAL_NODE);
  const emitterRef = new OutputEmitterRef();
  node.value = initialValue;
  function getter() {
    producerAccessed(node);
    assertModelSet(node.value);
    return node.value;
  }
  getter[SIGNAL] = node;
  getter.asReadonly = signalAsReadonlyFn.bind(getter);
  getter.set = (newValue) => {
    if (!node.equal(node.value, newValue)) {
      signalSetFn(node, newValue);
      emitterRef.emit(newValue);
    }
  };
  getter.update = (updateFn) => {
    assertModelSet(node.value);
    getter.set(updateFn(node.value));
  };
  getter.subscribe = emitterRef.subscribe.bind(emitterRef);
  getter.destroyRef = emitterRef.destroyRef;
  if (ngDevMode) {
    getter.toString = () => `[Model Signal: ${getter()}]`;
  }
  return getter;
}
function assertModelSet(value) {
  if (value === REQUIRED_UNSET_VALUE) {
    throw new RuntimeError(952, ngDevMode && "Model is required but no value is available yet.");
  }
}
function modelFunction(initialValue) {
  ngDevMode && assertInInjectionContext(model);
  return createModelSignal(initialValue);
}
function modelRequiredFunction() {
  ngDevMode && assertInInjectionContext(model);
  return createModelSignal(REQUIRED_UNSET_VALUE);
}
var model = (() => {
  modelFunction.required = modelRequiredFunction;
  return modelFunction;
})();
var emitDistinctChangesOnlyDefaultValue = true;
var Query = class {
};
var ContentChildren = makePropDecorator("ContentChildren", (selector, opts = {}) => __spreadValues({
  selector,
  first: false,
  isViewQuery: false,
  descendants: false,
  emitDistinctChangesOnly: emitDistinctChangesOnlyDefaultValue
}, opts), Query);
var ContentChild = makePropDecorator("ContentChild", (selector, opts = {}) => __spreadValues({
  selector,
  first: true,
  isViewQuery: false,
  descendants: true
}, opts), Query);
var ViewChildren = makePropDecorator("ViewChildren", (selector, opts = {}) => __spreadValues({
  selector,
  first: false,
  isViewQuery: true,
  descendants: true,
  emitDistinctChangesOnly: emitDistinctChangesOnlyDefaultValue
}, opts), Query);
var ViewChild = makePropDecorator("ViewChild", (selector, opts) => __spreadValues({
  selector,
  first: true,
  isViewQuery: true,
  descendants: true
}, opts), Query);
function resolveComponentResources(resourceResolver) {
  const componentResolved = [];
  const urlMap = /* @__PURE__ */ new Map();
  function cachedResourceResolve(url) {
    let promise = urlMap.get(url);
    if (!promise) {
      const resp = resourceResolver(url);
      urlMap.set(url, promise = resp.then(unwrapResponse));
    }
    return promise;
  }
  componentResourceResolutionQueue.forEach((component, type) => {
    const promises = [];
    if (component.templateUrl) {
      promises.push(cachedResourceResolve(component.templateUrl).then((template) => {
        component.template = template;
      }));
    }
    const styles = typeof component.styles === "string" ? [component.styles] : component.styles || [];
    component.styles = styles;
    if (component.styleUrl && component.styleUrls?.length) {
      throw new Error("@Component cannot define both `styleUrl` and `styleUrls`. Use `styleUrl` if the component has one stylesheet, or `styleUrls` if it has multiple");
    } else if (component.styleUrls?.length) {
      const styleOffset = component.styles.length;
      const styleUrls = component.styleUrls;
      component.styleUrls.forEach((styleUrl, index) => {
        styles.push("");
        promises.push(cachedResourceResolve(styleUrl).then((style) => {
          styles[styleOffset + index] = style;
          styleUrls.splice(styleUrls.indexOf(styleUrl), 1);
          if (styleUrls.length == 0) {
            component.styleUrls = void 0;
          }
        }));
      });
    } else if (component.styleUrl) {
      promises.push(cachedResourceResolve(component.styleUrl).then((style) => {
        styles.push(style);
        component.styleUrl = void 0;
      }));
    }
    const fullyResolved = Promise.all(promises).then(() => componentDefResolved(type));
    componentResolved.push(fullyResolved);
  });
  clearResolutionOfComponentResourcesQueue();
  return Promise.all(componentResolved).then(() => void 0);
}
var componentResourceResolutionQueue = /* @__PURE__ */ new Map();
var componentDefPendingResolution = /* @__PURE__ */ new Set();
function maybeQueueResolutionOfComponentResources(type, metadata) {
  if (componentNeedsResolution(metadata)) {
    componentResourceResolutionQueue.set(type, metadata);
    componentDefPendingResolution.add(type);
  }
}
function componentNeedsResolution(component) {
  return !!(component.templateUrl && !component.hasOwnProperty("template") || component.styleUrls && component.styleUrls.length || component.styleUrl);
}
function clearResolutionOfComponentResourcesQueue() {
  const old = componentResourceResolutionQueue;
  componentResourceResolutionQueue = /* @__PURE__ */ new Map();
  return old;
}
function isComponentResourceResolutionQueueEmpty() {
  return componentResourceResolutionQueue.size === 0;
}
function unwrapResponse(response) {
  return typeof response == "string" ? response : response.text();
}
function componentDefResolved(type) {
  componentDefPendingResolution.delete(type);
}
var modules = /* @__PURE__ */ new Map();
var checkForDuplicateNgModules = true;
function assertSameOrNotExisting(id, type, incoming) {
  if (type && type !== incoming && checkForDuplicateNgModules) {
    throw new Error(`Duplicate module registered for ${id} - ${stringify(type)} vs ${stringify(type.name)}`);
  }
}
function registerNgModuleType(ngModuleType, id) {
  const existing = modules.get(id) || null;
  assertSameOrNotExisting(id, existing, ngModuleType);
  modules.set(id, ngModuleType);
}
function ɵɵvalidateIframeAttribute(attrValue, tagName, attrName) {
  const lView = getLView();
  const tNode = getSelectedTNode();
  const element = getNativeByTNode(tNode, lView);
  if (tNode.type === 2 && tagName.toLowerCase() === "iframe") {
    const iframe = element;
    iframe.src = "";
    iframe.srcdoc = trustedHTMLFromString("");
    nativeRemoveNode(lView[RENDERER], iframe);
    const errorMessage = ngDevMode && `Angular has detected that the \`${attrName}\` was applied as a binding to an <iframe>${getTemplateLocationDetails(lView)}. For security reasons, the \`${attrName}\` can be set on an <iframe> as a static attribute only. 
To fix this, switch the \`${attrName}\` binding to a static attribute in a template or in host bindings section.`;
    throw new RuntimeError(-910, errorMessage);
  }
  return attrValue;
}
function getSuperType(type) {
  return Object.getPrototypeOf(type.prototype).constructor;
}
function ɵɵInheritDefinitionFeature(definition) {
  let superType = getSuperType(definition.type);
  let shouldInheritFields = true;
  const inheritanceChain = [definition];
  while (superType) {
    let superDef = void 0;
    if (isComponentDef(definition)) {
      superDef = superType.ɵcmp || superType.ɵdir;
    } else {
      if (superType.ɵcmp) {
        throw new RuntimeError(903, ngDevMode && `Directives cannot inherit Components. Directive ${stringifyForError(definition.type)} is attempting to extend component ${stringifyForError(superType)}`);
      }
      superDef = superType.ɵdir;
    }
    if (superDef) {
      if (shouldInheritFields) {
        inheritanceChain.push(superDef);
        const writeableDef = definition;
        writeableDef.inputs = maybeUnwrapEmpty(definition.inputs);
        writeableDef.inputTransforms = maybeUnwrapEmpty(definition.inputTransforms);
        writeableDef.declaredInputs = maybeUnwrapEmpty(definition.declaredInputs);
        writeableDef.outputs = maybeUnwrapEmpty(definition.outputs);
        const superHostBindings = superDef.hostBindings;
        superHostBindings && inheritHostBindings(definition, superHostBindings);
        const superViewQuery = superDef.viewQuery;
        const superContentQueries = superDef.contentQueries;
        superViewQuery && inheritViewQuery(definition, superViewQuery);
        superContentQueries && inheritContentQueries(definition, superContentQueries);
        mergeInputsWithTransforms(definition, superDef);
        fillProperties(definition.outputs, superDef.outputs);
        if (isComponentDef(superDef) && superDef.data.animation) {
          const defData = definition.data;
          defData.animation = (defData.animation || []).concat(superDef.data.animation);
        }
      }
      const features = superDef.features;
      if (features) {
        for (let i = 0; i < features.length; i++) {
          const feature = features[i];
          if (feature && feature.ngInherit) {
            feature(definition);
          }
          if (feature === ɵɵInheritDefinitionFeature) {
            shouldInheritFields = false;
          }
        }
      }
    }
    superType = Object.getPrototypeOf(superType);
  }
  mergeHostAttrsAcrossInheritance(inheritanceChain);
}
function mergeInputsWithTransforms(target, source) {
  for (const key in source.inputs) {
    if (!source.inputs.hasOwnProperty(key)) {
      continue;
    }
    if (target.inputs.hasOwnProperty(key)) {
      continue;
    }
    const value = source.inputs[key];
    if (value === void 0) {
      continue;
    }
    target.inputs[key] = value;
    target.declaredInputs[key] = source.declaredInputs[key];
    if (source.inputTransforms !== null) {
      const minifiedName = Array.isArray(value) ? value[0] : value;
      if (!source.inputTransforms.hasOwnProperty(minifiedName)) {
        continue;
      }
      target.inputTransforms ??= {};
      target.inputTransforms[minifiedName] = source.inputTransforms[minifiedName];
    }
  }
}
function mergeHostAttrsAcrossInheritance(inheritanceChain) {
  let hostVars = 0;
  let hostAttrs = null;
  for (let i = inheritanceChain.length - 1; i >= 0; i--) {
    const def = inheritanceChain[i];
    def.hostVars = hostVars += def.hostVars;
    def.hostAttrs = mergeHostAttrs(def.hostAttrs, hostAttrs = mergeHostAttrs(hostAttrs, def.hostAttrs));
  }
}
function maybeUnwrapEmpty(value) {
  if (value === EMPTY_OBJ) {
    return {};
  } else if (value === EMPTY_ARRAY) {
    return [];
  } else {
    return value;
  }
}
function inheritViewQuery(definition, superViewQuery) {
  const prevViewQuery = definition.viewQuery;
  if (prevViewQuery) {
    definition.viewQuery = (rf, ctx) => {
      superViewQuery(rf, ctx);
      prevViewQuery(rf, ctx);
    };
  } else {
    definition.viewQuery = superViewQuery;
  }
}
function inheritContentQueries(definition, superContentQueries) {
  const prevContentQueries = definition.contentQueries;
  if (prevContentQueries) {
    definition.contentQueries = (rf, ctx, directiveIndex) => {
      superContentQueries(rf, ctx, directiveIndex);
      prevContentQueries(rf, ctx, directiveIndex);
    };
  } else {
    definition.contentQueries = superContentQueries;
  }
}
function inheritHostBindings(definition, superHostBindings) {
  const prevHostBindings = definition.hostBindings;
  if (prevHostBindings) {
    definition.hostBindings = (rf, ctx) => {
      superHostBindings(rf, ctx);
      prevHostBindings(rf, ctx);
    };
  } else {
    definition.hostBindings = superHostBindings;
  }
}
var COPY_DIRECTIVE_FIELDS = [
  // The child class should use the providers of its parent.
  "providersResolver"
  // Not listed here are any fields which are handled by the `ɵɵInheritDefinitionFeature`, such
  // as inputs, outputs, and host binding functions.
];
var COPY_COMPONENT_FIELDS = [
  // The child class should use the template function of its parent, including all template
  // semantics.
  "template",
  "decls",
  "consts",
  "vars",
  "onPush",
  "ngContentSelectors",
  // The child class should use the CSS styles of its parent, including all styling semantics.
  "styles",
  "encapsulation",
  // The child class should be checked by the runtime in the same way as its parent.
  "schemas"
];
function ɵɵCopyDefinitionFeature(definition) {
  let superType = getSuperType(definition.type);
  let superDef = void 0;
  if (isComponentDef(definition)) {
    superDef = superType.ɵcmp;
  } else {
    superDef = superType.ɵdir;
  }
  const defAny = definition;
  for (const field of COPY_DIRECTIVE_FIELDS) {
    defAny[field] = superDef[field];
  }
  if (isComponentDef(superDef)) {
    for (const field of COPY_COMPONENT_FIELDS) {
      defAny[field] = superDef[field];
    }
  }
}
function ɵɵHostDirectivesFeature(rawHostDirectives) {
  const feature = (definition) => {
    const resolved = (Array.isArray(rawHostDirectives) ? rawHostDirectives : rawHostDirectives()).map((dir) => {
      return typeof dir === "function" ? {
        directive: resolveForwardRef(dir),
        inputs: EMPTY_OBJ,
        outputs: EMPTY_OBJ
      } : {
        directive: resolveForwardRef(dir.directive),
        inputs: bindingArrayToMap(dir.inputs),
        outputs: bindingArrayToMap(dir.outputs)
      };
    });
    if (definition.hostDirectives === null) {
      definition.findHostDirectiveDefs = findHostDirectiveDefs;
      definition.hostDirectives = resolved;
    } else {
      definition.hostDirectives.unshift(...resolved);
    }
  };
  feature.ngInherit = true;
  return feature;
}
function findHostDirectiveDefs(currentDef, matchedDefs, hostDirectiveDefs) {
  if (currentDef.hostDirectives !== null) {
    for (const hostDirectiveConfig of currentDef.hostDirectives) {
      const hostDirectiveDef = getDirectiveDef(hostDirectiveConfig.directive);
      if (typeof ngDevMode === "undefined" || ngDevMode) {
        validateHostDirective(hostDirectiveConfig, hostDirectiveDef);
      }
      patchDeclaredInputs(hostDirectiveDef.declaredInputs, hostDirectiveConfig.inputs);
      findHostDirectiveDefs(hostDirectiveDef, matchedDefs, hostDirectiveDefs);
      hostDirectiveDefs.set(hostDirectiveDef, hostDirectiveConfig);
      matchedDefs.push(hostDirectiveDef);
    }
  }
}
function bindingArrayToMap(bindings) {
  if (bindings === void 0 || bindings.length === 0) {
    return EMPTY_OBJ;
  }
  const result = {};
  for (let i = 0; i < bindings.length; i += 2) {
    result[bindings[i]] = bindings[i + 1];
  }
  return result;
}
function patchDeclaredInputs(declaredInputs, exposedInputs) {
  for (const publicName in exposedInputs) {
    if (exposedInputs.hasOwnProperty(publicName)) {
      const remappedPublicName = exposedInputs[publicName];
      const privateName = declaredInputs[publicName];
      if ((typeof ngDevMode === "undefined" || ngDevMode) && declaredInputs.hasOwnProperty(remappedPublicName)) {
        assertEqual(declaredInputs[remappedPublicName], declaredInputs[publicName], `Conflicting host directive input alias ${publicName}.`);
      }
      declaredInputs[remappedPublicName] = privateName;
    }
  }
}
function validateHostDirective(hostDirectiveConfig, directiveDef) {
  const type = hostDirectiveConfig.directive;
  if (directiveDef === null) {
    if (getComponentDef(type) !== null) {
      throw new RuntimeError(310, `Host directive ${type.name} cannot be a component.`);
    }
    throw new RuntimeError(307, `Could not resolve metadata for host directive ${type.name}. Make sure that the ${type.name} class is annotated with an @Directive decorator.`);
  }
  if (!directiveDef.standalone) {
    throw new RuntimeError(308, `Host directive ${directiveDef.type.name} must be standalone.`);
  }
  validateMappings("input", directiveDef, hostDirectiveConfig.inputs);
  validateMappings("output", directiveDef, hostDirectiveConfig.outputs);
}
function validateMappings(bindingType, def, hostDirectiveBindings) {
  const className = def.type.name;
  const bindings = bindingType === "input" ? def.inputs : def.outputs;
  for (const publicName in hostDirectiveBindings) {
    if (hostDirectiveBindings.hasOwnProperty(publicName)) {
      if (!bindings.hasOwnProperty(publicName)) {
        throw new RuntimeError(311, `Directive ${className} does not have an ${bindingType} with a public name of ${publicName}.`);
      }
      const remappedPublicName = hostDirectiveBindings[publicName];
      if (bindings.hasOwnProperty(remappedPublicName) && remappedPublicName !== publicName) {
        throw new RuntimeError(312, `Cannot alias ${bindingType} ${publicName} of host directive ${className} to ${remappedPublicName}, because it already has a different ${bindingType} with the same public name.`);
      }
    }
  }
}
function ɵɵInputTransformsFeature(definition) {
  const inputs = definition.inputConfig;
  const inputTransforms = {};
  for (const minifiedKey in inputs) {
    if (inputs.hasOwnProperty(minifiedKey)) {
      const value = inputs[minifiedKey];
      if (Array.isArray(value) && value[3]) {
        inputTransforms[minifiedKey] = value[3];
      }
    }
  }
  definition.inputTransforms = inputTransforms;
}
var NgModuleRef$1 = class {
};
var NgModuleFactory$1 = class {
};
function createNgModule(ngModule, parentInjector) {
  return new NgModuleRef(ngModule, parentInjector ?? null, []);
}
var NgModuleRef = class extends NgModuleRef$1 {
  constructor(ngModuleType, _parent, additionalProviders, runInjectorInitializers = true) {
    super();
    this.ngModuleType = ngModuleType;
    this._parent = _parent;
    this._bootstrapComponents = [];
    this.destroyCbs = [];
    this.componentFactoryResolver = new ComponentFactoryResolver(this);
    const ngModuleDef = getNgModuleDef(ngModuleType);
    ngDevMode && assertDefined(ngModuleDef, `NgModule '${stringify(ngModuleType)}' is not a subtype of 'NgModuleType'.`);
    this._bootstrapComponents = maybeUnwrapFn(ngModuleDef.bootstrap);
    this._r3Injector = createInjectorWithoutInjectorInstances(ngModuleType, _parent, [{
      provide: NgModuleRef$1,
      useValue: this
    }, {
      provide: ComponentFactoryResolver$1,
      useValue: this.componentFactoryResolver
    }, ...additionalProviders], stringify(ngModuleType), /* @__PURE__ */ new Set(["environment"]));
    if (runInjectorInitializers) {
      this.resolveInjectorInitializers();
    }
  }
  resolveInjectorInitializers() {
    this._r3Injector.resolveInjectorInitializers();
    this.instance = this._r3Injector.get(this.ngModuleType);
  }
  get injector() {
    return this._r3Injector;
  }
  destroy() {
    ngDevMode && assertDefined(this.destroyCbs, "NgModule already destroyed");
    const injector = this._r3Injector;
    !injector.destroyed && injector.destroy();
    this.destroyCbs.forEach((fn) => fn());
    this.destroyCbs = null;
  }
  onDestroy(callback) {
    ngDevMode && assertDefined(this.destroyCbs, "NgModule already destroyed");
    this.destroyCbs.push(callback);
  }
};
var NgModuleFactory = class extends NgModuleFactory$1 {
  constructor(moduleType) {
    super();
    this.moduleType = moduleType;
  }
  create(parentInjector) {
    return new NgModuleRef(this.moduleType, parentInjector, []);
  }
};
function createNgModuleRefWithProviders(moduleType, parentInjector, additionalProviders) {
  return new NgModuleRef(moduleType, parentInjector, additionalProviders, false);
}
var EnvironmentNgModuleRefAdapter = class extends NgModuleRef$1 {
  constructor(config) {
    super();
    this.componentFactoryResolver = new ComponentFactoryResolver(this);
    this.instance = null;
    const injector = new R3Injector([...config.providers, {
      provide: NgModuleRef$1,
      useValue: this
    }, {
      provide: ComponentFactoryResolver$1,
      useValue: this.componentFactoryResolver
    }], config.parent || getNullInjector(), config.debugName, /* @__PURE__ */ new Set(["environment"]));
    this.injector = injector;
    if (config.runEnvironmentInitializers) {
      injector.resolveInjectorInitializers();
    }
  }
  destroy() {
    this.injector.destroy();
  }
  onDestroy(callback) {
    this.injector.onDestroy(callback);
  }
};
function createEnvironmentInjector(providers, parent, debugName = null) {
  const adapter = new EnvironmentNgModuleRefAdapter({
    providers,
    parent,
    debugName,
    runEnvironmentInitializers: true
  });
  return adapter.injector;
}
var CachedInjectorService = class _CachedInjectorService {
  constructor() {
    this.cachedInjectors = /* @__PURE__ */ new Map();
  }
  getOrCreateInjector(key, parentInjector, providers, debugName) {
    if (!this.cachedInjectors.has(key)) {
      const injector = providers.length > 0 ? createEnvironmentInjector(providers, parentInjector, debugName) : null;
      this.cachedInjectors.set(key, injector);
    }
    return this.cachedInjectors.get(key);
  }
  ngOnDestroy() {
    try {
      for (const injector of this.cachedInjectors.values()) {
        if (injector !== null) {
          injector.destroy();
        }
      }
    } finally {
      this.cachedInjectors.clear();
    }
  }
  static {
    this.ɵprov = ɵɵdefineInjectable({
      token: _CachedInjectorService,
      providedIn: "environment",
      factory: () => new _CachedInjectorService()
    });
  }
};
function isListLikeIterable(obj) {
  if (!isJsObject(obj)) return false;
  return Array.isArray(obj) || !(obj instanceof Map) && // JS Map are iterables but return entries as [k, v]
  Symbol.iterator in obj;
}
function areIterablesEqual(a, b, comparator) {
  const iterator1 = a[Symbol.iterator]();
  const iterator2 = b[Symbol.iterator]();
  while (true) {
    const item1 = iterator1.next();
    const item2 = iterator2.next();
    if (item1.done && item2.done) return true;
    if (item1.done || item2.done) return false;
    if (!comparator(item1.value, item2.value)) return false;
  }
}
function iterateListLike(obj, fn) {
  if (Array.isArray(obj)) {
    for (let i = 0; i < obj.length; i++) {
      fn(obj[i]);
    }
  } else {
    const iterator = obj[Symbol.iterator]();
    let item;
    while (!(item = iterator.next()).done) {
      fn(item.value);
    }
  }
}
function isJsObject(o) {
  return o !== null && (typeof o === "function" || typeof o === "object");
}
function devModeEqual(a, b) {
  const isListLikeIterableA = isListLikeIterable(a);
  const isListLikeIterableB = isListLikeIterable(b);
  if (isListLikeIterableA && isListLikeIterableB) {
    return areIterablesEqual(a, b, devModeEqual);
  } else {
    const isAObject = a && (typeof a === "object" || typeof a === "function");
    const isBObject = b && (typeof b === "object" || typeof b === "function");
    if (!isListLikeIterableA && isAObject && !isListLikeIterableB && isBObject) {
      return true;
    } else {
      return Object.is(a, b);
    }
  }
}
function updateBinding(lView, bindingIndex, value) {
  return lView[bindingIndex] = value;
}
function getBinding(lView, bindingIndex) {
  ngDevMode && assertIndexInRange(lView, bindingIndex);
  ngDevMode && assertNotSame(lView[bindingIndex], NO_CHANGE, "Stored value should never be NO_CHANGE.");
  return lView[bindingIndex];
}
function bindingUpdated(lView, bindingIndex, value) {
  ngDevMode && assertNotSame(value, NO_CHANGE, "Incoming value should never be NO_CHANGE.");
  ngDevMode && assertLessThan(bindingIndex, lView.length, `Slot should have been initialized to NO_CHANGE`);
  const oldValue = lView[bindingIndex];
  if (Object.is(oldValue, value)) {
    return false;
  } else {
    if (ngDevMode && isInCheckNoChangesMode()) {
      const oldValueToCompare = oldValue !== NO_CHANGE ? oldValue : void 0;
      if (!devModeEqual(oldValueToCompare, value)) {
        const details = getExpressionChangedErrorDetails(lView, bindingIndex, oldValueToCompare, value);
        throwErrorIfNoChangesMode(oldValue === NO_CHANGE, details.oldValue, details.newValue, details.propName, lView);
      }
      return false;
    }
    lView[bindingIndex] = value;
    return true;
  }
}
function bindingUpdated2(lView, bindingIndex, exp1, exp2) {
  const different = bindingUpdated(lView, bindingIndex, exp1);
  return bindingUpdated(lView, bindingIndex + 1, exp2) || different;
}
function bindingUpdated3(lView, bindingIndex, exp1, exp2, exp3) {
  const different = bindingUpdated2(lView, bindingIndex, exp1, exp2);
  return bindingUpdated(lView, bindingIndex + 2, exp3) || different;
}
function bindingUpdated4(lView, bindingIndex, exp1, exp2, exp3, exp4) {
  const different = bindingUpdated2(lView, bindingIndex, exp1, exp2);
  return bindingUpdated2(lView, bindingIndex + 2, exp3, exp4) || different;
}
function isDetachedByI18n(tNode) {
  return (tNode.flags & 32) === 32;
}
function templateFirstCreatePass(index, tView, lView, templateFn, decls, vars, tagName, attrs, localRefsIndex) {
  ngDevMode && assertFirstCreatePass(tView);
  ngDevMode && ngDevMode.firstCreatePass++;
  const tViewConsts = tView.consts;
  const tNode = getOrCreateTNode(tView, index, 4, tagName || null, attrs || null);
  resolveDirectives(tView, lView, tNode, getConstant(tViewConsts, localRefsIndex));
  registerPostOrderHooks(tView, tNode);
  const embeddedTView = tNode.tView = createTView(
    2,
    tNode,
    templateFn,
    decls,
    vars,
    tView.directiveRegistry,
    tView.pipeRegistry,
    null,
    tView.schemas,
    tViewConsts,
    null
    /* ssrId */
  );
  if (tView.queries !== null) {
    tView.queries.template(tView, tNode);
    embeddedTView.queries = tView.queries.embeddedTView(tNode);
  }
  return tNode;
}
function declareTemplate(declarationLView, declarationTView, index, templateFn, decls, vars, tagName, attrs, localRefsIndex, localRefExtractor) {
  const adjustedIndex = index + HEADER_OFFSET;
  const tNode = declarationTView.firstCreatePass ? templateFirstCreatePass(adjustedIndex, declarationTView, declarationLView, templateFn, decls, vars, tagName, attrs, localRefsIndex) : declarationTView.data[adjustedIndex];
  setCurrentTNode(tNode, false);
  const comment = _locateOrCreateContainerAnchor(declarationTView, declarationLView, tNode, index);
  if (wasLastNodeCreated()) {
    appendChild(declarationTView, declarationLView, comment, tNode);
  }
  attachPatchData(comment, declarationLView);
  const lContainer = createLContainer(comment, declarationLView, comment, tNode);
  declarationLView[adjustedIndex] = lContainer;
  addToViewTree(declarationLView, lContainer);
  populateDehydratedViewsInLContainer(lContainer, tNode, declarationLView);
  if (isDirectiveHost(tNode)) {
    createDirectivesInstances(declarationTView, declarationLView, tNode);
  }
  if (localRefsIndex != null) {
    saveResolvedLocalsInData(declarationLView, tNode, localRefExtractor);
  }
  return tNode;
}
function ɵɵtemplate(index, templateFn, decls, vars, tagName, attrsIndex, localRefsIndex, localRefExtractor) {
  const lView = getLView();
  const tView = getTView();
  const attrs = getConstant(tView.consts, attrsIndex);
  declareTemplate(lView, tView, index, templateFn, decls, vars, tagName, attrs, localRefsIndex, localRefExtractor);
  return ɵɵtemplate;
}
var _locateOrCreateContainerAnchor = createContainerAnchorImpl;
function createContainerAnchorImpl(tView, lView, tNode, index) {
  lastNodeWasCreated(true);
  return lView[RENDERER].createComment(ngDevMode ? "container" : "");
}
var DeferDependenciesLoadingState;
(function(DeferDependenciesLoadingState2) {
  DeferDependenciesLoadingState2[DeferDependenciesLoadingState2["NOT_STARTED"] = 0] = "NOT_STARTED";
  DeferDependenciesLoadingState2[DeferDependenciesLoadingState2["IN_PROGRESS"] = 1] = "IN_PROGRESS";
  DeferDependenciesLoadingState2[DeferDependenciesLoadingState2["COMPLETE"] = 2] = "COMPLETE";
  DeferDependenciesLoadingState2[DeferDependenciesLoadingState2["FAILED"] = 3] = "FAILED";
})(DeferDependenciesLoadingState || (DeferDependenciesLoadingState = {}));
var MINIMUM_SLOT = 0;
var LOADING_AFTER_SLOT = 1;
var DeferBlockState;
(function(DeferBlockState2) {
  DeferBlockState2[DeferBlockState2["Placeholder"] = 0] = "Placeholder";
  DeferBlockState2[DeferBlockState2["Loading"] = 1] = "Loading";
  DeferBlockState2[DeferBlockState2["Complete"] = 2] = "Complete";
  DeferBlockState2[DeferBlockState2["Error"] = 3] = "Error";
})(DeferBlockState || (DeferBlockState = {}));
var DeferBlockInternalState;
(function(DeferBlockInternalState2) {
  DeferBlockInternalState2[DeferBlockInternalState2["Initial"] = -1] = "Initial";
})(DeferBlockInternalState || (DeferBlockInternalState = {}));
var NEXT_DEFER_BLOCK_STATE = 0;
var DEFER_BLOCK_STATE = 1;
var STATE_IS_FROZEN_UNTIL = 2;
var LOADING_AFTER_CLEANUP_FN = 3;
var TRIGGER_CLEANUP_FNS = 4;
var PREFETCH_TRIGGER_CLEANUP_FNS = 5;
var DeferBlockBehavior;
(function(DeferBlockBehavior2) {
  DeferBlockBehavior2[DeferBlockBehavior2["Manual"] = 0] = "Manual";
  DeferBlockBehavior2[DeferBlockBehavior2["Playthrough"] = 1] = "Playthrough";
})(DeferBlockBehavior || (DeferBlockBehavior = {}));
function storeTriggerCleanupFn(type, lDetails, cleanupFn) {
  const key = type === 1 ? PREFETCH_TRIGGER_CLEANUP_FNS : TRIGGER_CLEANUP_FNS;
  if (lDetails[key] === null) {
    lDetails[key] = [];
  }
  lDetails[key].push(cleanupFn);
}
function invokeTriggerCleanupFns(type, lDetails) {
  const key = type === 1 ? PREFETCH_TRIGGER_CLEANUP_FNS : TRIGGER_CLEANUP_FNS;
  const cleanupFns = lDetails[key];
  if (cleanupFns !== null) {
    for (const cleanupFn of cleanupFns) {
      cleanupFn();
    }
    lDetails[key] = null;
  }
}
function invokeAllTriggerCleanupFns(lDetails) {
  invokeTriggerCleanupFns(1, lDetails);
  invokeTriggerCleanupFns(0, lDetails);
}
function getDeferBlockDataIndex(deferBlockIndex) {
  return deferBlockIndex + 1;
}
function getLDeferBlockDetails(lView, tNode) {
  const tView = lView[TVIEW];
  const slotIndex = getDeferBlockDataIndex(tNode.index);
  ngDevMode && assertIndexInDeclRange(tView, slotIndex);
  return lView[slotIndex];
}
function setLDeferBlockDetails(lView, deferBlockIndex, lDetails) {
  const tView = lView[TVIEW];
  const slotIndex = getDeferBlockDataIndex(deferBlockIndex);
  ngDevMode && assertIndexInDeclRange(tView, slotIndex);
  lView[slotIndex] = lDetails;
}
function getTDeferBlockDetails(tView, tNode) {
  const slotIndex = getDeferBlockDataIndex(tNode.index);
  ngDevMode && assertIndexInDeclRange(tView, slotIndex);
  return tView.data[slotIndex];
}
function setTDeferBlockDetails(tView, deferBlockIndex, deferBlockConfig) {
  const slotIndex = getDeferBlockDataIndex(deferBlockIndex);
  ngDevMode && assertIndexInDeclRange(tView, slotIndex);
  tView.data[slotIndex] = deferBlockConfig;
}
function getTemplateIndexForState(newState, hostLView, tNode) {
  const tView = hostLView[TVIEW];
  const tDetails = getTDeferBlockDetails(tView, tNode);
  switch (newState) {
    case DeferBlockState.Complete:
      return tDetails.primaryTmplIndex;
    case DeferBlockState.Loading:
      return tDetails.loadingTmplIndex;
    case DeferBlockState.Error:
      return tDetails.errorTmplIndex;
    case DeferBlockState.Placeholder:
      return tDetails.placeholderTmplIndex;
    default:
      ngDevMode && throwError(`Unexpected defer block state: ${newState}`);
      return null;
  }
}
function getMinimumDurationForState(tDetails, currentState) {
  if (currentState === DeferBlockState.Placeholder) {
    return tDetails.placeholderBlockConfig?.[MINIMUM_SLOT] ?? null;
  } else if (currentState === DeferBlockState.Loading) {
    return tDetails.loadingBlockConfig?.[MINIMUM_SLOT] ?? null;
  }
  return null;
}
function getLoadingBlockAfter(tDetails) {
  return tDetails.loadingBlockConfig?.[LOADING_AFTER_SLOT] ?? null;
}
function addDepsToRegistry(currentDeps, newDeps) {
  if (!currentDeps || currentDeps.length === 0) {
    return newDeps;
  }
  const currentDepSet = new Set(currentDeps);
  for (const dep of newDeps) {
    currentDepSet.add(dep);
  }
  return currentDeps.length === currentDepSet.size ? currentDeps : Array.from(currentDepSet);
}
function getPrimaryBlockTNode(tView, tDetails) {
  const adjustedIndex = tDetails.primaryTmplIndex + HEADER_OFFSET;
  return getTNode(tView, adjustedIndex);
}
function assertDeferredDependenciesLoaded(tDetails) {
  assertEqual(tDetails.loadingState, DeferDependenciesLoadingState.COMPLETE, "Expecting all deferred dependencies to be loaded.");
}
var eventListenerOptions = {
  passive: true,
  capture: true
};
var hoverTriggers = /* @__PURE__ */ new WeakMap();
var interactionTriggers = /* @__PURE__ */ new WeakMap();
var viewportTriggers = /* @__PURE__ */ new WeakMap();
var interactionEventNames = ["click", "keydown"];
var hoverEventNames = ["mouseenter", "focusin"];
var intersectionObserver = null;
var observedViewportElements = 0;
var DeferEventEntry = class {
  constructor() {
    this.callbacks = /* @__PURE__ */ new Set();
    this.listener = () => {
      for (const callback of this.callbacks) {
        callback();
      }
    };
  }
};
function onInteraction(trigger, callback) {
  let entry = interactionTriggers.get(trigger);
  if (!entry) {
    entry = new DeferEventEntry();
    interactionTriggers.set(trigger, entry);
    for (const name of interactionEventNames) {
      trigger.addEventListener(name, entry.listener, eventListenerOptions);
    }
  }
  entry.callbacks.add(callback);
  return () => {
    const {
      callbacks,
      listener
    } = entry;
    callbacks.delete(callback);
    if (callbacks.size === 0) {
      interactionTriggers.delete(trigger);
      for (const name of interactionEventNames) {
        trigger.removeEventListener(name, listener, eventListenerOptions);
      }
    }
  };
}
function onHover(trigger, callback) {
  let entry = hoverTriggers.get(trigger);
  if (!entry) {
    entry = new DeferEventEntry();
    hoverTriggers.set(trigger, entry);
    for (const name of hoverEventNames) {
      trigger.addEventListener(name, entry.listener, eventListenerOptions);
    }
  }
  entry.callbacks.add(callback);
  return () => {
    const {
      callbacks,
      listener
    } = entry;
    callbacks.delete(callback);
    if (callbacks.size === 0) {
      for (const name of hoverEventNames) {
        trigger.removeEventListener(name, listener, eventListenerOptions);
      }
      hoverTriggers.delete(trigger);
    }
  };
}
function onViewport(trigger, callback, injector) {
  const ngZone = injector.get(NgZone);
  let entry = viewportTriggers.get(trigger);
  intersectionObserver = intersectionObserver || ngZone.runOutsideAngular(() => {
    return new IntersectionObserver((entries) => {
      for (const current of entries) {
        if (current.isIntersecting && viewportTriggers.has(current.target)) {
          ngZone.run(viewportTriggers.get(current.target).listener);
        }
      }
    });
  });
  if (!entry) {
    entry = new DeferEventEntry();
    ngZone.runOutsideAngular(() => intersectionObserver.observe(trigger));
    viewportTriggers.set(trigger, entry);
    observedViewportElements++;
  }
  entry.callbacks.add(callback);
  return () => {
    if (!viewportTriggers.has(trigger)) {
      return;
    }
    entry.callbacks.delete(callback);
    if (entry.callbacks.size === 0) {
      intersectionObserver?.unobserve(trigger);
      viewportTriggers.delete(trigger);
      observedViewportElements--;
    }
    if (observedViewportElements === 0) {
      intersectionObserver?.disconnect();
      intersectionObserver = null;
    }
  };
}
function getTriggerLView(deferredHostLView, deferredTNode, walkUpTimes) {
  if (walkUpTimes == null) {
    return deferredHostLView;
  }
  if (walkUpTimes >= 0) {
    return walkUpViews(walkUpTimes, deferredHostLView);
  }
  const deferredContainer = deferredHostLView[deferredTNode.index];
  ngDevMode && assertLContainer(deferredContainer);
  const triggerLView = deferredContainer[CONTAINER_HEADER_OFFSET] ?? null;
  if (ngDevMode && triggerLView !== null) {
    const lDetails = getLDeferBlockDetails(deferredHostLView, deferredTNode);
    const renderedState = lDetails[DEFER_BLOCK_STATE];
    assertEqual(renderedState, DeferBlockState.Placeholder, "Expected a placeholder to be rendered in this defer block.");
    assertLView(triggerLView);
  }
  return triggerLView;
}
function getTriggerElement(triggerLView, triggerIndex) {
  const element = getNativeByIndex(HEADER_OFFSET + triggerIndex, triggerLView);
  ngDevMode && assertElement(element);
  return element;
}
function registerDomTrigger(initialLView, tNode, triggerIndex, walkUpTimes, registerFn, callback, type) {
  const injector = initialLView[INJECTOR];
  function pollDomTrigger() {
    if (isDestroyed(initialLView)) {
      return;
    }
    const lDetails = getLDeferBlockDetails(initialLView, tNode);
    const renderedState = lDetails[DEFER_BLOCK_STATE];
    if (renderedState !== DeferBlockInternalState.Initial && renderedState !== DeferBlockState.Placeholder) {
      return;
    }
    const triggerLView = getTriggerLView(initialLView, tNode, walkUpTimes);
    if (!triggerLView) {
      internalAfterNextRender(pollDomTrigger, {
        injector
      });
      return;
    }
    if (isDestroyed(triggerLView)) {
      return;
    }
    const element = getTriggerElement(triggerLView, triggerIndex);
    const cleanup = registerFn(element, () => {
      if (initialLView !== triggerLView) {
        removeLViewOnDestroy(triggerLView, cleanup);
      }
      callback();
    }, injector);
    if (initialLView !== triggerLView) {
      storeLViewOnDestroy(triggerLView, cleanup);
    }
    storeTriggerCleanupFn(type, lDetails, cleanup);
  }
  internalAfterNextRender(pollDomTrigger, {
    injector
  });
}
function onIdle(callback, lView) {
  const injector = lView[INJECTOR];
  const scheduler = injector.get(IdleScheduler);
  const cleanupFn = () => scheduler.remove(callback);
  scheduler.add(callback);
  return cleanupFn;
}
var _requestIdleCallback = () => typeof requestIdleCallback !== "undefined" ? requestIdleCallback : setTimeout;
var _cancelIdleCallback = () => typeof requestIdleCallback !== "undefined" ? cancelIdleCallback : clearTimeout;
var IdleScheduler = class _IdleScheduler {
  constructor() {
    this.executingCallbacks = false;
    this.idleId = null;
    this.current = /* @__PURE__ */ new Set();
    this.deferred = /* @__PURE__ */ new Set();
    this.ngZone = inject(NgZone);
    this.requestIdleCallbackFn = _requestIdleCallback().bind(globalThis);
    this.cancelIdleCallbackFn = _cancelIdleCallback().bind(globalThis);
  }
  add(callback) {
    const target = this.executingCallbacks ? this.deferred : this.current;
    target.add(callback);
    if (this.idleId === null) {
      this.scheduleIdleCallback();
    }
  }
  remove(callback) {
    const {
      current,
      deferred
    } = this;
    current.delete(callback);
    deferred.delete(callback);
    if (current.size === 0 && deferred.size === 0) {
      this.cancelIdleCallback();
    }
  }
  scheduleIdleCallback() {
    const callback = () => {
      this.cancelIdleCallback();
      this.executingCallbacks = true;
      for (const callback2 of this.current) {
        callback2();
      }
      this.current.clear();
      this.executingCallbacks = false;
      if (this.deferred.size > 0) {
        for (const callback2 of this.deferred) {
          this.current.add(callback2);
        }
        this.deferred.clear();
        this.scheduleIdleCallback();
      }
    };
    this.idleId = this.requestIdleCallbackFn(() => this.ngZone.run(callback));
  }
  cancelIdleCallback() {
    if (this.idleId !== null) {
      this.cancelIdleCallbackFn(this.idleId);
      this.idleId = null;
    }
  }
  ngOnDestroy() {
    this.cancelIdleCallback();
    this.current.clear();
    this.deferred.clear();
  }
  static {
    this.ɵprov = ɵɵdefineInjectable({
      token: _IdleScheduler,
      providedIn: "root",
      factory: () => new _IdleScheduler()
    });
  }
};
function onTimer(delay) {
  return (callback, lView) => scheduleTimerTrigger(delay, callback, lView);
}
function scheduleTimerTrigger(delay, callback, lView) {
  const injector = lView[INJECTOR];
  const scheduler = injector.get(TimerScheduler);
  const cleanupFn = () => scheduler.remove(callback);
  scheduler.add(delay, callback);
  return cleanupFn;
}
var TimerScheduler = class _TimerScheduler {
  constructor() {
    this.executingCallbacks = false;
    this.timeoutId = null;
    this.invokeTimerAt = null;
    this.current = [];
    this.deferred = [];
  }
  add(delay, callback) {
    const target = this.executingCallbacks ? this.deferred : this.current;
    this.addToQueue(target, Date.now() + delay, callback);
    this.scheduleTimer();
  }
  remove(callback) {
    const {
      current,
      deferred
    } = this;
    const callbackIndex = this.removeFromQueue(current, callback);
    if (callbackIndex === -1) {
      this.removeFromQueue(deferred, callback);
    }
    if (current.length === 0 && deferred.length === 0) {
      this.clearTimeout();
    }
  }
  addToQueue(target, invokeAt, callback) {
    let insertAtIndex = target.length;
    for (let i = 0; i < target.length; i += 2) {
      const invokeQueuedCallbackAt = target[i];
      if (invokeQueuedCallbackAt > invokeAt) {
        insertAtIndex = i;
        break;
      }
    }
    arrayInsert2(target, insertAtIndex, invokeAt, callback);
  }
  removeFromQueue(target, callback) {
    let index = -1;
    for (let i = 0; i < target.length; i += 2) {
      const queuedCallback = target[i + 1];
      if (queuedCallback === callback) {
        index = i;
        break;
      }
    }
    if (index > -1) {
      arraySplice(target, index, 2);
    }
    return index;
  }
  scheduleTimer() {
    const callback = () => {
      this.clearTimeout();
      this.executingCallbacks = true;
      const current = [...this.current];
      const now = Date.now();
      for (let i = 0; i < current.length; i += 2) {
        const invokeAt = current[i];
        const callback2 = current[i + 1];
        if (invokeAt <= now) {
          callback2();
        } else {
          break;
        }
      }
      let lastCallbackIndex = -1;
      for (let i = 0; i < this.current.length; i += 2) {
        const invokeAt = this.current[i];
        if (invokeAt <= now) {
          lastCallbackIndex = i + 1;
        } else {
          break;
        }
      }
      if (lastCallbackIndex >= 0) {
        arraySplice(this.current, 0, lastCallbackIndex + 1);
      }
      this.executingCallbacks = false;
      if (this.deferred.length > 0) {
        for (let i = 0; i < this.deferred.length; i += 2) {
          const invokeAt = this.deferred[i];
          const callback2 = this.deferred[i + 1];
          this.addToQueue(this.current, invokeAt, callback2);
        }
        this.deferred.length = 0;
      }
      this.scheduleTimer();
    };
    const FRAME_DURATION_MS = 16;
    if (this.current.length > 0) {
      const now = Date.now();
      const invokeAt = this.current[0];
      if (this.timeoutId === null || // Reschedule a timer in case a queue contains an item with
      // an earlier timestamp and the delta is more than an average
      // frame duration.
      this.invokeTimerAt && this.invokeTimerAt - invokeAt > FRAME_DURATION_MS) {
        this.clearTimeout();
        const timeout = Math.max(invokeAt - now, FRAME_DURATION_MS);
        this.invokeTimerAt = invokeAt;
        this.timeoutId = setTimeout(callback, timeout);
      }
    }
  }
  clearTimeout() {
    if (this.timeoutId !== null) {
      clearTimeout(this.timeoutId);
      this.timeoutId = null;
    }
  }
  ngOnDestroy() {
    this.clearTimeout();
    this.current.length = 0;
    this.deferred.length = 0;
  }
  static {
    this.ɵprov = ɵɵdefineInjectable({
      token: _TimerScheduler,
      providedIn: "root",
      factory: () => new _TimerScheduler()
    });
  }
};
var DEFER_BLOCK_DEPENDENCY_INTERCEPTOR = new InjectionToken("DEFER_BLOCK_DEPENDENCY_INTERCEPTOR");
var DEFER_BLOCK_CONFIG = new InjectionToken(ngDevMode ? "DEFER_BLOCK_CONFIG" : "");
function shouldTriggerDeferBlock(injector) {
  const config = injector.get(DEFER_BLOCK_CONFIG, null, {
    optional: true
  });
  if (config?.behavior === DeferBlockBehavior.Manual) {
    return false;
  }
  return isPlatformBrowser(injector);
}
var applyDeferBlockStateWithSchedulingImpl = null;
function ɵɵdeferEnableTimerScheduling(tView, tDetails, placeholderConfigIndex, loadingConfigIndex) {
  const tViewConsts = tView.consts;
  if (placeholderConfigIndex != null) {
    tDetails.placeholderBlockConfig = getConstant(tViewConsts, placeholderConfigIndex);
  }
  if (loadingConfigIndex != null) {
    tDetails.loadingBlockConfig = getConstant(tViewConsts, loadingConfigIndex);
  }
  if (applyDeferBlockStateWithSchedulingImpl === null) {
    applyDeferBlockStateWithSchedulingImpl = applyDeferBlockStateWithScheduling;
  }
}
function ɵɵdefer(index, primaryTmplIndex, dependencyResolverFn, loadingTmplIndex, placeholderTmplIndex, errorTmplIndex, loadingConfigIndex, placeholderConfigIndex, enableTimerScheduling) {
  const lView = getLView();
  const tView = getTView();
  const adjustedIndex = index + HEADER_OFFSET;
  const tNode = declareTemplate(lView, tView, index, null, 0, 0);
  if (tView.firstCreatePass) {
    performanceMarkFeature("NgDefer");
    const tDetails = {
      primaryTmplIndex,
      loadingTmplIndex: loadingTmplIndex ?? null,
      placeholderTmplIndex: placeholderTmplIndex ?? null,
      errorTmplIndex: errorTmplIndex ?? null,
      placeholderBlockConfig: null,
      loadingBlockConfig: null,
      dependencyResolverFn: dependencyResolverFn ?? null,
      loadingState: DeferDependenciesLoadingState.NOT_STARTED,
      loadingPromise: null,
      providers: null
    };
    enableTimerScheduling?.(tView, tDetails, placeholderConfigIndex, loadingConfigIndex);
    setTDeferBlockDetails(tView, adjustedIndex, tDetails);
  }
  const lContainer = lView[adjustedIndex];
  populateDehydratedViewsInLContainer(lContainer, tNode, lView);
  const lDetails = [
    null,
    // NEXT_DEFER_BLOCK_STATE
    DeferBlockInternalState.Initial,
    // DEFER_BLOCK_STATE
    null,
    // STATE_IS_FROZEN_UNTIL
    null,
    // LOADING_AFTER_CLEANUP_FN
    null,
    // TRIGGER_CLEANUP_FNS
    null
    // PREFETCH_TRIGGER_CLEANUP_FNS
  ];
  setLDeferBlockDetails(lView, adjustedIndex, lDetails);
  const cleanupTriggersFn = () => invokeAllTriggerCleanupFns(lDetails);
  storeTriggerCleanupFn(0, lDetails, () => removeLViewOnDestroy(lView, cleanupTriggersFn));
  storeLViewOnDestroy(lView, cleanupTriggersFn);
}
function ɵɵdeferWhen(rawValue) {
  const lView = getLView();
  const bindingIndex = nextBindingIndex();
  if (bindingUpdated(lView, bindingIndex, rawValue)) {
    const prevConsumer = setActiveConsumer(null);
    try {
      const value = Boolean(rawValue);
      const tNode = getSelectedTNode();
      const lDetails = getLDeferBlockDetails(lView, tNode);
      const renderedState = lDetails[DEFER_BLOCK_STATE];
      if (value === false && renderedState === DeferBlockInternalState.Initial) {
        renderPlaceholder(lView, tNode);
      } else if (value === true && (renderedState === DeferBlockInternalState.Initial || renderedState === DeferBlockState.Placeholder)) {
        triggerDeferBlock(lView, tNode);
      }
    } finally {
      setActiveConsumer(prevConsumer);
    }
  }
}
function ɵɵdeferPrefetchWhen(rawValue) {
  const lView = getLView();
  const bindingIndex = nextBindingIndex();
  if (bindingUpdated(lView, bindingIndex, rawValue)) {
    const prevConsumer = setActiveConsumer(null);
    try {
      const value = Boolean(rawValue);
      const tView = lView[TVIEW];
      const tNode = getSelectedTNode();
      const tDetails = getTDeferBlockDetails(tView, tNode);
      if (value === true && tDetails.loadingState === DeferDependenciesLoadingState.NOT_STARTED) {
        triggerPrefetching(tDetails, lView, tNode);
      }
    } finally {
      setActiveConsumer(prevConsumer);
    }
  }
}
function ɵɵdeferOnIdle() {
  scheduleDelayedTrigger(onIdle);
}
function ɵɵdeferPrefetchOnIdle() {
  scheduleDelayedPrefetching(onIdle);
}
function ɵɵdeferOnImmediate() {
  const lView = getLView();
  const tNode = getCurrentTNode();
  const tView = lView[TVIEW];
  const injector = lView[INJECTOR];
  const tDetails = getTDeferBlockDetails(tView, tNode);
  if (!shouldTriggerDeferBlock(injector) || tDetails.loadingTmplIndex === null) {
    renderPlaceholder(lView, tNode);
  }
  triggerDeferBlock(lView, tNode);
}
function ɵɵdeferPrefetchOnImmediate() {
  const lView = getLView();
  const tNode = getCurrentTNode();
  const tView = lView[TVIEW];
  const tDetails = getTDeferBlockDetails(tView, tNode);
  if (tDetails.loadingState === DeferDependenciesLoadingState.NOT_STARTED) {
    triggerResourceLoading(tDetails, lView, tNode);
  }
}
function ɵɵdeferOnTimer(delay) {
  scheduleDelayedTrigger(onTimer(delay));
}
function ɵɵdeferPrefetchOnTimer(delay) {
  scheduleDelayedPrefetching(onTimer(delay));
}
function ɵɵdeferOnHover(triggerIndex, walkUpTimes) {
  const lView = getLView();
  const tNode = getCurrentTNode();
  renderPlaceholder(lView, tNode);
  registerDomTrigger(
    lView,
    tNode,
    triggerIndex,
    walkUpTimes,
    onHover,
    () => triggerDeferBlock(lView, tNode),
    0
    /* TriggerType.Regular */
  );
}
function ɵɵdeferPrefetchOnHover(triggerIndex, walkUpTimes) {
  const lView = getLView();
  const tNode = getCurrentTNode();
  const tView = lView[TVIEW];
  const tDetails = getTDeferBlockDetails(tView, tNode);
  if (tDetails.loadingState === DeferDependenciesLoadingState.NOT_STARTED) {
    registerDomTrigger(
      lView,
      tNode,
      triggerIndex,
      walkUpTimes,
      onHover,
      () => triggerPrefetching(tDetails, lView, tNode),
      1
      /* TriggerType.Prefetch */
    );
  }
}
function ɵɵdeferOnInteraction(triggerIndex, walkUpTimes) {
  const lView = getLView();
  const tNode = getCurrentTNode();
  renderPlaceholder(lView, tNode);
  registerDomTrigger(
    lView,
    tNode,
    triggerIndex,
    walkUpTimes,
    onInteraction,
    () => triggerDeferBlock(lView, tNode),
    0
    /* TriggerType.Regular */
  );
}
function ɵɵdeferPrefetchOnInteraction(triggerIndex, walkUpTimes) {
  const lView = getLView();
  const tNode = getCurrentTNode();
  const tView = lView[TVIEW];
  const tDetails = getTDeferBlockDetails(tView, tNode);
  if (tDetails.loadingState === DeferDependenciesLoadingState.NOT_STARTED) {
    registerDomTrigger(
      lView,
      tNode,
      triggerIndex,
      walkUpTimes,
      onInteraction,
      () => triggerPrefetching(tDetails, lView, tNode),
      1
      /* TriggerType.Prefetch */
    );
  }
}
function ɵɵdeferOnViewport(triggerIndex, walkUpTimes) {
  const lView = getLView();
  const tNode = getCurrentTNode();
  renderPlaceholder(lView, tNode);
  registerDomTrigger(
    lView,
    tNode,
    triggerIndex,
    walkUpTimes,
    onViewport,
    () => triggerDeferBlock(lView, tNode),
    0
    /* TriggerType.Regular */
  );
}
function ɵɵdeferPrefetchOnViewport(triggerIndex, walkUpTimes) {
  const lView = getLView();
  const tNode = getCurrentTNode();
  const tView = lView[TVIEW];
  const tDetails = getTDeferBlockDetails(tView, tNode);
  if (tDetails.loadingState === DeferDependenciesLoadingState.NOT_STARTED) {
    registerDomTrigger(
      lView,
      tNode,
      triggerIndex,
      walkUpTimes,
      onViewport,
      () => triggerPrefetching(tDetails, lView, tNode),
      1
      /* TriggerType.Prefetch */
    );
  }
}
function scheduleDelayedTrigger(scheduleFn) {
  const lView = getLView();
  const tNode = getCurrentTNode();
  renderPlaceholder(lView, tNode);
  if (isPlatformBrowser(lView[INJECTOR])) {
    const cleanupFn = scheduleFn(() => triggerDeferBlock(lView, tNode), lView);
    const lDetails = getLDeferBlockDetails(lView, tNode);
    storeTriggerCleanupFn(0, lDetails, cleanupFn);
  }
}
function scheduleDelayedPrefetching(scheduleFn) {
  const lView = getLView();
  if (isPlatformBrowser(lView[INJECTOR])) {
    const tNode = getCurrentTNode();
    const tView = lView[TVIEW];
    const tDetails = getTDeferBlockDetails(tView, tNode);
    if (tDetails.loadingState === DeferDependenciesLoadingState.NOT_STARTED) {
      const lDetails = getLDeferBlockDetails(lView, tNode);
      const prefetch = () => triggerPrefetching(tDetails, lView, tNode);
      const cleanupFn = scheduleFn(prefetch, lView);
      storeTriggerCleanupFn(1, lDetails, cleanupFn);
    }
  }
}
function renderDeferBlockState(newState, tNode, lContainer, skipTimerScheduling = false) {
  const hostLView = lContainer[PARENT];
  const hostTView = hostLView[TVIEW];
  if (isDestroyed(hostLView)) return;
  ngDevMode && assertTNodeForLView(tNode, hostLView);
  const lDetails = getLDeferBlockDetails(hostLView, tNode);
  ngDevMode && assertDefined(lDetails, "Expected a defer block state defined");
  const currentState = lDetails[DEFER_BLOCK_STATE];
  if (isValidStateChange(currentState, newState) && isValidStateChange(lDetails[NEXT_DEFER_BLOCK_STATE] ?? -1, newState)) {
    const injector = hostLView[INJECTOR];
    const tDetails = getTDeferBlockDetails(hostTView, tNode);
    const needsScheduling = !skipTimerScheduling && isPlatformBrowser(injector) && (getLoadingBlockAfter(tDetails) !== null || getMinimumDurationForState(tDetails, DeferBlockState.Loading) !== null || getMinimumDurationForState(tDetails, DeferBlockState.Placeholder));
    if (ngDevMode && needsScheduling) {
      assertDefined(applyDeferBlockStateWithSchedulingImpl, "Expected scheduling function to be defined");
    }
    const applyStateFn = needsScheduling ? applyDeferBlockStateWithSchedulingImpl : applyDeferBlockState;
    try {
      applyStateFn(newState, lDetails, lContainer, tNode, hostLView);
    } catch (error) {
      handleError(hostLView, error);
    }
  }
}
function getOrCreateEnvironmentInjector(parentInjector, tDetails, providers) {
  return parentInjector.get(CachedInjectorService).getOrCreateInjector(tDetails, parentInjector, providers, ngDevMode ? "DeferBlock Injector" : "");
}
function createDeferBlockInjector(parentInjector, tDetails, providers) {
  if (parentInjector instanceof ChainedInjector) {
    const origInjector = parentInjector.injector;
    const parentEnvInjector2 = parentInjector.parentInjector;
    const envInjector = getOrCreateEnvironmentInjector(parentEnvInjector2, tDetails, providers);
    return new ChainedInjector(origInjector, envInjector);
  }
  const parentEnvInjector = parentInjector.get(EnvironmentInjector);
  if (parentEnvInjector !== parentInjector) {
    const envInjector = getOrCreateEnvironmentInjector(parentEnvInjector, tDetails, providers);
    return new ChainedInjector(parentInjector, envInjector);
  }
  return getOrCreateEnvironmentInjector(parentInjector, tDetails, providers);
}
function applyDeferBlockState(newState, lDetails, lContainer, tNode, hostLView) {
  const stateTmplIndex = getTemplateIndexForState(newState, hostLView, tNode);
  if (stateTmplIndex !== null) {
    lDetails[DEFER_BLOCK_STATE] = newState;
    const hostTView = hostLView[TVIEW];
    const adjustedIndex = stateTmplIndex + HEADER_OFFSET;
    const activeBlockTNode = getTNode(hostTView, adjustedIndex);
    const viewIndex = 0;
    removeLViewFromLContainer(lContainer, viewIndex);
    let injector;
    if (newState === DeferBlockState.Complete) {
      const tDetails = getTDeferBlockDetails(hostTView, tNode);
      const providers = tDetails.providers;
      if (providers && providers.length > 0) {
        injector = createDeferBlockInjector(hostLView[INJECTOR], tDetails, providers);
      }
    }
    const dehydratedView = findMatchingDehydratedView(lContainer, activeBlockTNode.tView.ssrId);
    const embeddedLView = createAndRenderEmbeddedLView(hostLView, activeBlockTNode, null, {
      dehydratedView,
      injector
    });
    addLViewToLContainer(lContainer, embeddedLView, viewIndex, shouldAddViewToDom(activeBlockTNode, dehydratedView));
    markViewDirty(
      embeddedLView,
      2
      /* NotificationSource.DeferBlockStateUpdate */
    );
  }
}
function applyDeferBlockStateWithScheduling(newState, lDetails, lContainer, tNode, hostLView) {
  const now = Date.now();
  const hostTView = hostLView[TVIEW];
  const tDetails = getTDeferBlockDetails(hostTView, tNode);
  if (lDetails[STATE_IS_FROZEN_UNTIL] === null || lDetails[STATE_IS_FROZEN_UNTIL] <= now) {
    lDetails[STATE_IS_FROZEN_UNTIL] = null;
    const loadingAfter = getLoadingBlockAfter(tDetails);
    const inLoadingAfterPhase = lDetails[LOADING_AFTER_CLEANUP_FN] !== null;
    if (newState === DeferBlockState.Loading && loadingAfter !== null && !inLoadingAfterPhase) {
      lDetails[NEXT_DEFER_BLOCK_STATE] = newState;
      const cleanupFn = scheduleDeferBlockUpdate(loadingAfter, lDetails, tNode, lContainer, hostLView);
      lDetails[LOADING_AFTER_CLEANUP_FN] = cleanupFn;
    } else {
      if (newState > DeferBlockState.Loading && inLoadingAfterPhase) {
        lDetails[LOADING_AFTER_CLEANUP_FN]();
        lDetails[LOADING_AFTER_CLEANUP_FN] = null;
        lDetails[NEXT_DEFER_BLOCK_STATE] = null;
      }
      applyDeferBlockState(newState, lDetails, lContainer, tNode, hostLView);
      const duration = getMinimumDurationForState(tDetails, newState);
      if (duration !== null) {
        lDetails[STATE_IS_FROZEN_UNTIL] = now + duration;
        scheduleDeferBlockUpdate(duration, lDetails, tNode, lContainer, hostLView);
      }
    }
  } else {
    lDetails[NEXT_DEFER_BLOCK_STATE] = newState;
  }
}
function scheduleDeferBlockUpdate(timeout, lDetails, tNode, lContainer, hostLView) {
  const callback = () => {
    const nextState = lDetails[NEXT_DEFER_BLOCK_STATE];
    lDetails[STATE_IS_FROZEN_UNTIL] = null;
    lDetails[NEXT_DEFER_BLOCK_STATE] = null;
    if (nextState !== null) {
      renderDeferBlockState(nextState, tNode, lContainer);
    }
  };
  return scheduleTimerTrigger(timeout, callback, hostLView);
}
function isValidStateChange(currentState, newState) {
  return currentState < newState;
}
function triggerPrefetching(tDetails, lView, tNode) {
  if (lView[INJECTOR] && shouldTriggerDeferBlock(lView[INJECTOR])) {
    triggerResourceLoading(tDetails, lView, tNode);
  }
}
function triggerResourceLoading(tDetails, lView, tNode) {
  const injector = lView[INJECTOR];
  const tView = lView[TVIEW];
  if (tDetails.loadingState !== DeferDependenciesLoadingState.NOT_STARTED) {
    return tDetails.loadingPromise ?? Promise.resolve();
  }
  const lDetails = getLDeferBlockDetails(lView, tNode);
  const primaryBlockTNode = getPrimaryBlockTNode(tView, tDetails);
  tDetails.loadingState = DeferDependenciesLoadingState.IN_PROGRESS;
  invokeTriggerCleanupFns(1, lDetails);
  let dependenciesFn = tDetails.dependencyResolverFn;
  if (ngDevMode) {
    const deferDependencyInterceptor = injector.get(DEFER_BLOCK_DEPENDENCY_INTERCEPTOR, null, {
      optional: true
    });
    if (deferDependencyInterceptor) {
      dependenciesFn = deferDependencyInterceptor.intercept(dependenciesFn);
    }
  }
  const pendingTasks = injector.get(PendingTasks);
  const taskId = pendingTasks.add();
  if (!dependenciesFn) {
    tDetails.loadingPromise = Promise.resolve().then(() => {
      tDetails.loadingPromise = null;
      tDetails.loadingState = DeferDependenciesLoadingState.COMPLETE;
      pendingTasks.remove(taskId);
    });
    return tDetails.loadingPromise;
  }
  tDetails.loadingPromise = Promise.allSettled(dependenciesFn()).then((results) => {
    let failed = false;
    const directiveDefs = [];
    const pipeDefs = [];
    for (const result of results) {
      if (result.status === "fulfilled") {
        const dependency = result.value;
        const directiveDef = getComponentDef(dependency) || getDirectiveDef(dependency);
        if (directiveDef) {
          directiveDefs.push(directiveDef);
        } else {
          const pipeDef = getPipeDef$1(dependency);
          if (pipeDef) {
            pipeDefs.push(pipeDef);
          }
        }
      } else {
        failed = true;
        break;
      }
    }
    tDetails.loadingPromise = null;
    pendingTasks.remove(taskId);
    if (failed) {
      tDetails.loadingState = DeferDependenciesLoadingState.FAILED;
      if (tDetails.errorTmplIndex === null) {
        const templateLocation = ngDevMode ? getTemplateLocationDetails(lView) : "";
        const error = new RuntimeError(750, ngDevMode && `Loading dependencies for \`@defer\` block failed, but no \`@error\` block was configured${templateLocation}. Consider using the \`@error\` block to render an error state.`);
        handleError(lView, error);
      }
    } else {
      tDetails.loadingState = DeferDependenciesLoadingState.COMPLETE;
      const primaryBlockTView = primaryBlockTNode.tView;
      if (directiveDefs.length > 0) {
        primaryBlockTView.directiveRegistry = addDepsToRegistry(primaryBlockTView.directiveRegistry, directiveDefs);
        const directiveTypes = directiveDefs.map((def) => def.type);
        const providers = internalImportProvidersFrom(false, ...directiveTypes);
        tDetails.providers = providers;
      }
      if (pipeDefs.length > 0) {
        primaryBlockTView.pipeRegistry = addDepsToRegistry(primaryBlockTView.pipeRegistry, pipeDefs);
      }
    }
  });
  return tDetails.loadingPromise;
}
function renderPlaceholder(lView, tNode) {
  const lContainer = lView[tNode.index];
  ngDevMode && assertLContainer(lContainer);
  renderDeferBlockState(DeferBlockState.Placeholder, tNode, lContainer);
}
function renderDeferStateAfterResourceLoading(tDetails, tNode, lContainer) {
  ngDevMode && assertDefined(tDetails.loadingPromise, "Expected loading Promise to exist on this defer block");
  tDetails.loadingPromise.then(() => {
    if (tDetails.loadingState === DeferDependenciesLoadingState.COMPLETE) {
      ngDevMode && assertDeferredDependenciesLoaded(tDetails);
      renderDeferBlockState(DeferBlockState.Complete, tNode, lContainer);
    } else if (tDetails.loadingState === DeferDependenciesLoadingState.FAILED) {
      renderDeferBlockState(DeferBlockState.Error, tNode, lContainer);
    }
  });
}
function triggerDeferBlock(lView, tNode) {
  const tView = lView[TVIEW];
  const lContainer = lView[tNode.index];
  const injector = lView[INJECTOR];
  ngDevMode && assertLContainer(lContainer);
  if (!shouldTriggerDeferBlock(injector)) return;
  const lDetails = getLDeferBlockDetails(lView, tNode);
  const tDetails = getTDeferBlockDetails(tView, tNode);
  invokeAllTriggerCleanupFns(lDetails);
  switch (tDetails.loadingState) {
    case DeferDependenciesLoadingState.NOT_STARTED:
      renderDeferBlockState(DeferBlockState.Loading, tNode, lContainer);
      triggerResourceLoading(tDetails, lView, tNode);
      if (tDetails.loadingState === DeferDependenciesLoadingState.IN_PROGRESS) {
        renderDeferStateAfterResourceLoading(tDetails, tNode, lContainer);
      }
      break;
    case DeferDependenciesLoadingState.IN_PROGRESS:
      renderDeferBlockState(DeferBlockState.Loading, tNode, lContainer);
      renderDeferStateAfterResourceLoading(tDetails, tNode, lContainer);
      break;
    case DeferDependenciesLoadingState.COMPLETE:
      ngDevMode && assertDeferredDependenciesLoaded(tDetails);
      renderDeferBlockState(DeferBlockState.Complete, tNode, lContainer);
      break;
    case DeferDependenciesLoadingState.FAILED:
      renderDeferBlockState(DeferBlockState.Error, tNode, lContainer);
      break;
    default:
      if (ngDevMode) {
        throwError("Unknown defer block state");
      }
  }
}
function ɵɵattribute(name, value, sanitizer, namespace) {
  const lView = getLView();
  const bindingIndex = nextBindingIndex();
  if (bindingUpdated(lView, bindingIndex, value)) {
    const tView = getTView();
    const tNode = getSelectedTNode();
    elementAttributeInternal(tNode, lView, name, value, sanitizer, namespace);
    ngDevMode && storePropertyBindingMetadata(tView.data, tNode, "attr." + name, bindingIndex);
  }
  return ɵɵattribute;
}
function interpolationV(lView, values) {
  ngDevMode && assertLessThan(2, values.length, "should have at least 3 values");
  ngDevMode && assertEqual(values.length % 2, 1, "should have an odd number of values");
  let isBindingUpdated = false;
  let bindingIndex = getBindingIndex();
  for (let i = 1; i < values.length; i += 2) {
    isBindingUpdated = bindingUpdated(lView, bindingIndex++, values[i]) || isBindingUpdated;
  }
  setBindingIndex(bindingIndex);
  if (!isBindingUpdated) {
    return NO_CHANGE;
  }
  let content = values[0];
  for (let i = 1; i < values.length; i += 2) {
    content += renderStringify(values[i]) + values[i + 1];
  }
  return content;
}
function interpolation1(lView, prefix, v0, suffix) {
  const different = bindingUpdated(lView, nextBindingIndex(), v0);
  return different ? prefix + renderStringify(v0) + suffix : NO_CHANGE;
}
function interpolation2(lView, prefix, v0, i0, v1, suffix) {
  const bindingIndex = getBindingIndex();
  const different = bindingUpdated2(lView, bindingIndex, v0, v1);
  incrementBindingIndex(2);
  return different ? prefix + renderStringify(v0) + i0 + renderStringify(v1) + suffix : NO_CHANGE;
}
function interpolation3(lView, prefix, v0, i0, v1, i1, v2, suffix) {
  const bindingIndex = getBindingIndex();
  const different = bindingUpdated3(lView, bindingIndex, v0, v1, v2);
  incrementBindingIndex(3);
  return different ? prefix + renderStringify(v0) + i0 + renderStringify(v1) + i1 + renderStringify(v2) + suffix : NO_CHANGE;
}
function interpolation4(lView, prefix, v0, i0, v1, i1, v2, i2, v3, suffix) {
  const bindingIndex = getBindingIndex();
  const different = bindingUpdated4(lView, bindingIndex, v0, v1, v2, v3);
  incrementBindingIndex(4);
  return different ? prefix + renderStringify(v0) + i0 + renderStringify(v1) + i1 + renderStringify(v2) + i2 + renderStringify(v3) + suffix : NO_CHANGE;
}
function interpolation5(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, suffix) {
  const bindingIndex = getBindingIndex();
  let different = bindingUpdated4(lView, bindingIndex, v0, v1, v2, v3);
  different = bindingUpdated(lView, bindingIndex + 4, v4) || different;
  incrementBindingIndex(5);
  return different ? prefix + renderStringify(v0) + i0 + renderStringify(v1) + i1 + renderStringify(v2) + i2 + renderStringify(v3) + i3 + renderStringify(v4) + suffix : NO_CHANGE;
}
function interpolation6(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, suffix) {
  const bindingIndex = getBindingIndex();
  let different = bindingUpdated4(lView, bindingIndex, v0, v1, v2, v3);
  different = bindingUpdated2(lView, bindingIndex + 4, v4, v5) || different;
  incrementBindingIndex(6);
  return different ? prefix + renderStringify(v0) + i0 + renderStringify(v1) + i1 + renderStringify(v2) + i2 + renderStringify(v3) + i3 + renderStringify(v4) + i4 + renderStringify(v5) + suffix : NO_CHANGE;
}
function interpolation7(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, suffix) {
  const bindingIndex = getBindingIndex();
  let different = bindingUpdated4(lView, bindingIndex, v0, v1, v2, v3);
  different = bindingUpdated3(lView, bindingIndex + 4, v4, v5, v6) || different;
  incrementBindingIndex(7);
  return different ? prefix + renderStringify(v0) + i0 + renderStringify(v1) + i1 + renderStringify(v2) + i2 + renderStringify(v3) + i3 + renderStringify(v4) + i4 + renderStringify(v5) + i5 + renderStringify(v6) + suffix : NO_CHANGE;
}
function interpolation8(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, i6, v7, suffix) {
  const bindingIndex = getBindingIndex();
  let different = bindingUpdated4(lView, bindingIndex, v0, v1, v2, v3);
  different = bindingUpdated4(lView, bindingIndex + 4, v4, v5, v6, v7) || different;
  incrementBindingIndex(8);
  return different ? prefix + renderStringify(v0) + i0 + renderStringify(v1) + i1 + renderStringify(v2) + i2 + renderStringify(v3) + i3 + renderStringify(v4) + i4 + renderStringify(v5) + i5 + renderStringify(v6) + i6 + renderStringify(v7) + suffix : NO_CHANGE;
}
function ɵɵattributeInterpolate1(attrName, prefix, v0, suffix, sanitizer, namespace) {
  const lView = getLView();
  const interpolatedValue = interpolation1(lView, prefix, v0, suffix);
  if (interpolatedValue !== NO_CHANGE) {
    const tNode = getSelectedTNode();
    elementAttributeInternal(tNode, lView, attrName, interpolatedValue, sanitizer, namespace);
    ngDevMode && storePropertyBindingMetadata(getTView().data, tNode, "attr." + attrName, getBindingIndex() - 1, prefix, suffix);
  }
  return ɵɵattributeInterpolate1;
}
function ɵɵattributeInterpolate2(attrName, prefix, v0, i0, v1, suffix, sanitizer, namespace) {
  const lView = getLView();
  const interpolatedValue = interpolation2(lView, prefix, v0, i0, v1, suffix);
  if (interpolatedValue !== NO_CHANGE) {
    const tNode = getSelectedTNode();
    elementAttributeInternal(tNode, lView, attrName, interpolatedValue, sanitizer, namespace);
    ngDevMode && storePropertyBindingMetadata(getTView().data, tNode, "attr." + attrName, getBindingIndex() - 2, prefix, i0, suffix);
  }
  return ɵɵattributeInterpolate2;
}
function ɵɵattributeInterpolate3(attrName, prefix, v0, i0, v1, i1, v2, suffix, sanitizer, namespace) {
  const lView = getLView();
  const interpolatedValue = interpolation3(lView, prefix, v0, i0, v1, i1, v2, suffix);
  if (interpolatedValue !== NO_CHANGE) {
    const tNode = getSelectedTNode();
    elementAttributeInternal(tNode, lView, attrName, interpolatedValue, sanitizer, namespace);
    ngDevMode && storePropertyBindingMetadata(getTView().data, tNode, "attr." + attrName, getBindingIndex() - 3, prefix, i0, i1, suffix);
  }
  return ɵɵattributeInterpolate3;
}
function ɵɵattributeInterpolate4(attrName, prefix, v0, i0, v1, i1, v2, i2, v3, suffix, sanitizer, namespace) {
  const lView = getLView();
  const interpolatedValue = interpolation4(lView, prefix, v0, i0, v1, i1, v2, i2, v3, suffix);
  if (interpolatedValue !== NO_CHANGE) {
    const tNode = getSelectedTNode();
    elementAttributeInternal(tNode, lView, attrName, interpolatedValue, sanitizer, namespace);
    ngDevMode && storePropertyBindingMetadata(getTView().data, tNode, "attr." + attrName, getBindingIndex() - 4, prefix, i0, i1, i2, suffix);
  }
  return ɵɵattributeInterpolate4;
}
function ɵɵattributeInterpolate5(attrName, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, suffix, sanitizer, namespace) {
  const lView = getLView();
  const interpolatedValue = interpolation5(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, suffix);
  if (interpolatedValue !== NO_CHANGE) {
    const tNode = getSelectedTNode();
    elementAttributeInternal(tNode, lView, attrName, interpolatedValue, sanitizer, namespace);
    ngDevMode && storePropertyBindingMetadata(getTView().data, tNode, "attr." + attrName, getBindingIndex() - 5, prefix, i0, i1, i2, i3, suffix);
  }
  return ɵɵattributeInterpolate5;
}
function ɵɵattributeInterpolate6(attrName, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, suffix, sanitizer, namespace) {
  const lView = getLView();
  const interpolatedValue = interpolation6(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, suffix);
  if (interpolatedValue !== NO_CHANGE) {
    const tNode = getSelectedTNode();
    elementAttributeInternal(tNode, lView, attrName, interpolatedValue, sanitizer, namespace);
    ngDevMode && storePropertyBindingMetadata(getTView().data, tNode, "attr." + attrName, getBindingIndex() - 6, prefix, i0, i1, i2, i3, i4, suffix);
  }
  return ɵɵattributeInterpolate6;
}
function ɵɵattributeInterpolate7(attrName, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, suffix, sanitizer, namespace) {
  const lView = getLView();
  const interpolatedValue = interpolation7(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, suffix);
  if (interpolatedValue !== NO_CHANGE) {
    const tNode = getSelectedTNode();
    elementAttributeInternal(tNode, lView, attrName, interpolatedValue, sanitizer, namespace);
    ngDevMode && storePropertyBindingMetadata(getTView().data, tNode, "attr." + attrName, getBindingIndex() - 7, prefix, i0, i1, i2, i3, i4, i5, suffix);
  }
  return ɵɵattributeInterpolate7;
}
function ɵɵattributeInterpolate8(attrName, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, i6, v7, suffix, sanitizer, namespace) {
  const lView = getLView();
  const interpolatedValue = interpolation8(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, i6, v7, suffix);
  if (interpolatedValue !== NO_CHANGE) {
    const tNode = getSelectedTNode();
    elementAttributeInternal(tNode, lView, attrName, interpolatedValue, sanitizer, namespace);
    ngDevMode && storePropertyBindingMetadata(getTView().data, tNode, "attr." + attrName, getBindingIndex() - 8, prefix, i0, i1, i2, i3, i4, i5, i6, suffix);
  }
  return ɵɵattributeInterpolate8;
}
function ɵɵattributeInterpolateV(attrName, values, sanitizer, namespace) {
  const lView = getLView();
  const interpolated = interpolationV(lView, values);
  if (interpolated !== NO_CHANGE) {
    const tNode = getSelectedTNode();
    elementAttributeInternal(tNode, lView, attrName, interpolated, sanitizer, namespace);
    if (ngDevMode) {
      const interpolationInBetween = [values[0]];
      for (let i = 2; i < values.length; i += 2) {
        interpolationInBetween.push(values[i]);
      }
      storePropertyBindingMetadata(getTView().data, tNode, "attr." + attrName, getBindingIndex() - interpolationInBetween.length + 1, ...interpolationInBetween);
    }
  }
  return ɵɵattributeInterpolateV;
}
function toTStylingRange(prev, next) {
  ngDevMode && assertNumberInRange(
    prev,
    0,
    32767
    /* StylingRange.UNSIGNED_MASK */
  );
  ngDevMode && assertNumberInRange(
    next,
    0,
    32767
    /* StylingRange.UNSIGNED_MASK */
  );
  return prev << 17 | next << 2;
}
function getTStylingRangePrev(tStylingRange) {
  ngDevMode && assertNumber(tStylingRange, "expected number");
  return tStylingRange >> 17 & 32767;
}
function getTStylingRangePrevDuplicate(tStylingRange) {
  ngDevMode && assertNumber(tStylingRange, "expected number");
  return (tStylingRange & 2) == 2;
}
function setTStylingRangePrev(tStylingRange, previous) {
  ngDevMode && assertNumber(tStylingRange, "expected number");
  ngDevMode && assertNumberInRange(
    previous,
    0,
    32767
    /* StylingRange.UNSIGNED_MASK */
  );
  return tStylingRange & ~4294836224 | previous << 17;
}
function setTStylingRangePrevDuplicate(tStylingRange) {
  ngDevMode && assertNumber(tStylingRange, "expected number");
  return tStylingRange | 2;
}
function getTStylingRangeNext(tStylingRange) {
  ngDevMode && assertNumber(tStylingRange, "expected number");
  return (tStylingRange & 131068) >> 2;
}
function setTStylingRangeNext(tStylingRange, next) {
  ngDevMode && assertNumber(tStylingRange, "expected number");
  ngDevMode && assertNumberInRange(
    next,
    0,
    32767
    /* StylingRange.UNSIGNED_MASK */
  );
  return tStylingRange & ~131068 | //
  next << 2;
}
function getTStylingRangeNextDuplicate(tStylingRange) {
  ngDevMode && assertNumber(tStylingRange, "expected number");
  return (tStylingRange & 1) === 1;
}
function setTStylingRangeNextDuplicate(tStylingRange) {
  ngDevMode && assertNumber(tStylingRange, "expected number");
  return tStylingRange | 1;
}
function insertTStylingBinding(tData, tNode, tStylingKeyWithStatic, index, isHostBinding, isClassBinding) {
  ngDevMode && assertFirstUpdatePass(getTView());
  let tBindings = isClassBinding ? tNode.classBindings : tNode.styleBindings;
  let tmplHead = getTStylingRangePrev(tBindings);
  let tmplTail = getTStylingRangeNext(tBindings);
  tData[index] = tStylingKeyWithStatic;
  let isKeyDuplicateOfStatic = false;
  let tStylingKey;
  if (Array.isArray(tStylingKeyWithStatic)) {
    const staticKeyValueArray = tStylingKeyWithStatic;
    tStylingKey = staticKeyValueArray[1];
    if (tStylingKey === null || keyValueArrayIndexOf(staticKeyValueArray, tStylingKey) > 0) {
      isKeyDuplicateOfStatic = true;
    }
  } else {
    tStylingKey = tStylingKeyWithStatic;
  }
  if (isHostBinding) {
    const hasTemplateBindings = tmplTail !== 0;
    if (hasTemplateBindings) {
      const previousNode = getTStylingRangePrev(tData[tmplHead + 1]);
      tData[index + 1] = toTStylingRange(previousNode, tmplHead);
      if (previousNode !== 0) {
        tData[previousNode + 1] = setTStylingRangeNext(tData[previousNode + 1], index);
      }
      tData[tmplHead + 1] = setTStylingRangePrev(tData[tmplHead + 1], index);
    } else {
      tData[index + 1] = toTStylingRange(tmplHead, 0);
      if (tmplHead !== 0) {
        tData[tmplHead + 1] = setTStylingRangeNext(tData[tmplHead + 1], index);
      }
      tmplHead = index;
    }
  } else {
    tData[index + 1] = toTStylingRange(tmplTail, 0);
    ngDevMode && assertEqual(tmplHead !== 0 && tmplTail === 0, false, "Adding template bindings after hostBindings is not allowed.");
    if (tmplHead === 0) {
      tmplHead = index;
    } else {
      tData[tmplTail + 1] = setTStylingRangeNext(tData[tmplTail + 1], index);
    }
    tmplTail = index;
  }
  if (isKeyDuplicateOfStatic) {
    tData[index + 1] = setTStylingRangePrevDuplicate(tData[index + 1]);
  }
  markDuplicates(tData, tStylingKey, index, true);
  markDuplicates(tData, tStylingKey, index, false);
  markDuplicateOfResidualStyling(tNode, tStylingKey, tData, index, isClassBinding);
  tBindings = toTStylingRange(tmplHead, tmplTail);
  if (isClassBinding) {
    tNode.classBindings = tBindings;
  } else {
    tNode.styleBindings = tBindings;
  }
}
function markDuplicateOfResidualStyling(tNode, tStylingKey, tData, index, isClassBinding) {
  const residual = isClassBinding ? tNode.residualClasses : tNode.residualStyles;
  if (residual != null && typeof tStylingKey == "string" && keyValueArrayIndexOf(residual, tStylingKey) >= 0) {
    tData[index + 1] = setTStylingRangeNextDuplicate(tData[index + 1]);
  }
}
function markDuplicates(tData, tStylingKey, index, isPrevDir) {
  const tStylingAtIndex = tData[index + 1];
  const isMap = tStylingKey === null;
  let cursor = isPrevDir ? getTStylingRangePrev(tStylingAtIndex) : getTStylingRangeNext(tStylingAtIndex);
  let foundDuplicate = false;
  while (cursor !== 0 && (foundDuplicate === false || isMap)) {
    ngDevMode && assertIndexInRange(tData, cursor);
    const tStylingValueAtCursor = tData[cursor];
    const tStyleRangeAtCursor = tData[cursor + 1];
    if (isStylingMatch(tStylingValueAtCursor, tStylingKey)) {
      foundDuplicate = true;
      tData[cursor + 1] = isPrevDir ? setTStylingRangeNextDuplicate(tStyleRangeAtCursor) : setTStylingRangePrevDuplicate(tStyleRangeAtCursor);
    }
    cursor = isPrevDir ? getTStylingRangePrev(tStyleRangeAtCursor) : getTStylingRangeNext(tStyleRangeAtCursor);
  }
  if (foundDuplicate) {
    tData[index + 1] = isPrevDir ? setTStylingRangePrevDuplicate(tStylingAtIndex) : setTStylingRangeNextDuplicate(tStylingAtIndex);
  }
}
function isStylingMatch(tStylingKeyCursor, tStylingKey) {
  ngDevMode && assertNotEqual(Array.isArray(tStylingKey), true, "Expected that 'tStylingKey' has been unwrapped");
  if (tStylingKeyCursor === null || // If the cursor is `null` it means that we have map at that
  // location so we must assume that we have a match.
  tStylingKey == null || // If `tStylingKey` is `null` then it is a map therefor assume that it
  // contains a match.
  (Array.isArray(tStylingKeyCursor) ? tStylingKeyCursor[1] : tStylingKeyCursor) === tStylingKey) {
    return true;
  } else if (Array.isArray(tStylingKeyCursor) && typeof tStylingKey === "string") {
    return keyValueArrayIndexOf(tStylingKeyCursor, tStylingKey) >= 0;
  }
  return false;
}
var parserState = {
  textEnd: 0,
  key: 0,
  keyEnd: 0,
  value: 0,
  valueEnd: 0
};
function getLastParsedKey(text) {
  return text.substring(parserState.key, parserState.keyEnd);
}
function getLastParsedValue(text) {
  return text.substring(parserState.value, parserState.valueEnd);
}
function parseClassName(text) {
  resetParserState(text);
  return parseClassNameNext(text, consumeWhitespace(text, 0, parserState.textEnd));
}
function parseClassNameNext(text, index) {
  const end = parserState.textEnd;
  if (end === index) {
    return -1;
  }
  index = parserState.keyEnd = consumeClassToken(text, parserState.key = index, end);
  return consumeWhitespace(text, index, end);
}
function parseStyle(text) {
  resetParserState(text);
  return parseStyleNext(text, consumeWhitespace(text, 0, parserState.textEnd));
}
function parseStyleNext(text, startIndex) {
  const end = parserState.textEnd;
  let index = parserState.key = consumeWhitespace(text, startIndex, end);
  if (end === index) {
    return -1;
  }
  index = parserState.keyEnd = consumeStyleKey(text, index, end);
  index = consumeSeparator(
    text,
    index,
    end,
    58
    /* CharCode.COLON */
  );
  index = parserState.value = consumeWhitespace(text, index, end);
  index = parserState.valueEnd = consumeStyleValue(text, index, end);
  return consumeSeparator(
    text,
    index,
    end,
    59
    /* CharCode.SEMI_COLON */
  );
}
function resetParserState(text) {
  parserState.key = 0;
  parserState.keyEnd = 0;
  parserState.value = 0;
  parserState.valueEnd = 0;
  parserState.textEnd = text.length;
}
function consumeWhitespace(text, startIndex, endIndex) {
  while (startIndex < endIndex && text.charCodeAt(startIndex) <= 32) {
    startIndex++;
  }
  return startIndex;
}
function consumeClassToken(text, startIndex, endIndex) {
  while (startIndex < endIndex && text.charCodeAt(startIndex) > 32) {
    startIndex++;
  }
  return startIndex;
}
function consumeStyleKey(text, startIndex, endIndex) {
  let ch;
  while (startIndex < endIndex && ((ch = text.charCodeAt(startIndex)) === 45 || ch === 95 || (ch & -33) >= 65 && (ch & -33) <= 90 || ch >= 48 && ch <= 57)) {
    startIndex++;
  }
  return startIndex;
}
function consumeSeparator(text, startIndex, endIndex, separator) {
  startIndex = consumeWhitespace(text, startIndex, endIndex);
  if (startIndex < endIndex) {
    if (ngDevMode && text.charCodeAt(startIndex) !== separator) {
      malformedStyleError(text, String.fromCharCode(separator), startIndex);
    }
    startIndex++;
  }
  return startIndex;
}
function consumeStyleValue(text, startIndex, endIndex) {
  let ch1 = -1;
  let ch2 = -1;
  let ch3 = -1;
  let i = startIndex;
  let lastChIndex = i;
  while (i < endIndex) {
    const ch = text.charCodeAt(i++);
    if (ch === 59) {
      return lastChIndex;
    } else if (ch === 34 || ch === 39) {
      lastChIndex = i = consumeQuotedText(text, ch, i, endIndex);
    } else if (startIndex === i - 4 && // We have seen only 4 characters so far "URL(" (Ignore "foo_URL()")
    ch3 === 85 && ch2 === 82 && ch1 === 76 && ch === 40) {
      lastChIndex = i = consumeQuotedText(text, 41, i, endIndex);
    } else if (ch > 32) {
      lastChIndex = i;
    }
    ch3 = ch2;
    ch2 = ch1;
    ch1 = ch & -33;
  }
  return lastChIndex;
}
function consumeQuotedText(text, quoteCharCode, startIndex, endIndex) {
  let ch1 = -1;
  let index = startIndex;
  while (index < endIndex) {
    const ch = text.charCodeAt(index++);
    if (ch == quoteCharCode && ch1 !== 92) {
      return index;
    }
    if (ch == 92 && ch1 === 92) {
      ch1 = 0;
    } else {
      ch1 = ch;
    }
  }
  throw ngDevMode ? malformedStyleError(text, String.fromCharCode(quoteCharCode), endIndex) : new Error();
}
function malformedStyleError(text, expecting, index) {
  ngDevMode && assertEqual(typeof text === "string", true, "String expected here");
  throw throwError(`Malformed style at location ${index} in string '` + text.substring(0, index) + "[>>" + text.substring(index, index + 1) + "<<]" + text.slice(index + 1) + `'. Expecting '${expecting}'.`);
}
function ɵɵproperty(propName, value, sanitizer) {
  const lView = getLView();
  const bindingIndex = nextBindingIndex();
  if (bindingUpdated(lView, bindingIndex, value)) {
    const tView = getTView();
    const tNode = getSelectedTNode();
    elementPropertyInternal(tView, tNode, lView, propName, value, lView[RENDERER], sanitizer, false);
    ngDevMode && storePropertyBindingMetadata(tView.data, tNode, propName, bindingIndex);
  }
  return ɵɵproperty;
}
function setDirectiveInputsWhichShadowsStyling(tView, tNode, lView, value, isClassBased) {
  const inputs = tNode.inputs;
  const property = isClassBased ? "class" : "style";
  setInputsForProperty(tView, lView, inputs[property], property, value);
}
function ɵɵstyleProp(prop, value, suffix) {
  checkStylingProperty(prop, value, suffix, false);
  return ɵɵstyleProp;
}
function ɵɵclassProp(className, value) {
  checkStylingProperty(className, value, null, true);
  return ɵɵclassProp;
}
function ɵɵstyleMap(styles) {
  checkStylingMap(styleKeyValueArraySet, styleStringParser, styles, false);
}
function styleStringParser(keyValueArray, text) {
  for (let i = parseStyle(text); i >= 0; i = parseStyleNext(text, i)) {
    styleKeyValueArraySet(keyValueArray, getLastParsedKey(text), getLastParsedValue(text));
  }
}
function ɵɵclassMap(classes) {
  checkStylingMap(classKeyValueArraySet, classStringParser, classes, true);
}
function classStringParser(keyValueArray, text) {
  for (let i = parseClassName(text); i >= 0; i = parseClassNameNext(text, i)) {
    keyValueArraySet(keyValueArray, getLastParsedKey(text), true);
  }
}
function checkStylingProperty(prop, value, suffix, isClassBased) {
  const lView = getLView();
  const tView = getTView();
  const bindingIndex = incrementBindingIndex(2);
  if (tView.firstUpdatePass) {
    stylingFirstUpdatePass(tView, prop, bindingIndex, isClassBased);
  }
  if (value !== NO_CHANGE && bindingUpdated(lView, bindingIndex, value)) {
    const tNode = tView.data[getSelectedIndex()];
    updateStyling(tView, tNode, lView, lView[RENDERER], prop, lView[bindingIndex + 1] = normalizeSuffix(value, suffix), isClassBased, bindingIndex);
  }
}
function checkStylingMap(keyValueArraySet2, stringParser, value, isClassBased) {
  const tView = getTView();
  const bindingIndex = incrementBindingIndex(2);
  if (tView.firstUpdatePass) {
    stylingFirstUpdatePass(tView, null, bindingIndex, isClassBased);
  }
  const lView = getLView();
  if (value !== NO_CHANGE && bindingUpdated(lView, bindingIndex, value)) {
    const tNode = tView.data[getSelectedIndex()];
    if (hasStylingInputShadow(tNode, isClassBased) && !isInHostBindings(tView, bindingIndex)) {
      if (ngDevMode) {
        const tStylingKey = tView.data[bindingIndex];
        assertEqual(Array.isArray(tStylingKey) ? tStylingKey[1] : tStylingKey, false, "Styling linked list shadow input should be marked as 'false'");
      }
      let staticPrefix = isClassBased ? tNode.classesWithoutHost : tNode.stylesWithoutHost;
      ngDevMode && isClassBased === false && staticPrefix !== null && assertEqual(staticPrefix.endsWith(";"), true, "Expecting static portion to end with ';'");
      if (staticPrefix !== null) {
        value = concatStringsWithSpace(staticPrefix, value ? value : "");
      }
      setDirectiveInputsWhichShadowsStyling(tView, tNode, lView, value, isClassBased);
    } else {
      updateStylingMap(tView, tNode, lView, lView[RENDERER], lView[bindingIndex + 1], lView[bindingIndex + 1] = toStylingKeyValueArray(keyValueArraySet2, stringParser, value), isClassBased, bindingIndex);
    }
  }
}
function isInHostBindings(tView, bindingIndex) {
  return bindingIndex >= tView.expandoStartIndex;
}
function stylingFirstUpdatePass(tView, tStylingKey, bindingIndex, isClassBased) {
  ngDevMode && assertFirstUpdatePass(tView);
  const tData = tView.data;
  if (tData[bindingIndex + 1] === null) {
    const tNode = tData[getSelectedIndex()];
    ngDevMode && assertDefined(tNode, "TNode expected");
    const isHostBindings = isInHostBindings(tView, bindingIndex);
    if (hasStylingInputShadow(tNode, isClassBased) && tStylingKey === null && !isHostBindings) {
      tStylingKey = false;
    }
    tStylingKey = wrapInStaticStylingKey(tData, tNode, tStylingKey, isClassBased);
    insertTStylingBinding(tData, tNode, tStylingKey, bindingIndex, isHostBindings, isClassBased);
  }
}
function wrapInStaticStylingKey(tData, tNode, stylingKey, isClassBased) {
  const hostDirectiveDef = getCurrentDirectiveDef(tData);
  let residual = isClassBased ? tNode.residualClasses : tNode.residualStyles;
  if (hostDirectiveDef === null) {
    const isFirstStylingInstructionInTemplate = (isClassBased ? tNode.classBindings : tNode.styleBindings) === 0;
    if (isFirstStylingInstructionInTemplate) {
      stylingKey = collectStylingFromDirectives(null, tData, tNode, stylingKey, isClassBased);
      stylingKey = collectStylingFromTAttrs(stylingKey, tNode.attrs, isClassBased);
      residual = null;
    }
  } else {
    const directiveStylingLast = tNode.directiveStylingLast;
    const isFirstStylingInstructionInHostBinding = directiveStylingLast === -1 || tData[directiveStylingLast] !== hostDirectiveDef;
    if (isFirstStylingInstructionInHostBinding) {
      stylingKey = collectStylingFromDirectives(hostDirectiveDef, tData, tNode, stylingKey, isClassBased);
      if (residual === null) {
        let templateStylingKey = getTemplateHeadTStylingKey(tData, tNode, isClassBased);
        if (templateStylingKey !== void 0 && Array.isArray(templateStylingKey)) {
          templateStylingKey = collectStylingFromDirectives(null, tData, tNode, templateStylingKey[1], isClassBased);
          templateStylingKey = collectStylingFromTAttrs(templateStylingKey, tNode.attrs, isClassBased);
          setTemplateHeadTStylingKey(tData, tNode, isClassBased, templateStylingKey);
        }
      } else {
        residual = collectResidual(tData, tNode, isClassBased);
      }
    }
  }
  if (residual !== void 0) {
    isClassBased ? tNode.residualClasses = residual : tNode.residualStyles = residual;
  }
  return stylingKey;
}
function getTemplateHeadTStylingKey(tData, tNode, isClassBased) {
  const bindings = isClassBased ? tNode.classBindings : tNode.styleBindings;
  if (getTStylingRangeNext(bindings) === 0) {
    return void 0;
  }
  return tData[getTStylingRangePrev(bindings)];
}
function setTemplateHeadTStylingKey(tData, tNode, isClassBased, tStylingKey) {
  const bindings = isClassBased ? tNode.classBindings : tNode.styleBindings;
  ngDevMode && assertNotEqual(getTStylingRangeNext(bindings), 0, "Expecting to have at least one template styling binding.");
  tData[getTStylingRangePrev(bindings)] = tStylingKey;
}
function collectResidual(tData, tNode, isClassBased) {
  let residual = void 0;
  const directiveEnd = tNode.directiveEnd;
  ngDevMode && assertNotEqual(tNode.directiveStylingLast, -1, "By the time this function gets called at least one hostBindings-node styling instruction must have executed.");
  for (let i = 1 + tNode.directiveStylingLast; i < directiveEnd; i++) {
    const attrs = tData[i].hostAttrs;
    residual = collectStylingFromTAttrs(residual, attrs, isClassBased);
  }
  return collectStylingFromTAttrs(residual, tNode.attrs, isClassBased);
}
function collectStylingFromDirectives(hostDirectiveDef, tData, tNode, stylingKey, isClassBased) {
  let currentDirective = null;
  const directiveEnd = tNode.directiveEnd;
  let directiveStylingLast = tNode.directiveStylingLast;
  if (directiveStylingLast === -1) {
    directiveStylingLast = tNode.directiveStart;
  } else {
    directiveStylingLast++;
  }
  while (directiveStylingLast < directiveEnd) {
    currentDirective = tData[directiveStylingLast];
    ngDevMode && assertDefined(currentDirective, "expected to be defined");
    stylingKey = collectStylingFromTAttrs(stylingKey, currentDirective.hostAttrs, isClassBased);
    if (currentDirective === hostDirectiveDef) break;
    directiveStylingLast++;
  }
  if (hostDirectiveDef !== null) {
    tNode.directiveStylingLast = directiveStylingLast;
  }
  return stylingKey;
}
function collectStylingFromTAttrs(stylingKey, attrs, isClassBased) {
  const desiredMarker = isClassBased ? 1 : 2;
  let currentMarker = -1;
  if (attrs !== null) {
    for (let i = 0; i < attrs.length; i++) {
      const item = attrs[i];
      if (typeof item === "number") {
        currentMarker = item;
      } else {
        if (currentMarker === desiredMarker) {
          if (!Array.isArray(stylingKey)) {
            stylingKey = stylingKey === void 0 ? [] : ["", stylingKey];
          }
          keyValueArraySet(stylingKey, item, isClassBased ? true : attrs[++i]);
        }
      }
    }
  }
  return stylingKey === void 0 ? null : stylingKey;
}
function toStylingKeyValueArray(keyValueArraySet2, stringParser, value) {
  if (value == null || value === "") return EMPTY_ARRAY;
  const styleKeyValueArray = [];
  const unwrappedValue = unwrapSafeValue(value);
  if (Array.isArray(unwrappedValue)) {
    for (let i = 0; i < unwrappedValue.length; i++) {
      keyValueArraySet2(styleKeyValueArray, unwrappedValue[i], true);
    }
  } else if (typeof unwrappedValue === "object") {
    for (const key in unwrappedValue) {
      if (unwrappedValue.hasOwnProperty(key)) {
        keyValueArraySet2(styleKeyValueArray, key, unwrappedValue[key]);
      }
    }
  } else if (typeof unwrappedValue === "string") {
    stringParser(styleKeyValueArray, unwrappedValue);
  } else {
    ngDevMode && throwError("Unsupported styling type " + typeof unwrappedValue + ": " + unwrappedValue);
  }
  return styleKeyValueArray;
}
function styleKeyValueArraySet(keyValueArray, key, value) {
  keyValueArraySet(keyValueArray, key, unwrapSafeValue(value));
}
function classKeyValueArraySet(keyValueArray, key, value) {
  const stringKey = String(key);
  if (stringKey !== "" && !stringKey.includes(" ")) {
    keyValueArraySet(keyValueArray, stringKey, value);
  }
}
function updateStylingMap(tView, tNode, lView, renderer, oldKeyValueArray, newKeyValueArray, isClassBased, bindingIndex) {
  if (oldKeyValueArray === NO_CHANGE) {
    oldKeyValueArray = EMPTY_ARRAY;
  }
  let oldIndex = 0;
  let newIndex = 0;
  let oldKey = 0 < oldKeyValueArray.length ? oldKeyValueArray[0] : null;
  let newKey = 0 < newKeyValueArray.length ? newKeyValueArray[0] : null;
  while (oldKey !== null || newKey !== null) {
    ngDevMode && assertLessThan(oldIndex, 999, "Are we stuck in infinite loop?");
    ngDevMode && assertLessThan(newIndex, 999, "Are we stuck in infinite loop?");
    const oldValue = oldIndex < oldKeyValueArray.length ? oldKeyValueArray[oldIndex + 1] : void 0;
    const newValue = newIndex < newKeyValueArray.length ? newKeyValueArray[newIndex + 1] : void 0;
    let setKey = null;
    let setValue = void 0;
    if (oldKey === newKey) {
      oldIndex += 2;
      newIndex += 2;
      if (oldValue !== newValue) {
        setKey = newKey;
        setValue = newValue;
      }
    } else if (newKey === null || oldKey !== null && oldKey < newKey) {
      oldIndex += 2;
      setKey = oldKey;
    } else {
      ngDevMode && assertDefined(newKey, "Expecting to have a valid key");
      newIndex += 2;
      setKey = newKey;
      setValue = newValue;
    }
    if (setKey !== null) {
      updateStyling(tView, tNode, lView, renderer, setKey, setValue, isClassBased, bindingIndex);
    }
    oldKey = oldIndex < oldKeyValueArray.length ? oldKeyValueArray[oldIndex] : null;
    newKey = newIndex < newKeyValueArray.length ? newKeyValueArray[newIndex] : null;
  }
}
function updateStyling(tView, tNode, lView, renderer, prop, value, isClassBased, bindingIndex) {
  if (!(tNode.type & 3)) {
    return;
  }
  const tData = tView.data;
  const tRange = tData[bindingIndex + 1];
  const higherPriorityValue = getTStylingRangeNextDuplicate(tRange) ? findStylingValue(tData, tNode, lView, prop, getTStylingRangeNext(tRange), isClassBased) : void 0;
  if (!isStylingValuePresent(higherPriorityValue)) {
    if (!isStylingValuePresent(value)) {
      if (getTStylingRangePrevDuplicate(tRange)) {
        value = findStylingValue(tData, null, lView, prop, bindingIndex, isClassBased);
      }
    }
    const rNode = getNativeByIndex(getSelectedIndex(), lView);
    applyStyling(renderer, isClassBased, rNode, prop, value);
  }
}
function findStylingValue(tData, tNode, lView, prop, index, isClassBased) {
  const isPrevDirection = tNode === null;
  let value = void 0;
  while (index > 0) {
    const rawKey = tData[index];
    const containsStatics = Array.isArray(rawKey);
    const key = containsStatics ? rawKey[1] : rawKey;
    const isStylingMap = key === null;
    let valueAtLViewIndex = lView[index + 1];
    if (valueAtLViewIndex === NO_CHANGE) {
      valueAtLViewIndex = isStylingMap ? EMPTY_ARRAY : void 0;
    }
    let currentValue = isStylingMap ? keyValueArrayGet(valueAtLViewIndex, prop) : key === prop ? valueAtLViewIndex : void 0;
    if (containsStatics && !isStylingValuePresent(currentValue)) {
      currentValue = keyValueArrayGet(rawKey, prop);
    }
    if (isStylingValuePresent(currentValue)) {
      value = currentValue;
      if (isPrevDirection) {
        return value;
      }
    }
    const tRange = tData[index + 1];
    index = isPrevDirection ? getTStylingRangePrev(tRange) : getTStylingRangeNext(tRange);
  }
  if (tNode !== null) {
    let residual = isClassBased ? tNode.residualClasses : tNode.residualStyles;
    if (residual != null) {
      value = keyValueArrayGet(residual, prop);
    }
  }
  return value;
}
function isStylingValuePresent(value) {
  return value !== void 0;
}
function normalizeSuffix(value, suffix) {
  if (value == null || value === "") {
  } else if (typeof suffix === "string") {
    value = value + suffix;
  } else if (typeof value === "object") {
    value = stringify(unwrapSafeValue(value));
  }
  return value;
}
function hasStylingInputShadow(tNode, isClassBased) {
  return (tNode.flags & (isClassBased ? 8 : 16)) !== 0;
}
function ɵɵclassMapInterpolate1(prefix, v0, suffix) {
  const lView = getLView();
  const interpolatedValue = interpolation1(lView, prefix, v0, suffix);
  checkStylingMap(keyValueArraySet, classStringParser, interpolatedValue, true);
}
function ɵɵclassMapInterpolate2(prefix, v0, i0, v1, suffix) {
  const lView = getLView();
  const interpolatedValue = interpolation2(lView, prefix, v0, i0, v1, suffix);
  checkStylingMap(keyValueArraySet, classStringParser, interpolatedValue, true);
}
function ɵɵclassMapInterpolate3(prefix, v0, i0, v1, i1, v2, suffix) {
  const lView = getLView();
  const interpolatedValue = interpolation3(lView, prefix, v0, i0, v1, i1, v2, suffix);
  checkStylingMap(keyValueArraySet, classStringParser, interpolatedValue, true);
}
function ɵɵclassMapInterpolate4(prefix, v0, i0, v1, i1, v2, i2, v3, suffix) {
  const lView = getLView();
  const interpolatedValue = interpolation4(lView, prefix, v0, i0, v1, i1, v2, i2, v3, suffix);
  checkStylingMap(keyValueArraySet, classStringParser, interpolatedValue, true);
}
function ɵɵclassMapInterpolate5(prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, suffix) {
  const lView = getLView();
  const interpolatedValue = interpolation5(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, suffix);
  checkStylingMap(keyValueArraySet, classStringParser, interpolatedValue, true);
}
function ɵɵclassMapInterpolate6(prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, suffix) {
  const lView = getLView();
  const interpolatedValue = interpolation6(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, suffix);
  checkStylingMap(keyValueArraySet, classStringParser, interpolatedValue, true);
}
function ɵɵclassMapInterpolate7(prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, suffix) {
  const lView = getLView();
  const interpolatedValue = interpolation7(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, suffix);
  checkStylingMap(keyValueArraySet, classStringParser, interpolatedValue, true);
}
function ɵɵclassMapInterpolate8(prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, i6, v7, suffix) {
  const lView = getLView();
  const interpolatedValue = interpolation8(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, i6, v7, suffix);
  checkStylingMap(keyValueArraySet, classStringParser, interpolatedValue, true);
}
function ɵɵclassMapInterpolateV(values) {
  const lView = getLView();
  const interpolatedValue = interpolationV(lView, values);
  checkStylingMap(keyValueArraySet, classStringParser, interpolatedValue, true);
}
function ɵɵcomponentInstance() {
  const instance = getLView()[DECLARATION_COMPONENT_VIEW][CONTEXT];
  ngDevMode && assertDefined(instance, "Expected component instance to be defined");
  return instance;
}
var LiveCollection = class {
  destroy(item) {
  }
  updateValue(index, value) {
  }
  // operations below could be implemented on top of the operations defined so far, but having
  // them explicitly allow clear expression of intent and potentially more performant
  // implementations
  swap(index1, index2) {
    const startIdx = Math.min(index1, index2);
    const endIdx = Math.max(index1, index2);
    const endItem = this.detach(endIdx);
    if (endIdx - startIdx > 1) {
      const startItem = this.detach(startIdx);
      this.attach(startIdx, endItem);
      this.attach(endIdx, startItem);
    } else {
      this.attach(startIdx, endItem);
    }
  }
  move(prevIndex, newIdx) {
    this.attach(newIdx, this.detach(prevIndex));
  }
};
function valuesMatching(liveIdx, liveValue, newIdx, newValue, trackBy) {
  if (liveIdx === newIdx && Object.is(liveValue, newValue)) {
    return 1;
  } else if (Object.is(trackBy(liveIdx, liveValue), trackBy(newIdx, newValue))) {
    return -1;
  }
  return 0;
}
function recordDuplicateKeys(keyToIdx, key, idx) {
  const idxSoFar = keyToIdx.get(key);
  if (idxSoFar !== void 0) {
    idxSoFar.add(idx);
  } else {
    keyToIdx.set(key, /* @__PURE__ */ new Set([idx]));
  }
}
function reconcile(liveCollection, newCollection, trackByFn) {
  let detachedItems = void 0;
  let liveKeysInTheFuture = void 0;
  let liveStartIdx = 0;
  let liveEndIdx = liveCollection.length - 1;
  const duplicateKeys = ngDevMode ? /* @__PURE__ */ new Map() : void 0;
  if (Array.isArray(newCollection)) {
    let newEndIdx = newCollection.length - 1;
    while (liveStartIdx <= liveEndIdx && liveStartIdx <= newEndIdx) {
      const liveStartValue = liveCollection.at(liveStartIdx);
      const newStartValue = newCollection[liveStartIdx];
      if (ngDevMode) {
        recordDuplicateKeys(duplicateKeys, trackByFn(liveStartIdx, newStartValue), liveStartIdx);
      }
      const isStartMatching = valuesMatching(liveStartIdx, liveStartValue, liveStartIdx, newStartValue, trackByFn);
      if (isStartMatching !== 0) {
        if (isStartMatching < 0) {
          liveCollection.updateValue(liveStartIdx, newStartValue);
        }
        liveStartIdx++;
        continue;
      }
      const liveEndValue = liveCollection.at(liveEndIdx);
      const newEndValue = newCollection[newEndIdx];
      if (ngDevMode) {
        recordDuplicateKeys(duplicateKeys, trackByFn(newEndIdx, newEndValue), newEndIdx);
      }
      const isEndMatching = valuesMatching(liveEndIdx, liveEndValue, newEndIdx, newEndValue, trackByFn);
      if (isEndMatching !== 0) {
        if (isEndMatching < 0) {
          liveCollection.updateValue(liveEndIdx, newEndValue);
        }
        liveEndIdx--;
        newEndIdx--;
        continue;
      }
      const liveStartKey = trackByFn(liveStartIdx, liveStartValue);
      const liveEndKey = trackByFn(liveEndIdx, liveEndValue);
      const newStartKey = trackByFn(liveStartIdx, newStartValue);
      if (Object.is(newStartKey, liveEndKey)) {
        const newEndKey = trackByFn(newEndIdx, newEndValue);
        if (Object.is(newEndKey, liveStartKey)) {
          liveCollection.swap(liveStartIdx, liveEndIdx);
          liveCollection.updateValue(liveEndIdx, newEndValue);
          newEndIdx--;
          liveEndIdx--;
        } else {
          liveCollection.move(liveEndIdx, liveStartIdx);
        }
        liveCollection.updateValue(liveStartIdx, newStartValue);
        liveStartIdx++;
        continue;
      }
      detachedItems ??= new UniqueValueMultiKeyMap();
      liveKeysInTheFuture ??= initLiveItemsInTheFuture(liveCollection, liveStartIdx, liveEndIdx, trackByFn);
      if (attachPreviouslyDetached(liveCollection, detachedItems, liveStartIdx, newStartKey)) {
        liveCollection.updateValue(liveStartIdx, newStartValue);
        liveStartIdx++;
        liveEndIdx++;
      } else if (!liveKeysInTheFuture.has(newStartKey)) {
        const newItem = liveCollection.create(liveStartIdx, newCollection[liveStartIdx]);
        liveCollection.attach(liveStartIdx, newItem);
        liveStartIdx++;
        liveEndIdx++;
      } else {
        detachedItems.set(liveStartKey, liveCollection.detach(liveStartIdx));
        liveEndIdx--;
      }
    }
    while (liveStartIdx <= newEndIdx) {
      createOrAttach(liveCollection, detachedItems, trackByFn, liveStartIdx, newCollection[liveStartIdx]);
      liveStartIdx++;
    }
  } else if (newCollection != null) {
    const newCollectionIterator = newCollection[Symbol.iterator]();
    let newIterationResult = newCollectionIterator.next();
    while (!newIterationResult.done && liveStartIdx <= liveEndIdx) {
      const liveValue = liveCollection.at(liveStartIdx);
      const newValue = newIterationResult.value;
      if (ngDevMode) {
        recordDuplicateKeys(duplicateKeys, trackByFn(liveStartIdx, newValue), liveStartIdx);
      }
      const isStartMatching = valuesMatching(liveStartIdx, liveValue, liveStartIdx, newValue, trackByFn);
      if (isStartMatching !== 0) {
        if (isStartMatching < 0) {
          liveCollection.updateValue(liveStartIdx, newValue);
        }
        liveStartIdx++;
        newIterationResult = newCollectionIterator.next();
      } else {
        detachedItems ??= new UniqueValueMultiKeyMap();
        liveKeysInTheFuture ??= initLiveItemsInTheFuture(liveCollection, liveStartIdx, liveEndIdx, trackByFn);
        const newKey = trackByFn(liveStartIdx, newValue);
        if (attachPreviouslyDetached(liveCollection, detachedItems, liveStartIdx, newKey)) {
          liveCollection.updateValue(liveStartIdx, newValue);
          liveStartIdx++;
          liveEndIdx++;
          newIterationResult = newCollectionIterator.next();
        } else if (!liveKeysInTheFuture.has(newKey)) {
          liveCollection.attach(liveStartIdx, liveCollection.create(liveStartIdx, newValue));
          liveStartIdx++;
          liveEndIdx++;
          newIterationResult = newCollectionIterator.next();
        } else {
          const liveKey = trackByFn(liveStartIdx, liveValue);
          detachedItems.set(liveKey, liveCollection.detach(liveStartIdx));
          liveEndIdx--;
        }
      }
    }
    while (!newIterationResult.done) {
      createOrAttach(liveCollection, detachedItems, trackByFn, liveCollection.length, newIterationResult.value);
      newIterationResult = newCollectionIterator.next();
    }
  }
  while (liveStartIdx <= liveEndIdx) {
    liveCollection.destroy(liveCollection.detach(liveEndIdx--));
  }
  detachedItems?.forEach((item) => {
    liveCollection.destroy(item);
  });
  if (ngDevMode) {
    let duplicatedKeysMsg = [];
    for (const [key, idxSet] of duplicateKeys) {
      if (idxSet.size > 1) {
        const idx = [...idxSet].sort((a, b) => a - b);
        for (let i = 1; i < idx.length; i++) {
          duplicatedKeysMsg.push(`key "${stringifyForError(key)}" at index "${idx[i - 1]}" and "${idx[i]}"`);
        }
      }
    }
    if (duplicatedKeysMsg.length > 0) {
      const message = formatRuntimeError(-955, "The provided track expression resulted in duplicated keys for a given collection. Adjust the tracking expression such that it uniquely identifies all the items in the collection. Duplicated keys were: \n" + duplicatedKeysMsg.join(", \n") + ".");
      console.warn(message);
    }
  }
}
function attachPreviouslyDetached(prevCollection, detachedItems, index, key) {
  if (detachedItems !== void 0 && detachedItems.has(key)) {
    prevCollection.attach(index, detachedItems.get(key));
    detachedItems.delete(key);
    return true;
  }
  return false;
}
function createOrAttach(liveCollection, detachedItems, trackByFn, index, value) {
  if (!attachPreviouslyDetached(liveCollection, detachedItems, index, trackByFn(index, value))) {
    const newItem = liveCollection.create(index, value);
    liveCollection.attach(index, newItem);
  } else {
    liveCollection.updateValue(index, value);
  }
}
function initLiveItemsInTheFuture(liveCollection, start, end, trackByFn) {
  const keys = /* @__PURE__ */ new Set();
  for (let i = start; i <= end; i++) {
    keys.add(trackByFn(i, liveCollection.at(i)));
  }
  return keys;
}
var UniqueValueMultiKeyMap = class {
  constructor() {
    this.kvMap = /* @__PURE__ */ new Map();
    this._vMap = void 0;
  }
  has(key) {
    return this.kvMap.has(key);
  }
  delete(key) {
    if (!this.has(key)) return false;
    const value = this.kvMap.get(key);
    if (this._vMap !== void 0 && this._vMap.has(value)) {
      this.kvMap.set(key, this._vMap.get(value));
      this._vMap.delete(value);
    } else {
      this.kvMap.delete(key);
    }
    return true;
  }
  get(key) {
    return this.kvMap.get(key);
  }
  set(key, value) {
    if (this.kvMap.has(key)) {
      let prevValue = this.kvMap.get(key);
      ngDevMode && assertNotSame(prevValue, value, `Detected a duplicated value ${value} for the key ${key}`);
      if (this._vMap === void 0) {
        this._vMap = /* @__PURE__ */ new Map();
      }
      const vMap = this._vMap;
      while (vMap.has(prevValue)) {
        prevValue = vMap.get(prevValue);
      }
      vMap.set(prevValue, value);
    } else {
      this.kvMap.set(key, value);
    }
  }
  forEach(cb) {
    for (let [key, value] of this.kvMap) {
      cb(value, key);
      if (this._vMap !== void 0) {
        const vMap = this._vMap;
        while (vMap.has(value)) {
          value = vMap.get(value);
          cb(value, key);
        }
      }
    }
  }
};
function ɵɵconditional(matchingTemplateIndex, contextValue) {
  performanceMarkFeature("NgControlFlow");
  const hostLView = getLView();
  const bindingIndex = nextBindingIndex();
  const prevMatchingTemplateIndex = hostLView[bindingIndex] !== NO_CHANGE ? hostLView[bindingIndex] : -1;
  const prevContainer = prevMatchingTemplateIndex !== -1 ? getLContainer(hostLView, HEADER_OFFSET + prevMatchingTemplateIndex) : void 0;
  const viewInContainerIdx = 0;
  if (bindingUpdated(hostLView, bindingIndex, matchingTemplateIndex)) {
    const prevConsumer = setActiveConsumer(null);
    try {
      if (prevContainer !== void 0) {
        removeLViewFromLContainer(prevContainer, viewInContainerIdx);
      }
      if (matchingTemplateIndex !== -1) {
        const nextLContainerIndex = HEADER_OFFSET + matchingTemplateIndex;
        const nextContainer = getLContainer(hostLView, nextLContainerIndex);
        const templateTNode = getExistingTNode(hostLView[TVIEW], nextLContainerIndex);
        const dehydratedView = findMatchingDehydratedView(nextContainer, templateTNode.tView.ssrId);
        const embeddedLView = createAndRenderEmbeddedLView(hostLView, templateTNode, contextValue, {
          dehydratedView
        });
        addLViewToLContainer(nextContainer, embeddedLView, viewInContainerIdx, shouldAddViewToDom(templateTNode, dehydratedView));
      }
    } finally {
      setActiveConsumer(prevConsumer);
    }
  } else if (prevContainer !== void 0) {
    const lView = getLViewFromLContainer(prevContainer, viewInContainerIdx);
    if (lView !== void 0) {
      lView[CONTEXT] = contextValue;
    }
  }
}
var RepeaterContext = class {
  constructor(lContainer, $implicit, $index) {
    this.lContainer = lContainer;
    this.$implicit = $implicit;
    this.$index = $index;
  }
  get $count() {
    return this.lContainer.length - CONTAINER_HEADER_OFFSET;
  }
};
function ɵɵrepeaterTrackByIndex(index) {
  return index;
}
function ɵɵrepeaterTrackByIdentity(_, value) {
  return value;
}
var RepeaterMetadata = class {
  constructor(hasEmptyBlock, trackByFn, liveCollection) {
    this.hasEmptyBlock = hasEmptyBlock;
    this.trackByFn = trackByFn;
    this.liveCollection = liveCollection;
  }
};
function ɵɵrepeaterCreate(index, templateFn, decls, vars, tagName, attrsIndex, trackByFn, trackByUsesComponentInstance, emptyTemplateFn, emptyDecls, emptyVars, emptyTagName, emptyAttrsIndex) {
  performanceMarkFeature("NgControlFlow");
  ngDevMode && assertFunction(trackByFn, `A track expression must be a function, was ${typeof trackByFn} instead.`);
  const lView = getLView();
  const tView = getTView();
  const hasEmptyBlock = emptyTemplateFn !== void 0;
  const hostLView = getLView();
  const boundTrackBy = trackByUsesComponentInstance ? (
    // We only want to bind when necessary, because it produces a
    // new function. For pure functions it's not necessary.
    trackByFn.bind(hostLView[DECLARATION_COMPONENT_VIEW][CONTEXT])
  ) : trackByFn;
  const metadata = new RepeaterMetadata(hasEmptyBlock, boundTrackBy);
  hostLView[HEADER_OFFSET + index] = metadata;
  declareTemplate(lView, tView, index + 1, templateFn, decls, vars, tagName, getConstant(tView.consts, attrsIndex));
  if (hasEmptyBlock) {
    ngDevMode && assertDefined(emptyDecls, "Missing number of declarations for the empty repeater block.");
    ngDevMode && assertDefined(emptyVars, "Missing number of bindings for the empty repeater block.");
    declareTemplate(lView, tView, index + 2, emptyTemplateFn, emptyDecls, emptyVars, emptyTagName, getConstant(tView.consts, emptyAttrsIndex));
  }
}
function isViewExpensiveToRecreate(lView) {
  return lView.length - HEADER_OFFSET > 2;
}
var OperationsCounter = class {
  constructor() {
    this.created = 0;
    this.destroyed = 0;
  }
  reset() {
    this.created = 0;
    this.destroyed = 0;
  }
  recordCreate() {
    this.created++;
  }
  recordDestroy() {
    this.destroyed++;
  }
  /**
   * A method indicating if the entire collection was re-created as part of the reconciliation pass.
   * Used to warn developers about the usage of a tracking function that might result in excessive
   * amount of view creation / destroy operations.
   *
   * @returns boolean value indicating if a live collection was re-created
   */
  wasReCreated(collectionLen) {
    return collectionLen > 0 && this.created === this.destroyed && this.created === collectionLen;
  }
};
var LiveCollectionLContainerImpl = class extends LiveCollection {
  constructor(lContainer, hostLView, templateTNode) {
    super();
    this.lContainer = lContainer;
    this.hostLView = hostLView;
    this.templateTNode = templateTNode;
    this.operationsCounter = ngDevMode ? new OperationsCounter() : void 0;
    this.needsIndexUpdate = false;
  }
  get length() {
    return this.lContainer.length - CONTAINER_HEADER_OFFSET;
  }
  at(index) {
    return this.getLView(index)[CONTEXT].$implicit;
  }
  attach(index, lView) {
    const dehydratedView = lView[HYDRATION];
    this.needsIndexUpdate ||= index !== this.length;
    addLViewToLContainer(this.lContainer, lView, index, shouldAddViewToDom(this.templateTNode, dehydratedView));
  }
  detach(index) {
    this.needsIndexUpdate ||= index !== this.length - 1;
    return detachExistingView(this.lContainer, index);
  }
  create(index, value) {
    const dehydratedView = findMatchingDehydratedView(this.lContainer, this.templateTNode.tView.ssrId);
    const embeddedLView = createAndRenderEmbeddedLView(this.hostLView, this.templateTNode, new RepeaterContext(this.lContainer, value, index), {
      dehydratedView
    });
    this.operationsCounter?.recordCreate();
    return embeddedLView;
  }
  destroy(lView) {
    destroyLView(lView[TVIEW], lView);
    this.operationsCounter?.recordDestroy();
  }
  updateValue(index, value) {
    this.getLView(index)[CONTEXT].$implicit = value;
  }
  reset() {
    this.needsIndexUpdate = false;
    this.operationsCounter?.reset();
  }
  updateIndexes() {
    if (this.needsIndexUpdate) {
      for (let i = 0; i < this.length; i++) {
        this.getLView(i)[CONTEXT].$index = i;
      }
    }
  }
  getLView(index) {
    return getExistingLViewFromLContainer(this.lContainer, index);
  }
};
function ɵɵrepeater(collection) {
  const prevConsumer = setActiveConsumer(null);
  const metadataSlotIdx = getSelectedIndex();
  try {
    const hostLView = getLView();
    const hostTView = hostLView[TVIEW];
    const metadata = hostLView[metadataSlotIdx];
    const containerIndex = metadataSlotIdx + 1;
    const lContainer = getLContainer(hostLView, containerIndex);
    if (metadata.liveCollection === void 0) {
      const itemTemplateTNode = getExistingTNode(hostTView, containerIndex);
      metadata.liveCollection = new LiveCollectionLContainerImpl(lContainer, hostLView, itemTemplateTNode);
    } else {
      metadata.liveCollection.reset();
    }
    const liveCollection = metadata.liveCollection;
    reconcile(liveCollection, collection, metadata.trackByFn);
    if (ngDevMode && metadata.trackByFn === ɵɵrepeaterTrackByIdentity && liveCollection.operationsCounter?.wasReCreated(liveCollection.length) && isViewExpensiveToRecreate(getExistingLViewFromLContainer(lContainer, 0))) {
      const message = formatRuntimeError(-956, `The configured tracking expression (track by identity) caused re-creation of the entire collection of size ${liveCollection.length}. This is an expensive operation requiring destruction and subsequent creation of DOM nodes, directives, components etc. Please review the "track expression" and make sure that it uniquely identifies items in a collection.`);
      console.warn(message);
    }
    liveCollection.updateIndexes();
    if (metadata.hasEmptyBlock) {
      const bindingIndex = nextBindingIndex();
      const isCollectionEmpty = liveCollection.length === 0;
      if (bindingUpdated(hostLView, bindingIndex, isCollectionEmpty)) {
        const emptyTemplateIndex = metadataSlotIdx + 2;
        const lContainerForEmpty = getLContainer(hostLView, emptyTemplateIndex);
        if (isCollectionEmpty) {
          const emptyTemplateTNode = getExistingTNode(hostTView, emptyTemplateIndex);
          const dehydratedView = findMatchingDehydratedView(lContainerForEmpty, emptyTemplateTNode.tView.ssrId);
          const embeddedLView = createAndRenderEmbeddedLView(hostLView, emptyTemplateTNode, void 0, {
            dehydratedView
          });
          addLViewToLContainer(lContainerForEmpty, embeddedLView, 0, shouldAddViewToDom(emptyTemplateTNode, dehydratedView));
        } else {
          removeLViewFromLContainer(lContainerForEmpty, 0);
        }
      }
    }
  } finally {
    setActiveConsumer(prevConsumer);
  }
}
function getLContainer(lView, index) {
  const lContainer = lView[index];
  ngDevMode && assertLContainer(lContainer);
  return lContainer;
}
function detachExistingView(lContainer, index) {
  const existingLView = detachView(lContainer, index);
  ngDevMode && assertLView(existingLView);
  return existingLView;
}
function getExistingLViewFromLContainer(lContainer, index) {
  const existingLView = getLViewFromLContainer(lContainer, index);
  ngDevMode && assertLView(existingLView);
  return existingLView;
}
function getExistingTNode(tView, index) {
  const tNode = getTNode(tView, index);
  ngDevMode && assertTNode(tNode);
  return tNode;
}
function elementStartFirstCreatePass(index, tView, lView, name, attrsIndex, localRefsIndex) {
  ngDevMode && assertFirstCreatePass(tView);
  ngDevMode && ngDevMode.firstCreatePass++;
  const tViewConsts = tView.consts;
  const attrs = getConstant(tViewConsts, attrsIndex);
  const tNode = getOrCreateTNode(tView, index, 2, name, attrs);
  resolveDirectives(tView, lView, tNode, getConstant(tViewConsts, localRefsIndex));
  if (tNode.attrs !== null) {
    computeStaticStyling(tNode, tNode.attrs, false);
  }
  if (tNode.mergedAttrs !== null) {
    computeStaticStyling(tNode, tNode.mergedAttrs, true);
  }
  if (tView.queries !== null) {
    tView.queries.elementStart(tView, tNode);
  }
  return tNode;
}
function ɵɵelementStart(index, name, attrsIndex, localRefsIndex) {
  const lView = getLView();
  const tView = getTView();
  const adjustedIndex = HEADER_OFFSET + index;
  ngDevMode && assertEqual(getBindingIndex(), tView.bindingStartIndex, "elements should be created before any bindings");
  ngDevMode && assertIndexInRange(lView, adjustedIndex);
  const renderer = lView[RENDERER];
  const tNode = tView.firstCreatePass ? elementStartFirstCreatePass(adjustedIndex, tView, lView, name, attrsIndex, localRefsIndex) : tView.data[adjustedIndex];
  const native = _locateOrCreateElementNode(tView, lView, tNode, renderer, name, index);
  lView[adjustedIndex] = native;
  const hasDirectives = isDirectiveHost(tNode);
  if (ngDevMode && tView.firstCreatePass) {
    validateElementIsKnown(native, lView, tNode.value, tView.schemas, hasDirectives);
  }
  setCurrentTNode(tNode, true);
  setupStaticAttributes(renderer, native, tNode);
  if (!isDetachedByI18n(tNode) && wasLastNodeCreated()) {
    appendChild(tView, lView, native, tNode);
  }
  if (getElementDepthCount() === 0) {
    attachPatchData(native, lView);
  }
  increaseElementDepthCount();
  if (hasDirectives) {
    createDirectivesInstances(tView, lView, tNode);
    executeContentQueries(tView, tNode, lView);
  }
  if (localRefsIndex !== null) {
    saveResolvedLocalsInData(lView, tNode);
  }
  return ɵɵelementStart;
}
function ɵɵelementEnd() {
  let currentTNode = getCurrentTNode();
  ngDevMode && assertDefined(currentTNode, "No parent node to close.");
  if (isCurrentTNodeParent()) {
    setCurrentTNodeAsNotParent();
  } else {
    ngDevMode && assertHasParent(getCurrentTNode());
    currentTNode = currentTNode.parent;
    setCurrentTNode(currentTNode, false);
  }
  const tNode = currentTNode;
  ngDevMode && assertTNodeType(
    tNode,
    3
    /* TNodeType.AnyRNode */
  );
  if (isSkipHydrationRootTNode(tNode)) {
    leaveSkipHydrationBlock();
  }
  decreaseElementDepthCount();
  const tView = getTView();
  if (tView.firstCreatePass) {
    registerPostOrderHooks(tView, currentTNode);
    if (isContentQueryHost(currentTNode)) {
      tView.queries.elementEnd(currentTNode);
    }
  }
  if (tNode.classesWithoutHost != null && hasClassInput(tNode)) {
    setDirectiveInputsWhichShadowsStyling(tView, tNode, getLView(), tNode.classesWithoutHost, true);
  }
  if (tNode.stylesWithoutHost != null && hasStyleInput(tNode)) {
    setDirectiveInputsWhichShadowsStyling(tView, tNode, getLView(), tNode.stylesWithoutHost, false);
  }
  return ɵɵelementEnd;
}
function ɵɵelement(index, name, attrsIndex, localRefsIndex) {
  ɵɵelementStart(index, name, attrsIndex, localRefsIndex);
  ɵɵelementEnd();
  return ɵɵelement;
}
var _locateOrCreateElementNode = (tView, lView, tNode, renderer, name, index) => {
  lastNodeWasCreated(true);
  return createElementNode(renderer, name, getNamespace$1());
};
function elementContainerStartFirstCreatePass(index, tView, lView, attrsIndex, localRefsIndex) {
  ngDevMode && ngDevMode.firstCreatePass++;
  const tViewConsts = tView.consts;
  const attrs = getConstant(tViewConsts, attrsIndex);
  const tNode = getOrCreateTNode(tView, index, 8, "ng-container", attrs);
  if (attrs !== null) {
    computeStaticStyling(tNode, attrs, true);
  }
  const localRefs = getConstant(tViewConsts, localRefsIndex);
  resolveDirectives(tView, lView, tNode, localRefs);
  if (tView.queries !== null) {
    tView.queries.elementStart(tView, tNode);
  }
  return tNode;
}
function ɵɵelementContainerStart(index, attrsIndex, localRefsIndex) {
  const lView = getLView();
  const tView = getTView();
  const adjustedIndex = index + HEADER_OFFSET;
  ngDevMode && assertIndexInRange(lView, adjustedIndex);
  ngDevMode && assertEqual(getBindingIndex(), tView.bindingStartIndex, "element containers should be created before any bindings");
  const tNode = tView.firstCreatePass ? elementContainerStartFirstCreatePass(adjustedIndex, tView, lView, attrsIndex, localRefsIndex) : tView.data[adjustedIndex];
  setCurrentTNode(tNode, true);
  const comment = _locateOrCreateElementContainerNode(tView, lView, tNode, index);
  lView[adjustedIndex] = comment;
  if (wasLastNodeCreated()) {
    appendChild(tView, lView, comment, tNode);
  }
  attachPatchData(comment, lView);
  if (isDirectiveHost(tNode)) {
    createDirectivesInstances(tView, lView, tNode);
    executeContentQueries(tView, tNode, lView);
  }
  if (localRefsIndex != null) {
    saveResolvedLocalsInData(lView, tNode);
  }
  return ɵɵelementContainerStart;
}
function ɵɵelementContainerEnd() {
  let currentTNode = getCurrentTNode();
  const tView = getTView();
  if (isCurrentTNodeParent()) {
    setCurrentTNodeAsNotParent();
  } else {
    ngDevMode && assertHasParent(currentTNode);
    currentTNode = currentTNode.parent;
    setCurrentTNode(currentTNode, false);
  }
  ngDevMode && assertTNodeType(
    currentTNode,
    8
    /* TNodeType.ElementContainer */
  );
  if (tView.firstCreatePass) {
    registerPostOrderHooks(tView, currentTNode);
    if (isContentQueryHost(currentTNode)) {
      tView.queries.elementEnd(currentTNode);
    }
  }
  return ɵɵelementContainerEnd;
}
function ɵɵelementContainer(index, attrsIndex, localRefsIndex) {
  ɵɵelementContainerStart(index, attrsIndex, localRefsIndex);
  ɵɵelementContainerEnd();
  return ɵɵelementContainer;
}
var _locateOrCreateElementContainerNode = (tView, lView, tNode, index) => {
  lastNodeWasCreated(true);
  return createCommentNode(lView[RENDERER], ngDevMode ? "ng-container" : "");
};
function ɵɵgetCurrentView() {
  return getLView();
}
function ɵɵhostProperty(propName, value, sanitizer) {
  const lView = getLView();
  const bindingIndex = nextBindingIndex();
  if (bindingUpdated(lView, bindingIndex, value)) {
    const tView = getTView();
    const tNode = getSelectedTNode();
    elementPropertyInternal(tView, tNode, lView, propName, value, lView[RENDERER], sanitizer, true);
    ngDevMode && storePropertyBindingMetadata(tView.data, tNode, propName, bindingIndex);
  }
  return ɵɵhostProperty;
}
function ɵɵsyntheticHostProperty(propName, value, sanitizer) {
  const lView = getLView();
  const bindingIndex = nextBindingIndex();
  if (bindingUpdated(lView, bindingIndex, value)) {
    const tView = getTView();
    const tNode = getSelectedTNode();
    const currentDef = getCurrentDirectiveDef(tView.data);
    const renderer = loadComponentRenderer(currentDef, tNode, lView);
    elementPropertyInternal(tView, tNode, lView, propName, value, renderer, sanitizer, true);
    ngDevMode && storePropertyBindingMetadata(tView.data, tNode, propName, bindingIndex);
  }
  return ɵɵsyntheticHostProperty;
}
if (typeof ngI18nClosureMode === "undefined") {
  (function() {
    _global["ngI18nClosureMode"] = // TODO(FW-1250): validate that this actually, you know, works.
    // tslint:disable-next-line:no-toplevel-property-access
    typeof goog !== "undefined" && typeof goog.getMsg === "function";
  })();
}
var u = void 0;
function plural(val) {
  const n = val, i = Math.floor(Math.abs(val)), v = val.toString().replace(/^[^.]*\.?/, "").length;
  if (i === 1 && v === 0) return 1;
  return 5;
}
var localeEn = ["en", [["a", "p"], ["AM", "PM"], u], [["AM", "PM"], u, u], [["S", "M", "T", "W", "T", "F", "S"], ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"], ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"], ["Su", "Mo", "Tu", "We", "Th", "Fr", "Sa"]], u, [["J", "F", "M", "A", "M", "J", "J", "A", "S", "O", "N", "D"], ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"], ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"]], u, [["B", "A"], ["BC", "AD"], ["Before Christ", "Anno Domini"]], 0, [6, 0], ["M/d/yy", "MMM d, y", "MMMM d, y", "EEEE, MMMM d, y"], ["h:mm a", "h:mm:ss a", "h:mm:ss a z", "h:mm:ss a zzzz"], ["{1}, {0}", u, "{1} 'at' {0}", u], [".", ",", ";", "%", "+", "-", "E", "×", "‰", "∞", "NaN", ":"], ["#,##0.###", "#,##0%", "¤#,##0.00", "#E0"], "USD", "$", "US Dollar", {}, "ltr", plural];
var LOCALE_DATA = {};
function findLocaleData(locale) {
  const normalizedLocale = normalizeLocale(locale);
  let match = getLocaleData(normalizedLocale);
  if (match) {
    return match;
  }
  const parentLocale = normalizedLocale.split("-")[0];
  match = getLocaleData(parentLocale);
  if (match) {
    return match;
  }
  if (parentLocale === "en") {
    return localeEn;
  }
  throw new RuntimeError(701, ngDevMode && `Missing locale data for the locale "${locale}".`);
}
function getLocalePluralCase(locale) {
  const data = findLocaleData(locale);
  return data[LocaleDataIndex.PluralCase];
}
function getLocaleData(normalizedLocale) {
  if (!(normalizedLocale in LOCALE_DATA)) {
    LOCALE_DATA[normalizedLocale] = _global.ng && _global.ng.common && _global.ng.common.locales && _global.ng.common.locales[normalizedLocale];
  }
  return LOCALE_DATA[normalizedLocale];
}
var LocaleDataIndex;
(function(LocaleDataIndex2) {
  LocaleDataIndex2[LocaleDataIndex2["LocaleId"] = 0] = "LocaleId";
  LocaleDataIndex2[LocaleDataIndex2["DayPeriodsFormat"] = 1] = "DayPeriodsFormat";
  LocaleDataIndex2[LocaleDataIndex2["DayPeriodsStandalone"] = 2] = "DayPeriodsStandalone";
  LocaleDataIndex2[LocaleDataIndex2["DaysFormat"] = 3] = "DaysFormat";
  LocaleDataIndex2[LocaleDataIndex2["DaysStandalone"] = 4] = "DaysStandalone";
  LocaleDataIndex2[LocaleDataIndex2["MonthsFormat"] = 5] = "MonthsFormat";
  LocaleDataIndex2[LocaleDataIndex2["MonthsStandalone"] = 6] = "MonthsStandalone";
  LocaleDataIndex2[LocaleDataIndex2["Eras"] = 7] = "Eras";
  LocaleDataIndex2[LocaleDataIndex2["FirstDayOfWeek"] = 8] = "FirstDayOfWeek";
  LocaleDataIndex2[LocaleDataIndex2["WeekendRange"] = 9] = "WeekendRange";
  LocaleDataIndex2[LocaleDataIndex2["DateFormat"] = 10] = "DateFormat";
  LocaleDataIndex2[LocaleDataIndex2["TimeFormat"] = 11] = "TimeFormat";
  LocaleDataIndex2[LocaleDataIndex2["DateTimeFormat"] = 12] = "DateTimeFormat";
  LocaleDataIndex2[LocaleDataIndex2["NumberSymbols"] = 13] = "NumberSymbols";
  LocaleDataIndex2[LocaleDataIndex2["NumberFormats"] = 14] = "NumberFormats";
  LocaleDataIndex2[LocaleDataIndex2["CurrencyCode"] = 15] = "CurrencyCode";
  LocaleDataIndex2[LocaleDataIndex2["CurrencySymbol"] = 16] = "CurrencySymbol";
  LocaleDataIndex2[LocaleDataIndex2["CurrencyName"] = 17] = "CurrencyName";
  LocaleDataIndex2[LocaleDataIndex2["Currencies"] = 18] = "Currencies";
  LocaleDataIndex2[LocaleDataIndex2["Directionality"] = 19] = "Directionality";
  LocaleDataIndex2[LocaleDataIndex2["PluralCase"] = 20] = "PluralCase";
  LocaleDataIndex2[LocaleDataIndex2["ExtraData"] = 21] = "ExtraData";
})(LocaleDataIndex || (LocaleDataIndex = {}));
function normalizeLocale(locale) {
  return locale.toLowerCase().replace(/_/g, "-");
}
var pluralMapping = ["zero", "one", "two", "few", "many"];
function getPluralCase(value, locale) {
  const plural2 = getLocalePluralCase(locale)(parseInt(value, 10));
  const result = pluralMapping[plural2];
  return result !== void 0 ? result : "other";
}
var DEFAULT_LOCALE_ID = "en-US";
var USD_CURRENCY_CODE = "USD";
var ELEMENT_MARKER = {
  marker: "element"
};
var ICU_MARKER = {
  marker: "ICU"
};
var I18nCreateOpCode;
(function(I18nCreateOpCode2) {
  I18nCreateOpCode2[I18nCreateOpCode2["SHIFT"] = 2] = "SHIFT";
  I18nCreateOpCode2[I18nCreateOpCode2["APPEND_EAGERLY"] = 1] = "APPEND_EAGERLY";
  I18nCreateOpCode2[I18nCreateOpCode2["COMMENT"] = 2] = "COMMENT";
})(I18nCreateOpCode || (I18nCreateOpCode = {}));
var LOCALE_ID$1 = DEFAULT_LOCALE_ID;
function setLocaleId(localeId) {
  ngDevMode && assertDefined(localeId, `Expected localeId to be defined`);
  if (typeof localeId === "string") {
    LOCALE_ID$1 = localeId.toLowerCase().replace(/_/g, "-");
  }
}
function getLocaleId() {
  return LOCALE_ID$1;
}
var changeMask = 0;
var changeMaskCounter = 0;
function setMaskBit(hasChange) {
  if (hasChange) {
    changeMask = changeMask | 1 << Math.min(changeMaskCounter, 31);
  }
  changeMaskCounter++;
}
function applyI18n(tView, lView, index) {
  if (changeMaskCounter > 0) {
    ngDevMode && assertDefined(tView, `tView should be defined`);
    const tI18n = tView.data[index];
    const updateOpCodes = Array.isArray(tI18n) ? tI18n : tI18n.update;
    const bindingsStartIndex = getBindingIndex() - changeMaskCounter - 1;
    applyUpdateOpCodes(tView, lView, updateOpCodes, bindingsStartIndex, changeMask);
  }
  changeMask = 0;
  changeMaskCounter = 0;
}
function createNodeWithoutHydration(lView, textOrName, nodeType) {
  const renderer = lView[RENDERER];
  switch (nodeType) {
    case Node.COMMENT_NODE:
      return createCommentNode(renderer, textOrName);
    case Node.TEXT_NODE:
      return createTextNode(renderer, textOrName);
    case Node.ELEMENT_NODE:
      return createElementNode(renderer, textOrName, null);
  }
}
var _locateOrCreateNode = (lView, index, textOrName, nodeType) => {
  lastNodeWasCreated(true);
  return createNodeWithoutHydration(lView, textOrName, nodeType);
};
function applyCreateOpCodes(lView, createOpCodes, parentRNode, insertInFrontOf) {
  const renderer = lView[RENDERER];
  for (let i = 0; i < createOpCodes.length; i++) {
    const opCode = createOpCodes[i++];
    const text = createOpCodes[i];
    const isComment = (opCode & I18nCreateOpCode.COMMENT) === I18nCreateOpCode.COMMENT;
    const appendNow = (opCode & I18nCreateOpCode.APPEND_EAGERLY) === I18nCreateOpCode.APPEND_EAGERLY;
    const index = opCode >>> I18nCreateOpCode.SHIFT;
    let rNode = lView[index];
    let lastNodeWasCreated2 = false;
    if (rNode === null) {
      rNode = lView[index] = _locateOrCreateNode(lView, index, text, isComment ? Node.COMMENT_NODE : Node.TEXT_NODE);
      lastNodeWasCreated2 = wasLastNodeCreated();
    }
    if (appendNow && parentRNode !== null && lastNodeWasCreated2) {
      nativeInsertBefore(renderer, parentRNode, rNode, insertInFrontOf, false);
    }
  }
}
function applyMutableOpCodes(tView, mutableOpCodes, lView, anchorRNode) {
  ngDevMode && assertDomNode(anchorRNode);
  const renderer = lView[RENDERER];
  let rootIdx = null;
  let rootRNode;
  for (let i = 0; i < mutableOpCodes.length; i++) {
    const opCode = mutableOpCodes[i];
    if (typeof opCode == "string") {
      const textNodeIndex = mutableOpCodes[++i];
      if (lView[textNodeIndex] === null) {
        ngDevMode && ngDevMode.rendererCreateTextNode++;
        ngDevMode && assertIndexInRange(lView, textNodeIndex);
        lView[textNodeIndex] = _locateOrCreateNode(lView, textNodeIndex, opCode, Node.TEXT_NODE);
      }
    } else if (typeof opCode == "number") {
      switch (opCode & 1) {
        case 0:
          const parentIdx = getParentFromIcuCreateOpCode(opCode);
          if (rootIdx === null) {
            rootIdx = parentIdx;
            rootRNode = nativeParentNode(renderer, anchorRNode);
          }
          let insertInFrontOf;
          let parentRNode;
          if (parentIdx === rootIdx) {
            insertInFrontOf = anchorRNode;
            parentRNode = rootRNode;
          } else {
            insertInFrontOf = null;
            parentRNode = unwrapRNode(lView[parentIdx]);
          }
          if (parentRNode !== null) {
            ngDevMode && assertDomNode(parentRNode);
            const refIdx = getRefFromIcuCreateOpCode(opCode);
            ngDevMode && assertGreaterThan(refIdx, HEADER_OFFSET, "Missing ref");
            const child = lView[refIdx];
            ngDevMode && assertDomNode(child);
            nativeInsertBefore(renderer, parentRNode, child, insertInFrontOf, false);
            const tIcu = getTIcu(tView, refIdx);
            if (tIcu !== null && typeof tIcu === "object") {
              ngDevMode && assertTIcu(tIcu);
              const caseIndex = getCurrentICUCaseIndex(tIcu, lView);
              if (caseIndex !== null) {
                applyMutableOpCodes(tView, tIcu.create[caseIndex], lView, lView[tIcu.anchorIdx]);
              }
            }
          }
          break;
        case 1:
          const elementNodeIndex = opCode >>> 1;
          const attrName = mutableOpCodes[++i];
          const attrValue = mutableOpCodes[++i];
          setElementAttribute(renderer, getNativeByIndex(elementNodeIndex, lView), null, null, attrName, attrValue, null);
          break;
        default:
          if (ngDevMode) {
            throw new RuntimeError(700, `Unable to determine the type of mutate operation for "${opCode}"`);
          }
      }
    } else {
      switch (opCode) {
        case ICU_MARKER:
          const commentValue = mutableOpCodes[++i];
          const commentNodeIndex = mutableOpCodes[++i];
          if (lView[commentNodeIndex] === null) {
            ngDevMode && assertEqual(typeof commentValue, "string", `Expected "${commentValue}" to be a comment node value`);
            ngDevMode && ngDevMode.rendererCreateComment++;
            ngDevMode && assertIndexInExpandoRange(lView, commentNodeIndex);
            const commentRNode = lView[commentNodeIndex] = _locateOrCreateNode(lView, commentNodeIndex, commentValue, Node.COMMENT_NODE);
            attachPatchData(commentRNode, lView);
          }
          break;
        case ELEMENT_MARKER:
          const tagName = mutableOpCodes[++i];
          const elementNodeIndex = mutableOpCodes[++i];
          if (lView[elementNodeIndex] === null) {
            ngDevMode && assertEqual(typeof tagName, "string", `Expected "${tagName}" to be an element node tag name`);
            ngDevMode && ngDevMode.rendererCreateElement++;
            ngDevMode && assertIndexInExpandoRange(lView, elementNodeIndex);
            const elementRNode = lView[elementNodeIndex] = _locateOrCreateNode(lView, elementNodeIndex, tagName, Node.ELEMENT_NODE);
            attachPatchData(elementRNode, lView);
          }
          break;
        default:
          ngDevMode && throwError(`Unable to determine the type of mutate operation for "${opCode}"`);
      }
    }
  }
}
function applyUpdateOpCodes(tView, lView, updateOpCodes, bindingsStartIndex, changeMask2) {
  for (let i = 0; i < updateOpCodes.length; i++) {
    const checkBit = updateOpCodes[i];
    const skipCodes = updateOpCodes[++i];
    if (checkBit & changeMask2) {
      let value = "";
      for (let j = i + 1; j <= i + skipCodes; j++) {
        const opCode = updateOpCodes[j];
        if (typeof opCode == "string") {
          value += opCode;
        } else if (typeof opCode == "number") {
          if (opCode < 0) {
            value += renderStringify(lView[bindingsStartIndex - opCode]);
          } else {
            const nodeIndex = opCode >>> 2;
            switch (opCode & 3) {
              case 1:
                const propName = updateOpCodes[++j];
                const sanitizeFn = updateOpCodes[++j];
                const tNodeOrTagName = tView.data[nodeIndex];
                ngDevMode && assertDefined(tNodeOrTagName, "Experting TNode or string");
                if (typeof tNodeOrTagName === "string") {
                  setElementAttribute(lView[RENDERER], lView[nodeIndex], null, tNodeOrTagName, propName, value, sanitizeFn);
                } else {
                  elementPropertyInternal(tView, tNodeOrTagName, lView, propName, value, lView[RENDERER], sanitizeFn, false);
                }
                break;
              case 0:
                const rText = lView[nodeIndex];
                rText !== null && updateTextNode(lView[RENDERER], rText, value);
                break;
              case 2:
                applyIcuSwitchCase(tView, getTIcu(tView, nodeIndex), lView, value);
                break;
              case 3:
                applyIcuUpdateCase(tView, getTIcu(tView, nodeIndex), bindingsStartIndex, lView);
                break;
            }
          }
        }
      }
    } else {
      const opCode = updateOpCodes[i + 1];
      if (opCode > 0 && (opCode & 3) === 3) {
        const nodeIndex = opCode >>> 2;
        const tIcu = getTIcu(tView, nodeIndex);
        const currentIndex = lView[tIcu.currentCaseLViewIndex];
        if (currentIndex < 0) {
          applyIcuUpdateCase(tView, tIcu, bindingsStartIndex, lView);
        }
      }
    }
    i += skipCodes;
  }
}
function applyIcuUpdateCase(tView, tIcu, bindingsStartIndex, lView) {
  ngDevMode && assertIndexInRange(lView, tIcu.currentCaseLViewIndex);
  let activeCaseIndex = lView[tIcu.currentCaseLViewIndex];
  if (activeCaseIndex !== null) {
    let mask = changeMask;
    if (activeCaseIndex < 0) {
      activeCaseIndex = lView[tIcu.currentCaseLViewIndex] = ~activeCaseIndex;
      mask = -1;
    }
    applyUpdateOpCodes(tView, lView, tIcu.update[activeCaseIndex], bindingsStartIndex, mask);
  }
}
function applyIcuSwitchCase(tView, tIcu, lView, value) {
  const caseIndex = getCaseIndex(tIcu, value);
  let activeCaseIndex = getCurrentICUCaseIndex(tIcu, lView);
  if (activeCaseIndex !== caseIndex) {
    applyIcuSwitchCaseRemove(tView, tIcu, lView);
    lView[tIcu.currentCaseLViewIndex] = caseIndex === null ? null : ~caseIndex;
    if (caseIndex !== null) {
      const anchorRNode = lView[tIcu.anchorIdx];
      if (anchorRNode) {
        ngDevMode && assertDomNode(anchorRNode);
        applyMutableOpCodes(tView, tIcu.create[caseIndex], lView, anchorRNode);
      }
      claimDehydratedIcuCase(lView, tIcu.anchorIdx, caseIndex);
    }
  }
}
function applyIcuSwitchCaseRemove(tView, tIcu, lView) {
  let activeCaseIndex = getCurrentICUCaseIndex(tIcu, lView);
  if (activeCaseIndex !== null) {
    const removeCodes = tIcu.remove[activeCaseIndex];
    for (let i = 0; i < removeCodes.length; i++) {
      const nodeOrIcuIndex = removeCodes[i];
      if (nodeOrIcuIndex > 0) {
        const rNode = getNativeByIndex(nodeOrIcuIndex, lView);
        rNode !== null && nativeRemoveNode(lView[RENDERER], rNode);
      } else {
        applyIcuSwitchCaseRemove(tView, getTIcu(tView, ~nodeOrIcuIndex), lView);
      }
    }
  }
}
function getCaseIndex(icuExpression, bindingValue) {
  let index = icuExpression.cases.indexOf(bindingValue);
  if (index === -1) {
    switch (icuExpression.type) {
      case 1: {
        const resolvedCase = getPluralCase(bindingValue, getLocaleId());
        index = icuExpression.cases.indexOf(resolvedCase);
        if (index === -1 && resolvedCase !== "other") {
          index = icuExpression.cases.indexOf("other");
        }
        break;
      }
      case 0: {
        index = icuExpression.cases.indexOf("other");
        break;
      }
    }
  }
  return index === -1 ? null : index;
}
function i18nCreateOpCodesToString(opcodes) {
  const createOpCodes = opcodes || (Array.isArray(this) ? this : []);
  let lines = [];
  for (let i = 0; i < createOpCodes.length; i++) {
    const opCode = createOpCodes[i++];
    const text = createOpCodes[i];
    const isComment = (opCode & I18nCreateOpCode.COMMENT) === I18nCreateOpCode.COMMENT;
    const appendNow = (opCode & I18nCreateOpCode.APPEND_EAGERLY) === I18nCreateOpCode.APPEND_EAGERLY;
    const index = opCode >>> I18nCreateOpCode.SHIFT;
    lines.push(`lView[${index}] = document.${isComment ? "createComment" : "createText"}(${JSON.stringify(text)});`);
    if (appendNow) {
      lines.push(`parent.appendChild(lView[${index}]);`);
    }
  }
  return lines;
}
function i18nUpdateOpCodesToString(opcodes) {
  const parser = new OpCodeParser(opcodes || (Array.isArray(this) ? this : []));
  let lines = [];
  function consumeOpCode(value) {
    const ref = value >>> 2;
    const opCode = value & 3;
    switch (opCode) {
      case 0:
        return `(lView[${ref}] as Text).textContent = $$$`;
      case 1:
        const attrName = parser.consumeString();
        const sanitizationFn = parser.consumeFunction();
        const value2 = sanitizationFn ? `(${sanitizationFn})($$$)` : "$$$";
        return `(lView[${ref}] as Element).setAttribute('${attrName}', ${value2})`;
      case 2:
        return `icuSwitchCase(${ref}, $$$)`;
      case 3:
        return `icuUpdateCase(${ref})`;
    }
    throw new Error("unexpected OpCode");
  }
  while (parser.hasMore()) {
    let mask = parser.consumeNumber();
    let size = parser.consumeNumber();
    const end = parser.i + size;
    const statements = [];
    let statement = "";
    while (parser.i < end) {
      let value = parser.consumeNumberOrString();
      if (typeof value === "string") {
        statement += value;
      } else if (value < 0) {
        statement += "${lView[i" + value + "]}";
      } else {
        const opCodeText = consumeOpCode(value);
        statements.push(opCodeText.replace("$$$", "`" + statement + "`") + ";");
        statement = "";
      }
    }
    lines.push(`if (mask & 0b${mask.toString(2)}) { ${statements.join(" ")} }`);
  }
  return lines;
}
function icuCreateOpCodesToString(opcodes) {
  const parser = new OpCodeParser(opcodes || (Array.isArray(this) ? this : []));
  let lines = [];
  function consumeOpCode(opCode) {
    const parent = getParentFromIcuCreateOpCode(opCode);
    const ref = getRefFromIcuCreateOpCode(opCode);
    switch (getInstructionFromIcuCreateOpCode(opCode)) {
      case 0:
        return `(lView[${parent}] as Element).appendChild(lView[${lastRef}])`;
      case 1:
        return `(lView[${ref}] as Element).setAttribute("${parser.consumeString()}", "${parser.consumeString()}")`;
    }
    throw new Error("Unexpected OpCode: " + getInstructionFromIcuCreateOpCode(opCode));
  }
  let lastRef = -1;
  while (parser.hasMore()) {
    let value = parser.consumeNumberStringOrMarker();
    if (value === ICU_MARKER) {
      const text = parser.consumeString();
      lastRef = parser.consumeNumber();
      lines.push(`lView[${lastRef}] = document.createComment("${text}")`);
    } else if (value === ELEMENT_MARKER) {
      const text = parser.consumeString();
      lastRef = parser.consumeNumber();
      lines.push(`lView[${lastRef}] = document.createElement("${text}")`);
    } else if (typeof value === "string") {
      lastRef = parser.consumeNumber();
      lines.push(`lView[${lastRef}] = document.createTextNode("${value}")`);
    } else if (typeof value === "number") {
      const line = consumeOpCode(value);
      line && lines.push(line);
    } else {
      throw new Error("Unexpected value");
    }
  }
  return lines;
}
function i18nRemoveOpCodesToString(opcodes) {
  const removeCodes = opcodes || (Array.isArray(this) ? this : []);
  let lines = [];
  for (let i = 0; i < removeCodes.length; i++) {
    const nodeOrIcuIndex = removeCodes[i];
    if (nodeOrIcuIndex > 0) {
      lines.push(`remove(lView[${nodeOrIcuIndex}])`);
    } else {
      lines.push(`removeNestedICU(${~nodeOrIcuIndex})`);
    }
  }
  return lines;
}
var OpCodeParser = class {
  constructor(codes) {
    this.i = 0;
    this.codes = codes;
  }
  hasMore() {
    return this.i < this.codes.length;
  }
  consumeNumber() {
    let value = this.codes[this.i++];
    assertNumber(value, "expecting number in OpCode");
    return value;
  }
  consumeString() {
    let value = this.codes[this.i++];
    assertString(value, "expecting string in OpCode");
    return value;
  }
  consumeFunction() {
    let value = this.codes[this.i++];
    if (value === null || typeof value === "function") {
      return value;
    }
    throw new Error("expecting function in OpCode");
  }
  consumeNumberOrString() {
    let value = this.codes[this.i++];
    if (typeof value === "string") {
      return value;
    }
    assertNumber(value, "expecting number or string in OpCode");
    return value;
  }
  consumeNumberStringOrMarker() {
    let value = this.codes[this.i++];
    if (typeof value === "string" || typeof value === "number" || value == ICU_MARKER || value == ELEMENT_MARKER) {
      return value;
    }
    assertNumber(value, "expecting number, string, ICU_MARKER or ELEMENT_MARKER in OpCode");
    return value;
  }
};
var BINDING_REGEXP = /�(\d+):?\d*�/gi;
var ICU_REGEXP = /({\s*�\d+:?\d*�\s*,\s*\S{6}\s*,[\s\S]*})/gi;
var NESTED_ICU = /�(\d+)�/;
var ICU_BLOCK_REGEXP = /^\s*(�\d+:?\d*�)\s*,\s*(select|plural)\s*,/;
var MARKER = `�`;
var SUBTEMPLATE_REGEXP = /�\/?\*(\d+:\d+)�/gi;
var PH_REGEXP = /�(\/?[#*]\d+):?\d*�/gi;
var NGSP_UNICODE_REGEXP = /\uE500/g;
function replaceNgsp(value) {
  return value.replace(NGSP_UNICODE_REGEXP, " ");
}
function attachDebugGetter(obj, debugGetter) {
  if (ngDevMode) {
    Object.defineProperty(obj, "debug", {
      get: debugGetter,
      enumerable: false
    });
  } else {
    throw new Error("This method should be guarded with `ngDevMode` so that it can be tree shaken in production!");
  }
}
function i18nStartFirstCreatePass(tView, parentTNodeIndex, lView, index, message, subTemplateIndex) {
  const rootTNode = getCurrentParentTNode();
  const createOpCodes = [];
  const updateOpCodes = [];
  const existingTNodeStack = [[]];
  const astStack = [[]];
  if (ngDevMode) {
    attachDebugGetter(createOpCodes, i18nCreateOpCodesToString);
    attachDebugGetter(updateOpCodes, i18nUpdateOpCodesToString);
  }
  message = getTranslationForTemplate(message, subTemplateIndex);
  const msgParts = replaceNgsp(message).split(PH_REGEXP);
  for (let i = 0; i < msgParts.length; i++) {
    let value = msgParts[i];
    if ((i & 1) === 0) {
      const parts = i18nParseTextIntoPartsAndICU(value);
      for (let j = 0; j < parts.length; j++) {
        let part = parts[j];
        if ((j & 1) === 0) {
          const text = part;
          ngDevMode && assertString(text, "Parsed ICU part should be string");
          if (text !== "") {
            i18nStartFirstCreatePassProcessTextNode(astStack[0], tView, rootTNode, existingTNodeStack[0], createOpCodes, updateOpCodes, lView, text);
          }
        } else {
          const icuExpression = part;
          if (typeof icuExpression !== "object") {
            throw new Error(`Unable to parse ICU expression in "${message}" message.`);
          }
          const icuContainerTNode = createTNodeAndAddOpCode(tView, rootTNode, existingTNodeStack[0], lView, createOpCodes, ngDevMode ? `ICU ${index}:${icuExpression.mainBinding}` : "", true);
          const icuNodeIndex = icuContainerTNode.index;
          ngDevMode && assertGreaterThanOrEqual(icuNodeIndex, HEADER_OFFSET, "Index must be in absolute LView offset");
          icuStart(astStack[0], tView, lView, updateOpCodes, parentTNodeIndex, icuExpression, icuNodeIndex);
        }
      }
    } else {
      const isClosing = value.charCodeAt(0) === 47;
      const type = value.charCodeAt(isClosing ? 1 : 0);
      ngDevMode && assertOneOf(
        type,
        42,
        35
        /* CharCode.HASH */
      );
      const index2 = HEADER_OFFSET + Number.parseInt(value.substring(isClosing ? 2 : 1));
      if (isClosing) {
        existingTNodeStack.shift();
        astStack.shift();
        setCurrentTNode(getCurrentParentTNode(), false);
      } else {
        const tNode = createTNodePlaceholder(tView, existingTNodeStack[0], index2);
        existingTNodeStack.unshift([]);
        setCurrentTNode(tNode, true);
        const placeholderNode = {
          kind: 2,
          index: index2,
          children: [],
          type: type === 35 ? 0 : 1
          /* I18nPlaceholderType.SUBTEMPLATE */
        };
        astStack[0].push(placeholderNode);
        astStack.unshift(placeholderNode.children);
      }
    }
  }
  tView.data[index] = {
    create: createOpCodes,
    update: updateOpCodes,
    ast: astStack[0],
    parentTNodeIndex
  };
}
function createTNodeAndAddOpCode(tView, rootTNode, existingTNodes, lView, createOpCodes, text, isICU) {
  const i18nNodeIdx = allocExpando(tView, lView, 1, null);
  let opCode = i18nNodeIdx << I18nCreateOpCode.SHIFT;
  let parentTNode = getCurrentParentTNode();
  if (rootTNode === parentTNode) {
    parentTNode = null;
  }
  if (parentTNode === null) {
    opCode |= I18nCreateOpCode.APPEND_EAGERLY;
  }
  if (isICU) {
    opCode |= I18nCreateOpCode.COMMENT;
    ensureIcuContainerVisitorLoaded(loadIcuContainerVisitor);
  }
  createOpCodes.push(opCode, text === null ? "" : text);
  const tNode = createTNodeAtIndex(tView, i18nNodeIdx, isICU ? 32 : 1, text === null ? ngDevMode ? "{{?}}" : "" : text, null);
  addTNodeAndUpdateInsertBeforeIndex(existingTNodes, tNode);
  const tNodeIdx = tNode.index;
  setCurrentTNode(
    tNode,
    false
    /* Text nodes are self closing */
  );
  if (parentTNode !== null && rootTNode !== parentTNode) {
    setTNodeInsertBeforeIndex(parentTNode, tNodeIdx);
  }
  return tNode;
}
function i18nStartFirstCreatePassProcessTextNode(ast, tView, rootTNode, existingTNodes, createOpCodes, updateOpCodes, lView, text) {
  const hasBinding = text.match(BINDING_REGEXP);
  const tNode = createTNodeAndAddOpCode(tView, rootTNode, existingTNodes, lView, createOpCodes, hasBinding ? null : text, false);
  const index = tNode.index;
  if (hasBinding) {
    generateBindingUpdateOpCodes(updateOpCodes, text, index, null, 0, null);
  }
  ast.push({
    kind: 0,
    index
  });
}
function i18nAttributesFirstPass(tView, index, values) {
  const previousElement = getCurrentTNode();
  const previousElementIndex = previousElement.index;
  const updateOpCodes = [];
  if (ngDevMode) {
    attachDebugGetter(updateOpCodes, i18nUpdateOpCodesToString);
  }
  if (tView.firstCreatePass && tView.data[index] === null) {
    for (let i = 0; i < values.length; i += 2) {
      const attrName = values[i];
      const message = values[i + 1];
      if (message !== "") {
        if (ICU_REGEXP.test(message)) {
          throw new Error(`ICU expressions are not supported in attributes. Message: "${message}".`);
        }
        generateBindingUpdateOpCodes(updateOpCodes, message, previousElementIndex, attrName, countBindings(updateOpCodes), null);
      }
    }
    tView.data[index] = updateOpCodes;
  }
}
function generateBindingUpdateOpCodes(updateOpCodes, str, destinationNode, attrName, bindingStart, sanitizeFn) {
  ngDevMode && assertGreaterThanOrEqual(destinationNode, HEADER_OFFSET, "Index must be in absolute LView offset");
  const maskIndex = updateOpCodes.length;
  const sizeIndex = maskIndex + 1;
  updateOpCodes.push(null, null);
  const startIndex = maskIndex + 2;
  if (ngDevMode) {
    attachDebugGetter(updateOpCodes, i18nUpdateOpCodesToString);
  }
  const textParts = str.split(BINDING_REGEXP);
  let mask = 0;
  for (let j = 0; j < textParts.length; j++) {
    const textValue = textParts[j];
    if (j & 1) {
      const bindingIndex = bindingStart + parseInt(textValue, 10);
      updateOpCodes.push(-1 - bindingIndex);
      mask = mask | toMaskBit(bindingIndex);
    } else if (textValue !== "") {
      updateOpCodes.push(textValue);
    }
  }
  updateOpCodes.push(destinationNode << 2 | (attrName ? 1 : 0));
  if (attrName) {
    updateOpCodes.push(attrName, sanitizeFn);
  }
  updateOpCodes[maskIndex] = mask;
  updateOpCodes[sizeIndex] = updateOpCodes.length - startIndex;
  return mask;
}
function countBindings(opCodes) {
  let count = 0;
  for (let i = 0; i < opCodes.length; i++) {
    const opCode = opCodes[i];
    if (typeof opCode === "number" && opCode < 0) {
      count++;
    }
  }
  return count;
}
function toMaskBit(bindingIndex) {
  return 1 << Math.min(bindingIndex, 31);
}
function removeInnerTemplateTranslation(message) {
  let match;
  let res = "";
  let index = 0;
  let inTemplate = false;
  let tagMatched;
  while ((match = SUBTEMPLATE_REGEXP.exec(message)) !== null) {
    if (!inTemplate) {
      res += message.substring(index, match.index + match[0].length);
      tagMatched = match[1];
      inTemplate = true;
    } else {
      if (match[0] === `${MARKER}/*${tagMatched}${MARKER}`) {
        index = match.index;
        inTemplate = false;
      }
    }
  }
  ngDevMode && assertEqual(inTemplate, false, `Tag mismatch: unable to find the end of the sub-template in the translation "${message}"`);
  res += message.slice(index);
  return res;
}
function getTranslationForTemplate(message, subTemplateIndex) {
  if (isRootTemplateMessage(subTemplateIndex)) {
    return removeInnerTemplateTranslation(message);
  } else {
    const start = message.indexOf(`:${subTemplateIndex}${MARKER}`) + 2 + subTemplateIndex.toString().length;
    const end = message.search(new RegExp(`${MARKER}\\/\\*\\d+:${subTemplateIndex}${MARKER}`));
    return removeInnerTemplateTranslation(message.substring(start, end));
  }
}
function icuStart(ast, tView, lView, updateOpCodes, parentIdx, icuExpression, anchorIdx) {
  ngDevMode && assertDefined(icuExpression, "ICU expression must be defined");
  let bindingMask = 0;
  const tIcu = {
    type: icuExpression.type,
    currentCaseLViewIndex: allocExpando(tView, lView, 1, null),
    anchorIdx,
    cases: [],
    create: [],
    remove: [],
    update: []
  };
  addUpdateIcuSwitch(updateOpCodes, icuExpression, anchorIdx);
  setTIcu(tView, anchorIdx, tIcu);
  const values = icuExpression.values;
  const cases = [];
  for (let i = 0; i < values.length; i++) {
    const valueArr = values[i];
    const nestedIcus = [];
    for (let j = 0; j < valueArr.length; j++) {
      const value = valueArr[j];
      if (typeof value !== "string") {
        const icuIndex = nestedIcus.push(value) - 1;
        valueArr[j] = `<!--�${icuIndex}�-->`;
      }
    }
    const caseAst = [];
    cases.push(caseAst);
    bindingMask = parseIcuCase(caseAst, tView, tIcu, lView, updateOpCodes, parentIdx, icuExpression.cases[i], valueArr.join(""), nestedIcus) | bindingMask;
  }
  if (bindingMask) {
    addUpdateIcuUpdate(updateOpCodes, bindingMask, anchorIdx);
  }
  ast.push({
    kind: 3,
    index: anchorIdx,
    cases,
    currentCaseLViewIndex: tIcu.currentCaseLViewIndex
  });
}
function parseICUBlock(pattern) {
  const cases = [];
  const values = [];
  let icuType = 1;
  let mainBinding = 0;
  pattern = pattern.replace(ICU_BLOCK_REGEXP, function(str, binding, type) {
    if (type === "select") {
      icuType = 0;
    } else {
      icuType = 1;
    }
    mainBinding = parseInt(binding.slice(1), 10);
    return "";
  });
  const parts = i18nParseTextIntoPartsAndICU(pattern);
  for (let pos = 0; pos < parts.length; ) {
    let key = parts[pos++].trim();
    if (icuType === 1) {
      key = key.replace(/\s*(?:=)?(\w+)\s*/, "$1");
    }
    if (key.length) {
      cases.push(key);
    }
    const blocks = i18nParseTextIntoPartsAndICU(parts[pos++]);
    if (cases.length > values.length) {
      values.push(blocks);
    }
  }
  return {
    type: icuType,
    mainBinding,
    cases,
    values
  };
}
function i18nParseTextIntoPartsAndICU(pattern) {
  if (!pattern) {
    return [];
  }
  let prevPos = 0;
  const braceStack = [];
  const results = [];
  const braces = /[{}]/g;
  braces.lastIndex = 0;
  let match;
  while (match = braces.exec(pattern)) {
    const pos = match.index;
    if (match[0] == "}") {
      braceStack.pop();
      if (braceStack.length == 0) {
        const block = pattern.substring(prevPos, pos);
        if (ICU_BLOCK_REGEXP.test(block)) {
          results.push(parseICUBlock(block));
        } else {
          results.push(block);
        }
        prevPos = pos + 1;
      }
    } else {
      if (braceStack.length == 0) {
        const substring2 = pattern.substring(prevPos, pos);
        results.push(substring2);
        prevPos = pos + 1;
      }
      braceStack.push("{");
    }
  }
  const substring = pattern.substring(prevPos);
  results.push(substring);
  return results;
}
function parseIcuCase(ast, tView, tIcu, lView, updateOpCodes, parentIdx, caseName, unsafeCaseHtml, nestedIcus) {
  const create = [];
  const remove2 = [];
  const update = [];
  if (ngDevMode) {
    attachDebugGetter(create, icuCreateOpCodesToString);
    attachDebugGetter(remove2, i18nRemoveOpCodesToString);
    attachDebugGetter(update, i18nUpdateOpCodesToString);
  }
  tIcu.cases.push(caseName);
  tIcu.create.push(create);
  tIcu.remove.push(remove2);
  tIcu.update.push(update);
  const inertBodyHelper2 = getInertBodyHelper(getDocument());
  const inertBodyElement = inertBodyHelper2.getInertBodyElement(unsafeCaseHtml);
  ngDevMode && assertDefined(inertBodyElement, "Unable to generate inert body element");
  const inertRootNode = getTemplateContent(inertBodyElement) || inertBodyElement;
  if (inertRootNode) {
    return walkIcuTree(ast, tView, tIcu, lView, updateOpCodes, create, remove2, update, inertRootNode, parentIdx, nestedIcus, 0);
  } else {
    return 0;
  }
}
function walkIcuTree(ast, tView, tIcu, lView, sharedUpdateOpCodes, create, remove2, update, parentNode, parentIdx, nestedIcus, depth) {
  let bindingMask = 0;
  let currentNode = parentNode.firstChild;
  while (currentNode) {
    const newIndex = allocExpando(tView, lView, 1, null);
    switch (currentNode.nodeType) {
      case Node.ELEMENT_NODE:
        const element = currentNode;
        const tagName = element.tagName.toLowerCase();
        if (VALID_ELEMENTS.hasOwnProperty(tagName)) {
          addCreateNodeAndAppend(create, ELEMENT_MARKER, tagName, parentIdx, newIndex);
          tView.data[newIndex] = tagName;
          const elAttrs = element.attributes;
          for (let i = 0; i < elAttrs.length; i++) {
            const attr = elAttrs.item(i);
            const lowerAttrName = attr.name.toLowerCase();
            const hasBinding2 = !!attr.value.match(BINDING_REGEXP);
            if (hasBinding2) {
              if (VALID_ATTRS.hasOwnProperty(lowerAttrName)) {
                if (URI_ATTRS[lowerAttrName]) {
                  generateBindingUpdateOpCodes(update, attr.value, newIndex, attr.name, 0, _sanitizeUrl);
                } else {
                  generateBindingUpdateOpCodes(update, attr.value, newIndex, attr.name, 0, null);
                }
              } else {
                ngDevMode && console.warn(`WARNING: ignoring unsafe attribute value ${lowerAttrName} on element ${tagName} (see ${XSS_SECURITY_URL})`);
              }
            } else {
              addCreateAttribute(create, newIndex, attr);
            }
          }
          const elementNode = {
            kind: 1,
            index: newIndex,
            children: []
          };
          ast.push(elementNode);
          bindingMask = walkIcuTree(elementNode.children, tView, tIcu, lView, sharedUpdateOpCodes, create, remove2, update, currentNode, newIndex, nestedIcus, depth + 1) | bindingMask;
          addRemoveNode(remove2, newIndex, depth);
        }
        break;
      case Node.TEXT_NODE:
        const value = currentNode.textContent || "";
        const hasBinding = value.match(BINDING_REGEXP);
        addCreateNodeAndAppend(create, null, hasBinding ? "" : value, parentIdx, newIndex);
        addRemoveNode(remove2, newIndex, depth);
        if (hasBinding) {
          bindingMask = generateBindingUpdateOpCodes(update, value, newIndex, null, 0, null) | bindingMask;
        }
        ast.push({
          kind: 0,
          index: newIndex
        });
        break;
      case Node.COMMENT_NODE:
        const isNestedIcu = NESTED_ICU.exec(currentNode.textContent || "");
        if (isNestedIcu) {
          const nestedIcuIndex = parseInt(isNestedIcu[1], 10);
          const icuExpression = nestedIcus[nestedIcuIndex];
          addCreateNodeAndAppend(create, ICU_MARKER, ngDevMode ? `nested ICU ${nestedIcuIndex}` : "", parentIdx, newIndex);
          icuStart(ast, tView, lView, sharedUpdateOpCodes, parentIdx, icuExpression, newIndex);
          addRemoveNestedIcu(remove2, newIndex, depth);
        }
        break;
    }
    currentNode = currentNode.nextSibling;
  }
  return bindingMask;
}
function addRemoveNode(remove2, index, depth) {
  if (depth === 0) {
    remove2.push(index);
  }
}
function addRemoveNestedIcu(remove2, index, depth) {
  if (depth === 0) {
    remove2.push(~index);
    remove2.push(index);
  }
}
function addUpdateIcuSwitch(update, icuExpression, index) {
  update.push(
    toMaskBit(icuExpression.mainBinding),
    2,
    -1 - icuExpression.mainBinding,
    index << 2 | 2
    /* I18nUpdateOpCode.IcuSwitch */
  );
}
function addUpdateIcuUpdate(update, bindingMask, index) {
  update.push(
    bindingMask,
    1,
    index << 2 | 3
    /* I18nUpdateOpCode.IcuUpdate */
  );
}
function addCreateNodeAndAppend(create, marker, text, appendToParentIdx, createAtIdx) {
  if (marker !== null) {
    create.push(marker);
  }
  create.push(text, createAtIdx, icuCreateOpCode(0, appendToParentIdx, createAtIdx));
}
function addCreateAttribute(create, newIndex, attr) {
  create.push(newIndex << 1 | 1, attr.name, attr.value);
}
var ROOT_TEMPLATE_ID = 0;
var PP_MULTI_VALUE_PLACEHOLDERS_REGEXP = /\[(�.+?�?)\]/;
var PP_PLACEHOLDERS_REGEXP = /\[(�.+?�?)\]|(�\/?\*\d+:\d+�)/g;
var PP_ICU_VARS_REGEXP = /({\s*)(VAR_(PLURAL|SELECT)(_\d+)?)(\s*,)/g;
var PP_ICU_PLACEHOLDERS_REGEXP = /{([A-Z0-9_]+)}/g;
var PP_ICUS_REGEXP = /�I18N_EXP_(ICU(_\d+)?)�/g;
var PP_CLOSE_TEMPLATE_REGEXP = /\/\*/;
var PP_TEMPLATE_ID_REGEXP = /\d+\:(\d+)/;
function i18nPostprocess(message, replacements = {}) {
  let result = message;
  if (PP_MULTI_VALUE_PLACEHOLDERS_REGEXP.test(message)) {
    const matches = {};
    const templateIdsStack = [ROOT_TEMPLATE_ID];
    result = result.replace(PP_PLACEHOLDERS_REGEXP, (m, phs, tmpl) => {
      const content = phs || tmpl;
      const placeholders = matches[content] || [];
      if (!placeholders.length) {
        content.split("|").forEach((placeholder2) => {
          const match = placeholder2.match(PP_TEMPLATE_ID_REGEXP);
          const templateId2 = match ? parseInt(match[1], 10) : ROOT_TEMPLATE_ID;
          const isCloseTemplateTag2 = PP_CLOSE_TEMPLATE_REGEXP.test(placeholder2);
          placeholders.push([templateId2, isCloseTemplateTag2, placeholder2]);
        });
        matches[content] = placeholders;
      }
      if (!placeholders.length) {
        throw new Error(`i18n postprocess: unmatched placeholder - ${content}`);
      }
      const currentTemplateId = templateIdsStack[templateIdsStack.length - 1];
      let idx = 0;
      for (let i = 0; i < placeholders.length; i++) {
        if (placeholders[i][0] === currentTemplateId) {
          idx = i;
          break;
        }
      }
      const [templateId, isCloseTemplateTag, placeholder] = placeholders[idx];
      if (isCloseTemplateTag) {
        templateIdsStack.pop();
      } else if (currentTemplateId !== templateId) {
        templateIdsStack.push(templateId);
      }
      placeholders.splice(idx, 1);
      return placeholder;
    });
  }
  if (!Object.keys(replacements).length) {
    return result;
  }
  result = result.replace(PP_ICU_VARS_REGEXP, (match, start, key, _type, _idx, end) => {
    return replacements.hasOwnProperty(key) ? `${start}${replacements[key]}${end}` : match;
  });
  result = result.replace(PP_ICU_PLACEHOLDERS_REGEXP, (match, key) => {
    return replacements.hasOwnProperty(key) ? replacements[key] : match;
  });
  result = result.replace(PP_ICUS_REGEXP, (match, key) => {
    if (replacements.hasOwnProperty(key)) {
      const list = replacements[key];
      if (!list.length) {
        throw new Error(`i18n postprocess: unmatched ICU - ${match} with key: ${key}`);
      }
      return list.shift();
    }
    return match;
  });
  return result;
}
function ɵɵi18nStart(index, messageIndex, subTemplateIndex = -1) {
  const tView = getTView();
  const lView = getLView();
  const adjustedIndex = HEADER_OFFSET + index;
  ngDevMode && assertDefined(tView, `tView should be defined`);
  const message = getConstant(tView.consts, messageIndex);
  const parentTNode = getCurrentParentTNode();
  if (tView.firstCreatePass) {
    i18nStartFirstCreatePass(tView, parentTNode === null ? 0 : parentTNode.index, lView, adjustedIndex, message, subTemplateIndex);
  }
  if (tView.type === 2) {
    const componentLView = lView[DECLARATION_COMPONENT_VIEW];
    componentLView[FLAGS] |= 32;
  } else {
    lView[FLAGS] |= 32;
  }
  const tI18n = tView.data[adjustedIndex];
  const sameViewParentTNode = parentTNode === lView[T_HOST] ? null : parentTNode;
  const parentRNode = getClosestRElement(tView, sameViewParentTNode, lView);
  const insertInFrontOf = parentTNode && parentTNode.type & 8 ? lView[parentTNode.index] : null;
  prepareI18nBlockForHydration(lView, adjustedIndex, parentTNode, subTemplateIndex);
  applyCreateOpCodes(lView, tI18n.create, parentRNode, insertInFrontOf);
  setInI18nBlock(true);
}
function ɵɵi18nEnd() {
  setInI18nBlock(false);
}
function ɵɵi18n(index, messageIndex, subTemplateIndex) {
  ɵɵi18nStart(index, messageIndex, subTemplateIndex);
  ɵɵi18nEnd();
}
function ɵɵi18nAttributes(index, attrsIndex) {
  const tView = getTView();
  ngDevMode && assertDefined(tView, `tView should be defined`);
  const attrs = getConstant(tView.consts, attrsIndex);
  i18nAttributesFirstPass(tView, index + HEADER_OFFSET, attrs);
}
function ɵɵi18nExp(value) {
  const lView = getLView();
  setMaskBit(bindingUpdated(lView, nextBindingIndex(), value));
  return ɵɵi18nExp;
}
function ɵɵi18nApply(index) {
  applyI18n(getTView(), getLView(), index + HEADER_OFFSET);
}
function ɵɵi18nPostprocess(message, replacements = {}) {
  return i18nPostprocess(message, replacements);
}
var stashEventListener = (el, eventName, listenerFn) => {
};
function ɵɵlistener(eventName, listenerFn, useCapture, eventTargetResolver) {
  const lView = getLView();
  const tView = getTView();
  const tNode = getCurrentTNode();
  listenerInternal(tView, lView, lView[RENDERER], tNode, eventName, listenerFn, eventTargetResolver);
  return ɵɵlistener;
}
function ɵɵsyntheticHostListener(eventName, listenerFn) {
  const tNode = getCurrentTNode();
  const lView = getLView();
  const tView = getTView();
  const currentDef = getCurrentDirectiveDef(tView.data);
  const renderer = loadComponentRenderer(currentDef, tNode, lView);
  listenerInternal(tView, lView, renderer, tNode, eventName, listenerFn);
  return ɵɵsyntheticHostListener;
}
function findExistingListener(tView, lView, eventName, tNodeIdx) {
  const tCleanup = tView.cleanup;
  if (tCleanup != null) {
    for (let i = 0; i < tCleanup.length - 1; i += 2) {
      const cleanupEventName = tCleanup[i];
      if (cleanupEventName === eventName && tCleanup[i + 1] === tNodeIdx) {
        const lCleanup = lView[CLEANUP];
        const listenerIdxInLCleanup = tCleanup[i + 2];
        return lCleanup.length > listenerIdxInLCleanup ? lCleanup[listenerIdxInLCleanup] : null;
      }
      if (typeof cleanupEventName === "string") {
        i += 2;
      }
    }
  }
  return null;
}
function listenerInternal(tView, lView, renderer, tNode, eventName, listenerFn, eventTargetResolver) {
  const isTNodeDirectiveHost = isDirectiveHost(tNode);
  const firstCreatePass = tView.firstCreatePass;
  const tCleanup = firstCreatePass && getOrCreateTViewCleanup(tView);
  const context = lView[CONTEXT];
  const lCleanup = getOrCreateLViewCleanup(lView);
  ngDevMode && assertTNodeType(
    tNode,
    3 | 12
    /* TNodeType.AnyContainer */
  );
  let processOutputs = true;
  if (tNode.type & 3 || eventTargetResolver) {
    const native = getNativeByTNode(tNode, lView);
    const target = eventTargetResolver ? eventTargetResolver(native) : native;
    const lCleanupIndex = lCleanup.length;
    const idxOrTargetGetter = eventTargetResolver ? (_lView) => eventTargetResolver(unwrapRNode(_lView[tNode.index])) : tNode.index;
    let existingListener = null;
    if (!eventTargetResolver && isTNodeDirectiveHost) {
      existingListener = findExistingListener(tView, lView, eventName, tNode.index);
    }
    if (existingListener !== null) {
      const lastListenerFn = existingListener.__ngLastListenerFn__ || existingListener;
      lastListenerFn.__ngNextListenerFn__ = listenerFn;
      existingListener.__ngLastListenerFn__ = listenerFn;
      processOutputs = false;
    } else {
      listenerFn = wrapListener(tNode, lView, context, listenerFn);
      stashEventListener(native, eventName, listenerFn);
      const cleanupFn = renderer.listen(target, eventName, listenerFn);
      ngDevMode && ngDevMode.rendererAddEventListener++;
      lCleanup.push(listenerFn, cleanupFn);
      tCleanup && tCleanup.push(eventName, idxOrTargetGetter, lCleanupIndex, lCleanupIndex + 1);
    }
  } else {
    listenerFn = wrapListener(tNode, lView, context, listenerFn);
  }
  const outputs = tNode.outputs;
  let props;
  if (processOutputs && outputs !== null && (props = outputs[eventName])) {
    const propsLength = props.length;
    if (propsLength) {
      for (let i = 0; i < propsLength; i += 2) {
        const index = props[i];
        ngDevMode && assertIndexInRange(lView, index);
        const minifiedName = props[i + 1];
        const directiveInstance = lView[index];
        const output = directiveInstance[minifiedName];
        if (ngDevMode && !isOutputSubscribable(output)) {
          throw new Error(`@Output ${minifiedName} not initialized in '${directiveInstance.constructor.name}'.`);
        }
        const subscription = output.subscribe(listenerFn);
        const idx = lCleanup.length;
        lCleanup.push(listenerFn, subscription);
        tCleanup && tCleanup.push(eventName, tNode.index, idx, -(idx + 1));
      }
    }
  }
}
function executeListenerWithErrorHandling(lView, context, listenerFn, e) {
  const prevConsumer = setActiveConsumer(null);
  try {
    profiler(6, context, listenerFn);
    return listenerFn(e) !== false;
  } catch (error) {
    handleError(lView, error);
    return false;
  } finally {
    profiler(7, context, listenerFn);
    setActiveConsumer(prevConsumer);
  }
}
function wrapListener(tNode, lView, context, listenerFn) {
  return function wrapListenerIn_markDirtyAndPreventDefault(e) {
    if (e === Function) {
      return listenerFn;
    }
    const startView = tNode.componentOffset > -1 ? getComponentLViewByIndex(tNode.index, lView) : lView;
    markViewDirty(
      startView,
      5
      /* NotificationSource.Listener */
    );
    let result = executeListenerWithErrorHandling(lView, context, listenerFn, e);
    let nextListenerFn = wrapListenerIn_markDirtyAndPreventDefault.__ngNextListenerFn__;
    while (nextListenerFn) {
      result = executeListenerWithErrorHandling(lView, context, nextListenerFn, e) && result;
      nextListenerFn = nextListenerFn.__ngNextListenerFn__;
    }
    return result;
  };
}
function isOutputSubscribable(value) {
  return value != null && typeof value.subscribe === "function";
}
function ɵɵnextContext(level = 1) {
  return nextContextImpl(level);
}
function matchingProjectionSlotIndex(tNode, projectionSlots) {
  let wildcardNgContentIndex = null;
  const ngProjectAsAttrVal = getProjectAsAttrValue(tNode);
  for (let i = 0; i < projectionSlots.length; i++) {
    const slotValue = projectionSlots[i];
    if (slotValue === "*") {
      wildcardNgContentIndex = i;
      continue;
    }
    if (ngProjectAsAttrVal === null ? isNodeMatchingSelectorList(
      tNode,
      slotValue,
      /* isProjectionMode */
      true
    ) : isSelectorInSelectorList(ngProjectAsAttrVal, slotValue)) {
      return i;
    }
  }
  return wildcardNgContentIndex;
}
function ɵɵprojectionDef(projectionSlots) {
  const componentNode = getLView()[DECLARATION_COMPONENT_VIEW][T_HOST];
  if (!componentNode.projection) {
    const numProjectionSlots = projectionSlots ? projectionSlots.length : 1;
    const projectionHeads = componentNode.projection = newArray(numProjectionSlots, null);
    const tails = projectionHeads.slice();
    let componentChild = componentNode.child;
    while (componentChild !== null) {
      if (componentChild.type !== 128) {
        const slotIndex = projectionSlots ? matchingProjectionSlotIndex(componentChild, projectionSlots) : 0;
        if (slotIndex !== null) {
          if (tails[slotIndex]) {
            tails[slotIndex].projectionNext = componentChild;
          } else {
            projectionHeads[slotIndex] = componentChild;
          }
          tails[slotIndex] = componentChild;
        }
      }
      componentChild = componentChild.next;
    }
  }
}
function ɵɵprojection(nodeIndex, selectorIndex = 0, attrs, fallbackTemplateFn, fallbackDecls, fallbackVars) {
  const lView = getLView();
  const tView = getTView();
  const fallbackIndex = fallbackTemplateFn ? nodeIndex + 1 : null;
  if (fallbackIndex !== null) {
    declareTemplate(lView, tView, fallbackIndex, fallbackTemplateFn, fallbackDecls, fallbackVars, null, attrs);
  }
  const tProjectionNode = getOrCreateTNode(tView, HEADER_OFFSET + nodeIndex, 16, null, attrs || null);
  if (tProjectionNode.projection === null) {
    tProjectionNode.projection = selectorIndex;
  }
  setCurrentTNodeAsNotParent();
  const hydrationInfo = lView[HYDRATION];
  const isNodeCreationMode = !hydrationInfo || isInSkipHydrationBlock$1();
  const componentHostNode = lView[DECLARATION_COMPONENT_VIEW][T_HOST];
  const isEmpty = componentHostNode.projection[tProjectionNode.projection] === null;
  if (isEmpty && fallbackIndex !== null) {
    insertFallbackContent(lView, tView, fallbackIndex);
  } else if (isNodeCreationMode && (tProjectionNode.flags & 32) !== 32) {
    applyProjection(tView, lView, tProjectionNode);
  }
}
function insertFallbackContent(lView, tView, fallbackIndex) {
  const adjustedIndex = HEADER_OFFSET + fallbackIndex;
  const fallbackTNode = tView.data[adjustedIndex];
  const fallbackLContainer = lView[adjustedIndex];
  ngDevMode && assertTNode(fallbackTNode);
  ngDevMode && assertLContainer(fallbackLContainer);
  const dehydratedView = findMatchingDehydratedView(fallbackLContainer, fallbackTNode.tView.ssrId);
  const fallbackLView = createAndRenderEmbeddedLView(lView, fallbackTNode, void 0, {
    dehydratedView
  });
  addLViewToLContainer(fallbackLContainer, fallbackLView, 0, shouldAddViewToDom(fallbackTNode, dehydratedView));
}
function ɵɵpropertyInterpolate(propName, v0, sanitizer) {
  ɵɵpropertyInterpolate1(propName, "", v0, "", sanitizer);
  return ɵɵpropertyInterpolate;
}
function ɵɵpropertyInterpolate1(propName, prefix, v0, suffix, sanitizer) {
  const lView = getLView();
  const interpolatedValue = interpolation1(lView, prefix, v0, suffix);
  if (interpolatedValue !== NO_CHANGE) {
    const tView = getTView();
    const tNode = getSelectedTNode();
    elementPropertyInternal(tView, tNode, lView, propName, interpolatedValue, lView[RENDERER], sanitizer, false);
    ngDevMode && storePropertyBindingMetadata(tView.data, tNode, propName, getBindingIndex() - 1, prefix, suffix);
  }
  return ɵɵpropertyInterpolate1;
}
function ɵɵpropertyInterpolate2(propName, prefix, v0, i0, v1, suffix, sanitizer) {
  const lView = getLView();
  const interpolatedValue = interpolation2(lView, prefix, v0, i0, v1, suffix);
  if (interpolatedValue !== NO_CHANGE) {
    const tView = getTView();
    const tNode = getSelectedTNode();
    elementPropertyInternal(tView, tNode, lView, propName, interpolatedValue, lView[RENDERER], sanitizer, false);
    ngDevMode && storePropertyBindingMetadata(tView.data, tNode, propName, getBindingIndex() - 2, prefix, i0, suffix);
  }
  return ɵɵpropertyInterpolate2;
}
function ɵɵpropertyInterpolate3(propName, prefix, v0, i0, v1, i1, v2, suffix, sanitizer) {
  const lView = getLView();
  const interpolatedValue = interpolation3(lView, prefix, v0, i0, v1, i1, v2, suffix);
  if (interpolatedValue !== NO_CHANGE) {
    const tView = getTView();
    const tNode = getSelectedTNode();
    elementPropertyInternal(tView, tNode, lView, propName, interpolatedValue, lView[RENDERER], sanitizer, false);
    ngDevMode && storePropertyBindingMetadata(tView.data, tNode, propName, getBindingIndex() - 3, prefix, i0, i1, suffix);
  }
  return ɵɵpropertyInterpolate3;
}
function ɵɵpropertyInterpolate4(propName, prefix, v0, i0, v1, i1, v2, i2, v3, suffix, sanitizer) {
  const lView = getLView();
  const interpolatedValue = interpolation4(lView, prefix, v0, i0, v1, i1, v2, i2, v3, suffix);
  if (interpolatedValue !== NO_CHANGE) {
    const tView = getTView();
    const tNode = getSelectedTNode();
    elementPropertyInternal(tView, tNode, lView, propName, interpolatedValue, lView[RENDERER], sanitizer, false);
    ngDevMode && storePropertyBindingMetadata(tView.data, tNode, propName, getBindingIndex() - 4, prefix, i0, i1, i2, suffix);
  }
  return ɵɵpropertyInterpolate4;
}
function ɵɵpropertyInterpolate5(propName, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, suffix, sanitizer) {
  const lView = getLView();
  const interpolatedValue = interpolation5(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, suffix);
  if (interpolatedValue !== NO_CHANGE) {
    const tView = getTView();
    const tNode = getSelectedTNode();
    elementPropertyInternal(tView, tNode, lView, propName, interpolatedValue, lView[RENDERER], sanitizer, false);
    ngDevMode && storePropertyBindingMetadata(tView.data, tNode, propName, getBindingIndex() - 5, prefix, i0, i1, i2, i3, suffix);
  }
  return ɵɵpropertyInterpolate5;
}
function ɵɵpropertyInterpolate6(propName, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, suffix, sanitizer) {
  const lView = getLView();
  const interpolatedValue = interpolation6(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, suffix);
  if (interpolatedValue !== NO_CHANGE) {
    const tView = getTView();
    const tNode = getSelectedTNode();
    elementPropertyInternal(tView, tNode, lView, propName, interpolatedValue, lView[RENDERER], sanitizer, false);
    ngDevMode && storePropertyBindingMetadata(tView.data, tNode, propName, getBindingIndex() - 6, prefix, i0, i1, i2, i3, i4, suffix);
  }
  return ɵɵpropertyInterpolate6;
}
function ɵɵpropertyInterpolate7(propName, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, suffix, sanitizer) {
  const lView = getLView();
  const interpolatedValue = interpolation7(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, suffix);
  if (interpolatedValue !== NO_CHANGE) {
    const tView = getTView();
    const tNode = getSelectedTNode();
    elementPropertyInternal(tView, tNode, lView, propName, interpolatedValue, lView[RENDERER], sanitizer, false);
    ngDevMode && storePropertyBindingMetadata(tView.data, tNode, propName, getBindingIndex() - 7, prefix, i0, i1, i2, i3, i4, i5, suffix);
  }
  return ɵɵpropertyInterpolate7;
}
function ɵɵpropertyInterpolate8(propName, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, i6, v7, suffix, sanitizer) {
  const lView = getLView();
  const interpolatedValue = interpolation8(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, i6, v7, suffix);
  if (interpolatedValue !== NO_CHANGE) {
    const tView = getTView();
    const tNode = getSelectedTNode();
    elementPropertyInternal(tView, tNode, lView, propName, interpolatedValue, lView[RENDERER], sanitizer, false);
    ngDevMode && storePropertyBindingMetadata(tView.data, tNode, propName, getBindingIndex() - 8, prefix, i0, i1, i2, i3, i4, i5, i6, suffix);
  }
  return ɵɵpropertyInterpolate8;
}
function ɵɵpropertyInterpolateV(propName, values, sanitizer) {
  const lView = getLView();
  const interpolatedValue = interpolationV(lView, values);
  if (interpolatedValue !== NO_CHANGE) {
    const tView = getTView();
    const tNode = getSelectedTNode();
    elementPropertyInternal(tView, tNode, lView, propName, interpolatedValue, lView[RENDERER], sanitizer, false);
    if (ngDevMode) {
      const interpolationInBetween = [values[0]];
      for (let i = 2; i < values.length; i += 2) {
        interpolationInBetween.push(values[i]);
      }
      storePropertyBindingMetadata(tView.data, tNode, propName, getBindingIndex() - interpolationInBetween.length + 1, ...interpolationInBetween);
    }
  }
  return ɵɵpropertyInterpolateV;
}
function ɵɵcontentQuery(directiveIndex, predicate, flags, read) {
  createContentQuery(directiveIndex, predicate, flags, read);
}
function ɵɵviewQuery(predicate, flags, read) {
  createViewQuery(predicate, flags, read);
}
function ɵɵqueryRefresh(queryList) {
  const lView = getLView();
  const tView = getTView();
  const queryIndex = getCurrentQueryIndex();
  setCurrentQueryIndex(queryIndex + 1);
  const tQuery = getTQuery(tView, queryIndex);
  if (queryList.dirty && isCreationMode(lView) === ((tQuery.metadata.flags & 2) === 2)) {
    if (tQuery.matches === null) {
      queryList.reset([]);
    } else {
      const result = getQueryResults(lView, queryIndex);
      queryList.reset(result, unwrapElementRef);
      queryList.notifyOnChanges();
    }
    return true;
  }
  return false;
}
function ɵɵloadQuery() {
  return loadQueryInternal(getLView(), getCurrentQueryIndex());
}
function ɵɵcontentQuerySignal(directiveIndex, target, predicate, flags, read) {
  bindQueryToSignal(target, createContentQuery(directiveIndex, predicate, flags, read));
}
function ɵɵviewQuerySignal(target, predicate, flags, read) {
  bindQueryToSignal(target, createViewQuery(predicate, flags, read));
}
function ɵɵqueryAdvance(indexOffset = 1) {
  setCurrentQueryIndex(getCurrentQueryIndex() + indexOffset);
}
function store(tView, lView, index, value) {
  if (index >= tView.data.length) {
    tView.data[index] = null;
    tView.blueprint[index] = null;
  }
  lView[index] = value;
}
function ɵɵreference(index) {
  const contextLView = getContextLView();
  return load(contextLView, HEADER_OFFSET + index);
}
function ɵɵstyleMapInterpolate1(prefix, v0, suffix) {
  const lView = getLView();
  const interpolatedValue = interpolation1(lView, prefix, v0, suffix);
  ɵɵstyleMap(interpolatedValue);
}
function ɵɵstyleMapInterpolate2(prefix, v0, i0, v1, suffix) {
  const lView = getLView();
  const interpolatedValue = interpolation2(lView, prefix, v0, i0, v1, suffix);
  ɵɵstyleMap(interpolatedValue);
}
function ɵɵstyleMapInterpolate3(prefix, v0, i0, v1, i1, v2, suffix) {
  const lView = getLView();
  const interpolatedValue = interpolation3(lView, prefix, v0, i0, v1, i1, v2, suffix);
  ɵɵstyleMap(interpolatedValue);
}
function ɵɵstyleMapInterpolate4(prefix, v0, i0, v1, i1, v2, i2, v3, suffix) {
  const lView = getLView();
  const interpolatedValue = interpolation4(lView, prefix, v0, i0, v1, i1, v2, i2, v3, suffix);
  ɵɵstyleMap(interpolatedValue);
}
function ɵɵstyleMapInterpolate5(prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, suffix) {
  const lView = getLView();
  const interpolatedValue = interpolation5(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, suffix);
  ɵɵstyleMap(interpolatedValue);
}
function ɵɵstyleMapInterpolate6(prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, suffix) {
  const lView = getLView();
  const interpolatedValue = interpolation6(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, suffix);
  ɵɵstyleMap(interpolatedValue);
}
function ɵɵstyleMapInterpolate7(prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, suffix) {
  const lView = getLView();
  const interpolatedValue = interpolation7(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, suffix);
  ɵɵstyleMap(interpolatedValue);
}
function ɵɵstyleMapInterpolate8(prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, i6, v7, suffix) {
  const lView = getLView();
  const interpolatedValue = interpolation8(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, i6, v7, suffix);
  ɵɵstyleMap(interpolatedValue);
}
function ɵɵstyleMapInterpolateV(values) {
  const lView = getLView();
  const interpolatedValue = interpolationV(lView, values);
  ɵɵstyleMap(interpolatedValue);
}
function ɵɵstylePropInterpolate1(prop, prefix, v0, suffix, valueSuffix) {
  const lView = getLView();
  const interpolatedValue = interpolation1(lView, prefix, v0, suffix);
  checkStylingProperty(prop, interpolatedValue, valueSuffix, false);
  return ɵɵstylePropInterpolate1;
}
function ɵɵstylePropInterpolate2(prop, prefix, v0, i0, v1, suffix, valueSuffix) {
  const lView = getLView();
  const interpolatedValue = interpolation2(lView, prefix, v0, i0, v1, suffix);
  checkStylingProperty(prop, interpolatedValue, valueSuffix, false);
  return ɵɵstylePropInterpolate2;
}
function ɵɵstylePropInterpolate3(prop, prefix, v0, i0, v1, i1, v2, suffix, valueSuffix) {
  const lView = getLView();
  const interpolatedValue = interpolation3(lView, prefix, v0, i0, v1, i1, v2, suffix);
  checkStylingProperty(prop, interpolatedValue, valueSuffix, false);
  return ɵɵstylePropInterpolate3;
}
function ɵɵstylePropInterpolate4(prop, prefix, v0, i0, v1, i1, v2, i2, v3, suffix, valueSuffix) {
  const lView = getLView();
  const interpolatedValue = interpolation4(lView, prefix, v0, i0, v1, i1, v2, i2, v3, suffix);
  checkStylingProperty(prop, interpolatedValue, valueSuffix, false);
  return ɵɵstylePropInterpolate4;
}
function ɵɵstylePropInterpolate5(prop, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, suffix, valueSuffix) {
  const lView = getLView();
  const interpolatedValue = interpolation5(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, suffix);
  checkStylingProperty(prop, interpolatedValue, valueSuffix, false);
  return ɵɵstylePropInterpolate5;
}
function ɵɵstylePropInterpolate6(prop, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, suffix, valueSuffix) {
  const lView = getLView();
  const interpolatedValue = interpolation6(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, suffix);
  checkStylingProperty(prop, interpolatedValue, valueSuffix, false);
  return ɵɵstylePropInterpolate6;
}
function ɵɵstylePropInterpolate7(prop, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, suffix, valueSuffix) {
  const lView = getLView();
  const interpolatedValue = interpolation7(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, suffix);
  checkStylingProperty(prop, interpolatedValue, valueSuffix, false);
  return ɵɵstylePropInterpolate7;
}
function ɵɵstylePropInterpolate8(prop, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, i6, v7, suffix, valueSuffix) {
  const lView = getLView();
  const interpolatedValue = interpolation8(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, i6, v7, suffix);
  checkStylingProperty(prop, interpolatedValue, valueSuffix, false);
  return ɵɵstylePropInterpolate8;
}
function ɵɵstylePropInterpolateV(prop, values, valueSuffix) {
  const lView = getLView();
  const interpolatedValue = interpolationV(lView, values);
  checkStylingProperty(prop, interpolatedValue, valueSuffix, false);
  return ɵɵstylePropInterpolateV;
}
function ɵɵtext(index, value = "") {
  const lView = getLView();
  const tView = getTView();
  const adjustedIndex = index + HEADER_OFFSET;
  ngDevMode && assertEqual(getBindingIndex(), tView.bindingStartIndex, "text nodes should be created before any bindings");
  ngDevMode && assertIndexInRange(lView, adjustedIndex);
  const tNode = tView.firstCreatePass ? getOrCreateTNode(tView, adjustedIndex, 1, value, null) : tView.data[adjustedIndex];
  const textNative = _locateOrCreateTextNode(tView, lView, tNode, value, index);
  lView[adjustedIndex] = textNative;
  if (wasLastNodeCreated()) {
    appendChild(tView, lView, textNative, tNode);
  }
  setCurrentTNode(tNode, false);
}
var _locateOrCreateTextNode = (tView, lView, tNode, value, index) => {
  lastNodeWasCreated(true);
  return createTextNode(lView[RENDERER], value);
};
function ɵɵtextInterpolate(v0) {
  ɵɵtextInterpolate1("", v0, "");
  return ɵɵtextInterpolate;
}
function ɵɵtextInterpolate1(prefix, v0, suffix) {
  const lView = getLView();
  const interpolated = interpolation1(lView, prefix, v0, suffix);
  if (interpolated !== NO_CHANGE) {
    textBindingInternal(lView, getSelectedIndex(), interpolated);
  }
  return ɵɵtextInterpolate1;
}
function ɵɵtextInterpolate2(prefix, v0, i0, v1, suffix) {
  const lView = getLView();
  const interpolated = interpolation2(lView, prefix, v0, i0, v1, suffix);
  if (interpolated !== NO_CHANGE) {
    textBindingInternal(lView, getSelectedIndex(), interpolated);
  }
  return ɵɵtextInterpolate2;
}
function ɵɵtextInterpolate3(prefix, v0, i0, v1, i1, v2, suffix) {
  const lView = getLView();
  const interpolated = interpolation3(lView, prefix, v0, i0, v1, i1, v2, suffix);
  if (interpolated !== NO_CHANGE) {
    textBindingInternal(lView, getSelectedIndex(), interpolated);
  }
  return ɵɵtextInterpolate3;
}
function ɵɵtextInterpolate4(prefix, v0, i0, v1, i1, v2, i2, v3, suffix) {
  const lView = getLView();
  const interpolated = interpolation4(lView, prefix, v0, i0, v1, i1, v2, i2, v3, suffix);
  if (interpolated !== NO_CHANGE) {
    textBindingInternal(lView, getSelectedIndex(), interpolated);
  }
  return ɵɵtextInterpolate4;
}
function ɵɵtextInterpolate5(prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, suffix) {
  const lView = getLView();
  const interpolated = interpolation5(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, suffix);
  if (interpolated !== NO_CHANGE) {
    textBindingInternal(lView, getSelectedIndex(), interpolated);
  }
  return ɵɵtextInterpolate5;
}
function ɵɵtextInterpolate6(prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, suffix) {
  const lView = getLView();
  const interpolated = interpolation6(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, suffix);
  if (interpolated !== NO_CHANGE) {
    textBindingInternal(lView, getSelectedIndex(), interpolated);
  }
  return ɵɵtextInterpolate6;
}
function ɵɵtextInterpolate7(prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, suffix) {
  const lView = getLView();
  const interpolated = interpolation7(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, suffix);
  if (interpolated !== NO_CHANGE) {
    textBindingInternal(lView, getSelectedIndex(), interpolated);
  }
  return ɵɵtextInterpolate7;
}
function ɵɵtextInterpolate8(prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, i6, v7, suffix) {
  const lView = getLView();
  const interpolated = interpolation8(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, i6, v7, suffix);
  if (interpolated !== NO_CHANGE) {
    textBindingInternal(lView, getSelectedIndex(), interpolated);
  }
  return ɵɵtextInterpolate8;
}
function ɵɵtextInterpolateV(values) {
  const lView = getLView();
  const interpolated = interpolationV(lView, values);
  if (interpolated !== NO_CHANGE) {
    textBindingInternal(lView, getSelectedIndex(), interpolated);
  }
  return ɵɵtextInterpolateV;
}
function ɵɵtwoWayProperty(propName, value, sanitizer) {
  if (isWritableSignal(value)) {
    value = value();
  }
  const lView = getLView();
  const bindingIndex = nextBindingIndex();
  if (bindingUpdated(lView, bindingIndex, value)) {
    const tView = getTView();
    const tNode = getSelectedTNode();
    elementPropertyInternal(tView, tNode, lView, propName, value, lView[RENDERER], sanitizer, false);
    ngDevMode && storePropertyBindingMetadata(tView.data, tNode, propName, bindingIndex);
  }
  return ɵɵtwoWayProperty;
}
function ɵɵtwoWayBindingSet(target, value) {
  const canWrite = isWritableSignal(target);
  canWrite && target.set(value);
  return canWrite;
}
function ɵɵtwoWayListener(eventName, listenerFn) {
  const lView = getLView();
  const tView = getTView();
  const tNode = getCurrentTNode();
  listenerInternal(tView, lView, lView[RENDERER], tNode, eventName, listenerFn);
  return ɵɵtwoWayListener;
}
var UNINITIALIZED_LET = {};
function ɵɵdeclareLet(index) {
  const tView = getTView();
  const lView = getLView();
  const adjustedIndex = index + HEADER_OFFSET;
  const tNode = getOrCreateTNode(tView, adjustedIndex, 128, null, null);
  setCurrentTNode(tNode, false);
  store(tView, lView, adjustedIndex, UNINITIALIZED_LET);
  return ɵɵdeclareLet;
}
function ɵɵstoreLet(value) {
  performanceMarkFeature("NgLet");
  const tView = getTView();
  const lView = getLView();
  const index = getSelectedIndex();
  store(tView, lView, index, value);
  return value;
}
function ɵɵreadContextLet(index) {
  const contextLView = getContextLView();
  const value = load(contextLView, HEADER_OFFSET + index);
  if (value === UNINITIALIZED_LET) {
    throw new RuntimeError(314, ngDevMode && "Attempting to access a @let declaration whose value is not available yet");
  }
  return value;
}
function providersResolver(def, providers, viewProviders) {
  const tView = getTView();
  if (tView.firstCreatePass) {
    const isComponent2 = isComponentDef(def);
    resolveProvider(viewProviders, tView.data, tView.blueprint, isComponent2, true);
    resolveProvider(providers, tView.data, tView.blueprint, isComponent2, false);
  }
}
function resolveProvider(provider, tInjectables, lInjectablesBlueprint, isComponent2, isViewProvider) {
  provider = resolveForwardRef(provider);
  if (Array.isArray(provider)) {
    for (let i = 0; i < provider.length; i++) {
      resolveProvider(provider[i], tInjectables, lInjectablesBlueprint, isComponent2, isViewProvider);
    }
  } else {
    const tView = getTView();
    const lView = getLView();
    const tNode = getCurrentTNode();
    let token = isTypeProvider(provider) ? provider : resolveForwardRef(provider.provide);
    const providerFactory = providerToFactory(provider);
    if (ngDevMode) {
      const injector = new NodeInjector(tNode, lView);
      runInInjectorProfilerContext(injector, token, () => {
        emitProviderConfiguredEvent(provider, isViewProvider);
      });
    }
    const beginIndex = tNode.providerIndexes & 1048575;
    const endIndex = tNode.directiveStart;
    const cptViewProvidersCount = tNode.providerIndexes >> 20;
    if (isTypeProvider(provider) || !provider.multi) {
      const factory = new NodeInjectorFactory(providerFactory, isViewProvider, ɵɵdirectiveInject);
      const existingFactoryIndex = indexOf(token, tInjectables, isViewProvider ? beginIndex : beginIndex + cptViewProvidersCount, endIndex);
      if (existingFactoryIndex === -1) {
        diPublicInInjector(getOrCreateNodeInjectorForNode(tNode, lView), tView, token);
        registerDestroyHooksIfSupported(tView, provider, tInjectables.length);
        tInjectables.push(token);
        tNode.directiveStart++;
        tNode.directiveEnd++;
        if (isViewProvider) {
          tNode.providerIndexes += 1048576;
        }
        lInjectablesBlueprint.push(factory);
        lView.push(factory);
      } else {
        lInjectablesBlueprint[existingFactoryIndex] = factory;
        lView[existingFactoryIndex] = factory;
      }
    } else {
      const existingProvidersFactoryIndex = indexOf(token, tInjectables, beginIndex + cptViewProvidersCount, endIndex);
      const existingViewProvidersFactoryIndex = indexOf(token, tInjectables, beginIndex, beginIndex + cptViewProvidersCount);
      const doesProvidersFactoryExist = existingProvidersFactoryIndex >= 0 && lInjectablesBlueprint[existingProvidersFactoryIndex];
      const doesViewProvidersFactoryExist = existingViewProvidersFactoryIndex >= 0 && lInjectablesBlueprint[existingViewProvidersFactoryIndex];
      if (isViewProvider && !doesViewProvidersFactoryExist || !isViewProvider && !doesProvidersFactoryExist) {
        diPublicInInjector(getOrCreateNodeInjectorForNode(tNode, lView), tView, token);
        const factory = multiFactory(isViewProvider ? multiViewProvidersFactoryResolver : multiProvidersFactoryResolver, lInjectablesBlueprint.length, isViewProvider, isComponent2, providerFactory);
        if (!isViewProvider && doesViewProvidersFactoryExist) {
          lInjectablesBlueprint[existingViewProvidersFactoryIndex].providerFactory = factory;
        }
        registerDestroyHooksIfSupported(tView, provider, tInjectables.length, 0);
        tInjectables.push(token);
        tNode.directiveStart++;
        tNode.directiveEnd++;
        if (isViewProvider) {
          tNode.providerIndexes += 1048576;
        }
        lInjectablesBlueprint.push(factory);
        lView.push(factory);
      } else {
        const indexInFactory = multiFactoryAdd(lInjectablesBlueprint[isViewProvider ? existingViewProvidersFactoryIndex : existingProvidersFactoryIndex], providerFactory, !isViewProvider && isComponent2);
        registerDestroyHooksIfSupported(tView, provider, existingProvidersFactoryIndex > -1 ? existingProvidersFactoryIndex : existingViewProvidersFactoryIndex, indexInFactory);
      }
      if (!isViewProvider && isComponent2 && doesViewProvidersFactoryExist) {
        lInjectablesBlueprint[existingViewProvidersFactoryIndex].componentProviders++;
      }
    }
  }
}
function registerDestroyHooksIfSupported(tView, provider, contextIndex, indexInFactory) {
  const providerIsTypeProvider = isTypeProvider(provider);
  const providerIsClassProvider = isClassProvider(provider);
  if (providerIsTypeProvider || providerIsClassProvider) {
    const classToken = providerIsClassProvider ? resolveForwardRef(provider.useClass) : provider;
    const prototype = classToken.prototype;
    const ngOnDestroy = prototype.ngOnDestroy;
    if (ngOnDestroy) {
      const hooks = tView.destroyHooks || (tView.destroyHooks = []);
      if (!providerIsTypeProvider && provider.multi) {
        ngDevMode && assertDefined(indexInFactory, "indexInFactory when registering multi factory destroy hook");
        const existingCallbacksIndex = hooks.indexOf(contextIndex);
        if (existingCallbacksIndex === -1) {
          hooks.push(contextIndex, [indexInFactory, ngOnDestroy]);
        } else {
          hooks[existingCallbacksIndex + 1].push(indexInFactory, ngOnDestroy);
        }
      } else {
        hooks.push(contextIndex, ngOnDestroy);
      }
    }
  }
}
function multiFactoryAdd(multiFactory2, factory, isComponentProvider) {
  if (isComponentProvider) {
    multiFactory2.componentProviders++;
  }
  return multiFactory2.multi.push(factory) - 1;
}
function indexOf(item, arr, begin, end) {
  for (let i = begin; i < end; i++) {
    if (arr[i] === item) return i;
  }
  return -1;
}
function multiProvidersFactoryResolver(_, tData, lData, tNode) {
  return multiResolve(this.multi, []);
}
function multiViewProvidersFactoryResolver(_, tData, lView, tNode) {
  const factories = this.multi;
  let result;
  if (this.providerFactory) {
    const componentCount = this.providerFactory.componentProviders;
    const multiProviders = getNodeInjectable(lView, lView[TVIEW], this.providerFactory.index, tNode);
    result = multiProviders.slice(0, componentCount);
    multiResolve(factories, result);
    for (let i = componentCount; i < multiProviders.length; i++) {
      result.push(multiProviders[i]);
    }
  } else {
    result = [];
    multiResolve(factories, result);
  }
  return result;
}
function multiResolve(factories, result) {
  for (let i = 0; i < factories.length; i++) {
    const factory = factories[i];
    result.push(factory());
  }
  return result;
}
function multiFactory(factoryFn, index, isViewProvider, isComponent2, f) {
  const factory = new NodeInjectorFactory(factoryFn, isViewProvider, ɵɵdirectiveInject);
  factory.multi = [];
  factory.index = index;
  factory.componentProviders = 0;
  multiFactoryAdd(factory, f, isComponent2 && !isViewProvider);
  return factory;
}
function ɵɵProvidersFeature(providers, viewProviders = []) {
  return (definition) => {
    definition.providersResolver = (def, processProvidersFn) => {
      return providersResolver(
        def,
        //
        processProvidersFn ? processProvidersFn(providers) : providers,
        //
        viewProviders
      );
    };
  };
}
var StandaloneService = class _StandaloneService {
  constructor(_injector) {
    this._injector = _injector;
    this.cachedInjectors = /* @__PURE__ */ new Map();
  }
  getOrCreateStandaloneInjector(componentDef) {
    if (!componentDef.standalone) {
      return null;
    }
    if (!this.cachedInjectors.has(componentDef)) {
      const providers = internalImportProvidersFrom(false, componentDef.type);
      const standaloneInjector = providers.length > 0 ? createEnvironmentInjector([providers], this._injector, `Standalone[${componentDef.type.name}]`) : null;
      this.cachedInjectors.set(componentDef, standaloneInjector);
    }
    return this.cachedInjectors.get(componentDef);
  }
  ngOnDestroy() {
    try {
      for (const injector of this.cachedInjectors.values()) {
        if (injector !== null) {
          injector.destroy();
        }
      }
    } finally {
      this.cachedInjectors.clear();
    }
  }
  static {
    this.ɵprov = ɵɵdefineInjectable({
      token: _StandaloneService,
      providedIn: "environment",
      factory: () => new _StandaloneService(ɵɵinject(EnvironmentInjector))
    });
  }
};
function ɵɵStandaloneFeature(definition) {
  performanceMarkFeature("NgStandalone");
  definition.getStandaloneInjector = (parentInjector) => {
    return parentInjector.get(StandaloneService).getOrCreateStandaloneInjector(definition);
  };
}
function ɵɵsetComponentScope(type, directives, pipes) {
  const def = type.ɵcmp;
  def.directiveDefs = extractDefListOrFactory(
    directives,
    /* pipeDef */
    false
  );
  def.pipeDefs = extractDefListOrFactory(
    pipes,
    /* pipeDef */
    true
  );
}
function ɵɵsetNgModuleScope(type, scope) {
  return noSideEffects(() => {
    const ngModuleDef = getNgModuleDef(type, true);
    ngModuleDef.declarations = convertToTypeArray(scope.declarations || EMPTY_ARRAY);
    ngModuleDef.imports = convertToTypeArray(scope.imports || EMPTY_ARRAY);
    ngModuleDef.exports = convertToTypeArray(scope.exports || EMPTY_ARRAY);
    if (scope.bootstrap) {
      ngModuleDef.bootstrap = convertToTypeArray(scope.bootstrap);
    }
    depsTracker.registerNgModule(type, scope);
  });
}
function convertToTypeArray(values) {
  if (typeof values === "function") {
    return values;
  }
  const flattenValues = flatten(values);
  if (flattenValues.some(isForwardRef)) {
    return () => flattenValues.map(resolveForwardRef).map(maybeUnwrapModuleWithProviders);
  } else {
    return flattenValues.map(maybeUnwrapModuleWithProviders);
  }
}
function maybeUnwrapModuleWithProviders(value) {
  return isModuleWithProviders(value) ? value.ngModule : value;
}
function setClassMetadata(type, decorators, ctorParameters, propDecorators) {
  return noSideEffects(() => {
    const clazz = type;
    if (decorators !== null) {
      if (clazz.hasOwnProperty("decorators") && clazz.decorators !== void 0) {
        clazz.decorators.push(...decorators);
      } else {
        clazz.decorators = decorators;
      }
    }
    if (ctorParameters !== null) {
      clazz.ctorParameters = ctorParameters;
    }
    if (propDecorators !== null) {
      if (clazz.hasOwnProperty("propDecorators") && clazz.propDecorators !== void 0) {
        clazz.propDecorators = __spreadValues(__spreadValues({}, clazz.propDecorators), propDecorators);
      } else {
        clazz.propDecorators = propDecorators;
      }
    }
  });
}
function ɵɵpureFunction0(slotOffset, pureFn, thisArg) {
  const bindingIndex = getBindingRoot() + slotOffset;
  const lView = getLView();
  return lView[bindingIndex] === NO_CHANGE ? updateBinding(lView, bindingIndex, thisArg ? pureFn.call(thisArg) : pureFn()) : getBinding(lView, bindingIndex);
}
function ɵɵpureFunction1(slotOffset, pureFn, exp, thisArg) {
  return pureFunction1Internal(getLView(), getBindingRoot(), slotOffset, pureFn, exp, thisArg);
}
function ɵɵpureFunction2(slotOffset, pureFn, exp1, exp2, thisArg) {
  return pureFunction2Internal(getLView(), getBindingRoot(), slotOffset, pureFn, exp1, exp2, thisArg);
}
function ɵɵpureFunction3(slotOffset, pureFn, exp1, exp2, exp3, thisArg) {
  return pureFunction3Internal(getLView(), getBindingRoot(), slotOffset, pureFn, exp1, exp2, exp3, thisArg);
}
function ɵɵpureFunction4(slotOffset, pureFn, exp1, exp2, exp3, exp4, thisArg) {
  return pureFunction4Internal(getLView(), getBindingRoot(), slotOffset, pureFn, exp1, exp2, exp3, exp4, thisArg);
}
function ɵɵpureFunction5(slotOffset, pureFn, exp1, exp2, exp3, exp4, exp5, thisArg) {
  const bindingIndex = getBindingRoot() + slotOffset;
  const lView = getLView();
  const different = bindingUpdated4(lView, bindingIndex, exp1, exp2, exp3, exp4);
  return bindingUpdated(lView, bindingIndex + 4, exp5) || different ? updateBinding(lView, bindingIndex + 5, thisArg ? pureFn.call(thisArg, exp1, exp2, exp3, exp4, exp5) : pureFn(exp1, exp2, exp3, exp4, exp5)) : getBinding(lView, bindingIndex + 5);
}
function ɵɵpureFunction6(slotOffset, pureFn, exp1, exp2, exp3, exp4, exp5, exp6, thisArg) {
  const bindingIndex = getBindingRoot() + slotOffset;
  const lView = getLView();
  const different = bindingUpdated4(lView, bindingIndex, exp1, exp2, exp3, exp4);
  return bindingUpdated2(lView, bindingIndex + 4, exp5, exp6) || different ? updateBinding(lView, bindingIndex + 6, thisArg ? pureFn.call(thisArg, exp1, exp2, exp3, exp4, exp5, exp6) : pureFn(exp1, exp2, exp3, exp4, exp5, exp6)) : getBinding(lView, bindingIndex + 6);
}
function ɵɵpureFunction7(slotOffset, pureFn, exp1, exp2, exp3, exp4, exp5, exp6, exp7, thisArg) {
  const bindingIndex = getBindingRoot() + slotOffset;
  const lView = getLView();
  let different = bindingUpdated4(lView, bindingIndex, exp1, exp2, exp3, exp4);
  return bindingUpdated3(lView, bindingIndex + 4, exp5, exp6, exp7) || different ? updateBinding(lView, bindingIndex + 7, thisArg ? pureFn.call(thisArg, exp1, exp2, exp3, exp4, exp5, exp6, exp7) : pureFn(exp1, exp2, exp3, exp4, exp5, exp6, exp7)) : getBinding(lView, bindingIndex + 7);
}
function ɵɵpureFunction8(slotOffset, pureFn, exp1, exp2, exp3, exp4, exp5, exp6, exp7, exp8, thisArg) {
  const bindingIndex = getBindingRoot() + slotOffset;
  const lView = getLView();
  const different = bindingUpdated4(lView, bindingIndex, exp1, exp2, exp3, exp4);
  return bindingUpdated4(lView, bindingIndex + 4, exp5, exp6, exp7, exp8) || different ? updateBinding(lView, bindingIndex + 8, thisArg ? pureFn.call(thisArg, exp1, exp2, exp3, exp4, exp5, exp6, exp7, exp8) : pureFn(exp1, exp2, exp3, exp4, exp5, exp6, exp7, exp8)) : getBinding(lView, bindingIndex + 8);
}
function ɵɵpureFunctionV(slotOffset, pureFn, exps, thisArg) {
  return pureFunctionVInternal(getLView(), getBindingRoot(), slotOffset, pureFn, exps, thisArg);
}
function getPureFunctionReturnValue(lView, returnValueIndex) {
  ngDevMode && assertIndexInRange(lView, returnValueIndex);
  const lastReturnValue = lView[returnValueIndex];
  return lastReturnValue === NO_CHANGE ? void 0 : lastReturnValue;
}
function pureFunction1Internal(lView, bindingRoot, slotOffset, pureFn, exp, thisArg) {
  const bindingIndex = bindingRoot + slotOffset;
  return bindingUpdated(lView, bindingIndex, exp) ? updateBinding(lView, bindingIndex + 1, thisArg ? pureFn.call(thisArg, exp) : pureFn(exp)) : getPureFunctionReturnValue(lView, bindingIndex + 1);
}
function pureFunction2Internal(lView, bindingRoot, slotOffset, pureFn, exp1, exp2, thisArg) {
  const bindingIndex = bindingRoot + slotOffset;
  return bindingUpdated2(lView, bindingIndex, exp1, exp2) ? updateBinding(lView, bindingIndex + 2, thisArg ? pureFn.call(thisArg, exp1, exp2) : pureFn(exp1, exp2)) : getPureFunctionReturnValue(lView, bindingIndex + 2);
}
function pureFunction3Internal(lView, bindingRoot, slotOffset, pureFn, exp1, exp2, exp3, thisArg) {
  const bindingIndex = bindingRoot + slotOffset;
  return bindingUpdated3(lView, bindingIndex, exp1, exp2, exp3) ? updateBinding(lView, bindingIndex + 3, thisArg ? pureFn.call(thisArg, exp1, exp2, exp3) : pureFn(exp1, exp2, exp3)) : getPureFunctionReturnValue(lView, bindingIndex + 3);
}
function pureFunction4Internal(lView, bindingRoot, slotOffset, pureFn, exp1, exp2, exp3, exp4, thisArg) {
  const bindingIndex = bindingRoot + slotOffset;
  return bindingUpdated4(lView, bindingIndex, exp1, exp2, exp3, exp4) ? updateBinding(lView, bindingIndex + 4, thisArg ? pureFn.call(thisArg, exp1, exp2, exp3, exp4) : pureFn(exp1, exp2, exp3, exp4)) : getPureFunctionReturnValue(lView, bindingIndex + 4);
}
function pureFunctionVInternal(lView, bindingRoot, slotOffset, pureFn, exps, thisArg) {
  let bindingIndex = bindingRoot + slotOffset;
  let different = false;
  for (let i = 0; i < exps.length; i++) {
    bindingUpdated(lView, bindingIndex++, exps[i]) && (different = true);
  }
  return different ? updateBinding(lView, bindingIndex, pureFn.apply(thisArg, exps)) : getPureFunctionReturnValue(lView, bindingIndex);
}
function ɵɵpipe(index, pipeName) {
  const tView = getTView();
  let pipeDef;
  const adjustedIndex = index + HEADER_OFFSET;
  if (tView.firstCreatePass) {
    pipeDef = getPipeDef(pipeName, tView.pipeRegistry);
    tView.data[adjustedIndex] = pipeDef;
    if (pipeDef.onDestroy) {
      (tView.destroyHooks ??= []).push(adjustedIndex, pipeDef.onDestroy);
    }
  } else {
    pipeDef = tView.data[adjustedIndex];
  }
  const pipeFactory = pipeDef.factory || (pipeDef.factory = getFactoryDef(pipeDef.type, true));
  let previousInjectorProfilerContext;
  if (ngDevMode) {
    previousInjectorProfilerContext = setInjectorProfilerContext({
      injector: new NodeInjector(getCurrentTNode(), getLView()),
      token: pipeDef.type
    });
  }
  const previousInjectImplementation = setInjectImplementation(ɵɵdirectiveInject);
  try {
    const previousIncludeViewProviders = setIncludeViewProviders(false);
    const pipeInstance = pipeFactory();
    setIncludeViewProviders(previousIncludeViewProviders);
    store(tView, getLView(), adjustedIndex, pipeInstance);
    return pipeInstance;
  } finally {
    setInjectImplementation(previousInjectImplementation);
    ngDevMode && setInjectorProfilerContext(previousInjectorProfilerContext);
  }
}
function getPipeDef(name, registry) {
  if (registry) {
    if (ngDevMode) {
      const pipes = registry.filter((pipe) => pipe.name === name);
      if (pipes.length > 1) {
        console.warn(formatRuntimeError(313, getMultipleMatchingPipesMessage(name)));
      }
    }
    for (let i = registry.length - 1; i >= 0; i--) {
      const pipeDef = registry[i];
      if (name === pipeDef.name) {
        return pipeDef;
      }
    }
  }
  if (ngDevMode) {
    throw new RuntimeError(-302, getPipeNotFoundErrorMessage(name));
  }
  return;
}
function getMultipleMatchingPipesMessage(name) {
  const lView = getLView();
  const declarationLView = lView[DECLARATION_COMPONENT_VIEW];
  const context = declarationLView[CONTEXT];
  const hostIsStandalone = isHostComponentStandalone(lView);
  const componentInfoMessage = context ? ` in the '${context.constructor.name}' component` : "";
  const verifyMessage = `check ${hostIsStandalone ? "'@Component.imports' of this component" : "the imports of this module"}`;
  const errorMessage = `Multiple pipes match the name \`${name}\`${componentInfoMessage}. ${verifyMessage}`;
  return errorMessage;
}
function getPipeNotFoundErrorMessage(name) {
  const lView = getLView();
  const declarationLView = lView[DECLARATION_COMPONENT_VIEW];
  const context = declarationLView[CONTEXT];
  const hostIsStandalone = isHostComponentStandalone(lView);
  const componentInfoMessage = context ? ` in the '${context.constructor.name}' component` : "";
  const verifyMessage = `Verify that it is ${hostIsStandalone ? "included in the '@Component.imports' of this component" : "declared or imported in this module"}`;
  const errorMessage = `The pipe '${name}' could not be found${componentInfoMessage}. ${verifyMessage}`;
  return errorMessage;
}
function ɵɵpipeBind1(index, offset, v1) {
  const adjustedIndex = index + HEADER_OFFSET;
  const lView = getLView();
  const pipeInstance = load(lView, adjustedIndex);
  return isPure(lView, adjustedIndex) ? pureFunction1Internal(lView, getBindingRoot(), offset, pipeInstance.transform, v1, pipeInstance) : pipeInstance.transform(v1);
}
function ɵɵpipeBind2(index, slotOffset, v1, v2) {
  const adjustedIndex = index + HEADER_OFFSET;
  const lView = getLView();
  const pipeInstance = load(lView, adjustedIndex);
  return isPure(lView, adjustedIndex) ? pureFunction2Internal(lView, getBindingRoot(), slotOffset, pipeInstance.transform, v1, v2, pipeInstance) : pipeInstance.transform(v1, v2);
}
function ɵɵpipeBind3(index, slotOffset, v1, v2, v3) {
  const adjustedIndex = index + HEADER_OFFSET;
  const lView = getLView();
  const pipeInstance = load(lView, adjustedIndex);
  return isPure(lView, adjustedIndex) ? pureFunction3Internal(lView, getBindingRoot(), slotOffset, pipeInstance.transform, v1, v2, v3, pipeInstance) : pipeInstance.transform(v1, v2, v3);
}
function ɵɵpipeBind4(index, slotOffset, v1, v2, v3, v4) {
  const adjustedIndex = index + HEADER_OFFSET;
  const lView = getLView();
  const pipeInstance = load(lView, adjustedIndex);
  return isPure(lView, adjustedIndex) ? pureFunction4Internal(lView, getBindingRoot(), slotOffset, pipeInstance.transform, v1, v2, v3, v4, pipeInstance) : pipeInstance.transform(v1, v2, v3, v4);
}
function ɵɵpipeBindV(index, slotOffset, values) {
  const adjustedIndex = index + HEADER_OFFSET;
  const lView = getLView();
  const pipeInstance = load(lView, adjustedIndex);
  return isPure(lView, adjustedIndex) ? pureFunctionVInternal(lView, getBindingRoot(), slotOffset, pipeInstance.transform, values, pipeInstance) : pipeInstance.transform.apply(pipeInstance, values);
}
function isPure(lView, index) {
  return lView[TVIEW].data[index].pure;
}
function ɵɵtemplateRefExtractor(tNode, lView) {
  return createTemplateRef(tNode, lView);
}
function ɵɵgetComponentDepsFactory(type, rawImports) {
  return () => {
    try {
      return depsTracker.getComponentDependencies(type, rawImports).dependencies;
    } catch (e) {
      console.error(`Computing dependencies in local compilation mode for the component "${type.name}" failed with the exception:`, e);
      throw e;
    }
  };
}
function ɵsetClassDebugInfo(type, debugInfo) {
  const def = getComponentDef(type);
  if (def !== null) {
    def.debugInfo = debugInfo;
  }
}
var angularCoreEnv = /* @__PURE__ */ (() => ({
  "ɵɵattribute": ɵɵattribute,
  "ɵɵattributeInterpolate1": ɵɵattributeInterpolate1,
  "ɵɵattributeInterpolate2": ɵɵattributeInterpolate2,
  "ɵɵattributeInterpolate3": ɵɵattributeInterpolate3,
  "ɵɵattributeInterpolate4": ɵɵattributeInterpolate4,
  "ɵɵattributeInterpolate5": ɵɵattributeInterpolate5,
  "ɵɵattributeInterpolate6": ɵɵattributeInterpolate6,
  "ɵɵattributeInterpolate7": ɵɵattributeInterpolate7,
  "ɵɵattributeInterpolate8": ɵɵattributeInterpolate8,
  "ɵɵattributeInterpolateV": ɵɵattributeInterpolateV,
  "ɵɵdefineComponent": ɵɵdefineComponent,
  "ɵɵdefineDirective": ɵɵdefineDirective,
  "ɵɵdefineInjectable": ɵɵdefineInjectable,
  "ɵɵdefineInjector": ɵɵdefineInjector,
  "ɵɵdefineNgModule": ɵɵdefineNgModule,
  "ɵɵdefinePipe": ɵɵdefinePipe,
  "ɵɵdirectiveInject": ɵɵdirectiveInject,
  "ɵɵgetInheritedFactory": ɵɵgetInheritedFactory,
  "ɵɵinject": ɵɵinject,
  "ɵɵinjectAttribute": ɵɵinjectAttribute,
  "ɵɵinvalidFactory": ɵɵinvalidFactory,
  "ɵɵinvalidFactoryDep": ɵɵinvalidFactoryDep,
  "ɵɵtemplateRefExtractor": ɵɵtemplateRefExtractor,
  "ɵɵresetView": ɵɵresetView,
  "ɵɵHostDirectivesFeature": ɵɵHostDirectivesFeature,
  "ɵɵNgOnChangesFeature": ɵɵNgOnChangesFeature,
  "ɵɵProvidersFeature": ɵɵProvidersFeature,
  "ɵɵCopyDefinitionFeature": ɵɵCopyDefinitionFeature,
  "ɵɵInheritDefinitionFeature": ɵɵInheritDefinitionFeature,
  "ɵɵInputTransformsFeature": ɵɵInputTransformsFeature,
  "ɵɵStandaloneFeature": ɵɵStandaloneFeature,
  "ɵɵnextContext": ɵɵnextContext,
  "ɵɵnamespaceHTML": ɵɵnamespaceHTML,
  "ɵɵnamespaceMathML": ɵɵnamespaceMathML,
  "ɵɵnamespaceSVG": ɵɵnamespaceSVG,
  "ɵɵenableBindings": ɵɵenableBindings,
  "ɵɵdisableBindings": ɵɵdisableBindings,
  "ɵɵelementStart": ɵɵelementStart,
  "ɵɵelementEnd": ɵɵelementEnd,
  "ɵɵelement": ɵɵelement,
  "ɵɵelementContainerStart": ɵɵelementContainerStart,
  "ɵɵelementContainerEnd": ɵɵelementContainerEnd,
  "ɵɵelementContainer": ɵɵelementContainer,
  "ɵɵpureFunction0": ɵɵpureFunction0,
  "ɵɵpureFunction1": ɵɵpureFunction1,
  "ɵɵpureFunction2": ɵɵpureFunction2,
  "ɵɵpureFunction3": ɵɵpureFunction3,
  "ɵɵpureFunction4": ɵɵpureFunction4,
  "ɵɵpureFunction5": ɵɵpureFunction5,
  "ɵɵpureFunction6": ɵɵpureFunction6,
  "ɵɵpureFunction7": ɵɵpureFunction7,
  "ɵɵpureFunction8": ɵɵpureFunction8,
  "ɵɵpureFunctionV": ɵɵpureFunctionV,
  "ɵɵgetCurrentView": ɵɵgetCurrentView,
  "ɵɵrestoreView": ɵɵrestoreView,
  "ɵɵlistener": ɵɵlistener,
  "ɵɵprojection": ɵɵprojection,
  "ɵɵsyntheticHostProperty": ɵɵsyntheticHostProperty,
  "ɵɵsyntheticHostListener": ɵɵsyntheticHostListener,
  "ɵɵpipeBind1": ɵɵpipeBind1,
  "ɵɵpipeBind2": ɵɵpipeBind2,
  "ɵɵpipeBind3": ɵɵpipeBind3,
  "ɵɵpipeBind4": ɵɵpipeBind4,
  "ɵɵpipeBindV": ɵɵpipeBindV,
  "ɵɵprojectionDef": ɵɵprojectionDef,
  "ɵɵhostProperty": ɵɵhostProperty,
  "ɵɵproperty": ɵɵproperty,
  "ɵɵpropertyInterpolate": ɵɵpropertyInterpolate,
  "ɵɵpropertyInterpolate1": ɵɵpropertyInterpolate1,
  "ɵɵpropertyInterpolate2": ɵɵpropertyInterpolate2,
  "ɵɵpropertyInterpolate3": ɵɵpropertyInterpolate3,
  "ɵɵpropertyInterpolate4": ɵɵpropertyInterpolate4,
  "ɵɵpropertyInterpolate5": ɵɵpropertyInterpolate5,
  "ɵɵpropertyInterpolate6": ɵɵpropertyInterpolate6,
  "ɵɵpropertyInterpolate7": ɵɵpropertyInterpolate7,
  "ɵɵpropertyInterpolate8": ɵɵpropertyInterpolate8,
  "ɵɵpropertyInterpolateV": ɵɵpropertyInterpolateV,
  "ɵɵpipe": ɵɵpipe,
  "ɵɵqueryRefresh": ɵɵqueryRefresh,
  "ɵɵqueryAdvance": ɵɵqueryAdvance,
  "ɵɵviewQuery": ɵɵviewQuery,
  "ɵɵviewQuerySignal": ɵɵviewQuerySignal,
  "ɵɵloadQuery": ɵɵloadQuery,
  "ɵɵcontentQuery": ɵɵcontentQuery,
  "ɵɵcontentQuerySignal": ɵɵcontentQuerySignal,
  "ɵɵreference": ɵɵreference,
  "ɵɵclassMap": ɵɵclassMap,
  "ɵɵclassMapInterpolate1": ɵɵclassMapInterpolate1,
  "ɵɵclassMapInterpolate2": ɵɵclassMapInterpolate2,
  "ɵɵclassMapInterpolate3": ɵɵclassMapInterpolate3,
  "ɵɵclassMapInterpolate4": ɵɵclassMapInterpolate4,
  "ɵɵclassMapInterpolate5": ɵɵclassMapInterpolate5,
  "ɵɵclassMapInterpolate6": ɵɵclassMapInterpolate6,
  "ɵɵclassMapInterpolate7": ɵɵclassMapInterpolate7,
  "ɵɵclassMapInterpolate8": ɵɵclassMapInterpolate8,
  "ɵɵclassMapInterpolateV": ɵɵclassMapInterpolateV,
  "ɵɵstyleMap": ɵɵstyleMap,
  "ɵɵstyleMapInterpolate1": ɵɵstyleMapInterpolate1,
  "ɵɵstyleMapInterpolate2": ɵɵstyleMapInterpolate2,
  "ɵɵstyleMapInterpolate3": ɵɵstyleMapInterpolate3,
  "ɵɵstyleMapInterpolate4": ɵɵstyleMapInterpolate4,
  "ɵɵstyleMapInterpolate5": ɵɵstyleMapInterpolate5,
  "ɵɵstyleMapInterpolate6": ɵɵstyleMapInterpolate6,
  "ɵɵstyleMapInterpolate7": ɵɵstyleMapInterpolate7,
  "ɵɵstyleMapInterpolate8": ɵɵstyleMapInterpolate8,
  "ɵɵstyleMapInterpolateV": ɵɵstyleMapInterpolateV,
  "ɵɵstyleProp": ɵɵstyleProp,
  "ɵɵstylePropInterpolate1": ɵɵstylePropInterpolate1,
  "ɵɵstylePropInterpolate2": ɵɵstylePropInterpolate2,
  "ɵɵstylePropInterpolate3": ɵɵstylePropInterpolate3,
  "ɵɵstylePropInterpolate4": ɵɵstylePropInterpolate4,
  "ɵɵstylePropInterpolate5": ɵɵstylePropInterpolate5,
  "ɵɵstylePropInterpolate6": ɵɵstylePropInterpolate6,
  "ɵɵstylePropInterpolate7": ɵɵstylePropInterpolate7,
  "ɵɵstylePropInterpolate8": ɵɵstylePropInterpolate8,
  "ɵɵstylePropInterpolateV": ɵɵstylePropInterpolateV,
  "ɵɵclassProp": ɵɵclassProp,
  "ɵɵadvance": ɵɵadvance,
  "ɵɵtemplate": ɵɵtemplate,
  "ɵɵconditional": ɵɵconditional,
  "ɵɵdefer": ɵɵdefer,
  "ɵɵdeferWhen": ɵɵdeferWhen,
  "ɵɵdeferOnIdle": ɵɵdeferOnIdle,
  "ɵɵdeferOnImmediate": ɵɵdeferOnImmediate,
  "ɵɵdeferOnTimer": ɵɵdeferOnTimer,
  "ɵɵdeferOnHover": ɵɵdeferOnHover,
  "ɵɵdeferOnInteraction": ɵɵdeferOnInteraction,
  "ɵɵdeferOnViewport": ɵɵdeferOnViewport,
  "ɵɵdeferPrefetchWhen": ɵɵdeferPrefetchWhen,
  "ɵɵdeferPrefetchOnIdle": ɵɵdeferPrefetchOnIdle,
  "ɵɵdeferPrefetchOnImmediate": ɵɵdeferPrefetchOnImmediate,
  "ɵɵdeferPrefetchOnTimer": ɵɵdeferPrefetchOnTimer,
  "ɵɵdeferPrefetchOnHover": ɵɵdeferPrefetchOnHover,
  "ɵɵdeferPrefetchOnInteraction": ɵɵdeferPrefetchOnInteraction,
  "ɵɵdeferPrefetchOnViewport": ɵɵdeferPrefetchOnViewport,
  "ɵɵdeferEnableTimerScheduling": ɵɵdeferEnableTimerScheduling,
  "ɵɵrepeater": ɵɵrepeater,
  "ɵɵrepeaterCreate": ɵɵrepeaterCreate,
  "ɵɵrepeaterTrackByIndex": ɵɵrepeaterTrackByIndex,
  "ɵɵrepeaterTrackByIdentity": ɵɵrepeaterTrackByIdentity,
  "ɵɵcomponentInstance": ɵɵcomponentInstance,
  "ɵɵtext": ɵɵtext,
  "ɵɵtextInterpolate": ɵɵtextInterpolate,
  "ɵɵtextInterpolate1": ɵɵtextInterpolate1,
  "ɵɵtextInterpolate2": ɵɵtextInterpolate2,
  "ɵɵtextInterpolate3": ɵɵtextInterpolate3,
  "ɵɵtextInterpolate4": ɵɵtextInterpolate4,
  "ɵɵtextInterpolate5": ɵɵtextInterpolate5,
  "ɵɵtextInterpolate6": ɵɵtextInterpolate6,
  "ɵɵtextInterpolate7": ɵɵtextInterpolate7,
  "ɵɵtextInterpolate8": ɵɵtextInterpolate8,
  "ɵɵtextInterpolateV": ɵɵtextInterpolateV,
  "ɵɵi18n": ɵɵi18n,
  "ɵɵi18nAttributes": ɵɵi18nAttributes,
  "ɵɵi18nExp": ɵɵi18nExp,
  "ɵɵi18nStart": ɵɵi18nStart,
  "ɵɵi18nEnd": ɵɵi18nEnd,
  "ɵɵi18nApply": ɵɵi18nApply,
  "ɵɵi18nPostprocess": ɵɵi18nPostprocess,
  "ɵɵresolveWindow": ɵɵresolveWindow,
  "ɵɵresolveDocument": ɵɵresolveDocument,
  "ɵɵresolveBody": ɵɵresolveBody,
  "ɵɵsetComponentScope": ɵɵsetComponentScope,
  "ɵɵsetNgModuleScope": ɵɵsetNgModuleScope,
  "ɵɵregisterNgModuleType": registerNgModuleType,
  "ɵɵgetComponentDepsFactory": ɵɵgetComponentDepsFactory,
  "ɵsetClassDebugInfo": ɵsetClassDebugInfo,
  "ɵɵdeclareLet": ɵɵdeclareLet,
  "ɵɵstoreLet": ɵɵstoreLet,
  "ɵɵreadContextLet": ɵɵreadContextLet,
  "ɵɵsanitizeHtml": ɵɵsanitizeHtml,
  "ɵɵsanitizeStyle": ɵɵsanitizeStyle,
  "ɵɵsanitizeResourceUrl": ɵɵsanitizeResourceUrl,
  "ɵɵsanitizeScript": ɵɵsanitizeScript,
  "ɵɵsanitizeUrl": ɵɵsanitizeUrl,
  "ɵɵsanitizeUrlOrResourceUrl": ɵɵsanitizeUrlOrResourceUrl,
  "ɵɵtrustConstantHtml": ɵɵtrustConstantHtml,
  "ɵɵtrustConstantResourceUrl": ɵɵtrustConstantResourceUrl,
  "ɵɵvalidateIframeAttribute": ɵɵvalidateIframeAttribute,
  "forwardRef": forwardRef,
  "resolveForwardRef": resolveForwardRef,
  "ɵɵtwoWayProperty": ɵɵtwoWayProperty,
  "ɵɵtwoWayBindingSet": ɵɵtwoWayBindingSet,
  "ɵɵtwoWayListener": ɵɵtwoWayListener
}))();
var jitOptions = null;
function setJitOptions(options) {
  if (jitOptions !== null) {
    if (options.defaultEncapsulation !== jitOptions.defaultEncapsulation) {
      ngDevMode && console.error("Provided value for `defaultEncapsulation` can not be changed once it has been set.");
      return;
    }
    if (options.preserveWhitespaces !== jitOptions.preserveWhitespaces) {
      ngDevMode && console.error("Provided value for `preserveWhitespaces` can not be changed once it has been set.");
      return;
    }
  }
  jitOptions = options;
}
function getJitOptions() {
  return jitOptions;
}
function patchModuleCompilation() {
}
var moduleQueue = [];
function enqueueModuleForDelayedScoping(moduleType, ngModule) {
  moduleQueue.push({
    moduleType,
    ngModule
  });
}
var flushingModuleQueue = false;
function flushModuleScopingQueueAsMuchAsPossible() {
  if (!flushingModuleQueue) {
    flushingModuleQueue = true;
    try {
      for (let i = moduleQueue.length - 1; i >= 0; i--) {
        const {
          moduleType,
          ngModule
        } = moduleQueue[i];
        if (ngModule.declarations && ngModule.declarations.every(isResolvedDeclaration)) {
          moduleQueue.splice(i, 1);
          setScopeOnDeclaredComponents(moduleType, ngModule);
        }
      }
    } finally {
      flushingModuleQueue = false;
    }
  }
}
function isResolvedDeclaration(declaration) {
  if (Array.isArray(declaration)) {
    return declaration.every(isResolvedDeclaration);
  }
  return !!resolveForwardRef(declaration);
}
function compileNgModule(moduleType, ngModule = {}) {
  patchModuleCompilation();
  compileNgModuleDefs(moduleType, ngModule);
  if (ngModule.id !== void 0) {
    registerNgModuleType(moduleType, ngModule.id);
  }
  enqueueModuleForDelayedScoping(moduleType, ngModule);
}
function compileNgModuleDefs(moduleType, ngModule, allowDuplicateDeclarationsInRoot = false) {
  ngDevMode && assertDefined(moduleType, "Required value moduleType");
  ngDevMode && assertDefined(ngModule, "Required value ngModule");
  const declarations = flatten(ngModule.declarations || EMPTY_ARRAY);
  let ngModuleDef = null;
  Object.defineProperty(moduleType, NG_MOD_DEF, {
    configurable: true,
    get: () => {
      if (ngModuleDef === null) {
        if (ngDevMode && ngModule.imports && ngModule.imports.indexOf(moduleType) > -1) {
          throw new Error(`'${stringifyForError(moduleType)}' module can't import itself`);
        }
        const compiler = getCompilerFacade({
          usage: 0,
          kind: "NgModule",
          type: moduleType
        });
        ngModuleDef = compiler.compileNgModule(angularCoreEnv, `ng:///${moduleType.name}/ɵmod.js`, {
          type: moduleType,
          bootstrap: flatten(ngModule.bootstrap || EMPTY_ARRAY).map(resolveForwardRef),
          declarations: declarations.map(resolveForwardRef),
          imports: flatten(ngModule.imports || EMPTY_ARRAY).map(resolveForwardRef).map(expandModuleWithProviders),
          exports: flatten(ngModule.exports || EMPTY_ARRAY).map(resolveForwardRef).map(expandModuleWithProviders),
          schemas: ngModule.schemas ? flatten(ngModule.schemas) : null,
          id: ngModule.id || null
        });
        if (!ngModuleDef.schemas) {
          ngModuleDef.schemas = [];
        }
      }
      return ngModuleDef;
    }
  });
  let ngFactoryDef = null;
  Object.defineProperty(moduleType, NG_FACTORY_DEF, {
    get: () => {
      if (ngFactoryDef === null) {
        const compiler = getCompilerFacade({
          usage: 0,
          kind: "NgModule",
          type: moduleType
        });
        ngFactoryDef = compiler.compileFactory(angularCoreEnv, `ng:///${moduleType.name}/ɵfac.js`, {
          name: moduleType.name,
          type: moduleType,
          deps: reflectDependencies(moduleType),
          target: compiler.FactoryTarget.NgModule,
          typeArgumentCount: 0
        });
      }
      return ngFactoryDef;
    },
    // Make the property configurable in dev mode to allow overriding in tests
    configurable: !!ngDevMode
  });
  let ngInjectorDef = null;
  Object.defineProperty(moduleType, NG_INJ_DEF, {
    get: () => {
      if (ngInjectorDef === null) {
        ngDevMode && verifySemanticsOfNgModuleDef(moduleType, allowDuplicateDeclarationsInRoot);
        const meta = {
          name: moduleType.name,
          type: moduleType,
          providers: ngModule.providers || EMPTY_ARRAY,
          imports: [(ngModule.imports || EMPTY_ARRAY).map(resolveForwardRef), (ngModule.exports || EMPTY_ARRAY).map(resolveForwardRef)]
        };
        const compiler = getCompilerFacade({
          usage: 0,
          kind: "NgModule",
          type: moduleType
        });
        ngInjectorDef = compiler.compileInjector(angularCoreEnv, `ng:///${moduleType.name}/ɵinj.js`, meta);
      }
      return ngInjectorDef;
    },
    // Make the property configurable in dev mode to allow overriding in tests
    configurable: !!ngDevMode
  });
}
function generateStandaloneInDeclarationsError(type, location2) {
  const prefix = `Unexpected "${stringifyForError(type)}" found in the "declarations" array of the`;
  const suffix = `"${stringifyForError(type)}" is marked as standalone and can't be declared in any NgModule - did you intend to import it instead (by adding it to the "imports" array)?`;
  return `${prefix} ${location2}, ${suffix}`;
}
function verifySemanticsOfNgModuleDef(moduleType, allowDuplicateDeclarationsInRoot, importingModule) {
  if (verifiedNgModule.get(moduleType)) return;
  if (isStandalone(moduleType)) return;
  verifiedNgModule.set(moduleType, true);
  moduleType = resolveForwardRef(moduleType);
  let ngModuleDef;
  if (importingModule) {
    ngModuleDef = getNgModuleDef(moduleType);
    if (!ngModuleDef) {
      throw new Error(`Unexpected value '${moduleType.name}' imported by the module '${importingModule.name}'. Please add an @NgModule annotation.`);
    }
  } else {
    ngModuleDef = getNgModuleDef(moduleType, true);
  }
  const errors = [];
  const declarations = maybeUnwrapFn(ngModuleDef.declarations);
  const imports = maybeUnwrapFn(ngModuleDef.imports);
  flatten(imports).map(unwrapModuleWithProvidersImports).forEach((modOrStandaloneCmpt) => {
    verifySemanticsOfNgModuleImport(modOrStandaloneCmpt, moduleType);
    verifySemanticsOfNgModuleDef(modOrStandaloneCmpt, false, moduleType);
  });
  const exports = maybeUnwrapFn(ngModuleDef.exports);
  declarations.forEach(verifyDeclarationsHaveDefinitions);
  declarations.forEach(verifyDirectivesHaveSelector);
  declarations.forEach((declarationType) => verifyNotStandalone(declarationType, moduleType));
  const combinedDeclarations = [...declarations.map(resolveForwardRef), ...flatten(imports.map(computeCombinedExports)).map(resolveForwardRef)];
  exports.forEach(verifyExportsAreDeclaredOrReExported);
  declarations.forEach((decl) => verifyDeclarationIsUnique(decl, allowDuplicateDeclarationsInRoot));
  const ngModule = getAnnotation(moduleType, "NgModule");
  if (ngModule) {
    ngModule.imports && flatten(ngModule.imports).map(unwrapModuleWithProvidersImports).forEach((mod) => {
      verifySemanticsOfNgModuleImport(mod, moduleType);
      verifySemanticsOfNgModuleDef(mod, false, moduleType);
    });
    ngModule.bootstrap && deepForEach(ngModule.bootstrap, verifyCorrectBootstrapType);
    ngModule.bootstrap && deepForEach(ngModule.bootstrap, verifyComponentIsPartOfNgModule);
  }
  if (errors.length) {
    throw new Error(errors.join("\n"));
  }
  function verifyDeclarationsHaveDefinitions(type) {
    type = resolveForwardRef(type);
    const def = getComponentDef(type) || getDirectiveDef(type) || getPipeDef$1(type);
    if (!def) {
      errors.push(`Unexpected value '${stringifyForError(type)}' declared by the module '${stringifyForError(moduleType)}'. Please add a @Pipe/@Directive/@Component annotation.`);
    }
  }
  function verifyDirectivesHaveSelector(type) {
    type = resolveForwardRef(type);
    const def = getDirectiveDef(type);
    if (!getComponentDef(type) && def && def.selectors.length == 0) {
      errors.push(`Directive ${stringifyForError(type)} has no selector, please add it!`);
    }
  }
  function verifyNotStandalone(type, moduleType2) {
    type = resolveForwardRef(type);
    const def = getComponentDef(type) || getDirectiveDef(type) || getPipeDef$1(type);
    if (def?.standalone) {
      const location2 = `"${stringifyForError(moduleType2)}" NgModule`;
      errors.push(generateStandaloneInDeclarationsError(type, location2));
    }
  }
  function verifyExportsAreDeclaredOrReExported(type) {
    type = resolveForwardRef(type);
    const kind = getComponentDef(type) && "component" || getDirectiveDef(type) && "directive" || getPipeDef$1(type) && "pipe";
    if (kind) {
      if (combinedDeclarations.lastIndexOf(type) === -1) {
        errors.push(`Can't export ${kind} ${stringifyForError(type)} from ${stringifyForError(moduleType)} as it was neither declared nor imported!`);
      }
    }
  }
  function verifyDeclarationIsUnique(type, suppressErrors) {
    type = resolveForwardRef(type);
    const existingModule = ownerNgModule.get(type);
    if (existingModule && existingModule !== moduleType) {
      if (!suppressErrors) {
        const modules2 = [existingModule, moduleType].map(stringifyForError).sort();
        errors.push(`Type ${stringifyForError(type)} is part of the declarations of 2 modules: ${modules2[0]} and ${modules2[1]}! Please consider moving ${stringifyForError(type)} to a higher module that imports ${modules2[0]} and ${modules2[1]}. You can also create a new NgModule that exports and includes ${stringifyForError(type)} then import that NgModule in ${modules2[0]} and ${modules2[1]}.`);
      }
    } else {
      ownerNgModule.set(type, moduleType);
    }
  }
  function verifyComponentIsPartOfNgModule(type) {
    type = resolveForwardRef(type);
    const existingModule = ownerNgModule.get(type);
    if (!existingModule && !isStandalone(type)) {
      errors.push(`Component ${stringifyForError(type)} is not part of any NgModule or the module has not been imported into your module.`);
    }
  }
  function verifyCorrectBootstrapType(type) {
    type = resolveForwardRef(type);
    if (!getComponentDef(type)) {
      errors.push(`${stringifyForError(type)} cannot be used as an entry component.`);
    }
    if (isStandalone(type)) {
      errors.push(`The \`${stringifyForError(type)}\` class is a standalone component, which can not be used in the \`@NgModule.bootstrap\` array. Use the \`bootstrapApplication\` function for bootstrap instead.`);
    }
  }
  function verifySemanticsOfNgModuleImport(type, importingModule2) {
    type = resolveForwardRef(type);
    const directiveDef = getComponentDef(type) || getDirectiveDef(type);
    if (directiveDef !== null && !directiveDef.standalone) {
      throw new Error(`Unexpected directive '${type.name}' imported by the module '${importingModule2.name}'. Please add an @NgModule annotation.`);
    }
    const pipeDef = getPipeDef$1(type);
    if (pipeDef !== null && !pipeDef.standalone) {
      throw new Error(`Unexpected pipe '${type.name}' imported by the module '${importingModule2.name}'. Please add an @NgModule annotation.`);
    }
  }
}
function unwrapModuleWithProvidersImports(typeOrWithProviders) {
  typeOrWithProviders = resolveForwardRef(typeOrWithProviders);
  return typeOrWithProviders.ngModule || typeOrWithProviders;
}
function getAnnotation(type, name) {
  let annotation = null;
  collect(type.__annotations__);
  collect(type.decorators);
  return annotation;
  function collect(annotations) {
    if (annotations) {
      annotations.forEach(readAnnotation);
    }
  }
  function readAnnotation(decorator) {
    if (!annotation) {
      const proto = Object.getPrototypeOf(decorator);
      if (proto.ngMetadataName == name) {
        annotation = decorator;
      } else if (decorator.type) {
        const proto2 = Object.getPrototypeOf(decorator.type);
        if (proto2.ngMetadataName == name) {
          annotation = decorator.args[0];
        }
      }
    }
  }
}
var ownerNgModule = /* @__PURE__ */ new WeakMap();
var verifiedNgModule = /* @__PURE__ */ new WeakMap();
function computeCombinedExports(type) {
  type = resolveForwardRef(type);
  const ngModuleDef = getNgModuleDef(type);
  if (ngModuleDef === null) {
    return [type];
  }
  return flatten(maybeUnwrapFn(ngModuleDef.exports).map((type2) => {
    const ngModuleDef2 = getNgModuleDef(type2);
    if (ngModuleDef2) {
      verifySemanticsOfNgModuleDef(type2, false);
      return computeCombinedExports(type2);
    } else {
      return type2;
    }
  }));
}
function setScopeOnDeclaredComponents(moduleType, ngModule) {
  const declarations = flatten(ngModule.declarations || EMPTY_ARRAY);
  const transitiveScopes = transitiveScopesFor(moduleType);
  declarations.forEach((declaration) => {
    declaration = resolveForwardRef(declaration);
    if (declaration.hasOwnProperty(NG_COMP_DEF)) {
      const component = declaration;
      const componentDef = getComponentDef(component);
      patchComponentDefWithScope(componentDef, transitiveScopes);
    } else if (!declaration.hasOwnProperty(NG_DIR_DEF) && !declaration.hasOwnProperty(NG_PIPE_DEF)) {
      declaration.ngSelectorScope = moduleType;
    }
  });
}
function patchComponentDefWithScope(componentDef, transitiveScopes) {
  componentDef.directiveDefs = () => Array.from(transitiveScopes.compilation.directives).map((dir) => dir.hasOwnProperty(NG_COMP_DEF) ? getComponentDef(dir) : getDirectiveDef(dir)).filter((def) => !!def);
  componentDef.pipeDefs = () => Array.from(transitiveScopes.compilation.pipes).map((pipe) => getPipeDef$1(pipe));
  componentDef.schemas = transitiveScopes.schemas;
  componentDef.tView = null;
}
function transitiveScopesFor(type) {
  if (isNgModule(type)) {
    if (USE_RUNTIME_DEPS_TRACKER_FOR_JIT) {
      const scope = depsTracker.getNgModuleScope(type);
      const def = getNgModuleDef(type, true);
      return __spreadValues({
        schemas: def.schemas || null
      }, scope);
    } else {
      return transitiveScopesForNgModule(type);
    }
  } else if (isStandalone(type)) {
    const directiveDef = getComponentDef(type) || getDirectiveDef(type);
    if (directiveDef !== null) {
      return {
        schemas: null,
        compilation: {
          directives: /* @__PURE__ */ new Set(),
          pipes: /* @__PURE__ */ new Set()
        },
        exported: {
          directives: /* @__PURE__ */ new Set([type]),
          pipes: /* @__PURE__ */ new Set()
        }
      };
    }
    const pipeDef = getPipeDef$1(type);
    if (pipeDef !== null) {
      return {
        schemas: null,
        compilation: {
          directives: /* @__PURE__ */ new Set(),
          pipes: /* @__PURE__ */ new Set()
        },
        exported: {
          directives: /* @__PURE__ */ new Set(),
          pipes: /* @__PURE__ */ new Set([type])
        }
      };
    }
  }
  throw new Error(`${type.name} does not have a module def (ɵmod property)`);
}
function transitiveScopesForNgModule(moduleType) {
  const def = getNgModuleDef(moduleType, true);
  if (def.transitiveCompileScopes !== null) {
    return def.transitiveCompileScopes;
  }
  const scopes = {
    schemas: def.schemas || null,
    compilation: {
      directives: /* @__PURE__ */ new Set(),
      pipes: /* @__PURE__ */ new Set()
    },
    exported: {
      directives: /* @__PURE__ */ new Set(),
      pipes: /* @__PURE__ */ new Set()
    }
  };
  maybeUnwrapFn(def.imports).forEach((imported) => {
    const importedScope = transitiveScopesFor(imported);
    importedScope.exported.directives.forEach((entry) => scopes.compilation.directives.add(entry));
    importedScope.exported.pipes.forEach((entry) => scopes.compilation.pipes.add(entry));
  });
  maybeUnwrapFn(def.declarations).forEach((declared) => {
    const declaredWithDefs = declared;
    if (getPipeDef$1(declaredWithDefs)) {
      scopes.compilation.pipes.add(declared);
    } else {
      scopes.compilation.directives.add(declared);
    }
  });
  maybeUnwrapFn(def.exports).forEach((exported) => {
    const exportedType = exported;
    if (isNgModule(exportedType)) {
      const exportedScope = transitiveScopesFor(exportedType);
      exportedScope.exported.directives.forEach((entry) => {
        scopes.compilation.directives.add(entry);
        scopes.exported.directives.add(entry);
      });
      exportedScope.exported.pipes.forEach((entry) => {
        scopes.compilation.pipes.add(entry);
        scopes.exported.pipes.add(entry);
      });
    } else if (getPipeDef$1(exportedType)) {
      scopes.exported.pipes.add(exportedType);
    } else {
      scopes.exported.directives.add(exportedType);
    }
  });
  def.transitiveCompileScopes = scopes;
  return scopes;
}
function expandModuleWithProviders(value) {
  if (isModuleWithProviders(value)) {
    return value.ngModule;
  }
  return value;
}
var compilationDepth = 0;
function compileComponent(type, metadata) {
  (typeof ngDevMode === "undefined" || ngDevMode) && initNgDevMode();
  let ngComponentDef = null;
  maybeQueueResolutionOfComponentResources(type, metadata);
  addDirectiveFactoryDef(type, metadata);
  Object.defineProperty(type, NG_COMP_DEF, {
    get: () => {
      if (ngComponentDef === null) {
        const compiler = getCompilerFacade({
          usage: 0,
          kind: "component",
          type
        });
        if (componentNeedsResolution(metadata)) {
          const error = [`Component '${type.name}' is not resolved:`];
          if (metadata.templateUrl) {
            error.push(` - templateUrl: ${metadata.templateUrl}`);
          }
          if (metadata.styleUrls && metadata.styleUrls.length) {
            error.push(` - styleUrls: ${JSON.stringify(metadata.styleUrls)}`);
          }
          if (metadata.styleUrl) {
            error.push(` - styleUrl: ${metadata.styleUrl}`);
          }
          error.push(`Did you run and wait for 'resolveComponentResources()'?`);
          throw new Error(error.join("\n"));
        }
        const options = getJitOptions();
        let preserveWhitespaces = metadata.preserveWhitespaces;
        if (preserveWhitespaces === void 0) {
          if (options !== null && options.preserveWhitespaces !== void 0) {
            preserveWhitespaces = options.preserveWhitespaces;
          } else {
            preserveWhitespaces = false;
          }
        }
        let encapsulation = metadata.encapsulation;
        if (encapsulation === void 0) {
          if (options !== null && options.defaultEncapsulation !== void 0) {
            encapsulation = options.defaultEncapsulation;
          } else {
            encapsulation = ViewEncapsulation$1.Emulated;
          }
        }
        const templateUrl = metadata.templateUrl || `ng:///${type.name}/template.html`;
        const meta = __spreadProps(__spreadValues({}, directiveMetadata(type, metadata)), {
          typeSourceSpan: compiler.createParseSourceSpan("Component", type.name, templateUrl),
          template: metadata.template || "",
          preserveWhitespaces,
          styles: typeof metadata.styles === "string" ? [metadata.styles] : metadata.styles || EMPTY_ARRAY,
          animations: metadata.animations,
          // JIT components are always compiled against an empty set of `declarations`. Instead, the
          // `directiveDefs` and `pipeDefs` are updated at a later point:
          //  * for NgModule-based components, they're set when the NgModule which declares the
          //    component resolves in the module scoping queue
          //  * for standalone components, they're set just below, after `compileComponent`.
          declarations: [],
          changeDetection: metadata.changeDetection,
          encapsulation,
          interpolation: metadata.interpolation,
          viewProviders: metadata.viewProviders || null
        });
        compilationDepth++;
        try {
          if (meta.usesInheritance) {
            addDirectiveDefToUndecoratedParents(type);
          }
          ngComponentDef = compiler.compileComponent(angularCoreEnv, templateUrl, meta);
          if (metadata.standalone) {
            const imports = flatten(metadata.imports || EMPTY_ARRAY);
            const {
              directiveDefs,
              pipeDefs
            } = getStandaloneDefFunctions(type, imports);
            ngComponentDef.directiveDefs = directiveDefs;
            ngComponentDef.pipeDefs = pipeDefs;
            ngComponentDef.dependencies = () => imports.map(resolveForwardRef);
          }
        } finally {
          compilationDepth--;
        }
        if (compilationDepth === 0) {
          flushModuleScopingQueueAsMuchAsPossible();
        }
        if (hasSelectorScope(type)) {
          const scopes = transitiveScopesFor(type.ngSelectorScope);
          patchComponentDefWithScope(ngComponentDef, scopes);
        }
        if (metadata.schemas) {
          if (metadata.standalone) {
            ngComponentDef.schemas = metadata.schemas;
          } else {
            throw new Error(`The 'schemas' was specified for the ${stringifyForError(type)} but is only valid on a component that is standalone.`);
          }
        } else if (metadata.standalone) {
          ngComponentDef.schemas = [];
        }
      }
      return ngComponentDef;
    },
    // Make the property configurable in dev mode to allow overriding in tests
    configurable: !!ngDevMode
  });
}
function getStandaloneDefFunctions(type, imports) {
  let cachedDirectiveDefs = null;
  let cachedPipeDefs = null;
  const directiveDefs = () => {
    if (!USE_RUNTIME_DEPS_TRACKER_FOR_JIT) {
      if (cachedDirectiveDefs === null) {
        cachedDirectiveDefs = [getComponentDef(type)];
        const seen = /* @__PURE__ */ new Set([type]);
        for (const rawDep of imports) {
          ngDevMode && verifyStandaloneImport(rawDep, type);
          const dep = resolveForwardRef(rawDep);
          if (seen.has(dep)) {
            continue;
          }
          seen.add(dep);
          if (!!getNgModuleDef(dep)) {
            const scope = transitiveScopesFor(dep);
            for (const dir of scope.exported.directives) {
              const def = getComponentDef(dir) || getDirectiveDef(dir);
              if (def && !seen.has(dir)) {
                seen.add(dir);
                cachedDirectiveDefs.push(def);
              }
            }
          } else {
            const def = getComponentDef(dep) || getDirectiveDef(dep);
            if (def) {
              cachedDirectiveDefs.push(def);
            }
          }
        }
      }
      return cachedDirectiveDefs;
    } else {
      if (ngDevMode) {
        for (const rawDep of imports) {
          verifyStandaloneImport(rawDep, type);
        }
      }
      if (!isComponent(type)) {
        return [];
      }
      const scope = depsTracker.getStandaloneComponentScope(type, imports);
      return [...scope.compilation.directives].map((p) => getComponentDef(p) || getDirectiveDef(p)).filter((d) => d !== null);
    }
  };
  const pipeDefs = () => {
    if (!USE_RUNTIME_DEPS_TRACKER_FOR_JIT) {
      if (cachedPipeDefs === null) {
        cachedPipeDefs = [];
        const seen = /* @__PURE__ */ new Set();
        for (const rawDep of imports) {
          const dep = resolveForwardRef(rawDep);
          if (seen.has(dep)) {
            continue;
          }
          seen.add(dep);
          if (!!getNgModuleDef(dep)) {
            const scope = transitiveScopesFor(dep);
            for (const pipe of scope.exported.pipes) {
              const def = getPipeDef$1(pipe);
              if (def && !seen.has(pipe)) {
                seen.add(pipe);
                cachedPipeDefs.push(def);
              }
            }
          } else {
            const def = getPipeDef$1(dep);
            if (def) {
              cachedPipeDefs.push(def);
            }
          }
        }
      }
      return cachedPipeDefs;
    } else {
      if (ngDevMode) {
        for (const rawDep of imports) {
          verifyStandaloneImport(rawDep, type);
        }
      }
      if (!isComponent(type)) {
        return [];
      }
      const scope = depsTracker.getStandaloneComponentScope(type, imports);
      return [...scope.compilation.pipes].map((p) => getPipeDef$1(p)).filter((d) => d !== null);
    }
  };
  return {
    directiveDefs,
    pipeDefs
  };
}
function hasSelectorScope(component) {
  return component.ngSelectorScope !== void 0;
}
function compileDirective(type, directive) {
  let ngDirectiveDef = null;
  addDirectiveFactoryDef(type, directive || {});
  Object.defineProperty(type, NG_DIR_DEF, {
    get: () => {
      if (ngDirectiveDef === null) {
        const meta = getDirectiveMetadata(type, directive || {});
        const compiler = getCompilerFacade({
          usage: 0,
          kind: "directive",
          type
        });
        ngDirectiveDef = compiler.compileDirective(angularCoreEnv, meta.sourceMapUrl, meta.metadata);
      }
      return ngDirectiveDef;
    },
    // Make the property configurable in dev mode to allow overriding in tests
    configurable: !!ngDevMode
  });
}
function getDirectiveMetadata(type, metadata) {
  const name = type && type.name;
  const sourceMapUrl = `ng:///${name}/ɵdir.js`;
  const compiler = getCompilerFacade({
    usage: 0,
    kind: "directive",
    type
  });
  const facade = directiveMetadata(type, metadata);
  facade.typeSourceSpan = compiler.createParseSourceSpan("Directive", name, sourceMapUrl);
  if (facade.usesInheritance) {
    addDirectiveDefToUndecoratedParents(type);
  }
  return {
    metadata: facade,
    sourceMapUrl
  };
}
function addDirectiveFactoryDef(type, metadata) {
  let ngFactoryDef = null;
  Object.defineProperty(type, NG_FACTORY_DEF, {
    get: () => {
      if (ngFactoryDef === null) {
        const meta = getDirectiveMetadata(type, metadata);
        const compiler = getCompilerFacade({
          usage: 0,
          kind: "directive",
          type
        });
        ngFactoryDef = compiler.compileFactory(angularCoreEnv, `ng:///${type.name}/ɵfac.js`, {
          name: meta.metadata.name,
          type: meta.metadata.type,
          typeArgumentCount: 0,
          deps: reflectDependencies(type),
          target: compiler.FactoryTarget.Directive
        });
      }
      return ngFactoryDef;
    },
    // Make the property configurable in dev mode to allow overriding in tests
    configurable: !!ngDevMode
  });
}
function extendsDirectlyFromObject(type) {
  return Object.getPrototypeOf(type.prototype) === Object.prototype;
}
function directiveMetadata(type, metadata) {
  const reflect = getReflect();
  const propMetadata = reflect.ownPropMetadata(type);
  return {
    name: type.name,
    type,
    selector: metadata.selector !== void 0 ? metadata.selector : null,
    host: metadata.host || EMPTY_OBJ,
    propMetadata,
    inputs: metadata.inputs || EMPTY_ARRAY,
    outputs: metadata.outputs || EMPTY_ARRAY,
    queries: extractQueriesMetadata(type, propMetadata, isContentQuery),
    lifecycle: {
      usesOnChanges: reflect.hasLifecycleHook(type, "ngOnChanges")
    },
    typeSourceSpan: null,
    usesInheritance: !extendsDirectlyFromObject(type),
    exportAs: extractExportAs(metadata.exportAs),
    providers: metadata.providers || null,
    viewQueries: extractQueriesMetadata(type, propMetadata, isViewQuery),
    isStandalone: !!metadata.standalone,
    isSignal: !!metadata.signals,
    hostDirectives: metadata.hostDirectives?.map((directive) => typeof directive === "function" ? {
      directive
    } : directive) || null
  };
}
function addDirectiveDefToUndecoratedParents(type) {
  const objPrototype = Object.prototype;
  let parent = Object.getPrototypeOf(type.prototype).constructor;
  while (parent && parent !== objPrototype) {
    if (!getDirectiveDef(parent) && !getComponentDef(parent) && shouldAddAbstractDirective(parent)) {
      compileDirective(parent, null);
    }
    parent = Object.getPrototypeOf(parent);
  }
}
function convertToR3QueryPredicate(selector) {
  return typeof selector === "string" ? splitByComma(selector) : resolveForwardRef(selector);
}
function convertToR3QueryMetadata(propertyName, ann) {
  return {
    propertyName,
    predicate: convertToR3QueryPredicate(ann.selector),
    descendants: ann.descendants,
    first: ann.first,
    read: ann.read ? ann.read : null,
    static: !!ann.static,
    emitDistinctChangesOnly: !!ann.emitDistinctChangesOnly,
    isSignal: !!ann.isSignal
  };
}
function extractQueriesMetadata(type, propMetadata, isQueryAnn) {
  const queriesMeta = [];
  for (const field in propMetadata) {
    if (propMetadata.hasOwnProperty(field)) {
      const annotations = propMetadata[field];
      annotations.forEach((ann) => {
        if (isQueryAnn(ann)) {
          if (!ann.selector) {
            throw new Error(`Can't construct a query for the property "${field}" of "${stringifyForError(type)}" since the query selector wasn't defined.`);
          }
          if (annotations.some(isInputAnnotation)) {
            throw new Error(`Cannot combine @Input decorators with query decorators`);
          }
          queriesMeta.push(convertToR3QueryMetadata(field, ann));
        }
      });
    }
  }
  return queriesMeta;
}
function extractExportAs(exportAs) {
  return exportAs === void 0 ? null : splitByComma(exportAs);
}
function isContentQuery(value) {
  const name = value.ngMetadataName;
  return name === "ContentChild" || name === "ContentChildren";
}
function isViewQuery(value) {
  const name = value.ngMetadataName;
  return name === "ViewChild" || name === "ViewChildren";
}
function isInputAnnotation(value) {
  return value.ngMetadataName === "Input";
}
function splitByComma(value) {
  return value.split(",").map((piece) => piece.trim());
}
var LIFECYCLE_HOOKS = ["ngOnChanges", "ngOnInit", "ngOnDestroy", "ngDoCheck", "ngAfterViewInit", "ngAfterViewChecked", "ngAfterContentInit", "ngAfterContentChecked"];
function shouldAddAbstractDirective(type) {
  const reflect = getReflect();
  if (LIFECYCLE_HOOKS.some((hookName) => reflect.hasLifecycleHook(type, hookName))) {
    return true;
  }
  const propMetadata = reflect.propMetadata(type);
  for (const field in propMetadata) {
    const annotations = propMetadata[field];
    for (let i = 0; i < annotations.length; i++) {
      const current = annotations[i];
      const metadataName = current.ngMetadataName;
      if (isInputAnnotation(current) || isContentQuery(current) || isViewQuery(current) || metadataName === "Output" || metadataName === "HostBinding" || metadataName === "HostListener") {
        return true;
      }
    }
  }
  return false;
}
function compilePipe(type, meta) {
  let ngPipeDef = null;
  let ngFactoryDef = null;
  Object.defineProperty(type, NG_FACTORY_DEF, {
    get: () => {
      if (ngFactoryDef === null) {
        const metadata = getPipeMetadata(type, meta);
        const compiler = getCompilerFacade({
          usage: 0,
          kind: "pipe",
          type: metadata.type
        });
        ngFactoryDef = compiler.compileFactory(angularCoreEnv, `ng:///${metadata.name}/ɵfac.js`, {
          name: metadata.name,
          type: metadata.type,
          typeArgumentCount: 0,
          deps: reflectDependencies(type),
          target: compiler.FactoryTarget.Pipe
        });
      }
      return ngFactoryDef;
    },
    // Make the property configurable in dev mode to allow overriding in tests
    configurable: !!ngDevMode
  });
  Object.defineProperty(type, NG_PIPE_DEF, {
    get: () => {
      if (ngPipeDef === null) {
        const metadata = getPipeMetadata(type, meta);
        const compiler = getCompilerFacade({
          usage: 0,
          kind: "pipe",
          type: metadata.type
        });
        ngPipeDef = compiler.compilePipe(angularCoreEnv, `ng:///${metadata.name}/ɵpipe.js`, metadata);
      }
      return ngPipeDef;
    },
    // Make the property configurable in dev mode to allow overriding in tests
    configurable: !!ngDevMode
  });
}
function getPipeMetadata(type, meta) {
  return {
    type,
    name: type.name,
    pipeName: meta.name,
    pure: meta.pure !== void 0 ? meta.pure : true,
    isStandalone: !!meta.standalone
  };
}
var Directive = makeDecorator("Directive", (dir = {}) => dir, void 0, void 0, (type, meta) => compileDirective(type, meta));
var Component = makeDecorator("Component", (c = {}) => __spreadValues({
  changeDetection: ChangeDetectionStrategy.Default
}, c), Directive, void 0, (type, meta) => compileComponent(type, meta));
var Pipe = makeDecorator("Pipe", (p) => __spreadValues({
  pure: true
}, p), void 0, void 0, (type, meta) => compilePipe(type, meta));
var Input = makePropDecorator("Input", (arg) => {
  if (!arg) {
    return {};
  }
  return typeof arg === "string" ? {
    alias: arg
  } : arg;
});
var Output = makePropDecorator("Output", (alias) => ({
  alias
}));
var HostBinding = makePropDecorator("HostBinding", (hostPropertyName) => ({
  hostPropertyName
}));
var HostListener = makePropDecorator("HostListener", (eventName, args) => ({
  eventName,
  args
}));
var NgModule = makeDecorator(
  "NgModule",
  (ngModule) => ngModule,
  void 0,
  void 0,
  /**
   * Decorator that marks the following class as an NgModule, and supplies
   * configuration metadata for it.
   *
   * * The `declarations` option configures the compiler
   * with information about what belongs to the NgModule.
   * * The `providers` options configures the NgModule's injector to provide
   * dependencies the NgModule members.
   * * The `imports` and `exports` options bring in members from other modules, and make
   * this module's members available to others.
   */
  (type, meta) => compileNgModule(type, meta)
);
var Version = class {
  constructor(full) {
    this.full = full;
    const parts = full.split(".");
    this.major = parts[0];
    this.minor = parts[1];
    this.patch = parts.slice(2).join(".");
  }
};
var VERSION = new Version("18.2.0");
var Console = class _Console {
  log(message) {
    console.log(message);
  }
  // Note: for reporting errors use `DOM.logError()` as it is platform specific
  warn(message) {
    console.warn(message);
  }
  static {
    this.ɵfac = function Console_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _Console)();
    };
  }
  static {
    this.ɵprov = ɵɵdefineInjectable({
      token: _Console,
      factory: _Console.ɵfac,
      providedIn: "platform"
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(Console, [{
    type: Injectable,
    args: [{
      providedIn: "platform"
    }]
  }], null, null);
})();
var DIDebugData = class {
  constructor() {
    this.resolverToTokenToDependencies = /* @__PURE__ */ new WeakMap();
    this.resolverToProviders = /* @__PURE__ */ new WeakMap();
    this.standaloneInjectorToComponent = /* @__PURE__ */ new WeakMap();
  }
  reset() {
    this.resolverToTokenToDependencies = /* @__PURE__ */ new WeakMap();
    this.resolverToProviders = /* @__PURE__ */ new WeakMap();
    this.standaloneInjectorToComponent = /* @__PURE__ */ new WeakMap();
  }
};
var frameworkDIDebugData = new DIDebugData();
function getFrameworkDIDebugData() {
  return frameworkDIDebugData;
}
function setupFrameworkInjectorProfiler() {
  frameworkDIDebugData.reset();
  setInjectorProfiler((injectorProfilerEvent) => handleInjectorProfilerEvent(injectorProfilerEvent));
}
function handleInjectorProfilerEvent(injectorProfilerEvent) {
  const {
    context,
    type
  } = injectorProfilerEvent;
  if (type === 0) {
    handleInjectEvent(context, injectorProfilerEvent.service);
  } else if (type === 1) {
    handleInstanceCreatedByInjectorEvent(context, injectorProfilerEvent.instance);
  } else if (type === 2) {
    handleProviderConfiguredEvent(context, injectorProfilerEvent.providerRecord);
  }
}
function handleInjectEvent(context, data) {
  const diResolver = getDIResolver(context.injector);
  if (diResolver === null) {
    throwError("An Inject event must be run within an injection context.");
  }
  const diResolverToInstantiatedToken = frameworkDIDebugData.resolverToTokenToDependencies;
  if (!diResolverToInstantiatedToken.has(diResolver)) {
    diResolverToInstantiatedToken.set(diResolver, /* @__PURE__ */ new WeakMap());
  }
  if (!canBeHeldWeakly(context.token)) {
    return;
  }
  const instantiatedTokenToDependencies = diResolverToInstantiatedToken.get(diResolver);
  if (!instantiatedTokenToDependencies.has(context.token)) {
    instantiatedTokenToDependencies.set(context.token, []);
  }
  const {
    token,
    value,
    flags
  } = data;
  assertDefined(context.token, "Injector profiler context token is undefined.");
  const dependencies = instantiatedTokenToDependencies.get(context.token);
  assertDefined(dependencies, "Could not resolve dependencies for token.");
  if (context.injector instanceof NodeInjector) {
    dependencies.push({
      token,
      value,
      flags,
      injectedIn: getNodeInjectorContext(context.injector)
    });
  } else {
    dependencies.push({
      token,
      value,
      flags
    });
  }
}
function getNodeInjectorContext(injector) {
  if (!(injector instanceof NodeInjector)) {
    throwError("getNodeInjectorContext must be called with a NodeInjector");
  }
  const lView = getNodeInjectorLView(injector);
  const tNode = getNodeInjectorTNode(injector);
  if (tNode === null) {
    return;
  }
  assertTNodeForLView(tNode, lView);
  return {
    lView,
    tNode
  };
}
function handleInstanceCreatedByInjectorEvent(context, data) {
  const {
    value
  } = data;
  if (getDIResolver(context.injector) === null) {
    throwError("An InjectorCreatedInstance event must be run within an injection context.");
  }
  let standaloneComponent = void 0;
  if (typeof value === "object") {
    standaloneComponent = value?.constructor;
  }
  if (standaloneComponent == void 0 || !isStandaloneComponent(standaloneComponent)) {
    return;
  }
  const environmentInjector = context.injector.get(EnvironmentInjector, null, {
    optional: true
  });
  if (environmentInjector === null) {
    return;
  }
  const {
    standaloneInjectorToComponent
  } = frameworkDIDebugData;
  if (standaloneInjectorToComponent.has(environmentInjector)) {
    return;
  }
  standaloneInjectorToComponent.set(environmentInjector, standaloneComponent);
}
function isStandaloneComponent(value) {
  const def = getComponentDef(value);
  return !!def?.standalone;
}
function handleProviderConfiguredEvent(context, data) {
  const {
    resolverToProviders
  } = frameworkDIDebugData;
  let diResolver;
  if (context?.injector instanceof NodeInjector) {
    diResolver = getNodeInjectorTNode(context.injector);
  } else {
    diResolver = context.injector;
  }
  if (diResolver === null) {
    throwError("A ProviderConfigured event must be run within an injection context.");
  }
  if (!resolverToProviders.has(diResolver)) {
    resolverToProviders.set(diResolver, []);
  }
  resolverToProviders.get(diResolver).push(data);
}
function getDIResolver(injector) {
  let diResolver = null;
  if (injector === void 0) {
    return diResolver;
  }
  if (injector instanceof NodeInjector) {
    diResolver = getNodeInjectorLView(injector);
  } else {
    diResolver = injector;
  }
  return diResolver;
}
function canBeHeldWeakly(value) {
  return value !== null && (typeof value === "object" || typeof value === "function" || typeof value === "symbol");
}
function applyChanges(component) {
  ngDevMode && assertDefined(component, "component");
  markViewDirty(
    getComponentViewByInstance(component),
    3
    /* NotificationSource.DebugApplyChanges */
  );
  getRootComponents(component).forEach((rootComponent) => detectChanges(rootComponent));
}
function detectChanges(component) {
  const view = getComponentViewByInstance(component);
  view[FLAGS] |= 1024;
  detectChangesInternal(view);
}
function getDependenciesFromInjectable(injector, token) {
  const instance = injector.get(token, null, {
    self: true,
    optional: true
  });
  if (instance === null) {
    throw new Error(`Unable to determine instance of ${token} in given injector`);
  }
  const unformattedDependencies = getDependenciesForTokenInInjector(token, injector);
  const resolutionPath = getInjectorResolutionPath(injector);
  const dependencies = unformattedDependencies.map((dep) => {
    const formattedDependency = {
      value: dep.value
    };
    const flags = dep.flags;
    formattedDependency.flags = {
      optional: (8 & flags) === 8,
      host: (1 & flags) === 1,
      self: (2 & flags) === 2,
      skipSelf: (4 & flags) === 4
      /* InternalInjectFlags.SkipSelf */
    };
    for (let i = 0; i < resolutionPath.length; i++) {
      const injectorToCheck = resolutionPath[i];
      if (i === 0 && formattedDependency.flags.skipSelf) {
        continue;
      }
      if (formattedDependency.flags.host && injectorToCheck instanceof EnvironmentInjector) {
        break;
      }
      const instance2 = injectorToCheck.get(dep.token, null, {
        self: true,
        optional: true
      });
      if (instance2 !== null) {
        if (formattedDependency.flags.host) {
          const firstInjector = resolutionPath[0];
          const lookupFromFirstInjector = firstInjector.get(dep.token, null, __spreadProps(__spreadValues({}, formattedDependency.flags), {
            optional: true
          }));
          if (lookupFromFirstInjector !== null) {
            formattedDependency.providedIn = injectorToCheck;
          }
          break;
        }
        formattedDependency.providedIn = injectorToCheck;
        break;
      }
      if (i === 0 && formattedDependency.flags.self) {
        break;
      }
    }
    if (dep.token) formattedDependency.token = dep.token;
    return formattedDependency;
  });
  return {
    instance,
    dependencies
  };
}
function getDependenciesForTokenInInjector(token, injector) {
  const {
    resolverToTokenToDependencies
  } = getFrameworkDIDebugData();
  if (!(injector instanceof NodeInjector)) {
    return resolverToTokenToDependencies.get(injector)?.get?.(token) ?? [];
  }
  const lView = getNodeInjectorLView(injector);
  const tokenDependencyMap = resolverToTokenToDependencies.get(lView);
  const dependencies = tokenDependencyMap?.get(token) ?? [];
  return dependencies.filter((dependency) => {
    const dependencyNode = dependency.injectedIn?.tNode;
    if (dependencyNode === void 0) {
      return false;
    }
    const instanceNode = getNodeInjectorTNode(injector);
    assertTNode(dependencyNode);
    assertTNode(instanceNode);
    return dependencyNode === instanceNode;
  });
}
function getProviderImportsContainer(injector) {
  const {
    standaloneInjectorToComponent
  } = getFrameworkDIDebugData();
  if (standaloneInjectorToComponent.has(injector)) {
    return standaloneInjectorToComponent.get(injector);
  }
  const defTypeRef = injector.get(NgModuleRef$1, null, {
    self: true,
    optional: true
  });
  if (defTypeRef === null) {
    return null;
  }
  if (defTypeRef.instance === null) {
    return null;
  }
  return defTypeRef.instance.constructor;
}
function getNodeInjectorProviders(injector) {
  const diResolver = getNodeInjectorTNode(injector);
  const {
    resolverToProviders
  } = getFrameworkDIDebugData();
  return resolverToProviders.get(diResolver) ?? [];
}
function getProviderImportPaths(providerImportsContainer) {
  const providerToPath = /* @__PURE__ */ new Map();
  const visitedContainers = /* @__PURE__ */ new Set();
  const visitor = walkProviderTreeToDiscoverImportPaths(providerToPath, visitedContainers);
  walkProviderTree(providerImportsContainer, visitor, [], /* @__PURE__ */ new Set());
  return providerToPath;
}
function walkProviderTreeToDiscoverImportPaths(providerToPath, visitedContainers) {
  return (provider, container) => {
    if (!providerToPath.has(provider)) {
      providerToPath.set(provider, [container]);
    }
    if (!visitedContainers.has(container)) {
      for (const prov of providerToPath.keys()) {
        const existingImportPath = providerToPath.get(prov);
        let containerDef = getInjectorDef(container);
        if (!containerDef) {
          const ngModule = container.ngModule;
          containerDef = getInjectorDef(ngModule);
        }
        if (!containerDef) {
          return;
        }
        const lastContainerAddedToPath = existingImportPath[0];
        let isNextStepInPath = false;
        deepForEach(containerDef.imports, (moduleImport) => {
          if (isNextStepInPath) {
            return;
          }
          isNextStepInPath = moduleImport.ngModule === lastContainerAddedToPath || moduleImport === lastContainerAddedToPath;
          if (isNextStepInPath) {
            providerToPath.get(prov)?.unshift(container);
          }
        });
      }
    }
    visitedContainers.add(container);
  };
}
function getEnvironmentInjectorProviders(injector) {
  const providerRecordsWithoutImportPaths = getFrameworkDIDebugData().resolverToProviders.get(injector) ?? [];
  if (isPlatformInjector(injector)) {
    return providerRecordsWithoutImportPaths;
  }
  const providerImportsContainer = getProviderImportsContainer(injector);
  if (providerImportsContainer === null) {
    return providerRecordsWithoutImportPaths;
  }
  const providerToPath = getProviderImportPaths(providerImportsContainer);
  const providerRecords = [];
  for (const providerRecord of providerRecordsWithoutImportPaths) {
    const provider = providerRecord.provider;
    const token = provider.provide;
    if (token === ENVIRONMENT_INITIALIZER || token === INJECTOR_DEF_TYPES) {
      continue;
    }
    let importPath = providerToPath.get(provider) ?? [];
    const def = getComponentDef(providerImportsContainer);
    const isStandaloneComponent2 = !!def?.standalone;
    if (isStandaloneComponent2) {
      importPath = [providerImportsContainer, ...importPath];
    }
    providerRecords.push(__spreadProps(__spreadValues({}, providerRecord), {
      importPath
    }));
  }
  return providerRecords;
}
function isPlatformInjector(injector) {
  return injector instanceof R3Injector && injector.scopes.has("platform");
}
function getInjectorProviders(injector) {
  if (injector instanceof NodeInjector) {
    return getNodeInjectorProviders(injector);
  } else if (injector instanceof EnvironmentInjector) {
    return getEnvironmentInjectorProviders(injector);
  }
  throwError("getInjectorProviders only supports NodeInjector and EnvironmentInjector");
}
function getInjectorMetadata(injector) {
  if (injector instanceof NodeInjector) {
    const lView = getNodeInjectorLView(injector);
    const tNode = getNodeInjectorTNode(injector);
    assertTNodeForLView(tNode, lView);
    return {
      type: "element",
      source: getNativeByTNode(tNode, lView)
    };
  }
  if (injector instanceof R3Injector) {
    return {
      type: "environment",
      source: injector.source ?? null
    };
  }
  if (injector instanceof NullInjector) {
    return {
      type: "null",
      source: null
    };
  }
  return null;
}
function getInjectorResolutionPath(injector) {
  const resolutionPath = [injector];
  getInjectorResolutionPathHelper(injector, resolutionPath);
  return resolutionPath;
}
function getInjectorResolutionPathHelper(injector, resolutionPath) {
  const parent = getInjectorParent(injector);
  if (parent === null) {
    if (injector instanceof NodeInjector) {
      const firstInjector = resolutionPath[0];
      if (firstInjector instanceof NodeInjector) {
        const moduleInjector = getModuleInjectorOfNodeInjector(firstInjector);
        if (moduleInjector === null) {
          throwError("NodeInjector must have some connection to the module injector tree");
        }
        resolutionPath.push(moduleInjector);
        getInjectorResolutionPathHelper(moduleInjector, resolutionPath);
      }
      return resolutionPath;
    }
  } else {
    resolutionPath.push(parent);
    getInjectorResolutionPathHelper(parent, resolutionPath);
  }
  return resolutionPath;
}
function getInjectorParent(injector) {
  if (injector instanceof R3Injector) {
    const parent = injector.parent;
    if (isRouterOutletInjector(parent)) {
      return parent.parentInjector;
    }
    return parent;
  }
  let tNode;
  let lView;
  if (injector instanceof NodeInjector) {
    tNode = getNodeInjectorTNode(injector);
    lView = getNodeInjectorLView(injector);
  } else if (injector instanceof NullInjector) {
    return null;
  } else if (injector instanceof ChainedInjector) {
    return injector.parentInjector;
  } else {
    throwError("getInjectorParent only support injectors of type R3Injector, NodeInjector, NullInjector");
  }
  const parentLocation = getParentInjectorLocation(tNode, lView);
  if (hasParentInjector(parentLocation)) {
    const parentInjectorIndex = getParentInjectorIndex(parentLocation);
    const parentLView = getParentInjectorView(parentLocation, lView);
    const parentTView = parentLView[TVIEW];
    const parentTNode = parentTView.data[
      parentInjectorIndex + 8
      /* NodeInjectorOffset.TNODE */
    ];
    return new NodeInjector(parentTNode, parentLView);
  } else {
    const chainedInjector = lView[INJECTOR];
    const injectorParent = chainedInjector.injector?.parent;
    if (injectorParent instanceof NodeInjector) {
      return injectorParent;
    }
  }
  return null;
}
function getModuleInjectorOfNodeInjector(injector) {
  let lView;
  if (injector instanceof NodeInjector) {
    lView = getNodeInjectorLView(injector);
  } else {
    throwError("getModuleInjectorOfNodeInjector must be called with a NodeInjector");
  }
  const inj = lView[INJECTOR];
  const moduleInjector = inj instanceof ChainedInjector ? inj.parentInjector : inj.parent;
  if (!moduleInjector) {
    throwError("NodeInjector must have some connection to the module injector tree");
  }
  return moduleInjector;
}
var GLOBAL_PUBLISH_EXPANDO_KEY = "ng";
var globalUtilsFunctions = {
  /**
   * Warning: functions that start with `ɵ` are considered *INTERNAL* and should not be relied upon
   * in application's code. The contract of those functions might be changed in any release and/or a
   * function can be removed completely.
   */
  "ɵgetDependenciesFromInjectable": getDependenciesFromInjectable,
  "ɵgetInjectorProviders": getInjectorProviders,
  "ɵgetInjectorResolutionPath": getInjectorResolutionPath,
  "ɵgetInjectorMetadata": getInjectorMetadata,
  "ɵsetProfiler": setProfiler,
  "getDirectiveMetadata": getDirectiveMetadata$1,
  "getComponent": getComponent$1,
  "getContext": getContext,
  "getListeners": getListeners,
  "getOwningComponent": getOwningComponent,
  "getHostElement": getHostElement,
  "getInjector": getInjector,
  "getRootComponents": getRootComponents,
  "getDirectives": getDirectives,
  "applyChanges": applyChanges,
  "isSignal": isSignal
};
var _published = false;
function publishDefaultGlobalUtils$1() {
  if (!_published) {
    _published = true;
    if (typeof window !== "undefined") {
      setupFrameworkInjectorProfiler();
    }
    for (const [methodName, method] of Object.entries(globalUtilsFunctions)) {
      publishGlobalUtil(methodName, method);
    }
  }
}
function publishGlobalUtil(name, fn) {
  if (typeof COMPILED === "undefined" || !COMPILED) {
    const w = _global;
    ngDevMode && assertDefined(fn, "function not defined");
    w[GLOBAL_PUBLISH_EXPANDO_KEY] ??= {};
    w[GLOBAL_PUBLISH_EXPANDO_KEY][name] = fn;
  }
}
var TESTABILITY = new InjectionToken("");
var TESTABILITY_GETTER = new InjectionToken("");
var Testability = class _Testability {
  constructor(_ngZone, registry, testabilityGetter) {
    this._ngZone = _ngZone;
    this.registry = registry;
    this._isZoneStable = true;
    this._callbacks = [];
    this.taskTrackingZone = null;
    if (!_testabilityGetter) {
      setTestabilityGetter(testabilityGetter);
      testabilityGetter.addToWindow(registry);
    }
    this._watchAngularEvents();
    _ngZone.run(() => {
      this.taskTrackingZone = typeof Zone == "undefined" ? null : Zone.current.get("TaskTrackingZone");
    });
  }
  _watchAngularEvents() {
    this._ngZone.onUnstable.subscribe({
      next: () => {
        this._isZoneStable = false;
      }
    });
    this._ngZone.runOutsideAngular(() => {
      this._ngZone.onStable.subscribe({
        next: () => {
          NgZone.assertNotInAngularZone();
          queueMicrotask(() => {
            this._isZoneStable = true;
            this._runCallbacksIfReady();
          });
        }
      });
    });
  }
  /**
   * Whether an associated application is stable
   */
  isStable() {
    return this._isZoneStable && !this._ngZone.hasPendingMacrotasks;
  }
  _runCallbacksIfReady() {
    if (this.isStable()) {
      queueMicrotask(() => {
        while (this._callbacks.length !== 0) {
          let cb = this._callbacks.pop();
          clearTimeout(cb.timeoutId);
          cb.doneCb();
        }
      });
    } else {
      let pending = this.getPendingTasks();
      this._callbacks = this._callbacks.filter((cb) => {
        if (cb.updateCb && cb.updateCb(pending)) {
          clearTimeout(cb.timeoutId);
          return false;
        }
        return true;
      });
    }
  }
  getPendingTasks() {
    if (!this.taskTrackingZone) {
      return [];
    }
    return this.taskTrackingZone.macroTasks.map((t) => {
      return {
        source: t.source,
        // From TaskTrackingZone:
        // https://github.com/angular/zone.js/blob/master/lib/zone-spec/task-tracking.ts#L40
        creationLocation: t.creationLocation,
        data: t.data
      };
    });
  }
  addCallback(cb, timeout, updateCb) {
    let timeoutId = -1;
    if (timeout && timeout > 0) {
      timeoutId = setTimeout(() => {
        this._callbacks = this._callbacks.filter((cb2) => cb2.timeoutId !== timeoutId);
        cb();
      }, timeout);
    }
    this._callbacks.push({
      doneCb: cb,
      timeoutId,
      updateCb
    });
  }
  /**
   * Wait for the application to be stable with a timeout. If the timeout is reached before that
   * happens, the callback receives a list of the macro tasks that were pending, otherwise null.
   *
   * @param doneCb The callback to invoke when Angular is stable or the timeout expires
   *    whichever comes first.
   * @param timeout Optional. The maximum time to wait for Angular to become stable. If not
   *    specified, whenStable() will wait forever.
   * @param updateCb Optional. If specified, this callback will be invoked whenever the set of
   *    pending macrotasks changes. If this callback returns true doneCb will not be invoked
   *    and no further updates will be issued.
   */
  whenStable(doneCb, timeout, updateCb) {
    if (updateCb && !this.taskTrackingZone) {
      throw new Error('Task tracking zone is required when passing an update callback to whenStable(). Is "zone.js/plugins/task-tracking" loaded?');
    }
    this.addCallback(doneCb, timeout, updateCb);
    this._runCallbacksIfReady();
  }
  /**
   * Registers an application with a testability hook so that it can be tracked.
   * @param token token of application, root element
   *
   * @internal
   */
  registerApplication(token) {
    this.registry.registerApplication(token, this);
  }
  /**
   * Unregisters an application.
   * @param token token of application, root element
   *
   * @internal
   */
  unregisterApplication(token) {
    this.registry.unregisterApplication(token);
  }
  /**
   * Find providers by name
   * @param using The root element to search from
   * @param provider The name of binding variable
   * @param exactMatch Whether using exactMatch
   */
  findProviders(using, provider, exactMatch) {
    return [];
  }
  static {
    this.ɵfac = function Testability_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _Testability)(ɵɵinject(NgZone), ɵɵinject(TestabilityRegistry), ɵɵinject(TESTABILITY_GETTER));
    };
  }
  static {
    this.ɵprov = ɵɵdefineInjectable({
      token: _Testability,
      factory: _Testability.ɵfac
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(Testability, [{
    type: Injectable
  }], () => [{
    type: NgZone
  }, {
    type: TestabilityRegistry
  }, {
    type: void 0,
    decorators: [{
      type: Inject,
      args: [TESTABILITY_GETTER]
    }]
  }], null);
})();
var TestabilityRegistry = class _TestabilityRegistry {
  constructor() {
    this._applications = /* @__PURE__ */ new Map();
  }
  /**
   * Registers an application with a testability hook so that it can be tracked
   * @param token token of application, root element
   * @param testability Testability hook
   */
  registerApplication(token, testability) {
    this._applications.set(token, testability);
  }
  /**
   * Unregisters an application.
   * @param token token of application, root element
   */
  unregisterApplication(token) {
    this._applications.delete(token);
  }
  /**
   * Unregisters all applications
   */
  unregisterAllApplications() {
    this._applications.clear();
  }
  /**
   * Get a testability hook associated with the application
   * @param elem root element
   */
  getTestability(elem) {
    return this._applications.get(elem) || null;
  }
  /**
   * Get all registered testabilities
   */
  getAllTestabilities() {
    return Array.from(this._applications.values());
  }
  /**
   * Get all registered applications(root elements)
   */
  getAllRootElements() {
    return Array.from(this._applications.keys());
  }
  /**
   * Find testability of a node in the Tree
   * @param elem node
   * @param findInAncestors whether finding testability in ancestors if testability was not found in
   * current node
   */
  findTestabilityInTree(elem, findInAncestors = true) {
    return _testabilityGetter?.findTestabilityInTree(this, elem, findInAncestors) ?? null;
  }
  static {
    this.ɵfac = function TestabilityRegistry_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _TestabilityRegistry)();
    };
  }
  static {
    this.ɵprov = ɵɵdefineInjectable({
      token: _TestabilityRegistry,
      factory: _TestabilityRegistry.ɵfac,
      providedIn: "platform"
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(TestabilityRegistry, [{
    type: Injectable,
    args: [{
      providedIn: "platform"
    }]
  }], null, null);
})();
function setTestabilityGetter(getter) {
  _testabilityGetter = getter;
}
var _testabilityGetter;
function isPromise(obj) {
  return !!obj && typeof obj.then === "function";
}
function isSubscribable(obj) {
  return !!obj && typeof obj.subscribe === "function";
}
var APP_INITIALIZER = new InjectionToken(ngDevMode ? "Application Initializer" : "");
var ApplicationInitStatus = class _ApplicationInitStatus {
  constructor() {
    this.initialized = false;
    this.done = false;
    this.donePromise = new Promise((res, rej) => {
      this.resolve = res;
      this.reject = rej;
    });
    this.appInits = inject(APP_INITIALIZER, {
      optional: true
    }) ?? [];
    if ((typeof ngDevMode === "undefined" || ngDevMode) && !Array.isArray(this.appInits)) {
      throw new RuntimeError(-209, `Unexpected type of the \`APP_INITIALIZER\` token value (expected an array, but got ${typeof this.appInits}). Please check that the \`APP_INITIALIZER\` token is configured as a \`multi: true\` provider.`);
    }
  }
  /** @internal */
  runInitializers() {
    if (this.initialized) {
      return;
    }
    const asyncInitPromises = [];
    for (const appInits of this.appInits) {
      const initResult = appInits();
      if (isPromise(initResult)) {
        asyncInitPromises.push(initResult);
      } else if (isSubscribable(initResult)) {
        const observableAsPromise = new Promise((resolve, reject) => {
          initResult.subscribe({
            complete: resolve,
            error: reject
          });
        });
        asyncInitPromises.push(observableAsPromise);
      }
    }
    const complete = () => {
      this.done = true;
      this.resolve();
    };
    Promise.all(asyncInitPromises).then(() => {
      complete();
    }).catch((e) => {
      this.reject(e);
    });
    if (asyncInitPromises.length === 0) {
      complete();
    }
    this.initialized = true;
  }
  static {
    this.ɵfac = function ApplicationInitStatus_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _ApplicationInitStatus)();
    };
  }
  static {
    this.ɵprov = ɵɵdefineInjectable({
      token: _ApplicationInitStatus,
      factory: _ApplicationInitStatus.ɵfac,
      providedIn: "root"
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ApplicationInitStatus, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], () => [], null);
})();
var APP_BOOTSTRAP_LISTENER = new InjectionToken(ngDevMode ? "appBootstrapListener" : "");
function publishDefaultGlobalUtils() {
  ngDevMode && publishDefaultGlobalUtils$1();
}
function publishSignalConfiguration() {
  setThrowInvalidWriteToSignalError(() => {
    throw new RuntimeError(600, ngDevMode && "Writing to signals is not allowed in a `computed` or an `effect` by default. Use `allowSignalWrites` in the `CreateEffectOptions` to enable this inside effects.");
  });
}
function isBoundToModule(cf) {
  return cf.isBoundToModule;
}
var MAXIMUM_REFRESH_RERUNS = 10;
function _callAndReportToErrorHandler(errorHandler, ngZone, callback) {
  try {
    const result = callback();
    if (isPromise(result)) {
      return result.catch((e) => {
        ngZone.runOutsideAngular(() => errorHandler.handleError(e));
        throw e;
      });
    }
    return result;
  } catch (e) {
    ngZone.runOutsideAngular(() => errorHandler.handleError(e));
    throw e;
  }
}
function optionsReducer(dst, objs) {
  if (Array.isArray(objs)) {
    return objs.reduce(optionsReducer, dst);
  }
  return __spreadValues(__spreadValues({}, dst), objs);
}
var ApplicationRef = class _ApplicationRef {
  constructor() {
    this._bootstrapListeners = [];
    this._runningTick = false;
    this._destroyed = false;
    this._destroyListeners = [];
    this._views = [];
    this.internalErrorHandler = inject(INTERNAL_APPLICATION_ERROR_HANDLER);
    this.afterRenderEffectManager = inject(AfterRenderEventManager);
    this.zonelessEnabled = inject(ZONELESS_ENABLED);
    this.externalTestViews = /* @__PURE__ */ new Set();
    this.beforeRender = new Subject();
    this.afterTick = new Subject();
    this.componentTypes = [];
    this.components = [];
    this.isStable = inject(PendingTasks).hasPendingTasks.pipe(map((pending) => !pending));
    this._injector = inject(EnvironmentInjector);
  }
  /** @internal */
  get allViews() {
    return [...this.externalTestViews.keys(), ...this._views];
  }
  /**
   * Indicates whether this instance was destroyed.
   */
  get destroyed() {
    return this._destroyed;
  }
  /**
   * @returns A promise that resolves when the application becomes stable
   */
  whenStable() {
    let subscription;
    return new Promise((resolve) => {
      subscription = this.isStable.subscribe({
        next: (stable) => {
          if (stable) {
            resolve();
          }
        }
      });
    }).finally(() => {
      subscription.unsubscribe();
    });
  }
  /**
   * The `EnvironmentInjector` used to create this application.
   */
  get injector() {
    return this._injector;
  }
  /**
   * Bootstrap a component onto the element identified by its selector or, optionally, to a
   * specified element.
   *
   * @usageNotes
   * ### Bootstrap process
   *
   * When bootstrapping a component, Angular mounts it onto a target DOM element
   * and kicks off automatic change detection. The target DOM element can be
   * provided using the `rootSelectorOrNode` argument.
   *
   * If the target DOM element is not provided, Angular tries to find one on a page
   * using the `selector` of the component that is being bootstrapped
   * (first matched element is used).
   *
   * ### Example
   *
   * Generally, we define the component to bootstrap in the `bootstrap` array of `NgModule`,
   * but it requires us to know the component while writing the application code.
   *
   * Imagine a situation where we have to wait for an API call to decide about the component to
   * bootstrap. We can use the `ngDoBootstrap` hook of the `NgModule` and call this method to
   * dynamically bootstrap a component.
   *
   * {@example core/ts/platform/platform.ts region='componentSelector'}
   *
   * Optionally, a component can be mounted onto a DOM element that does not match the
   * selector of the bootstrapped component.
   *
   * In the following example, we are providing a CSS selector to match the target element.
   *
   * {@example core/ts/platform/platform.ts region='cssSelector'}
   *
   * While in this example, we are providing reference to a DOM node.
   *
   * {@example core/ts/platform/platform.ts region='domNode'}
   */
  bootstrap(componentOrFactory, rootSelectorOrNode) {
    (typeof ngDevMode === "undefined" || ngDevMode) && this.warnIfDestroyed();
    const isComponentFactory = componentOrFactory instanceof ComponentFactory$1;
    const initStatus = this._injector.get(ApplicationInitStatus);
    if (!initStatus.done) {
      const standalone = !isComponentFactory && isStandalone(componentOrFactory);
      const errorMessage = (typeof ngDevMode === "undefined" || ngDevMode) && "Cannot bootstrap as there are still asynchronous initializers running." + (standalone ? "" : " Bootstrap components in the `ngDoBootstrap` method of the root module.");
      throw new RuntimeError(405, errorMessage);
    }
    let componentFactory;
    if (isComponentFactory) {
      componentFactory = componentOrFactory;
    } else {
      const resolver = this._injector.get(ComponentFactoryResolver$1);
      componentFactory = resolver.resolveComponentFactory(componentOrFactory);
    }
    this.componentTypes.push(componentFactory.componentType);
    const ngModule = isBoundToModule(componentFactory) ? void 0 : this._injector.get(NgModuleRef$1);
    const selectorOrNode = rootSelectorOrNode || componentFactory.selector;
    const compRef = componentFactory.create(Injector.NULL, [], selectorOrNode, ngModule);
    const nativeElement = compRef.location.nativeElement;
    const testability = compRef.injector.get(TESTABILITY, null);
    testability?.registerApplication(nativeElement);
    compRef.onDestroy(() => {
      this.detachView(compRef.hostView);
      remove(this.components, compRef);
      testability?.unregisterApplication(nativeElement);
    });
    this._loadComponent(compRef);
    if (typeof ngDevMode === "undefined" || ngDevMode) {
      const _console = this._injector.get(Console);
      _console.log(`Angular is running in development mode.`);
    }
    return compRef;
  }
  /**
   * Invoke this method to explicitly process change detection and its side-effects.
   *
   * In development mode, `tick()` also performs a second change detection cycle to ensure that no
   * further changes are detected. If additional changes are picked up during this second cycle,
   * bindings in the app have side-effects that cannot be resolved in a single change detection
   * pass.
   * In this case, Angular throws an error, since an Angular application can only have one change
   * detection pass during which all change detection must complete.
   */
  tick() {
    this._tick(true);
  }
  /** @internal */
  _tick(refreshViews) {
    (typeof ngDevMode === "undefined" || ngDevMode) && this.warnIfDestroyed();
    if (this._runningTick) {
      throw new RuntimeError(101, ngDevMode && "ApplicationRef.tick is called recursively");
    }
    const prevConsumer = setActiveConsumer(null);
    try {
      this._runningTick = true;
      this.detectChangesInAttachedViews(refreshViews);
      if (typeof ngDevMode === "undefined" || ngDevMode) {
        for (let view of this._views) {
          view.checkNoChanges();
        }
      }
    } catch (e) {
      this.internalErrorHandler(e);
    } finally {
      this._runningTick = false;
      setActiveConsumer(prevConsumer);
      this.afterTick.next();
    }
  }
  detectChangesInAttachedViews(refreshViews) {
    let rendererFactory = null;
    if (!this._injector.destroyed) {
      rendererFactory = this._injector.get(RendererFactory2, null, {
        optional: true
      });
    }
    let runs = 0;
    const afterRenderEffectManager = this.afterRenderEffectManager;
    while (runs < MAXIMUM_REFRESH_RERUNS) {
      const isFirstPass = runs === 0;
      if (refreshViews || !isFirstPass) {
        this.beforeRender.next(isFirstPass);
        for (let {
          _lView,
          notifyErrorHandler
        } of this._views) {
          detectChangesInViewIfRequired(_lView, notifyErrorHandler, isFirstPass, this.zonelessEnabled);
        }
      } else {
        rendererFactory?.begin?.();
        rendererFactory?.end?.();
      }
      runs++;
      afterRenderEffectManager.executeInternalCallbacks();
      if (this.allViews.some(({
        _lView
      }) => requiresRefreshOrTraversal(_lView))) {
        continue;
      }
      afterRenderEffectManager.execute();
      if (!this.allViews.some(({
        _lView
      }) => requiresRefreshOrTraversal(_lView))) {
        break;
      }
    }
    if ((typeof ngDevMode === "undefined" || ngDevMode) && runs >= MAXIMUM_REFRESH_RERUNS) {
      throw new RuntimeError(103, ngDevMode && "Infinite change detection while refreshing application views. Ensure views are not calling `markForCheck` on every template execution or that afterRender hooks always mark views for check.");
    }
  }
  /**
   * Attaches a view so that it will be dirty checked.
   * The view will be automatically detached when it is destroyed.
   * This will throw if the view is already attached to a ViewContainer.
   */
  attachView(viewRef) {
    (typeof ngDevMode === "undefined" || ngDevMode) && this.warnIfDestroyed();
    const view = viewRef;
    this._views.push(view);
    view.attachToAppRef(this);
  }
  /**
   * Detaches a view from dirty checking again.
   */
  detachView(viewRef) {
    (typeof ngDevMode === "undefined" || ngDevMode) && this.warnIfDestroyed();
    const view = viewRef;
    remove(this._views, view);
    view.detachFromAppRef();
  }
  _loadComponent(componentRef) {
    this.attachView(componentRef.hostView);
    this.tick();
    this.components.push(componentRef);
    const listeners = this._injector.get(APP_BOOTSTRAP_LISTENER, []);
    if (ngDevMode && !Array.isArray(listeners)) {
      throw new RuntimeError(-209, `Unexpected type of the \`APP_BOOTSTRAP_LISTENER\` token value (expected an array, but got ${typeof listeners}). Please check that the \`APP_BOOTSTRAP_LISTENER\` token is configured as a \`multi: true\` provider.`);
    }
    [...this._bootstrapListeners, ...listeners].forEach((listener) => listener(componentRef));
  }
  /** @internal */
  ngOnDestroy() {
    if (this._destroyed) return;
    try {
      this._destroyListeners.forEach((listener) => listener());
      this._views.slice().forEach((view) => view.destroy());
    } finally {
      this._destroyed = true;
      this._views = [];
      this._bootstrapListeners = [];
      this._destroyListeners = [];
    }
  }
  /**
   * Registers a listener to be called when an instance is destroyed.
   *
   * @param callback A callback function to add as a listener.
   * @returns A function which unregisters a listener.
   */
  onDestroy(callback) {
    (typeof ngDevMode === "undefined" || ngDevMode) && this.warnIfDestroyed();
    this._destroyListeners.push(callback);
    return () => remove(this._destroyListeners, callback);
  }
  /**
   * Destroys an Angular application represented by this `ApplicationRef`. Calling this function
   * will destroy the associated environment injectors as well as all the bootstrapped components
   * with their views.
   */
  destroy() {
    if (this._destroyed) {
      throw new RuntimeError(406, ngDevMode && "This instance of the `ApplicationRef` has already been destroyed.");
    }
    const injector = this._injector;
    if (injector.destroy && !injector.destroyed) {
      injector.destroy();
    }
  }
  /**
   * Returns the number of attached views.
   */
  get viewCount() {
    return this._views.length;
  }
  warnIfDestroyed() {
    if ((typeof ngDevMode === "undefined" || ngDevMode) && this._destroyed) {
      console.warn(formatRuntimeError(406, "This instance of the `ApplicationRef` has already been destroyed."));
    }
  }
  static {
    this.ɵfac = function ApplicationRef_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _ApplicationRef)();
    };
  }
  static {
    this.ɵprov = ɵɵdefineInjectable({
      token: _ApplicationRef,
      factory: _ApplicationRef.ɵfac,
      providedIn: "root"
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ApplicationRef, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], null, null);
})();
function remove(list, el) {
  const index = list.indexOf(el);
  if (index > -1) {
    list.splice(index, 1);
  }
}
var whenStableStore;
function whenStable(applicationRef) {
  whenStableStore ??= /* @__PURE__ */ new WeakMap();
  const cachedWhenStable = whenStableStore.get(applicationRef);
  if (cachedWhenStable) {
    return cachedWhenStable;
  }
  const whenStablePromise = applicationRef.isStable.pipe(first((isStable) => isStable)).toPromise().then(() => void 0);
  whenStableStore.set(applicationRef, whenStablePromise);
  applicationRef.onDestroy(() => whenStableStore?.delete(applicationRef));
  return whenStablePromise;
}
function detectChangesInViewIfRequired(lView, notifyErrorHandler, isFirstPass, zonelessEnabled) {
  if (!isFirstPass && !requiresRefreshOrTraversal(lView)) {
    return;
  }
  const mode = isFirstPass && !zonelessEnabled ? (
    // The first pass is always in Global mode, which includes `CheckAlways` views.
    0
  ) : (
    // Only refresh views with the `RefreshView` flag or views is a changed signal
    1
  );
  detectChangesInternal(lView, notifyErrorHandler, mode);
}
var ModuleWithComponentFactories = class {
  constructor(ngModuleFactory, componentFactories) {
    this.ngModuleFactory = ngModuleFactory;
    this.componentFactories = componentFactories;
  }
};
var Compiler = class _Compiler {
  /**
   * Compiles the given NgModule and all of its components. All templates of the components
   * have to be inlined.
   */
  compileModuleSync(moduleType) {
    return new NgModuleFactory(moduleType);
  }
  /**
   * Compiles the given NgModule and all of its components
   */
  compileModuleAsync(moduleType) {
    return Promise.resolve(this.compileModuleSync(moduleType));
  }
  /**
   * Same as {@link #compileModuleSync} but also creates ComponentFactories for all components.
   */
  compileModuleAndAllComponentsSync(moduleType) {
    const ngModuleFactory = this.compileModuleSync(moduleType);
    const moduleDef = getNgModuleDef(moduleType);
    const componentFactories = maybeUnwrapFn(moduleDef.declarations).reduce((factories, declaration) => {
      const componentDef = getComponentDef(declaration);
      componentDef && factories.push(new ComponentFactory(componentDef));
      return factories;
    }, []);
    return new ModuleWithComponentFactories(ngModuleFactory, componentFactories);
  }
  /**
   * Same as {@link #compileModuleAsync} but also creates ComponentFactories for all components.
   */
  compileModuleAndAllComponentsAsync(moduleType) {
    return Promise.resolve(this.compileModuleAndAllComponentsSync(moduleType));
  }
  /**
   * Clears all caches.
   */
  clearCache() {
  }
  /**
   * Clears the cache for the given component/ngModule.
   */
  clearCacheFor(type) {
  }
  /**
   * Returns the id for a given NgModule, if one is defined and known to the compiler.
   */
  getModuleId(moduleType) {
    return void 0;
  }
  static {
    this.ɵfac = function Compiler_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _Compiler)();
    };
  }
  static {
    this.ɵprov = ɵɵdefineInjectable({
      token: _Compiler,
      factory: _Compiler.ɵfac,
      providedIn: "root"
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(Compiler, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], null, null);
})();
var COMPILER_OPTIONS = new InjectionToken(ngDevMode ? "compilerOptions" : "");
function compileNgModuleFactory(injector, options, moduleType) {
  ngDevMode && assertNgModuleType(moduleType);
  const moduleFactory = new NgModuleFactory(moduleType);
  if (typeof ngJitMode !== "undefined" && !ngJitMode) {
    return Promise.resolve(moduleFactory);
  }
  const compilerOptions = injector.get(COMPILER_OPTIONS, []).concat(options);
  setJitOptions({
    defaultEncapsulation: _lastDefined(compilerOptions.map((opts) => opts.defaultEncapsulation)),
    preserveWhitespaces: _lastDefined(compilerOptions.map((opts) => opts.preserveWhitespaces))
  });
  if (isComponentResourceResolutionQueueEmpty()) {
    return Promise.resolve(moduleFactory);
  }
  const compilerProviders = compilerOptions.flatMap((option) => option.providers ?? []);
  if (compilerProviders.length === 0) {
    return Promise.resolve(moduleFactory);
  }
  const compiler = getCompilerFacade({
    usage: 0,
    kind: "NgModule",
    type: moduleType
  });
  const compilerInjector = Injector.create({
    providers: compilerProviders
  });
  const resourceLoader = compilerInjector.get(compiler.ResourceLoader);
  return resolveComponentResources((url) => Promise.resolve(resourceLoader.get(url))).then(() => moduleFactory);
}
function _lastDefined(args) {
  for (let i = args.length - 1; i >= 0; i--) {
    if (args[i] !== void 0) {
      return args[i];
    }
  }
  return void 0;
}
var NgZoneChangeDetectionScheduler = class _NgZoneChangeDetectionScheduler {
  constructor() {
    this.zone = inject(NgZone);
    this.changeDetectionScheduler = inject(ChangeDetectionScheduler);
    this.applicationRef = inject(ApplicationRef);
  }
  initialize() {
    if (this._onMicrotaskEmptySubscription) {
      return;
    }
    this._onMicrotaskEmptySubscription = this.zone.onMicrotaskEmpty.subscribe({
      next: () => {
        if (this.changeDetectionScheduler.runningTick) {
          return;
        }
        this.zone.run(() => {
          this.applicationRef.tick();
        });
      }
    });
  }
  ngOnDestroy() {
    this._onMicrotaskEmptySubscription?.unsubscribe();
  }
  static {
    this.ɵfac = function NgZoneChangeDetectionScheduler_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _NgZoneChangeDetectionScheduler)();
    };
  }
  static {
    this.ɵprov = ɵɵdefineInjectable({
      token: _NgZoneChangeDetectionScheduler,
      factory: _NgZoneChangeDetectionScheduler.ɵfac,
      providedIn: "root"
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NgZoneChangeDetectionScheduler, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], null, null);
})();
var PROVIDED_NG_ZONE = new InjectionToken(typeof ngDevMode === "undefined" || ngDevMode ? "provideZoneChangeDetection token" : "", {
  factory: () => false
});
function internalProvideZoneChangeDetection({
  ngZoneFactory,
  ignoreChangesOutsideZone
}) {
  ngZoneFactory ??= () => new NgZone(getNgZoneOptions());
  return [
    {
      provide: NgZone,
      useFactory: ngZoneFactory
    },
    {
      provide: ENVIRONMENT_INITIALIZER,
      multi: true,
      useFactory: () => {
        const ngZoneChangeDetectionScheduler = inject(NgZoneChangeDetectionScheduler, {
          optional: true
        });
        if ((typeof ngDevMode === "undefined" || ngDevMode) && ngZoneChangeDetectionScheduler === null) {
          throw new RuntimeError(402, `A required Injectable was not found in the dependency injection tree. If you are bootstrapping an NgModule, make sure that the \`BrowserModule\` is imported.`);
        }
        return () => ngZoneChangeDetectionScheduler.initialize();
      }
    },
    {
      provide: ENVIRONMENT_INITIALIZER,
      multi: true,
      useFactory: () => {
        const service = inject(ZoneStablePendingTask);
        return () => {
          service.initialize();
        };
      }
    },
    // Always disable scheduler whenever explicitly disabled, even if another place called
    // `provideZoneChangeDetection` without the 'ignore' option.
    ignoreChangesOutsideZone === true ? {
      provide: ZONELESS_SCHEDULER_DISABLED,
      useValue: true
    } : []
  ];
}
function getNgZoneOptions(options) {
  return {
    enableLongStackTrace: typeof ngDevMode === "undefined" ? false : !!ngDevMode,
    shouldCoalesceEventChangeDetection: options?.eventCoalescing ?? false,
    shouldCoalesceRunChangeDetection: options?.runCoalescing ?? false
  };
}
var ZoneStablePendingTask = class _ZoneStablePendingTask {
  constructor() {
    this.subscription = new Subscription();
    this.initialized = false;
    this.zone = inject(NgZone);
    this.pendingTasks = inject(PendingTasks);
  }
  initialize() {
    if (this.initialized) {
      return;
    }
    this.initialized = true;
    let task = null;
    if (!this.zone.isStable && !this.zone.hasPendingMacrotasks && !this.zone.hasPendingMicrotasks) {
      task = this.pendingTasks.add();
    }
    this.zone.runOutsideAngular(() => {
      this.subscription.add(this.zone.onStable.subscribe(() => {
        NgZone.assertNotInAngularZone();
        queueMicrotask(() => {
          if (task !== null && !this.zone.hasPendingMacrotasks && !this.zone.hasPendingMicrotasks) {
            this.pendingTasks.remove(task);
            task = null;
          }
        });
      }));
    });
    this.subscription.add(this.zone.onUnstable.subscribe(() => {
      NgZone.assertInAngularZone();
      task ??= this.pendingTasks.add();
    }));
  }
  ngOnDestroy() {
    this.subscription.unsubscribe();
  }
  static {
    this.ɵfac = function ZoneStablePendingTask_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _ZoneStablePendingTask)();
    };
  }
  static {
    this.ɵprov = ɵɵdefineInjectable({
      token: _ZoneStablePendingTask,
      factory: _ZoneStablePendingTask.ɵfac,
      providedIn: "root"
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ZoneStablePendingTask, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], null, null);
})();
var CONSECUTIVE_MICROTASK_NOTIFICATION_LIMIT = 100;
var consecutiveMicrotaskNotifications = 0;
var stackFromLastFewNotifications = [];
function trackMicrotaskNotificationForDebugging() {
  consecutiveMicrotaskNotifications++;
  if (CONSECUTIVE_MICROTASK_NOTIFICATION_LIMIT - consecutiveMicrotaskNotifications < 5) {
    const stack = new Error().stack;
    if (stack) {
      stackFromLastFewNotifications.push(stack);
    }
  }
  if (consecutiveMicrotaskNotifications === CONSECUTIVE_MICROTASK_NOTIFICATION_LIMIT) {
    throw new RuntimeError(103, "Angular could not stabilize because there were endless change notifications within the browser event loop. The stack from the last several notifications: \n" + stackFromLastFewNotifications.join("\n"));
  }
}
var ChangeDetectionSchedulerImpl = class _ChangeDetectionSchedulerImpl {
  constructor() {
    this.appRef = inject(ApplicationRef);
    this.taskService = inject(PendingTasks);
    this.ngZone = inject(NgZone);
    this.zonelessEnabled = inject(ZONELESS_ENABLED);
    this.disableScheduling = inject(ZONELESS_SCHEDULER_DISABLED, {
      optional: true
    }) ?? false;
    this.zoneIsDefined = typeof Zone !== "undefined" && !!Zone.root.run;
    this.schedulerTickApplyArgs = [{
      data: {
        "__scheduler_tick__": true
      }
    }];
    this.subscriptions = new Subscription();
    this.angularZoneId = this.zoneIsDefined ? this.ngZone._inner?.get(angularZoneInstanceIdProperty) : null;
    this.cancelScheduledCallback = null;
    this.shouldRefreshViews = false;
    this.useMicrotaskScheduler = false;
    this.runningTick = false;
    this.pendingRenderTaskId = null;
    this.subscriptions.add(this.appRef.afterTick.subscribe(() => {
      if (!this.runningTick) {
        this.cleanup();
      }
    }));
    this.subscriptions.add(this.ngZone.onUnstable.subscribe(() => {
      if (!this.runningTick) {
        this.cleanup();
      }
    }));
    this.disableScheduling ||= !this.zonelessEnabled && // NoopNgZone without enabling zoneless means no scheduling whatsoever
    (this.ngZone instanceof NoopNgZone || // The same goes for the lack of Zone without enabling zoneless scheduling
    !this.zoneIsDefined);
  }
  notify(source) {
    if (!this.zonelessEnabled && source === 5) {
      return;
    }
    switch (source) {
      case 3:
      case 2:
      case 0:
      case 4:
      case 5:
      case 1: {
        this.shouldRefreshViews = true;
        break;
      }
      case 8:
      case 7:
      case 6:
      case 9:
      default: {
      }
    }
    if (!this.shouldScheduleTick()) {
      return;
    }
    if (typeof ngDevMode === "undefined" || ngDevMode) {
      if (this.useMicrotaskScheduler) {
        trackMicrotaskNotificationForDebugging();
      } else {
        consecutiveMicrotaskNotifications = 0;
        stackFromLastFewNotifications.length = 0;
      }
    }
    const scheduleCallback = this.useMicrotaskScheduler ? scheduleCallbackWithMicrotask : scheduleCallbackWithRafRace;
    this.pendingRenderTaskId = this.taskService.add();
    if (this.zoneIsDefined) {
      Zone.root.run(() => {
        this.cancelScheduledCallback = scheduleCallback(() => {
          this.tick(this.shouldRefreshViews);
        });
      });
    } else {
      this.cancelScheduledCallback = scheduleCallback(() => {
        this.tick(this.shouldRefreshViews);
      });
    }
  }
  shouldScheduleTick() {
    if (this.disableScheduling) {
      return false;
    }
    if (this.pendingRenderTaskId !== null || this.runningTick || this.appRef._runningTick) {
      return false;
    }
    if (!this.zonelessEnabled && this.zoneIsDefined && Zone.current.get(angularZoneInstanceIdProperty + this.angularZoneId)) {
      return false;
    }
    return true;
  }
  /**
   * Calls ApplicationRef._tick inside the `NgZone`.
   *
   * Calling `tick` directly runs change detection and cancels any change detection that had been
   * scheduled previously.
   *
   * @param shouldRefreshViews Passed directly to `ApplicationRef._tick` and skips straight to
   *     render hooks when `false`.
   */
  tick(shouldRefreshViews) {
    if (this.runningTick || this.appRef.destroyed) {
      return;
    }
    const task = this.taskService.add();
    try {
      this.ngZone.run(() => {
        this.runningTick = true;
        this.appRef._tick(shouldRefreshViews);
      }, void 0, this.schedulerTickApplyArgs);
    } catch (e) {
      this.taskService.remove(task);
      throw e;
    } finally {
      this.cleanup();
    }
    this.useMicrotaskScheduler = true;
    scheduleCallbackWithMicrotask(() => {
      this.useMicrotaskScheduler = false;
      this.taskService.remove(task);
    });
  }
  ngOnDestroy() {
    this.subscriptions.unsubscribe();
    this.cleanup();
  }
  cleanup() {
    this.shouldRefreshViews = false;
    this.runningTick = false;
    this.cancelScheduledCallback?.();
    this.cancelScheduledCallback = null;
    if (this.pendingRenderTaskId !== null) {
      const taskId = this.pendingRenderTaskId;
      this.pendingRenderTaskId = null;
      this.taskService.remove(taskId);
    }
  }
  static {
    this.ɵfac = function ChangeDetectionSchedulerImpl_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _ChangeDetectionSchedulerImpl)();
    };
  }
  static {
    this.ɵprov = ɵɵdefineInjectable({
      token: _ChangeDetectionSchedulerImpl,
      factory: _ChangeDetectionSchedulerImpl.ɵfac,
      providedIn: "root"
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ChangeDetectionSchedulerImpl, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], () => [], null);
})();
function getGlobalLocale() {
  if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode && typeof goog !== "undefined" && goog.LOCALE !== "en") {
    return goog.LOCALE;
  } else {
    return typeof $localize !== "undefined" && $localize.locale || DEFAULT_LOCALE_ID;
  }
}
var LOCALE_ID = new InjectionToken(ngDevMode ? "LocaleId" : "", {
  providedIn: "root",
  factory: () => inject(LOCALE_ID, InjectFlags.Optional | InjectFlags.SkipSelf) || getGlobalLocale()
});
var DEFAULT_CURRENCY_CODE = new InjectionToken(ngDevMode ? "DefaultCurrencyCode" : "", {
  providedIn: "root",
  factory: () => USD_CURRENCY_CODE
});
var TRANSLATIONS = new InjectionToken(ngDevMode ? "Translations" : "");
var TRANSLATIONS_FORMAT = new InjectionToken(ngDevMode ? "TranslationsFormat" : "");
var MissingTranslationStrategy;
(function(MissingTranslationStrategy2) {
  MissingTranslationStrategy2[MissingTranslationStrategy2["Error"] = 0] = "Error";
  MissingTranslationStrategy2[MissingTranslationStrategy2["Warning"] = 1] = "Warning";
  MissingTranslationStrategy2[MissingTranslationStrategy2["Ignore"] = 2] = "Ignore";
})(MissingTranslationStrategy || (MissingTranslationStrategy = {}));
var SCAN_DELAY = 200;
var OVERSIZED_IMAGE_TOLERANCE = 1200;
var ImagePerformanceWarning = class _ImagePerformanceWarning {
  constructor() {
    this.window = null;
    this.observer = null;
    this.options = inject(IMAGE_CONFIG);
    this.isBrowser = inject(PLATFORM_ID) === "browser";
  }
  start() {
    if (!this.isBrowser || typeof PerformanceObserver === "undefined" || this.options?.disableImageSizeWarning && this.options?.disableImageLazyLoadWarning) {
      return;
    }
    this.observer = this.initPerformanceObserver();
    const doc = getDocument();
    const win = doc.defaultView;
    if (typeof win !== "undefined") {
      this.window = win;
      const waitToScan = () => {
        setTimeout(this.scanImages.bind(this), SCAN_DELAY);
      };
      const setup = () => {
        if (doc.readyState === "complete") {
          waitToScan();
        } else {
          this.window?.addEventListener("load", waitToScan, {
            once: true
          });
        }
      };
      if (typeof Zone !== "undefined") {
        Zone.root.run(() => setup());
      } else {
        setup();
      }
    }
  }
  ngOnDestroy() {
    this.observer?.disconnect();
  }
  initPerformanceObserver() {
    if (typeof PerformanceObserver === "undefined") {
      return null;
    }
    const observer = new PerformanceObserver((entryList) => {
      const entries = entryList.getEntries();
      if (entries.length === 0) return;
      const lcpElement = entries[entries.length - 1];
      const imgSrc = lcpElement.element?.src ?? "";
      if (imgSrc.startsWith("data:") || imgSrc.startsWith("blob:")) return;
      this.lcpImageUrl = imgSrc;
    });
    observer.observe({
      type: "largest-contentful-paint",
      buffered: true
    });
    return observer;
  }
  scanImages() {
    const images = getDocument().querySelectorAll("img");
    let lcpElementFound, lcpElementLoadedCorrectly = false;
    images.forEach((image) => {
      if (!this.options?.disableImageSizeWarning) {
        for (const image2 of images) {
          if (!image2.getAttribute("ng-img") && this.isOversized(image2)) {
            logOversizedImageWarning(image2.src);
          }
        }
      }
      if (!this.options?.disableImageLazyLoadWarning && this.lcpImageUrl) {
        if (image.src === this.lcpImageUrl) {
          lcpElementFound = true;
          if (image.loading !== "lazy" || image.getAttribute("ng-img")) {
            lcpElementLoadedCorrectly = true;
          }
        }
      }
    });
    if (lcpElementFound && !lcpElementLoadedCorrectly && this.lcpImageUrl && !this.options?.disableImageLazyLoadWarning) {
      logLazyLCPWarning(this.lcpImageUrl);
    }
  }
  isOversized(image) {
    if (!this.window) {
      return false;
    }
    const computedStyle = this.window.getComputedStyle(image);
    let renderedWidth = parseFloat(computedStyle.getPropertyValue("width"));
    let renderedHeight = parseFloat(computedStyle.getPropertyValue("height"));
    const boxSizing = computedStyle.getPropertyValue("box-sizing");
    const objectFit = computedStyle.getPropertyValue("object-fit");
    if (objectFit === `cover`) {
      return false;
    }
    if (boxSizing === "border-box") {
      const paddingTop = computedStyle.getPropertyValue("padding-top");
      const paddingRight = computedStyle.getPropertyValue("padding-right");
      const paddingBottom = computedStyle.getPropertyValue("padding-bottom");
      const paddingLeft = computedStyle.getPropertyValue("padding-left");
      renderedWidth -= parseFloat(paddingRight) + parseFloat(paddingLeft);
      renderedHeight -= parseFloat(paddingTop) + parseFloat(paddingBottom);
    }
    const intrinsicWidth = image.naturalWidth;
    const intrinsicHeight = image.naturalHeight;
    const recommendedWidth = this.window.devicePixelRatio * renderedWidth;
    const recommendedHeight = this.window.devicePixelRatio * renderedHeight;
    const oversizedWidth = intrinsicWidth - recommendedWidth >= OVERSIZED_IMAGE_TOLERANCE;
    const oversizedHeight = intrinsicHeight - recommendedHeight >= OVERSIZED_IMAGE_TOLERANCE;
    return oversizedWidth || oversizedHeight;
  }
  static {
    this.ɵfac = function ImagePerformanceWarning_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _ImagePerformanceWarning)();
    };
  }
  static {
    this.ɵprov = ɵɵdefineInjectable({
      token: _ImagePerformanceWarning,
      factory: _ImagePerformanceWarning.ɵfac,
      providedIn: "root"
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ImagePerformanceWarning, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], null, null);
})();
function logLazyLCPWarning(src) {
  console.warn(formatRuntimeError(-913, `An image with src ${src} is the Largest Contentful Paint (LCP) element but was given a "loading" value of "lazy", which can negatively impact application loading performance. This warning can be addressed by changing the loading value of the LCP image to "eager", or by using the NgOptimizedImage directive's prioritization utilities. For more information about addressing or disabling this warning, see https://angular.dev/errors/NG0913`));
}
function logOversizedImageWarning(src) {
  console.warn(formatRuntimeError(-913, `An image with src ${src} has intrinsic file dimensions much larger than its rendered size. This can negatively impact application loading performance. For more information about addressing or disabling this warning, see https://angular.dev/errors/NG0913`));
}
var PLATFORM_DESTROY_LISTENERS = new InjectionToken(ngDevMode ? "PlatformDestroyListeners" : "");
function isApplicationBootstrapConfig(config) {
  return !!config.platformInjector;
}
function bootstrap(config) {
  const envInjector = isApplicationBootstrapConfig(config) ? config.r3Injector : config.moduleRef.injector;
  const ngZone = envInjector.get(NgZone);
  return ngZone.run(() => {
    if (isApplicationBootstrapConfig(config)) {
      config.r3Injector.resolveInjectorInitializers();
    } else {
      config.moduleRef.resolveInjectorInitializers();
    }
    const exceptionHandler = envInjector.get(ErrorHandler, null);
    if (typeof ngDevMode === "undefined" || ngDevMode) {
      if (exceptionHandler === null) {
        const errorMessage = isApplicationBootstrapConfig(config) ? "No `ErrorHandler` found in the Dependency Injection tree." : "No ErrorHandler. Is platform module (BrowserModule) included";
        throw new RuntimeError(402, errorMessage);
      }
      if (envInjector.get(PROVIDED_ZONELESS) && envInjector.get(PROVIDED_NG_ZONE)) {
        throw new RuntimeError(408, "Invalid change detection configuration: provideZoneChangeDetection and provideExperimentalZonelessChangeDetection cannot be used together.");
      }
    }
    let onErrorSubscription;
    ngZone.runOutsideAngular(() => {
      onErrorSubscription = ngZone.onError.subscribe({
        next: (error) => {
          exceptionHandler.handleError(error);
        }
      });
    });
    if (isApplicationBootstrapConfig(config)) {
      const destroyListener = () => envInjector.destroy();
      const onPlatformDestroyListeners = config.platformInjector.get(PLATFORM_DESTROY_LISTENERS);
      onPlatformDestroyListeners.add(destroyListener);
      envInjector.onDestroy(() => {
        onErrorSubscription.unsubscribe();
        onPlatformDestroyListeners.delete(destroyListener);
      });
    } else {
      config.moduleRef.onDestroy(() => {
        remove(config.allPlatformModules, config.moduleRef);
        onErrorSubscription.unsubscribe();
      });
    }
    return _callAndReportToErrorHandler(exceptionHandler, ngZone, () => {
      const initStatus = envInjector.get(ApplicationInitStatus);
      initStatus.runInitializers();
      return initStatus.donePromise.then(() => {
        const localeId = envInjector.get(LOCALE_ID, DEFAULT_LOCALE_ID);
        setLocaleId(localeId || DEFAULT_LOCALE_ID);
        if (typeof ngDevMode === "undefined" || ngDevMode) {
          const imagePerformanceService = envInjector.get(ImagePerformanceWarning);
          imagePerformanceService.start();
        }
        if (isApplicationBootstrapConfig(config)) {
          const appRef = envInjector.get(ApplicationRef);
          if (config.rootComponent !== void 0) {
            appRef.bootstrap(config.rootComponent);
          }
          return appRef;
        } else {
          moduleDoBootstrap(config.moduleRef, config.allPlatformModules);
          return config.moduleRef;
        }
      });
    });
  });
}
function moduleDoBootstrap(moduleRef, allPlatformModules) {
  const appRef = moduleRef.injector.get(ApplicationRef);
  if (moduleRef._bootstrapComponents.length > 0) {
    moduleRef._bootstrapComponents.forEach((f) => appRef.bootstrap(f));
  } else if (moduleRef.instance.ngDoBootstrap) {
    moduleRef.instance.ngDoBootstrap(appRef);
  } else {
    throw new RuntimeError(-403, ngDevMode && `The module ${stringify(moduleRef.instance.constructor)} was bootstrapped, but it does not declare "@NgModule.bootstrap" components nor a "ngDoBootstrap" method. Please define one of these.`);
  }
  allPlatformModules.push(moduleRef);
}
var PlatformRef = class _PlatformRef {
  /** @internal */
  constructor(_injector) {
    this._injector = _injector;
    this._modules = [];
    this._destroyListeners = [];
    this._destroyed = false;
  }
  /**
   * Creates an instance of an `@NgModule` for the given platform.
   *
   * @deprecated Passing NgModule factories as the `PlatformRef.bootstrapModuleFactory` function
   *     argument is deprecated. Use the `PlatformRef.bootstrapModule` API instead.
   */
  bootstrapModuleFactory(moduleFactory, options) {
    const ngZoneFactory = () => getNgZone(options?.ngZone, getNgZoneOptions({
      eventCoalescing: options?.ngZoneEventCoalescing,
      runCoalescing: options?.ngZoneRunCoalescing
    }));
    const ignoreChangesOutsideZone = options?.ignoreChangesOutsideZone;
    const allAppProviders = [internalProvideZoneChangeDetection({
      ngZoneFactory,
      ignoreChangesOutsideZone
    }), {
      provide: ChangeDetectionScheduler,
      useExisting: ChangeDetectionSchedulerImpl
    }];
    const moduleRef = createNgModuleRefWithProviders(moduleFactory.moduleType, this.injector, allAppProviders);
    return bootstrap({
      moduleRef,
      allPlatformModules: this._modules
    });
  }
  /**
   * Creates an instance of an `@NgModule` for a given platform.
   *
   * @usageNotes
   * ### Simple Example
   *
   * ```typescript
   * @NgModule({
   *   imports: [BrowserModule]
   * })
   * class MyModule {}
   *
   * let moduleRef = platformBrowser().bootstrapModule(MyModule);
   * ```
   *
   */
  bootstrapModule(moduleType, compilerOptions = []) {
    const options = optionsReducer({}, compilerOptions);
    return compileNgModuleFactory(this.injector, options, moduleType).then((moduleFactory) => this.bootstrapModuleFactory(moduleFactory, options));
  }
  /**
   * Registers a listener to be called when the platform is destroyed.
   */
  onDestroy(callback) {
    this._destroyListeners.push(callback);
  }
  /**
   * Retrieves the platform {@link Injector}, which is the parent injector for
   * every Angular application on the page and provides singleton providers.
   */
  get injector() {
    return this._injector;
  }
  /**
   * Destroys the current Angular platform and all Angular applications on the page.
   * Destroys all modules and listeners registered with the platform.
   */
  destroy() {
    if (this._destroyed) {
      throw new RuntimeError(404, ngDevMode && "The platform has already been destroyed!");
    }
    this._modules.slice().forEach((module) => module.destroy());
    this._destroyListeners.forEach((listener) => listener());
    const destroyListeners = this._injector.get(PLATFORM_DESTROY_LISTENERS, null);
    if (destroyListeners) {
      destroyListeners.forEach((listener) => listener());
      destroyListeners.clear();
    }
    this._destroyed = true;
  }
  /**
   * Indicates whether this instance was destroyed.
   */
  get destroyed() {
    return this._destroyed;
  }
  static {
    this.ɵfac = function PlatformRef_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _PlatformRef)(ɵɵinject(Injector));
    };
  }
  static {
    this.ɵprov = ɵɵdefineInjectable({
      token: _PlatformRef,
      factory: _PlatformRef.ɵfac,
      providedIn: "platform"
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PlatformRef, [{
    type: Injectable,
    args: [{
      providedIn: "platform"
    }]
  }], () => [{
    type: Injector
  }], null);
})();
var _platformInjector = null;
var ALLOW_MULTIPLE_PLATFORMS = new InjectionToken(ngDevMode ? "AllowMultipleToken" : "");
function createPlatform(injector) {
  if (_platformInjector && !_platformInjector.get(ALLOW_MULTIPLE_PLATFORMS, false)) {
    throw new RuntimeError(400, ngDevMode && "There can be only one platform. Destroy the previous one to create a new one.");
  }
  publishDefaultGlobalUtils();
  publishSignalConfiguration();
  _platformInjector = injector;
  const platform = injector.get(PlatformRef);
  runPlatformInitializers(injector);
  return platform;
}
function createPlatformFactory(parentPlatformFactory, name, providers = []) {
  const desc = `Platform: ${name}`;
  const marker = new InjectionToken(desc);
  return (extraProviders = []) => {
    let platform = getPlatform();
    if (!platform || platform.injector.get(ALLOW_MULTIPLE_PLATFORMS, false)) {
      const platformProviders = [...providers, ...extraProviders, {
        provide: marker,
        useValue: true
      }];
      if (parentPlatformFactory) {
        parentPlatformFactory(platformProviders);
      } else {
        createPlatform(createPlatformInjector(platformProviders, desc));
      }
    }
    return assertPlatform(marker);
  };
}
function createPlatformInjector(providers = [], name) {
  return Injector.create({
    name,
    providers: [{
      provide: INJECTOR_SCOPE,
      useValue: "platform"
    }, {
      provide: PLATFORM_DESTROY_LISTENERS,
      useValue: /* @__PURE__ */ new Set([() => _platformInjector = null])
    }, ...providers]
  });
}
function assertPlatform(requiredToken) {
  const platform = getPlatform();
  if (!platform) {
    throw new RuntimeError(401, ngDevMode && "No platform exists!");
  }
  if ((typeof ngDevMode === "undefined" || ngDevMode) && !platform.injector.get(requiredToken, null)) {
    throw new RuntimeError(400, "A platform with a different configuration has been created. Please destroy it first.");
  }
  return platform;
}
function getPlatform() {
  return _platformInjector?.get(PlatformRef) ?? null;
}
function runPlatformInitializers(injector) {
  const inits = injector.get(PLATFORM_INITIALIZER, null);
  inits?.forEach((init) => init());
}
var ChangeDetectorRef = class {
  static {
    this.__NG_ELEMENT_ID__ = injectChangeDetectorRef;
  }
};
function injectChangeDetectorRef(flags) {
  return createViewRef(
    getCurrentTNode(),
    getLView(),
    (flags & 16) === 16
    /* InternalInjectFlags.ForPipe */
  );
}
function createViewRef(tNode, lView, isPipe2) {
  if (isComponentHost(tNode) && !isPipe2) {
    const componentView = getComponentLViewByIndex(tNode.index, lView);
    return new ViewRef$1(componentView, componentView);
  } else if (tNode.type & (3 | 12 | 32 | 128)) {
    const hostComponentView = lView[DECLARATION_COMPONENT_VIEW];
    return new ViewRef$1(hostComponentView, lView);
  }
  return null;
}
var DefaultIterableDifferFactory = class {
  constructor() {
  }
  supports(obj) {
    return isListLikeIterable(obj);
  }
  create(trackByFn) {
    return new DefaultIterableDiffer(trackByFn);
  }
};
var trackByIdentity = (index, item) => item;
var DefaultIterableDiffer = class {
  constructor(trackByFn) {
    this.length = 0;
    this._linkedRecords = null;
    this._unlinkedRecords = null;
    this._previousItHead = null;
    this._itHead = null;
    this._itTail = null;
    this._additionsHead = null;
    this._additionsTail = null;
    this._movesHead = null;
    this._movesTail = null;
    this._removalsHead = null;
    this._removalsTail = null;
    this._identityChangesHead = null;
    this._identityChangesTail = null;
    this._trackByFn = trackByFn || trackByIdentity;
  }
  forEachItem(fn) {
    let record;
    for (record = this._itHead; record !== null; record = record._next) {
      fn(record);
    }
  }
  forEachOperation(fn) {
    let nextIt = this._itHead;
    let nextRemove = this._removalsHead;
    let addRemoveOffset = 0;
    let moveOffsets = null;
    while (nextIt || nextRemove) {
      const record = !nextRemove || nextIt && nextIt.currentIndex < getPreviousIndex(nextRemove, addRemoveOffset, moveOffsets) ? nextIt : nextRemove;
      const adjPreviousIndex = getPreviousIndex(record, addRemoveOffset, moveOffsets);
      const currentIndex = record.currentIndex;
      if (record === nextRemove) {
        addRemoveOffset--;
        nextRemove = nextRemove._nextRemoved;
      } else {
        nextIt = nextIt._next;
        if (record.previousIndex == null) {
          addRemoveOffset++;
        } else {
          if (!moveOffsets) moveOffsets = [];
          const localMovePreviousIndex = adjPreviousIndex - addRemoveOffset;
          const localCurrentIndex = currentIndex - addRemoveOffset;
          if (localMovePreviousIndex != localCurrentIndex) {
            for (let i = 0; i < localMovePreviousIndex; i++) {
              const offset = i < moveOffsets.length ? moveOffsets[i] : moveOffsets[i] = 0;
              const index = offset + i;
              if (localCurrentIndex <= index && index < localMovePreviousIndex) {
                moveOffsets[i] = offset + 1;
              }
            }
            const previousIndex = record.previousIndex;
            moveOffsets[previousIndex] = localCurrentIndex - localMovePreviousIndex;
          }
        }
      }
      if (adjPreviousIndex !== currentIndex) {
        fn(record, adjPreviousIndex, currentIndex);
      }
    }
  }
  forEachPreviousItem(fn) {
    let record;
    for (record = this._previousItHead; record !== null; record = record._nextPrevious) {
      fn(record);
    }
  }
  forEachAddedItem(fn) {
    let record;
    for (record = this._additionsHead; record !== null; record = record._nextAdded) {
      fn(record);
    }
  }
  forEachMovedItem(fn) {
    let record;
    for (record = this._movesHead; record !== null; record = record._nextMoved) {
      fn(record);
    }
  }
  forEachRemovedItem(fn) {
    let record;
    for (record = this._removalsHead; record !== null; record = record._nextRemoved) {
      fn(record);
    }
  }
  forEachIdentityChange(fn) {
    let record;
    for (record = this._identityChangesHead; record !== null; record = record._nextIdentityChange) {
      fn(record);
    }
  }
  diff(collection) {
    if (collection == null) collection = [];
    if (!isListLikeIterable(collection)) {
      throw new RuntimeError(900, ngDevMode && `Error trying to diff '${stringify(collection)}'. Only arrays and iterables are allowed`);
    }
    if (this.check(collection)) {
      return this;
    } else {
      return null;
    }
  }
  onDestroy() {
  }
  check(collection) {
    this._reset();
    let record = this._itHead;
    let mayBeDirty = false;
    let index;
    let item;
    let itemTrackBy;
    if (Array.isArray(collection)) {
      this.length = collection.length;
      for (let index2 = 0; index2 < this.length; index2++) {
        item = collection[index2];
        itemTrackBy = this._trackByFn(index2, item);
        if (record === null || !Object.is(record.trackById, itemTrackBy)) {
          record = this._mismatch(record, item, itemTrackBy, index2);
          mayBeDirty = true;
        } else {
          if (mayBeDirty) {
            record = this._verifyReinsertion(record, item, itemTrackBy, index2);
          }
          if (!Object.is(record.item, item)) this._addIdentityChange(record, item);
        }
        record = record._next;
      }
    } else {
      index = 0;
      iterateListLike(collection, (item2) => {
        itemTrackBy = this._trackByFn(index, item2);
        if (record === null || !Object.is(record.trackById, itemTrackBy)) {
          record = this._mismatch(record, item2, itemTrackBy, index);
          mayBeDirty = true;
        } else {
          if (mayBeDirty) {
            record = this._verifyReinsertion(record, item2, itemTrackBy, index);
          }
          if (!Object.is(record.item, item2)) this._addIdentityChange(record, item2);
        }
        record = record._next;
        index++;
      });
      this.length = index;
    }
    this._truncate(record);
    this.collection = collection;
    return this.isDirty;
  }
  /* CollectionChanges is considered dirty if it has any additions, moves, removals, or identity
   * changes.
   */
  get isDirty() {
    return this._additionsHead !== null || this._movesHead !== null || this._removalsHead !== null || this._identityChangesHead !== null;
  }
  /**
   * Reset the state of the change objects to show no changes. This means set previousKey to
   * currentKey, and clear all of the queues (additions, moves, removals).
   * Set the previousIndexes of moved and added items to their currentIndexes
   * Reset the list of additions, moves and removals
   *
   * @internal
   */
  _reset() {
    if (this.isDirty) {
      let record;
      for (record = this._previousItHead = this._itHead; record !== null; record = record._next) {
        record._nextPrevious = record._next;
      }
      for (record = this._additionsHead; record !== null; record = record._nextAdded) {
        record.previousIndex = record.currentIndex;
      }
      this._additionsHead = this._additionsTail = null;
      for (record = this._movesHead; record !== null; record = record._nextMoved) {
        record.previousIndex = record.currentIndex;
      }
      this._movesHead = this._movesTail = null;
      this._removalsHead = this._removalsTail = null;
      this._identityChangesHead = this._identityChangesTail = null;
    }
  }
  /**
   * This is the core function which handles differences between collections.
   *
   * - `record` is the record which we saw at this position last time. If null then it is a new
   *   item.
   * - `item` is the current item in the collection
   * - `index` is the position of the item in the collection
   *
   * @internal
   */
  _mismatch(record, item, itemTrackBy, index) {
    let previousRecord;
    if (record === null) {
      previousRecord = this._itTail;
    } else {
      previousRecord = record._prev;
      this._remove(record);
    }
    record = this._unlinkedRecords === null ? null : this._unlinkedRecords.get(itemTrackBy, null);
    if (record !== null) {
      if (!Object.is(record.item, item)) this._addIdentityChange(record, item);
      this._reinsertAfter(record, previousRecord, index);
    } else {
      record = this._linkedRecords === null ? null : this._linkedRecords.get(itemTrackBy, index);
      if (record !== null) {
        if (!Object.is(record.item, item)) this._addIdentityChange(record, item);
        this._moveAfter(record, previousRecord, index);
      } else {
        record = this._addAfter(new IterableChangeRecord_(item, itemTrackBy), previousRecord, index);
      }
    }
    return record;
  }
  /**
   * This check is only needed if an array contains duplicates. (Short circuit of nothing dirty)
   *
   * Use case: `[a, a]` => `[b, a, a]`
   *
   * If we did not have this check then the insertion of `b` would:
   *   1) evict first `a`
   *   2) insert `b` at `0` index.
   *   3) leave `a` at index `1` as is. <-- this is wrong!
   *   3) reinsert `a` at index 2. <-- this is wrong!
   *
   * The correct behavior is:
   *   1) evict first `a`
   *   2) insert `b` at `0` index.
   *   3) reinsert `a` at index 1.
   *   3) move `a` at from `1` to `2`.
   *
   *
   * Double check that we have not evicted a duplicate item. We need to check if the item type may
   * have already been removed:
   * The insertion of b will evict the first 'a'. If we don't reinsert it now it will be reinserted
   * at the end. Which will show up as the two 'a's switching position. This is incorrect, since a
   * better way to think of it is as insert of 'b' rather then switch 'a' with 'b' and then add 'a'
   * at the end.
   *
   * @internal
   */
  _verifyReinsertion(record, item, itemTrackBy, index) {
    let reinsertRecord = this._unlinkedRecords === null ? null : this._unlinkedRecords.get(itemTrackBy, null);
    if (reinsertRecord !== null) {
      record = this._reinsertAfter(reinsertRecord, record._prev, index);
    } else if (record.currentIndex != index) {
      record.currentIndex = index;
      this._addToMoves(record, index);
    }
    return record;
  }
  /**
   * Get rid of any excess {@link IterableChangeRecord_}s from the previous collection
   *
   * - `record` The first excess {@link IterableChangeRecord_}.
   *
   * @internal
   */
  _truncate(record) {
    while (record !== null) {
      const nextRecord = record._next;
      this._addToRemovals(this._unlink(record));
      record = nextRecord;
    }
    if (this._unlinkedRecords !== null) {
      this._unlinkedRecords.clear();
    }
    if (this._additionsTail !== null) {
      this._additionsTail._nextAdded = null;
    }
    if (this._movesTail !== null) {
      this._movesTail._nextMoved = null;
    }
    if (this._itTail !== null) {
      this._itTail._next = null;
    }
    if (this._removalsTail !== null) {
      this._removalsTail._nextRemoved = null;
    }
    if (this._identityChangesTail !== null) {
      this._identityChangesTail._nextIdentityChange = null;
    }
  }
  /** @internal */
  _reinsertAfter(record, prevRecord, index) {
    if (this._unlinkedRecords !== null) {
      this._unlinkedRecords.remove(record);
    }
    const prev = record._prevRemoved;
    const next = record._nextRemoved;
    if (prev === null) {
      this._removalsHead = next;
    } else {
      prev._nextRemoved = next;
    }
    if (next === null) {
      this._removalsTail = prev;
    } else {
      next._prevRemoved = prev;
    }
    this._insertAfter(record, prevRecord, index);
    this._addToMoves(record, index);
    return record;
  }
  /** @internal */
  _moveAfter(record, prevRecord, index) {
    this._unlink(record);
    this._insertAfter(record, prevRecord, index);
    this._addToMoves(record, index);
    return record;
  }
  /** @internal */
  _addAfter(record, prevRecord, index) {
    this._insertAfter(record, prevRecord, index);
    if (this._additionsTail === null) {
      this._additionsTail = this._additionsHead = record;
    } else {
      this._additionsTail = this._additionsTail._nextAdded = record;
    }
    return record;
  }
  /** @internal */
  _insertAfter(record, prevRecord, index) {
    const next = prevRecord === null ? this._itHead : prevRecord._next;
    record._next = next;
    record._prev = prevRecord;
    if (next === null) {
      this._itTail = record;
    } else {
      next._prev = record;
    }
    if (prevRecord === null) {
      this._itHead = record;
    } else {
      prevRecord._next = record;
    }
    if (this._linkedRecords === null) {
      this._linkedRecords = new _DuplicateMap();
    }
    this._linkedRecords.put(record);
    record.currentIndex = index;
    return record;
  }
  /** @internal */
  _remove(record) {
    return this._addToRemovals(this._unlink(record));
  }
  /** @internal */
  _unlink(record) {
    if (this._linkedRecords !== null) {
      this._linkedRecords.remove(record);
    }
    const prev = record._prev;
    const next = record._next;
    if (prev === null) {
      this._itHead = next;
    } else {
      prev._next = next;
    }
    if (next === null) {
      this._itTail = prev;
    } else {
      next._prev = prev;
    }
    return record;
  }
  /** @internal */
  _addToMoves(record, toIndex) {
    if (record.previousIndex === toIndex) {
      return record;
    }
    if (this._movesTail === null) {
      this._movesTail = this._movesHead = record;
    } else {
      this._movesTail = this._movesTail._nextMoved = record;
    }
    return record;
  }
  _addToRemovals(record) {
    if (this._unlinkedRecords === null) {
      this._unlinkedRecords = new _DuplicateMap();
    }
    this._unlinkedRecords.put(record);
    record.currentIndex = null;
    record._nextRemoved = null;
    if (this._removalsTail === null) {
      this._removalsTail = this._removalsHead = record;
      record._prevRemoved = null;
    } else {
      record._prevRemoved = this._removalsTail;
      this._removalsTail = this._removalsTail._nextRemoved = record;
    }
    return record;
  }
  /** @internal */
  _addIdentityChange(record, item) {
    record.item = item;
    if (this._identityChangesTail === null) {
      this._identityChangesTail = this._identityChangesHead = record;
    } else {
      this._identityChangesTail = this._identityChangesTail._nextIdentityChange = record;
    }
    return record;
  }
};
var IterableChangeRecord_ = class {
  constructor(item, trackById) {
    this.item = item;
    this.trackById = trackById;
    this.currentIndex = null;
    this.previousIndex = null;
    this._nextPrevious = null;
    this._prev = null;
    this._next = null;
    this._prevDup = null;
    this._nextDup = null;
    this._prevRemoved = null;
    this._nextRemoved = null;
    this._nextAdded = null;
    this._nextMoved = null;
    this._nextIdentityChange = null;
  }
};
var _DuplicateItemRecordList = class {
  constructor() {
    this._head = null;
    this._tail = null;
  }
  /**
   * Append the record to the list of duplicates.
   *
   * Note: by design all records in the list of duplicates hold the same value in record.item.
   */
  add(record) {
    if (this._head === null) {
      this._head = this._tail = record;
      record._nextDup = null;
      record._prevDup = null;
    } else {
      this._tail._nextDup = record;
      record._prevDup = this._tail;
      record._nextDup = null;
      this._tail = record;
    }
  }
  // Returns a IterableChangeRecord_ having IterableChangeRecord_.trackById == trackById and
  // IterableChangeRecord_.currentIndex >= atOrAfterIndex
  get(trackById, atOrAfterIndex) {
    let record;
    for (record = this._head; record !== null; record = record._nextDup) {
      if ((atOrAfterIndex === null || atOrAfterIndex <= record.currentIndex) && Object.is(record.trackById, trackById)) {
        return record;
      }
    }
    return null;
  }
  /**
   * Remove one {@link IterableChangeRecord_} from the list of duplicates.
   *
   * Returns whether the list of duplicates is empty.
   */
  remove(record) {
    const prev = record._prevDup;
    const next = record._nextDup;
    if (prev === null) {
      this._head = next;
    } else {
      prev._nextDup = next;
    }
    if (next === null) {
      this._tail = prev;
    } else {
      next._prevDup = prev;
    }
    return this._head === null;
  }
};
var _DuplicateMap = class {
  constructor() {
    this.map = /* @__PURE__ */ new Map();
  }
  put(record) {
    const key = record.trackById;
    let duplicates = this.map.get(key);
    if (!duplicates) {
      duplicates = new _DuplicateItemRecordList();
      this.map.set(key, duplicates);
    }
    duplicates.add(record);
  }
  /**
   * Retrieve the `value` using key. Because the IterableChangeRecord_ value may be one which we
   * have already iterated over, we use the `atOrAfterIndex` to pretend it is not there.
   *
   * Use case: `[a, b, c, a, a]` if we are at index `3` which is the second `a` then asking if we
   * have any more `a`s needs to return the second `a`.
   */
  get(trackById, atOrAfterIndex) {
    const key = trackById;
    const recordList = this.map.get(key);
    return recordList ? recordList.get(trackById, atOrAfterIndex) : null;
  }
  /**
   * Removes a {@link IterableChangeRecord_} from the list of duplicates.
   *
   * The list of duplicates also is removed from the map if it gets empty.
   */
  remove(record) {
    const key = record.trackById;
    const recordList = this.map.get(key);
    if (recordList.remove(record)) {
      this.map.delete(key);
    }
    return record;
  }
  get isEmpty() {
    return this.map.size === 0;
  }
  clear() {
    this.map.clear();
  }
};
function getPreviousIndex(item, addRemoveOffset, moveOffsets) {
  const previousIndex = item.previousIndex;
  if (previousIndex === null) return previousIndex;
  let moveOffset = 0;
  if (moveOffsets && previousIndex < moveOffsets.length) {
    moveOffset = moveOffsets[previousIndex];
  }
  return previousIndex + addRemoveOffset + moveOffset;
}
var DefaultKeyValueDifferFactory = class {
  constructor() {
  }
  supports(obj) {
    return obj instanceof Map || isJsObject(obj);
  }
  create() {
    return new DefaultKeyValueDiffer();
  }
};
var DefaultKeyValueDiffer = class {
  constructor() {
    this._records = /* @__PURE__ */ new Map();
    this._mapHead = null;
    this._appendAfter = null;
    this._previousMapHead = null;
    this._changesHead = null;
    this._changesTail = null;
    this._additionsHead = null;
    this._additionsTail = null;
    this._removalsHead = null;
    this._removalsTail = null;
  }
  get isDirty() {
    return this._additionsHead !== null || this._changesHead !== null || this._removalsHead !== null;
  }
  forEachItem(fn) {
    let record;
    for (record = this._mapHead; record !== null; record = record._next) {
      fn(record);
    }
  }
  forEachPreviousItem(fn) {
    let record;
    for (record = this._previousMapHead; record !== null; record = record._nextPrevious) {
      fn(record);
    }
  }
  forEachChangedItem(fn) {
    let record;
    for (record = this._changesHead; record !== null; record = record._nextChanged) {
      fn(record);
    }
  }
  forEachAddedItem(fn) {
    let record;
    for (record = this._additionsHead; record !== null; record = record._nextAdded) {
      fn(record);
    }
  }
  forEachRemovedItem(fn) {
    let record;
    for (record = this._removalsHead; record !== null; record = record._nextRemoved) {
      fn(record);
    }
  }
  diff(map2) {
    if (!map2) {
      map2 = /* @__PURE__ */ new Map();
    } else if (!(map2 instanceof Map || isJsObject(map2))) {
      throw new RuntimeError(900, ngDevMode && `Error trying to diff '${stringify(map2)}'. Only maps and objects are allowed`);
    }
    return this.check(map2) ? this : null;
  }
  onDestroy() {
  }
  /**
   * Check the current state of the map vs the previous.
   * The algorithm is optimised for when the keys do no change.
   */
  check(map2) {
    this._reset();
    let insertBefore = this._mapHead;
    this._appendAfter = null;
    this._forEach(map2, (value, key) => {
      if (insertBefore && insertBefore.key === key) {
        this._maybeAddToChanges(insertBefore, value);
        this._appendAfter = insertBefore;
        insertBefore = insertBefore._next;
      } else {
        const record = this._getOrCreateRecordForKey(key, value);
        insertBefore = this._insertBeforeOrAppend(insertBefore, record);
      }
    });
    if (insertBefore) {
      if (insertBefore._prev) {
        insertBefore._prev._next = null;
      }
      this._removalsHead = insertBefore;
      for (let record = insertBefore; record !== null; record = record._nextRemoved) {
        if (record === this._mapHead) {
          this._mapHead = null;
        }
        this._records.delete(record.key);
        record._nextRemoved = record._next;
        record.previousValue = record.currentValue;
        record.currentValue = null;
        record._prev = null;
        record._next = null;
      }
    }
    if (this._changesTail) this._changesTail._nextChanged = null;
    if (this._additionsTail) this._additionsTail._nextAdded = null;
    return this.isDirty;
  }
  /**
   * Inserts a record before `before` or append at the end of the list when `before` is null.
   *
   * Notes:
   * - This method appends at `this._appendAfter`,
   * - This method updates `this._appendAfter`,
   * - The return value is the new value for the insertion pointer.
   */
  _insertBeforeOrAppend(before, record) {
    if (before) {
      const prev = before._prev;
      record._next = before;
      record._prev = prev;
      before._prev = record;
      if (prev) {
        prev._next = record;
      }
      if (before === this._mapHead) {
        this._mapHead = record;
      }
      this._appendAfter = before;
      return before;
    }
    if (this._appendAfter) {
      this._appendAfter._next = record;
      record._prev = this._appendAfter;
    } else {
      this._mapHead = record;
    }
    this._appendAfter = record;
    return null;
  }
  _getOrCreateRecordForKey(key, value) {
    if (this._records.has(key)) {
      const record2 = this._records.get(key);
      this._maybeAddToChanges(record2, value);
      const prev = record2._prev;
      const next = record2._next;
      if (prev) {
        prev._next = next;
      }
      if (next) {
        next._prev = prev;
      }
      record2._next = null;
      record2._prev = null;
      return record2;
    }
    const record = new KeyValueChangeRecord_(key);
    this._records.set(key, record);
    record.currentValue = value;
    this._addToAdditions(record);
    return record;
  }
  /** @internal */
  _reset() {
    if (this.isDirty) {
      let record;
      this._previousMapHead = this._mapHead;
      for (record = this._previousMapHead; record !== null; record = record._next) {
        record._nextPrevious = record._next;
      }
      for (record = this._changesHead; record !== null; record = record._nextChanged) {
        record.previousValue = record.currentValue;
      }
      for (record = this._additionsHead; record != null; record = record._nextAdded) {
        record.previousValue = record.currentValue;
      }
      this._changesHead = this._changesTail = null;
      this._additionsHead = this._additionsTail = null;
      this._removalsHead = null;
    }
  }
  // Add the record or a given key to the list of changes only when the value has actually changed
  _maybeAddToChanges(record, newValue) {
    if (!Object.is(newValue, record.currentValue)) {
      record.previousValue = record.currentValue;
      record.currentValue = newValue;
      this._addToChanges(record);
    }
  }
  _addToAdditions(record) {
    if (this._additionsHead === null) {
      this._additionsHead = this._additionsTail = record;
    } else {
      this._additionsTail._nextAdded = record;
      this._additionsTail = record;
    }
  }
  _addToChanges(record) {
    if (this._changesHead === null) {
      this._changesHead = this._changesTail = record;
    } else {
      this._changesTail._nextChanged = record;
      this._changesTail = record;
    }
  }
  /** @internal */
  _forEach(obj, fn) {
    if (obj instanceof Map) {
      obj.forEach(fn);
    } else {
      Object.keys(obj).forEach((k) => fn(obj[k], k));
    }
  }
};
var KeyValueChangeRecord_ = class {
  constructor(key) {
    this.key = key;
    this.previousValue = null;
    this.currentValue = null;
    this._nextPrevious = null;
    this._next = null;
    this._prev = null;
    this._nextAdded = null;
    this._nextRemoved = null;
    this._nextChanged = null;
  }
};
function defaultIterableDiffersFactory() {
  return new IterableDiffers([new DefaultIterableDifferFactory()]);
}
var IterableDiffers = class _IterableDiffers {
  static {
    this.ɵprov = ɵɵdefineInjectable({
      token: _IterableDiffers,
      providedIn: "root",
      factory: defaultIterableDiffersFactory
    });
  }
  constructor(factories) {
    this.factories = factories;
  }
  static create(factories, parent) {
    if (parent != null) {
      const copied = parent.factories.slice();
      factories = factories.concat(copied);
    }
    return new _IterableDiffers(factories);
  }
  /**
   * Takes an array of {@link IterableDifferFactory} and returns a provider used to extend the
   * inherited {@link IterableDiffers} instance with the provided factories and return a new
   * {@link IterableDiffers} instance.
   *
   * @usageNotes
   * ### Example
   *
   * The following example shows how to extend an existing list of factories,
   * which will only be applied to the injector for this component and its children.
   * This step is all that's required to make a new {@link IterableDiffer} available.
   *
   * ```
   * @Component({
   *   viewProviders: [
   *     IterableDiffers.extend([new ImmutableListDiffer()])
   *   ]
   * })
   * ```
   */
  static extend(factories) {
    return {
      provide: _IterableDiffers,
      useFactory: (parent) => {
        return _IterableDiffers.create(factories, parent || defaultIterableDiffersFactory());
      },
      // Dependency technically isn't optional, but we can provide a better error message this way.
      deps: [[_IterableDiffers, new SkipSelf(), new Optional()]]
    };
  }
  find(iterable) {
    const factory = this.factories.find((f) => f.supports(iterable));
    if (factory != null) {
      return factory;
    } else {
      throw new RuntimeError(901, ngDevMode && `Cannot find a differ supporting object '${iterable}' of type '${getTypeNameForDebugging(iterable)}'`);
    }
  }
};
function getTypeNameForDebugging(type) {
  return type["name"] || typeof type;
}
function defaultKeyValueDiffersFactory() {
  return new KeyValueDiffers([new DefaultKeyValueDifferFactory()]);
}
var KeyValueDiffers = class _KeyValueDiffers {
  static {
    this.ɵprov = ɵɵdefineInjectable({
      token: _KeyValueDiffers,
      providedIn: "root",
      factory: defaultKeyValueDiffersFactory
    });
  }
  constructor(factories) {
    this.factories = factories;
  }
  static create(factories, parent) {
    if (parent) {
      const copied = parent.factories.slice();
      factories = factories.concat(copied);
    }
    return new _KeyValueDiffers(factories);
  }
  /**
   * Takes an array of {@link KeyValueDifferFactory} and returns a provider used to extend the
   * inherited {@link KeyValueDiffers} instance with the provided factories and return a new
   * {@link KeyValueDiffers} instance.
   *
   * @usageNotes
   * ### Example
   *
   * The following example shows how to extend an existing list of factories,
   * which will only be applied to the injector for this component and its children.
   * This step is all that's required to make a new {@link KeyValueDiffer} available.
   *
   * ```
   * @Component({
   *   viewProviders: [
   *     KeyValueDiffers.extend([new ImmutableMapDiffer()])
   *   ]
   * })
   * ```
   */
  static extend(factories) {
    return {
      provide: _KeyValueDiffers,
      useFactory: (parent) => {
        return _KeyValueDiffers.create(factories, parent || defaultKeyValueDiffersFactory());
      },
      // Dependency technically isn't optional, but we can provide a better error message this way.
      deps: [[_KeyValueDiffers, new SkipSelf(), new Optional()]]
    };
  }
  find(kv) {
    const factory = this.factories.find((f) => f.supports(kv));
    if (factory) {
      return factory;
    }
    throw new RuntimeError(901, ngDevMode && `Cannot find a differ supporting object '${kv}'`);
  }
};
var keyValDiff = [new DefaultKeyValueDifferFactory()];
var iterableDiff = [new DefaultIterableDifferFactory()];
var defaultIterableDiffers = new IterableDiffers(iterableDiff);
var defaultKeyValueDiffers = new KeyValueDiffers(keyValDiff);
var platformCore = createPlatformFactory(null, "core", []);
var ApplicationModule = class _ApplicationModule {
  // Inject ApplicationRef to make it eager...
  constructor(appRef) {
  }
  static {
    this.ɵfac = function ApplicationModule_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _ApplicationModule)(ɵɵinject(ApplicationRef));
    };
  }
  static {
    this.ɵmod = ɵɵdefineNgModule({
      type: _ApplicationModule
    });
  }
  static {
    this.ɵinj = ɵɵdefineInjector({});
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ApplicationModule, [{
    type: NgModule
  }], () => [{
    type: ApplicationRef
  }], null);
})();
function defaultEquals2(a, b) {
  return Object.is(a, b);
}
var activeConsumer2 = null;
var SIGNAL2 = Symbol("SIGNAL");
function setActiveConsumer2(consumer) {
  const prev = activeConsumer2;
  activeConsumer2 = consumer;
  return prev;
}
var REACTIVE_NODE2 = {
  version: 0,
  lastCleanEpoch: 0,
  dirty: false,
  producerNode: void 0,
  producerLastReadVersion: void 0,
  producerIndexOfThis: void 0,
  nextProducerIndex: 0,
  liveConsumerNode: void 0,
  liveConsumerIndexOfThis: void 0,
  consumerAllowSignalWrites: false,
  consumerIsAlwaysLive: false,
  producerMustRecompute: () => false,
  producerRecomputeValue: () => {
  },
  consumerMarkedDirty: () => {
  },
  consumerOnSignalRead: () => {
  }
};
function consumerBeforeComputation2(node) {
  node && (node.nextProducerIndex = 0);
  return setActiveConsumer2(node);
}
function consumerAfterComputation2(node, prevConsumer) {
  setActiveConsumer2(prevConsumer);
  if (!node || node.producerNode === void 0 || node.producerIndexOfThis === void 0 || node.producerLastReadVersion === void 0) {
    return;
  }
  if (consumerIsLive2(node)) {
    for (let i = node.nextProducerIndex; i < node.producerNode.length; i++) {
      producerRemoveLiveConsumerAtIndex2(node.producerNode[i], node.producerIndexOfThis[i]);
    }
  }
  while (node.producerNode.length > node.nextProducerIndex) {
    node.producerNode.pop();
    node.producerLastReadVersion.pop();
    node.producerIndexOfThis.pop();
  }
}
function producerRemoveLiveConsumerAtIndex2(node, idx) {
  assertProducerNode2(node);
  if (typeof ngDevMode !== "undefined" && ngDevMode && idx >= node.liveConsumerNode.length) {
    throw new Error(`Assertion error: active consumer index ${idx} is out of bounds of ${node.liveConsumerNode.length} consumers)`);
  }
  if (node.liveConsumerNode.length === 1 && isConsumerNode2(node)) {
    for (let i = 0; i < node.producerNode.length; i++) {
      producerRemoveLiveConsumerAtIndex2(node.producerNode[i], node.producerIndexOfThis[i]);
    }
  }
  const lastIdx = node.liveConsumerNode.length - 1;
  node.liveConsumerNode[idx] = node.liveConsumerNode[lastIdx];
  node.liveConsumerIndexOfThis[idx] = node.liveConsumerIndexOfThis[lastIdx];
  node.liveConsumerNode.length--;
  node.liveConsumerIndexOfThis.length--;
  if (idx < node.liveConsumerNode.length) {
    const idxProducer = node.liveConsumerIndexOfThis[idx];
    const consumer = node.liveConsumerNode[idx];
    assertConsumerNode2(consumer);
    consumer.producerIndexOfThis[idxProducer] = idx;
  }
}
function consumerIsLive2(node) {
  return node.consumerIsAlwaysLive || (node?.liveConsumerNode?.length ?? 0) > 0;
}
function assertConsumerNode2(node) {
  node.producerNode ??= [];
  node.producerIndexOfThis ??= [];
  node.producerLastReadVersion ??= [];
}
function assertProducerNode2(node) {
  node.liveConsumerNode ??= [];
  node.liveConsumerIndexOfThis ??= [];
}
function isConsumerNode2(node) {
  return node.producerNode !== void 0;
}
var UNSET2 = Symbol("UNSET");
var COMPUTING2 = Symbol("COMPUTING");
var ERRORED2 = Symbol("ERRORED");
var COMPUTED_NODE2 = (() => {
  return __spreadProps(__spreadValues({}, REACTIVE_NODE2), {
    value: UNSET2,
    dirty: true,
    error: null,
    equal: defaultEquals2,
    producerMustRecompute(node) {
      return node.value === UNSET2 || node.value === COMPUTING2;
    },
    producerRecomputeValue(node) {
      if (node.value === COMPUTING2) {
        throw new Error("Detected cycle in computations.");
      }
      const oldValue = node.value;
      node.value = COMPUTING2;
      const prevConsumer = consumerBeforeComputation2(node);
      let newValue;
      try {
        newValue = node.computation();
      } catch (err) {
        newValue = ERRORED2;
        node.error = err;
      } finally {
        consumerAfterComputation2(node, prevConsumer);
      }
      if (oldValue !== UNSET2 && oldValue !== ERRORED2 && newValue !== ERRORED2 && node.equal(oldValue, newValue)) {
        node.value = oldValue;
        return;
      }
      node.value = newValue;
      node.version++;
    }
  });
})();
var SIGNAL_NODE2 = (() => {
  return __spreadProps(__spreadValues({}, REACTIVE_NODE2), {
    equal: defaultEquals2,
    value: void 0
  });
})();
var NOOP_CLEANUP_FN2 = () => {
};
var WATCH_NODE2 = (() => {
  return __spreadProps(__spreadValues({}, REACTIVE_NODE2), {
    consumerIsAlwaysLive: true,
    consumerAllowSignalWrites: false,
    consumerMarkedDirty: (node) => {
      if (node.schedule !== null) {
        node.schedule(node.ref);
      }
    },
    hasRun: false,
    cleanupFn: NOOP_CLEANUP_FN2
  });
})();
var sharedStashFunction = (rEl, eventType, listenerFn) => {
  const el = rEl;
  const eventListenerMap = el.__jsaction_fns ?? /* @__PURE__ */ new Map();
  const eventListeners = eventListenerMap.get(eventType) ?? [];
  eventListeners.push(listenerFn);
  eventListenerMap.set(eventType, eventListeners);
  el.__jsaction_fns = eventListenerMap;
};
var JSACTION_EVENT_CONTRACT = new InjectionToken(ngDevMode ? "EVENT_CONTRACT_DETAILS" : "", {
  providedIn: "root",
  factory: () => ({})
});
var GLOBAL_EVENT_DELEGATION = new InjectionToken(ngDevMode ? "GLOBAL_EVENT_DELEGATION" : "");
var GlobalEventDelegation = class _GlobalEventDelegation {
  constructor() {
    this.eventContractDetails = inject(JSACTION_EVENT_CONTRACT);
  }
  ngOnDestroy() {
    this.eventContractDetails.instance?.cleanUp();
  }
  supports(eventType) {
    return isEarlyEventType(eventType);
  }
  addEventListener(element, eventType, handler) {
    if (element.nodeType === Node.ELEMENT_NODE) {
      this.eventContractDetails.instance.addEvent(eventType);
      getDefaulted(element)[eventType] = "";
      sharedStashFunction(element, eventType, handler);
    } else {
      element.addEventListener(eventType, handler);
    }
    return () => this.removeEventListener(element, eventType, handler);
  }
  removeEventListener(element, eventType, callback) {
    if (element.nodeType === Node.ELEMENT_NODE) {
      getDefaulted(element)[eventType] = void 0;
    } else {
      element.removeEventListener(eventType, callback);
    }
  }
  static {
    this.ɵfac = function GlobalEventDelegation_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _GlobalEventDelegation)();
    };
  }
  static {
    this.ɵprov = ɵɵdefineInjectable({
      token: _GlobalEventDelegation,
      factory: _GlobalEventDelegation.ɵfac
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(GlobalEventDelegation, [{
    type: Injectable
  }], null, null);
})();
function booleanAttribute(value) {
  return typeof value === "boolean" ? value : value != null && value !== "false";
}
function numberAttribute(value, fallbackValue = NaN) {
  const isNumberValue = !isNaN(parseFloat(value)) && !isNaN(Number(value));
  return isNumberValue ? Number(value) : fallbackValue;
}
function untracked(nonReactiveReadsFn) {
  const prevConsumer = setActiveConsumer(null);
  try {
    return nonReactiveReadsFn();
  } finally {
    setActiveConsumer(prevConsumer);
  }
}
var APP_EFFECT_SCHEDULER = new InjectionToken("", {
  providedIn: "root",
  factory: () => inject(EffectScheduler)
});
var EffectScheduler = class _EffectScheduler {
  static {
    this.ɵprov = ɵɵdefineInjectable({
      token: _EffectScheduler,
      providedIn: "root",
      factory: () => new ZoneAwareEffectScheduler()
    });
  }
};
var ZoneAwareEffectScheduler = class {
  constructor() {
    this.queuedEffectCount = 0;
    this.queues = /* @__PURE__ */ new Map();
    this.pendingTasks = inject(PendingTasks);
    this.taskId = null;
  }
  scheduleEffect(handle) {
    this.enqueue(handle);
    if (this.taskId === null) {
      const taskId = this.taskId = this.pendingTasks.add();
      queueMicrotask(() => {
        this.flush();
        this.pendingTasks.remove(taskId);
        this.taskId = null;
      });
    }
  }
  enqueue(handle) {
    const zone = handle.creationZone;
    if (!this.queues.has(zone)) {
      this.queues.set(zone, /* @__PURE__ */ new Set());
    }
    const queue = this.queues.get(zone);
    if (queue.has(handle)) {
      return;
    }
    this.queuedEffectCount++;
    queue.add(handle);
  }
  /**
   * Run all scheduled effects.
   *
   * Execution order of effects within the same zone is guaranteed to be FIFO, but there is no
   * ordering guarantee between effects scheduled in different zones.
   */
  flush() {
    while (this.queuedEffectCount > 0) {
      for (const [zone, queue] of this.queues) {
        if (zone === null) {
          this.flushQueue(queue);
        } else {
          zone.run(() => this.flushQueue(queue));
        }
      }
    }
  }
  flushQueue(queue) {
    for (const handle of queue) {
      queue.delete(handle);
      this.queuedEffectCount--;
      handle.run();
    }
  }
};
if (typeof ngDevMode !== "undefined" && ngDevMode) {
  _global.$localize ??= function() {
    throw new Error("It looks like your application or one of its dependencies is using i18n.\nAngular 9 introduced a global `$localize()` function that needs to be loaded.\nPlease run `ng add @angular/localize` from the Angular CLI.\n(For non-CLI projects, add `import '@angular/localize/init';` to your `polyfills.ts` file.\nFor server-side rendering applications add the import to your `main.server.ts` file.)");
  };
}

// node_modules/@mindfiredigital/pivothead-angular/node_modules/@angular/common/fesm2022/common.mjs
var _DOM = null;
function getDOM() {
  return _DOM;
}
var PlatformNavigation = class _PlatformNavigation {
  static {
    this.ɵfac = function PlatformNavigation_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _PlatformNavigation)();
    };
  }
  static {
    this.ɵprov = ɵɵdefineInjectable({
      token: _PlatformNavigation,
      factory: () => (() => window.navigation)(),
      providedIn: "platform"
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PlatformNavigation, [{
    type: Injectable,
    args: [{
      providedIn: "platform",
      useFactory: () => window.navigation
    }]
  }], null, null);
})();
var DOCUMENT2 = new InjectionToken(ngDevMode ? "DocumentToken" : "");
var PlatformLocation = class _PlatformLocation {
  historyGo(relativePosition) {
    throw new Error(ngDevMode ? "Not implemented" : "");
  }
  static {
    this.ɵfac = function PlatformLocation_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _PlatformLocation)();
    };
  }
  static {
    this.ɵprov = ɵɵdefineInjectable({
      token: _PlatformLocation,
      factory: () => (() => inject(BrowserPlatformLocation))(),
      providedIn: "platform"
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PlatformLocation, [{
    type: Injectable,
    args: [{
      providedIn: "platform",
      useFactory: () => inject(BrowserPlatformLocation)
    }]
  }], null, null);
})();
var LOCATION_INITIALIZED = new InjectionToken(ngDevMode ? "Location Initialized" : "");
var BrowserPlatformLocation = class _BrowserPlatformLocation extends PlatformLocation {
  constructor() {
    super();
    this._doc = inject(DOCUMENT2);
    this._location = window.location;
    this._history = window.history;
  }
  getBaseHrefFromDOM() {
    return getDOM().getBaseHref(this._doc);
  }
  onPopState(fn) {
    const window2 = getDOM().getGlobalEventTarget(this._doc, "window");
    window2.addEventListener("popstate", fn, false);
    return () => window2.removeEventListener("popstate", fn);
  }
  onHashChange(fn) {
    const window2 = getDOM().getGlobalEventTarget(this._doc, "window");
    window2.addEventListener("hashchange", fn, false);
    return () => window2.removeEventListener("hashchange", fn);
  }
  get href() {
    return this._location.href;
  }
  get protocol() {
    return this._location.protocol;
  }
  get hostname() {
    return this._location.hostname;
  }
  get port() {
    return this._location.port;
  }
  get pathname() {
    return this._location.pathname;
  }
  get search() {
    return this._location.search;
  }
  get hash() {
    return this._location.hash;
  }
  set pathname(newPath) {
    this._location.pathname = newPath;
  }
  pushState(state, title, url) {
    this._history.pushState(state, title, url);
  }
  replaceState(state, title, url) {
    this._history.replaceState(state, title, url);
  }
  forward() {
    this._history.forward();
  }
  back() {
    this._history.back();
  }
  historyGo(relativePosition = 0) {
    this._history.go(relativePosition);
  }
  getState() {
    return this._history.state;
  }
  static {
    this.ɵfac = function BrowserPlatformLocation_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _BrowserPlatformLocation)();
    };
  }
  static {
    this.ɵprov = ɵɵdefineInjectable({
      token: _BrowserPlatformLocation,
      factory: () => (() => new _BrowserPlatformLocation())(),
      providedIn: "platform"
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(BrowserPlatformLocation, [{
    type: Injectable,
    args: [{
      providedIn: "platform",
      useFactory: () => new BrowserPlatformLocation()
    }]
  }], () => [], null);
})();
function joinWithSlash(start, end) {
  if (start.length == 0) {
    return end;
  }
  if (end.length == 0) {
    return start;
  }
  let slashes = 0;
  if (start.endsWith("/")) {
    slashes++;
  }
  if (end.startsWith("/")) {
    slashes++;
  }
  if (slashes == 2) {
    return start + end.substring(1);
  }
  if (slashes == 1) {
    return start + end;
  }
  return start + "/" + end;
}
function stripTrailingSlash(url) {
  const match = url.match(/#|\?|$/);
  const pathEndIdx = match && match.index || url.length;
  const droppedSlashIdx = pathEndIdx - (url[pathEndIdx - 1] === "/" ? 1 : 0);
  return url.slice(0, droppedSlashIdx) + url.slice(pathEndIdx);
}
function normalizeQueryParams(params) {
  return params && params[0] !== "?" ? "?" + params : params;
}
var LocationStrategy = class _LocationStrategy {
  historyGo(relativePosition) {
    throw new Error(ngDevMode ? "Not implemented" : "");
  }
  static {
    this.ɵfac = function LocationStrategy_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _LocationStrategy)();
    };
  }
  static {
    this.ɵprov = ɵɵdefineInjectable({
      token: _LocationStrategy,
      factory: () => (() => inject(PathLocationStrategy))(),
      providedIn: "root"
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(LocationStrategy, [{
    type: Injectable,
    args: [{
      providedIn: "root",
      useFactory: () => inject(PathLocationStrategy)
    }]
  }], null, null);
})();
var APP_BASE_HREF = new InjectionToken(ngDevMode ? "appBaseHref" : "");
var PathLocationStrategy = class _PathLocationStrategy extends LocationStrategy {
  constructor(_platformLocation, href) {
    super();
    this._platformLocation = _platformLocation;
    this._removeListenerFns = [];
    this._baseHref = href ?? this._platformLocation.getBaseHrefFromDOM() ?? inject(DOCUMENT2).location?.origin ?? "";
  }
  /** @nodoc */
  ngOnDestroy() {
    while (this._removeListenerFns.length) {
      this._removeListenerFns.pop()();
    }
  }
  onPopState(fn) {
    this._removeListenerFns.push(this._platformLocation.onPopState(fn), this._platformLocation.onHashChange(fn));
  }
  getBaseHref() {
    return this._baseHref;
  }
  prepareExternalUrl(internal) {
    return joinWithSlash(this._baseHref, internal);
  }
  path(includeHash = false) {
    const pathname = this._platformLocation.pathname + normalizeQueryParams(this._platformLocation.search);
    const hash = this._platformLocation.hash;
    return hash && includeHash ? `${pathname}${hash}` : pathname;
  }
  pushState(state, title, url, queryParams) {
    const externalUrl = this.prepareExternalUrl(url + normalizeQueryParams(queryParams));
    this._platformLocation.pushState(state, title, externalUrl);
  }
  replaceState(state, title, url, queryParams) {
    const externalUrl = this.prepareExternalUrl(url + normalizeQueryParams(queryParams));
    this._platformLocation.replaceState(state, title, externalUrl);
  }
  forward() {
    this._platformLocation.forward();
  }
  back() {
    this._platformLocation.back();
  }
  getState() {
    return this._platformLocation.getState();
  }
  historyGo(relativePosition = 0) {
    this._platformLocation.historyGo?.(relativePosition);
  }
  static {
    this.ɵfac = function PathLocationStrategy_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _PathLocationStrategy)(ɵɵinject(PlatformLocation), ɵɵinject(APP_BASE_HREF, 8));
    };
  }
  static {
    this.ɵprov = ɵɵdefineInjectable({
      token: _PathLocationStrategy,
      factory: _PathLocationStrategy.ɵfac,
      providedIn: "root"
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PathLocationStrategy, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], () => [{
    type: PlatformLocation
  }, {
    type: void 0,
    decorators: [{
      type: Optional
    }, {
      type: Inject,
      args: [APP_BASE_HREF]
    }]
  }], null);
})();
var HashLocationStrategy = class _HashLocationStrategy extends LocationStrategy {
  constructor(_platformLocation, _baseHref) {
    super();
    this._platformLocation = _platformLocation;
    this._baseHref = "";
    this._removeListenerFns = [];
    if (_baseHref != null) {
      this._baseHref = _baseHref;
    }
  }
  /** @nodoc */
  ngOnDestroy() {
    while (this._removeListenerFns.length) {
      this._removeListenerFns.pop()();
    }
  }
  onPopState(fn) {
    this._removeListenerFns.push(this._platformLocation.onPopState(fn), this._platformLocation.onHashChange(fn));
  }
  getBaseHref() {
    return this._baseHref;
  }
  path(includeHash = false) {
    const path = this._platformLocation.hash ?? "#";
    return path.length > 0 ? path.substring(1) : path;
  }
  prepareExternalUrl(internal) {
    const url = joinWithSlash(this._baseHref, internal);
    return url.length > 0 ? "#" + url : url;
  }
  pushState(state, title, path, queryParams) {
    let url = this.prepareExternalUrl(path + normalizeQueryParams(queryParams));
    if (url.length == 0) {
      url = this._platformLocation.pathname;
    }
    this._platformLocation.pushState(state, title, url);
  }
  replaceState(state, title, path, queryParams) {
    let url = this.prepareExternalUrl(path + normalizeQueryParams(queryParams));
    if (url.length == 0) {
      url = this._platformLocation.pathname;
    }
    this._platformLocation.replaceState(state, title, url);
  }
  forward() {
    this._platformLocation.forward();
  }
  back() {
    this._platformLocation.back();
  }
  getState() {
    return this._platformLocation.getState();
  }
  historyGo(relativePosition = 0) {
    this._platformLocation.historyGo?.(relativePosition);
  }
  static {
    this.ɵfac = function HashLocationStrategy_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _HashLocationStrategy)(ɵɵinject(PlatformLocation), ɵɵinject(APP_BASE_HREF, 8));
    };
  }
  static {
    this.ɵprov = ɵɵdefineInjectable({
      token: _HashLocationStrategy,
      factory: _HashLocationStrategy.ɵfac
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(HashLocationStrategy, [{
    type: Injectable
  }], () => [{
    type: PlatformLocation
  }, {
    type: void 0,
    decorators: [{
      type: Optional
    }, {
      type: Inject,
      args: [APP_BASE_HREF]
    }]
  }], null);
})();
var Location = class _Location {
  constructor(locationStrategy) {
    this._subject = new EventEmitter();
    this._urlChangeListeners = [];
    this._urlChangeSubscription = null;
    this._locationStrategy = locationStrategy;
    const baseHref = this._locationStrategy.getBaseHref();
    this._basePath = _stripOrigin(stripTrailingSlash(_stripIndexHtml(baseHref)));
    this._locationStrategy.onPopState((ev) => {
      this._subject.emit({
        "url": this.path(true),
        "pop": true,
        "state": ev.state,
        "type": ev.type
      });
    });
  }
  /** @nodoc */
  ngOnDestroy() {
    this._urlChangeSubscription?.unsubscribe();
    this._urlChangeListeners = [];
  }
  /**
   * Normalizes the URL path for this location.
   *
   * @param includeHash True to include an anchor fragment in the path.
   *
   * @returns The normalized URL path.
   */
  // TODO: vsavkin. Remove the boolean flag and always include hash once the deprecated router is
  // removed.
  path(includeHash = false) {
    return this.normalize(this._locationStrategy.path(includeHash));
  }
  /**
   * Reports the current state of the location history.
   * @returns The current value of the `history.state` object.
   */
  getState() {
    return this._locationStrategy.getState();
  }
  /**
   * Normalizes the given path and compares to the current normalized path.
   *
   * @param path The given URL path.
   * @param query Query parameters.
   *
   * @returns True if the given URL path is equal to the current normalized path, false
   * otherwise.
   */
  isCurrentPathEqualTo(path, query = "") {
    return this.path() == this.normalize(path + normalizeQueryParams(query));
  }
  /**
   * Normalizes a URL path by stripping any trailing slashes.
   *
   * @param url String representing a URL.
   *
   * @returns The normalized URL string.
   */
  normalize(url) {
    return _Location.stripTrailingSlash(_stripBasePath(this._basePath, _stripIndexHtml(url)));
  }
  /**
   * Normalizes an external URL path.
   * If the given URL doesn't begin with a leading slash (`'/'`), adds one
   * before normalizing. Adds a hash if `HashLocationStrategy` is
   * in use, or the `APP_BASE_HREF` if the `PathLocationStrategy` is in use.
   *
   * @param url String representing a URL.
   *
   * @returns  A normalized platform-specific URL.
   */
  prepareExternalUrl(url) {
    if (url && url[0] !== "/") {
      url = "/" + url;
    }
    return this._locationStrategy.prepareExternalUrl(url);
  }
  // TODO: rename this method to pushState
  /**
   * Changes the browser's URL to a normalized version of a given URL, and pushes a
   * new item onto the platform's history.
   *
   * @param path  URL path to normalize.
   * @param query Query parameters.
   * @param state Location history state.
   *
   */
  go(path, query = "", state = null) {
    this._locationStrategy.pushState(state, "", path, query);
    this._notifyUrlChangeListeners(this.prepareExternalUrl(path + normalizeQueryParams(query)), state);
  }
  /**
   * Changes the browser's URL to a normalized version of the given URL, and replaces
   * the top item on the platform's history stack.
   *
   * @param path  URL path to normalize.
   * @param query Query parameters.
   * @param state Location history state.
   */
  replaceState(path, query = "", state = null) {
    this._locationStrategy.replaceState(state, "", path, query);
    this._notifyUrlChangeListeners(this.prepareExternalUrl(path + normalizeQueryParams(query)), state);
  }
  /**
   * Navigates forward in the platform's history.
   */
  forward() {
    this._locationStrategy.forward();
  }
  /**
   * Navigates back in the platform's history.
   */
  back() {
    this._locationStrategy.back();
  }
  /**
   * Navigate to a specific page from session history, identified by its relative position to the
   * current page.
   *
   * @param relativePosition  Position of the target page in the history relative to the current
   *     page.
   * A negative value moves backwards, a positive value moves forwards, e.g. `location.historyGo(2)`
   * moves forward two pages and `location.historyGo(-2)` moves back two pages. When we try to go
   * beyond what's stored in the history session, we stay in the current page. Same behaviour occurs
   * when `relativePosition` equals 0.
   * @see https://developer.mozilla.org/en-US/docs/Web/API/History_API#Moving_to_a_specific_point_in_history
   */
  historyGo(relativePosition = 0) {
    this._locationStrategy.historyGo?.(relativePosition);
  }
  /**
   * Registers a URL change listener. Use to catch updates performed by the Angular
   * framework that are not detectible through "popstate" or "hashchange" events.
   *
   * @param fn The change handler function, which take a URL and a location history state.
   * @returns A function that, when executed, unregisters a URL change listener.
   */
  onUrlChange(fn) {
    this._urlChangeListeners.push(fn);
    this._urlChangeSubscription ??= this.subscribe((v) => {
      this._notifyUrlChangeListeners(v.url, v.state);
    });
    return () => {
      const fnIndex = this._urlChangeListeners.indexOf(fn);
      this._urlChangeListeners.splice(fnIndex, 1);
      if (this._urlChangeListeners.length === 0) {
        this._urlChangeSubscription?.unsubscribe();
        this._urlChangeSubscription = null;
      }
    };
  }
  /** @internal */
  _notifyUrlChangeListeners(url = "", state) {
    this._urlChangeListeners.forEach((fn) => fn(url, state));
  }
  /**
   * Subscribes to the platform's `popState` events.
   *
   * Note: `Location.go()` does not trigger the `popState` event in the browser. Use
   * `Location.onUrlChange()` to subscribe to URL changes instead.
   *
   * @param value Event that is triggered when the state history changes.
   * @param exception The exception to throw.
   *
   * @see [onpopstate](https://developer.mozilla.org/en-US/docs/Web/API/WindowEventHandlers/onpopstate)
   *
   * @returns Subscribed events.
   */
  subscribe(onNext, onThrow, onReturn) {
    return this._subject.subscribe({
      next: onNext,
      error: onThrow,
      complete: onReturn
    });
  }
  static {
    this.normalizeQueryParams = normalizeQueryParams;
  }
  static {
    this.joinWithSlash = joinWithSlash;
  }
  static {
    this.stripTrailingSlash = stripTrailingSlash;
  }
  static {
    this.ɵfac = function Location_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _Location)(ɵɵinject(LocationStrategy));
    };
  }
  static {
    this.ɵprov = ɵɵdefineInjectable({
      token: _Location,
      factory: () => createLocation(),
      providedIn: "root"
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(Location, [{
    type: Injectable,
    args: [{
      providedIn: "root",
      // See #23917
      useFactory: createLocation
    }]
  }], () => [{
    type: LocationStrategy
  }], null);
})();
function createLocation() {
  return new Location(ɵɵinject(LocationStrategy));
}
function _stripBasePath(basePath, url) {
  if (!basePath || !url.startsWith(basePath)) {
    return url;
  }
  const strippedUrl = url.substring(basePath.length);
  if (strippedUrl === "" || ["/", ";", "?", "#"].includes(strippedUrl[0])) {
    return strippedUrl;
  }
  return url;
}
function _stripIndexHtml(url) {
  return url.replace(/\/index.html$/, "");
}
function _stripOrigin(baseHref) {
  const isAbsoluteUrl2 = new RegExp("^(https?:)?//").test(baseHref);
  if (isAbsoluteUrl2) {
    const [, pathname] = baseHref.split(/\/\/[^\/]+/);
    return pathname;
  }
  return baseHref;
}
var CURRENCIES_EN = {
  "ADP": [void 0, void 0, 0],
  "AFN": [void 0, "؋", 0],
  "ALL": [void 0, void 0, 0],
  "AMD": [void 0, "֏", 2],
  "AOA": [void 0, "Kz"],
  "ARS": [void 0, "$"],
  "AUD": ["A$", "$"],
  "AZN": [void 0, "₼"],
  "BAM": [void 0, "KM"],
  "BBD": [void 0, "$"],
  "BDT": [void 0, "৳"],
  "BHD": [void 0, void 0, 3],
  "BIF": [void 0, void 0, 0],
  "BMD": [void 0, "$"],
  "BND": [void 0, "$"],
  "BOB": [void 0, "Bs"],
  "BRL": ["R$"],
  "BSD": [void 0, "$"],
  "BWP": [void 0, "P"],
  "BYN": [void 0, void 0, 2],
  "BYR": [void 0, void 0, 0],
  "BZD": [void 0, "$"],
  "CAD": ["CA$", "$", 2],
  "CHF": [void 0, void 0, 2],
  "CLF": [void 0, void 0, 4],
  "CLP": [void 0, "$", 0],
  "CNY": ["CN¥", "¥"],
  "COP": [void 0, "$", 2],
  "CRC": [void 0, "₡", 2],
  "CUC": [void 0, "$"],
  "CUP": [void 0, "$"],
  "CZK": [void 0, "Kč", 2],
  "DJF": [void 0, void 0, 0],
  "DKK": [void 0, "kr", 2],
  "DOP": [void 0, "$"],
  "EGP": [void 0, "E£"],
  "ESP": [void 0, "₧", 0],
  "EUR": ["€"],
  "FJD": [void 0, "$"],
  "FKP": [void 0, "£"],
  "GBP": ["£"],
  "GEL": [void 0, "₾"],
  "GHS": [void 0, "GH₵"],
  "GIP": [void 0, "£"],
  "GNF": [void 0, "FG", 0],
  "GTQ": [void 0, "Q"],
  "GYD": [void 0, "$", 2],
  "HKD": ["HK$", "$"],
  "HNL": [void 0, "L"],
  "HRK": [void 0, "kn"],
  "HUF": [void 0, "Ft", 2],
  "IDR": [void 0, "Rp", 2],
  "ILS": ["₪"],
  "INR": ["₹"],
  "IQD": [void 0, void 0, 0],
  "IRR": [void 0, void 0, 0],
  "ISK": [void 0, "kr", 0],
  "ITL": [void 0, void 0, 0],
  "JMD": [void 0, "$"],
  "JOD": [void 0, void 0, 3],
  "JPY": ["¥", void 0, 0],
  "KHR": [void 0, "៛"],
  "KMF": [void 0, "CF", 0],
  "KPW": [void 0, "₩", 0],
  "KRW": ["₩", void 0, 0],
  "KWD": [void 0, void 0, 3],
  "KYD": [void 0, "$"],
  "KZT": [void 0, "₸"],
  "LAK": [void 0, "₭", 0],
  "LBP": [void 0, "L£", 0],
  "LKR": [void 0, "Rs"],
  "LRD": [void 0, "$"],
  "LTL": [void 0, "Lt"],
  "LUF": [void 0, void 0, 0],
  "LVL": [void 0, "Ls"],
  "LYD": [void 0, void 0, 3],
  "MGA": [void 0, "Ar", 0],
  "MGF": [void 0, void 0, 0],
  "MMK": [void 0, "K", 0],
  "MNT": [void 0, "₮", 2],
  "MRO": [void 0, void 0, 0],
  "MUR": [void 0, "Rs", 2],
  "MXN": ["MX$", "$"],
  "MYR": [void 0, "RM"],
  "NAD": [void 0, "$"],
  "NGN": [void 0, "₦"],
  "NIO": [void 0, "C$"],
  "NOK": [void 0, "kr", 2],
  "NPR": [void 0, "Rs"],
  "NZD": ["NZ$", "$"],
  "OMR": [void 0, void 0, 3],
  "PHP": ["₱"],
  "PKR": [void 0, "Rs", 2],
  "PLN": [void 0, "zł"],
  "PYG": [void 0, "₲", 0],
  "RON": [void 0, "lei"],
  "RSD": [void 0, void 0, 0],
  "RUB": [void 0, "₽"],
  "RWF": [void 0, "RF", 0],
  "SBD": [void 0, "$"],
  "SEK": [void 0, "kr", 2],
  "SGD": [void 0, "$"],
  "SHP": [void 0, "£"],
  "SLE": [void 0, void 0, 2],
  "SLL": [void 0, void 0, 0],
  "SOS": [void 0, void 0, 0],
  "SRD": [void 0, "$"],
  "SSP": [void 0, "£"],
  "STD": [void 0, void 0, 0],
  "STN": [void 0, "Db"],
  "SYP": [void 0, "£", 0],
  "THB": [void 0, "฿"],
  "TMM": [void 0, void 0, 0],
  "TND": [void 0, void 0, 3],
  "TOP": [void 0, "T$"],
  "TRL": [void 0, void 0, 0],
  "TRY": [void 0, "₺"],
  "TTD": [void 0, "$"],
  "TWD": ["NT$", "$", 2],
  "TZS": [void 0, void 0, 2],
  "UAH": [void 0, "₴"],
  "UGX": [void 0, void 0, 0],
  "USD": ["$"],
  "UYI": [void 0, void 0, 0],
  "UYU": [void 0, "$"],
  "UYW": [void 0, void 0, 4],
  "UZS": [void 0, void 0, 2],
  "VEF": [void 0, "Bs", 2],
  "VND": ["₫", void 0, 0],
  "VUV": [void 0, void 0, 0],
  "XAF": ["FCFA", void 0, 0],
  "XCD": ["EC$", "$"],
  "XOF": ["F CFA", void 0, 0],
  "XPF": ["CFPF", void 0, 0],
  "XXX": ["¤"],
  "YER": [void 0, void 0, 0],
  "ZAR": [void 0, "R"],
  "ZMK": [void 0, void 0, 0],
  "ZMW": [void 0, "ZK"],
  "ZWD": [void 0, void 0, 0]
};
var NumberFormatStyle;
(function(NumberFormatStyle2) {
  NumberFormatStyle2[NumberFormatStyle2["Decimal"] = 0] = "Decimal";
  NumberFormatStyle2[NumberFormatStyle2["Percent"] = 1] = "Percent";
  NumberFormatStyle2[NumberFormatStyle2["Currency"] = 2] = "Currency";
  NumberFormatStyle2[NumberFormatStyle2["Scientific"] = 3] = "Scientific";
})(NumberFormatStyle || (NumberFormatStyle = {}));
var Plural;
(function(Plural2) {
  Plural2[Plural2["Zero"] = 0] = "Zero";
  Plural2[Plural2["One"] = 1] = "One";
  Plural2[Plural2["Two"] = 2] = "Two";
  Plural2[Plural2["Few"] = 3] = "Few";
  Plural2[Plural2["Many"] = 4] = "Many";
  Plural2[Plural2["Other"] = 5] = "Other";
})(Plural || (Plural = {}));
var FormStyle;
(function(FormStyle2) {
  FormStyle2[FormStyle2["Format"] = 0] = "Format";
  FormStyle2[FormStyle2["Standalone"] = 1] = "Standalone";
})(FormStyle || (FormStyle = {}));
var TranslationWidth;
(function(TranslationWidth2) {
  TranslationWidth2[TranslationWidth2["Narrow"] = 0] = "Narrow";
  TranslationWidth2[TranslationWidth2["Abbreviated"] = 1] = "Abbreviated";
  TranslationWidth2[TranslationWidth2["Wide"] = 2] = "Wide";
  TranslationWidth2[TranslationWidth2["Short"] = 3] = "Short";
})(TranslationWidth || (TranslationWidth = {}));
var FormatWidth;
(function(FormatWidth2) {
  FormatWidth2[FormatWidth2["Short"] = 0] = "Short";
  FormatWidth2[FormatWidth2["Medium"] = 1] = "Medium";
  FormatWidth2[FormatWidth2["Long"] = 2] = "Long";
  FormatWidth2[FormatWidth2["Full"] = 3] = "Full";
})(FormatWidth || (FormatWidth = {}));
var NumberSymbol = {
  /**
   * Decimal separator.
   * For `en-US`, the dot character.
   * Example: 2,345`.`67
   */
  Decimal: 0,
  /**
   * Grouping separator, typically for thousands.
   * For `en-US`, the comma character.
   * Example: 2`,`345.67
   */
  Group: 1,
  /**
   * List-item separator.
   * Example: "one, two, and three"
   */
  List: 2,
  /**
   * Sign for percentage (out of 100).
   * Example: 23.4%
   */
  PercentSign: 3,
  /**
   * Sign for positive numbers.
   * Example: +23
   */
  PlusSign: 4,
  /**
   * Sign for negative numbers.
   * Example: -23
   */
  MinusSign: 5,
  /**
   * Computer notation for exponential value (n times a power of 10).
   * Example: 1.2E3
   */
  Exponential: 6,
  /**
   * Human-readable format of exponential.
   * Example: 1.2x103
   */
  SuperscriptingExponent: 7,
  /**
   * Sign for permille (out of 1000).
   * Example: 23.4‰
   */
  PerMille: 8,
  /**
   * Infinity, can be used with plus and minus.
   * Example: ∞, +∞, -∞
   */
  Infinity: 9,
  /**
   * Not a number.
   * Example: NaN
   */
  NaN: 10,
  /**
   * Symbol used between time units.
   * Example: 10:52
   */
  TimeSeparator: 11,
  /**
   * Decimal separator for currency values (fallback to `Decimal`).
   * Example: $2,345.67
   */
  CurrencyDecimal: 12,
  /**
   * Group separator for currency values (fallback to `Group`).
   * Example: $2,345.67
   */
  CurrencyGroup: 13
};
var WeekDay;
(function(WeekDay2) {
  WeekDay2[WeekDay2["Sunday"] = 0] = "Sunday";
  WeekDay2[WeekDay2["Monday"] = 1] = "Monday";
  WeekDay2[WeekDay2["Tuesday"] = 2] = "Tuesday";
  WeekDay2[WeekDay2["Wednesday"] = 3] = "Wednesday";
  WeekDay2[WeekDay2["Thursday"] = 4] = "Thursday";
  WeekDay2[WeekDay2["Friday"] = 5] = "Friday";
  WeekDay2[WeekDay2["Saturday"] = 6] = "Saturday";
})(WeekDay || (WeekDay = {}));
function getLocaleId2(locale) {
  return findLocaleData(locale)[LocaleDataIndex.LocaleId];
}
function getLocaleDayPeriods(locale, formStyle, width) {
  const data = findLocaleData(locale);
  const amPmData = [data[LocaleDataIndex.DayPeriodsFormat], data[LocaleDataIndex.DayPeriodsStandalone]];
  const amPm = getLastDefinedValue(amPmData, formStyle);
  return getLastDefinedValue(amPm, width);
}
function getLocaleDayNames(locale, formStyle, width) {
  const data = findLocaleData(locale);
  const daysData = [data[LocaleDataIndex.DaysFormat], data[LocaleDataIndex.DaysStandalone]];
  const days = getLastDefinedValue(daysData, formStyle);
  return getLastDefinedValue(days, width);
}
function getLocaleMonthNames(locale, formStyle, width) {
  const data = findLocaleData(locale);
  const monthsData = [data[LocaleDataIndex.MonthsFormat], data[LocaleDataIndex.MonthsStandalone]];
  const months = getLastDefinedValue(monthsData, formStyle);
  return getLastDefinedValue(months, width);
}
function getLocaleEraNames(locale, width) {
  const data = findLocaleData(locale);
  const erasData = data[LocaleDataIndex.Eras];
  return getLastDefinedValue(erasData, width);
}
function getLocaleDateFormat(locale, width) {
  const data = findLocaleData(locale);
  return getLastDefinedValue(data[LocaleDataIndex.DateFormat], width);
}
function getLocaleTimeFormat(locale, width) {
  const data = findLocaleData(locale);
  return getLastDefinedValue(data[LocaleDataIndex.TimeFormat], width);
}
function getLocaleDateTimeFormat(locale, width) {
  const data = findLocaleData(locale);
  const dateTimeFormatData = data[LocaleDataIndex.DateTimeFormat];
  return getLastDefinedValue(dateTimeFormatData, width);
}
function getLocaleNumberSymbol(locale, symbol) {
  const data = findLocaleData(locale);
  const res = data[LocaleDataIndex.NumberSymbols][symbol];
  if (typeof res === "undefined") {
    if (symbol === NumberSymbol.CurrencyDecimal) {
      return data[LocaleDataIndex.NumberSymbols][NumberSymbol.Decimal];
    } else if (symbol === NumberSymbol.CurrencyGroup) {
      return data[LocaleDataIndex.NumberSymbols][NumberSymbol.Group];
    }
  }
  return res;
}
function getLocaleNumberFormat(locale, type) {
  const data = findLocaleData(locale);
  return data[LocaleDataIndex.NumberFormats][type];
}
function getLocaleCurrencies(locale) {
  const data = findLocaleData(locale);
  return data[LocaleDataIndex.Currencies];
}
var getLocalePluralCase2 = getLocalePluralCase;
function checkFullData(data) {
  if (!data[LocaleDataIndex.ExtraData]) {
    throw new Error(`Missing extra locale data for the locale "${data[LocaleDataIndex.LocaleId]}". Use "registerLocaleData" to load new data. See the "I18n guide" on angular.io to know more.`);
  }
}
function getLocaleExtraDayPeriodRules(locale) {
  const data = findLocaleData(locale);
  checkFullData(data);
  const rules = data[LocaleDataIndex.ExtraData][
    2
    /* ɵExtraLocaleDataIndex.ExtraDayPeriodsRules */
  ] || [];
  return rules.map((rule) => {
    if (typeof rule === "string") {
      return extractTime(rule);
    }
    return [extractTime(rule[0]), extractTime(rule[1])];
  });
}
function getLocaleExtraDayPeriods(locale, formStyle, width) {
  const data = findLocaleData(locale);
  checkFullData(data);
  const dayPeriodsData = [data[LocaleDataIndex.ExtraData][
    0
    /* ɵExtraLocaleDataIndex.ExtraDayPeriodFormats */
  ], data[LocaleDataIndex.ExtraData][
    1
    /* ɵExtraLocaleDataIndex.ExtraDayPeriodStandalone */
  ]];
  const dayPeriods = getLastDefinedValue(dayPeriodsData, formStyle) || [];
  return getLastDefinedValue(dayPeriods, width) || [];
}
function getLastDefinedValue(data, index) {
  for (let i = index; i > -1; i--) {
    if (typeof data[i] !== "undefined") {
      return data[i];
    }
  }
  throw new Error("Locale data API: locale data undefined");
}
function extractTime(time) {
  const [h, m] = time.split(":");
  return {
    hours: +h,
    minutes: +m
  };
}
function getCurrencySymbol(code, format, locale = "en") {
  const currency = getLocaleCurrencies(locale)[code] || CURRENCIES_EN[code] || [];
  const symbolNarrow = currency[
    1
    /* ɵCurrencyIndex.SymbolNarrow */
  ];
  if (format === "narrow" && typeof symbolNarrow === "string") {
    return symbolNarrow;
  }
  return currency[
    0
    /* ɵCurrencyIndex.Symbol */
  ] || code;
}
var DEFAULT_NB_OF_CURRENCY_DIGITS = 2;
function getNumberOfCurrencyDigits(code) {
  let digits;
  const currency = CURRENCIES_EN[code];
  if (currency) {
    digits = currency[
      2
      /* ɵCurrencyIndex.NbOfDigits */
    ];
  }
  return typeof digits === "number" ? digits : DEFAULT_NB_OF_CURRENCY_DIGITS;
}
var ISO8601_DATE_REGEX = /^(\d{4,})-?(\d\d)-?(\d\d)(?:T(\d\d)(?::?(\d\d)(?::?(\d\d)(?:\.(\d+))?)?)?(Z|([+-])(\d\d):?(\d\d))?)?$/;
var NAMED_FORMATS = {};
var DATE_FORMATS_SPLIT = /((?:[^BEGHLMOSWYZabcdhmswyz']+)|(?:'(?:[^']|'')*')|(?:G{1,5}|y{1,4}|Y{1,4}|M{1,5}|L{1,5}|w{1,2}|W{1}|d{1,2}|E{1,6}|c{1,6}|a{1,5}|b{1,5}|B{1,5}|h{1,2}|H{1,2}|m{1,2}|s{1,2}|S{1,3}|z{1,4}|Z{1,5}|O{1,4}))([\s\S]*)/;
var ZoneWidth;
(function(ZoneWidth2) {
  ZoneWidth2[ZoneWidth2["Short"] = 0] = "Short";
  ZoneWidth2[ZoneWidth2["ShortGMT"] = 1] = "ShortGMT";
  ZoneWidth2[ZoneWidth2["Long"] = 2] = "Long";
  ZoneWidth2[ZoneWidth2["Extended"] = 3] = "Extended";
})(ZoneWidth || (ZoneWidth = {}));
var DateType;
(function(DateType2) {
  DateType2[DateType2["FullYear"] = 0] = "FullYear";
  DateType2[DateType2["Month"] = 1] = "Month";
  DateType2[DateType2["Date"] = 2] = "Date";
  DateType2[DateType2["Hours"] = 3] = "Hours";
  DateType2[DateType2["Minutes"] = 4] = "Minutes";
  DateType2[DateType2["Seconds"] = 5] = "Seconds";
  DateType2[DateType2["FractionalSeconds"] = 6] = "FractionalSeconds";
  DateType2[DateType2["Day"] = 7] = "Day";
})(DateType || (DateType = {}));
var TranslationType;
(function(TranslationType2) {
  TranslationType2[TranslationType2["DayPeriods"] = 0] = "DayPeriods";
  TranslationType2[TranslationType2["Days"] = 1] = "Days";
  TranslationType2[TranslationType2["Months"] = 2] = "Months";
  TranslationType2[TranslationType2["Eras"] = 3] = "Eras";
})(TranslationType || (TranslationType = {}));
function formatDate(value, format, locale, timezone) {
  let date = toDate(value);
  const namedFormat = getNamedFormat(locale, format);
  format = namedFormat || format;
  let parts = [];
  let match;
  while (format) {
    match = DATE_FORMATS_SPLIT.exec(format);
    if (match) {
      parts = parts.concat(match.slice(1));
      const part = parts.pop();
      if (!part) {
        break;
      }
      format = part;
    } else {
      parts.push(format);
      break;
    }
  }
  let dateTimezoneOffset = date.getTimezoneOffset();
  if (timezone) {
    dateTimezoneOffset = timezoneToOffset(timezone, dateTimezoneOffset);
    date = convertTimezoneToLocal(date, timezone, true);
  }
  let text = "";
  parts.forEach((value2) => {
    const dateFormatter = getDateFormatter(value2);
    text += dateFormatter ? dateFormatter(date, locale, dateTimezoneOffset) : value2 === "''" ? "'" : value2.replace(/(^'|'$)/g, "").replace(/''/g, "'");
  });
  return text;
}
function createDate(year, month, date) {
  const newDate = /* @__PURE__ */ new Date(0);
  newDate.setFullYear(year, month, date);
  newDate.setHours(0, 0, 0);
  return newDate;
}
function getNamedFormat(locale, format) {
  const localeId = getLocaleId2(locale);
  NAMED_FORMATS[localeId] ??= {};
  if (NAMED_FORMATS[localeId][format]) {
    return NAMED_FORMATS[localeId][format];
  }
  let formatValue2 = "";
  switch (format) {
    case "shortDate":
      formatValue2 = getLocaleDateFormat(locale, FormatWidth.Short);
      break;
    case "mediumDate":
      formatValue2 = getLocaleDateFormat(locale, FormatWidth.Medium);
      break;
    case "longDate":
      formatValue2 = getLocaleDateFormat(locale, FormatWidth.Long);
      break;
    case "fullDate":
      formatValue2 = getLocaleDateFormat(locale, FormatWidth.Full);
      break;
    case "shortTime":
      formatValue2 = getLocaleTimeFormat(locale, FormatWidth.Short);
      break;
    case "mediumTime":
      formatValue2 = getLocaleTimeFormat(locale, FormatWidth.Medium);
      break;
    case "longTime":
      formatValue2 = getLocaleTimeFormat(locale, FormatWidth.Long);
      break;
    case "fullTime":
      formatValue2 = getLocaleTimeFormat(locale, FormatWidth.Full);
      break;
    case "short":
      const shortTime = getNamedFormat(locale, "shortTime");
      const shortDate = getNamedFormat(locale, "shortDate");
      formatValue2 = formatDateTime(getLocaleDateTimeFormat(locale, FormatWidth.Short), [shortTime, shortDate]);
      break;
    case "medium":
      const mediumTime = getNamedFormat(locale, "mediumTime");
      const mediumDate = getNamedFormat(locale, "mediumDate");
      formatValue2 = formatDateTime(getLocaleDateTimeFormat(locale, FormatWidth.Medium), [mediumTime, mediumDate]);
      break;
    case "long":
      const longTime = getNamedFormat(locale, "longTime");
      const longDate = getNamedFormat(locale, "longDate");
      formatValue2 = formatDateTime(getLocaleDateTimeFormat(locale, FormatWidth.Long), [longTime, longDate]);
      break;
    case "full":
      const fullTime = getNamedFormat(locale, "fullTime");
      const fullDate = getNamedFormat(locale, "fullDate");
      formatValue2 = formatDateTime(getLocaleDateTimeFormat(locale, FormatWidth.Full), [fullTime, fullDate]);
      break;
  }
  if (formatValue2) {
    NAMED_FORMATS[localeId][format] = formatValue2;
  }
  return formatValue2;
}
function formatDateTime(str, opt_values) {
  if (opt_values) {
    str = str.replace(/\{([^}]+)}/g, function(match, key) {
      return opt_values != null && key in opt_values ? opt_values[key] : match;
    });
  }
  return str;
}
function padNumber(num, digits, minusSign = "-", trim, negWrap) {
  let neg = "";
  if (num < 0 || negWrap && num <= 0) {
    if (negWrap) {
      num = -num + 1;
    } else {
      num = -num;
      neg = minusSign;
    }
  }
  let strNum = String(num);
  while (strNum.length < digits) {
    strNum = "0" + strNum;
  }
  if (trim) {
    strNum = strNum.slice(strNum.length - digits);
  }
  return neg + strNum;
}
function formatFractionalSeconds(milliseconds, digits) {
  const strMs = padNumber(milliseconds, 3);
  return strMs.substring(0, digits);
}
function dateGetter(name, size, offset = 0, trim = false, negWrap = false) {
  return function(date, locale) {
    let part = getDatePart(name, date);
    if (offset > 0 || part > -offset) {
      part += offset;
    }
    if (name === DateType.Hours) {
      if (part === 0 && offset === -12) {
        part = 12;
      }
    } else if (name === DateType.FractionalSeconds) {
      return formatFractionalSeconds(part, size);
    }
    const localeMinus = getLocaleNumberSymbol(locale, NumberSymbol.MinusSign);
    return padNumber(part, size, localeMinus, trim, negWrap);
  };
}
function getDatePart(part, date) {
  switch (part) {
    case DateType.FullYear:
      return date.getFullYear();
    case DateType.Month:
      return date.getMonth();
    case DateType.Date:
      return date.getDate();
    case DateType.Hours:
      return date.getHours();
    case DateType.Minutes:
      return date.getMinutes();
    case DateType.Seconds:
      return date.getSeconds();
    case DateType.FractionalSeconds:
      return date.getMilliseconds();
    case DateType.Day:
      return date.getDay();
    default:
      throw new Error(`Unknown DateType value "${part}".`);
  }
}
function dateStrGetter(name, width, form = FormStyle.Format, extended = false) {
  return function(date, locale) {
    return getDateTranslation(date, locale, name, width, form, extended);
  };
}
function getDateTranslation(date, locale, name, width, form, extended) {
  switch (name) {
    case TranslationType.Months:
      return getLocaleMonthNames(locale, form, width)[date.getMonth()];
    case TranslationType.Days:
      return getLocaleDayNames(locale, form, width)[date.getDay()];
    case TranslationType.DayPeriods:
      const currentHours = date.getHours();
      const currentMinutes = date.getMinutes();
      if (extended) {
        const rules = getLocaleExtraDayPeriodRules(locale);
        const dayPeriods = getLocaleExtraDayPeriods(locale, form, width);
        const index = rules.findIndex((rule) => {
          if (Array.isArray(rule)) {
            const [from, to] = rule;
            const afterFrom = currentHours >= from.hours && currentMinutes >= from.minutes;
            const beforeTo = currentHours < to.hours || currentHours === to.hours && currentMinutes < to.minutes;
            if (from.hours < to.hours) {
              if (afterFrom && beforeTo) {
                return true;
              }
            } else if (afterFrom || beforeTo) {
              return true;
            }
          } else {
            if (rule.hours === currentHours && rule.minutes === currentMinutes) {
              return true;
            }
          }
          return false;
        });
        if (index !== -1) {
          return dayPeriods[index];
        }
      }
      return getLocaleDayPeriods(locale, form, width)[currentHours < 12 ? 0 : 1];
    case TranslationType.Eras:
      return getLocaleEraNames(locale, width)[date.getFullYear() <= 0 ? 0 : 1];
    default:
      const unexpected = name;
      throw new Error(`unexpected translation type ${unexpected}`);
  }
}
function timeZoneGetter(width) {
  return function(date, locale, offset) {
    const zone = -1 * offset;
    const minusSign = getLocaleNumberSymbol(locale, NumberSymbol.MinusSign);
    const hours = zone > 0 ? Math.floor(zone / 60) : Math.ceil(zone / 60);
    switch (width) {
      case ZoneWidth.Short:
        return (zone >= 0 ? "+" : "") + padNumber(hours, 2, minusSign) + padNumber(Math.abs(zone % 60), 2, minusSign);
      case ZoneWidth.ShortGMT:
        return "GMT" + (zone >= 0 ? "+" : "") + padNumber(hours, 1, minusSign);
      case ZoneWidth.Long:
        return "GMT" + (zone >= 0 ? "+" : "") + padNumber(hours, 2, minusSign) + ":" + padNumber(Math.abs(zone % 60), 2, minusSign);
      case ZoneWidth.Extended:
        if (offset === 0) {
          return "Z";
        } else {
          return (zone >= 0 ? "+" : "") + padNumber(hours, 2, minusSign) + ":" + padNumber(Math.abs(zone % 60), 2, minusSign);
        }
      default:
        throw new Error(`Unknown zone width "${width}"`);
    }
  };
}
var JANUARY = 0;
var THURSDAY = 4;
function getFirstThursdayOfYear(year) {
  const firstDayOfYear = createDate(year, JANUARY, 1).getDay();
  return createDate(year, 0, 1 + (firstDayOfYear <= THURSDAY ? THURSDAY : THURSDAY + 7) - firstDayOfYear);
}
function getThursdayThisIsoWeek(datetime) {
  const currentDay = datetime.getDay();
  const deltaToThursday = currentDay === 0 ? -3 : THURSDAY - currentDay;
  return createDate(datetime.getFullYear(), datetime.getMonth(), datetime.getDate() + deltaToThursday);
}
function weekGetter(size, monthBased = false) {
  return function(date, locale) {
    let result;
    if (monthBased) {
      const nbDaysBefore1stDayOfMonth = new Date(date.getFullYear(), date.getMonth(), 1).getDay() - 1;
      const today = date.getDate();
      result = 1 + Math.floor((today + nbDaysBefore1stDayOfMonth) / 7);
    } else {
      const thisThurs = getThursdayThisIsoWeek(date);
      const firstThurs = getFirstThursdayOfYear(thisThurs.getFullYear());
      const diff = thisThurs.getTime() - firstThurs.getTime();
      result = 1 + Math.round(diff / 6048e5);
    }
    return padNumber(result, size, getLocaleNumberSymbol(locale, NumberSymbol.MinusSign));
  };
}
function weekNumberingYearGetter(size, trim = false) {
  return function(date, locale) {
    const thisThurs = getThursdayThisIsoWeek(date);
    const weekNumberingYear = thisThurs.getFullYear();
    return padNumber(weekNumberingYear, size, getLocaleNumberSymbol(locale, NumberSymbol.MinusSign), trim);
  };
}
var DATE_FORMATS = {};
function getDateFormatter(format) {
  if (DATE_FORMATS[format]) {
    return DATE_FORMATS[format];
  }
  let formatter;
  switch (format) {
    case "G":
    case "GG":
    case "GGG":
      formatter = dateStrGetter(TranslationType.Eras, TranslationWidth.Abbreviated);
      break;
    case "GGGG":
      formatter = dateStrGetter(TranslationType.Eras, TranslationWidth.Wide);
      break;
    case "GGGGG":
      formatter = dateStrGetter(TranslationType.Eras, TranslationWidth.Narrow);
      break;
    case "y":
      formatter = dateGetter(DateType.FullYear, 1, 0, false, true);
      break;
    case "yy":
      formatter = dateGetter(DateType.FullYear, 2, 0, true, true);
      break;
    case "yyy":
      formatter = dateGetter(DateType.FullYear, 3, 0, false, true);
      break;
    case "yyyy":
      formatter = dateGetter(DateType.FullYear, 4, 0, false, true);
      break;
    case "Y":
      formatter = weekNumberingYearGetter(1);
      break;
    case "YY":
      formatter = weekNumberingYearGetter(2, true);
      break;
    case "YYY":
      formatter = weekNumberingYearGetter(3);
      break;
    case "YYYY":
      formatter = weekNumberingYearGetter(4);
      break;
    case "M":
    case "L":
      formatter = dateGetter(DateType.Month, 1, 1);
      break;
    case "MM":
    case "LL":
      formatter = dateGetter(DateType.Month, 2, 1);
      break;
    case "MMM":
      formatter = dateStrGetter(TranslationType.Months, TranslationWidth.Abbreviated);
      break;
    case "MMMM":
      formatter = dateStrGetter(TranslationType.Months, TranslationWidth.Wide);
      break;
    case "MMMMM":
      formatter = dateStrGetter(TranslationType.Months, TranslationWidth.Narrow);
      break;
    case "LLL":
      formatter = dateStrGetter(TranslationType.Months, TranslationWidth.Abbreviated, FormStyle.Standalone);
      break;
    case "LLLL":
      formatter = dateStrGetter(TranslationType.Months, TranslationWidth.Wide, FormStyle.Standalone);
      break;
    case "LLLLL":
      formatter = dateStrGetter(TranslationType.Months, TranslationWidth.Narrow, FormStyle.Standalone);
      break;
    case "w":
      formatter = weekGetter(1);
      break;
    case "ww":
      formatter = weekGetter(2);
      break;
    case "W":
      formatter = weekGetter(1, true);
      break;
    case "d":
      formatter = dateGetter(DateType.Date, 1);
      break;
    case "dd":
      formatter = dateGetter(DateType.Date, 2);
      break;
    case "c":
    case "cc":
      formatter = dateGetter(DateType.Day, 1);
      break;
    case "ccc":
      formatter = dateStrGetter(TranslationType.Days, TranslationWidth.Abbreviated, FormStyle.Standalone);
      break;
    case "cccc":
      formatter = dateStrGetter(TranslationType.Days, TranslationWidth.Wide, FormStyle.Standalone);
      break;
    case "ccccc":
      formatter = dateStrGetter(TranslationType.Days, TranslationWidth.Narrow, FormStyle.Standalone);
      break;
    case "cccccc":
      formatter = dateStrGetter(TranslationType.Days, TranslationWidth.Short, FormStyle.Standalone);
      break;
    case "E":
    case "EE":
    case "EEE":
      formatter = dateStrGetter(TranslationType.Days, TranslationWidth.Abbreviated);
      break;
    case "EEEE":
      formatter = dateStrGetter(TranslationType.Days, TranslationWidth.Wide);
      break;
    case "EEEEE":
      formatter = dateStrGetter(TranslationType.Days, TranslationWidth.Narrow);
      break;
    case "EEEEEE":
      formatter = dateStrGetter(TranslationType.Days, TranslationWidth.Short);
      break;
    case "a":
    case "aa":
    case "aaa":
      formatter = dateStrGetter(TranslationType.DayPeriods, TranslationWidth.Abbreviated);
      break;
    case "aaaa":
      formatter = dateStrGetter(TranslationType.DayPeriods, TranslationWidth.Wide);
      break;
    case "aaaaa":
      formatter = dateStrGetter(TranslationType.DayPeriods, TranslationWidth.Narrow);
      break;
    case "b":
    case "bb":
    case "bbb":
      formatter = dateStrGetter(TranslationType.DayPeriods, TranslationWidth.Abbreviated, FormStyle.Standalone, true);
      break;
    case "bbbb":
      formatter = dateStrGetter(TranslationType.DayPeriods, TranslationWidth.Wide, FormStyle.Standalone, true);
      break;
    case "bbbbb":
      formatter = dateStrGetter(TranslationType.DayPeriods, TranslationWidth.Narrow, FormStyle.Standalone, true);
      break;
    case "B":
    case "BB":
    case "BBB":
      formatter = dateStrGetter(TranslationType.DayPeriods, TranslationWidth.Abbreviated, FormStyle.Format, true);
      break;
    case "BBBB":
      formatter = dateStrGetter(TranslationType.DayPeriods, TranslationWidth.Wide, FormStyle.Format, true);
      break;
    case "BBBBB":
      formatter = dateStrGetter(TranslationType.DayPeriods, TranslationWidth.Narrow, FormStyle.Format, true);
      break;
    case "h":
      formatter = dateGetter(DateType.Hours, 1, -12);
      break;
    case "hh":
      formatter = dateGetter(DateType.Hours, 2, -12);
      break;
    case "H":
      formatter = dateGetter(DateType.Hours, 1);
      break;
    case "HH":
      formatter = dateGetter(DateType.Hours, 2);
      break;
    case "m":
      formatter = dateGetter(DateType.Minutes, 1);
      break;
    case "mm":
      formatter = dateGetter(DateType.Minutes, 2);
      break;
    case "s":
      formatter = dateGetter(DateType.Seconds, 1);
      break;
    case "ss":
      formatter = dateGetter(DateType.Seconds, 2);
      break;
    case "S":
      formatter = dateGetter(DateType.FractionalSeconds, 1);
      break;
    case "SS":
      formatter = dateGetter(DateType.FractionalSeconds, 2);
      break;
    case "SSS":
      formatter = dateGetter(DateType.FractionalSeconds, 3);
      break;
    case "Z":
    case "ZZ":
    case "ZZZ":
      formatter = timeZoneGetter(ZoneWidth.Short);
      break;
    case "ZZZZZ":
      formatter = timeZoneGetter(ZoneWidth.Extended);
      break;
    case "O":
    case "OO":
    case "OOO":
    case "z":
    case "zz":
    case "zzz":
      formatter = timeZoneGetter(ZoneWidth.ShortGMT);
      break;
    case "OOOO":
    case "ZZZZ":
    case "zzzz":
      formatter = timeZoneGetter(ZoneWidth.Long);
      break;
    default:
      return null;
  }
  DATE_FORMATS[format] = formatter;
  return formatter;
}
function timezoneToOffset(timezone, fallback) {
  timezone = timezone.replace(/:/g, "");
  const requestedTimezoneOffset = Date.parse("Jan 01, 1970 00:00:00 " + timezone) / 6e4;
  return isNaN(requestedTimezoneOffset) ? fallback : requestedTimezoneOffset;
}
function addDateMinutes(date, minutes) {
  date = new Date(date.getTime());
  date.setMinutes(date.getMinutes() + minutes);
  return date;
}
function convertTimezoneToLocal(date, timezone, reverse) {
  const reverseValue = reverse ? -1 : 1;
  const dateTimezoneOffset = date.getTimezoneOffset();
  const timezoneOffset = timezoneToOffset(timezone, dateTimezoneOffset);
  return addDateMinutes(date, reverseValue * (timezoneOffset - dateTimezoneOffset));
}
function toDate(value) {
  if (isDate(value)) {
    return value;
  }
  if (typeof value === "number" && !isNaN(value)) {
    return new Date(value);
  }
  if (typeof value === "string") {
    value = value.trim();
    if (/^(\d{4}(-\d{1,2}(-\d{1,2})?)?)$/.test(value)) {
      const [y, m = 1, d = 1] = value.split("-").map((val) => +val);
      return createDate(y, m - 1, d);
    }
    const parsedNb = parseFloat(value);
    if (!isNaN(value - parsedNb)) {
      return new Date(parsedNb);
    }
    let match;
    if (match = value.match(ISO8601_DATE_REGEX)) {
      return isoStringToDate(match);
    }
  }
  const date = new Date(value);
  if (!isDate(date)) {
    throw new Error(`Unable to convert "${value}" into a date`);
  }
  return date;
}
function isoStringToDate(match) {
  const date = /* @__PURE__ */ new Date(0);
  let tzHour = 0;
  let tzMin = 0;
  const dateSetter = match[8] ? date.setUTCFullYear : date.setFullYear;
  const timeSetter = match[8] ? date.setUTCHours : date.setHours;
  if (match[9]) {
    tzHour = Number(match[9] + match[10]);
    tzMin = Number(match[9] + match[11]);
  }
  dateSetter.call(date, Number(match[1]), Number(match[2]) - 1, Number(match[3]));
  const h = Number(match[4] || 0) - tzHour;
  const m = Number(match[5] || 0) - tzMin;
  const s = Number(match[6] || 0);
  const ms = Math.floor(parseFloat("0." + (match[7] || 0)) * 1e3);
  timeSetter.call(date, h, m, s, ms);
  return date;
}
function isDate(value) {
  return value instanceof Date && !isNaN(value.valueOf());
}
var NUMBER_FORMAT_REGEXP = /^(\d+)?\.((\d+)(-(\d+))?)?$/;
var MAX_DIGITS = 22;
var DECIMAL_SEP = ".";
var ZERO_CHAR = "0";
var PATTERN_SEP = ";";
var GROUP_SEP = ",";
var DIGIT_CHAR = "#";
var CURRENCY_CHAR = "¤";
var PERCENT_CHAR = "%";
function formatNumberToLocaleString(value, pattern, locale, groupSymbol, decimalSymbol, digitsInfo, isPercent = false) {
  let formattedText = "";
  let isZero = false;
  if (!isFinite(value)) {
    formattedText = getLocaleNumberSymbol(locale, NumberSymbol.Infinity);
  } else {
    let parsedNumber = parseNumber(value);
    if (isPercent) {
      parsedNumber = toPercent(parsedNumber);
    }
    let minInt = pattern.minInt;
    let minFraction = pattern.minFrac;
    let maxFraction = pattern.maxFrac;
    if (digitsInfo) {
      const parts = digitsInfo.match(NUMBER_FORMAT_REGEXP);
      if (parts === null) {
        throw new Error(`${digitsInfo} is not a valid digit info`);
      }
      const minIntPart = parts[1];
      const minFractionPart = parts[3];
      const maxFractionPart = parts[5];
      if (minIntPart != null) {
        minInt = parseIntAutoRadix(minIntPart);
      }
      if (minFractionPart != null) {
        minFraction = parseIntAutoRadix(minFractionPart);
      }
      if (maxFractionPart != null) {
        maxFraction = parseIntAutoRadix(maxFractionPart);
      } else if (minFractionPart != null && minFraction > maxFraction) {
        maxFraction = minFraction;
      }
    }
    roundNumber(parsedNumber, minFraction, maxFraction);
    let digits = parsedNumber.digits;
    let integerLen = parsedNumber.integerLen;
    const exponent = parsedNumber.exponent;
    let decimals = [];
    isZero = digits.every((d) => !d);
    for (; integerLen < minInt; integerLen++) {
      digits.unshift(0);
    }
    for (; integerLen < 0; integerLen++) {
      digits.unshift(0);
    }
    if (integerLen > 0) {
      decimals = digits.splice(integerLen, digits.length);
    } else {
      decimals = digits;
      digits = [0];
    }
    const groups = [];
    if (digits.length >= pattern.lgSize) {
      groups.unshift(digits.splice(-pattern.lgSize, digits.length).join(""));
    }
    while (digits.length > pattern.gSize) {
      groups.unshift(digits.splice(-pattern.gSize, digits.length).join(""));
    }
    if (digits.length) {
      groups.unshift(digits.join(""));
    }
    formattedText = groups.join(getLocaleNumberSymbol(locale, groupSymbol));
    if (decimals.length) {
      formattedText += getLocaleNumberSymbol(locale, decimalSymbol) + decimals.join("");
    }
    if (exponent) {
      formattedText += getLocaleNumberSymbol(locale, NumberSymbol.Exponential) + "+" + exponent;
    }
  }
  if (value < 0 && !isZero) {
    formattedText = pattern.negPre + formattedText + pattern.negSuf;
  } else {
    formattedText = pattern.posPre + formattedText + pattern.posSuf;
  }
  return formattedText;
}
function formatCurrency(value, locale, currency, currencyCode, digitsInfo) {
  const format = getLocaleNumberFormat(locale, NumberFormatStyle.Currency);
  const pattern = parseNumberFormat(format, getLocaleNumberSymbol(locale, NumberSymbol.MinusSign));
  pattern.minFrac = getNumberOfCurrencyDigits(currencyCode);
  pattern.maxFrac = pattern.minFrac;
  const res = formatNumberToLocaleString(value, pattern, locale, NumberSymbol.CurrencyGroup, NumberSymbol.CurrencyDecimal, digitsInfo);
  return res.replace(CURRENCY_CHAR, currency).replace(CURRENCY_CHAR, "").trim();
}
function formatPercent(value, locale, digitsInfo) {
  const format = getLocaleNumberFormat(locale, NumberFormatStyle.Percent);
  const pattern = parseNumberFormat(format, getLocaleNumberSymbol(locale, NumberSymbol.MinusSign));
  const res = formatNumberToLocaleString(value, pattern, locale, NumberSymbol.Group, NumberSymbol.Decimal, digitsInfo, true);
  return res.replace(new RegExp(PERCENT_CHAR, "g"), getLocaleNumberSymbol(locale, NumberSymbol.PercentSign));
}
function formatNumber(value, locale, digitsInfo) {
  const format = getLocaleNumberFormat(locale, NumberFormatStyle.Decimal);
  const pattern = parseNumberFormat(format, getLocaleNumberSymbol(locale, NumberSymbol.MinusSign));
  return formatNumberToLocaleString(value, pattern, locale, NumberSymbol.Group, NumberSymbol.Decimal, digitsInfo);
}
function parseNumberFormat(format, minusSign = "-") {
  const p = {
    minInt: 1,
    minFrac: 0,
    maxFrac: 0,
    posPre: "",
    posSuf: "",
    negPre: "",
    negSuf: "",
    gSize: 0,
    lgSize: 0
  };
  const patternParts = format.split(PATTERN_SEP);
  const positive = patternParts[0];
  const negative = patternParts[1];
  const positiveParts = positive.indexOf(DECIMAL_SEP) !== -1 ? positive.split(DECIMAL_SEP) : [positive.substring(0, positive.lastIndexOf(ZERO_CHAR) + 1), positive.substring(positive.lastIndexOf(ZERO_CHAR) + 1)], integer = positiveParts[0], fraction = positiveParts[1] || "";
  p.posPre = integer.substring(0, integer.indexOf(DIGIT_CHAR));
  for (let i = 0; i < fraction.length; i++) {
    const ch = fraction.charAt(i);
    if (ch === ZERO_CHAR) {
      p.minFrac = p.maxFrac = i + 1;
    } else if (ch === DIGIT_CHAR) {
      p.maxFrac = i + 1;
    } else {
      p.posSuf += ch;
    }
  }
  const groups = integer.split(GROUP_SEP);
  p.gSize = groups[1] ? groups[1].length : 0;
  p.lgSize = groups[2] || groups[1] ? (groups[2] || groups[1]).length : 0;
  if (negative) {
    const trunkLen = positive.length - p.posPre.length - p.posSuf.length, pos = negative.indexOf(DIGIT_CHAR);
    p.negPre = negative.substring(0, pos).replace(/'/g, "");
    p.negSuf = negative.slice(pos + trunkLen).replace(/'/g, "");
  } else {
    p.negPre = minusSign + p.posPre;
    p.negSuf = p.posSuf;
  }
  return p;
}
function toPercent(parsedNumber) {
  if (parsedNumber.digits[0] === 0) {
    return parsedNumber;
  }
  const fractionLen = parsedNumber.digits.length - parsedNumber.integerLen;
  if (parsedNumber.exponent) {
    parsedNumber.exponent += 2;
  } else {
    if (fractionLen === 0) {
      parsedNumber.digits.push(0, 0);
    } else if (fractionLen === 1) {
      parsedNumber.digits.push(0);
    }
    parsedNumber.integerLen += 2;
  }
  return parsedNumber;
}
function parseNumber(num) {
  let numStr = Math.abs(num) + "";
  let exponent = 0, digits, integerLen;
  let i, j, zeros;
  if ((integerLen = numStr.indexOf(DECIMAL_SEP)) > -1) {
    numStr = numStr.replace(DECIMAL_SEP, "");
  }
  if ((i = numStr.search(/e/i)) > 0) {
    if (integerLen < 0) integerLen = i;
    integerLen += +numStr.slice(i + 1);
    numStr = numStr.substring(0, i);
  } else if (integerLen < 0) {
    integerLen = numStr.length;
  }
  for (i = 0; numStr.charAt(i) === ZERO_CHAR; i++) {
  }
  if (i === (zeros = numStr.length)) {
    digits = [0];
    integerLen = 1;
  } else {
    zeros--;
    while (numStr.charAt(zeros) === ZERO_CHAR) zeros--;
    integerLen -= i;
    digits = [];
    for (j = 0; i <= zeros; i++, j++) {
      digits[j] = Number(numStr.charAt(i));
    }
  }
  if (integerLen > MAX_DIGITS) {
    digits = digits.splice(0, MAX_DIGITS - 1);
    exponent = integerLen - 1;
    integerLen = 1;
  }
  return {
    digits,
    exponent,
    integerLen
  };
}
function roundNumber(parsedNumber, minFrac, maxFrac) {
  if (minFrac > maxFrac) {
    throw new Error(`The minimum number of digits after fraction (${minFrac}) is higher than the maximum (${maxFrac}).`);
  }
  let digits = parsedNumber.digits;
  let fractionLen = digits.length - parsedNumber.integerLen;
  const fractionSize = Math.min(Math.max(minFrac, fractionLen), maxFrac);
  let roundAt = fractionSize + parsedNumber.integerLen;
  let digit = digits[roundAt];
  if (roundAt > 0) {
    digits.splice(Math.max(parsedNumber.integerLen, roundAt));
    for (let j = roundAt; j < digits.length; j++) {
      digits[j] = 0;
    }
  } else {
    fractionLen = Math.max(0, fractionLen);
    parsedNumber.integerLen = 1;
    digits.length = Math.max(1, roundAt = fractionSize + 1);
    digits[0] = 0;
    for (let i = 1; i < roundAt; i++) digits[i] = 0;
  }
  if (digit >= 5) {
    if (roundAt - 1 < 0) {
      for (let k = 0; k > roundAt; k--) {
        digits.unshift(0);
        parsedNumber.integerLen++;
      }
      digits.unshift(1);
      parsedNumber.integerLen++;
    } else {
      digits[roundAt - 1]++;
    }
  }
  for (; fractionLen < Math.max(0, fractionSize); fractionLen++) digits.push(0);
  let dropTrailingZeros = fractionSize !== 0;
  const minLen = minFrac + parsedNumber.integerLen;
  const carry = digits.reduceRight(function(carry2, d, i, digits2) {
    d = d + carry2;
    digits2[i] = d < 10 ? d : d - 10;
    if (dropTrailingZeros) {
      if (digits2[i] === 0 && i >= minLen) {
        digits2.pop();
      } else {
        dropTrailingZeros = false;
      }
    }
    return d >= 10 ? 1 : 0;
  }, 0);
  if (carry) {
    digits.unshift(carry);
    parsedNumber.integerLen++;
  }
}
function parseIntAutoRadix(text) {
  const result = parseInt(text);
  if (isNaN(result)) {
    throw new Error("Invalid integer literal when parsing " + text);
  }
  return result;
}
var NgLocalization = class _NgLocalization {
  static {
    this.ɵfac = function NgLocalization_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _NgLocalization)();
    };
  }
  static {
    this.ɵprov = ɵɵdefineInjectable({
      token: _NgLocalization,
      factory: function NgLocalization_Factory(__ngFactoryType__) {
        let __ngConditionalFactory__ = null;
        if (__ngFactoryType__) {
          __ngConditionalFactory__ = new __ngFactoryType__();
        } else {
          __ngConditionalFactory__ = ((locale) => new NgLocaleLocalization(locale))(ɵɵinject(LOCALE_ID));
        }
        return __ngConditionalFactory__;
      },
      providedIn: "root"
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NgLocalization, [{
    type: Injectable,
    args: [{
      providedIn: "root",
      useFactory: (locale) => new NgLocaleLocalization(locale),
      deps: [LOCALE_ID]
    }]
  }], null, null);
})();
function getPluralCategory(value, cases, ngLocalization, locale) {
  let key = `=${value}`;
  if (cases.indexOf(key) > -1) {
    return key;
  }
  key = ngLocalization.getPluralCategory(value, locale);
  if (cases.indexOf(key) > -1) {
    return key;
  }
  if (cases.indexOf("other") > -1) {
    return "other";
  }
  throw new Error(`No plural message found for value "${value}"`);
}
var NgLocaleLocalization = class _NgLocaleLocalization extends NgLocalization {
  constructor(locale) {
    super();
    this.locale = locale;
  }
  getPluralCategory(value, locale) {
    const plural2 = getLocalePluralCase2(locale || this.locale)(value);
    switch (plural2) {
      case Plural.Zero:
        return "zero";
      case Plural.One:
        return "one";
      case Plural.Two:
        return "two";
      case Plural.Few:
        return "few";
      case Plural.Many:
        return "many";
      default:
        return "other";
    }
  }
  static {
    this.ɵfac = function NgLocaleLocalization_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _NgLocaleLocalization)(ɵɵinject(LOCALE_ID));
    };
  }
  static {
    this.ɵprov = ɵɵdefineInjectable({
      token: _NgLocaleLocalization,
      factory: _NgLocaleLocalization.ɵfac
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NgLocaleLocalization, [{
    type: Injectable
  }], () => [{
    type: void 0,
    decorators: [{
      type: Inject,
      args: [LOCALE_ID]
    }]
  }], null);
})();
var WS_REGEXP = /\s+/;
var EMPTY_ARRAY2 = [];
var NgClass = class _NgClass {
  constructor(_ngEl, _renderer) {
    this._ngEl = _ngEl;
    this._renderer = _renderer;
    this.initialClasses = EMPTY_ARRAY2;
    this.stateMap = /* @__PURE__ */ new Map();
  }
  set klass(value) {
    this.initialClasses = value != null ? value.trim().split(WS_REGEXP) : EMPTY_ARRAY2;
  }
  set ngClass(value) {
    this.rawClass = typeof value === "string" ? value.trim().split(WS_REGEXP) : value;
  }
  /*
  The NgClass directive uses the custom change detection algorithm for its inputs. The custom
  algorithm is necessary since inputs are represented as complex object or arrays that need to be
  deeply-compared.
     This algorithm is perf-sensitive since NgClass is used very frequently and its poor performance
  might negatively impact runtime performance of the entire change detection cycle. The design of
  this algorithm is making sure that:
  - there is no unnecessary DOM manipulation (CSS classes are added / removed from the DOM only when
  needed), even if references to bound objects change;
  - there is no memory allocation if nothing changes (even relatively modest memory allocation
  during the change detection cycle can result in GC pauses for some of the CD cycles).
     The algorithm works by iterating over the set of bound classes, staring with [class] binding and
  then going over [ngClass] binding. For each CSS class name:
  - check if it was seen before (this information is tracked in the state map) and if its value
  changed;
  - mark it as "touched" - names that are not marked are not present in the latest set of binding
  and we can remove such class name from the internal data structures;
     After iteration over all the CSS class names we've got data structure with all the information
  necessary to synchronize changes to the DOM - it is enough to iterate over the state map, flush
  changes to the DOM and reset internal data structures so those are ready for the next change
  detection cycle.
   */
  ngDoCheck() {
    for (const klass of this.initialClasses) {
      this._updateState(klass, true);
    }
    const rawClass = this.rawClass;
    if (Array.isArray(rawClass) || rawClass instanceof Set) {
      for (const klass of rawClass) {
        this._updateState(klass, true);
      }
    } else if (rawClass != null) {
      for (const klass of Object.keys(rawClass)) {
        this._updateState(klass, Boolean(rawClass[klass]));
      }
    }
    this._applyStateDiff();
  }
  _updateState(klass, nextEnabled) {
    const state = this.stateMap.get(klass);
    if (state !== void 0) {
      if (state.enabled !== nextEnabled) {
        state.changed = true;
        state.enabled = nextEnabled;
      }
      state.touched = true;
    } else {
      this.stateMap.set(klass, {
        enabled: nextEnabled,
        changed: true,
        touched: true
      });
    }
  }
  _applyStateDiff() {
    for (const stateEntry of this.stateMap) {
      const klass = stateEntry[0];
      const state = stateEntry[1];
      if (state.changed) {
        this._toggleClass(klass, state.enabled);
        state.changed = false;
      } else if (!state.touched) {
        if (state.enabled) {
          this._toggleClass(klass, false);
        }
        this.stateMap.delete(klass);
      }
      state.touched = false;
    }
  }
  _toggleClass(klass, enabled) {
    if (ngDevMode) {
      if (typeof klass !== "string") {
        throw new Error(`NgClass can only toggle CSS classes expressed as strings, got ${stringify(klass)}`);
      }
    }
    klass = klass.trim();
    if (klass.length > 0) {
      klass.split(WS_REGEXP).forEach((klass2) => {
        if (enabled) {
          this._renderer.addClass(this._ngEl.nativeElement, klass2);
        } else {
          this._renderer.removeClass(this._ngEl.nativeElement, klass2);
        }
      });
    }
  }
  static {
    this.ɵfac = function NgClass_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _NgClass)(ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(Renderer2));
    };
  }
  static {
    this.ɵdir = ɵɵdefineDirective({
      type: _NgClass,
      selectors: [["", "ngClass", ""]],
      inputs: {
        klass: [0, "class", "klass"],
        ngClass: "ngClass"
      },
      standalone: true
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NgClass, [{
    type: Directive,
    args: [{
      selector: "[ngClass]",
      standalone: true
    }]
  }], () => [{
    type: ElementRef
  }, {
    type: Renderer2
  }], {
    klass: [{
      type: Input,
      args: ["class"]
    }],
    ngClass: [{
      type: Input,
      args: ["ngClass"]
    }]
  });
})();
var NgComponentOutlet = class _NgComponentOutlet {
  constructor(_viewContainerRef) {
    this._viewContainerRef = _viewContainerRef;
    this.ngComponentOutlet = null;
    this._inputsUsed = /* @__PURE__ */ new Map();
  }
  _needToReCreateNgModuleInstance(changes) {
    return changes["ngComponentOutletNgModule"] !== void 0 || changes["ngComponentOutletNgModuleFactory"] !== void 0;
  }
  _needToReCreateComponentInstance(changes) {
    return changes["ngComponentOutlet"] !== void 0 || changes["ngComponentOutletContent"] !== void 0 || changes["ngComponentOutletInjector"] !== void 0 || this._needToReCreateNgModuleInstance(changes);
  }
  /** @nodoc */
  ngOnChanges(changes) {
    if (this._needToReCreateComponentInstance(changes)) {
      this._viewContainerRef.clear();
      this._inputsUsed.clear();
      this._componentRef = void 0;
      if (this.ngComponentOutlet) {
        const injector = this.ngComponentOutletInjector || this._viewContainerRef.parentInjector;
        if (this._needToReCreateNgModuleInstance(changes)) {
          this._moduleRef?.destroy();
          if (this.ngComponentOutletNgModule) {
            this._moduleRef = createNgModule(this.ngComponentOutletNgModule, getParentInjector(injector));
          } else if (this.ngComponentOutletNgModuleFactory) {
            this._moduleRef = this.ngComponentOutletNgModuleFactory.create(getParentInjector(injector));
          } else {
            this._moduleRef = void 0;
          }
        }
        this._componentRef = this._viewContainerRef.createComponent(this.ngComponentOutlet, {
          injector,
          ngModuleRef: this._moduleRef,
          projectableNodes: this.ngComponentOutletContent
        });
      }
    }
  }
  /** @nodoc */
  ngDoCheck() {
    if (this._componentRef) {
      if (this.ngComponentOutletInputs) {
        for (const inputName of Object.keys(this.ngComponentOutletInputs)) {
          this._inputsUsed.set(inputName, true);
        }
      }
      this._applyInputStateDiff(this._componentRef);
    }
  }
  /** @nodoc */
  ngOnDestroy() {
    this._moduleRef?.destroy();
  }
  _applyInputStateDiff(componentRef) {
    for (const [inputName, touched] of this._inputsUsed) {
      if (!touched) {
        componentRef.setInput(inputName, void 0);
        this._inputsUsed.delete(inputName);
      } else {
        componentRef.setInput(inputName, this.ngComponentOutletInputs[inputName]);
        this._inputsUsed.set(inputName, false);
      }
    }
  }
  static {
    this.ɵfac = function NgComponentOutlet_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _NgComponentOutlet)(ɵɵdirectiveInject(ViewContainerRef));
    };
  }
  static {
    this.ɵdir = ɵɵdefineDirective({
      type: _NgComponentOutlet,
      selectors: [["", "ngComponentOutlet", ""]],
      inputs: {
        ngComponentOutlet: "ngComponentOutlet",
        ngComponentOutletInputs: "ngComponentOutletInputs",
        ngComponentOutletInjector: "ngComponentOutletInjector",
        ngComponentOutletContent: "ngComponentOutletContent",
        ngComponentOutletNgModule: "ngComponentOutletNgModule",
        ngComponentOutletNgModuleFactory: "ngComponentOutletNgModuleFactory"
      },
      standalone: true,
      features: [ɵɵNgOnChangesFeature]
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NgComponentOutlet, [{
    type: Directive,
    args: [{
      selector: "[ngComponentOutlet]",
      standalone: true
    }]
  }], () => [{
    type: ViewContainerRef
  }], {
    ngComponentOutlet: [{
      type: Input
    }],
    ngComponentOutletInputs: [{
      type: Input
    }],
    ngComponentOutletInjector: [{
      type: Input
    }],
    ngComponentOutletContent: [{
      type: Input
    }],
    ngComponentOutletNgModule: [{
      type: Input
    }],
    ngComponentOutletNgModuleFactory: [{
      type: Input
    }]
  });
})();
function getParentInjector(injector) {
  const parentNgModule = injector.get(NgModuleRef$1);
  return parentNgModule.injector;
}
var NgForOfContext = class {
  constructor($implicit, ngForOf, index, count) {
    this.$implicit = $implicit;
    this.ngForOf = ngForOf;
    this.index = index;
    this.count = count;
  }
  get first() {
    return this.index === 0;
  }
  get last() {
    return this.index === this.count - 1;
  }
  get even() {
    return this.index % 2 === 0;
  }
  get odd() {
    return !this.even;
  }
};
var NgForOf = class _NgForOf {
  /**
   * The value of the iterable expression, which can be used as a
   * [template input variable](guide/directives/structural-directives#shorthand).
   */
  set ngForOf(ngForOf) {
    this._ngForOf = ngForOf;
    this._ngForOfDirty = true;
  }
  /**
   * Specifies a custom `TrackByFunction` to compute the identity of items in an iterable.
   *
   * If a custom `TrackByFunction` is not provided, `NgForOf` will use the item's [object
   * identity](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is)
   * as the key.
   *
   * `NgForOf` uses the computed key to associate items in an iterable with DOM elements
   * it produces for these items.
   *
   * A custom `TrackByFunction` is useful to provide good user experience in cases when items in an
   * iterable rendered using `NgForOf` have a natural identifier (for example, custom ID or a
   * primary key), and this iterable could be updated with new object instances that still
   * represent the same underlying entity (for example, when data is re-fetched from the server,
   * and the iterable is recreated and re-rendered, but most of the data is still the same).
   *
   * @see {@link TrackByFunction}
   */
  set ngForTrackBy(fn) {
    if ((typeof ngDevMode === "undefined" || ngDevMode) && fn != null && typeof fn !== "function") {
      console.warn(`trackBy must be a function, but received ${JSON.stringify(fn)}. See https://angular.io/api/common/NgForOf#change-propagation for more information.`);
    }
    this._trackByFn = fn;
  }
  get ngForTrackBy() {
    return this._trackByFn;
  }
  constructor(_viewContainer, _template, _differs) {
    this._viewContainer = _viewContainer;
    this._template = _template;
    this._differs = _differs;
    this._ngForOf = null;
    this._ngForOfDirty = true;
    this._differ = null;
  }
  /**
   * A reference to the template that is stamped out for each item in the iterable.
   * @see [template reference variable](guide/templates/reference-variables)
   */
  set ngForTemplate(value) {
    if (value) {
      this._template = value;
    }
  }
  /**
   * Applies the changes when needed.
   * @nodoc
   */
  ngDoCheck() {
    if (this._ngForOfDirty) {
      this._ngForOfDirty = false;
      const value = this._ngForOf;
      if (!this._differ && value) {
        if (typeof ngDevMode === "undefined" || ngDevMode) {
          try {
            this._differ = this._differs.find(value).create(this.ngForTrackBy);
          } catch {
            let errorMessage = `Cannot find a differ supporting object '${value}' of type '${getTypeName(value)}'. NgFor only supports binding to Iterables, such as Arrays.`;
            if (typeof value === "object") {
              errorMessage += " Did you mean to use the keyvalue pipe?";
            }
            throw new RuntimeError(-2200, errorMessage);
          }
        } else {
          this._differ = this._differs.find(value).create(this.ngForTrackBy);
        }
      }
    }
    if (this._differ) {
      const changes = this._differ.diff(this._ngForOf);
      if (changes) this._applyChanges(changes);
    }
  }
  _applyChanges(changes) {
    const viewContainer = this._viewContainer;
    changes.forEachOperation((item, adjustedPreviousIndex, currentIndex) => {
      if (item.previousIndex == null) {
        viewContainer.createEmbeddedView(this._template, new NgForOfContext(item.item, this._ngForOf, -1, -1), currentIndex === null ? void 0 : currentIndex);
      } else if (currentIndex == null) {
        viewContainer.remove(adjustedPreviousIndex === null ? void 0 : adjustedPreviousIndex);
      } else if (adjustedPreviousIndex !== null) {
        const view = viewContainer.get(adjustedPreviousIndex);
        viewContainer.move(view, currentIndex);
        applyViewChange(view, item);
      }
    });
    for (let i = 0, ilen = viewContainer.length; i < ilen; i++) {
      const viewRef = viewContainer.get(i);
      const context = viewRef.context;
      context.index = i;
      context.count = ilen;
      context.ngForOf = this._ngForOf;
    }
    changes.forEachIdentityChange((record) => {
      const viewRef = viewContainer.get(record.currentIndex);
      applyViewChange(viewRef, record);
    });
  }
  /**
   * Asserts the correct type of the context for the template that `NgForOf` will render.
   *
   * The presence of this method is a signal to the Ivy template type-check compiler that the
   * `NgForOf` structural directive renders its template with a specific context type.
   */
  static ngTemplateContextGuard(dir, ctx) {
    return true;
  }
  static {
    this.ɵfac = function NgForOf_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _NgForOf)(ɵɵdirectiveInject(ViewContainerRef), ɵɵdirectiveInject(TemplateRef), ɵɵdirectiveInject(IterableDiffers));
    };
  }
  static {
    this.ɵdir = ɵɵdefineDirective({
      type: _NgForOf,
      selectors: [["", "ngFor", "", "ngForOf", ""]],
      inputs: {
        ngForOf: "ngForOf",
        ngForTrackBy: "ngForTrackBy",
        ngForTemplate: "ngForTemplate"
      },
      standalone: true
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NgForOf, [{
    type: Directive,
    args: [{
      selector: "[ngFor][ngForOf]",
      standalone: true
    }]
  }], () => [{
    type: ViewContainerRef
  }, {
    type: TemplateRef
  }, {
    type: IterableDiffers
  }], {
    ngForOf: [{
      type: Input
    }],
    ngForTrackBy: [{
      type: Input
    }],
    ngForTemplate: [{
      type: Input
    }]
  });
})();
function applyViewChange(view, record) {
  view.context.$implicit = record.item;
}
function getTypeName(type) {
  return type["name"] || typeof type;
}
var NgIf = class _NgIf {
  constructor(_viewContainer, templateRef) {
    this._viewContainer = _viewContainer;
    this._context = new NgIfContext();
    this._thenTemplateRef = null;
    this._elseTemplateRef = null;
    this._thenViewRef = null;
    this._elseViewRef = null;
    this._thenTemplateRef = templateRef;
  }
  /**
   * The Boolean expression to evaluate as the condition for showing a template.
   */
  set ngIf(condition) {
    this._context.$implicit = this._context.ngIf = condition;
    this._updateView();
  }
  /**
   * A template to show if the condition expression evaluates to true.
   */
  set ngIfThen(templateRef) {
    assertTemplate("ngIfThen", templateRef);
    this._thenTemplateRef = templateRef;
    this._thenViewRef = null;
    this._updateView();
  }
  /**
   * A template to show if the condition expression evaluates to false.
   */
  set ngIfElse(templateRef) {
    assertTemplate("ngIfElse", templateRef);
    this._elseTemplateRef = templateRef;
    this._elseViewRef = null;
    this._updateView();
  }
  _updateView() {
    if (this._context.$implicit) {
      if (!this._thenViewRef) {
        this._viewContainer.clear();
        this._elseViewRef = null;
        if (this._thenTemplateRef) {
          this._thenViewRef = this._viewContainer.createEmbeddedView(this._thenTemplateRef, this._context);
        }
      }
    } else {
      if (!this._elseViewRef) {
        this._viewContainer.clear();
        this._thenViewRef = null;
        if (this._elseTemplateRef) {
          this._elseViewRef = this._viewContainer.createEmbeddedView(this._elseTemplateRef, this._context);
        }
      }
    }
  }
  /**
   * Asserts the correct type of the context for the template that `NgIf` will render.
   *
   * The presence of this method is a signal to the Ivy template type-check compiler that the
   * `NgIf` structural directive renders its template with a specific context type.
   */
  static ngTemplateContextGuard(dir, ctx) {
    return true;
  }
  static {
    this.ɵfac = function NgIf_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _NgIf)(ɵɵdirectiveInject(ViewContainerRef), ɵɵdirectiveInject(TemplateRef));
    };
  }
  static {
    this.ɵdir = ɵɵdefineDirective({
      type: _NgIf,
      selectors: [["", "ngIf", ""]],
      inputs: {
        ngIf: "ngIf",
        ngIfThen: "ngIfThen",
        ngIfElse: "ngIfElse"
      },
      standalone: true
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NgIf, [{
    type: Directive,
    args: [{
      selector: "[ngIf]",
      standalone: true
    }]
  }], () => [{
    type: ViewContainerRef
  }, {
    type: TemplateRef
  }], {
    ngIf: [{
      type: Input
    }],
    ngIfThen: [{
      type: Input
    }],
    ngIfElse: [{
      type: Input
    }]
  });
})();
var NgIfContext = class {
  constructor() {
    this.$implicit = null;
    this.ngIf = null;
  }
};
function assertTemplate(property, templateRef) {
  const isTemplateRefOrNull = !!(!templateRef || templateRef.createEmbeddedView);
  if (!isTemplateRefOrNull) {
    throw new Error(`${property} must be a TemplateRef, but received '${stringify(templateRef)}'.`);
  }
}
var SwitchView = class {
  constructor(_viewContainerRef, _templateRef) {
    this._viewContainerRef = _viewContainerRef;
    this._templateRef = _templateRef;
    this._created = false;
  }
  create() {
    this._created = true;
    this._viewContainerRef.createEmbeddedView(this._templateRef);
  }
  destroy() {
    this._created = false;
    this._viewContainerRef.clear();
  }
  enforceState(created) {
    if (created && !this._created) {
      this.create();
    } else if (!created && this._created) {
      this.destroy();
    }
  }
};
var NgSwitch = class _NgSwitch {
  constructor() {
    this._defaultViews = [];
    this._defaultUsed = false;
    this._caseCount = 0;
    this._lastCaseCheckIndex = 0;
    this._lastCasesMatched = false;
  }
  set ngSwitch(newValue) {
    this._ngSwitch = newValue;
    if (this._caseCount === 0) {
      this._updateDefaultCases(true);
    }
  }
  /** @internal */
  _addCase() {
    return this._caseCount++;
  }
  /** @internal */
  _addDefault(view) {
    this._defaultViews.push(view);
  }
  /** @internal */
  _matchCase(value) {
    const matched = value === this._ngSwitch;
    this._lastCasesMatched ||= matched;
    this._lastCaseCheckIndex++;
    if (this._lastCaseCheckIndex === this._caseCount) {
      this._updateDefaultCases(!this._lastCasesMatched);
      this._lastCaseCheckIndex = 0;
      this._lastCasesMatched = false;
    }
    return matched;
  }
  _updateDefaultCases(useDefault) {
    if (this._defaultViews.length > 0 && useDefault !== this._defaultUsed) {
      this._defaultUsed = useDefault;
      for (const defaultView of this._defaultViews) {
        defaultView.enforceState(useDefault);
      }
    }
  }
  static {
    this.ɵfac = function NgSwitch_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _NgSwitch)();
    };
  }
  static {
    this.ɵdir = ɵɵdefineDirective({
      type: _NgSwitch,
      selectors: [["", "ngSwitch", ""]],
      inputs: {
        ngSwitch: "ngSwitch"
      },
      standalone: true
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NgSwitch, [{
    type: Directive,
    args: [{
      selector: "[ngSwitch]",
      standalone: true
    }]
  }], null, {
    ngSwitch: [{
      type: Input
    }]
  });
})();
var NgSwitchCase = class _NgSwitchCase {
  constructor(viewContainer, templateRef, ngSwitch) {
    this.ngSwitch = ngSwitch;
    if ((typeof ngDevMode === "undefined" || ngDevMode) && !ngSwitch) {
      throwNgSwitchProviderNotFoundError("ngSwitchCase", "NgSwitchCase");
    }
    ngSwitch._addCase();
    this._view = new SwitchView(viewContainer, templateRef);
  }
  /**
   * Performs case matching. For internal use only.
   * @nodoc
   */
  ngDoCheck() {
    this._view.enforceState(this.ngSwitch._matchCase(this.ngSwitchCase));
  }
  static {
    this.ɵfac = function NgSwitchCase_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _NgSwitchCase)(ɵɵdirectiveInject(ViewContainerRef), ɵɵdirectiveInject(TemplateRef), ɵɵdirectiveInject(NgSwitch, 9));
    };
  }
  static {
    this.ɵdir = ɵɵdefineDirective({
      type: _NgSwitchCase,
      selectors: [["", "ngSwitchCase", ""]],
      inputs: {
        ngSwitchCase: "ngSwitchCase"
      },
      standalone: true
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NgSwitchCase, [{
    type: Directive,
    args: [{
      selector: "[ngSwitchCase]",
      standalone: true
    }]
  }], () => [{
    type: ViewContainerRef
  }, {
    type: TemplateRef
  }, {
    type: NgSwitch,
    decorators: [{
      type: Optional
    }, {
      type: Host
    }]
  }], {
    ngSwitchCase: [{
      type: Input
    }]
  });
})();
var NgSwitchDefault = class _NgSwitchDefault {
  constructor(viewContainer, templateRef, ngSwitch) {
    if ((typeof ngDevMode === "undefined" || ngDevMode) && !ngSwitch) {
      throwNgSwitchProviderNotFoundError("ngSwitchDefault", "NgSwitchDefault");
    }
    ngSwitch._addDefault(new SwitchView(viewContainer, templateRef));
  }
  static {
    this.ɵfac = function NgSwitchDefault_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _NgSwitchDefault)(ɵɵdirectiveInject(ViewContainerRef), ɵɵdirectiveInject(TemplateRef), ɵɵdirectiveInject(NgSwitch, 9));
    };
  }
  static {
    this.ɵdir = ɵɵdefineDirective({
      type: _NgSwitchDefault,
      selectors: [["", "ngSwitchDefault", ""]],
      standalone: true
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NgSwitchDefault, [{
    type: Directive,
    args: [{
      selector: "[ngSwitchDefault]",
      standalone: true
    }]
  }], () => [{
    type: ViewContainerRef
  }, {
    type: TemplateRef
  }, {
    type: NgSwitch,
    decorators: [{
      type: Optional
    }, {
      type: Host
    }]
  }], null);
})();
function throwNgSwitchProviderNotFoundError(attrName, directiveName) {
  throw new RuntimeError(2e3, `An element with the "${attrName}" attribute (matching the "${directiveName}" directive) must be located inside an element with the "ngSwitch" attribute (matching "NgSwitch" directive)`);
}
var NgPlural = class _NgPlural {
  constructor(_localization) {
    this._localization = _localization;
    this._caseViews = {};
  }
  set ngPlural(value) {
    this._updateView(value);
  }
  addCase(value, switchView) {
    this._caseViews[value] = switchView;
  }
  _updateView(switchValue) {
    this._clearViews();
    const cases = Object.keys(this._caseViews);
    const key = getPluralCategory(switchValue, cases, this._localization);
    this._activateView(this._caseViews[key]);
  }
  _clearViews() {
    if (this._activeView) this._activeView.destroy();
  }
  _activateView(view) {
    if (view) {
      this._activeView = view;
      this._activeView.create();
    }
  }
  static {
    this.ɵfac = function NgPlural_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _NgPlural)(ɵɵdirectiveInject(NgLocalization));
    };
  }
  static {
    this.ɵdir = ɵɵdefineDirective({
      type: _NgPlural,
      selectors: [["", "ngPlural", ""]],
      inputs: {
        ngPlural: "ngPlural"
      },
      standalone: true
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NgPlural, [{
    type: Directive,
    args: [{
      selector: "[ngPlural]",
      standalone: true
    }]
  }], () => [{
    type: NgLocalization
  }], {
    ngPlural: [{
      type: Input
    }]
  });
})();
var NgPluralCase = class _NgPluralCase {
  constructor(value, template, viewContainer, ngPlural) {
    this.value = value;
    const isANumber = !isNaN(Number(value));
    ngPlural.addCase(isANumber ? `=${value}` : value, new SwitchView(viewContainer, template));
  }
  static {
    this.ɵfac = function NgPluralCase_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _NgPluralCase)(ɵɵinjectAttribute("ngPluralCase"), ɵɵdirectiveInject(TemplateRef), ɵɵdirectiveInject(ViewContainerRef), ɵɵdirectiveInject(NgPlural, 1));
    };
  }
  static {
    this.ɵdir = ɵɵdefineDirective({
      type: _NgPluralCase,
      selectors: [["", "ngPluralCase", ""]],
      standalone: true
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NgPluralCase, [{
    type: Directive,
    args: [{
      selector: "[ngPluralCase]",
      standalone: true
    }]
  }], () => [{
    type: void 0,
    decorators: [{
      type: Attribute2,
      args: ["ngPluralCase"]
    }]
  }, {
    type: TemplateRef
  }, {
    type: ViewContainerRef
  }, {
    type: NgPlural,
    decorators: [{
      type: Host
    }]
  }], null);
})();
var NgStyle = class _NgStyle {
  constructor(_ngEl, _differs, _renderer) {
    this._ngEl = _ngEl;
    this._differs = _differs;
    this._renderer = _renderer;
    this._ngStyle = null;
    this._differ = null;
  }
  set ngStyle(values) {
    this._ngStyle = values;
    if (!this._differ && values) {
      this._differ = this._differs.find(values).create();
    }
  }
  ngDoCheck() {
    if (this._differ) {
      const changes = this._differ.diff(this._ngStyle);
      if (changes) {
        this._applyChanges(changes);
      }
    }
  }
  _setStyle(nameAndUnit, value) {
    const [name, unit] = nameAndUnit.split(".");
    const flags = name.indexOf("-") === -1 ? void 0 : RendererStyleFlags2.DashCase;
    if (value != null) {
      this._renderer.setStyle(this._ngEl.nativeElement, name, unit ? `${value}${unit}` : value, flags);
    } else {
      this._renderer.removeStyle(this._ngEl.nativeElement, name, flags);
    }
  }
  _applyChanges(changes) {
    changes.forEachRemovedItem((record) => this._setStyle(record.key, null));
    changes.forEachAddedItem((record) => this._setStyle(record.key, record.currentValue));
    changes.forEachChangedItem((record) => this._setStyle(record.key, record.currentValue));
  }
  static {
    this.ɵfac = function NgStyle_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _NgStyle)(ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(KeyValueDiffers), ɵɵdirectiveInject(Renderer2));
    };
  }
  static {
    this.ɵdir = ɵɵdefineDirective({
      type: _NgStyle,
      selectors: [["", "ngStyle", ""]],
      inputs: {
        ngStyle: "ngStyle"
      },
      standalone: true
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NgStyle, [{
    type: Directive,
    args: [{
      selector: "[ngStyle]",
      standalone: true
    }]
  }], () => [{
    type: ElementRef
  }, {
    type: KeyValueDiffers
  }, {
    type: Renderer2
  }], {
    ngStyle: [{
      type: Input,
      args: ["ngStyle"]
    }]
  });
})();
var NgTemplateOutlet = class _NgTemplateOutlet {
  constructor(_viewContainerRef) {
    this._viewContainerRef = _viewContainerRef;
    this._viewRef = null;
    this.ngTemplateOutletContext = null;
    this.ngTemplateOutlet = null;
    this.ngTemplateOutletInjector = null;
  }
  ngOnChanges(changes) {
    if (this._shouldRecreateView(changes)) {
      const viewContainerRef = this._viewContainerRef;
      if (this._viewRef) {
        viewContainerRef.remove(viewContainerRef.indexOf(this._viewRef));
      }
      if (!this.ngTemplateOutlet) {
        this._viewRef = null;
        return;
      }
      const viewContext = this._createContextForwardProxy();
      this._viewRef = viewContainerRef.createEmbeddedView(this.ngTemplateOutlet, viewContext, {
        injector: this.ngTemplateOutletInjector ?? void 0
      });
    }
  }
  /**
   * We need to re-create existing embedded view if either is true:
   * - the outlet changed.
   * - the injector changed.
   */
  _shouldRecreateView(changes) {
    return !!changes["ngTemplateOutlet"] || !!changes["ngTemplateOutletInjector"];
  }
  /**
   * For a given outlet instance, we create a proxy object that delegates
   * to the user-specified context. This allows changing, or swapping out
   * the context object completely without having to destroy/re-create the view.
   */
  _createContextForwardProxy() {
    return new Proxy({}, {
      set: (_target, prop, newValue) => {
        if (!this.ngTemplateOutletContext) {
          return false;
        }
        return Reflect.set(this.ngTemplateOutletContext, prop, newValue);
      },
      get: (_target, prop, receiver) => {
        if (!this.ngTemplateOutletContext) {
          return void 0;
        }
        return Reflect.get(this.ngTemplateOutletContext, prop, receiver);
      }
    });
  }
  static {
    this.ɵfac = function NgTemplateOutlet_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _NgTemplateOutlet)(ɵɵdirectiveInject(ViewContainerRef));
    };
  }
  static {
    this.ɵdir = ɵɵdefineDirective({
      type: _NgTemplateOutlet,
      selectors: [["", "ngTemplateOutlet", ""]],
      inputs: {
        ngTemplateOutletContext: "ngTemplateOutletContext",
        ngTemplateOutlet: "ngTemplateOutlet",
        ngTemplateOutletInjector: "ngTemplateOutletInjector"
      },
      standalone: true,
      features: [ɵɵNgOnChangesFeature]
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NgTemplateOutlet, [{
    type: Directive,
    args: [{
      selector: "[ngTemplateOutlet]",
      standalone: true
    }]
  }], () => [{
    type: ViewContainerRef
  }], {
    ngTemplateOutletContext: [{
      type: Input
    }],
    ngTemplateOutlet: [{
      type: Input
    }],
    ngTemplateOutletInjector: [{
      type: Input
    }]
  });
})();
var COMMON_DIRECTIVES = [NgClass, NgComponentOutlet, NgForOf, NgIf, NgTemplateOutlet, NgStyle, NgSwitch, NgSwitchCase, NgSwitchDefault, NgPlural, NgPluralCase];
function invalidPipeArgumentError(type, value) {
  return new RuntimeError(2100, ngDevMode && `InvalidPipeArgument: '${value}' for pipe '${stringify(type)}'`);
}
var SubscribableStrategy = class {
  createSubscription(async, updateLatestValue) {
    return untracked(() => async.subscribe({
      next: updateLatestValue,
      error: (e) => {
        throw e;
      }
    }));
  }
  dispose(subscription) {
    untracked(() => subscription.unsubscribe());
  }
};
var PromiseStrategy = class {
  createSubscription(async, updateLatestValue) {
    return async.then(updateLatestValue, (e) => {
      throw e;
    });
  }
  dispose(subscription) {
  }
};
var _promiseStrategy = new PromiseStrategy();
var _subscribableStrategy = new SubscribableStrategy();
var AsyncPipe = class _AsyncPipe {
  constructor(ref) {
    this._latestValue = null;
    this.markForCheckOnValueUpdate = true;
    this._subscription = null;
    this._obj = null;
    this._strategy = null;
    this._ref = ref;
  }
  ngOnDestroy() {
    if (this._subscription) {
      this._dispose();
    }
    this._ref = null;
  }
  transform(obj) {
    if (!this._obj) {
      if (obj) {
        try {
          this.markForCheckOnValueUpdate = false;
          this._subscribe(obj);
        } finally {
          this.markForCheckOnValueUpdate = true;
        }
      }
      return this._latestValue;
    }
    if (obj !== this._obj) {
      this._dispose();
      return this.transform(obj);
    }
    return this._latestValue;
  }
  _subscribe(obj) {
    this._obj = obj;
    this._strategy = this._selectStrategy(obj);
    this._subscription = this._strategy.createSubscription(obj, (value) => this._updateLatestValue(obj, value));
  }
  _selectStrategy(obj) {
    if (isPromise(obj)) {
      return _promiseStrategy;
    }
    if (isSubscribable(obj)) {
      return _subscribableStrategy;
    }
    throw invalidPipeArgumentError(_AsyncPipe, obj);
  }
  _dispose() {
    this._strategy.dispose(this._subscription);
    this._latestValue = null;
    this._subscription = null;
    this._obj = null;
  }
  _updateLatestValue(async, value) {
    if (async === this._obj) {
      this._latestValue = value;
      if (this.markForCheckOnValueUpdate) {
        this._ref?.markForCheck();
      }
    }
  }
  static {
    this.ɵfac = function AsyncPipe_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _AsyncPipe)(ɵɵdirectiveInject(ChangeDetectorRef, 16));
    };
  }
  static {
    this.ɵpipe = ɵɵdefinePipe({
      name: "async",
      type: _AsyncPipe,
      pure: false,
      standalone: true
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(AsyncPipe, [{
    type: Pipe,
    args: [{
      name: "async",
      pure: false,
      standalone: true
    }]
  }], () => [{
    type: ChangeDetectorRef
  }], null);
})();
var LowerCasePipe = class _LowerCasePipe {
  transform(value) {
    if (value == null) return null;
    if (typeof value !== "string") {
      throw invalidPipeArgumentError(_LowerCasePipe, value);
    }
    return value.toLowerCase();
  }
  static {
    this.ɵfac = function LowerCasePipe_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _LowerCasePipe)();
    };
  }
  static {
    this.ɵpipe = ɵɵdefinePipe({
      name: "lowercase",
      type: _LowerCasePipe,
      pure: true,
      standalone: true
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(LowerCasePipe, [{
    type: Pipe,
    args: [{
      name: "lowercase",
      standalone: true
    }]
  }], null, null);
})();
var unicodeWordMatch = /(?:[0-9A-Za-z\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0560-\u0588\u05D0-\u05EA\u05EF-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u0860-\u086A\u0870-\u0887\u0889-\u088E\u08A0-\u08C9\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u09FC\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C5D\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D04-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E86-\u0E8A\u0E8C-\u0EA3\u0EA5\u0EA7-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16F1-\u16F8\u1700-\u1711\u171F-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1878\u1880-\u1884\u1887-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4C\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1C90-\u1CBA\u1CBD-\u1CBF\u1CE9-\u1CEC\u1CEE-\u1CF3\u1CF5\u1CF6\u1CFA\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2183\u2184\u2C00-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005\u3006\u3031-\u3035\u303B\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312F\u3131-\u318E\u31A0-\u31BF\u31F0-\u31FF\u3400-\u4DBF\u4E00-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6E5\uA717-\uA71F\uA722-\uA788\uA78B-\uA7CA\uA7D0\uA7D1\uA7D3\uA7D5-\uA7D9\uA7F2-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA8FE\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB69\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF2D-\uDF40\uDF42-\uDF49\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF]|\uD801[\uDC00-\uDC9D\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDD70-\uDD7A\uDD7C-\uDD8A\uDD8C-\uDD92\uDD94\uDD95\uDD97-\uDDA1\uDDA3-\uDDB1\uDDB3-\uDDB9\uDDBB\uDDBC\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67\uDF80-\uDF85\uDF87-\uDFB0\uDFB2-\uDFBA]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE35\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2\uDD00-\uDD23\uDE80-\uDEA9\uDEB0\uDEB1\uDF00-\uDF1C\uDF27\uDF30-\uDF45\uDF70-\uDF81\uDFB0-\uDFC4\uDFE0-\uDFF6]|\uD804[\uDC03-\uDC37\uDC71\uDC72\uDC75\uDC83-\uDCAF\uDCD0-\uDCE8\uDD03-\uDD26\uDD44\uDD47\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE2B\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEDE\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF50\uDF5D-\uDF61]|\uD805[\uDC00-\uDC34\uDC47-\uDC4A\uDC5F-\uDC61\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDD80-\uDDAE\uDDD8-\uDDDB\uDE00-\uDE2F\uDE44\uDE80-\uDEAA\uDEB8\uDF00-\uDF1A\uDF40-\uDF46]|\uD806[\uDC00-\uDC2B\uDCA0-\uDCDF\uDCFF-\uDD06\uDD09\uDD0C-\uDD13\uDD15\uDD16\uDD18-\uDD2F\uDD3F\uDD41\uDDA0-\uDDA7\uDDAA-\uDDD0\uDDE1\uDDE3\uDE00\uDE0B-\uDE32\uDE3A\uDE50\uDE5C-\uDE89\uDE9D\uDEB0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC2E\uDC40\uDC72-\uDC8F\uDD00-\uDD06\uDD08\uDD09\uDD0B-\uDD30\uDD46\uDD60-\uDD65\uDD67\uDD68\uDD6A-\uDD89\uDD98\uDEE0-\uDEF2\uDFB0]|\uD808[\uDC00-\uDF99]|\uD809[\uDC80-\uDD43]|\uD80B[\uDF90-\uDFF0]|[\uD80C\uD81C-\uD820\uD822\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872\uD874-\uD879\uD880-\uD883][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDE70-\uDEBE\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDE40-\uDE7F\uDF00-\uDF4A\uDF50\uDF93-\uDF9F\uDFE0\uDFE1\uDFE3]|\uD821[\uDC00-\uDFF7]|\uD823[\uDC00-\uDCD5\uDD00-\uDD08]|\uD82B[\uDFF0-\uDFF3\uDFF5-\uDFFB\uDFFD\uDFFE]|\uD82C[\uDC00-\uDD22\uDD50-\uDD52\uDD64-\uDD67\uDD70-\uDEFB]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB]|\uD837[\uDF00-\uDF1E]|\uD838[\uDD00-\uDD2C\uDD37-\uDD3D\uDD4E\uDE90-\uDEAD\uDEC0-\uDEEB]|\uD839[\uDFE0-\uDFE6\uDFE8-\uDFEB\uDFED\uDFEE\uDFF0-\uDFFE]|\uD83A[\uDC00-\uDCC4\uDD00-\uDD43\uDD4B]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDEDF\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF38\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1\uDEB0-\uDFFF]|\uD87A[\uDC00-\uDFE0]|\uD87E[\uDC00-\uDE1D]|\uD884[\uDC00-\uDF4A])\S*/g;
var TitleCasePipe = class _TitleCasePipe {
  transform(value) {
    if (value == null) return null;
    if (typeof value !== "string") {
      throw invalidPipeArgumentError(_TitleCasePipe, value);
    }
    return value.replace(unicodeWordMatch, (txt) => txt[0].toUpperCase() + txt.slice(1).toLowerCase());
  }
  static {
    this.ɵfac = function TitleCasePipe_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _TitleCasePipe)();
    };
  }
  static {
    this.ɵpipe = ɵɵdefinePipe({
      name: "titlecase",
      type: _TitleCasePipe,
      pure: true,
      standalone: true
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(TitleCasePipe, [{
    type: Pipe,
    args: [{
      name: "titlecase",
      standalone: true
    }]
  }], null, null);
})();
var UpperCasePipe = class _UpperCasePipe {
  transform(value) {
    if (value == null) return null;
    if (typeof value !== "string") {
      throw invalidPipeArgumentError(_UpperCasePipe, value);
    }
    return value.toUpperCase();
  }
  static {
    this.ɵfac = function UpperCasePipe_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _UpperCasePipe)();
    };
  }
  static {
    this.ɵpipe = ɵɵdefinePipe({
      name: "uppercase",
      type: _UpperCasePipe,
      pure: true,
      standalone: true
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(UpperCasePipe, [{
    type: Pipe,
    args: [{
      name: "uppercase",
      standalone: true
    }]
  }], null, null);
})();
var DEFAULT_DATE_FORMAT = "mediumDate";
var DATE_PIPE_DEFAULT_TIMEZONE = new InjectionToken(ngDevMode ? "DATE_PIPE_DEFAULT_TIMEZONE" : "");
var DATE_PIPE_DEFAULT_OPTIONS = new InjectionToken(ngDevMode ? "DATE_PIPE_DEFAULT_OPTIONS" : "");
var DatePipe = class _DatePipe {
  constructor(locale, defaultTimezone, defaultOptions) {
    this.locale = locale;
    this.defaultTimezone = defaultTimezone;
    this.defaultOptions = defaultOptions;
  }
  transform(value, format, timezone, locale) {
    if (value == null || value === "" || value !== value) return null;
    try {
      const _format = format ?? this.defaultOptions?.dateFormat ?? DEFAULT_DATE_FORMAT;
      const _timezone = timezone ?? this.defaultOptions?.timezone ?? this.defaultTimezone ?? void 0;
      return formatDate(value, _format, locale || this.locale, _timezone);
    } catch (error) {
      throw invalidPipeArgumentError(_DatePipe, error.message);
    }
  }
  static {
    this.ɵfac = function DatePipe_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _DatePipe)(ɵɵdirectiveInject(LOCALE_ID, 16), ɵɵdirectiveInject(DATE_PIPE_DEFAULT_TIMEZONE, 24), ɵɵdirectiveInject(DATE_PIPE_DEFAULT_OPTIONS, 24));
    };
  }
  static {
    this.ɵpipe = ɵɵdefinePipe({
      name: "date",
      type: _DatePipe,
      pure: true,
      standalone: true
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DatePipe, [{
    type: Pipe,
    args: [{
      name: "date",
      standalone: true
    }]
  }], () => [{
    type: void 0,
    decorators: [{
      type: Inject,
      args: [LOCALE_ID]
    }]
  }, {
    type: void 0,
    decorators: [{
      type: Inject,
      args: [DATE_PIPE_DEFAULT_TIMEZONE]
    }, {
      type: Optional
    }]
  }, {
    type: void 0,
    decorators: [{
      type: Inject,
      args: [DATE_PIPE_DEFAULT_OPTIONS]
    }, {
      type: Optional
    }]
  }], null);
})();
var _INTERPOLATION_REGEXP = /#/g;
var I18nPluralPipe = class _I18nPluralPipe {
  constructor(_localization) {
    this._localization = _localization;
  }
  /**
   * @param value the number to be formatted
   * @param pluralMap an object that mimics the ICU format, see
   * https://unicode-org.github.io/icu/userguide/format_parse/messages/.
   * @param locale a `string` defining the locale to use (uses the current {@link LOCALE_ID} by
   * default).
   */
  transform(value, pluralMap, locale) {
    if (value == null) return "";
    if (typeof pluralMap !== "object" || pluralMap === null) {
      throw invalidPipeArgumentError(_I18nPluralPipe, pluralMap);
    }
    const key = getPluralCategory(value, Object.keys(pluralMap), this._localization, locale);
    return pluralMap[key].replace(_INTERPOLATION_REGEXP, value.toString());
  }
  static {
    this.ɵfac = function I18nPluralPipe_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _I18nPluralPipe)(ɵɵdirectiveInject(NgLocalization, 16));
    };
  }
  static {
    this.ɵpipe = ɵɵdefinePipe({
      name: "i18nPlural",
      type: _I18nPluralPipe,
      pure: true,
      standalone: true
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(I18nPluralPipe, [{
    type: Pipe,
    args: [{
      name: "i18nPlural",
      standalone: true
    }]
  }], () => [{
    type: NgLocalization
  }], null);
})();
var I18nSelectPipe = class _I18nSelectPipe {
  /**
   * @param value a string to be internationalized.
   * @param mapping an object that indicates the text that should be displayed
   * for different values of the provided `value`.
   */
  transform(value, mapping) {
    if (value == null) return "";
    if (typeof mapping !== "object" || typeof value !== "string") {
      throw invalidPipeArgumentError(_I18nSelectPipe, mapping);
    }
    if (mapping.hasOwnProperty(value)) {
      return mapping[value];
    }
    if (mapping.hasOwnProperty("other")) {
      return mapping["other"];
    }
    return "";
  }
  static {
    this.ɵfac = function I18nSelectPipe_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _I18nSelectPipe)();
    };
  }
  static {
    this.ɵpipe = ɵɵdefinePipe({
      name: "i18nSelect",
      type: _I18nSelectPipe,
      pure: true,
      standalone: true
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(I18nSelectPipe, [{
    type: Pipe,
    args: [{
      name: "i18nSelect",
      standalone: true
    }]
  }], null, null);
})();
var JsonPipe = class _JsonPipe {
  /**
   * @param value A value of any type to convert into a JSON-format string.
   */
  transform(value) {
    return JSON.stringify(value, null, 2);
  }
  static {
    this.ɵfac = function JsonPipe_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _JsonPipe)();
    };
  }
  static {
    this.ɵpipe = ɵɵdefinePipe({
      name: "json",
      type: _JsonPipe,
      pure: false,
      standalone: true
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(JsonPipe, [{
    type: Pipe,
    args: [{
      name: "json",
      pure: false,
      standalone: true
    }]
  }], null, null);
})();
function makeKeyValuePair(key, value) {
  return {
    key,
    value
  };
}
var KeyValuePipe = class _KeyValuePipe {
  constructor(differs) {
    this.differs = differs;
    this.keyValues = [];
    this.compareFn = defaultComparator;
  }
  transform(input2, compareFn = defaultComparator) {
    if (!input2 || !(input2 instanceof Map) && typeof input2 !== "object") {
      return null;
    }
    this.differ ??= this.differs.find(input2).create();
    const differChanges = this.differ.diff(input2);
    const compareFnChanged = compareFn !== this.compareFn;
    if (differChanges) {
      this.keyValues = [];
      differChanges.forEachItem((r) => {
        this.keyValues.push(makeKeyValuePair(r.key, r.currentValue));
      });
    }
    if (differChanges || compareFnChanged) {
      this.keyValues.sort(compareFn);
      this.compareFn = compareFn;
    }
    return this.keyValues;
  }
  static {
    this.ɵfac = function KeyValuePipe_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _KeyValuePipe)(ɵɵdirectiveInject(KeyValueDiffers, 16));
    };
  }
  static {
    this.ɵpipe = ɵɵdefinePipe({
      name: "keyvalue",
      type: _KeyValuePipe,
      pure: false,
      standalone: true
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(KeyValuePipe, [{
    type: Pipe,
    args: [{
      name: "keyvalue",
      pure: false,
      standalone: true
    }]
  }], () => [{
    type: KeyValueDiffers
  }], null);
})();
function defaultComparator(keyValueA, keyValueB) {
  const a = keyValueA.key;
  const b = keyValueB.key;
  if (a === b) return 0;
  if (a === void 0) return 1;
  if (b === void 0) return -1;
  if (a === null) return 1;
  if (b === null) return -1;
  if (typeof a == "string" && typeof b == "string") {
    return a < b ? -1 : 1;
  }
  if (typeof a == "number" && typeof b == "number") {
    return a - b;
  }
  if (typeof a == "boolean" && typeof b == "boolean") {
    return a < b ? -1 : 1;
  }
  const aString = String(a);
  const bString = String(b);
  return aString == bString ? 0 : aString < bString ? -1 : 1;
}
var DecimalPipe = class _DecimalPipe {
  constructor(_locale) {
    this._locale = _locale;
  }
  /**
   * @param value The value to be formatted.
   * @param digitsInfo Sets digit and decimal representation.
   * [See more](#digitsinfo).
   * @param locale Specifies what locale format rules to use.
   * [See more](#locale).
   */
  transform(value, digitsInfo, locale) {
    if (!isValue(value)) return null;
    locale ||= this._locale;
    try {
      const num = strToNumber(value);
      return formatNumber(num, locale, digitsInfo);
    } catch (error) {
      throw invalidPipeArgumentError(_DecimalPipe, error.message);
    }
  }
  static {
    this.ɵfac = function DecimalPipe_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _DecimalPipe)(ɵɵdirectiveInject(LOCALE_ID, 16));
    };
  }
  static {
    this.ɵpipe = ɵɵdefinePipe({
      name: "number",
      type: _DecimalPipe,
      pure: true,
      standalone: true
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DecimalPipe, [{
    type: Pipe,
    args: [{
      name: "number",
      standalone: true
    }]
  }], () => [{
    type: void 0,
    decorators: [{
      type: Inject,
      args: [LOCALE_ID]
    }]
  }], null);
})();
var PercentPipe = class _PercentPipe {
  constructor(_locale) {
    this._locale = _locale;
  }
  /**
   *
   * @param value The number to be formatted as a percentage.
   * @param digitsInfo Decimal representation options, specified by a string
   * in the following format:<br>
   * <code>{minIntegerDigits}.{minFractionDigits}-{maxFractionDigits}</code>.
   *   - `minIntegerDigits`: The minimum number of integer digits before the decimal point.
   * Default is `1`.
   *   - `minFractionDigits`: The minimum number of digits after the decimal point.
   * Default is `0`.
   *   - `maxFractionDigits`: The maximum number of digits after the decimal point.
   * Default is `0`.
   * @param locale A locale code for the locale format rules to use.
   * When not supplied, uses the value of `LOCALE_ID`, which is `en-US` by default.
   * See [Setting your app locale](guide/i18n/locale-id).
   */
  transform(value, digitsInfo, locale) {
    if (!isValue(value)) return null;
    locale ||= this._locale;
    try {
      const num = strToNumber(value);
      return formatPercent(num, locale, digitsInfo);
    } catch (error) {
      throw invalidPipeArgumentError(_PercentPipe, error.message);
    }
  }
  static {
    this.ɵfac = function PercentPipe_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _PercentPipe)(ɵɵdirectiveInject(LOCALE_ID, 16));
    };
  }
  static {
    this.ɵpipe = ɵɵdefinePipe({
      name: "percent",
      type: _PercentPipe,
      pure: true,
      standalone: true
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PercentPipe, [{
    type: Pipe,
    args: [{
      name: "percent",
      standalone: true
    }]
  }], () => [{
    type: void 0,
    decorators: [{
      type: Inject,
      args: [LOCALE_ID]
    }]
  }], null);
})();
var CurrencyPipe = class _CurrencyPipe {
  constructor(_locale, _defaultCurrencyCode = "USD") {
    this._locale = _locale;
    this._defaultCurrencyCode = _defaultCurrencyCode;
  }
  /**
   *
   * @param value The number to be formatted as currency.
   * @param currencyCode The [ISO 4217](https://en.wikipedia.org/wiki/ISO_4217) currency code,
   * such as `USD` for the US dollar and `EUR` for the euro. The default currency code can be
   * configured using the `DEFAULT_CURRENCY_CODE` injection token.
   * @param display The format for the currency indicator. One of the following:
   *   - `code`: Show the code (such as `USD`).
   *   - `symbol`(default): Show the symbol (such as `$`).
   *   - `symbol-narrow`: Use the narrow symbol for locales that have two symbols for their
   * currency.
   * For example, the Canadian dollar CAD has the symbol `CA$` and the symbol-narrow `$`. If the
   * locale has no narrow symbol, uses the standard symbol for the locale.
   *   - String: Use the given string value instead of a code or a symbol.
   * For example, an empty string will suppress the currency & symbol.
   *   - Boolean (marked deprecated in v5): `true` for symbol and false for `code`.
   *
   * @param digitsInfo Decimal representation options, specified by a string
   * in the following format:<br>
   * <code>{minIntegerDigits}.{minFractionDigits}-{maxFractionDigits}</code>.
   *   - `minIntegerDigits`: The minimum number of integer digits before the decimal point.
   * Default is `1`.
   *   - `minFractionDigits`: The minimum number of digits after the decimal point.
   * Default is `2`.
   *   - `maxFractionDigits`: The maximum number of digits after the decimal point.
   * Default is `2`.
   * If not provided, the number will be formatted with the proper amount of digits,
   * depending on what the [ISO 4217](https://en.wikipedia.org/wiki/ISO_4217) specifies.
   * For example, the Canadian dollar has 2 digits, whereas the Chilean peso has none.
   * @param locale A locale code for the locale format rules to use.
   * When not supplied, uses the value of `LOCALE_ID`, which is `en-US` by default.
   * See [Setting your app locale](guide/i18n/locale-id).
   */
  transform(value, currencyCode = this._defaultCurrencyCode, display = "symbol", digitsInfo, locale) {
    if (!isValue(value)) return null;
    locale ||= this._locale;
    if (typeof display === "boolean") {
      if ((typeof ngDevMode === "undefined" || ngDevMode) && console && console.warn) {
        console.warn(`Warning: the currency pipe has been changed in Angular v5. The symbolDisplay option (third parameter) is now a string instead of a boolean. The accepted values are "code", "symbol" or "symbol-narrow".`);
      }
      display = display ? "symbol" : "code";
    }
    let currency = currencyCode || this._defaultCurrencyCode;
    if (display !== "code") {
      if (display === "symbol" || display === "symbol-narrow") {
        currency = getCurrencySymbol(currency, display === "symbol" ? "wide" : "narrow", locale);
      } else {
        currency = display;
      }
    }
    try {
      const num = strToNumber(value);
      return formatCurrency(num, locale, currency, currencyCode, digitsInfo);
    } catch (error) {
      throw invalidPipeArgumentError(_CurrencyPipe, error.message);
    }
  }
  static {
    this.ɵfac = function CurrencyPipe_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _CurrencyPipe)(ɵɵdirectiveInject(LOCALE_ID, 16), ɵɵdirectiveInject(DEFAULT_CURRENCY_CODE, 16));
    };
  }
  static {
    this.ɵpipe = ɵɵdefinePipe({
      name: "currency",
      type: _CurrencyPipe,
      pure: true,
      standalone: true
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CurrencyPipe, [{
    type: Pipe,
    args: [{
      name: "currency",
      standalone: true
    }]
  }], () => [{
    type: void 0,
    decorators: [{
      type: Inject,
      args: [LOCALE_ID]
    }]
  }, {
    type: void 0,
    decorators: [{
      type: Inject,
      args: [DEFAULT_CURRENCY_CODE]
    }]
  }], null);
})();
function isValue(value) {
  return !(value == null || value === "" || value !== value);
}
function strToNumber(value) {
  if (typeof value === "string" && !isNaN(Number(value) - parseFloat(value))) {
    return Number(value);
  }
  if (typeof value !== "number") {
    throw new Error(`${value} is not a number`);
  }
  return value;
}
var SlicePipe = class _SlicePipe {
  transform(value, start, end) {
    if (value == null) return null;
    if (!this.supports(value)) {
      throw invalidPipeArgumentError(_SlicePipe, value);
    }
    return value.slice(start, end);
  }
  supports(obj) {
    return typeof obj === "string" || Array.isArray(obj);
  }
  static {
    this.ɵfac = function SlicePipe_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _SlicePipe)();
    };
  }
  static {
    this.ɵpipe = ɵɵdefinePipe({
      name: "slice",
      type: _SlicePipe,
      pure: false,
      standalone: true
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(SlicePipe, [{
    type: Pipe,
    args: [{
      name: "slice",
      pure: false,
      standalone: true
    }]
  }], null, null);
})();
var COMMON_PIPES = [AsyncPipe, UpperCasePipe, LowerCasePipe, JsonPipe, SlicePipe, DecimalPipe, PercentPipe, TitleCasePipe, CurrencyPipe, DatePipe, I18nPluralPipe, I18nSelectPipe, KeyValuePipe];
var CommonModule = class _CommonModule {
  static {
    this.ɵfac = function CommonModule_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _CommonModule)();
    };
  }
  static {
    this.ɵmod = ɵɵdefineNgModule({
      type: _CommonModule,
      imports: [NgClass, NgComponentOutlet, NgForOf, NgIf, NgTemplateOutlet, NgStyle, NgSwitch, NgSwitchCase, NgSwitchDefault, NgPlural, NgPluralCase, AsyncPipe, UpperCasePipe, LowerCasePipe, JsonPipe, SlicePipe, DecimalPipe, PercentPipe, TitleCasePipe, CurrencyPipe, DatePipe, I18nPluralPipe, I18nSelectPipe, KeyValuePipe],
      exports: [NgClass, NgComponentOutlet, NgForOf, NgIf, NgTemplateOutlet, NgStyle, NgSwitch, NgSwitchCase, NgSwitchDefault, NgPlural, NgPluralCase, AsyncPipe, UpperCasePipe, LowerCasePipe, JsonPipe, SlicePipe, DecimalPipe, PercentPipe, TitleCasePipe, CurrencyPipe, DatePipe, I18nPluralPipe, I18nSelectPipe, KeyValuePipe]
    });
  }
  static {
    this.ɵinj = ɵɵdefineInjector({});
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CommonModule, [{
    type: NgModule,
    args: [{
      imports: [COMMON_DIRECTIVES, COMMON_PIPES],
      exports: [COMMON_DIRECTIVES, COMMON_PIPES]
    }]
  }], null, null);
})();
var PLATFORM_BROWSER_ID = "browser";
var PLATFORM_SERVER_ID = "server";
function isPlatformBrowser2(platformId) {
  return platformId === PLATFORM_BROWSER_ID;
}
function isPlatformServer(platformId) {
  return platformId === PLATFORM_SERVER_ID;
}
var VERSION2 = new Version("18.2.0");
var ViewportScroller = class _ViewportScroller {
  static {
    this.ɵprov = ɵɵdefineInjectable({
      token: _ViewportScroller,
      providedIn: "root",
      factory: () => isPlatformBrowser2(inject(PLATFORM_ID)) ? new BrowserViewportScroller(inject(DOCUMENT2), window) : new NullViewportScroller()
    });
  }
};
var BrowserViewportScroller = class {
  constructor(document2, window2) {
    this.document = document2;
    this.window = window2;
    this.offset = () => [0, 0];
  }
  /**
   * Configures the top offset used when scrolling to an anchor.
   * @param offset A position in screen coordinates (a tuple with x and y values)
   * or a function that returns the top offset position.
   *
   */
  setOffset(offset) {
    if (Array.isArray(offset)) {
      this.offset = () => offset;
    } else {
      this.offset = offset;
    }
  }
  /**
   * Retrieves the current scroll position.
   * @returns The position in screen coordinates.
   */
  getScrollPosition() {
    return [this.window.scrollX, this.window.scrollY];
  }
  /**
   * Sets the scroll position.
   * @param position The new position in screen coordinates.
   */
  scrollToPosition(position) {
    this.window.scrollTo(position[0], position[1]);
  }
  /**
   * Scrolls to an element and attempts to focus the element.
   *
   * Note that the function name here is misleading in that the target string may be an ID for a
   * non-anchor element.
   *
   * @param target The ID of an element or name of the anchor.
   *
   * @see https://html.spec.whatwg.org/#the-indicated-part-of-the-document
   * @see https://html.spec.whatwg.org/#scroll-to-fragid
   */
  scrollToAnchor(target) {
    const elSelected = findAnchorFromDocument(this.document, target);
    if (elSelected) {
      this.scrollToElement(elSelected);
      elSelected.focus();
    }
  }
  /**
   * Disables automatic scroll restoration provided by the browser.
   */
  setHistoryScrollRestoration(scrollRestoration) {
    this.window.history.scrollRestoration = scrollRestoration;
  }
  /**
   * Scrolls to an element using the native offset and the specified offset set on this scroller.
   *
   * The offset can be used when we know that there is a floating header and scrolling naively to an
   * element (ex: `scrollIntoView`) leaves the element hidden behind the floating header.
   */
  scrollToElement(el) {
    const rect = el.getBoundingClientRect();
    const left = rect.left + this.window.pageXOffset;
    const top = rect.top + this.window.pageYOffset;
    const offset = this.offset();
    this.window.scrollTo(left - offset[0], top - offset[1]);
  }
};
function findAnchorFromDocument(document2, target) {
  const documentResult = document2.getElementById(target) || document2.getElementsByName(target)[0];
  if (documentResult) {
    return documentResult;
  }
  if (typeof document2.createTreeWalker === "function" && document2.body && typeof document2.body.attachShadow === "function") {
    const treeWalker = document2.createTreeWalker(document2.body, NodeFilter.SHOW_ELEMENT);
    let currentNode = treeWalker.currentNode;
    while (currentNode) {
      const shadowRoot = currentNode.shadowRoot;
      if (shadowRoot) {
        const result = shadowRoot.getElementById(target) || shadowRoot.querySelector(`[name="${target}"]`);
        if (result) {
          return result;
        }
      }
      currentNode = treeWalker.nextNode();
    }
  }
  return null;
}
var NullViewportScroller = class {
  /**
   * Empty implementation
   */
  setOffset(offset) {
  }
  /**
   * Empty implementation
   */
  getScrollPosition() {
    return [0, 0];
  }
  /**
   * Empty implementation
   */
  scrollToPosition(position) {
  }
  /**
   * Empty implementation
   */
  scrollToAnchor(anchor) {
  }
  /**
   * Empty implementation
   */
  setHistoryScrollRestoration(scrollRestoration) {
  }
};
var PLACEHOLDER_QUALITY = "20";
function getUrl(src, win) {
  return isAbsoluteUrl(src) ? new URL(src) : new URL(src, win.location.href);
}
function isAbsoluteUrl(src) {
  return /^https?:\/\//.test(src);
}
function extractHostname(url) {
  return isAbsoluteUrl(url) ? new URL(url).hostname : url;
}
function isValidPath(path) {
  const isString = typeof path === "string";
  if (!isString || path.trim() === "") {
    return false;
  }
  try {
    const url = new URL(path);
    return true;
  } catch {
    return false;
  }
}
function normalizePath(path) {
  return path.endsWith("/") ? path.slice(0, -1) : path;
}
function normalizeSrc(src) {
  return src.startsWith("/") ? src.slice(1) : src;
}
var noopImageLoader = (config) => config.src;
var IMAGE_LOADER = new InjectionToken(ngDevMode ? "ImageLoader" : "", {
  providedIn: "root",
  factory: () => noopImageLoader
});
function createImageLoader(buildUrlFn, exampleUrls) {
  return function provideImageLoader(path) {
    if (!isValidPath(path)) {
      throwInvalidPathError(path, exampleUrls || []);
    }
    path = normalizePath(path);
    const loaderFn = (config) => {
      if (isAbsoluteUrl(config.src)) {
        throwUnexpectedAbsoluteUrlError(path, config.src);
      }
      return buildUrlFn(path, __spreadProps(__spreadValues({}, config), {
        src: normalizeSrc(config.src)
      }));
    };
    const providers = [{
      provide: IMAGE_LOADER,
      useValue: loaderFn
    }];
    return providers;
  };
}
function throwInvalidPathError(path, exampleUrls) {
  throw new RuntimeError(2959, ngDevMode && `Image loader has detected an invalid path (\`${path}\`). To fix this, supply a path using one of the following formats: ${exampleUrls.join(" or ")}`);
}
function throwUnexpectedAbsoluteUrlError(path, url) {
  throw new RuntimeError(2959, ngDevMode && `Image loader has detected a \`<img>\` tag with an invalid \`ngSrc\` attribute: ${url}. This image loader expects \`ngSrc\` to be a relative URL - however the provided value is an absolute URL. To fix this, provide \`ngSrc\` as a path relative to the base URL configured for this loader (\`${path}\`).`);
}
var provideCloudflareLoader = createImageLoader(createCloudflareUrl, ngDevMode ? ["https://<ZONE>/cdn-cgi/image/<OPTIONS>/<SOURCE-IMAGE>"] : void 0);
function createCloudflareUrl(path, config) {
  let params = `format=auto`;
  if (config.width) {
    params += `,width=${config.width}`;
  }
  if (config.isPlaceholder) {
    params += `,quality=${PLACEHOLDER_QUALITY}`;
  }
  return `${path}/cdn-cgi/image/${params}/${config.src}`;
}
var cloudinaryLoaderInfo = {
  name: "Cloudinary",
  testUrl: isCloudinaryUrl
};
var CLOUDINARY_LOADER_REGEX = /https?\:\/\/[^\/]+\.cloudinary\.com\/.+/;
function isCloudinaryUrl(url) {
  return CLOUDINARY_LOADER_REGEX.test(url);
}
var provideCloudinaryLoader = createImageLoader(createCloudinaryUrl, ngDevMode ? ["https://res.cloudinary.com/mysite", "https://mysite.cloudinary.com", "https://subdomain.mysite.com"] : void 0);
function createCloudinaryUrl(path, config) {
  const quality = config.isPlaceholder ? "q_auto:low" : "q_auto";
  let params = `f_auto,${quality}`;
  if (config.width) {
    params += `,w_${config.width}`;
  }
  return `${path}/image/upload/${params}/${config.src}`;
}
var imageKitLoaderInfo = {
  name: "ImageKit",
  testUrl: isImageKitUrl
};
var IMAGE_KIT_LOADER_REGEX = /https?\:\/\/[^\/]+\.imagekit\.io\/.+/;
function isImageKitUrl(url) {
  return IMAGE_KIT_LOADER_REGEX.test(url);
}
var provideImageKitLoader = createImageLoader(createImagekitUrl, ngDevMode ? ["https://ik.imagekit.io/mysite", "https://subdomain.mysite.com"] : void 0);
function createImagekitUrl(path, config) {
  const {
    src,
    width
  } = config;
  const params = [];
  if (width) {
    params.push(`w-${width}`);
  }
  if (config.isPlaceholder) {
    params.push(`q-${PLACEHOLDER_QUALITY}`);
  }
  const urlSegments = params.length ? [path, `tr:${params.join(",")}`, src] : [path, src];
  const url = new URL(urlSegments.join("/"));
  return url.href;
}
var imgixLoaderInfo = {
  name: "Imgix",
  testUrl: isImgixUrl
};
var IMGIX_LOADER_REGEX = /https?\:\/\/[^\/]+\.imgix\.net\/.+/;
function isImgixUrl(url) {
  return IMGIX_LOADER_REGEX.test(url);
}
var provideImgixLoader = createImageLoader(createImgixUrl, ngDevMode ? ["https://somepath.imgix.net/"] : void 0);
function createImgixUrl(path, config) {
  const url = new URL(`${path}/${config.src}`);
  url.searchParams.set("auto", "format");
  if (config.width) {
    url.searchParams.set("w", config.width.toString());
  }
  if (config.isPlaceholder) {
    url.searchParams.set("q", PLACEHOLDER_QUALITY);
  }
  return url.href;
}
var netlifyLoaderInfo = {
  name: "Netlify",
  testUrl: isNetlifyUrl
};
var NETLIFY_LOADER_REGEX = /https?\:\/\/[^\/]+\.netlify\.app\/.+/;
function isNetlifyUrl(url) {
  return NETLIFY_LOADER_REGEX.test(url);
}
function imgDirectiveDetails(ngSrc, includeNgSrc = true) {
  const ngSrcInfo = includeNgSrc ? `(activated on an <img> element with the \`ngSrc="${ngSrc}"\`) ` : "";
  return `The NgOptimizedImage directive ${ngSrcInfo}has detected that`;
}
function assertDevMode(checkName) {
  if (!ngDevMode) {
    throw new RuntimeError(2958, `Unexpected invocation of the ${checkName} in the prod mode. Please make sure that the prod mode is enabled for production builds.`);
  }
}
var LCPImageObserver = class _LCPImageObserver {
  constructor() {
    this.images = /* @__PURE__ */ new Map();
    this.window = null;
    this.observer = null;
    const isBrowser = isPlatformBrowser2(inject(PLATFORM_ID));
    assertDevMode("LCP checker");
    const win = inject(DOCUMENT2).defaultView;
    if (isBrowser && typeof PerformanceObserver !== "undefined") {
      this.window = win;
      this.observer = this.initPerformanceObserver();
    }
  }
  /**
   * Inits PerformanceObserver and subscribes to LCP events.
   * Based on https://web.dev/lcp/#measure-lcp-in-javascript
   */
  initPerformanceObserver() {
    const observer = new PerformanceObserver((entryList) => {
      const entries = entryList.getEntries();
      if (entries.length === 0) return;
      const lcpElement = entries[entries.length - 1];
      const imgSrc = lcpElement.element?.src ?? "";
      if (imgSrc.startsWith("data:") || imgSrc.startsWith("blob:")) return;
      const img = this.images.get(imgSrc);
      if (!img) return;
      if (!img.priority && !img.alreadyWarnedPriority) {
        img.alreadyWarnedPriority = true;
        logMissingPriorityError(imgSrc);
      }
      if (img.modified && !img.alreadyWarnedModified) {
        img.alreadyWarnedModified = true;
        logModifiedWarning(imgSrc);
      }
    });
    observer.observe({
      type: "largest-contentful-paint",
      buffered: true
    });
    return observer;
  }
  registerImage(rewrittenSrc, originalNgSrc, isPriority) {
    if (!this.observer) return;
    const newObservedImageState = {
      priority: isPriority,
      modified: false,
      alreadyWarnedModified: false,
      alreadyWarnedPriority: false
    };
    this.images.set(getUrl(rewrittenSrc, this.window).href, newObservedImageState);
  }
  unregisterImage(rewrittenSrc) {
    if (!this.observer) return;
    this.images.delete(getUrl(rewrittenSrc, this.window).href);
  }
  updateImage(originalSrc, newSrc) {
    if (!this.observer) return;
    const originalUrl = getUrl(originalSrc, this.window).href;
    const img = this.images.get(originalUrl);
    if (img) {
      img.modified = true;
      this.images.set(getUrl(newSrc, this.window).href, img);
      this.images.delete(originalUrl);
    }
  }
  ngOnDestroy() {
    if (!this.observer) return;
    this.observer.disconnect();
    this.images.clear();
  }
  static {
    this.ɵfac = function LCPImageObserver_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _LCPImageObserver)();
    };
  }
  static {
    this.ɵprov = ɵɵdefineInjectable({
      token: _LCPImageObserver,
      factory: _LCPImageObserver.ɵfac,
      providedIn: "root"
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(LCPImageObserver, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], () => [], null);
})();
function logMissingPriorityError(ngSrc) {
  const directiveDetails = imgDirectiveDetails(ngSrc);
  console.error(formatRuntimeError(2955, `${directiveDetails} this image is the Largest Contentful Paint (LCP) element but was not marked "priority". This image should be marked "priority" in order to prioritize its loading. To fix this, add the "priority" attribute.`));
}
function logModifiedWarning(ngSrc) {
  const directiveDetails = imgDirectiveDetails(ngSrc);
  console.warn(formatRuntimeError(2964, `${directiveDetails} this image is the Largest Contentful Paint (LCP) element and has had its "ngSrc" attribute modified. This can cause slower loading performance. It is recommended not to modify the "ngSrc" property on any image which could be the LCP element.`));
}
var INTERNAL_PRECONNECT_CHECK_BLOCKLIST = /* @__PURE__ */ new Set(["localhost", "127.0.0.1", "0.0.0.0"]);
var PRECONNECT_CHECK_BLOCKLIST = new InjectionToken(ngDevMode ? "PRECONNECT_CHECK_BLOCKLIST" : "");
var PreconnectLinkChecker = class _PreconnectLinkChecker {
  constructor() {
    this.document = inject(DOCUMENT2);
    this.isServer = isPlatformServer(inject(PLATFORM_ID));
    this.preconnectLinks = null;
    this.alreadySeen = /* @__PURE__ */ new Set();
    this.window = null;
    this.blocklist = new Set(INTERNAL_PRECONNECT_CHECK_BLOCKLIST);
    assertDevMode("preconnect link checker");
    const win = this.document.defaultView;
    if (typeof win !== "undefined") {
      this.window = win;
    }
    const blocklist = inject(PRECONNECT_CHECK_BLOCKLIST, {
      optional: true
    });
    if (blocklist) {
      this.populateBlocklist(blocklist);
    }
  }
  populateBlocklist(origins) {
    if (Array.isArray(origins)) {
      deepForEach2(origins, (origin) => {
        this.blocklist.add(extractHostname(origin));
      });
    } else {
      this.blocklist.add(extractHostname(origins));
    }
  }
  /**
   * Checks that a preconnect resource hint exists in the head for the
   * given src.
   *
   * @param rewrittenSrc src formatted with loader
   * @param originalNgSrc ngSrc value
   */
  assertPreconnect(rewrittenSrc, originalNgSrc) {
    if (this.isServer) return;
    const imgUrl = getUrl(rewrittenSrc, this.window);
    if (this.blocklist.has(imgUrl.hostname) || this.alreadySeen.has(imgUrl.origin)) return;
    this.alreadySeen.add(imgUrl.origin);
    this.preconnectLinks ??= this.queryPreconnectLinks();
    if (!this.preconnectLinks.has(imgUrl.origin)) {
      console.warn(formatRuntimeError(2956, `${imgDirectiveDetails(originalNgSrc)} there is no preconnect tag present for this image. Preconnecting to the origin(s) that serve priority images ensures that these images are delivered as soon as possible. To fix this, please add the following element into the <head> of the document:
  <link rel="preconnect" href="${imgUrl.origin}">`));
    }
  }
  queryPreconnectLinks() {
    const preconnectUrls = /* @__PURE__ */ new Set();
    const selector = "link[rel=preconnect]";
    const links = Array.from(this.document.querySelectorAll(selector));
    for (let link of links) {
      const url = getUrl(link.href, this.window);
      preconnectUrls.add(url.origin);
    }
    return preconnectUrls;
  }
  ngOnDestroy() {
    this.preconnectLinks?.clear();
    this.alreadySeen.clear();
  }
  static {
    this.ɵfac = function PreconnectLinkChecker_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _PreconnectLinkChecker)();
    };
  }
  static {
    this.ɵprov = ɵɵdefineInjectable({
      token: _PreconnectLinkChecker,
      factory: _PreconnectLinkChecker.ɵfac,
      providedIn: "root"
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PreconnectLinkChecker, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], () => [], null);
})();
function deepForEach2(input2, fn) {
  for (let value of input2) {
    Array.isArray(value) ? deepForEach2(value, fn) : fn(value);
  }
}
var DEFAULT_PRELOADED_IMAGES_LIMIT = 5;
var PRELOADED_IMAGES = new InjectionToken("NG_OPTIMIZED_PRELOADED_IMAGES", {
  providedIn: "root",
  factory: () => /* @__PURE__ */ new Set()
});
var PreloadLinkCreator = class _PreloadLinkCreator {
  constructor() {
    this.preloadedImages = inject(PRELOADED_IMAGES);
    this.document = inject(DOCUMENT2);
  }
  /**
   * @description Add a preload `<link>` to the `<head>` of the `index.html` that is served from the
   * server while using Angular Universal and SSR to kick off image loads for high priority images.
   *
   * The `sizes` (passed in from the user) and `srcset` (parsed and formatted from `ngSrcset`)
   * properties used to set the corresponding attributes, `imagesizes` and `imagesrcset`
   * respectively, on the preload `<link>` tag so that the correctly sized image is preloaded from
   * the CDN.
   *
   * {@link https://web.dev/preload-responsive-images/#imagesrcset-and-imagesizes}
   *
   * @param renderer The `Renderer2` passed in from the directive
   * @param src The original src of the image that is set on the `ngSrc` input.
   * @param srcset The parsed and formatted srcset created from the `ngSrcset` input
   * @param sizes The value of the `sizes` attribute passed in to the `<img>` tag
   */
  createPreloadLinkTag(renderer, src, srcset, sizes) {
    if (ngDevMode) {
      if (this.preloadedImages.size >= DEFAULT_PRELOADED_IMAGES_LIMIT) {
        throw new RuntimeError(2961, ngDevMode && `The \`NgOptimizedImage\` directive has detected that more than ${DEFAULT_PRELOADED_IMAGES_LIMIT} images were marked as priority. This might negatively affect an overall performance of the page. To fix this, remove the "priority" attribute from images with less priority.`);
      }
    }
    if (this.preloadedImages.has(src)) {
      return;
    }
    this.preloadedImages.add(src);
    const preload = renderer.createElement("link");
    renderer.setAttribute(preload, "as", "image");
    renderer.setAttribute(preload, "href", src);
    renderer.setAttribute(preload, "rel", "preload");
    renderer.setAttribute(preload, "fetchpriority", "high");
    if (sizes) {
      renderer.setAttribute(preload, "imageSizes", sizes);
    }
    if (srcset) {
      renderer.setAttribute(preload, "imageSrcset", srcset);
    }
    renderer.appendChild(this.document.head, preload);
  }
  static {
    this.ɵfac = function PreloadLinkCreator_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _PreloadLinkCreator)();
    };
  }
  static {
    this.ɵprov = ɵɵdefineInjectable({
      token: _PreloadLinkCreator,
      factory: _PreloadLinkCreator.ɵfac,
      providedIn: "root"
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PreloadLinkCreator, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], null, null);
})();
var BASE64_IMG_MAX_LENGTH_IN_ERROR = 50;
var VALID_WIDTH_DESCRIPTOR_SRCSET = /^((\s*\d+w\s*(,|$)){1,})$/;
var VALID_DENSITY_DESCRIPTOR_SRCSET = /^((\s*\d+(\.\d+)?x\s*(,|$)){1,})$/;
var ABSOLUTE_SRCSET_DENSITY_CAP = 3;
var RECOMMENDED_SRCSET_DENSITY_CAP = 2;
var DENSITY_SRCSET_MULTIPLIERS = [1, 2];
var VIEWPORT_BREAKPOINT_CUTOFF = 640;
var ASPECT_RATIO_TOLERANCE = 0.1;
var OVERSIZED_IMAGE_TOLERANCE2 = 1e3;
var FIXED_SRCSET_WIDTH_LIMIT = 1920;
var FIXED_SRCSET_HEIGHT_LIMIT = 1080;
var PLACEHOLDER_BLUR_AMOUNT = 15;
var PLACEHOLDER_DIMENSION_LIMIT = 1e3;
var DATA_URL_WARN_LIMIT = 4e3;
var DATA_URL_ERROR_LIMIT = 1e4;
var BUILT_IN_LOADERS = [imgixLoaderInfo, imageKitLoaderInfo, cloudinaryLoaderInfo, netlifyLoaderInfo];
var PRIORITY_COUNT_THRESHOLD = 10;
var IMGS_WITH_PRIORITY_ATTR_COUNT = 0;
var NgOptimizedImage = class _NgOptimizedImage {
  constructor() {
    this.imageLoader = inject(IMAGE_LOADER);
    this.config = processConfig(inject(IMAGE_CONFIG));
    this.renderer = inject(Renderer2);
    this.imgElement = inject(ElementRef).nativeElement;
    this.injector = inject(Injector);
    this.isServer = isPlatformServer(inject(PLATFORM_ID));
    this.preloadLinkCreator = inject(PreloadLinkCreator);
    this.lcpObserver = ngDevMode ? this.injector.get(LCPImageObserver) : null;
    this._renderedSrc = null;
    this.priority = false;
    this.disableOptimizedSrcset = false;
    this.fill = false;
  }
  /** @nodoc */
  ngOnInit() {
    performanceMarkFeature("NgOptimizedImage");
    if (ngDevMode) {
      const ngZone = this.injector.get(NgZone);
      assertNonEmptyInput(this, "ngSrc", this.ngSrc);
      assertValidNgSrcset(this, this.ngSrcset);
      assertNoConflictingSrc(this);
      if (this.ngSrcset) {
        assertNoConflictingSrcset(this);
      }
      assertNotBase64Image(this);
      assertNotBlobUrl(this);
      if (this.fill) {
        assertEmptyWidthAndHeight(this);
        ngZone.runOutsideAngular(() => assertNonZeroRenderedHeight(this, this.imgElement, this.renderer));
      } else {
        assertNonEmptyWidthAndHeight(this);
        if (this.height !== void 0) {
          assertGreaterThanZero(this, this.height, "height");
        }
        if (this.width !== void 0) {
          assertGreaterThanZero(this, this.width, "width");
        }
        ngZone.runOutsideAngular(() => assertNoImageDistortion(this, this.imgElement, this.renderer));
      }
      assertValidLoadingInput(this);
      if (!this.ngSrcset) {
        assertNoComplexSizes(this);
      }
      assertValidPlaceholder(this, this.imageLoader);
      assertNotMissingBuiltInLoader(this.ngSrc, this.imageLoader);
      assertNoNgSrcsetWithoutLoader(this, this.imageLoader);
      assertNoLoaderParamsWithoutLoader(this, this.imageLoader);
      if (this.lcpObserver !== null) {
        const ngZone2 = this.injector.get(NgZone);
        ngZone2.runOutsideAngular(() => {
          this.lcpObserver.registerImage(this.getRewrittenSrc(), this.ngSrc, this.priority);
        });
      }
      if (this.priority) {
        const checker = this.injector.get(PreconnectLinkChecker);
        checker.assertPreconnect(this.getRewrittenSrc(), this.ngSrc);
        if (!this.isServer) {
          const applicationRef = this.injector.get(ApplicationRef);
          assetPriorityCountBelowThreshold(applicationRef);
        }
      }
    }
    if (this.placeholder) {
      this.removePlaceholderOnLoad(this.imgElement);
    }
    this.setHostAttributes();
  }
  setHostAttributes() {
    if (this.fill) {
      this.sizes ||= "100vw";
    } else {
      this.setHostAttribute("width", this.width.toString());
      this.setHostAttribute("height", this.height.toString());
    }
    this.setHostAttribute("loading", this.getLoadingBehavior());
    this.setHostAttribute("fetchpriority", this.getFetchPriority());
    this.setHostAttribute("ng-img", "true");
    const rewrittenSrcset = this.updateSrcAndSrcset();
    if (this.sizes) {
      this.setHostAttribute("sizes", this.sizes);
    }
    if (this.isServer && this.priority) {
      this.preloadLinkCreator.createPreloadLinkTag(this.renderer, this.getRewrittenSrc(), rewrittenSrcset, this.sizes);
    }
  }
  /** @nodoc */
  ngOnChanges(changes) {
    if (ngDevMode) {
      assertNoPostInitInputChange(this, changes, ["ngSrcset", "width", "height", "priority", "fill", "loading", "sizes", "loaderParams", "disableOptimizedSrcset"]);
    }
    if (changes["ngSrc"] && !changes["ngSrc"].isFirstChange()) {
      const oldSrc = this._renderedSrc;
      this.updateSrcAndSrcset(true);
      const newSrc = this._renderedSrc;
      if (this.lcpObserver !== null && oldSrc && newSrc && oldSrc !== newSrc) {
        const ngZone = this.injector.get(NgZone);
        ngZone.runOutsideAngular(() => {
          this.lcpObserver?.updateImage(oldSrc, newSrc);
        });
      }
    }
    if (ngDevMode && changes["placeholder"]?.currentValue && !this.isServer) {
      assertPlaceholderDimensions(this, this.imgElement);
    }
  }
  callImageLoader(configWithoutCustomParams) {
    let augmentedConfig = configWithoutCustomParams;
    if (this.loaderParams) {
      augmentedConfig.loaderParams = this.loaderParams;
    }
    return this.imageLoader(augmentedConfig);
  }
  getLoadingBehavior() {
    if (!this.priority && this.loading !== void 0) {
      return this.loading;
    }
    return this.priority ? "eager" : "lazy";
  }
  getFetchPriority() {
    return this.priority ? "high" : "auto";
  }
  getRewrittenSrc() {
    if (!this._renderedSrc) {
      const imgConfig = {
        src: this.ngSrc
      };
      this._renderedSrc = this.callImageLoader(imgConfig);
    }
    return this._renderedSrc;
  }
  getRewrittenSrcset() {
    const widthSrcSet = VALID_WIDTH_DESCRIPTOR_SRCSET.test(this.ngSrcset);
    const finalSrcs = this.ngSrcset.split(",").filter((src) => src !== "").map((srcStr) => {
      srcStr = srcStr.trim();
      const width = widthSrcSet ? parseFloat(srcStr) : parseFloat(srcStr) * this.width;
      return `${this.callImageLoader({
        src: this.ngSrc,
        width
      })} ${srcStr}`;
    });
    return finalSrcs.join(", ");
  }
  getAutomaticSrcset() {
    if (this.sizes) {
      return this.getResponsiveSrcset();
    } else {
      return this.getFixedSrcset();
    }
  }
  getResponsiveSrcset() {
    const {
      breakpoints
    } = this.config;
    let filteredBreakpoints = breakpoints;
    if (this.sizes?.trim() === "100vw") {
      filteredBreakpoints = breakpoints.filter((bp) => bp >= VIEWPORT_BREAKPOINT_CUTOFF);
    }
    const finalSrcs = filteredBreakpoints.map((bp) => `${this.callImageLoader({
      src: this.ngSrc,
      width: bp
    })} ${bp}w`);
    return finalSrcs.join(", ");
  }
  updateSrcAndSrcset(forceSrcRecalc = false) {
    if (forceSrcRecalc) {
      this._renderedSrc = null;
    }
    const rewrittenSrc = this.getRewrittenSrc();
    this.setHostAttribute("src", rewrittenSrc);
    let rewrittenSrcset = void 0;
    if (this.ngSrcset) {
      rewrittenSrcset = this.getRewrittenSrcset();
    } else if (this.shouldGenerateAutomaticSrcset()) {
      rewrittenSrcset = this.getAutomaticSrcset();
    }
    if (rewrittenSrcset) {
      this.setHostAttribute("srcset", rewrittenSrcset);
    }
    return rewrittenSrcset;
  }
  getFixedSrcset() {
    const finalSrcs = DENSITY_SRCSET_MULTIPLIERS.map((multiplier) => `${this.callImageLoader({
      src: this.ngSrc,
      width: this.width * multiplier
    })} ${multiplier}x`);
    return finalSrcs.join(", ");
  }
  shouldGenerateAutomaticSrcset() {
    let oversizedImage = false;
    if (!this.sizes) {
      oversizedImage = this.width > FIXED_SRCSET_WIDTH_LIMIT || this.height > FIXED_SRCSET_HEIGHT_LIMIT;
    }
    return !this.disableOptimizedSrcset && !this.srcset && this.imageLoader !== noopImageLoader && !oversizedImage;
  }
  /**
   * Returns an image url formatted for use with the CSS background-image property. Expects one of:
   * * A base64 encoded image, which is wrapped and passed through.
   * * A boolean. If true, calls the image loader to generate a small placeholder url.
   */
  generatePlaceholder(placeholderInput) {
    const {
      placeholderResolution
    } = this.config;
    if (placeholderInput === true) {
      return `url(${this.callImageLoader({
        src: this.ngSrc,
        width: placeholderResolution,
        isPlaceholder: true
      })})`;
    } else if (typeof placeholderInput === "string") {
      return `url(${placeholderInput})`;
    }
    return null;
  }
  /**
   * Determines if blur should be applied, based on an optional boolean
   * property `blur` within the optional configuration object `placeholderConfig`.
   */
  shouldBlurPlaceholder(placeholderConfig) {
    if (!placeholderConfig || !placeholderConfig.hasOwnProperty("blur")) {
      return true;
    }
    return Boolean(placeholderConfig.blur);
  }
  removePlaceholderOnLoad(img) {
    const callback = () => {
      const changeDetectorRef = this.injector.get(ChangeDetectorRef);
      removeLoadListenerFn();
      removeErrorListenerFn();
      this.placeholder = false;
      changeDetectorRef.markForCheck();
    };
    const removeLoadListenerFn = this.renderer.listen(img, "load", callback);
    const removeErrorListenerFn = this.renderer.listen(img, "error", callback);
  }
  /** @nodoc */
  ngOnDestroy() {
    if (ngDevMode) {
      if (!this.priority && this._renderedSrc !== null && this.lcpObserver !== null) {
        this.lcpObserver.unregisterImage(this._renderedSrc);
      }
    }
  }
  setHostAttribute(name, value) {
    this.renderer.setAttribute(this.imgElement, name, value);
  }
  static {
    this.ɵfac = function NgOptimizedImage_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _NgOptimizedImage)();
    };
  }
  static {
    this.ɵdir = ɵɵdefineDirective({
      type: _NgOptimizedImage,
      selectors: [["img", "ngSrc", ""]],
      hostVars: 18,
      hostBindings: function NgOptimizedImage_HostBindings(rf, ctx) {
        if (rf & 2) {
          ɵɵstyleProp("position", ctx.fill ? "absolute" : null)("width", ctx.fill ? "100%" : null)("height", ctx.fill ? "100%" : null)("inset", ctx.fill ? "0" : null)("background-size", ctx.placeholder ? "cover" : null)("background-position", ctx.placeholder ? "50% 50%" : null)("background-repeat", ctx.placeholder ? "no-repeat" : null)("background-image", ctx.placeholder ? ctx.generatePlaceholder(ctx.placeholder) : null)("filter", ctx.placeholder && ctx.shouldBlurPlaceholder(ctx.placeholderConfig) ? "blur(15px)" : null);
        }
      },
      inputs: {
        ngSrc: [2, "ngSrc", "ngSrc", unwrapSafeUrl],
        ngSrcset: "ngSrcset",
        sizes: "sizes",
        width: [2, "width", "width", numberAttribute],
        height: [2, "height", "height", numberAttribute],
        loading: "loading",
        priority: [2, "priority", "priority", booleanAttribute],
        loaderParams: "loaderParams",
        disableOptimizedSrcset: [2, "disableOptimizedSrcset", "disableOptimizedSrcset", booleanAttribute],
        fill: [2, "fill", "fill", booleanAttribute],
        placeholder: [2, "placeholder", "placeholder", booleanOrUrlAttribute],
        placeholderConfig: "placeholderConfig",
        src: "src",
        srcset: "srcset"
      },
      standalone: true,
      features: [ɵɵInputTransformsFeature, ɵɵNgOnChangesFeature]
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NgOptimizedImage, [{
    type: Directive,
    args: [{
      standalone: true,
      selector: "img[ngSrc]",
      host: {
        "[style.position]": 'fill ? "absolute" : null',
        "[style.width]": 'fill ? "100%" : null',
        "[style.height]": 'fill ? "100%" : null',
        "[style.inset]": 'fill ? "0" : null',
        "[style.background-size]": 'placeholder ? "cover" : null',
        "[style.background-position]": 'placeholder ? "50% 50%" : null',
        "[style.background-repeat]": 'placeholder ? "no-repeat" : null',
        "[style.background-image]": "placeholder ? generatePlaceholder(placeholder) : null",
        "[style.filter]": `placeholder && shouldBlurPlaceholder(placeholderConfig) ? "blur(${PLACEHOLDER_BLUR_AMOUNT}px)" : null`
      }
    }]
  }], null, {
    ngSrc: [{
      type: Input,
      args: [{
        required: true,
        transform: unwrapSafeUrl
      }]
    }],
    ngSrcset: [{
      type: Input
    }],
    sizes: [{
      type: Input
    }],
    width: [{
      type: Input,
      args: [{
        transform: numberAttribute
      }]
    }],
    height: [{
      type: Input,
      args: [{
        transform: numberAttribute
      }]
    }],
    loading: [{
      type: Input
    }],
    priority: [{
      type: Input,
      args: [{
        transform: booleanAttribute
      }]
    }],
    loaderParams: [{
      type: Input
    }],
    disableOptimizedSrcset: [{
      type: Input,
      args: [{
        transform: booleanAttribute
      }]
    }],
    fill: [{
      type: Input,
      args: [{
        transform: booleanAttribute
      }]
    }],
    placeholder: [{
      type: Input,
      args: [{
        transform: booleanOrUrlAttribute
      }]
    }],
    placeholderConfig: [{
      type: Input
    }],
    src: [{
      type: Input
    }],
    srcset: [{
      type: Input
    }]
  });
})();
function processConfig(config) {
  let sortedBreakpoints = {};
  if (config.breakpoints) {
    sortedBreakpoints.breakpoints = config.breakpoints.sort((a, b) => a - b);
  }
  return Object.assign({}, IMAGE_CONFIG_DEFAULTS, config, sortedBreakpoints);
}
function assertNoConflictingSrc(dir) {
  if (dir.src) {
    throw new RuntimeError(2950, `${imgDirectiveDetails(dir.ngSrc)} both \`src\` and \`ngSrc\` have been set. Supplying both of these attributes breaks lazy loading. The NgOptimizedImage directive sets \`src\` itself based on the value of \`ngSrc\`. To fix this, please remove the \`src\` attribute.`);
  }
}
function assertNoConflictingSrcset(dir) {
  if (dir.srcset) {
    throw new RuntimeError(2951, `${imgDirectiveDetails(dir.ngSrc)} both \`srcset\` and \`ngSrcset\` have been set. Supplying both of these attributes breaks lazy loading. The NgOptimizedImage directive sets \`srcset\` itself based on the value of \`ngSrcset\`. To fix this, please remove the \`srcset\` attribute.`);
  }
}
function assertNotBase64Image(dir) {
  let ngSrc = dir.ngSrc.trim();
  if (ngSrc.startsWith("data:")) {
    if (ngSrc.length > BASE64_IMG_MAX_LENGTH_IN_ERROR) {
      ngSrc = ngSrc.substring(0, BASE64_IMG_MAX_LENGTH_IN_ERROR) + "...";
    }
    throw new RuntimeError(2952, `${imgDirectiveDetails(dir.ngSrc, false)} \`ngSrc\` is a Base64-encoded string (${ngSrc}). NgOptimizedImage does not support Base64-encoded strings. To fix this, disable the NgOptimizedImage directive for this element by removing \`ngSrc\` and using a standard \`src\` attribute instead.`);
  }
}
function assertNoComplexSizes(dir) {
  let sizes = dir.sizes;
  if (sizes?.match(/((\)|,)\s|^)\d+px/)) {
    throw new RuntimeError(2952, `${imgDirectiveDetails(dir.ngSrc, false)} \`sizes\` was set to a string including pixel values. For automatic \`srcset\` generation, \`sizes\` must only include responsive values, such as \`sizes="50vw"\` or \`sizes="(min-width: 768px) 50vw, 100vw"\`. To fix this, modify the \`sizes\` attribute, or provide your own \`ngSrcset\` value directly.`);
  }
}
function assertValidPlaceholder(dir, imageLoader) {
  assertNoPlaceholderConfigWithoutPlaceholder(dir);
  assertNoRelativePlaceholderWithoutLoader(dir, imageLoader);
  assertNoOversizedDataUrl(dir);
}
function assertNoPlaceholderConfigWithoutPlaceholder(dir) {
  if (dir.placeholderConfig && !dir.placeholder) {
    throw new RuntimeError(2952, `${imgDirectiveDetails(dir.ngSrc, false)} \`placeholderConfig\` options were provided for an image that does not use the \`placeholder\` attribute, and will have no effect.`);
  }
}
function assertNoRelativePlaceholderWithoutLoader(dir, imageLoader) {
  if (dir.placeholder === true && imageLoader === noopImageLoader) {
    throw new RuntimeError(2963, `${imgDirectiveDetails(dir.ngSrc)} the \`placeholder\` attribute is set to true but no image loader is configured (i.e. the default one is being used), which would result in the same image being used for the primary image and its placeholder. To fix this, provide a loader or remove the \`placeholder\` attribute from the image.`);
  }
}
function assertNoOversizedDataUrl(dir) {
  if (dir.placeholder && typeof dir.placeholder === "string" && dir.placeholder.startsWith("data:")) {
    if (dir.placeholder.length > DATA_URL_ERROR_LIMIT) {
      throw new RuntimeError(2965, `${imgDirectiveDetails(dir.ngSrc)} the \`placeholder\` attribute is set to a data URL which is longer than ${DATA_URL_ERROR_LIMIT} characters. This is strongly discouraged, as large inline placeholders directly increase the bundle size of Angular and hurt page load performance. To fix this, generate a smaller data URL placeholder.`);
    }
    if (dir.placeholder.length > DATA_URL_WARN_LIMIT) {
      console.warn(formatRuntimeError(2965, `${imgDirectiveDetails(dir.ngSrc)} the \`placeholder\` attribute is set to a data URL which is longer than ${DATA_URL_WARN_LIMIT} characters. This is discouraged, as large inline placeholders directly increase the bundle size of Angular and hurt page load performance. For better loading performance, generate a smaller data URL placeholder.`));
    }
  }
}
function assertNotBlobUrl(dir) {
  const ngSrc = dir.ngSrc.trim();
  if (ngSrc.startsWith("blob:")) {
    throw new RuntimeError(2952, `${imgDirectiveDetails(dir.ngSrc)} \`ngSrc\` was set to a blob URL (${ngSrc}). Blob URLs are not supported by the NgOptimizedImage directive. To fix this, disable the NgOptimizedImage directive for this element by removing \`ngSrc\` and using a regular \`src\` attribute instead.`);
  }
}
function assertNonEmptyInput(dir, name, value) {
  const isString = typeof value === "string";
  const isEmptyString = isString && value.trim() === "";
  if (!isString || isEmptyString) {
    throw new RuntimeError(2952, `${imgDirectiveDetails(dir.ngSrc)} \`${name}\` has an invalid value (\`${value}\`). To fix this, change the value to a non-empty string.`);
  }
}
function assertValidNgSrcset(dir, value) {
  if (value == null) return;
  assertNonEmptyInput(dir, "ngSrcset", value);
  const stringVal = value;
  const isValidWidthDescriptor = VALID_WIDTH_DESCRIPTOR_SRCSET.test(stringVal);
  const isValidDensityDescriptor = VALID_DENSITY_DESCRIPTOR_SRCSET.test(stringVal);
  if (isValidDensityDescriptor) {
    assertUnderDensityCap(dir, stringVal);
  }
  const isValidSrcset = isValidWidthDescriptor || isValidDensityDescriptor;
  if (!isValidSrcset) {
    throw new RuntimeError(2952, `${imgDirectiveDetails(dir.ngSrc)} \`ngSrcset\` has an invalid value (\`${value}\`). To fix this, supply \`ngSrcset\` using a comma-separated list of one or more width descriptors (e.g. "100w, 200w") or density descriptors (e.g. "1x, 2x").`);
  }
}
function assertUnderDensityCap(dir, value) {
  const underDensityCap = value.split(",").every((num) => num === "" || parseFloat(num) <= ABSOLUTE_SRCSET_DENSITY_CAP);
  if (!underDensityCap) {
    throw new RuntimeError(2952, `${imgDirectiveDetails(dir.ngSrc)} the \`ngSrcset\` contains an unsupported image density:\`${value}\`. NgOptimizedImage generally recommends a max image density of ${RECOMMENDED_SRCSET_DENSITY_CAP}x but supports image densities up to ${ABSOLUTE_SRCSET_DENSITY_CAP}x. The human eye cannot distinguish between image densities greater than ${RECOMMENDED_SRCSET_DENSITY_CAP}x - which makes them unnecessary for most use cases. Images that will be pinch-zoomed are typically the primary use case for ${ABSOLUTE_SRCSET_DENSITY_CAP}x images. Please remove the high density descriptor and try again.`);
  }
}
function postInitInputChangeError(dir, inputName) {
  let reason;
  if (inputName === "width" || inputName === "height") {
    reason = `Changing \`${inputName}\` may result in different attribute value applied to the underlying image element and cause layout shifts on a page.`;
  } else {
    reason = `Changing the \`${inputName}\` would have no effect on the underlying image element, because the resource loading has already occurred.`;
  }
  return new RuntimeError(2953, `${imgDirectiveDetails(dir.ngSrc)} \`${inputName}\` was updated after initialization. The NgOptimizedImage directive will not react to this input change. ${reason} To fix this, either switch \`${inputName}\` to a static value or wrap the image element in an *ngIf that is gated on the necessary value.`);
}
function assertNoPostInitInputChange(dir, changes, inputs) {
  inputs.forEach((input2) => {
    const isUpdated = changes.hasOwnProperty(input2);
    if (isUpdated && !changes[input2].isFirstChange()) {
      if (input2 === "ngSrc") {
        dir = {
          ngSrc: changes[input2].previousValue
        };
      }
      throw postInitInputChangeError(dir, input2);
    }
  });
}
function assertGreaterThanZero(dir, inputValue, inputName) {
  const validNumber = typeof inputValue === "number" && inputValue > 0;
  const validString = typeof inputValue === "string" && /^\d+$/.test(inputValue.trim()) && parseInt(inputValue) > 0;
  if (!validNumber && !validString) {
    throw new RuntimeError(2952, `${imgDirectiveDetails(dir.ngSrc)} \`${inputName}\` has an invalid value. To fix this, provide \`${inputName}\` as a number greater than 0.`);
  }
}
function assertNoImageDistortion(dir, img, renderer) {
  const removeLoadListenerFn = renderer.listen(img, "load", () => {
    removeLoadListenerFn();
    removeErrorListenerFn();
    const computedStyle = window.getComputedStyle(img);
    let renderedWidth = parseFloat(computedStyle.getPropertyValue("width"));
    let renderedHeight = parseFloat(computedStyle.getPropertyValue("height"));
    const boxSizing = computedStyle.getPropertyValue("box-sizing");
    if (boxSizing === "border-box") {
      const paddingTop = computedStyle.getPropertyValue("padding-top");
      const paddingRight = computedStyle.getPropertyValue("padding-right");
      const paddingBottom = computedStyle.getPropertyValue("padding-bottom");
      const paddingLeft = computedStyle.getPropertyValue("padding-left");
      renderedWidth -= parseFloat(paddingRight) + parseFloat(paddingLeft);
      renderedHeight -= parseFloat(paddingTop) + parseFloat(paddingBottom);
    }
    const renderedAspectRatio = renderedWidth / renderedHeight;
    const nonZeroRenderedDimensions = renderedWidth !== 0 && renderedHeight !== 0;
    const intrinsicWidth = img.naturalWidth;
    const intrinsicHeight = img.naturalHeight;
    const intrinsicAspectRatio = intrinsicWidth / intrinsicHeight;
    const suppliedWidth = dir.width;
    const suppliedHeight = dir.height;
    const suppliedAspectRatio = suppliedWidth / suppliedHeight;
    const inaccurateDimensions = Math.abs(suppliedAspectRatio - intrinsicAspectRatio) > ASPECT_RATIO_TOLERANCE;
    const stylingDistortion = nonZeroRenderedDimensions && Math.abs(intrinsicAspectRatio - renderedAspectRatio) > ASPECT_RATIO_TOLERANCE;
    if (inaccurateDimensions) {
      console.warn(formatRuntimeError(2952, `${imgDirectiveDetails(dir.ngSrc)} the aspect ratio of the image does not match the aspect ratio indicated by the width and height attributes. 
Intrinsic image size: ${intrinsicWidth}w x ${intrinsicHeight}h (aspect-ratio: ${round(intrinsicAspectRatio)}). 
Supplied width and height attributes: ${suppliedWidth}w x ${suppliedHeight}h (aspect-ratio: ${round(suppliedAspectRatio)}). 
To fix this, update the width and height attributes.`));
    } else if (stylingDistortion) {
      console.warn(formatRuntimeError(2952, `${imgDirectiveDetails(dir.ngSrc)} the aspect ratio of the rendered image does not match the image's intrinsic aspect ratio. 
Intrinsic image size: ${intrinsicWidth}w x ${intrinsicHeight}h (aspect-ratio: ${round(intrinsicAspectRatio)}). 
Rendered image size: ${renderedWidth}w x ${renderedHeight}h (aspect-ratio: ${round(renderedAspectRatio)}). 
This issue can occur if "width" and "height" attributes are added to an image without updating the corresponding image styling. To fix this, adjust image styling. In most cases, adding "height: auto" or "width: auto" to the image styling will fix this issue.`));
    } else if (!dir.ngSrcset && nonZeroRenderedDimensions) {
      const recommendedWidth = RECOMMENDED_SRCSET_DENSITY_CAP * renderedWidth;
      const recommendedHeight = RECOMMENDED_SRCSET_DENSITY_CAP * renderedHeight;
      const oversizedWidth = intrinsicWidth - recommendedWidth >= OVERSIZED_IMAGE_TOLERANCE2;
      const oversizedHeight = intrinsicHeight - recommendedHeight >= OVERSIZED_IMAGE_TOLERANCE2;
      if (oversizedWidth || oversizedHeight) {
        console.warn(formatRuntimeError(2960, `${imgDirectiveDetails(dir.ngSrc)} the intrinsic image is significantly larger than necessary. 
Rendered image size: ${renderedWidth}w x ${renderedHeight}h. 
Intrinsic image size: ${intrinsicWidth}w x ${intrinsicHeight}h. 
Recommended intrinsic image size: ${recommendedWidth}w x ${recommendedHeight}h. 
Note: Recommended intrinsic image size is calculated assuming a maximum DPR of ${RECOMMENDED_SRCSET_DENSITY_CAP}. To improve loading time, resize the image or consider using the "ngSrcset" and "sizes" attributes.`));
      }
    }
  });
  const removeErrorListenerFn = renderer.listen(img, "error", () => {
    removeLoadListenerFn();
    removeErrorListenerFn();
  });
}
function assertNonEmptyWidthAndHeight(dir) {
  let missingAttributes = [];
  if (dir.width === void 0) missingAttributes.push("width");
  if (dir.height === void 0) missingAttributes.push("height");
  if (missingAttributes.length > 0) {
    throw new RuntimeError(2954, `${imgDirectiveDetails(dir.ngSrc)} these required attributes are missing: ${missingAttributes.map((attr) => `"${attr}"`).join(", ")}. Including "width" and "height" attributes will prevent image-related layout shifts. To fix this, include "width" and "height" attributes on the image tag or turn on "fill" mode with the \`fill\` attribute.`);
  }
}
function assertEmptyWidthAndHeight(dir) {
  if (dir.width || dir.height) {
    throw new RuntimeError(2952, `${imgDirectiveDetails(dir.ngSrc)} the attributes \`height\` and/or \`width\` are present along with the \`fill\` attribute. Because \`fill\` mode causes an image to fill its containing element, the size attributes have no effect and should be removed.`);
  }
}
function assertNonZeroRenderedHeight(dir, img, renderer) {
  const removeLoadListenerFn = renderer.listen(img, "load", () => {
    removeLoadListenerFn();
    removeErrorListenerFn();
    const renderedHeight = img.clientHeight;
    if (dir.fill && renderedHeight === 0) {
      console.warn(formatRuntimeError(2952, `${imgDirectiveDetails(dir.ngSrc)} the height of the fill-mode image is zero. This is likely because the containing element does not have the CSS 'position' property set to one of the following: "relative", "fixed", or "absolute". To fix this problem, make sure the container element has the CSS 'position' property defined and the height of the element is not zero.`));
    }
  });
  const removeErrorListenerFn = renderer.listen(img, "error", () => {
    removeLoadListenerFn();
    removeErrorListenerFn();
  });
}
function assertValidLoadingInput(dir) {
  if (dir.loading && dir.priority) {
    throw new RuntimeError(2952, `${imgDirectiveDetails(dir.ngSrc)} the \`loading\` attribute was used on an image that was marked "priority". Setting \`loading\` on priority images is not allowed because these images will always be eagerly loaded. To fix this, remove the “loading” attribute from the priority image.`);
  }
  const validInputs = ["auto", "eager", "lazy"];
  if (typeof dir.loading === "string" && !validInputs.includes(dir.loading)) {
    throw new RuntimeError(2952, `${imgDirectiveDetails(dir.ngSrc)} the \`loading\` attribute has an invalid value (\`${dir.loading}\`). To fix this, provide a valid value ("lazy", "eager", or "auto").`);
  }
}
function assertNotMissingBuiltInLoader(ngSrc, imageLoader) {
  if (imageLoader === noopImageLoader) {
    let builtInLoaderName = "";
    for (const loader of BUILT_IN_LOADERS) {
      if (loader.testUrl(ngSrc)) {
        builtInLoaderName = loader.name;
        break;
      }
    }
    if (builtInLoaderName) {
      console.warn(formatRuntimeError(2962, `NgOptimizedImage: It looks like your images may be hosted on the ${builtInLoaderName} CDN, but your app is not using Angular's built-in loader for that CDN. We recommend switching to use the built-in by calling \`provide${builtInLoaderName}Loader()\` in your \`providers\` and passing it your instance's base URL. If you don't want to use the built-in loader, define a custom loader function using IMAGE_LOADER to silence this warning.`));
    }
  }
}
function assertNoNgSrcsetWithoutLoader(dir, imageLoader) {
  if (dir.ngSrcset && imageLoader === noopImageLoader) {
    console.warn(formatRuntimeError(2963, `${imgDirectiveDetails(dir.ngSrc)} the \`ngSrcset\` attribute is present but no image loader is configured (i.e. the default one is being used), which would result in the same image being used for all configured sizes. To fix this, provide a loader or remove the \`ngSrcset\` attribute from the image.`));
  }
}
function assertNoLoaderParamsWithoutLoader(dir, imageLoader) {
  if (dir.loaderParams && imageLoader === noopImageLoader) {
    console.warn(formatRuntimeError(2963, `${imgDirectiveDetails(dir.ngSrc)} the \`loaderParams\` attribute is present but no image loader is configured (i.e. the default one is being used), which means that the loaderParams data will not be consumed and will not affect the URL. To fix this, provide a custom loader or remove the \`loaderParams\` attribute from the image.`));
  }
}
function assetPriorityCountBelowThreshold(appRef) {
  return __async(this, null, function* () {
    if (IMGS_WITH_PRIORITY_ATTR_COUNT === 0) {
      IMGS_WITH_PRIORITY_ATTR_COUNT++;
      yield whenStable(appRef);
      if (IMGS_WITH_PRIORITY_ATTR_COUNT > PRIORITY_COUNT_THRESHOLD) {
        console.warn(formatRuntimeError(2966, `NgOptimizedImage: The "priority" attribute is set to true more than ${PRIORITY_COUNT_THRESHOLD} times (${IMGS_WITH_PRIORITY_ATTR_COUNT} times). Marking too many images as "high" priority can hurt your application's LCP (https://web.dev/lcp). "Priority" should only be set on the image expected to be the page's LCP element.`));
      }
    } else {
      IMGS_WITH_PRIORITY_ATTR_COUNT++;
    }
  });
}
function assertPlaceholderDimensions(dir, imgElement) {
  const computedStyle = window.getComputedStyle(imgElement);
  let renderedWidth = parseFloat(computedStyle.getPropertyValue("width"));
  let renderedHeight = parseFloat(computedStyle.getPropertyValue("height"));
  if (renderedWidth > PLACEHOLDER_DIMENSION_LIMIT || renderedHeight > PLACEHOLDER_DIMENSION_LIMIT) {
    console.warn(formatRuntimeError(2967, `${imgDirectiveDetails(dir.ngSrc)} it uses a placeholder image, but at least one of the dimensions attribute (height or width) exceeds the limit of ${PLACEHOLDER_DIMENSION_LIMIT}px. To fix this, use a smaller image as a placeholder.`));
  }
}
function round(input2) {
  return Number.isInteger(input2) ? input2 : input2.toFixed(2);
}
function unwrapSafeUrl(value) {
  if (typeof value === "string") {
    return value;
  }
  return unwrapSafeValue(value);
}
function booleanOrUrlAttribute(value) {
  if (typeof value === "string" && value !== "true" && value !== "false" && value !== "") {
    return value;
  }
  return booleanAttribute(value);
}

// node_modules/@mindfiredigital/pivothead-angular/dist/fesm2022/mindfiredigital-pivothead-angular.mjs
var _c0 = ["pivotElement"];
var _c1 = [[["", "slot", "header"]], [["", "slot", "body"]]];
var _c2 = ["[slot='header']", "[slot='body']"];
var _c3 = () => ({});
function PivotHeadComponent_ng_container_2_div_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 5);
    ɵɵelementContainer(1, 6);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(2);
    ɵɵadvance();
    ɵɵproperty("ngTemplateOutlet", ctx_r0.headerTemplate);
  }
}
function PivotHeadComponent_ng_container_2_div_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 7);
    ɵɵelementContainer(1, 6);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(2);
    ɵɵadvance();
    ɵɵproperty("ngTemplateOutlet", ctx_r0.bodyTemplate);
  }
}
function PivotHeadComponent_ng_container_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵtemplate(1, PivotHeadComponent_ng_container_2_div_1_Template, 2, 1, "div", 3);
    ɵɵprojection(2);
    ɵɵtemplate(3, PivotHeadComponent_ng_container_2_div_3_Template, 2, 1, "div", 4);
    ɵɵprojection(4, 1);
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r0.headerTemplate);
    ɵɵadvance(2);
    ɵɵproperty("ngIf", ctx_r0.bodyTemplate);
  }
}
function toJsonAttr(value) {
  try {
    return JSON.stringify(value);
  } catch {
    return void 0;
  }
}
var PivotHeadComponent = class _PivotHeadComponent {
  elementRef;
  // Inputs matching React props
  mode = "default";
  className;
  classAttr;
  hostStyle;
  styleAttr;
  data;
  options;
  filters;
  pagination;
  // Template inputs for minimal mode slots
  headerTemplate;
  bodyTemplate;
  // Event outputs
  stateChange = new EventEmitter();
  viewModeChange = new EventEmitter();
  paginationChange = new EventEmitter();
  // Track last known pagination to emit changes when state changes
  lastPagination;
  // Track when the custom element is defined to avoid setter shadowing
  elDefined = false;
  elDefinedPromise = null;
  upgradePromise;
  // Ensure the web component is defined only in the browser
  ensureElementDefined() {
    return __async(this, null, function* () {
      try {
        if (typeof window === "undefined") return;
        if (typeof customElements === "undefined") return;
        if (customElements.get("pivot-head")) return;
        yield import("./pivot-head-2VQXMX42.js");
      } catch {
      }
    });
  }
  whenElDefined() {
    if (this.elDefined) return Promise.resolve();
    if (!this.elDefinedPromise) {
      this.elDefinedPromise = (typeof customElements !== "undefined" ? customElements.whenDefined("pivot-head") : Promise.resolve()).then(() => {
        this.elDefined = true;
        this.upgradeElementProperties();
        this.syncPropsToElement();
        this.schedulePaginationSync();
      });
    }
    return this.elDefinedPromise;
  }
  upgradeElementProperties() {
    const el = this.el;
    if (!el) return;
    const props = ["data", "options", "filters", "pagination"];
    for (const prop of props) {
      if (Object.prototype.hasOwnProperty.call(el, prop)) {
        const value = el[prop];
        delete el[prop];
        el[prop] = value;
      }
    }
  }
  // Computed attributes for the custom element
  get dataAttr() {
    return this.data !== void 0 ? toJsonAttr(this.data) : void 0;
  }
  get optionsAttr() {
    return this.options !== void 0 ? toJsonAttr(this.options) : void 0;
  }
  get filtersAttr() {
    return this.filters !== void 0 ? toJsonAttr(this.filters) : void 0;
  }
  get paginationAttr() {
    return this.pagination !== void 0 ? toJsonAttr(this.pagination) : void 0;
  }
  // Expose the underlying element
  get el() {
    return this.elementRef?.nativeElement || null;
  }
  // Expose methods from the web component via a grouped object (parity with React)
  get methods() {
    const el = this.el;
    return {
      getState: () => el?.getState?.(),
      refresh: () => el?.refresh?.(),
      sort: (f, d) => el?.sort?.(f, d),
      setMeasures: (m) => el?.setMeasures?.(m),
      setDimensions: (d) => el?.setDimensions?.(d),
      setGroupConfig: (c) => el?.setGroupConfig?.(c),
      getFilters: () => el?.getFilters?.(),
      getPagination: () => el?.getPagination?.(),
      getData: () => el?.getData?.(),
      getProcessedData: () => el?.getProcessedData?.(),
      // Format-related methods
      formatValue: (value, field) => el?.formatValue?.(value, field),
      updateFieldFormatting: (field, format) => el?.updateFieldFormatting?.(field, format),
      getFieldAlignment: (field) => el?.getFieldAlignment?.(field),
      showFormatPopup: () => el?.showFormatPopup?.(),
      getGroupedData: () => el?.getGroupedData?.(),
      swapRows: (from, to) => el?.swapRows?.(from, to),
      swapColumns: (from, to) => el?.swapColumns?.(from, to),
      previousPage: () => el?.previousPage?.(),
      nextPage: () => el?.nextPage?.(),
      setPageSize: (s) => el?.setPageSize?.(s),
      goToPage: (p) => el?.goToPage?.(p),
      setViewMode: (m) => el?.setViewMode?.(m),
      getViewMode: () => el?.getViewMode?.(),
      exportToHTML: (n) => el?.exportToHTML?.(n),
      exportToPDF: (n) => el?.exportToPDF?.(n),
      exportToExcel: (n) => el?.exportToExcel?.(n),
      openPrintDialog: () => el?.openPrintDialog?.()
    };
  }
  // Convenience: expose direct method wrappers for Angular consumers
  getState() {
    return this.el?.getState?.();
  }
  refresh() {
    this.el?.refresh?.();
  }
  sort(field, direction) {
    this.el?.sort?.(field, direction);
  }
  setMeasures(measures) {
    this.el?.setMeasures?.(measures);
  }
  setDimensions(dimensions) {
    this.el?.setDimensions?.(dimensions);
  }
  setGroupConfig(config) {
    this.el?.setGroupConfig?.(config);
  }
  getFilters() {
    return this.el?.getFilters?.();
  }
  getPagination() {
    return this.el?.getPagination?.();
  }
  getData() {
    return this.el?.getData?.();
  }
  getProcessedData() {
    return this.el?.getProcessedData?.();
  }
  formatValue(value, field) {
    return this.el?.formatValue?.(value, field);
  }
  updateFieldFormatting(field, format) {
    this.el?.updateFieldFormatting?.(field, format);
  }
  getFieldAlignment(field) {
    return this.el?.getFieldAlignment?.(field);
  }
  showFormatPopup() {
    this.el?.showFormatPopup?.();
  }
  getGroupedData() {
    return this.el?.getGroupedData?.();
  }
  swapRows(fromIndex, toIndex) {
    this.el?.swapRows?.(fromIndex, toIndex);
  }
  swapColumns(fromIndex, toIndex) {
    this.el?.swapColumns?.(fromIndex, toIndex);
  }
  previousPage() {
    this.el?.previousPage?.();
  }
  nextPage() {
    this.el?.nextPage?.();
  }
  setPageSize(size) {
    this.el?.setPageSize?.(size);
  }
  goToPage(page) {
    this.el?.goToPage?.(page);
  }
  setViewMode(mode) {
    this.el?.setViewMode?.(mode);
  }
  getViewMode() {
    return this.el?.getViewMode?.();
  }
  exportToHTML(fileName) {
    this.el?.exportToHTML?.(fileName);
  }
  exportToPDF(fileName) {
    this.el?.exportToPDF?.(fileName);
  }
  exportToExcel(fileName) {
    this.el?.exportToExcel?.(fileName);
  }
  openPrintDialog() {
    this.el?.openPrintDialog?.();
  }
  ngAfterViewInit() {
    return __async(this, null, function* () {
      yield this.ensureElementDefined();
      this.setupEventListeners();
      this.ensureUpgradeAndSync();
      this.emitInitialPagination();
    });
  }
  ngOnInit() {
  }
  ngOnChanges() {
    if (this.el) {
      this.ensureUpgradeAndSync();
      this.schedulePaginationSync();
    }
  }
  ngOnDestroy() {
    this.removeEventListeners();
  }
  setupEventListeners() {
    const el = this.el;
    if (!el) return;
    el.addEventListener("stateChange", this.handleStateChange);
    el.addEventListener("viewModeChange", this.handleViewModeChange);
    el.addEventListener("paginationChange", this.handlePaginationChange);
  }
  removeEventListeners() {
    const el = this.el;
    if (!el) return;
    el.removeEventListener("stateChange", this.handleStateChange);
    el.removeEventListener("viewModeChange", this.handleViewModeChange);
    el.removeEventListener("paginationChange", this.handlePaginationChange);
  }
  handleStateChange = (event) => {
    const customEvent = event;
    this.stateChange.emit(customEvent.detail);
    this.schedulePaginationSync();
  };
  handleViewModeChange = (event) => {
    const customEvent = event;
    this.viewModeChange.emit(customEvent.detail);
  };
  handlePaginationChange = (event) => {
    const customEvent = event;
    if (customEvent?.detail) {
      this.lastPagination = customEvent.detail;
    }
    this.paginationChange.emit(customEvent.detail);
  };
  syncPropsToElement() {
    const el = this.el;
    if (!el) return;
    if (this.mode !== void 0) {
      el.setAttribute("mode", this.mode);
    }
    const isDefined = typeof customElements !== "undefined" && !!customElements.get("pivot-head");
    if (!isDefined) return;
    if (this.data !== void 0) {
      el.data = this.data;
    }
    if (this.options !== void 0) {
      el.options = this.options;
    }
    if (this.filters !== void 0) {
      el.filters = this.filters;
    }
    if (this.pagination !== void 0) {
      el.pagination = __spreadValues(__spreadValues({}, el.pagination || {
        currentPage: 1,
        pageSize: 10,
        totalPages: 1
      }), this.pagination);
    }
  }
  ensureUpgradeAndSync() {
    const el = this.el;
    if (!el) return;
    if (this.mode !== void 0) {
      el.setAttribute("mode", this.mode);
    }
    const hasCE = typeof customElements !== "undefined";
    if (!hasCE) {
      return;
    }
    if (customElements.get("pivot-head")) {
      ["data", "options", "filters", "pagination"].forEach((k) => {
        if (Object.prototype.hasOwnProperty.call(el, k)) {
          try {
            delete el[k];
          } catch (e) {
          }
        }
      });
      this.syncPropsToElement();
      return;
    }
    if (!this.upgradePromise) {
      this.upgradePromise = customElements.whenDefined("pivot-head").then(() => {
        ["data", "options", "filters", "pagination"].forEach((k) => {
          if (Object.prototype.hasOwnProperty.call(el, k)) {
            try {
              delete el[k];
            } catch (e) {
            }
          }
        });
        this.syncPropsToElement();
      });
    }
  }
  emitInitialPagination() {
    try {
      const current = this.el?.getPagination?.();
      if (current) {
        this.lastPagination = current;
        this.paginationChange.emit(current);
      }
    } catch {
    }
  }
  emitPaginationIfChanged() {
    const el = this.el;
    if (!el) return;
    try {
      const pag = el.getPagination?.();
      if (!pag) return;
      const last = this.lastPagination;
      if (!last || last.currentPage !== pag.currentPage || last.pageSize !== pag.pageSize || last.totalPages !== pag.totalPages) {
        this.lastPagination = pag;
        this.paginationChange.emit(pag);
      }
    } catch {
    }
  }
  schedulePaginationSync() {
    Promise.resolve().then(() => this.emitPaginationIfChanged());
  }
  static ɵfac = function PivotHeadComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _PivotHeadComponent)();
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _PivotHeadComponent,
    selectors: [["pivot-head-angular"]],
    viewQuery: function PivotHeadComponent_Query(rf, ctx) {
      if (rf & 1) {
        ɵɵviewQuery(_c0, 5, ElementRef);
      }
      if (rf & 2) {
        let _t;
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.elementRef = _t.first);
      }
    },
    inputs: {
      mode: "mode",
      className: "className",
      classAttr: [0, "class", "classAttr"],
      hostStyle: "hostStyle",
      styleAttr: [0, "style", "styleAttr"],
      data: "data",
      options: "options",
      filters: "filters",
      pagination: "pagination",
      headerTemplate: "headerTemplate",
      bodyTemplate: "bodyTemplate"
    },
    outputs: {
      stateChange: "stateChange",
      viewModeChange: "viewModeChange",
      paginationChange: "paginationChange"
    },
    features: [ɵɵNgOnChangesFeature],
    ngContentSelectors: _c2,
    decls: 3,
    vars: 10,
    consts: [["pivotElement", ""], [3, "ngStyle"], [4, "ngIf"], ["slot", "header", 4, "ngIf"], ["slot", "body", 4, "ngIf"], ["slot", "header"], [3, "ngTemplateOutlet"], ["slot", "body"]],
    template: function PivotHeadComponent_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵprojectionDef(_c1);
        ɵɵelementStart(0, "pivot-head", 1, 0);
        ɵɵtemplate(2, PivotHeadComponent_ng_container_2_Template, 5, 2, "ng-container", 2);
        ɵɵelementEnd();
      }
      if (rf & 2) {
        ɵɵclassMap(ctx.className || ctx.classAttr || "");
        ɵɵproperty("ngStyle", ctx.hostStyle || ctx.styleAttr || ɵɵpureFunction0(9, _c3));
        ɵɵattribute("mode", ctx.mode)("data", ctx.dataAttr)("options", ctx.optionsAttr)("filters", ctx.filtersAttr)("pagination", ctx.paginationAttr);
        ɵɵadvance(2);
        ɵɵproperty("ngIf", ctx.mode === "minimal");
      }
    },
    dependencies: [NgIf, NgTemplateOutlet, NgStyle],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PivotHeadComponent, [{
    type: Component,
    args: [{
      selector: "pivot-head-angular",
      template: `
    <pivot-head
      #pivotElement
      [attr.mode]="mode"
      [attr.data]="dataAttr"
      [attr.options]="optionsAttr"
      [attr.filters]="filtersAttr"
      [attr.pagination]="paginationAttr"
      [class]="className || classAttr || ''"
      [ngStyle]="hostStyle || styleAttr || {}"
    >
      <ng-container *ngIf="mode === 'minimal'">
        <div *ngIf="headerTemplate" slot="header">
          <ng-container [ngTemplateOutlet]="headerTemplate"></ng-container>
        </div>
        <ng-content select="[slot='header']"></ng-content>
        <div *ngIf="bodyTemplate" slot="body">
          <ng-container [ngTemplateOutlet]="bodyTemplate"></ng-container>
        </div>
        <ng-content select="[slot='body']"></ng-content>
      </ng-container>
    </pivot-head>
  `
    }]
  }], null, {
    elementRef: [{
      type: ViewChild,
      args: ["pivotElement", {
        static: false,
        read: ElementRef
      }]
    }],
    mode: [{
      type: Input
    }],
    className: [{
      type: Input
    }],
    classAttr: [{
      type: Input,
      args: ["class"]
    }],
    hostStyle: [{
      type: Input
    }],
    styleAttr: [{
      type: Input,
      args: ["style"]
    }],
    data: [{
      type: Input
    }],
    options: [{
      type: Input
    }],
    filters: [{
      type: Input
    }],
    pagination: [{
      type: Input
    }],
    headerTemplate: [{
      type: Input
    }],
    bodyTemplate: [{
      type: Input
    }],
    stateChange: [{
      type: Output
    }],
    viewModeChange: [{
      type: Output
    }],
    paginationChange: [{
      type: Output
    }]
  });
})();
var PivotHeadDirective = class _PivotHeadDirective {
  elementRef;
  // Inputs matching React props
  mode = "default";
  data;
  options;
  filters;
  pagination;
  // Event outputs
  stateChange = new EventEmitter();
  viewModeChange = new EventEmitter();
  paginationChange = new EventEmitter();
  // Track last known pagination to emit changes when state changes
  lastPagination;
  constructor(elementRef) {
    this.elementRef = elementRef;
  }
  // Resolve the underlying web component element irrespective of host
  get el() {
    const host = this.elementRef?.nativeElement;
    if (!host) return null;
    if (host.tagName === "PIVOT-HEAD") return host;
    const child = host.querySelector?.("pivot-head");
    return child || null;
  }
  // Expose methods from the web component
  get methods() {
    const el = this.el;
    return {
      getState: () => el?.getState?.(),
      refresh: () => el?.refresh?.(),
      sort: (f, d) => el?.sort?.(f, d),
      setMeasures: (m) => el?.setMeasures?.(m),
      setDimensions: (d) => el?.setDimensions?.(d),
      setGroupConfig: (c) => el?.setGroupConfig?.(c),
      getFilters: () => el?.getFilters?.(),
      getPagination: () => el?.getPagination?.(),
      getData: () => el?.getData?.(),
      getProcessedData: () => el?.getProcessedData?.(),
      // Format-related methods
      formatValue: (value, field) => el?.formatValue?.(value, field),
      updateFieldFormatting: (field, format) => el?.updateFieldFormatting?.(field, format),
      getFieldAlignment: (field) => el?.getFieldAlignment?.(field),
      showFormatPopup: () => el?.showFormatPopup?.(),
      getGroupedData: () => el?.getGroupedData?.(),
      swapRows: (from, to) => el?.swapRows?.(from, to),
      swapColumns: (from, to) => el?.swapColumns?.(from, to),
      previousPage: () => el?.previousPage?.(),
      nextPage: () => el?.nextPage?.(),
      setPageSize: (s) => el?.setPageSize?.(s),
      goToPage: (p) => el?.goToPage?.(p),
      setViewMode: (m) => el?.setViewMode?.(m),
      getViewMode: () => el?.getViewMode?.(),
      exportToHTML: (n) => el?.exportToHTML?.(n),
      exportToPDF: (n) => el?.exportToPDF?.(n),
      exportToExcel: (n) => el?.exportToExcel?.(n),
      openPrintDialog: () => el?.openPrintDialog?.()
    };
  }
  // Convenience direct wrappers
  getState() {
    return this.el?.getState?.();
  }
  refresh() {
    this.el?.refresh?.();
  }
  sort(field, direction) {
    this.el?.sort?.(field, direction);
  }
  setMeasures(measures) {
    this.el?.setMeasures?.(measures);
  }
  setDimensions(dimensions) {
    this.el?.setDimensions?.(dimensions);
  }
  setGroupConfig(config) {
    this.el?.setGroupConfig?.(config);
  }
  getFilters() {
    return this.el?.getFilters?.();
  }
  getPagination() {
    return this.el?.getPagination?.();
  }
  getData() {
    return this.el?.getData?.();
  }
  getProcessedData() {
    return this.el?.getProcessedData?.();
  }
  formatValue(value, field) {
    return this.el?.formatValue?.(value, field);
  }
  updateFieldFormatting(field, format) {
    this.el?.updateFieldFormatting?.(field, format);
  }
  getFieldAlignment(field) {
    return this.el?.getFieldAlignment?.(field);
  }
  showFormatPopup() {
    this.el?.showFormatPopup?.();
  }
  getGroupedData() {
    return this.el?.getGroupedData?.();
  }
  swapRows(fromIndex, toIndex) {
    this.el?.swapRows?.(fromIndex, toIndex);
  }
  swapColumns(fromIndex, toIndex) {
    this.el?.swapColumns?.(fromIndex, toIndex);
  }
  previousPage() {
    this.el?.previousPage?.();
  }
  nextPage() {
    this.el?.nextPage?.();
  }
  setPageSize(size) {
    this.el?.setPageSize?.(size);
  }
  goToPage(page) {
    this.el?.goToPage?.(page);
  }
  setViewMode(mode) {
    this.el?.setViewMode?.(mode);
  }
  getViewMode() {
    return this.el?.getViewMode?.();
  }
  exportToHTML(fileName) {
    this.el?.exportToHTML?.(fileName);
  }
  exportToPDF(fileName) {
    this.el?.exportToPDF?.(fileName);
  }
  exportToExcel(fileName) {
    this.el?.exportToExcel?.(fileName);
  }
  openPrintDialog() {
    this.el?.openPrintDialog?.();
  }
  ensureElementDefined() {
    return __async(this, null, function* () {
      try {
        if (typeof window === "undefined") return;
        if (typeof customElements === "undefined") return;
        if (customElements.get("pivot-head")) return;
        yield import("./pivot-head-2VQXMX42.js");
      } catch {
      }
    });
  }
  ngOnInit() {
    return __async(this, null, function* () {
      yield this.ensureElementDefined();
      this.setupEventListeners();
      this.syncPropsToElement();
      this.emitInitialPagination();
    });
  }
  ngOnChanges() {
    if (this.el) {
      this.syncPropsToElement();
      this.schedulePaginationSync();
    }
  }
  ngOnDestroy() {
    this.removeEventListeners();
  }
  setupEventListeners() {
    const el = this.el;
    if (!el) return;
    el.addEventListener("stateChange", this.handleStateChange);
    el.addEventListener("viewModeChange", this.handleViewModeChange);
    el.addEventListener("paginationChange", this.handlePaginationChange);
  }
  removeEventListeners() {
    const el = this.el;
    if (!el) return;
    el.removeEventListener("stateChange", this.handleStateChange);
    el.removeEventListener("viewModeChange", this.handleViewModeChange);
    el.removeEventListener("paginationChange", this.handlePaginationChange);
  }
  handleStateChange = (event) => {
    const customEvent = event;
    this.stateChange.emit(customEvent.detail);
    this.schedulePaginationSync();
  };
  handleViewModeChange = (event) => {
    const customEvent = event;
    this.viewModeChange.emit(customEvent.detail);
  };
  handlePaginationChange = (event) => {
    const customEvent = event;
    if (customEvent?.detail) {
      this.lastPagination = customEvent.detail;
    }
    this.paginationChange.emit(customEvent.detail);
  };
  syncPropsToElement() {
    const el = this.el;
    if (!el) return;
    if (this.mode !== void 0) {
      el.setAttribute("mode", this.mode);
    }
    if (this.data !== void 0) {
      const dataAttr = toJsonAttr(this.data);
      if (dataAttr) el.setAttribute("data", dataAttr);
      if (typeof customElements !== "undefined" && customElements.get("pivot-head")) {
        el.data = this.data;
      }
    } else {
      el.removeAttribute("data");
    }
    if (this.options !== void 0) {
      const optionsAttr = toJsonAttr(this.options);
      if (optionsAttr) el.setAttribute("options", optionsAttr);
      if (typeof customElements !== "undefined" && customElements.get("pivot-head")) {
        el.options = this.options;
      }
    } else {
      el.removeAttribute("options");
    }
    if (this.filters !== void 0) {
      const filtersAttr = toJsonAttr(this.filters);
      if (filtersAttr) el.setAttribute("filters", filtersAttr);
      if (typeof customElements !== "undefined" && customElements.get("pivot-head")) {
        el.filters = this.filters;
      }
    } else {
      el.removeAttribute("filters");
    }
    if (this.pagination !== void 0) {
      const paginationAttr = toJsonAttr(this.pagination);
      if (paginationAttr) el.setAttribute("pagination", paginationAttr);
      if (typeof customElements !== "undefined" && customElements.get("pivot-head")) {
        el.pagination = __spreadValues(__spreadValues({}, el.pagination || {
          currentPage: 1,
          pageSize: 10,
          totalPages: 1
        }), this.pagination);
      }
    } else {
      el.removeAttribute("pagination");
    }
  }
  emitInitialPagination() {
    try {
      const current = this.el?.getPagination?.();
      if (current) {
        this.lastPagination = current;
        this.paginationChange.emit(current);
      }
    } catch {
    }
  }
  emitPaginationIfChanged() {
    const el = this.el;
    if (!el) return;
    try {
      const pag = el.getPagination?.();
      if (!pag) return;
      const last = this.lastPagination;
      if (!last || last.currentPage !== pag.currentPage || last.pageSize !== pag.pageSize || last.totalPages !== pag.totalPages) {
        this.lastPagination = pag;
        this.paginationChange.emit(pag);
      }
    } catch {
    }
  }
  schedulePaginationSync() {
    Promise.resolve().then(() => this.emitPaginationIfChanged());
  }
  static ɵfac = function PivotHeadDirective_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _PivotHeadDirective)(ɵɵdirectiveInject(ElementRef));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _PivotHeadDirective,
    selectors: [["pivot-head", "pivotHeadDirective", ""], ["pivot-head-angular", "pivotHeadDirective", ""]],
    inputs: {
      mode: "mode",
      data: "data",
      options: "options",
      filters: "filters",
      pagination: "pagination"
    },
    outputs: {
      stateChange: "stateChange",
      viewModeChange: "viewModeChange",
      paginationChange: "paginationChange"
    },
    features: [ɵɵNgOnChangesFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PivotHeadDirective, [{
    type: Directive,
    args: [{
      selector: "pivot-head[pivotHeadDirective], pivot-head-angular[pivotHeadDirective]"
    }]
  }], () => [{
    type: ElementRef
  }], {
    mode: [{
      type: Input
    }],
    data: [{
      type: Input
    }],
    options: [{
      type: Input
    }],
    filters: [{
      type: Input
    }],
    pagination: [{
      type: Input
    }],
    stateChange: [{
      type: Output
    }],
    viewModeChange: [{
      type: Output
    }],
    paginationChange: [{
      type: Output
    }]
  });
})();
var PivotHeadService = class {
  /**
   * Validates pivot data format
   */
  validateData(data) {
    if (!Array.isArray(data)) return false;
    if (data.length === 0) return true;
    return data.every((item) => item !== null && typeof item === "object" && !Array.isArray(item));
  }
  /**
   * Extracts unique field names from data
   */
  getFieldNames(data) {
    if (!data.length) return [];
    const fieldSet = /* @__PURE__ */ new Set();
    data.forEach((record) => {
      Object.keys(record).forEach((key) => fieldSet.add(key));
    });
    return Array.from(fieldSet);
  }
  /**
   * Groups data by specified fields
   */
  groupDataBy(data, fields) {
    const groups = {};
    data.forEach((record) => {
      const groupKey = fields.map((field) => String(record[field] ?? "")).join("|");
      if (!groups[groupKey]) {
        groups[groupKey] = [];
      }
      groups[groupKey].push(record);
    });
    return groups;
  }
  /**
   * Calculates aggregate values for grouped data
   */
  calculateAggregates(data, field, aggregation = "sum") {
    if (!data.length) return 0;
    const values = data.map((record) => Number(record[field])).filter((val) => !isNaN(val));
    switch (aggregation) {
      case "sum":
        return values.reduce((sum, val) => sum + val, 0);
      case "avg":
        return values.length ? values.reduce((sum, val) => sum + val, 0) / values.length : 0;
      case "count":
        return values.length;
      case "min":
        return values.length ? Math.min(...values) : 0;
      case "max":
        return values.length ? Math.max(...values) : 0;
      default:
        return 0;
    }
  }
  /**
   * Creates format options for different data types
   */
  createFormatOptions(type, options) {
    const baseOptions = __spreadValues({
      type,
      decimals: 2,
      decimalSeparator: ".",
      thousandSeparator: ",",
      align: "right",
      nullValue: "-"
    }, options);
    switch (type) {
      case "currency":
        return __spreadProps(__spreadValues({}, baseOptions), {
          currency: "USD",
          currencyAlign: "left"
        });
      case "percentage":
        return __spreadProps(__spreadValues({}, baseOptions), {
          percent: true
        });
      case "date":
        return __spreadProps(__spreadValues({}, baseOptions), {
          align: "left",
          decimals: 0
        });
      default:
        return baseOptions;
    }
  }
  /**
   * Exports data to CSV format
   */
  exportToCsv(data, filename = "export.csv") {
    if (!data.length) return;
    const headers = Object.keys(data[0]);
    const csvContent = [headers.join(","), ...data.map((row) => headers.map((header) => {
      const value = row[header];
      return typeof value === "string" && value.includes(",") ? `"${value}"` : String(value ?? "");
    }).join(","))].join("\n");
    const blob = new Blob([csvContent], {
      type: "text/csv;charset=utf-8;"
    });
    const link = document.createElement("a");
    link.href = URL.createObjectURL(blob);
    link.download = filename;
    link.click();
    URL.revokeObjectURL(link.href);
  }
  /**
   * Filters data based on simple criteria
   */
  filterData(data, field, operator, value) {
    return data.filter((record) => {
      const recordValue = record[field];
      switch (operator) {
        case "equals":
          return String(recordValue) === String(value);
        case "contains":
          return String(recordValue).toLowerCase().includes(String(value).toLowerCase());
        case "greaterThan":
          return Number(recordValue) > Number(value);
        case "lessThan":
          return Number(recordValue) < Number(value);
        default:
          return true;
      }
    });
  }
};
__decorate([
  Injectable({
    providedIn: "root"
  })
  /**
   * Validates pivot data format
   */
], PivotHeadService.prototype, "validateData", null);
var PivotHeadModule = class _PivotHeadModule {
  static ɵfac = function PivotHeadModule_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _PivotHeadModule)();
  };
  static ɵmod = ɵɵdefineNgModule({
    type: _PivotHeadModule,
    declarations: [PivotHeadComponent, PivotHeadDirective],
    imports: [CommonModule],
    exports: [PivotHeadComponent, PivotHeadDirective]
  });
  static ɵinj = ɵɵdefineInjector({
    providers: [PivotHeadService],
    imports: [CommonModule]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PivotHeadModule, [{
    type: NgModule,
    args: [{
      declarations: [PivotHeadComponent, PivotHeadDirective],
      imports: [CommonModule],
      exports: [PivotHeadComponent, PivotHeadDirective],
      providers: [PivotHeadService],
      schemas: [CUSTOM_ELEMENTS_SCHEMA]
    }]
  }], null, null);
})();
export {
  PivotHeadComponent,
  PivotHeadDirective,
  PivotHeadModule,
  PivotHeadService
};
/*! Bundled license information:

@angular/core/fesm2022/primitives/signals.mjs:
  (**
   * @license Angular v18.2.0
   * (c) 2010-2024 Google LLC. https://angular.io/
   * License: MIT
   *)

@angular/core/fesm2022/primitives/event-dispatch.mjs:
  (**
   * @license Angular v18.2.0
   * (c) 2010-2024 Google LLC. https://angular.io/
   * License: MIT
   *)

@angular/core/fesm2022/core.mjs:
  (**
   * @license Angular v18.2.0
   * (c) 2010-2024 Google LLC. https://angular.io/
   * License: MIT
   *)

@angular/core/fesm2022/core.mjs:
  (*!
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   *)

@angular/core/fesm2022/core.mjs:
  (*!
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   *)

@angular/core/fesm2022/core.mjs:
  (*!
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   *)

@angular/core/fesm2022/core.mjs:
  (*!
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   *)

@angular/core/fesm2022/core.mjs:
  (*!
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   *)

@angular/common/fesm2022/common.mjs:
  (**
   * @license Angular v18.2.0
   * (c) 2010-2024 Google LLC. https://angular.io/
   * License: MIT
   *)
*/
//# sourceMappingURL=@mindfiredigital_pivothead-angular.js.map



================================================
FILE: .angular/cache/18.2.20/angular-pivothead-example/vite/deps/_metadata.json
================================================
{
  "hash": "7b960d5d",
  "configHash": "30aadff9",
  "lockfileHash": "5692903c",
  "browserHash": "239d4514",
  "optimized": {
    "@angular/common": {
      "src": "../../../../../../node_modules/@angular/common/fesm2022/common.mjs",
      "file": "@angular_common.js",
      "fileHash": "d960b56e",
      "needsInterop": false
    },
    "@angular/common/http": {
      "src": "../../../../../../node_modules/@angular/common/fesm2022/http.mjs",
      "file": "@angular_common_http.js",
      "fileHash": "82ce9055",
      "needsInterop": false
    },
    "@angular/core": {
      "src": "../../../../../../node_modules/@angular/core/fesm2022/core.mjs",
      "file": "@angular_core.js",
      "fileHash": "c08cc49d",
      "needsInterop": false
    },
    "@angular/core/primitives/event-dispatch": {
      "src": "../../../../../../node_modules/@angular/core/fesm2022/primitives/event-dispatch.mjs",
      "file": "@angular_core_primitives_event-dispatch.js",
      "fileHash": "ab34dbdd",
      "needsInterop": false
    },
    "@angular/core/primitives/signals": {
      "src": "../../../../../../node_modules/@angular/core/fesm2022/primitives/signals.mjs",
      "file": "@angular_core_primitives_signals.js",
      "fileHash": "86919d26",
      "needsInterop": false
    },
    "@mindfiredigital/pivothead-angular": {
      "src": "../../../../../../node_modules/@mindfiredigital/pivothead-angular/dist/fesm2022/mindfiredigital-pivothead-angular.mjs",
      "file": "@mindfiredigital_pivothead-angular.js",
      "fileHash": "ced208c0",
      "needsInterop": false
    },
    "rxjs": {
      "src": "../../../../../../node_modules/rxjs/dist/esm5/index.js",
      "file": "rxjs.js",
      "fileHash": "8d6d10ac",
      "needsInterop": false
    },
    "rxjs/operators": {
      "src": "../../../../../../node_modules/rxjs/dist/esm5/operators/index.js",
      "file": "rxjs_operators.js",
      "fileHash": "699bbebe",
      "needsInterop": false
    }
  },
  "chunks": {
    "html2canvas.esm-1a1724a1-JMHMFZKW": {
      "file": "html2canvas__esm-1a1724a1-JMHMFZKW.js"
    },
    "purify.es-78c333b1-RMLJBMGN": {
      "file": "purify__es-78c333b1-RMLJBMGN.js"
    },
    "index.es-980ec5f7-65FC5NO6": {
      "file": "index__es-980ec5f7-65FC5NO6.js"
    },
    "pivot-head-2VQXMX42": {
      "file": "pivot-head-2VQXMX42.js"
    },
    "chunk-JBLJVEST": {
      "file": "chunk-JBLJVEST.js"
    },
    "chunk-HB2ZDJCU": {
      "file": "chunk-HB2ZDJCU.js"
    },
    "chunk-2VVDJA4L": {
      "file": "chunk-2VVDJA4L.js"
    },
    "chunk-VKET2LIV": {
      "file": "chunk-VKET2LIV.js"
    },
    "chunk-HHOT2EEL": {
      "file": "chunk-HHOT2EEL.js"
    },
    "chunk-5NODSH2C": {
      "file": "chunk-5NODSH2C.js"
    },
    "chunk-LPUAGQXJ": {
      "file": "chunk-LPUAGQXJ.js"
    },
    "chunk-OVFEQSRS": {
      "file": "chunk-OVFEQSRS.js"
    },
    "chunk-WDMUDEB6": {
      "file": "chunk-WDMUDEB6.js"
    }
  }
}


================================================
FILE: .angular/cache/18.2.20/angular-pivothead-example/vite/deps/chunk-2VVDJA4L.js
================================================
import {
  Attribute,
  EventContract,
  EventContractContainer,
  EventDispatcher,
  clearAppScopedEarlyEventContract,
  getAppScopedQueuedEventInfos,
  getDefaulted,
  isCaptureEventType,
  isEarlyEventType,
  registerDispatcher$1
} from "./chunk-VKET2LIV.js";
import {
  REACTIVE_NODE,
  SIGNAL,
  SIGNAL_NODE,
  consumerAfterComputation,
  consumerBeforeComputation,
  consumerDestroy,
  consumerPollProducersForChange,
  createComputed,
  createSignal,
  createWatch,
  getActiveConsumer,
  producerAccessed,
  setActiveConsumer,
  setThrowInvalidWriteToSignalError,
  signalSetFn,
  signalUpdateFn
} from "./chunk-5NODSH2C.js";
import {
  BehaviorSubject,
  Subject,
  Subscription,
  first,
  map
} from "./chunk-OVFEQSRS.js";
import {
  __spreadProps,
  __spreadValues
} from "./chunk-WDMUDEB6.js";

// node_modules/@angular/core/fesm2022/core.mjs
var ERROR_DETAILS_PAGE_BASE_URL = "https://angular.dev/errors";
var XSS_SECURITY_URL = "https://g.co/ng/security#xss";
var RuntimeError = class extends Error {
  constructor(code, message) {
    super(formatRuntimeError(code, message));
    this.code = code;
  }
};
function formatRuntimeError(code, message) {
  const fullCode = `NG0${Math.abs(code)}`;
  let errorMessage = `${fullCode}${message ? ": " + message : ""}`;
  if (ngDevMode && code < 0) {
    const addPeriodSeparator = !errorMessage.match(/[.,;!?\n]$/);
    const separator = addPeriodSeparator ? "." : "";
    errorMessage = `${errorMessage}${separator} Find more at ${ERROR_DETAILS_PAGE_BASE_URL}/${fullCode}`;
  }
  return errorMessage;
}
var REQUIRED_UNSET_VALUE = Symbol("InputSignalNode#UNSET");
var INPUT_SIGNAL_NODE = (() => {
  return __spreadProps(__spreadValues({}, SIGNAL_NODE), {
    transformFn: void 0,
    applyValueToInputSignal(node, value) {
      signalSetFn(node, value);
    }
  });
})();
var ɵINPUT_SIGNAL_BRAND_READ_TYPE = Symbol();
var ɵINPUT_SIGNAL_BRAND_WRITE_TYPE = Symbol();
function createInputSignal(initialValue, options) {
  const node = Object.create(INPUT_SIGNAL_NODE);
  node.value = initialValue;
  node.transformFn = options?.transform;
  function inputValueFn() {
    producerAccessed(node);
    if (node.value === REQUIRED_UNSET_VALUE) {
      throw new RuntimeError(-950, ngDevMode && "Input is required but no value is available yet.");
    }
    return node.value;
  }
  inputValueFn[SIGNAL] = node;
  if (ngDevMode) {
    inputValueFn.toString = () => `[Input Signal: ${inputValueFn()}]`;
  }
  return inputValueFn;
}
function noSideEffects(fn) {
  return {
    toString: fn
  }.toString();
}
var ANNOTATIONS = "__annotations__";
var PARAMETERS = "__parameters__";
var PROP_METADATA = "__prop__metadata__";
function makeDecorator(name, props, parentClass, additionalProcessing, typeFn) {
  return noSideEffects(() => {
    const metaCtor = makeMetadataCtor(props);
    function DecoratorFactory(...args) {
      if (this instanceof DecoratorFactory) {
        metaCtor.call(this, ...args);
        return this;
      }
      const annotationInstance = new DecoratorFactory(...args);
      return function TypeDecorator(cls) {
        if (typeFn) typeFn(cls, ...args);
        const annotations = cls.hasOwnProperty(ANNOTATIONS) ? cls[ANNOTATIONS] : Object.defineProperty(cls, ANNOTATIONS, {
          value: []
        })[ANNOTATIONS];
        annotations.push(annotationInstance);
        if (additionalProcessing) additionalProcessing(cls);
        return cls;
      };
    }
    if (parentClass) {
      DecoratorFactory.prototype = Object.create(parentClass.prototype);
    }
    DecoratorFactory.prototype.ngMetadataName = name;
    DecoratorFactory.annotationCls = DecoratorFactory;
    return DecoratorFactory;
  });
}
function makeMetadataCtor(props) {
  return function ctor(...args) {
    if (props) {
      const values = props(...args);
      for (const propName in values) {
        this[propName] = values[propName];
      }
    }
  };
}
function makeParamDecorator(name, props, parentClass) {
  return noSideEffects(() => {
    const metaCtor = makeMetadataCtor(props);
    function ParamDecoratorFactory(...args) {
      if (this instanceof ParamDecoratorFactory) {
        metaCtor.apply(this, args);
        return this;
      }
      const annotationInstance = new ParamDecoratorFactory(...args);
      ParamDecorator.annotation = annotationInstance;
      return ParamDecorator;
      function ParamDecorator(cls, unusedKey, index) {
        const parameters = cls.hasOwnProperty(PARAMETERS) ? cls[PARAMETERS] : Object.defineProperty(cls, PARAMETERS, {
          value: []
        })[PARAMETERS];
        while (parameters.length <= index) {
          parameters.push(null);
        }
        (parameters[index] = parameters[index] || []).push(annotationInstance);
        return cls;
      }
    }
    if (parentClass) {
      ParamDecoratorFactory.prototype = Object.create(parentClass.prototype);
    }
    ParamDecoratorFactory.prototype.ngMetadataName = name;
    ParamDecoratorFactory.annotationCls = ParamDecoratorFactory;
    return ParamDecoratorFactory;
  });
}
function makePropDecorator(name, props, parentClass, additionalProcessing) {
  return noSideEffects(() => {
    const metaCtor = makeMetadataCtor(props);
    function PropDecoratorFactory(...args) {
      if (this instanceof PropDecoratorFactory) {
        metaCtor.apply(this, args);
        return this;
      }
      const decoratorInstance = new PropDecoratorFactory(...args);
      function PropDecorator(target, name2) {
        if (target === void 0) {
          throw new Error("Standard Angular field decorators are not supported in JIT mode.");
        }
        const constructor = target.constructor;
        const meta = constructor.hasOwnProperty(PROP_METADATA) ? constructor[PROP_METADATA] : Object.defineProperty(constructor, PROP_METADATA, {
          value: {}
        })[PROP_METADATA];
        meta[name2] = meta.hasOwnProperty(name2) && meta[name2] || [];
        meta[name2].unshift(decoratorInstance);
        if (additionalProcessing) additionalProcessing(target, name2, ...args);
      }
      return PropDecorator;
    }
    if (parentClass) {
      PropDecoratorFactory.prototype = Object.create(parentClass.prototype);
    }
    PropDecoratorFactory.prototype.ngMetadataName = name;
    PropDecoratorFactory.annotationCls = PropDecoratorFactory;
    return PropDecoratorFactory;
  });
}
var _global = globalThis;
function ngDevModeResetPerfCounters() {
  const locationString = typeof location !== "undefined" ? location.toString() : "";
  const newCounters = {
    namedConstructors: locationString.indexOf("ngDevMode=namedConstructors") != -1,
    firstCreatePass: 0,
    tNode: 0,
    tView: 0,
    rendererCreateTextNode: 0,
    rendererSetText: 0,
    rendererCreateElement: 0,
    rendererAddEventListener: 0,
    rendererSetAttribute: 0,
    rendererRemoveAttribute: 0,
    rendererSetProperty: 0,
    rendererSetClassName: 0,
    rendererAddClass: 0,
    rendererRemoveClass: 0,
    rendererSetStyle: 0,
    rendererRemoveStyle: 0,
    rendererDestroy: 0,
    rendererDestroyNode: 0,
    rendererMoveNode: 0,
    rendererRemoveNode: 0,
    rendererAppendChild: 0,
    rendererInsertBefore: 0,
    rendererCreateComment: 0,
    hydratedNodes: 0,
    hydratedComponents: 0,
    dehydratedViewsRemoved: 0,
    dehydratedViewsCleanupRuns: 0,
    componentsSkippedHydration: 0
  };
  const allowNgDevModeTrue = locationString.indexOf("ngDevMode=false") === -1;
  if (!allowNgDevModeTrue) {
    _global["ngDevMode"] = false;
  } else {
    if (typeof _global["ngDevMode"] !== "object") {
      _global["ngDevMode"] = {};
    }
    Object.assign(_global["ngDevMode"], newCounters);
  }
  return newCounters;
}
function initNgDevMode() {
  if (typeof ngDevMode === "undefined" || ngDevMode) {
    if (typeof ngDevMode !== "object" || Object.keys(ngDevMode).length === 0) {
      ngDevModeResetPerfCounters();
    }
    return typeof ngDevMode !== "undefined" && !!ngDevMode;
  }
  return false;
}
function getClosureSafeProperty(objWithPropertyToExtract) {
  for (let key in objWithPropertyToExtract) {
    if (objWithPropertyToExtract[key] === getClosureSafeProperty) {
      return key;
    }
  }
  throw Error("Could not find renamed property on target object.");
}
function fillProperties(target, source) {
  for (const key in source) {
    if (source.hasOwnProperty(key) && !target.hasOwnProperty(key)) {
      target[key] = source[key];
    }
  }
}
function stringify(token) {
  if (typeof token === "string") {
    return token;
  }
  if (Array.isArray(token)) {
    return "[" + token.map(stringify).join(", ") + "]";
  }
  if (token == null) {
    return "" + token;
  }
  if (token.overriddenName) {
    return `${token.overriddenName}`;
  }
  if (token.name) {
    return `${token.name}`;
  }
  const res = token.toString();
  if (res == null) {
    return "" + res;
  }
  const newLineIndex = res.indexOf("\n");
  return newLineIndex === -1 ? res : res.substring(0, newLineIndex);
}
function concatStringsWithSpace(before, after) {
  return before == null || before === "" ? after === null ? "" : after : after == null || after === "" ? before : before + " " + after;
}
function truncateMiddle(str, maxLength = 100) {
  if (!str || maxLength < 1 || str.length <= maxLength) return str;
  if (maxLength == 1) return str.substring(0, 1) + "...";
  const halfLimit = Math.round(maxLength / 2);
  return str.substring(0, halfLimit) + "..." + str.substring(str.length - halfLimit);
}
var __forward_ref__ = getClosureSafeProperty({
  __forward_ref__: getClosureSafeProperty
});
function forwardRef(forwardRefFn) {
  forwardRefFn.__forward_ref__ = forwardRef;
  forwardRefFn.toString = function() {
    return stringify(this());
  };
  return forwardRefFn;
}
function resolveForwardRef(type) {
  return isForwardRef(type) ? type() : type;
}
function isForwardRef(fn) {
  return typeof fn === "function" && fn.hasOwnProperty(__forward_ref__) && fn.__forward_ref__ === forwardRef;
}
function assertNumber(actual, msg) {
  if (!(typeof actual === "number")) {
    throwError(msg, typeof actual, "number", "===");
  }
}
function assertNumberInRange(actual, minInclusive, maxInclusive) {
  assertNumber(actual, "Expected a number");
  assertLessThanOrEqual(actual, maxInclusive, "Expected number to be less than or equal to");
  assertGreaterThanOrEqual(actual, minInclusive, "Expected number to be greater than or equal to");
}
function assertString(actual, msg) {
  if (!(typeof actual === "string")) {
    throwError(msg, actual === null ? "null" : typeof actual, "string", "===");
  }
}
function assertFunction(actual, msg) {
  if (!(typeof actual === "function")) {
    throwError(msg, actual === null ? "null" : typeof actual, "function", "===");
  }
}
function assertEqual(actual, expected, msg) {
  if (!(actual == expected)) {
    throwError(msg, actual, expected, "==");
  }
}
function assertNotEqual(actual, expected, msg) {
  if (!(actual != expected)) {
    throwError(msg, actual, expected, "!=");
  }
}
function assertSame(actual, expected, msg) {
  if (!(actual === expected)) {
    throwError(msg, actual, expected, "===");
  }
}
function assertNotSame(actual, expected, msg) {
  if (!(actual !== expected)) {
    throwError(msg, actual, expected, "!==");
  }
}
function assertLessThan(actual, expected, msg) {
  if (!(actual < expected)) {
    throwError(msg, actual, expected, "<");
  }
}
function assertLessThanOrEqual(actual, expected, msg) {
  if (!(actual <= expected)) {
    throwError(msg, actual, expected, "<=");
  }
}
function assertGreaterThan(actual, expected, msg) {
  if (!(actual > expected)) {
    throwError(msg, actual, expected, ">");
  }
}
function assertGreaterThanOrEqual(actual, expected, msg) {
  if (!(actual >= expected)) {
    throwError(msg, actual, expected, ">=");
  }
}
function assertDefined(actual, msg) {
  if (actual == null) {
    throwError(msg, actual, null, "!=");
  }
}
function throwError(msg, actual, expected, comparison) {
  throw new Error(`ASSERTION ERROR: ${msg}` + (comparison == null ? "" : ` [Expected=> ${expected} ${comparison} ${actual} <=Actual]`));
}
function assertDomNode(node) {
  if (!(node instanceof Node)) {
    throwError(`The provided value must be an instance of a DOM Node but got ${stringify(node)}`);
  }
}
function assertElement(node) {
  if (!(node instanceof Element)) {
    throwError(`The provided value must be an element but got ${stringify(node)}`);
  }
}
function assertIndexInRange(arr, index) {
  assertDefined(arr, "Array must be defined.");
  const maxLen = arr.length;
  if (index < 0 || index >= maxLen) {
    throwError(`Index expected to be less than ${maxLen} but got ${index}`);
  }
}
function assertOneOf(value, ...validValues) {
  if (validValues.indexOf(value) !== -1) return true;
  throwError(`Expected value to be one of ${JSON.stringify(validValues)} but was ${JSON.stringify(value)}.`);
}
function assertNotReactive(fn) {
  if (getActiveConsumer() !== null) {
    throwError(`${fn}() should never be called in a reactive context.`);
  }
}
function ɵɵdefineInjectable(opts) {
  return {
    token: opts.token,
    providedIn: opts.providedIn || null,
    factory: opts.factory,
    value: void 0
  };
}
var defineInjectable = ɵɵdefineInjectable;
function ɵɵdefineInjector(options) {
  return {
    providers: options.providers || [],
    imports: options.imports || []
  };
}
function getInjectableDef(type) {
  return getOwnDefinition(type, NG_PROV_DEF) || getOwnDefinition(type, NG_INJECTABLE_DEF);
}
function isInjectable(type) {
  return getInjectableDef(type) !== null;
}
function getOwnDefinition(type, field) {
  return type.hasOwnProperty(field) ? type[field] : null;
}
function getInheritedInjectableDef(type) {
  const def = type && (type[NG_PROV_DEF] || type[NG_INJECTABLE_DEF]);
  if (def) {
    ngDevMode && console.warn(`DEPRECATED: DI is instantiating a token "${type.name}" that inherits its @Injectable decorator but does not provide one itself.
This will become an error in a future version of Angular. Please add @Injectable() to the "${type.name}" class.`);
    return def;
  } else {
    return null;
  }
}
function getInjectorDef(type) {
  return type && (type.hasOwnProperty(NG_INJ_DEF) || type.hasOwnProperty(NG_INJECTOR_DEF)) ? type[NG_INJ_DEF] : null;
}
var NG_PROV_DEF = getClosureSafeProperty({
  ɵprov: getClosureSafeProperty
});
var NG_INJ_DEF = getClosureSafeProperty({
  ɵinj: getClosureSafeProperty
});
var NG_INJECTABLE_DEF = getClosureSafeProperty({
  ngInjectableDef: getClosureSafeProperty
});
var NG_INJECTOR_DEF = getClosureSafeProperty({
  ngInjectorDef: getClosureSafeProperty
});
var InjectionToken = class {
  /**
   * @param _desc   Description for the token,
   *                used only for debugging purposes,
   *                it should but does not need to be unique
   * @param options Options for the token's usage, as described above
   */
  constructor(_desc, options) {
    this._desc = _desc;
    this.ngMetadataName = "InjectionToken";
    this.ɵprov = void 0;
    if (typeof options == "number") {
      (typeof ngDevMode === "undefined" || ngDevMode) && assertLessThan(options, 0, "Only negative numbers are supported here");
      this.__NG_ELEMENT_ID__ = options;
    } else if (options !== void 0) {
      this.ɵprov = ɵɵdefineInjectable({
        token: this,
        providedIn: options.providedIn || "root",
        factory: options.factory
      });
    }
  }
  /**
   * @internal
   */
  get multi() {
    return this;
  }
  toString() {
    return `InjectionToken ${this._desc}`;
  }
};
var _injectorProfilerContext;
function getInjectorProfilerContext() {
  !ngDevMode && throwError("getInjectorProfilerContext should never be called in production mode");
  return _injectorProfilerContext;
}
function setInjectorProfilerContext(context) {
  !ngDevMode && throwError("setInjectorProfilerContext should never be called in production mode");
  const previous = _injectorProfilerContext;
  _injectorProfilerContext = context;
  return previous;
}
var injectorProfilerCallback = null;
var setInjectorProfiler = (injectorProfiler2) => {
  !ngDevMode && throwError("setInjectorProfiler should never be called in production mode");
  injectorProfilerCallback = injectorProfiler2;
};
function injectorProfiler(event) {
  !ngDevMode && throwError("Injector profiler should never be called in production mode");
  if (injectorProfilerCallback != null) {
    injectorProfilerCallback(event);
  }
}
function emitProviderConfiguredEvent(eventProvider, isViewProvider = false) {
  !ngDevMode && throwError("Injector profiler should never be called in production mode");
  let token;
  if (typeof eventProvider === "function") {
    token = eventProvider;
  } else if (eventProvider instanceof InjectionToken) {
    token = eventProvider;
  } else {
    token = resolveForwardRef(eventProvider.provide);
  }
  let provider = eventProvider;
  if (eventProvider instanceof InjectionToken) {
    provider = eventProvider.ɵprov || eventProvider;
  }
  injectorProfiler({
    type: 2,
    context: getInjectorProfilerContext(),
    providerRecord: {
      token,
      provider,
      isViewProvider
    }
  });
}
function emitInstanceCreatedByInjectorEvent(instance) {
  !ngDevMode && throwError("Injector profiler should never be called in production mode");
  injectorProfiler({
    type: 1,
    context: getInjectorProfilerContext(),
    instance: {
      value: instance
    }
  });
}
function emitInjectEvent(token, value, flags) {
  !ngDevMode && throwError("Injector profiler should never be called in production mode");
  injectorProfiler({
    type: 0,
    context: getInjectorProfilerContext(),
    service: {
      token,
      value,
      flags
    }
  });
}
function runInInjectorProfilerContext(injector, token, callback) {
  !ngDevMode && throwError("runInInjectorProfilerContext should never be called in production mode");
  const prevInjectContext = setInjectorProfilerContext({
    injector,
    token
  });
  try {
    callback();
  } finally {
    setInjectorProfilerContext(prevInjectContext);
  }
}
function isEnvironmentProviders(value) {
  return value && !!value.ɵproviders;
}
var NG_COMP_DEF = getClosureSafeProperty({
  ɵcmp: getClosureSafeProperty
});
var NG_DIR_DEF = getClosureSafeProperty({
  ɵdir: getClosureSafeProperty
});
var NG_PIPE_DEF = getClosureSafeProperty({
  ɵpipe: getClosureSafeProperty
});
var NG_MOD_DEF = getClosureSafeProperty({
  ɵmod: getClosureSafeProperty
});
var NG_FACTORY_DEF = getClosureSafeProperty({
  ɵfac: getClosureSafeProperty
});
var NG_ELEMENT_ID = getClosureSafeProperty({
  __NG_ELEMENT_ID__: getClosureSafeProperty
});
var NG_ENV_ID = getClosureSafeProperty({
  __NG_ENV_ID__: getClosureSafeProperty
});
function renderStringify(value) {
  if (typeof value === "string") return value;
  if (value == null) return "";
  return String(value);
}
function stringifyForError(value) {
  if (typeof value === "function") return value.name || value.toString();
  if (typeof value === "object" && value != null && typeof value.type === "function") {
    return value.type.name || value.type.toString();
  }
  return renderStringify(value);
}
function debugStringifyTypeForError(type) {
  let componentDef = type[NG_COMP_DEF] || null;
  if (componentDef !== null && componentDef.debugInfo) {
    return stringifyTypeFromDebugInfo(componentDef.debugInfo);
  }
  return stringifyForError(type);
}
function stringifyTypeFromDebugInfo(debugInfo) {
  if (!debugInfo.filePath || !debugInfo.lineNumber) {
    return debugInfo.className;
  } else {
    return `${debugInfo.className} (at ${debugInfo.filePath}:${debugInfo.lineNumber})`;
  }
}
function throwCyclicDependencyError(token, path) {
  const depPath = path ? `. Dependency path: ${path.join(" > ")} > ${token}` : "";
  throw new RuntimeError(-200, ngDevMode ? `Circular dependency in DI detected for ${token}${depPath}` : token);
}
function throwMixedMultiProviderError() {
  throw new Error(`Cannot mix multi providers and regular providers`);
}
function throwInvalidProviderError(ngModuleType, providers, provider) {
  if (ngModuleType && providers) {
    const providerDetail = providers.map((v) => v == provider ? "?" + provider + "?" : "...");
    throw new Error(`Invalid provider for the NgModule '${stringify(ngModuleType)}' - only instances of Provider and Type are allowed, got: [${providerDetail.join(", ")}]`);
  } else if (isEnvironmentProviders(provider)) {
    if (provider.ɵfromNgModule) {
      throw new RuntimeError(207, `Invalid providers from 'importProvidersFrom' present in a non-environment injector. 'importProvidersFrom' can't be used for component providers.`);
    } else {
      throw new RuntimeError(207, `Invalid providers present in a non-environment injector. 'EnvironmentProviders' can't be used for component providers.`);
    }
  } else {
    throw new Error("Invalid provider");
  }
}
function throwProviderNotFoundError(token, injectorName) {
  const errorMessage = ngDevMode && `No provider for ${stringifyForError(token)} found${injectorName ? ` in ${injectorName}` : ""}`;
  throw new RuntimeError(-201, errorMessage);
}
var InjectFlags;
(function(InjectFlags2) {
  InjectFlags2[InjectFlags2["Default"] = 0] = "Default";
  InjectFlags2[InjectFlags2["Host"] = 1] = "Host";
  InjectFlags2[InjectFlags2["Self"] = 2] = "Self";
  InjectFlags2[InjectFlags2["SkipSelf"] = 4] = "SkipSelf";
  InjectFlags2[InjectFlags2["Optional"] = 8] = "Optional";
})(InjectFlags || (InjectFlags = {}));
var _injectImplementation;
function getInjectImplementation() {
  return _injectImplementation;
}
function setInjectImplementation(impl) {
  const previous = _injectImplementation;
  _injectImplementation = impl;
  return previous;
}
function injectRootLimpMode(token, notFoundValue, flags) {
  const injectableDef = getInjectableDef(token);
  if (injectableDef && injectableDef.providedIn == "root") {
    return injectableDef.value === void 0 ? injectableDef.value = injectableDef.factory() : injectableDef.value;
  }
  if (flags & InjectFlags.Optional) return null;
  if (notFoundValue !== void 0) return notFoundValue;
  throwProviderNotFoundError(token, "Injector");
}
function assertInjectImplementationNotEqual(fn) {
  ngDevMode && assertNotEqual(_injectImplementation, fn, "Calling ɵɵinject would cause infinite recursion");
}
var _THROW_IF_NOT_FOUND = {};
var THROW_IF_NOT_FOUND = _THROW_IF_NOT_FOUND;
var DI_DECORATOR_FLAG = "__NG_DI_FLAG__";
var NG_TEMP_TOKEN_PATH = "ngTempTokenPath";
var NG_TOKEN_PATH = "ngTokenPath";
var NEW_LINE = /\n/gm;
var NO_NEW_LINE = "ɵ";
var SOURCE = "__source";
var _currentInjector = void 0;
function getCurrentInjector() {
  return _currentInjector;
}
function setCurrentInjector(injector) {
  const former = _currentInjector;
  _currentInjector = injector;
  return former;
}
function injectInjectorOnly(token, flags = InjectFlags.Default) {
  if (_currentInjector === void 0) {
    throw new RuntimeError(-203, ngDevMode && `inject() must be called from an injection context such as a constructor, a factory function, a field initializer, or a function used with \`runInInjectionContext\`.`);
  } else if (_currentInjector === null) {
    return injectRootLimpMode(token, void 0, flags);
  } else {
    const value = _currentInjector.get(token, flags & InjectFlags.Optional ? null : void 0, flags);
    ngDevMode && emitInjectEvent(token, value, flags);
    return value;
  }
}
function ɵɵinject(token, flags = InjectFlags.Default) {
  return (getInjectImplementation() || injectInjectorOnly)(resolveForwardRef(token), flags);
}
function ɵɵinvalidFactoryDep(index) {
  throw new RuntimeError(202, ngDevMode && `This constructor is not compatible with Angular Dependency Injection because its dependency at index ${index} of the parameter list is invalid.
This can happen if the dependency type is a primitive like a string or if an ancestor of this class is missing an Angular decorator.

Please check that 1) the type for the parameter at index ${index} is correct and 2) the correct Angular decorators are defined for this class and its ancestors.`);
}
function inject(token, flags = InjectFlags.Default) {
  return ɵɵinject(token, convertToBitFlags(flags));
}
function convertToBitFlags(flags) {
  if (typeof flags === "undefined" || typeof flags === "number") {
    return flags;
  }
  return 0 | // comment to force a line break in the formatter
  (flags.optional && 8) | (flags.host && 1) | (flags.self && 2) | (flags.skipSelf && 4);
}
function injectArgs(types) {
  const args = [];
  for (let i = 0; i < types.length; i++) {
    const arg = resolveForwardRef(types[i]);
    if (Array.isArray(arg)) {
      if (arg.length === 0) {
        throw new RuntimeError(900, ngDevMode && "Arguments array must have arguments.");
      }
      let type = void 0;
      let flags = InjectFlags.Default;
      for (let j = 0; j < arg.length; j++) {
        const meta = arg[j];
        const flag = getInjectFlag(meta);
        if (typeof flag === "number") {
          if (flag === -1) {
            type = meta.token;
          } else {
            flags |= flag;
          }
        } else {
          type = meta;
        }
      }
      args.push(ɵɵinject(type, flags));
    } else {
      args.push(ɵɵinject(arg));
    }
  }
  return args;
}
function attachInjectFlag(decorator, flag) {
  decorator[DI_DECORATOR_FLAG] = flag;
  decorator.prototype[DI_DECORATOR_FLAG] = flag;
  return decorator;
}
function getInjectFlag(token) {
  return token[DI_DECORATOR_FLAG];
}
function catchInjectorError(e, token, injectorErrorName, source) {
  const tokenPath = e[NG_TEMP_TOKEN_PATH];
  if (token[SOURCE]) {
    tokenPath.unshift(token[SOURCE]);
  }
  e.message = formatError("\n" + e.message, tokenPath, injectorErrorName, source);
  e[NG_TOKEN_PATH] = tokenPath;
  e[NG_TEMP_TOKEN_PATH] = null;
  throw e;
}
function formatError(text, obj, injectorErrorName, source = null) {
  text = text && text.charAt(0) === "\n" && text.charAt(1) == NO_NEW_LINE ? text.slice(2) : text;
  let context = stringify(obj);
  if (Array.isArray(obj)) {
    context = obj.map(stringify).join(" -> ");
  } else if (typeof obj === "object") {
    let parts = [];
    for (let key in obj) {
      if (obj.hasOwnProperty(key)) {
        let value = obj[key];
        parts.push(key + ":" + (typeof value === "string" ? JSON.stringify(value) : stringify(value)));
      }
    }
    context = `{${parts.join(", ")}}`;
  }
  return `${injectorErrorName}${source ? "(" + source + ")" : ""}[${context}]: ${text.replace(NEW_LINE, "\n  ")}`;
}
var Inject = attachInjectFlag(
  // Disable tslint because `DecoratorFlags` is a const enum which gets inlined.
  makeParamDecorator("Inject", (token) => ({
    token
  })),
  -1
  /* DecoratorFlags.Inject */
);
var Optional = (
  // Disable tslint because `InternalInjectFlags` is a const enum which gets inlined.
  // tslint:disable-next-line: no-toplevel-property-access
  attachInjectFlag(
    makeParamDecorator("Optional"),
    8
    /* InternalInjectFlags.Optional */
  )
);
var Self = (
  // Disable tslint because `InternalInjectFlags` is a const enum which gets inlined.
  // tslint:disable-next-line: no-toplevel-property-access
  attachInjectFlag(
    makeParamDecorator("Self"),
    2
    /* InternalInjectFlags.Self */
  )
);
var SkipSelf = (
  // Disable tslint because `InternalInjectFlags` is a const enum which gets inlined.
  // tslint:disable-next-line: no-toplevel-property-access
  attachInjectFlag(
    makeParamDecorator("SkipSelf"),
    4
    /* InternalInjectFlags.SkipSelf */
  )
);
var Host = (
  // Disable tslint because `InternalInjectFlags` is a const enum which gets inlined.
  // tslint:disable-next-line: no-toplevel-property-access
  attachInjectFlag(
    makeParamDecorator("Host"),
    1
    /* InternalInjectFlags.Host */
  )
);
function getFactoryDef(type, throwNotFound) {
  const hasFactoryDef = type.hasOwnProperty(NG_FACTORY_DEF);
  if (!hasFactoryDef && throwNotFound === true && ngDevMode) {
    throw new Error(`Type ${stringify(type)} does not have 'ɵfac' property.`);
  }
  return hasFactoryDef ? type[NG_FACTORY_DEF] : null;
}
function arrayEquals(a, b, identityAccessor) {
  if (a.length !== b.length) return false;
  for (let i = 0; i < a.length; i++) {
    let valueA = a[i];
    let valueB = b[i];
    if (identityAccessor) {
      valueA = identityAccessor(valueA);
      valueB = identityAccessor(valueB);
    }
    if (valueB !== valueA) {
      return false;
    }
  }
  return true;
}
function flatten(list) {
  return list.flat(Number.POSITIVE_INFINITY);
}
function deepForEach(input2, fn) {
  input2.forEach((value) => Array.isArray(value) ? deepForEach(value, fn) : fn(value));
}
function addToArray(arr, index, value) {
  if (index >= arr.length) {
    arr.push(value);
  } else {
    arr.splice(index, 0, value);
  }
}
function removeFromArray(arr, index) {
  if (index >= arr.length - 1) {
    return arr.pop();
  } else {
    return arr.splice(index, 1)[0];
  }
}
function newArray(size, value) {
  const list = [];
  for (let i = 0; i < size; i++) {
    list.push(value);
  }
  return list;
}
function arraySplice(array, index, count) {
  const length = array.length - count;
  while (index < length) {
    array[index] = array[index + count];
    index++;
  }
  while (count--) {
    array.pop();
  }
}
function arrayInsert2(array, index, value1, value2) {
  ngDevMode && assertLessThanOrEqual(index, array.length, "Can't insert past array end.");
  let end = array.length;
  if (end == index) {
    array.push(value1, value2);
  } else if (end === 1) {
    array.push(value2, array[0]);
    array[0] = value1;
  } else {
    end--;
    array.push(array[end - 1], array[end]);
    while (end > index) {
      const previousEnd = end - 2;
      array[end] = array[previousEnd];
      end--;
    }
    array[index] = value1;
    array[index + 1] = value2;
  }
}
function keyValueArraySet(keyValueArray, key, value) {
  let index = keyValueArrayIndexOf(keyValueArray, key);
  if (index >= 0) {
    keyValueArray[index | 1] = value;
  } else {
    index = ~index;
    arrayInsert2(keyValueArray, index, key, value);
  }
  return index;
}
function keyValueArrayGet(keyValueArray, key) {
  const index = keyValueArrayIndexOf(keyValueArray, key);
  if (index >= 0) {
    return keyValueArray[index | 1];
  }
  return void 0;
}
function keyValueArrayIndexOf(keyValueArray, key) {
  return _arrayIndexOfSorted(keyValueArray, key, 1);
}
function _arrayIndexOfSorted(array, value, shift) {
  ngDevMode && assertEqual(Array.isArray(array), true, "Expecting an array");
  let start = 0;
  let end = array.length >> shift;
  while (end !== start) {
    const middle = start + (end - start >> 1);
    const current = array[middle << shift];
    if (value === current) {
      return middle << shift;
    } else if (current > value) {
      end = middle;
    } else {
      start = middle + 1;
    }
  }
  return ~(end << shift);
}
var EMPTY_OBJ = {};
var EMPTY_ARRAY = [];
if ((typeof ngDevMode === "undefined" || ngDevMode) && initNgDevMode()) {
  Object.freeze(EMPTY_OBJ);
  Object.freeze(EMPTY_ARRAY);
}
var ENVIRONMENT_INITIALIZER = new InjectionToken(ngDevMode ? "ENVIRONMENT_INITIALIZER" : "");
var INJECTOR$1 = new InjectionToken(
  ngDevMode ? "INJECTOR" : "",
  // Disable tslint because this is const enum which gets inlined not top level prop access.
  // tslint:disable-next-line: no-toplevel-property-access
  -1
  /* InjectorMarkers.Injector */
);
var INJECTOR_DEF_TYPES = new InjectionToken(ngDevMode ? "INJECTOR_DEF_TYPES" : "");
var NullInjector = class {
  get(token, notFoundValue = THROW_IF_NOT_FOUND) {
    if (notFoundValue === THROW_IF_NOT_FOUND) {
      const error = new Error(`NullInjectorError: No provider for ${stringify(token)}!`);
      error.name = "NullInjectorError";
      throw error;
    }
    return notFoundValue;
  }
};
var ChangeDetectionStrategy;
(function(ChangeDetectionStrategy2) {
  ChangeDetectionStrategy2[ChangeDetectionStrategy2["OnPush"] = 0] = "OnPush";
  ChangeDetectionStrategy2[ChangeDetectionStrategy2["Default"] = 1] = "Default";
})(ChangeDetectionStrategy || (ChangeDetectionStrategy = {}));
var ViewEncapsulation$1;
(function(ViewEncapsulation2) {
  ViewEncapsulation2[ViewEncapsulation2["Emulated"] = 0] = "Emulated";
  ViewEncapsulation2[ViewEncapsulation2["None"] = 2] = "None";
  ViewEncapsulation2[ViewEncapsulation2["ShadowDom"] = 3] = "ShadowDom";
})(ViewEncapsulation$1 || (ViewEncapsulation$1 = {}));
var InputFlags;
(function(InputFlags2) {
  InputFlags2[InputFlags2["None"] = 0] = "None";
  InputFlags2[InputFlags2["SignalBased"] = 1] = "SignalBased";
  InputFlags2[InputFlags2["HasDecoratorInputTransform"] = 2] = "HasDecoratorInputTransform";
})(InputFlags || (InputFlags = {}));
function classIndexOf(className, classToSearch, startingIndex) {
  ngDevMode && assertNotEqual(classToSearch, "", 'can not look for "" string.');
  let end = className.length;
  while (true) {
    const foundIndex = className.indexOf(classToSearch, startingIndex);
    if (foundIndex === -1) return foundIndex;
    if (foundIndex === 0 || className.charCodeAt(foundIndex - 1) <= 32) {
      const length = classToSearch.length;
      if (foundIndex + length === end || className.charCodeAt(foundIndex + length) <= 32) {
        return foundIndex;
      }
    }
    startingIndex = foundIndex + 1;
  }
}
function setUpAttributes(renderer, native, attrs) {
  let i = 0;
  while (i < attrs.length) {
    const value = attrs[i];
    if (typeof value === "number") {
      if (value !== 0) {
        break;
      }
      i++;
      const namespaceURI = attrs[i++];
      const attrName = attrs[i++];
      const attrVal = attrs[i++];
      ngDevMode && ngDevMode.rendererSetAttribute++;
      renderer.setAttribute(native, attrName, attrVal, namespaceURI);
    } else {
      const attrName = value;
      const attrVal = attrs[++i];
      ngDevMode && ngDevMode.rendererSetAttribute++;
      if (isAnimationProp(attrName)) {
        renderer.setProperty(native, attrName, attrVal);
      } else {
        renderer.setAttribute(native, attrName, attrVal);
      }
      i++;
    }
  }
  return i;
}
function isNameOnlyAttributeMarker(marker) {
  return marker === 3 || marker === 4 || marker === 6;
}
function isAnimationProp(name) {
  return name.charCodeAt(0) === 64;
}
function mergeHostAttrs(dst, src) {
  if (src === null || src.length === 0) {
  } else if (dst === null || dst.length === 0) {
    dst = src.slice();
  } else {
    let srcMarker = -1;
    for (let i = 0; i < src.length; i++) {
      const item = src[i];
      if (typeof item === "number") {
        srcMarker = item;
      } else {
        if (srcMarker === 0) {
        } else if (srcMarker === -1 || srcMarker === 2) {
          mergeHostAttribute(dst, srcMarker, item, null, src[++i]);
        } else {
          mergeHostAttribute(dst, srcMarker, item, null, null);
        }
      }
    }
  }
  return dst;
}
function mergeHostAttribute(dst, marker, key1, key2, value) {
  let i = 0;
  let markerInsertPosition = dst.length;
  if (marker === -1) {
    markerInsertPosition = -1;
  } else {
    while (i < dst.length) {
      const dstValue = dst[i++];
      if (typeof dstValue === "number") {
        if (dstValue === marker) {
          markerInsertPosition = -1;
          break;
        } else if (dstValue > marker) {
          markerInsertPosition = i - 1;
          break;
        }
      }
    }
  }
  while (i < dst.length) {
    const item = dst[i];
    if (typeof item === "number") {
      break;
    } else if (item === key1) {
      if (key2 === null) {
        if (value !== null) {
          dst[i + 1] = value;
        }
        return;
      } else if (key2 === dst[i + 1]) {
        dst[i + 2] = value;
        return;
      }
    }
    i++;
    if (key2 !== null) i++;
    if (value !== null) i++;
  }
  if (markerInsertPosition !== -1) {
    dst.splice(markerInsertPosition, 0, marker);
    i = markerInsertPosition + 1;
  }
  dst.splice(i++, 0, key1);
  if (key2 !== null) {
    dst.splice(i++, 0, key2);
  }
  if (value !== null) {
    dst.splice(i++, 0, value);
  }
}
var NG_TEMPLATE_SELECTOR = "ng-template";
function isCssClassMatching(tNode, attrs, cssClassToMatch, isProjectionMode) {
  ngDevMode && assertEqual(cssClassToMatch, cssClassToMatch.toLowerCase(), "Class name expected to be lowercase.");
  let i = 0;
  if (isProjectionMode) {
    for (; i < attrs.length && typeof attrs[i] === "string"; i += 2) {
      if (attrs[i] === "class" && classIndexOf(attrs[i + 1].toLowerCase(), cssClassToMatch, 0) !== -1) {
        return true;
      }
    }
  } else if (isInlineTemplate(tNode)) {
    return false;
  }
  i = attrs.indexOf(1, i);
  if (i > -1) {
    let item;
    while (++i < attrs.length && typeof (item = attrs[i]) === "string") {
      if (item.toLowerCase() === cssClassToMatch) {
        return true;
      }
    }
  }
  return false;
}
function isInlineTemplate(tNode) {
  return tNode.type === 4 && tNode.value !== NG_TEMPLATE_SELECTOR;
}
function hasTagAndTypeMatch(tNode, currentSelector, isProjectionMode) {
  const tagNameToCompare = tNode.type === 4 && !isProjectionMode ? NG_TEMPLATE_SELECTOR : tNode.value;
  return currentSelector === tagNameToCompare;
}
function isNodeMatchingSelector(tNode, selector, isProjectionMode) {
  ngDevMode && assertDefined(selector[0], "Selector should have a tag name");
  let mode = 4;
  const nodeAttrs = tNode.attrs;
  const nameOnlyMarkerIdx = nodeAttrs !== null ? getNameOnlyMarkerIndex(nodeAttrs) : 0;
  let skipToNextSelector = false;
  for (let i = 0; i < selector.length; i++) {
    const current = selector[i];
    if (typeof current === "number") {
      if (!skipToNextSelector && !isPositive(mode) && !isPositive(current)) {
        return false;
      }
      if (skipToNextSelector && isPositive(current)) continue;
      skipToNextSelector = false;
      mode = current | mode & 1;
      continue;
    }
    if (skipToNextSelector) continue;
    if (mode & 4) {
      mode = 2 | mode & 1;
      if (current !== "" && !hasTagAndTypeMatch(tNode, current, isProjectionMode) || current === "" && selector.length === 1) {
        if (isPositive(mode)) return false;
        skipToNextSelector = true;
      }
    } else if (mode & 8) {
      if (nodeAttrs === null || !isCssClassMatching(tNode, nodeAttrs, current, isProjectionMode)) {
        if (isPositive(mode)) return false;
        skipToNextSelector = true;
      }
    } else {
      const selectorAttrValue = selector[++i];
      const attrIndexInNode = findAttrIndexInNode(current, nodeAttrs, isInlineTemplate(tNode), isProjectionMode);
      if (attrIndexInNode === -1) {
        if (isPositive(mode)) return false;
        skipToNextSelector = true;
        continue;
      }
      if (selectorAttrValue !== "") {
        let nodeAttrValue;
        if (attrIndexInNode > nameOnlyMarkerIdx) {
          nodeAttrValue = "";
        } else {
          ngDevMode && assertNotEqual(nodeAttrs[attrIndexInNode], 0, "We do not match directives on namespaced attributes");
          nodeAttrValue = nodeAttrs[attrIndexInNode + 1].toLowerCase();
        }
        if (mode & 2 && selectorAttrValue !== nodeAttrValue) {
          if (isPositive(mode)) return false;
          skipToNextSelector = true;
        }
      }
    }
  }
  return isPositive(mode) || skipToNextSelector;
}
function isPositive(mode) {
  return (mode & 1) === 0;
}
function findAttrIndexInNode(name, attrs, isInlineTemplate2, isProjectionMode) {
  if (attrs === null) return -1;
  let i = 0;
  if (isProjectionMode || !isInlineTemplate2) {
    let bindingsMode = false;
    while (i < attrs.length) {
      const maybeAttrName = attrs[i];
      if (maybeAttrName === name) {
        return i;
      } else if (maybeAttrName === 3 || maybeAttrName === 6) {
        bindingsMode = true;
      } else if (maybeAttrName === 1 || maybeAttrName === 2) {
        let value = attrs[++i];
        while (typeof value === "string") {
          value = attrs[++i];
        }
        continue;
      } else if (maybeAttrName === 4) {
        break;
      } else if (maybeAttrName === 0) {
        i += 4;
        continue;
      }
      i += bindingsMode ? 1 : 2;
    }
    return -1;
  } else {
    return matchTemplateAttribute(attrs, name);
  }
}
function isNodeMatchingSelectorList(tNode, selector, isProjectionMode = false) {
  for (let i = 0; i < selector.length; i++) {
    if (isNodeMatchingSelector(tNode, selector[i], isProjectionMode)) {
      return true;
    }
  }
  return false;
}
function getProjectAsAttrValue(tNode) {
  const nodeAttrs = tNode.attrs;
  if (nodeAttrs != null) {
    const ngProjectAsAttrIdx = nodeAttrs.indexOf(
      5
      /* AttributeMarker.ProjectAs */
    );
    if ((ngProjectAsAttrIdx & 1) === 0) {
      return nodeAttrs[ngProjectAsAttrIdx + 1];
    }
  }
  return null;
}
function getNameOnlyMarkerIndex(nodeAttrs) {
  for (let i = 0; i < nodeAttrs.length; i++) {
    const nodeAttr = nodeAttrs[i];
    if (isNameOnlyAttributeMarker(nodeAttr)) {
      return i;
    }
  }
  return nodeAttrs.length;
}
function matchTemplateAttribute(attrs, name) {
  let i = attrs.indexOf(
    4
    /* AttributeMarker.Template */
  );
  if (i > -1) {
    i++;
    while (i < attrs.length) {
      const attr = attrs[i];
      if (typeof attr === "number") return -1;
      if (attr === name) return i;
      i++;
    }
  }
  return -1;
}
function isSelectorInSelectorList(selector, list) {
  selectorListLoop: for (let i = 0; i < list.length; i++) {
    const currentSelectorInList = list[i];
    if (selector.length !== currentSelectorInList.length) {
      continue;
    }
    for (let j = 0; j < selector.length; j++) {
      if (selector[j] !== currentSelectorInList[j]) {
        continue selectorListLoop;
      }
    }
    return true;
  }
  return false;
}
function maybeWrapInNotSelector(isNegativeMode, chunk) {
  return isNegativeMode ? ":not(" + chunk.trim() + ")" : chunk;
}
function stringifyCSSSelector(selector) {
  let result = selector[0];
  let i = 1;
  let mode = 2;
  let currentChunk = "";
  let isNegativeMode = false;
  while (i < selector.length) {
    let valueOrMarker = selector[i];
    if (typeof valueOrMarker === "string") {
      if (mode & 2) {
        const attrValue = selector[++i];
        currentChunk += "[" + valueOrMarker + (attrValue.length > 0 ? '="' + attrValue + '"' : "") + "]";
      } else if (mode & 8) {
        currentChunk += "." + valueOrMarker;
      } else if (mode & 4) {
        currentChunk += " " + valueOrMarker;
      }
    } else {
      if (currentChunk !== "" && !isPositive(valueOrMarker)) {
        result += maybeWrapInNotSelector(isNegativeMode, currentChunk);
        currentChunk = "";
      }
      mode = valueOrMarker;
      isNegativeMode = isNegativeMode || !isPositive(mode);
    }
    i++;
  }
  if (currentChunk !== "") {
    result += maybeWrapInNotSelector(isNegativeMode, currentChunk);
  }
  return result;
}
function stringifyCSSSelectorList(selectorList) {
  return selectorList.map(stringifyCSSSelector).join(",");
}
function extractAttrsAndClassesFromSelector(selector) {
  const attrs = [];
  const classes = [];
  let i = 1;
  let mode = 2;
  while (i < selector.length) {
    let valueOrMarker = selector[i];
    if (typeof valueOrMarker === "string") {
      if (mode === 2) {
        if (valueOrMarker !== "") {
          attrs.push(valueOrMarker, selector[++i]);
        }
      } else if (mode === 8) {
        classes.push(valueOrMarker);
      }
    } else {
      if (!isPositive(mode)) break;
      mode = valueOrMarker;
    }
    i++;
  }
  return {
    attrs,
    classes
  };
}
function ɵɵdefineComponent(componentDefinition) {
  return noSideEffects(() => {
    (typeof ngDevMode === "undefined" || ngDevMode) && initNgDevMode();
    const baseDef = getNgDirectiveDef(componentDefinition);
    const def = __spreadProps(__spreadValues({}, baseDef), {
      decls: componentDefinition.decls,
      vars: componentDefinition.vars,
      template: componentDefinition.template,
      consts: componentDefinition.consts || null,
      ngContentSelectors: componentDefinition.ngContentSelectors,
      onPush: componentDefinition.changeDetection === ChangeDetectionStrategy.OnPush,
      directiveDefs: null,
      // assigned in noSideEffects
      pipeDefs: null,
      // assigned in noSideEffects
      dependencies: baseDef.standalone && componentDefinition.dependencies || null,
      getStandaloneInjector: null,
      signals: componentDefinition.signals ?? false,
      data: componentDefinition.data || {},
      encapsulation: componentDefinition.encapsulation || ViewEncapsulation$1.Emulated,
      styles: componentDefinition.styles || EMPTY_ARRAY,
      _: null,
      schemas: componentDefinition.schemas || null,
      tView: null,
      id: ""
    });
    initFeatures(def);
    const dependencies = componentDefinition.dependencies;
    def.directiveDefs = extractDefListOrFactory(
      dependencies,
      /* pipeDef */
      false
    );
    def.pipeDefs = extractDefListOrFactory(
      dependencies,
      /* pipeDef */
      true
    );
    def.id = getComponentId(def);
    return def;
  });
}
function extractDirectiveDef(type) {
  return getComponentDef(type) || getDirectiveDef(type);
}
function nonNull(value) {
  return value !== null;
}
function ɵɵdefineNgModule(def) {
  return noSideEffects(() => {
    const res = {
      type: def.type,
      bootstrap: def.bootstrap || EMPTY_ARRAY,
      declarations: def.declarations || EMPTY_ARRAY,
      imports: def.imports || EMPTY_ARRAY,
      exports: def.exports || EMPTY_ARRAY,
      transitiveCompileScopes: null,
      schemas: def.schemas || null,
      id: def.id || null
    };
    return res;
  });
}
function parseAndConvertBindingsForDefinition(obj, declaredInputs) {
  if (obj == null) return EMPTY_OBJ;
  const newLookup = {};
  for (const minifiedKey in obj) {
    if (obj.hasOwnProperty(minifiedKey)) {
      const value = obj[minifiedKey];
      let publicName;
      let declaredName;
      let inputFlags = InputFlags.None;
      if (Array.isArray(value)) {
        inputFlags = value[0];
        publicName = value[1];
        declaredName = value[2] ?? publicName;
      } else {
        publicName = value;
        declaredName = value;
      }
      if (declaredInputs) {
        newLookup[publicName] = inputFlags !== InputFlags.None ? [minifiedKey, inputFlags] : minifiedKey;
        declaredInputs[publicName] = declaredName;
      } else {
        newLookup[publicName] = minifiedKey;
      }
    }
  }
  return newLookup;
}
function ɵɵdefineDirective(directiveDefinition) {
  return noSideEffects(() => {
    const def = getNgDirectiveDef(directiveDefinition);
    initFeatures(def);
    return def;
  });
}
function ɵɵdefinePipe(pipeDef) {
  return {
    type: pipeDef.type,
    name: pipeDef.name,
    factory: null,
    pure: pipeDef.pure !== false,
    standalone: pipeDef.standalone === true,
    onDestroy: pipeDef.type.prototype.ngOnDestroy || null
  };
}
function getComponentDef(type) {
  return type[NG_COMP_DEF] || null;
}
function getDirectiveDef(type) {
  return type[NG_DIR_DEF] || null;
}
function getPipeDef$1(type) {
  return type[NG_PIPE_DEF] || null;
}
function isStandalone(type) {
  const def = getComponentDef(type) || getDirectiveDef(type) || getPipeDef$1(type);
  return def !== null ? def.standalone : false;
}
function getNgModuleDef(type, throwNotFound) {
  const ngModuleDef = type[NG_MOD_DEF] || null;
  if (!ngModuleDef && throwNotFound === true) {
    throw new Error(`Type ${stringify(type)} does not have 'ɵmod' property.`);
  }
  return ngModuleDef;
}
function getNgDirectiveDef(directiveDefinition) {
  const declaredInputs = {};
  return {
    type: directiveDefinition.type,
    providersResolver: null,
    factory: null,
    hostBindings: directiveDefinition.hostBindings || null,
    hostVars: directiveDefinition.hostVars || 0,
    hostAttrs: directiveDefinition.hostAttrs || null,
    contentQueries: directiveDefinition.contentQueries || null,
    declaredInputs,
    inputTransforms: null,
    inputConfig: directiveDefinition.inputs || EMPTY_OBJ,
    exportAs: directiveDefinition.exportAs || null,
    standalone: directiveDefinition.standalone === true,
    signals: directiveDefinition.signals === true,
    selectors: directiveDefinition.selectors || EMPTY_ARRAY,
    viewQuery: directiveDefinition.viewQuery || null,
    features: directiveDefinition.features || null,
    setInput: null,
    findHostDirectiveDefs: null,
    hostDirectives: null,
    inputs: parseAndConvertBindingsForDefinition(directiveDefinition.inputs, declaredInputs),
    outputs: parseAndConvertBindingsForDefinition(directiveDefinition.outputs),
    debugInfo: null
  };
}
function initFeatures(definition) {
  definition.features?.forEach((fn) => fn(definition));
}
function extractDefListOrFactory(dependencies, pipeDef) {
  if (!dependencies) {
    return null;
  }
  const defExtractor = pipeDef ? getPipeDef$1 : extractDirectiveDef;
  return () => (typeof dependencies === "function" ? dependencies() : dependencies).map((dep) => defExtractor(dep)).filter(nonNull);
}
var GENERATED_COMP_IDS = /* @__PURE__ */ new Map();
function getComponentId(componentDef) {
  let hash = 0;
  const hashSelectors = [
    componentDef.selectors,
    componentDef.ngContentSelectors,
    componentDef.hostVars,
    componentDef.hostAttrs,
    componentDef.consts,
    componentDef.vars,
    componentDef.decls,
    componentDef.encapsulation,
    componentDef.standalone,
    componentDef.signals,
    componentDef.exportAs,
    JSON.stringify(componentDef.inputs),
    JSON.stringify(componentDef.outputs),
    // We cannot use 'componentDef.type.name' as the name of the symbol will change and will not
    // match in the server and browser bundles.
    Object.getOwnPropertyNames(componentDef.type.prototype),
    !!componentDef.contentQueries,
    !!componentDef.viewQuery
  ].join("|");
  for (const char of hashSelectors) {
    hash = Math.imul(31, hash) + char.charCodeAt(0) << 0;
  }
  hash += 2147483647 + 1;
  const compId = "c" + hash;
  if (typeof ngDevMode === "undefined" || ngDevMode) {
    if (GENERATED_COMP_IDS.has(compId)) {
      const previousCompDefType = GENERATED_COMP_IDS.get(compId);
      if (previousCompDefType !== componentDef.type) {
        console.warn(formatRuntimeError(-912, `Component ID generation collision detected. Components '${previousCompDefType.name}' and '${componentDef.type.name}' with selector '${stringifyCSSSelectorList(componentDef.selectors)}' generated the same component ID. To fix this, you can change the selector of one of those components or add an extra host attribute to force a different ID.`));
      }
    } else {
      GENERATED_COMP_IDS.set(compId, componentDef.type);
    }
  }
  return compId;
}
function makeEnvironmentProviders(providers) {
  return {
    ɵproviders: providers
  };
}
function importProvidersFrom(...sources) {
  return {
    ɵproviders: internalImportProvidersFrom(true, sources),
    ɵfromNgModule: true
  };
}
function internalImportProvidersFrom(checkForStandaloneCmp, ...sources) {
  const providersOut = [];
  const dedup = /* @__PURE__ */ new Set();
  let injectorTypesWithProviders;
  const collectProviders = (provider) => {
    providersOut.push(provider);
  };
  deepForEach(sources, (source) => {
    if ((typeof ngDevMode === "undefined" || ngDevMode) && checkForStandaloneCmp) {
      const cmpDef = getComponentDef(source);
      if (cmpDef?.standalone) {
        throw new RuntimeError(800, `Importing providers supports NgModule or ModuleWithProviders but got a standalone component "${stringifyForError(source)}"`);
      }
    }
    const internalSource = source;
    if (walkProviderTree(internalSource, collectProviders, [], dedup)) {
      injectorTypesWithProviders ||= [];
      injectorTypesWithProviders.push(internalSource);
    }
  });
  if (injectorTypesWithProviders !== void 0) {
    processInjectorTypesWithProviders(injectorTypesWithProviders, collectProviders);
  }
  return providersOut;
}
function processInjectorTypesWithProviders(typesWithProviders, visitor) {
  for (let i = 0; i < typesWithProviders.length; i++) {
    const {
      ngModule,
      providers
    } = typesWithProviders[i];
    deepForEachProvider(providers, (provider) => {
      ngDevMode && validateProvider(provider, providers || EMPTY_ARRAY, ngModule);
      visitor(provider, ngModule);
    });
  }
}
function walkProviderTree(container, visitor, parents, dedup) {
  container = resolveForwardRef(container);
  if (!container) return false;
  let defType = null;
  let injDef = getInjectorDef(container);
  const cmpDef = !injDef && getComponentDef(container);
  if (!injDef && !cmpDef) {
    const ngModule = container.ngModule;
    injDef = getInjectorDef(ngModule);
    if (injDef) {
      defType = ngModule;
    } else {
      return false;
    }
  } else if (cmpDef && !cmpDef.standalone) {
    return false;
  } else {
    defType = container;
  }
  if (ngDevMode && parents.indexOf(defType) !== -1) {
    const defName = stringify(defType);
    const path = parents.map(stringify);
    throwCyclicDependencyError(defName, path);
  }
  const isDuplicate = dedup.has(defType);
  if (cmpDef) {
    if (isDuplicate) {
      return false;
    }
    dedup.add(defType);
    if (cmpDef.dependencies) {
      const deps = typeof cmpDef.dependencies === "function" ? cmpDef.dependencies() : cmpDef.dependencies;
      for (const dep of deps) {
        walkProviderTree(dep, visitor, parents, dedup);
      }
    }
  } else if (injDef) {
    if (injDef.imports != null && !isDuplicate) {
      ngDevMode && parents.push(defType);
      dedup.add(defType);
      let importTypesWithProviders;
      try {
        deepForEach(injDef.imports, (imported) => {
          if (walkProviderTree(imported, visitor, parents, dedup)) {
            importTypesWithProviders ||= [];
            importTypesWithProviders.push(imported);
          }
        });
      } finally {
        ngDevMode && parents.pop();
      }
      if (importTypesWithProviders !== void 0) {
        processInjectorTypesWithProviders(importTypesWithProviders, visitor);
      }
    }
    if (!isDuplicate) {
      const factory = getFactoryDef(defType) || (() => new defType());
      visitor({
        provide: defType,
        useFactory: factory,
        deps: EMPTY_ARRAY
      }, defType);
      visitor({
        provide: INJECTOR_DEF_TYPES,
        useValue: defType,
        multi: true
      }, defType);
      visitor({
        provide: ENVIRONMENT_INITIALIZER,
        useValue: () => ɵɵinject(defType),
        multi: true
      }, defType);
    }
    const defProviders = injDef.providers;
    if (defProviders != null && !isDuplicate) {
      const injectorType = container;
      deepForEachProvider(defProviders, (provider) => {
        ngDevMode && validateProvider(provider, defProviders, injectorType);
        visitor(provider, injectorType);
      });
    }
  } else {
    return false;
  }
  return defType !== container && container.providers !== void 0;
}
function validateProvider(provider, providers, containerType) {
  if (isTypeProvider(provider) || isValueProvider(provider) || isFactoryProvider(provider) || isExistingProvider(provider)) {
    return;
  }
  const classRef = resolveForwardRef(provider && (provider.useClass || provider.provide));
  if (!classRef) {
    throwInvalidProviderError(containerType, providers, provider);
  }
}
function deepForEachProvider(providers, fn) {
  for (let provider of providers) {
    if (isEnvironmentProviders(provider)) {
      provider = provider.ɵproviders;
    }
    if (Array.isArray(provider)) {
      deepForEachProvider(provider, fn);
    } else {
      fn(provider);
    }
  }
}
var USE_VALUE$1 = getClosureSafeProperty({
  provide: String,
  useValue: getClosureSafeProperty
});
function isValueProvider(value) {
  return value !== null && typeof value == "object" && USE_VALUE$1 in value;
}
function isExistingProvider(value) {
  return !!(value && value.useExisting);
}
function isFactoryProvider(value) {
  return !!(value && value.useFactory);
}
function isTypeProvider(value) {
  return typeof value === "function";
}
function isClassProvider(value) {
  return !!value.useClass;
}
var INJECTOR_SCOPE = new InjectionToken(ngDevMode ? "Set Injector scope." : "");
var NOT_YET = {};
var CIRCULAR = {};
var NULL_INJECTOR = void 0;
function getNullInjector() {
  if (NULL_INJECTOR === void 0) {
    NULL_INJECTOR = new NullInjector();
  }
  return NULL_INJECTOR;
}
var EnvironmentInjector = class {
};
var R3Injector = class extends EnvironmentInjector {
  /**
   * Flag indicating that this injector was previously destroyed.
   */
  get destroyed() {
    return this._destroyed;
  }
  constructor(providers, parent, source, scopes) {
    super();
    this.parent = parent;
    this.source = source;
    this.scopes = scopes;
    this.records = /* @__PURE__ */ new Map();
    this._ngOnDestroyHooks = /* @__PURE__ */ new Set();
    this._onDestroyHooks = [];
    this._destroyed = false;
    forEachSingleProvider(providers, (provider) => this.processProvider(provider));
    this.records.set(INJECTOR$1, makeRecord(void 0, this));
    if (scopes.has("environment")) {
      this.records.set(EnvironmentInjector, makeRecord(void 0, this));
    }
    const record = this.records.get(INJECTOR_SCOPE);
    if (record != null && typeof record.value === "string") {
      this.scopes.add(record.value);
    }
    this.injectorDefTypes = new Set(this.get(INJECTOR_DEF_TYPES, EMPTY_ARRAY, InjectFlags.Self));
  }
  /**
   * Destroy the injector and release references to every instance or provider associated with it.
   *
   * Also calls the `OnDestroy` lifecycle hooks of every instance that was created for which a
   * hook was found.
   */
  destroy() {
    this.assertNotDestroyed();
    this._destroyed = true;
    const prevConsumer = setActiveConsumer(null);
    try {
      for (const service of this._ngOnDestroyHooks) {
        service.ngOnDestroy();
      }
      const onDestroyHooks = this._onDestroyHooks;
      this._onDestroyHooks = [];
      for (const hook of onDestroyHooks) {
        hook();
      }
    } finally {
      this.records.clear();
      this._ngOnDestroyHooks.clear();
      this.injectorDefTypes.clear();
      setActiveConsumer(prevConsumer);
    }
  }
  onDestroy(callback) {
    this.assertNotDestroyed();
    this._onDestroyHooks.push(callback);
    return () => this.removeOnDestroy(callback);
  }
  runInContext(fn) {
    this.assertNotDestroyed();
    const previousInjector = setCurrentInjector(this);
    const previousInjectImplementation = setInjectImplementation(void 0);
    let prevInjectContext;
    if (ngDevMode) {
      prevInjectContext = setInjectorProfilerContext({
        injector: this,
        token: null
      });
    }
    try {
      return fn();
    } finally {
      setCurrentInjector(previousInjector);
      setInjectImplementation(previousInjectImplementation);
      ngDevMode && setInjectorProfilerContext(prevInjectContext);
    }
  }
  get(token, notFoundValue = THROW_IF_NOT_FOUND, flags = InjectFlags.Default) {
    this.assertNotDestroyed();
    if (token.hasOwnProperty(NG_ENV_ID)) {
      return token[NG_ENV_ID](this);
    }
    flags = convertToBitFlags(flags);
    let prevInjectContext;
    if (ngDevMode) {
      prevInjectContext = setInjectorProfilerContext({
        injector: this,
        token
      });
    }
    const previousInjector = setCurrentInjector(this);
    const previousInjectImplementation = setInjectImplementation(void 0);
    try {
      if (!(flags & InjectFlags.SkipSelf)) {
        let record = this.records.get(token);
        if (record === void 0) {
          const def = couldBeInjectableType(token) && getInjectableDef(token);
          if (def && this.injectableDefInScope(def)) {
            if (ngDevMode) {
              runInInjectorProfilerContext(this, token, () => {
                emitProviderConfiguredEvent(token);
              });
            }
            record = makeRecord(injectableDefOrInjectorDefFactory(token), NOT_YET);
          } else {
            record = null;
          }
          this.records.set(token, record);
        }
        if (record != null) {
          return this.hydrate(token, record);
        }
      }
      const nextInjector = !(flags & InjectFlags.Self) ? this.parent : getNullInjector();
      notFoundValue = flags & InjectFlags.Optional && notFoundValue === THROW_IF_NOT_FOUND ? null : notFoundValue;
      return nextInjector.get(token, notFoundValue);
    } catch (e) {
      if (e.name === "NullInjectorError") {
        const path = e[NG_TEMP_TOKEN_PATH] = e[NG_TEMP_TOKEN_PATH] || [];
        path.unshift(stringify(token));
        if (previousInjector) {
          throw e;
        } else {
          return catchInjectorError(e, token, "R3InjectorError", this.source);
        }
      } else {
        throw e;
      }
    } finally {
      setInjectImplementation(previousInjectImplementation);
      setCurrentInjector(previousInjector);
      ngDevMode && setInjectorProfilerContext(prevInjectContext);
    }
  }
  /** @internal */
  resolveInjectorInitializers() {
    const prevConsumer = setActiveConsumer(null);
    const previousInjector = setCurrentInjector(this);
    const previousInjectImplementation = setInjectImplementation(void 0);
    let prevInjectContext;
    if (ngDevMode) {
      prevInjectContext = setInjectorProfilerContext({
        injector: this,
        token: null
      });
    }
    try {
      const initializers = this.get(ENVIRONMENT_INITIALIZER, EMPTY_ARRAY, InjectFlags.Self);
      if (ngDevMode && !Array.isArray(initializers)) {
        throw new RuntimeError(-209, `Unexpected type of the \`ENVIRONMENT_INITIALIZER\` token value (expected an array, but got ${typeof initializers}). Please check that the \`ENVIRONMENT_INITIALIZER\` token is configured as a \`multi: true\` provider.`);
      }
      for (const initializer of initializers) {
        initializer();
      }
    } finally {
      setCurrentInjector(previousInjector);
      setInjectImplementation(previousInjectImplementation);
      ngDevMode && setInjectorProfilerContext(prevInjectContext);
      setActiveConsumer(prevConsumer);
    }
  }
  toString() {
    const tokens = [];
    const records = this.records;
    for (const token of records.keys()) {
      tokens.push(stringify(token));
    }
    return `R3Injector[${tokens.join(", ")}]`;
  }
  assertNotDestroyed() {
    if (this._destroyed) {
      throw new RuntimeError(205, ngDevMode && "Injector has already been destroyed.");
    }
  }
  /**
   * Process a `SingleProvider` and add it.
   */
  processProvider(provider) {
    provider = resolveForwardRef(provider);
    let token = isTypeProvider(provider) ? provider : resolveForwardRef(provider && provider.provide);
    const record = providerToRecord(provider);
    if (ngDevMode) {
      runInInjectorProfilerContext(this, token, () => {
        if (isValueProvider(provider)) {
          emitInstanceCreatedByInjectorEvent(provider.useValue);
        }
        emitProviderConfiguredEvent(provider);
      });
    }
    if (!isTypeProvider(provider) && provider.multi === true) {
      let multiRecord = this.records.get(token);
      if (multiRecord) {
        if (ngDevMode && multiRecord.multi === void 0) {
          throwMixedMultiProviderError();
        }
      } else {
        multiRecord = makeRecord(void 0, NOT_YET, true);
        multiRecord.factory = () => injectArgs(multiRecord.multi);
        this.records.set(token, multiRecord);
      }
      token = provider;
      multiRecord.multi.push(provider);
    } else {
      if (ngDevMode) {
        const existing = this.records.get(token);
        if (existing && existing.multi !== void 0) {
          throwMixedMultiProviderError();
        }
      }
    }
    this.records.set(token, record);
  }
  hydrate(token, record) {
    const prevConsumer = setActiveConsumer(null);
    try {
      if (ngDevMode && record.value === CIRCULAR) {
        throwCyclicDependencyError(stringify(token));
      } else if (record.value === NOT_YET) {
        record.value = CIRCULAR;
        if (ngDevMode) {
          runInInjectorProfilerContext(this, token, () => {
            record.value = record.factory();
            emitInstanceCreatedByInjectorEvent(record.value);
          });
        } else {
          record.value = record.factory();
        }
      }
      if (typeof record.value === "object" && record.value && hasOnDestroy(record.value)) {
        this._ngOnDestroyHooks.add(record.value);
      }
      return record.value;
    } finally {
      setActiveConsumer(prevConsumer);
    }
  }
  injectableDefInScope(def) {
    if (!def.providedIn) {
      return false;
    }
    const providedIn = resolveForwardRef(def.providedIn);
    if (typeof providedIn === "string") {
      return providedIn === "any" || this.scopes.has(providedIn);
    } else {
      return this.injectorDefTypes.has(providedIn);
    }
  }
  removeOnDestroy(callback) {
    const destroyCBIdx = this._onDestroyHooks.indexOf(callback);
    if (destroyCBIdx !== -1) {
      this._onDestroyHooks.splice(destroyCBIdx, 1);
    }
  }
};
function injectableDefOrInjectorDefFactory(token) {
  const injectableDef = getInjectableDef(token);
  const factory = injectableDef !== null ? injectableDef.factory : getFactoryDef(token);
  if (factory !== null) {
    return factory;
  }
  if (token instanceof InjectionToken) {
    throw new RuntimeError(204, ngDevMode && `Token ${stringify(token)} is missing a ɵprov definition.`);
  }
  if (token instanceof Function) {
    return getUndecoratedInjectableFactory(token);
  }
  throw new RuntimeError(204, ngDevMode && "unreachable");
}
function getUndecoratedInjectableFactory(token) {
  const paramLength = token.length;
  if (paramLength > 0) {
    throw new RuntimeError(204, ngDevMode && `Can't resolve all parameters for ${stringify(token)}: (${newArray(paramLength, "?").join(", ")}).`);
  }
  const inheritedInjectableDef = getInheritedInjectableDef(token);
  if (inheritedInjectableDef !== null) {
    return () => inheritedInjectableDef.factory(token);
  } else {
    return () => new token();
  }
}
function providerToRecord(provider) {
  if (isValueProvider(provider)) {
    return makeRecord(void 0, provider.useValue);
  } else {
    const factory = providerToFactory(provider);
    return makeRecord(factory, NOT_YET);
  }
}
function providerToFactory(provider, ngModuleType, providers) {
  let factory = void 0;
  if (ngDevMode && isEnvironmentProviders(provider)) {
    throwInvalidProviderError(void 0, providers, provider);
  }
  if (isTypeProvider(provider)) {
    const unwrappedProvider = resolveForwardRef(provider);
    return getFactoryDef(unwrappedProvider) || injectableDefOrInjectorDefFactory(unwrappedProvider);
  } else {
    if (isValueProvider(provider)) {
      factory = () => resolveForwardRef(provider.useValue);
    } else if (isFactoryProvider(provider)) {
      factory = () => provider.useFactory(...injectArgs(provider.deps || []));
    } else if (isExistingProvider(provider)) {
      factory = () => ɵɵinject(resolveForwardRef(provider.useExisting));
    } else {
      const classRef = resolveForwardRef(provider && (provider.useClass || provider.provide));
      if (ngDevMode && !classRef) {
        throwInvalidProviderError(ngModuleType, providers, provider);
      }
      if (hasDeps(provider)) {
        factory = () => new classRef(...injectArgs(provider.deps));
      } else {
        return getFactoryDef(classRef) || injectableDefOrInjectorDefFactory(classRef);
      }
    }
  }
  return factory;
}
function makeRecord(factory, value, multi = false) {
  return {
    factory,
    value,
    multi: multi ? [] : void 0
  };
}
function hasDeps(value) {
  return !!value.deps;
}
function hasOnDestroy(value) {
  return value !== null && typeof value === "object" && typeof value.ngOnDestroy === "function";
}
function couldBeInjectableType(value) {
  return typeof value === "function" || typeof value === "object" && value instanceof InjectionToken;
}
function forEachSingleProvider(providers, fn) {
  for (const provider of providers) {
    if (Array.isArray(provider)) {
      forEachSingleProvider(provider, fn);
    } else if (provider && isEnvironmentProviders(provider)) {
      forEachSingleProvider(provider.ɵproviders, fn);
    } else {
      fn(provider);
    }
  }
}
function runInInjectionContext(injector, fn) {
  if (injector instanceof R3Injector) {
    injector.assertNotDestroyed();
  }
  let prevInjectorProfilerContext;
  if (ngDevMode) {
    prevInjectorProfilerContext = setInjectorProfilerContext({
      injector,
      token: null
    });
  }
  const prevInjector = setCurrentInjector(injector);
  const previousInjectImplementation = setInjectImplementation(void 0);
  try {
    return fn();
  } finally {
    setCurrentInjector(prevInjector);
    ngDevMode && setInjectorProfilerContext(prevInjectorProfilerContext);
    setInjectImplementation(previousInjectImplementation);
  }
}
function isInInjectionContext() {
  return getInjectImplementation() !== void 0 || getCurrentInjector() != null;
}
function assertInInjectionContext(debugFn) {
  if (!isInInjectionContext()) {
    throw new RuntimeError(-203, ngDevMode && debugFn.name + "() can only be used within an injection context such as a constructor, a factory function, a field initializer, or a function used with `runInInjectionContext`");
  }
}
var FactoryTarget;
(function(FactoryTarget2) {
  FactoryTarget2[FactoryTarget2["Directive"] = 0] = "Directive";
  FactoryTarget2[FactoryTarget2["Component"] = 1] = "Component";
  FactoryTarget2[FactoryTarget2["Injectable"] = 2] = "Injectable";
  FactoryTarget2[FactoryTarget2["Pipe"] = 3] = "Pipe";
  FactoryTarget2[FactoryTarget2["NgModule"] = 4] = "NgModule";
})(FactoryTarget || (FactoryTarget = {}));
var R3TemplateDependencyKind;
(function(R3TemplateDependencyKind2) {
  R3TemplateDependencyKind2[R3TemplateDependencyKind2["Directive"] = 0] = "Directive";
  R3TemplateDependencyKind2[R3TemplateDependencyKind2["Pipe"] = 1] = "Pipe";
  R3TemplateDependencyKind2[R3TemplateDependencyKind2["NgModule"] = 2] = "NgModule";
})(R3TemplateDependencyKind || (R3TemplateDependencyKind = {}));
var ViewEncapsulation;
(function(ViewEncapsulation2) {
  ViewEncapsulation2[ViewEncapsulation2["Emulated"] = 0] = "Emulated";
  ViewEncapsulation2[ViewEncapsulation2["None"] = 2] = "None";
  ViewEncapsulation2[ViewEncapsulation2["ShadowDom"] = 3] = "ShadowDom";
})(ViewEncapsulation || (ViewEncapsulation = {}));
function getCompilerFacade(request) {
  const globalNg = _global["ng"];
  if (globalNg && globalNg.ɵcompilerFacade) {
    return globalNg.ɵcompilerFacade;
  }
  if (typeof ngDevMode === "undefined" || ngDevMode) {
    console.error(`JIT compilation failed for ${request.kind}`, request.type);
    let message = `The ${request.kind} '${request.type.name}' needs to be compiled using the JIT compiler, but '@angular/compiler' is not available.

`;
    if (request.usage === 1) {
      message += `The ${request.kind} is part of a library that has been partially compiled.
`;
      message += `However, the Angular Linker has not processed the library such that JIT compilation is used as fallback.
`;
      message += "\n";
      message += `Ideally, the library is processed using the Angular Linker to become fully AOT compiled.
`;
    } else {
      message += `JIT compilation is discouraged for production use-cases! Consider using AOT mode instead.
`;
    }
    message += `Alternatively, the JIT compiler should be loaded by bootstrapping using '@angular/platform-browser-dynamic' or '@angular/platform-server',
`;
    message += `or manually provide the compiler with 'import "@angular/compiler";' before bootstrapping.`;
    throw new Error(message);
  } else {
    throw new Error("JIT compiler unavailable");
  }
}
var angularCoreDiEnv = {
  "ɵɵdefineInjectable": ɵɵdefineInjectable,
  "ɵɵdefineInjector": ɵɵdefineInjector,
  "ɵɵinject": ɵɵinject,
  "ɵɵinvalidFactoryDep": ɵɵinvalidFactoryDep,
  "resolveForwardRef": resolveForwardRef
};
var Type = Function;
function isType(v) {
  return typeof v === "function";
}
var ES5_DELEGATE_CTOR = /^function\s+\S+\(\)\s*{[\s\S]+\.apply\(this,\s*(arguments|(?:[^()]+\(\[\],)?[^()]+\(arguments\).*)\)/;
var ES2015_INHERITED_CLASS = /^class\s+[A-Za-z\d$_]*\s*extends\s+[^{]+{/;
var ES2015_INHERITED_CLASS_WITH_CTOR = /^class\s+[A-Za-z\d$_]*\s*extends\s+[^{]+{[\s\S]*constructor\s*\(/;
var ES2015_INHERITED_CLASS_WITH_DELEGATE_CTOR = /^class\s+[A-Za-z\d$_]*\s*extends\s+[^{]+{[\s\S]*constructor\s*\(\)\s*{[^}]*super\(\.\.\.arguments\)/;
function isDelegateCtor(typeStr) {
  return ES5_DELEGATE_CTOR.test(typeStr) || ES2015_INHERITED_CLASS_WITH_DELEGATE_CTOR.test(typeStr) || ES2015_INHERITED_CLASS.test(typeStr) && !ES2015_INHERITED_CLASS_WITH_CTOR.test(typeStr);
}
var ReflectionCapabilities = class {
  constructor(reflect) {
    this._reflect = reflect || _global["Reflect"];
  }
  factory(t) {
    return (...args) => new t(...args);
  }
  /** @internal */
  _zipTypesAndAnnotations(paramTypes, paramAnnotations) {
    let result;
    if (typeof paramTypes === "undefined") {
      result = newArray(paramAnnotations.length);
    } else {
      result = newArray(paramTypes.length);
    }
    for (let i = 0; i < result.length; i++) {
      if (typeof paramTypes === "undefined") {
        result[i] = [];
      } else if (paramTypes[i] && paramTypes[i] != Object) {
        result[i] = [paramTypes[i]];
      } else {
        result[i] = [];
      }
      if (paramAnnotations && paramAnnotations[i] != null) {
        result[i] = result[i].concat(paramAnnotations[i]);
      }
    }
    return result;
  }
  _ownParameters(type, parentCtor) {
    const typeStr = type.toString();
    if (isDelegateCtor(typeStr)) {
      return null;
    }
    if (type.parameters && type.parameters !== parentCtor.parameters) {
      return type.parameters;
    }
    const tsickleCtorParams = type.ctorParameters;
    if (tsickleCtorParams && tsickleCtorParams !== parentCtor.ctorParameters) {
      const ctorParameters = typeof tsickleCtorParams === "function" ? tsickleCtorParams() : tsickleCtorParams;
      const paramTypes2 = ctorParameters.map((ctorParam) => ctorParam && ctorParam.type);
      const paramAnnotations2 = ctorParameters.map((ctorParam) => ctorParam && convertTsickleDecoratorIntoMetadata(ctorParam.decorators));
      return this._zipTypesAndAnnotations(paramTypes2, paramAnnotations2);
    }
    const paramAnnotations = type.hasOwnProperty(PARAMETERS) && type[PARAMETERS];
    const paramTypes = this._reflect && this._reflect.getOwnMetadata && this._reflect.getOwnMetadata("design:paramtypes", type);
    if (paramTypes || paramAnnotations) {
      return this._zipTypesAndAnnotations(paramTypes, paramAnnotations);
    }
    return newArray(type.length);
  }
  parameters(type) {
    if (!isType(type)) {
      return [];
    }
    const parentCtor = getParentCtor(type);
    let parameters = this._ownParameters(type, parentCtor);
    if (!parameters && parentCtor !== Object) {
      parameters = this.parameters(parentCtor);
    }
    return parameters || [];
  }
  _ownAnnotations(typeOrFunc, parentCtor) {
    if (typeOrFunc.annotations && typeOrFunc.annotations !== parentCtor.annotations) {
      let annotations = typeOrFunc.annotations;
      if (typeof annotations === "function" && annotations.annotations) {
        annotations = annotations.annotations;
      }
      return annotations;
    }
    if (typeOrFunc.decorators && typeOrFunc.decorators !== parentCtor.decorators) {
      return convertTsickleDecoratorIntoMetadata(typeOrFunc.decorators);
    }
    if (typeOrFunc.hasOwnProperty(ANNOTATIONS)) {
      return typeOrFunc[ANNOTATIONS];
    }
    return null;
  }
  annotations(typeOrFunc) {
    if (!isType(typeOrFunc)) {
      return [];
    }
    const parentCtor = getParentCtor(typeOrFunc);
    const ownAnnotations = this._ownAnnotations(typeOrFunc, parentCtor) || [];
    const parentAnnotations = parentCtor !== Object ? this.annotations(parentCtor) : [];
    return parentAnnotations.concat(ownAnnotations);
  }
  _ownPropMetadata(typeOrFunc, parentCtor) {
    if (typeOrFunc.propMetadata && typeOrFunc.propMetadata !== parentCtor.propMetadata) {
      let propMetadata = typeOrFunc.propMetadata;
      if (typeof propMetadata === "function" && propMetadata.propMetadata) {
        propMetadata = propMetadata.propMetadata;
      }
      return propMetadata;
    }
    if (typeOrFunc.propDecorators && typeOrFunc.propDecorators !== parentCtor.propDecorators) {
      const propDecorators = typeOrFunc.propDecorators;
      const propMetadata = {};
      Object.keys(propDecorators).forEach((prop) => {
        propMetadata[prop] = convertTsickleDecoratorIntoMetadata(propDecorators[prop]);
      });
      return propMetadata;
    }
    if (typeOrFunc.hasOwnProperty(PROP_METADATA)) {
      return typeOrFunc[PROP_METADATA];
    }
    return null;
  }
  propMetadata(typeOrFunc) {
    if (!isType(typeOrFunc)) {
      return {};
    }
    const parentCtor = getParentCtor(typeOrFunc);
    const propMetadata = {};
    if (parentCtor !== Object) {
      const parentPropMetadata = this.propMetadata(parentCtor);
      Object.keys(parentPropMetadata).forEach((propName) => {
        propMetadata[propName] = parentPropMetadata[propName];
      });
    }
    const ownPropMetadata = this._ownPropMetadata(typeOrFunc, parentCtor);
    if (ownPropMetadata) {
      Object.keys(ownPropMetadata).forEach((propName) => {
        const decorators = [];
        if (propMetadata.hasOwnProperty(propName)) {
          decorators.push(...propMetadata[propName]);
        }
        decorators.push(...ownPropMetadata[propName]);
        propMetadata[propName] = decorators;
      });
    }
    return propMetadata;
  }
  ownPropMetadata(typeOrFunc) {
    if (!isType(typeOrFunc)) {
      return {};
    }
    return this._ownPropMetadata(typeOrFunc, getParentCtor(typeOrFunc)) || {};
  }
  hasLifecycleHook(type, lcProperty) {
    return type instanceof Type && lcProperty in type.prototype;
  }
};
function convertTsickleDecoratorIntoMetadata(decoratorInvocations) {
  if (!decoratorInvocations) {
    return [];
  }
  return decoratorInvocations.map((decoratorInvocation) => {
    const decoratorType = decoratorInvocation.type;
    const annotationCls = decoratorType.annotationCls;
    const annotationArgs = decoratorInvocation.args ? decoratorInvocation.args : [];
    return new annotationCls(...annotationArgs);
  });
}
function getParentCtor(ctor) {
  const parentProto = ctor.prototype ? Object.getPrototypeOf(ctor.prototype) : null;
  const parentCtor = parentProto ? parentProto.constructor : null;
  return parentCtor || Object;
}
var HOST = 0;
var TVIEW = 1;
var FLAGS = 2;
var PARENT = 3;
var NEXT = 4;
var T_HOST = 5;
var HYDRATION = 6;
var CLEANUP = 7;
var CONTEXT = 8;
var INJECTOR = 9;
var ENVIRONMENT = 10;
var RENDERER = 11;
var CHILD_HEAD = 12;
var CHILD_TAIL = 13;
var DECLARATION_VIEW = 14;
var DECLARATION_COMPONENT_VIEW = 15;
var DECLARATION_LCONTAINER = 16;
var PREORDER_HOOK_FLAGS = 17;
var QUERIES = 18;
var ID = 19;
var EMBEDDED_VIEW_INJECTOR = 20;
var ON_DESTROY_HOOKS = 21;
var EFFECTS_TO_SCHEDULE = 22;
var REACTIVE_TEMPLATE_CONSUMER = 23;
var HEADER_OFFSET = 25;
var TYPE = 1;
var DEHYDRATED_VIEWS = 6;
var NATIVE = 7;
var VIEW_REFS = 8;
var MOVED_VIEWS = 9;
var CONTAINER_HEADER_OFFSET = 10;
var LContainerFlags;
(function(LContainerFlags2) {
  LContainerFlags2[LContainerFlags2["None"] = 0] = "None";
  LContainerFlags2[LContainerFlags2["HasTransplantedViews"] = 2] = "HasTransplantedViews";
})(LContainerFlags || (LContainerFlags = {}));
function isLView(value) {
  return Array.isArray(value) && typeof value[TYPE] === "object";
}
function isLContainer(value) {
  return Array.isArray(value) && value[TYPE] === true;
}
function isContentQueryHost(tNode) {
  return (tNode.flags & 4) !== 0;
}
function isComponentHost(tNode) {
  return tNode.componentOffset > -1;
}
function isDirectiveHost(tNode) {
  return (tNode.flags & 1) === 1;
}
function isComponentDef(def) {
  return !!def.template;
}
function isRootView(target) {
  return (target[FLAGS] & 512) !== 0;
}
function isProjectionTNode(tNode) {
  return (tNode.type & 16) === 16;
}
function hasI18n(lView) {
  return (lView[FLAGS] & 32) === 32;
}
function isDestroyed(lView) {
  return (lView[FLAGS] & 256) === 256;
}
function assertTNodeForLView(tNode, lView) {
  assertTNodeForTView(tNode, lView[TVIEW]);
}
function assertTNodeForTView(tNode, tView) {
  assertTNode(tNode);
  const tData = tView.data;
  for (let i = HEADER_OFFSET; i < tData.length; i++) {
    if (tData[i] === tNode) {
      return;
    }
  }
  throwError("This TNode does not belong to this TView.");
}
function assertTNode(tNode) {
  assertDefined(tNode, "TNode must be defined");
  if (!(tNode && typeof tNode === "object" && tNode.hasOwnProperty("directiveStylingLast"))) {
    throwError("Not of type TNode, got: " + tNode);
  }
}
function assertTIcu(tIcu) {
  assertDefined(tIcu, "Expected TIcu to be defined");
  if (!(typeof tIcu.currentCaseLViewIndex === "number")) {
    throwError("Object is not of TIcu type.");
  }
}
function assertComponentType(actual, msg = "Type passed in is not ComponentType, it does not have 'ɵcmp' property.") {
  if (!getComponentDef(actual)) {
    throwError(msg);
  }
}
function assertNgModuleType(actual, msg = "Type passed in is not NgModuleType, it does not have 'ɵmod' property.") {
  if (!getNgModuleDef(actual)) {
    throwError(msg);
  }
}
function assertHasParent(tNode) {
  assertDefined(tNode, "currentTNode should exist!");
  assertDefined(tNode.parent, "currentTNode should have a parent");
}
function assertLContainer(value) {
  assertDefined(value, "LContainer must be defined");
  assertEqual(isLContainer(value), true, "Expecting LContainer");
}
function assertLViewOrUndefined(value) {
  value && assertEqual(isLView(value), true, "Expecting LView or undefined or null");
}
function assertLView(value) {
  assertDefined(value, "LView must be defined");
  assertEqual(isLView(value), true, "Expecting LView");
}
function assertFirstCreatePass(tView, errMessage) {
  assertEqual(tView.firstCreatePass, true, errMessage || "Should only be called in first create pass.");
}
function assertFirstUpdatePass(tView, errMessage) {
  assertEqual(tView.firstUpdatePass, true, errMessage || "Should only be called in first update pass.");
}
function assertDirectiveDef(obj) {
  if (obj.type === void 0 || obj.selectors == void 0 || obj.inputs === void 0) {
    throwError(`Expected a DirectiveDef/ComponentDef and this object does not seem to have the expected shape.`);
  }
}
function assertIndexInDeclRange(tView, index) {
  assertBetween(HEADER_OFFSET, tView.bindingStartIndex, index);
}
function assertIndexInExpandoRange(lView, index) {
  const tView = lView[1];
  assertBetween(tView.expandoStartIndex, lView.length, index);
}
function assertBetween(lower, upper, index) {
  if (!(lower <= index && index < upper)) {
    throwError(`Index out of range (expecting ${lower} <= ${index} < ${upper})`);
  }
}
function assertProjectionSlots(lView, errMessage) {
  assertDefined(lView[DECLARATION_COMPONENT_VIEW], "Component views should exist.");
  assertDefined(lView[DECLARATION_COMPONENT_VIEW][T_HOST].projection, errMessage || "Components with projection nodes (<ng-content>) must have projection slots defined.");
}
function assertParentView(lView, errMessage) {
  assertDefined(lView, errMessage || "Component views should always have a parent view (component's host view)");
}
function assertNoDuplicateDirectives(directives) {
  if (directives.length < 2) {
    return;
  }
  const seenDirectives = /* @__PURE__ */ new Set();
  for (const current of directives) {
    if (seenDirectives.has(current)) {
      throw new RuntimeError(309, `Directive ${current.type.name} matches multiple times on the same element. Directives can only match an element once.`);
    }
    seenDirectives.add(current);
  }
}
function assertNodeInjector(lView, injectorIndex) {
  assertIndexInExpandoRange(lView, injectorIndex);
  assertIndexInExpandoRange(
    lView,
    injectorIndex + 8
    /* NodeInjectorOffset.PARENT */
  );
  assertNumber(lView[injectorIndex + 0], "injectorIndex should point to a bloom filter");
  assertNumber(lView[injectorIndex + 1], "injectorIndex should point to a bloom filter");
  assertNumber(lView[injectorIndex + 2], "injectorIndex should point to a bloom filter");
  assertNumber(lView[injectorIndex + 3], "injectorIndex should point to a bloom filter");
  assertNumber(lView[injectorIndex + 4], "injectorIndex should point to a bloom filter");
  assertNumber(lView[injectorIndex + 5], "injectorIndex should point to a bloom filter");
  assertNumber(lView[injectorIndex + 6], "injectorIndex should point to a bloom filter");
  assertNumber(lView[injectorIndex + 7], "injectorIndex should point to a bloom filter");
  assertNumber(lView[
    injectorIndex + 8
    /* NodeInjectorOffset.PARENT */
  ], "injectorIndex should point to parent injector");
}
var SimpleChange = class {
  constructor(previousValue, currentValue, firstChange) {
    this.previousValue = previousValue;
    this.currentValue = currentValue;
    this.firstChange = firstChange;
  }
  /**
   * Check whether the new value is the first value assigned.
   */
  isFirstChange() {
    return this.firstChange;
  }
};
function applyValueToInputField(instance, inputSignalNode, privateName, value) {
  if (inputSignalNode !== null) {
    inputSignalNode.applyValueToInputSignal(inputSignalNode, value);
  } else {
    instance[privateName] = value;
  }
}
function ɵɵNgOnChangesFeature() {
  return NgOnChangesFeatureImpl;
}
function NgOnChangesFeatureImpl(definition) {
  if (definition.type.prototype.ngOnChanges) {
    definition.setInput = ngOnChangesSetInput;
  }
  return rememberChangeHistoryAndInvokeOnChangesHook;
}
ɵɵNgOnChangesFeature.ngInherit = true;
function rememberChangeHistoryAndInvokeOnChangesHook() {
  const simpleChangesStore = getSimpleChangesStore(this);
  const current = simpleChangesStore?.current;
  if (current) {
    const previous = simpleChangesStore.previous;
    if (previous === EMPTY_OBJ) {
      simpleChangesStore.previous = current;
    } else {
      for (let key in current) {
        previous[key] = current[key];
      }
    }
    simpleChangesStore.current = null;
    this.ngOnChanges(current);
  }
}
function ngOnChangesSetInput(instance, inputSignalNode, value, publicName, privateName) {
  const declaredName = this.declaredInputs[publicName];
  ngDevMode && assertString(declaredName, "Name of input in ngOnChanges has to be a string");
  const simpleChangesStore = getSimpleChangesStore(instance) || setSimpleChangesStore(instance, {
    previous: EMPTY_OBJ,
    current: null
  });
  const current = simpleChangesStore.current || (simpleChangesStore.current = {});
  const previous = simpleChangesStore.previous;
  const previousChange = previous[declaredName];
  current[declaredName] = new SimpleChange(previousChange && previousChange.currentValue, value, previous === EMPTY_OBJ);
  applyValueToInputField(instance, inputSignalNode, privateName, value);
}
var SIMPLE_CHANGES_STORE = "__ngSimpleChanges__";
function getSimpleChangesStore(instance) {
  return instance[SIMPLE_CHANGES_STORE] || null;
}
function setSimpleChangesStore(instance, store2) {
  return instance[SIMPLE_CHANGES_STORE] = store2;
}
var profilerCallback = null;
var setProfiler = (profiler2) => {
  profilerCallback = profiler2;
};
var profiler = function(event, instance, hookOrListener) {
  if (profilerCallback != null) {
    profilerCallback(event, instance, hookOrListener);
  }
};
var SVG_NAMESPACE = "svg";
var MATH_ML_NAMESPACE = "math";
function unwrapRNode(value) {
  while (Array.isArray(value)) {
    value = value[HOST];
  }
  return value;
}
function unwrapLView(value) {
  while (Array.isArray(value)) {
    if (typeof value[TYPE] === "object") return value;
    value = value[HOST];
  }
  return null;
}
function getNativeByIndex(index, lView) {
  ngDevMode && assertIndexInRange(lView, index);
  ngDevMode && assertGreaterThanOrEqual(index, HEADER_OFFSET, "Expected to be past HEADER_OFFSET");
  return unwrapRNode(lView[index]);
}
function getNativeByTNode(tNode, lView) {
  ngDevMode && assertTNodeForLView(tNode, lView);
  ngDevMode && assertIndexInRange(lView, tNode.index);
  const node = unwrapRNode(lView[tNode.index]);
  return node;
}
function getNativeByTNodeOrNull(tNode, lView) {
  const index = tNode === null ? -1 : tNode.index;
  if (index !== -1) {
    ngDevMode && assertTNodeForLView(tNode, lView);
    const node = unwrapRNode(lView[index]);
    return node;
  }
  return null;
}
function getTNode(tView, index) {
  ngDevMode && assertGreaterThan(index, -1, "wrong index for TNode");
  ngDevMode && assertLessThan(index, tView.data.length, "wrong index for TNode");
  const tNode = tView.data[index];
  ngDevMode && tNode !== null && assertTNode(tNode);
  return tNode;
}
function load(view, index) {
  ngDevMode && assertIndexInRange(view, index);
  return view[index];
}
function getComponentLViewByIndex(nodeIndex, hostView) {
  ngDevMode && assertIndexInRange(hostView, nodeIndex);
  const slotValue = hostView[nodeIndex];
  const lView = isLView(slotValue) ? slotValue : slotValue[HOST];
  return lView;
}
function isCreationMode(view) {
  return (view[FLAGS] & 4) === 4;
}
function viewAttachedToChangeDetector(view) {
  return (view[FLAGS] & 128) === 128;
}
function viewAttachedToContainer(view) {
  return isLContainer(view[PARENT]);
}
function getConstant(consts, index) {
  if (index === null || index === void 0) return null;
  ngDevMode && assertIndexInRange(consts, index);
  return consts[index];
}
function resetPreOrderHookFlags(lView) {
  lView[PREORDER_HOOK_FLAGS] = 0;
}
function markViewForRefresh(lView) {
  if (lView[FLAGS] & 1024) {
    return;
  }
  lView[FLAGS] |= 1024;
  if (viewAttachedToChangeDetector(lView)) {
    markAncestorsForTraversal(lView);
  }
}
function walkUpViews(nestingLevel, currentView) {
  while (nestingLevel > 0) {
    ngDevMode && assertDefined(currentView[DECLARATION_VIEW], "Declaration view should be defined if nesting level is greater than 0.");
    currentView = currentView[DECLARATION_VIEW];
    nestingLevel--;
  }
  return currentView;
}
function requiresRefreshOrTraversal(lView) {
  return !!(lView[FLAGS] & (1024 | 8192) || lView[REACTIVE_TEMPLATE_CONSUMER]?.dirty);
}
function updateAncestorTraversalFlagsOnAttach(lView) {
  lView[ENVIRONMENT].changeDetectionScheduler?.notify(
    7
    /* NotificationSource.ViewAttached */
  );
  if (lView[FLAGS] & 64) {
    lView[FLAGS] |= 1024;
  }
  if (requiresRefreshOrTraversal(lView)) {
    markAncestorsForTraversal(lView);
  }
}
function markAncestorsForTraversal(lView) {
  lView[ENVIRONMENT].changeDetectionScheduler?.notify(
    0
    /* NotificationSource.MarkAncestorsForTraversal */
  );
  let parent = getLViewParent(lView);
  while (parent !== null) {
    if (parent[FLAGS] & 8192) {
      break;
    }
    parent[FLAGS] |= 8192;
    if (!viewAttachedToChangeDetector(parent)) {
      break;
    }
    parent = getLViewParent(parent);
  }
}
function storeLViewOnDestroy(lView, onDestroyCallback) {
  if ((lView[FLAGS] & 256) === 256) {
    throw new RuntimeError(911, ngDevMode && "View has already been destroyed.");
  }
  if (lView[ON_DESTROY_HOOKS] === null) {
    lView[ON_DESTROY_HOOKS] = [];
  }
  lView[ON_DESTROY_HOOKS].push(onDestroyCallback);
}
function removeLViewOnDestroy(lView, onDestroyCallback) {
  if (lView[ON_DESTROY_HOOKS] === null) return;
  const destroyCBIdx = lView[ON_DESTROY_HOOKS].indexOf(onDestroyCallback);
  if (destroyCBIdx !== -1) {
    lView[ON_DESTROY_HOOKS].splice(destroyCBIdx, 1);
  }
}
function getLViewParent(lView) {
  ngDevMode && assertLView(lView);
  const parent = lView[PARENT];
  return isLContainer(parent) ? parent[PARENT] : parent;
}
var instructionState = {
  lFrame: createLFrame(null),
  bindingsEnabled: true,
  skipHydrationRootTNode: null
};
var CheckNoChangesMode;
(function(CheckNoChangesMode2) {
  CheckNoChangesMode2[CheckNoChangesMode2["Off"] = 0] = "Off";
  CheckNoChangesMode2[CheckNoChangesMode2["Exhaustive"] = 1] = "Exhaustive";
  CheckNoChangesMode2[CheckNoChangesMode2["OnlyDirtyViews"] = 2] = "OnlyDirtyViews";
})(CheckNoChangesMode || (CheckNoChangesMode = {}));
var _checkNoChangesMode = 0;
var _isRefreshingViews = false;
function getElementDepthCount() {
  return instructionState.lFrame.elementDepthCount;
}
function increaseElementDepthCount() {
  instructionState.lFrame.elementDepthCount++;
}
function decreaseElementDepthCount() {
  instructionState.lFrame.elementDepthCount--;
}
function getBindingsEnabled() {
  return instructionState.bindingsEnabled;
}
function isInSkipHydrationBlock$1() {
  return instructionState.skipHydrationRootTNode !== null;
}
function isSkipHydrationRootTNode(tNode) {
  return instructionState.skipHydrationRootTNode === tNode;
}
function ɵɵenableBindings() {
  instructionState.bindingsEnabled = true;
}
function enterSkipHydrationBlock(tNode) {
  instructionState.skipHydrationRootTNode = tNode;
}
function ɵɵdisableBindings() {
  instructionState.bindingsEnabled = false;
}
function leaveSkipHydrationBlock() {
  instructionState.skipHydrationRootTNode = null;
}
function getLView() {
  return instructionState.lFrame.lView;
}
function getTView() {
  return instructionState.lFrame.tView;
}
function ɵɵrestoreView(viewToRestore) {
  instructionState.lFrame.contextLView = viewToRestore;
  return viewToRestore[CONTEXT];
}
function ɵɵresetView(value) {
  instructionState.lFrame.contextLView = null;
  return value;
}
function getCurrentTNode() {
  let currentTNode = getCurrentTNodePlaceholderOk();
  while (currentTNode !== null && currentTNode.type === 64) {
    currentTNode = currentTNode.parent;
  }
  return currentTNode;
}
function getCurrentTNodePlaceholderOk() {
  return instructionState.lFrame.currentTNode;
}
function getCurrentParentTNode() {
  const lFrame = instructionState.lFrame;
  const currentTNode = lFrame.currentTNode;
  return lFrame.isParent ? currentTNode : currentTNode.parent;
}
function setCurrentTNode(tNode, isParent) {
  ngDevMode && tNode && assertTNodeForTView(tNode, instructionState.lFrame.tView);
  const lFrame = instructionState.lFrame;
  lFrame.currentTNode = tNode;
  lFrame.isParent = isParent;
}
function isCurrentTNodeParent() {
  return instructionState.lFrame.isParent;
}
function setCurrentTNodeAsNotParent() {
  instructionState.lFrame.isParent = false;
}
function getContextLView() {
  const contextLView = instructionState.lFrame.contextLView;
  ngDevMode && assertDefined(contextLView, "contextLView must be defined.");
  return contextLView;
}
function isInCheckNoChangesMode() {
  !ngDevMode && throwError("Must never be called in production mode");
  return _checkNoChangesMode !== CheckNoChangesMode.Off;
}
function isExhaustiveCheckNoChanges() {
  !ngDevMode && throwError("Must never be called in production mode");
  return _checkNoChangesMode === CheckNoChangesMode.Exhaustive;
}
function setIsInCheckNoChangesMode(mode) {
  !ngDevMode && throwError("Must never be called in production mode");
  _checkNoChangesMode = mode;
}
function isRefreshingViews() {
  return _isRefreshingViews;
}
function setIsRefreshingViews(mode) {
  _isRefreshingViews = mode;
}
function getBindingRoot() {
  const lFrame = instructionState.lFrame;
  let index = lFrame.bindingRootIndex;
  if (index === -1) {
    index = lFrame.bindingRootIndex = lFrame.tView.bindingStartIndex;
  }
  return index;
}
function getBindingIndex() {
  return instructionState.lFrame.bindingIndex;
}
function setBindingIndex(value) {
  return instructionState.lFrame.bindingIndex = value;
}
function nextBindingIndex() {
  return instructionState.lFrame.bindingIndex++;
}
function incrementBindingIndex(count) {
  const lFrame = instructionState.lFrame;
  const index = lFrame.bindingIndex;
  lFrame.bindingIndex = lFrame.bindingIndex + count;
  return index;
}
function isInI18nBlock() {
  return instructionState.lFrame.inI18n;
}
function setInI18nBlock(isInI18nBlock2) {
  instructionState.lFrame.inI18n = isInI18nBlock2;
}
function setBindingRootForHostBindings(bindingRootIndex, currentDirectiveIndex) {
  const lFrame = instructionState.lFrame;
  lFrame.bindingIndex = lFrame.bindingRootIndex = bindingRootIndex;
  setCurrentDirectiveIndex(currentDirectiveIndex);
}
function getCurrentDirectiveIndex() {
  return instructionState.lFrame.currentDirectiveIndex;
}
function setCurrentDirectiveIndex(currentDirectiveIndex) {
  instructionState.lFrame.currentDirectiveIndex = currentDirectiveIndex;
}
function getCurrentDirectiveDef(tData) {
  const currentDirectiveIndex = instructionState.lFrame.currentDirectiveIndex;
  return currentDirectiveIndex === -1 ? null : tData[currentDirectiveIndex];
}
function getCurrentQueryIndex() {
  return instructionState.lFrame.currentQueryIndex;
}
function setCurrentQueryIndex(value) {
  instructionState.lFrame.currentQueryIndex = value;
}
function getDeclarationTNode(lView) {
  const tView = lView[TVIEW];
  if (tView.type === 2) {
    ngDevMode && assertDefined(tView.declTNode, "Embedded TNodes should have declaration parents.");
    return tView.declTNode;
  }
  if (tView.type === 1) {
    return lView[T_HOST];
  }
  return null;
}
function enterDI(lView, tNode, flags) {
  ngDevMode && assertLViewOrUndefined(lView);
  if (flags & InjectFlags.SkipSelf) {
    ngDevMode && assertTNodeForTView(tNode, lView[TVIEW]);
    let parentTNode = tNode;
    let parentLView = lView;
    while (true) {
      ngDevMode && assertDefined(parentTNode, "Parent TNode should be defined");
      parentTNode = parentTNode.parent;
      if (parentTNode === null && !(flags & InjectFlags.Host)) {
        parentTNode = getDeclarationTNode(parentLView);
        if (parentTNode === null) break;
        ngDevMode && assertDefined(parentLView, "Parent LView should be defined");
        parentLView = parentLView[DECLARATION_VIEW];
        if (parentTNode.type & (2 | 8)) {
          break;
        }
      } else {
        break;
      }
    }
    if (parentTNode === null) {
      return false;
    } else {
      tNode = parentTNode;
      lView = parentLView;
    }
  }
  ngDevMode && assertTNodeForLView(tNode, lView);
  const lFrame = instructionState.lFrame = allocLFrame();
  lFrame.currentTNode = tNode;
  lFrame.lView = lView;
  return true;
}
function enterView(newView) {
  ngDevMode && assertNotEqual(newView[0], newView[1], "????");
  ngDevMode && assertLViewOrUndefined(newView);
  const newLFrame = allocLFrame();
  if (ngDevMode) {
    assertEqual(newLFrame.isParent, true, "Expected clean LFrame");
    assertEqual(newLFrame.lView, null, "Expected clean LFrame");
    assertEqual(newLFrame.tView, null, "Expected clean LFrame");
    assertEqual(newLFrame.selectedIndex, -1, "Expected clean LFrame");
    assertEqual(newLFrame.elementDepthCount, 0, "Expected clean LFrame");
    assertEqual(newLFrame.currentDirectiveIndex, -1, "Expected clean LFrame");
    assertEqual(newLFrame.currentNamespace, null, "Expected clean LFrame");
    assertEqual(newLFrame.bindingRootIndex, -1, "Expected clean LFrame");
    assertEqual(newLFrame.currentQueryIndex, 0, "Expected clean LFrame");
  }
  const tView = newView[TVIEW];
  instructionState.lFrame = newLFrame;
  ngDevMode && tView.firstChild && assertTNodeForTView(tView.firstChild, tView);
  newLFrame.currentTNode = tView.firstChild;
  newLFrame.lView = newView;
  newLFrame.tView = tView;
  newLFrame.contextLView = newView;
  newLFrame.bindingIndex = tView.bindingStartIndex;
  newLFrame.inI18n = false;
}
function allocLFrame() {
  const currentLFrame = instructionState.lFrame;
  const childLFrame = currentLFrame === null ? null : currentLFrame.child;
  const newLFrame = childLFrame === null ? createLFrame(currentLFrame) : childLFrame;
  return newLFrame;
}
function createLFrame(parent) {
  const lFrame = {
    currentTNode: null,
    isParent: true,
    lView: null,
    tView: null,
    selectedIndex: -1,
    contextLView: null,
    elementDepthCount: 0,
    currentNamespace: null,
    currentDirectiveIndex: -1,
    bindingRootIndex: -1,
    bindingIndex: -1,
    currentQueryIndex: 0,
    parent,
    child: null,
    inI18n: false
  };
  parent !== null && (parent.child = lFrame);
  return lFrame;
}
function leaveViewLight() {
  const oldLFrame = instructionState.lFrame;
  instructionState.lFrame = oldLFrame.parent;
  oldLFrame.currentTNode = null;
  oldLFrame.lView = null;
  return oldLFrame;
}
var leaveDI = leaveViewLight;
function leaveView() {
  const oldLFrame = leaveViewLight();
  oldLFrame.isParent = true;
  oldLFrame.tView = null;
  oldLFrame.selectedIndex = -1;
  oldLFrame.contextLView = null;
  oldLFrame.elementDepthCount = 0;
  oldLFrame.currentDirectiveIndex = -1;
  oldLFrame.currentNamespace = null;
  oldLFrame.bindingRootIndex = -1;
  oldLFrame.bindingIndex = -1;
  oldLFrame.currentQueryIndex = 0;
}
function nextContextImpl(level) {
  const contextLView = instructionState.lFrame.contextLView = walkUpViews(level, instructionState.lFrame.contextLView);
  return contextLView[CONTEXT];
}
function getSelectedIndex() {
  return instructionState.lFrame.selectedIndex;
}
function setSelectedIndex(index) {
  ngDevMode && index !== -1 && assertGreaterThanOrEqual(index, HEADER_OFFSET, "Index must be past HEADER_OFFSET (or -1).");
  ngDevMode && assertLessThan(index, instructionState.lFrame.lView.length, "Can't set index passed end of LView");
  instructionState.lFrame.selectedIndex = index;
}
function getSelectedTNode() {
  const lFrame = instructionState.lFrame;
  return getTNode(lFrame.tView, lFrame.selectedIndex);
}
function ɵɵnamespaceSVG() {
  instructionState.lFrame.currentNamespace = SVG_NAMESPACE;
}
function ɵɵnamespaceMathML() {
  instructionState.lFrame.currentNamespace = MATH_ML_NAMESPACE;
}
function ɵɵnamespaceHTML() {
  namespaceHTMLInternal();
}
function namespaceHTMLInternal() {
  instructionState.lFrame.currentNamespace = null;
}
function getNamespace$1() {
  return instructionState.lFrame.currentNamespace;
}
var _wasLastNodeCreated = true;
function wasLastNodeCreated() {
  return _wasLastNodeCreated;
}
function lastNodeWasCreated(flag) {
  _wasLastNodeCreated = flag;
}
function registerPreOrderHooks(directiveIndex, directiveDef, tView) {
  ngDevMode && assertFirstCreatePass(tView);
  const {
    ngOnChanges,
    ngOnInit,
    ngDoCheck
  } = directiveDef.type.prototype;
  if (ngOnChanges) {
    const wrappedOnChanges = NgOnChangesFeatureImpl(directiveDef);
    (tView.preOrderHooks ??= []).push(directiveIndex, wrappedOnChanges);
    (tView.preOrderCheckHooks ??= []).push(directiveIndex, wrappedOnChanges);
  }
  if (ngOnInit) {
    (tView.preOrderHooks ??= []).push(0 - directiveIndex, ngOnInit);
  }
  if (ngDoCheck) {
    (tView.preOrderHooks ??= []).push(directiveIndex, ngDoCheck);
    (tView.preOrderCheckHooks ??= []).push(directiveIndex, ngDoCheck);
  }
}
function registerPostOrderHooks(tView, tNode) {
  ngDevMode && assertFirstCreatePass(tView);
  for (let i = tNode.directiveStart, end = tNode.directiveEnd; i < end; i++) {
    const directiveDef = tView.data[i];
    ngDevMode && assertDefined(directiveDef, "Expecting DirectiveDef");
    const lifecycleHooks = directiveDef.type.prototype;
    const {
      ngAfterContentInit,
      ngAfterContentChecked,
      ngAfterViewInit,
      ngAfterViewChecked,
      ngOnDestroy
    } = lifecycleHooks;
    if (ngAfterContentInit) {
      (tView.contentHooks ??= []).push(-i, ngAfterContentInit);
    }
    if (ngAfterContentChecked) {
      (tView.contentHooks ??= []).push(i, ngAfterContentChecked);
      (tView.contentCheckHooks ??= []).push(i, ngAfterContentChecked);
    }
    if (ngAfterViewInit) {
      (tView.viewHooks ??= []).push(-i, ngAfterViewInit);
    }
    if (ngAfterViewChecked) {
      (tView.viewHooks ??= []).push(i, ngAfterViewChecked);
      (tView.viewCheckHooks ??= []).push(i, ngAfterViewChecked);
    }
    if (ngOnDestroy != null) {
      (tView.destroyHooks ??= []).push(i, ngOnDestroy);
    }
  }
}
function executeCheckHooks(lView, hooks, nodeIndex) {
  callHooks(lView, hooks, 3, nodeIndex);
}
function executeInitAndCheckHooks(lView, hooks, initPhase, nodeIndex) {
  ngDevMode && assertNotEqual(initPhase, 3, "Init pre-order hooks should not be called more than once");
  if ((lView[FLAGS] & 3) === initPhase) {
    callHooks(lView, hooks, initPhase, nodeIndex);
  }
}
function incrementInitPhaseFlags(lView, initPhase) {
  ngDevMode && assertNotEqual(initPhase, 3, "Init hooks phase should not be incremented after all init hooks have been run.");
  let flags = lView[FLAGS];
  if ((flags & 3) === initPhase) {
    flags &= 16383;
    flags += 1;
    lView[FLAGS] = flags;
  }
}
function callHooks(currentView, arr, initPhase, currentNodeIndex) {
  ngDevMode && assertEqual(isInCheckNoChangesMode(), false, "Hooks should never be run when in check no changes mode.");
  const startIndex = currentNodeIndex !== void 0 ? currentView[PREORDER_HOOK_FLAGS] & 65535 : 0;
  const nodeIndexLimit = currentNodeIndex != null ? currentNodeIndex : -1;
  const max = arr.length - 1;
  let lastNodeIndexFound = 0;
  for (let i = startIndex; i < max; i++) {
    const hook = arr[i + 1];
    if (typeof hook === "number") {
      lastNodeIndexFound = arr[i];
      if (currentNodeIndex != null && lastNodeIndexFound >= currentNodeIndex) {
        break;
      }
    } else {
      const isInitHook = arr[i] < 0;
      if (isInitHook) {
        currentView[PREORDER_HOOK_FLAGS] += 65536;
      }
      if (lastNodeIndexFound < nodeIndexLimit || nodeIndexLimit == -1) {
        callHook(currentView, initPhase, arr, i);
        currentView[PREORDER_HOOK_FLAGS] = (currentView[PREORDER_HOOK_FLAGS] & 4294901760) + i + 2;
      }
      i++;
    }
  }
}
function callHookInternal(directive, hook) {
  profiler(4, directive, hook);
  const prevConsumer = setActiveConsumer(null);
  try {
    hook.call(directive);
  } finally {
    setActiveConsumer(prevConsumer);
    profiler(5, directive, hook);
  }
}
function callHook(currentView, initPhase, arr, i) {
  const isInitHook = arr[i] < 0;
  const hook = arr[i + 1];
  const directiveIndex = isInitHook ? -arr[i] : arr[i];
  const directive = currentView[directiveIndex];
  if (isInitHook) {
    const indexWithintInitPhase = currentView[FLAGS] >> 14;
    if (indexWithintInitPhase < currentView[PREORDER_HOOK_FLAGS] >> 16 && (currentView[FLAGS] & 3) === initPhase) {
      currentView[FLAGS] += 16384;
      callHookInternal(directive, hook);
    }
  } else {
    callHookInternal(directive, hook);
  }
}
var NO_PARENT_INJECTOR = -1;
var NodeInjectorFactory = class {
  constructor(factory, isViewProvider, injectImplementation) {
    this.factory = factory;
    this.resolving = false;
    ngDevMode && assertDefined(factory, "Factory not specified");
    ngDevMode && assertEqual(typeof factory, "function", "Expected factory function.");
    this.canSeeViewProviders = isViewProvider;
    this.injectImpl = injectImplementation;
  }
};
function isFactory(obj) {
  return obj instanceof NodeInjectorFactory;
}
function toTNodeTypeAsString(tNodeType) {
  let text = "";
  tNodeType & 1 && (text += "|Text");
  tNodeType & 2 && (text += "|Element");
  tNodeType & 4 && (text += "|Container");
  tNodeType & 8 && (text += "|ElementContainer");
  tNodeType & 16 && (text += "|Projection");
  tNodeType & 32 && (text += "|IcuContainer");
  tNodeType & 64 && (text += "|Placeholder");
  tNodeType & 128 && (text += "|LetDeclaration");
  return text.length > 0 ? text.substring(1) : text;
}
function isTNodeShape(value) {
  return value != null && typeof value === "object" && (value.insertBeforeIndex === null || typeof value.insertBeforeIndex === "number" || Array.isArray(value.insertBeforeIndex));
}
function hasClassInput(tNode) {
  return (tNode.flags & 8) !== 0;
}
function hasStyleInput(tNode) {
  return (tNode.flags & 16) !== 0;
}
function assertTNodeType(tNode, expectedTypes, message) {
  assertDefined(tNode, "should be called with a TNode");
  if ((tNode.type & expectedTypes) === 0) {
    throwError(message || `Expected [${toTNodeTypeAsString(expectedTypes)}] but got ${toTNodeTypeAsString(tNode.type)}.`);
  }
}
function assertPureTNodeType(type) {
  if (!(type === 2 || type === 1 || type === 4 || type === 8 || type === 32 || type === 16 || type === 64 || type === 128)) {
    throwError(`Expected TNodeType to have only a single type selected, but got ${toTNodeTypeAsString(type)}.`);
  }
}
var NOT_FOUND_CHECK_ONLY_ELEMENT_INJECTOR = {};
var ChainedInjector = class {
  constructor(injector, parentInjector) {
    this.injector = injector;
    this.parentInjector = parentInjector;
  }
  get(token, notFoundValue, flags) {
    flags = convertToBitFlags(flags);
    const value = this.injector.get(token, NOT_FOUND_CHECK_ONLY_ELEMENT_INJECTOR, flags);
    if (value !== NOT_FOUND_CHECK_ONLY_ELEMENT_INJECTOR || notFoundValue === NOT_FOUND_CHECK_ONLY_ELEMENT_INJECTOR) {
      return value;
    }
    return this.parentInjector.get(token, notFoundValue, flags);
  }
};
function hasParentInjector(parentLocation) {
  return parentLocation !== NO_PARENT_INJECTOR;
}
function getParentInjectorIndex(parentLocation) {
  if (ngDevMode) {
    assertNumber(parentLocation, "Number expected");
    assertNotEqual(parentLocation, -1, "Not a valid state.");
    const parentInjectorIndex = parentLocation & 32767;
    assertGreaterThan(parentInjectorIndex, HEADER_OFFSET, "Parent injector must be pointing past HEADER_OFFSET.");
  }
  return parentLocation & 32767;
}
function getParentInjectorViewOffset(parentLocation) {
  return parentLocation >> 16;
}
function getParentInjectorView(location2, startView) {
  let viewOffset = getParentInjectorViewOffset(location2);
  let parentView = startView;
  while (viewOffset > 0) {
    parentView = parentView[DECLARATION_VIEW];
    viewOffset--;
  }
  return parentView;
}
function isRouterOutletInjector(currentInjector) {
  return currentInjector instanceof ChainedInjector && typeof currentInjector.injector.__ngOutletInjector === "function";
}
var includeViewProviders = true;
function setIncludeViewProviders(v) {
  const oldValue = includeViewProviders;
  includeViewProviders = v;
  return oldValue;
}
var BLOOM_SIZE = 256;
var BLOOM_MASK = BLOOM_SIZE - 1;
var BLOOM_BUCKET_BITS = 5;
var nextNgElementId = 0;
var NOT_FOUND = {};
function bloomAdd(injectorIndex, tView, type) {
  ngDevMode && assertEqual(tView.firstCreatePass, true, "expected firstCreatePass to be true");
  let id;
  if (typeof type === "string") {
    id = type.charCodeAt(0) || 0;
  } else if (type.hasOwnProperty(NG_ELEMENT_ID)) {
    id = type[NG_ELEMENT_ID];
  }
  if (id == null) {
    id = type[NG_ELEMENT_ID] = nextNgElementId++;
  }
  const bloomHash = id & BLOOM_MASK;
  const mask = 1 << bloomHash;
  tView.data[injectorIndex + (bloomHash >> BLOOM_BUCKET_BITS)] |= mask;
}
function getOrCreateNodeInjectorForNode(tNode, lView) {
  const existingInjectorIndex = getInjectorIndex(tNode, lView);
  if (existingInjectorIndex !== -1) {
    return existingInjectorIndex;
  }
  const tView = lView[TVIEW];
  if (tView.firstCreatePass) {
    tNode.injectorIndex = lView.length;
    insertBloom(tView.data, tNode);
    insertBloom(lView, null);
    insertBloom(tView.blueprint, null);
  }
  const parentLoc = getParentInjectorLocation(tNode, lView);
  const injectorIndex = tNode.injectorIndex;
  if (hasParentInjector(parentLoc)) {
    const parentIndex = getParentInjectorIndex(parentLoc);
    const parentLView = getParentInjectorView(parentLoc, lView);
    const parentData = parentLView[TVIEW].data;
    for (let i = 0; i < 8; i++) {
      lView[injectorIndex + i] = parentLView[parentIndex + i] | parentData[parentIndex + i];
    }
  }
  lView[
    injectorIndex + 8
    /* NodeInjectorOffset.PARENT */
  ] = parentLoc;
  return injectorIndex;
}
function insertBloom(arr, footer) {
  arr.push(0, 0, 0, 0, 0, 0, 0, 0, footer);
}
function getInjectorIndex(tNode, lView) {
  if (tNode.injectorIndex === -1 || // If the injector index is the same as its parent's injector index, then the index has been
  // copied down from the parent node. No injector has been created yet on this node.
  tNode.parent && tNode.parent.injectorIndex === tNode.injectorIndex || // After the first template pass, the injector index might exist but the parent values
  // might not have been calculated yet for this instance
  lView[
    tNode.injectorIndex + 8
    /* NodeInjectorOffset.PARENT */
  ] === null) {
    return -1;
  } else {
    ngDevMode && assertIndexInRange(lView, tNode.injectorIndex);
    return tNode.injectorIndex;
  }
}
function getParentInjectorLocation(tNode, lView) {
  if (tNode.parent && tNode.parent.injectorIndex !== -1) {
    return tNode.parent.injectorIndex;
  }
  let declarationViewOffset = 0;
  let parentTNode = null;
  let lViewCursor = lView;
  while (lViewCursor !== null) {
    parentTNode = getTNodeFromLView(lViewCursor);
    if (parentTNode === null) {
      return NO_PARENT_INJECTOR;
    }
    ngDevMode && parentTNode && assertTNodeForLView(parentTNode, lViewCursor[DECLARATION_VIEW]);
    declarationViewOffset++;
    lViewCursor = lViewCursor[DECLARATION_VIEW];
    if (parentTNode.injectorIndex !== -1) {
      return parentTNode.injectorIndex | declarationViewOffset << 16;
    }
  }
  return NO_PARENT_INJECTOR;
}
function diPublicInInjector(injectorIndex, tView, token) {
  bloomAdd(injectorIndex, tView, token);
}
function injectAttributeImpl(tNode, attrNameToInject) {
  ngDevMode && assertTNodeType(
    tNode,
    12 | 3
    /* TNodeType.AnyRNode */
  );
  ngDevMode && assertDefined(tNode, "expecting tNode");
  if (attrNameToInject === "class") {
    return tNode.classes;
  }
  if (attrNameToInject === "style") {
    return tNode.styles;
  }
  const attrs = tNode.attrs;
  if (attrs) {
    const attrsLength = attrs.length;
    let i = 0;
    while (i < attrsLength) {
      const value = attrs[i];
      if (isNameOnlyAttributeMarker(value)) break;
      if (value === 0) {
        i = i + 2;
      } else if (typeof value === "number") {
        i++;
        while (i < attrsLength && typeof attrs[i] === "string") {
          i++;
        }
      } else if (value === attrNameToInject) {
        return attrs[i + 1];
      } else {
        i = i + 2;
      }
    }
  }
  return null;
}
function notFoundValueOrThrow(notFoundValue, token, flags) {
  if (flags & InjectFlags.Optional || notFoundValue !== void 0) {
    return notFoundValue;
  } else {
    throwProviderNotFoundError(token, "NodeInjector");
  }
}
function lookupTokenUsingModuleInjector(lView, token, flags, notFoundValue) {
  if (flags & InjectFlags.Optional && notFoundValue === void 0) {
    notFoundValue = null;
  }
  if ((flags & (InjectFlags.Self | InjectFlags.Host)) === 0) {
    const moduleInjector = lView[INJECTOR];
    const previousInjectImplementation = setInjectImplementation(void 0);
    try {
      if (moduleInjector) {
        return moduleInjector.get(token, notFoundValue, flags & InjectFlags.Optional);
      } else {
        return injectRootLimpMode(token, notFoundValue, flags & InjectFlags.Optional);
      }
    } finally {
      setInjectImplementation(previousInjectImplementation);
    }
  }
  return notFoundValueOrThrow(notFoundValue, token, flags);
}
function getOrCreateInjectable(tNode, lView, token, flags = InjectFlags.Default, notFoundValue) {
  if (tNode !== null) {
    if (lView[FLAGS] & 2048 && // The token must be present on the current node injector when the `Self`
    // flag is set, so the lookup on embedded view injector(s) can be skipped.
    !(flags & InjectFlags.Self)) {
      const embeddedInjectorValue = lookupTokenUsingEmbeddedInjector(tNode, lView, token, flags, NOT_FOUND);
      if (embeddedInjectorValue !== NOT_FOUND) {
        return embeddedInjectorValue;
      }
    }
    const value = lookupTokenUsingNodeInjector(tNode, lView, token, flags, NOT_FOUND);
    if (value !== NOT_FOUND) {
      return value;
    }
  }
  return lookupTokenUsingModuleInjector(lView, token, flags, notFoundValue);
}
function lookupTokenUsingNodeInjector(tNode, lView, token, flags, notFoundValue) {
  const bloomHash = bloomHashBitOrFactory(token);
  if (typeof bloomHash === "function") {
    if (!enterDI(lView, tNode, flags)) {
      return flags & InjectFlags.Host ? notFoundValueOrThrow(notFoundValue, token, flags) : lookupTokenUsingModuleInjector(lView, token, flags, notFoundValue);
    }
    try {
      let value;
      if (ngDevMode) {
        runInInjectorProfilerContext(new NodeInjector(getCurrentTNode(), getLView()), token, () => {
          value = bloomHash(flags);
          if (value != null) {
            emitInstanceCreatedByInjectorEvent(value);
          }
        });
      } else {
        value = bloomHash(flags);
      }
      if (value == null && !(flags & InjectFlags.Optional)) {
        throwProviderNotFoundError(token);
      } else {
        return value;
      }
    } finally {
      leaveDI();
    }
  } else if (typeof bloomHash === "number") {
    let previousTView = null;
    let injectorIndex = getInjectorIndex(tNode, lView);
    let parentLocation = NO_PARENT_INJECTOR;
    let hostTElementNode = flags & InjectFlags.Host ? lView[DECLARATION_COMPONENT_VIEW][T_HOST] : null;
    if (injectorIndex === -1 || flags & InjectFlags.SkipSelf) {
      parentLocation = injectorIndex === -1 ? getParentInjectorLocation(tNode, lView) : lView[
        injectorIndex + 8
        /* NodeInjectorOffset.PARENT */
      ];
      if (parentLocation === NO_PARENT_INJECTOR || !shouldSearchParent(flags, false)) {
        injectorIndex = -1;
      } else {
        previousTView = lView[TVIEW];
        injectorIndex = getParentInjectorIndex(parentLocation);
        lView = getParentInjectorView(parentLocation, lView);
      }
    }
    while (injectorIndex !== -1) {
      ngDevMode && assertNodeInjector(lView, injectorIndex);
      const tView = lView[TVIEW];
      ngDevMode && assertTNodeForLView(tView.data[
        injectorIndex + 8
        /* NodeInjectorOffset.TNODE */
      ], lView);
      if (bloomHasToken(bloomHash, injectorIndex, tView.data)) {
        const instance = searchTokensOnInjector(injectorIndex, lView, token, previousTView, flags, hostTElementNode);
        if (instance !== NOT_FOUND) {
          return instance;
        }
      }
      parentLocation = lView[
        injectorIndex + 8
        /* NodeInjectorOffset.PARENT */
      ];
      if (parentLocation !== NO_PARENT_INJECTOR && shouldSearchParent(flags, lView[TVIEW].data[
        injectorIndex + 8
        /* NodeInjectorOffset.TNODE */
      ] === hostTElementNode) && bloomHasToken(bloomHash, injectorIndex, lView)) {
        previousTView = tView;
        injectorIndex = getParentInjectorIndex(parentLocation);
        lView = getParentInjectorView(parentLocation, lView);
      } else {
        injectorIndex = -1;
      }
    }
  }
  return notFoundValue;
}
function searchTokensOnInjector(injectorIndex, lView, token, previousTView, flags, hostTElementNode) {
  const currentTView = lView[TVIEW];
  const tNode = currentTView.data[
    injectorIndex + 8
    /* NodeInjectorOffset.TNODE */
  ];
  const canAccessViewProviders = previousTView == null ? (
    // 1) This is the first invocation `previousTView == null` which means that we are at the
    // `TNode` of where injector is starting to look. In such a case the only time we are allowed
    // to look into the ViewProviders is if:
    // - we are on a component
    // - AND the injector set `includeViewProviders` to true (implying that the token can see
    // ViewProviders because it is the Component or a Service which itself was declared in
    // ViewProviders)
    isComponentHost(tNode) && includeViewProviders
  ) : (
    // 2) `previousTView != null` which means that we are now walking across the parent nodes.
    // In such a case we are only allowed to look into the ViewProviders if:
    // - We just crossed from child View to Parent View `previousTView != currentTView`
    // - AND the parent TNode is an Element.
    // This means that we just came from the Component's View and therefore are allowed to see
    // into the ViewProviders.
    previousTView != currentTView && (tNode.type & 3) !== 0
  );
  const isHostSpecialCase = flags & InjectFlags.Host && hostTElementNode === tNode;
  const injectableIdx = locateDirectiveOrProvider(tNode, currentTView, token, canAccessViewProviders, isHostSpecialCase);
  if (injectableIdx !== null) {
    return getNodeInjectable(lView, currentTView, injectableIdx, tNode);
  } else {
    return NOT_FOUND;
  }
}
function locateDirectiveOrProvider(tNode, tView, token, canAccessViewProviders, isHostSpecialCase) {
  const nodeProviderIndexes = tNode.providerIndexes;
  const tInjectables = tView.data;
  const injectablesStart = nodeProviderIndexes & 1048575;
  const directivesStart = tNode.directiveStart;
  const directiveEnd = tNode.directiveEnd;
  const cptViewProvidersCount = nodeProviderIndexes >> 20;
  const startingIndex = canAccessViewProviders ? injectablesStart : injectablesStart + cptViewProvidersCount;
  const endIndex = isHostSpecialCase ? injectablesStart + cptViewProvidersCount : directiveEnd;
  for (let i = startingIndex; i < endIndex; i++) {
    const providerTokenOrDef = tInjectables[i];
    if (i < directivesStart && token === providerTokenOrDef || i >= directivesStart && providerTokenOrDef.type === token) {
      return i;
    }
  }
  if (isHostSpecialCase) {
    const dirDef = tInjectables[directivesStart];
    if (dirDef && isComponentDef(dirDef) && dirDef.type === token) {
      return directivesStart;
    }
  }
  return null;
}
function getNodeInjectable(lView, tView, index, tNode) {
  let value = lView[index];
  const tData = tView.data;
  if (isFactory(value)) {
    const factory = value;
    if (factory.resolving) {
      throwCyclicDependencyError(stringifyForError(tData[index]));
    }
    const previousIncludeViewProviders = setIncludeViewProviders(factory.canSeeViewProviders);
    factory.resolving = true;
    let prevInjectContext;
    if (ngDevMode) {
      const token = tData[index].type || tData[index];
      const injector = new NodeInjector(tNode, lView);
      prevInjectContext = setInjectorProfilerContext({
        injector,
        token
      });
    }
    const previousInjectImplementation = factory.injectImpl ? setInjectImplementation(factory.injectImpl) : null;
    const success = enterDI(lView, tNode, InjectFlags.Default);
    ngDevMode && assertEqual(success, true, "Because flags do not contain `SkipSelf' we expect this to always succeed.");
    try {
      value = lView[index] = factory.factory(void 0, tData, lView, tNode);
      ngDevMode && emitInstanceCreatedByInjectorEvent(value);
      if (tView.firstCreatePass && index >= tNode.directiveStart) {
        ngDevMode && assertDirectiveDef(tData[index]);
        registerPreOrderHooks(index, tData[index], tView);
      }
    } finally {
      ngDevMode && setInjectorProfilerContext(prevInjectContext);
      previousInjectImplementation !== null && setInjectImplementation(previousInjectImplementation);
      setIncludeViewProviders(previousIncludeViewProviders);
      factory.resolving = false;
      leaveDI();
    }
  }
  return value;
}
function bloomHashBitOrFactory(token) {
  ngDevMode && assertDefined(token, "token must be defined");
  if (typeof token === "string") {
    return token.charCodeAt(0) || 0;
  }
  const tokenId = (
    // First check with `hasOwnProperty` so we don't get an inherited ID.
    token.hasOwnProperty(NG_ELEMENT_ID) ? token[NG_ELEMENT_ID] : void 0
  );
  if (typeof tokenId === "number") {
    if (tokenId >= 0) {
      return tokenId & BLOOM_MASK;
    } else {
      ngDevMode && assertEqual(tokenId, -1, "Expecting to get Special Injector Id");
      return createNodeInjector;
    }
  } else {
    return tokenId;
  }
}
function bloomHasToken(bloomHash, injectorIndex, injectorView) {
  const mask = 1 << bloomHash;
  const value = injectorView[injectorIndex + (bloomHash >> BLOOM_BUCKET_BITS)];
  return !!(value & mask);
}
function shouldSearchParent(flags, isFirstHostTNode) {
  return !(flags & InjectFlags.Self) && !(flags & InjectFlags.Host && isFirstHostTNode);
}
function getNodeInjectorLView(nodeInjector) {
  return nodeInjector._lView;
}
function getNodeInjectorTNode(nodeInjector) {
  return nodeInjector._tNode;
}
var NodeInjector = class {
  constructor(_tNode, _lView) {
    this._tNode = _tNode;
    this._lView = _lView;
  }
  get(token, notFoundValue, flags) {
    return getOrCreateInjectable(this._tNode, this._lView, token, convertToBitFlags(flags), notFoundValue);
  }
};
function createNodeInjector() {
  return new NodeInjector(getCurrentTNode(), getLView());
}
function ɵɵgetInheritedFactory(type) {
  return noSideEffects(() => {
    const ownConstructor = type.prototype.constructor;
    const ownFactory = ownConstructor[NG_FACTORY_DEF] || getFactoryOf(ownConstructor);
    const objectPrototype = Object.prototype;
    let parent = Object.getPrototypeOf(type.prototype).constructor;
    while (parent && parent !== objectPrototype) {
      const factory = parent[NG_FACTORY_DEF] || getFactoryOf(parent);
      if (factory && factory !== ownFactory) {
        return factory;
      }
      parent = Object.getPrototypeOf(parent);
    }
    return (t) => new t();
  });
}
function getFactoryOf(type) {
  if (isForwardRef(type)) {
    return () => {
      const factory = getFactoryOf(resolveForwardRef(type));
      return factory && factory();
    };
  }
  return getFactoryDef(type);
}
function lookupTokenUsingEmbeddedInjector(tNode, lView, token, flags, notFoundValue) {
  let currentTNode = tNode;
  let currentLView = lView;
  while (currentTNode !== null && currentLView !== null && currentLView[FLAGS] & 2048 && !(currentLView[FLAGS] & 512)) {
    ngDevMode && assertTNodeForLView(currentTNode, currentLView);
    const nodeInjectorValue = lookupTokenUsingNodeInjector(currentTNode, currentLView, token, flags | InjectFlags.Self, NOT_FOUND);
    if (nodeInjectorValue !== NOT_FOUND) {
      return nodeInjectorValue;
    }
    let parentTNode = currentTNode.parent;
    if (!parentTNode) {
      const embeddedViewInjector = currentLView[EMBEDDED_VIEW_INJECTOR];
      if (embeddedViewInjector) {
        const embeddedViewInjectorValue = embeddedViewInjector.get(token, NOT_FOUND, flags);
        if (embeddedViewInjectorValue !== NOT_FOUND) {
          return embeddedViewInjectorValue;
        }
      }
      parentTNode = getTNodeFromLView(currentLView);
      currentLView = currentLView[DECLARATION_VIEW];
    }
    currentTNode = parentTNode;
  }
  return notFoundValue;
}
function getTNodeFromLView(lView) {
  const tView = lView[TVIEW];
  const tViewType = tView.type;
  if (tViewType === 2) {
    ngDevMode && assertDefined(tView.declTNode, "Embedded TNodes should have declaration parents.");
    return tView.declTNode;
  } else if (tViewType === 1) {
    return lView[T_HOST];
  }
  return null;
}
function ɵɵinjectAttribute(attrNameToInject) {
  return injectAttributeImpl(getCurrentTNode(), attrNameToInject);
}
var Attribute2 = makeParamDecorator("Attribute", (attributeName) => ({
  attributeName,
  __NG_ELEMENT_ID__: () => ɵɵinjectAttribute(attributeName)
}));
var _reflect = null;
function getReflect() {
  return _reflect = _reflect || new ReflectionCapabilities();
}
function reflectDependencies(type) {
  return convertDependencies(getReflect().parameters(type));
}
function convertDependencies(deps) {
  return deps.map((dep) => reflectDependency(dep));
}
function reflectDependency(dep) {
  const meta = {
    token: null,
    attribute: null,
    host: false,
    optional: false,
    self: false,
    skipSelf: false
  };
  if (Array.isArray(dep) && dep.length > 0) {
    for (let j = 0; j < dep.length; j++) {
      const param = dep[j];
      if (param === void 0) {
        continue;
      }
      const proto = Object.getPrototypeOf(param);
      if (param instanceof Optional || proto.ngMetadataName === "Optional") {
        meta.optional = true;
      } else if (param instanceof SkipSelf || proto.ngMetadataName === "SkipSelf") {
        meta.skipSelf = true;
      } else if (param instanceof Self || proto.ngMetadataName === "Self") {
        meta.self = true;
      } else if (param instanceof Host || proto.ngMetadataName === "Host") {
        meta.host = true;
      } else if (param instanceof Inject) {
        meta.token = param.token;
      } else if (param instanceof Attribute2) {
        if (param.attributeName === void 0) {
          throw new RuntimeError(204, ngDevMode && `Attribute name must be defined.`);
        }
        meta.attribute = param.attributeName;
      } else {
        meta.token = param;
      }
    }
  } else if (dep === void 0 || Array.isArray(dep) && dep.length === 0) {
    meta.token = null;
  } else {
    meta.token = dep;
  }
  return meta;
}
function compileInjectable(type, meta) {
  let ngInjectableDef = null;
  let ngFactoryDef = null;
  if (!type.hasOwnProperty(NG_PROV_DEF)) {
    Object.defineProperty(type, NG_PROV_DEF, {
      get: () => {
        if (ngInjectableDef === null) {
          const compiler = getCompilerFacade({
            usage: 0,
            kind: "injectable",
            type
          });
          ngInjectableDef = compiler.compileInjectable(angularCoreDiEnv, `ng:///${type.name}/ɵprov.js`, getInjectableMetadata(type, meta));
        }
        return ngInjectableDef;
      }
    });
  }
  if (!type.hasOwnProperty(NG_FACTORY_DEF)) {
    Object.defineProperty(type, NG_FACTORY_DEF, {
      get: () => {
        if (ngFactoryDef === null) {
          const compiler = getCompilerFacade({
            usage: 0,
            kind: "injectable",
            type
          });
          ngFactoryDef = compiler.compileFactory(angularCoreDiEnv, `ng:///${type.name}/ɵfac.js`, {
            name: type.name,
            type,
            typeArgumentCount: 0,
            // In JIT mode types are not available nor used.
            deps: reflectDependencies(type),
            target: compiler.FactoryTarget.Injectable
          });
        }
        return ngFactoryDef;
      },
      // Leave this configurable so that the factories from directives or pipes can take precedence.
      configurable: true
    });
  }
}
var USE_VALUE = getClosureSafeProperty({
  provide: String,
  useValue: getClosureSafeProperty
});
function isUseClassProvider(meta) {
  return meta.useClass !== void 0;
}
function isUseValueProvider(meta) {
  return USE_VALUE in meta;
}
function isUseFactoryProvider(meta) {
  return meta.useFactory !== void 0;
}
function isUseExistingProvider(meta) {
  return meta.useExisting !== void 0;
}
function getInjectableMetadata(type, srcMeta) {
  const meta = srcMeta || {
    providedIn: null
  };
  const compilerMeta = {
    name: type.name,
    type,
    typeArgumentCount: 0,
    providedIn: meta.providedIn
  };
  if ((isUseClassProvider(meta) || isUseFactoryProvider(meta)) && meta.deps !== void 0) {
    compilerMeta.deps = convertDependencies(meta.deps);
  }
  if (isUseClassProvider(meta)) {
    compilerMeta.useClass = meta.useClass;
  } else if (isUseValueProvider(meta)) {
    compilerMeta.useValue = meta.useValue;
  } else if (isUseFactoryProvider(meta)) {
    compilerMeta.useFactory = meta.useFactory;
  } else if (isUseExistingProvider(meta)) {
    compilerMeta.useExisting = meta.useExisting;
  }
  return compilerMeta;
}
var Injectable = makeDecorator("Injectable", void 0, void 0, void 0, (type, meta) => compileInjectable(type, meta));
function createInjector(defType, parent = null, additionalProviders = null, name) {
  const injector = createInjectorWithoutInjectorInstances(defType, parent, additionalProviders, name);
  injector.resolveInjectorInitializers();
  return injector;
}
function createInjectorWithoutInjectorInstances(defType, parent = null, additionalProviders = null, name, scopes = /* @__PURE__ */ new Set()) {
  const providers = [additionalProviders || EMPTY_ARRAY, importProvidersFrom(defType)];
  name = name || (typeof defType === "object" ? void 0 : stringify(defType));
  return new R3Injector(providers, parent || getNullInjector(), name || null, scopes);
}
var Injector = class _Injector {
  static {
    this.THROW_IF_NOT_FOUND = THROW_IF_NOT_FOUND;
  }
  static {
    this.NULL = new NullInjector();
  }
  static create(options, parent) {
    if (Array.isArray(options)) {
      return createInjector({
        name: ""
      }, parent, options, "");
    } else {
      const name = options.name ?? "";
      return createInjector({
        name
      }, options.parent, options.providers, name);
    }
  }
  static {
    this.ɵprov = ɵɵdefineInjectable({
      token: _Injector,
      providedIn: "any",
      factory: () => ɵɵinject(INJECTOR$1)
    });
  }
  static {
    this.__NG_ELEMENT_ID__ = -1;
  }
};
var HostAttributeToken = class {
  constructor(attributeName) {
    this.attributeName = attributeName;
    this.__NG_ELEMENT_ID__ = () => ɵɵinjectAttribute(this.attributeName);
  }
  toString() {
    return `HostAttributeToken ${this.attributeName}`;
  }
};
var HOST_TAG_NAME = new InjectionToken(ngDevMode ? "HOST_TAG_NAME" : "");
HOST_TAG_NAME.__NG_ELEMENT_ID__ = (flags) => {
  const tNode = getCurrentTNode();
  if (tNode === null) {
    throw new RuntimeError(204, ngDevMode && "HOST_TAG_NAME can only be injected in directives and components during construction time (in a class constructor or as a class field initializer)");
  }
  if (tNode.type & 2) {
    return tNode.value;
  }
  if (flags & InjectFlags.Optional) {
    return null;
  }
  throw new RuntimeError(204, ngDevMode && `HOST_TAG_NAME was used on ${getDevModeNodeName(tNode)} which doesn't have an underlying element in the DOM. This is invalid, and so the dependency should be marked as optional.`);
};
function getDevModeNodeName(tNode) {
  if (tNode.type & 8) {
    return "an <ng-container>";
  } else if (tNode.type & 4) {
    return "an <ng-template>";
  } else if (tNode.type & 128) {
    return "an @let declaration";
  } else {
    return "a node";
  }
}
var ERROR_ORIGINAL_ERROR = "ngOriginalError";
function getOriginalError(error) {
  return error[ERROR_ORIGINAL_ERROR];
}
var DestroyRef = class {
  static {
    this.__NG_ELEMENT_ID__ = injectDestroyRef;
  }
  static {
    this.__NG_ENV_ID__ = (injector) => injector;
  }
};
var NodeInjectorDestroyRef = class extends DestroyRef {
  constructor(_lView) {
    super();
    this._lView = _lView;
  }
  onDestroy(callback) {
    storeLViewOnDestroy(this._lView, callback);
    return () => removeLViewOnDestroy(this._lView, callback);
  }
};
function injectDestroyRef() {
  return new NodeInjectorDestroyRef(getLView());
}
var PendingTasks = class _PendingTasks {
  constructor() {
    this.taskId = 0;
    this.pendingTasks = /* @__PURE__ */ new Set();
    this.hasPendingTasks = new BehaviorSubject(false);
  }
  get _hasPendingTasks() {
    return this.hasPendingTasks.value;
  }
  add() {
    if (!this._hasPendingTasks) {
      this.hasPendingTasks.next(true);
    }
    const taskId = this.taskId++;
    this.pendingTasks.add(taskId);
    return taskId;
  }
  remove(taskId) {
    this.pendingTasks.delete(taskId);
    if (this.pendingTasks.size === 0 && this._hasPendingTasks) {
      this.hasPendingTasks.next(false);
    }
  }
  ngOnDestroy() {
    this.pendingTasks.clear();
    if (this._hasPendingTasks) {
      this.hasPendingTasks.next(false);
    }
  }
  static {
    this.ɵprov = ɵɵdefineInjectable({
      token: _PendingTasks,
      providedIn: "root",
      factory: () => new _PendingTasks()
    });
  }
};
var ExperimentalPendingTasks = class _ExperimentalPendingTasks {
  constructor() {
    this.internalPendingTasks = inject(PendingTasks);
  }
  /**
   * Adds a new task that should block application's stability.
   * @returns A cleanup function that removes a task when called.
   */
  add() {
    const taskId = this.internalPendingTasks.add();
    return () => this.internalPendingTasks.remove(taskId);
  }
  static {
    this.ɵprov = ɵɵdefineInjectable({
      token: _ExperimentalPendingTasks,
      providedIn: "root",
      factory: () => new _ExperimentalPendingTasks()
    });
  }
};
var EventEmitter_ = class extends Subject {
  constructor(isAsync = false) {
    super();
    this.destroyRef = void 0;
    this.pendingTasks = void 0;
    this.__isAsync = isAsync;
    if (isInInjectionContext()) {
      this.destroyRef = inject(DestroyRef, {
        optional: true
      }) ?? void 0;
      this.pendingTasks = inject(PendingTasks, {
        optional: true
      }) ?? void 0;
    }
  }
  emit(value) {
    const prevConsumer = setActiveConsumer(null);
    try {
      super.next(value);
    } finally {
      setActiveConsumer(prevConsumer);
    }
  }
  subscribe(observerOrNext, error, complete) {
    let nextFn = observerOrNext;
    let errorFn = error || (() => null);
    let completeFn = complete;
    if (observerOrNext && typeof observerOrNext === "object") {
      const observer = observerOrNext;
      nextFn = observer.next?.bind(observer);
      errorFn = observer.error?.bind(observer);
      completeFn = observer.complete?.bind(observer);
    }
    if (this.__isAsync) {
      errorFn = this.wrapInTimeout(errorFn);
      if (nextFn) {
        nextFn = this.wrapInTimeout(nextFn);
      }
      if (completeFn) {
        completeFn = this.wrapInTimeout(completeFn);
      }
    }
    const sink = super.subscribe({
      next: nextFn,
      error: errorFn,
      complete: completeFn
    });
    if (observerOrNext instanceof Subscription) {
      observerOrNext.add(sink);
    }
    return sink;
  }
  wrapInTimeout(fn) {
    return (value) => {
      const taskId = this.pendingTasks?.add();
      setTimeout(() => {
        fn(value);
        if (taskId !== void 0) {
          this.pendingTasks?.remove(taskId);
        }
      });
    };
  }
};
var EventEmitter = EventEmitter_;
function noop(...args) {
}
function scheduleCallbackWithRafRace(callback) {
  let timeoutId;
  let animationFrameId;
  function cleanup() {
    callback = noop;
    try {
      if (animationFrameId !== void 0 && typeof cancelAnimationFrame === "function") {
        cancelAnimationFrame(animationFrameId);
      }
      if (timeoutId !== void 0) {
        clearTimeout(timeoutId);
      }
    } catch {
    }
  }
  timeoutId = setTimeout(() => {
    callback();
    cleanup();
  });
  if (typeof requestAnimationFrame === "function") {
    animationFrameId = requestAnimationFrame(() => {
      callback();
      cleanup();
    });
  }
  return () => cleanup();
}
function scheduleCallbackWithMicrotask(callback) {
  queueMicrotask(() => callback());
  return () => {
    callback = noop;
  };
}
var AsyncStackTaggingZoneSpec = class {
  constructor(namePrefix, consoleAsyncStackTaggingImpl = console) {
    this.name = "asyncStackTagging for " + namePrefix;
    this.createTask = consoleAsyncStackTaggingImpl?.createTask ?? (() => null);
  }
  onScheduleTask(delegate, _current, target, task) {
    task.consoleTask = this.createTask(`Zone - ${task.source || task.type}`);
    return delegate.scheduleTask(target, task);
  }
  onInvokeTask(delegate, _currentZone, targetZone, task, applyThis, applyArgs) {
    let ret;
    if (task.consoleTask) {
      ret = task.consoleTask.run(() => delegate.invokeTask(targetZone, task, applyThis, applyArgs));
    } else {
      ret = delegate.invokeTask(targetZone, task, applyThis, applyArgs);
    }
    return ret;
  }
};
var isAngularZoneProperty = "isAngularZone";
var angularZoneInstanceIdProperty = isAngularZoneProperty + "_ID";
var ngZoneInstanceId = 0;
var NgZone = class _NgZone {
  constructor({
    enableLongStackTrace = false,
    shouldCoalesceEventChangeDetection = false,
    shouldCoalesceRunChangeDetection = false
  }) {
    this.hasPendingMacrotasks = false;
    this.hasPendingMicrotasks = false;
    this.isStable = true;
    this.onUnstable = new EventEmitter(false);
    this.onMicrotaskEmpty = new EventEmitter(false);
    this.onStable = new EventEmitter(false);
    this.onError = new EventEmitter(false);
    if (typeof Zone == "undefined") {
      throw new RuntimeError(908, ngDevMode && `In this configuration Angular requires Zone.js`);
    }
    Zone.assertZonePatched();
    const self = this;
    self._nesting = 0;
    self._outer = self._inner = Zone.current;
    if (ngDevMode) {
      self._inner = self._inner.fork(new AsyncStackTaggingZoneSpec("Angular"));
    }
    if (Zone["TaskTrackingZoneSpec"]) {
      self._inner = self._inner.fork(new Zone["TaskTrackingZoneSpec"]());
    }
    if (enableLongStackTrace && Zone["longStackTraceZoneSpec"]) {
      self._inner = self._inner.fork(Zone["longStackTraceZoneSpec"]);
    }
    self.shouldCoalesceEventChangeDetection = !shouldCoalesceRunChangeDetection && shouldCoalesceEventChangeDetection;
    self.shouldCoalesceRunChangeDetection = shouldCoalesceRunChangeDetection;
    self.callbackScheduled = false;
    forkInnerZoneWithAngularBehavior(self);
  }
  /**
    This method checks whether the method call happens within an Angular Zone instance.
  */
  static isInAngularZone() {
    return typeof Zone !== "undefined" && Zone.current.get(isAngularZoneProperty) === true;
  }
  /**
    Assures that the method is called within the Angular Zone, otherwise throws an error.
  */
  static assertInAngularZone() {
    if (!_NgZone.isInAngularZone()) {
      throw new RuntimeError(909, ngDevMode && "Expected to be in Angular Zone, but it is not!");
    }
  }
  /**
    Assures that the method is called outside of the Angular Zone, otherwise throws an error.
  */
  static assertNotInAngularZone() {
    if (_NgZone.isInAngularZone()) {
      throw new RuntimeError(909, ngDevMode && "Expected to not be in Angular Zone, but it is!");
    }
  }
  /**
   * Executes the `fn` function synchronously within the Angular zone and returns value returned by
   * the function.
   *
   * Running functions via `run` allows you to reenter Angular zone from a task that was executed
   * outside of the Angular zone (typically started via {@link #runOutsideAngular}).
   *
   * Any future tasks or microtasks scheduled from within this function will continue executing from
   * within the Angular zone.
   *
   * If a synchronous error happens it will be rethrown and not reported via `onError`.
   */
  run(fn, applyThis, applyArgs) {
    return this._inner.run(fn, applyThis, applyArgs);
  }
  /**
   * Executes the `fn` function synchronously within the Angular zone as a task and returns value
   * returned by the function.
   *
   * Running functions via `run` allows you to reenter Angular zone from a task that was executed
   * outside of the Angular zone (typically started via {@link #runOutsideAngular}).
   *
   * Any future tasks or microtasks scheduled from within this function will continue executing from
   * within the Angular zone.
   *
   * If a synchronous error happens it will be rethrown and not reported via `onError`.
   */
  runTask(fn, applyThis, applyArgs, name) {
    const zone = this._inner;
    const task = zone.scheduleEventTask("NgZoneEvent: " + name, fn, EMPTY_PAYLOAD, noop, noop);
    try {
      return zone.runTask(task, applyThis, applyArgs);
    } finally {
      zone.cancelTask(task);
    }
  }
  /**
   * Same as `run`, except that synchronous errors are caught and forwarded via `onError` and not
   * rethrown.
   */
  runGuarded(fn, applyThis, applyArgs) {
    return this._inner.runGuarded(fn, applyThis, applyArgs);
  }
  /**
   * Executes the `fn` function synchronously in Angular's parent zone and returns value returned by
   * the function.
   *
   * Running functions via {@link #runOutsideAngular} allows you to escape Angular's zone and do
   * work that
   * doesn't trigger Angular change-detection or is subject to Angular's error handling.
   *
   * Any future tasks or microtasks scheduled from within this function will continue executing from
   * outside of the Angular zone.
   *
   * Use {@link #run} to reenter the Angular zone and do work that updates the application model.
   */
  runOutsideAngular(fn) {
    return this._outer.run(fn);
  }
};
var EMPTY_PAYLOAD = {};
function checkStable(zone) {
  if (zone._nesting == 0 && !zone.hasPendingMicrotasks && !zone.isStable) {
    try {
      zone._nesting++;
      zone.onMicrotaskEmpty.emit(null);
    } finally {
      zone._nesting--;
      if (!zone.hasPendingMicrotasks) {
        try {
          zone.runOutsideAngular(() => zone.onStable.emit(null));
        } finally {
          zone.isStable = true;
        }
      }
    }
  }
}
function delayChangeDetectionForEvents(zone) {
  if (zone.isCheckStableRunning || zone.callbackScheduled) {
    return;
  }
  zone.callbackScheduled = true;
  Zone.root.run(() => {
    scheduleCallbackWithRafRace(() => {
      zone.callbackScheduled = false;
      updateMicroTaskStatus(zone);
      zone.isCheckStableRunning = true;
      checkStable(zone);
      zone.isCheckStableRunning = false;
    });
  });
  updateMicroTaskStatus(zone);
}
function forkInnerZoneWithAngularBehavior(zone) {
  const delayChangeDetectionForEventsDelegate = () => {
    delayChangeDetectionForEvents(zone);
  };
  const instanceId = ngZoneInstanceId++;
  zone._inner = zone._inner.fork({
    name: "angular",
    properties: {
      [isAngularZoneProperty]: true,
      [angularZoneInstanceIdProperty]: instanceId,
      [angularZoneInstanceIdProperty + instanceId]: true
    },
    onInvokeTask: (delegate, current, target, task, applyThis, applyArgs) => {
      if (shouldBeIgnoredByZone(applyArgs)) {
        return delegate.invokeTask(target, task, applyThis, applyArgs);
      }
      try {
        onEnter(zone);
        return delegate.invokeTask(target, task, applyThis, applyArgs);
      } finally {
        if (zone.shouldCoalesceEventChangeDetection && task.type === "eventTask" || zone.shouldCoalesceRunChangeDetection) {
          delayChangeDetectionForEventsDelegate();
        }
        onLeave(zone);
      }
    },
    onInvoke: (delegate, current, target, callback, applyThis, applyArgs, source) => {
      try {
        onEnter(zone);
        return delegate.invoke(target, callback, applyThis, applyArgs, source);
      } finally {
        if (zone.shouldCoalesceRunChangeDetection && // Do not delay change detection when the task is the scheduler's tick.
        // We need to synchronously trigger the stability logic so that the
        // zone-based scheduler can prevent a duplicate ApplicationRef.tick
        // by first checking if the scheduler tick is running. This does seem a bit roundabout,
        // but we _do_ still want to trigger all the correct events when we exit the zone.run
        // (`onMicrotaskEmpty` and `onStable` _should_ emit; developers can have code which
        // relies on these events happening after change detection runs).
        // Note: `zone.callbackScheduled` is already in delayChangeDetectionForEventsDelegate
        // but is added here as well to prevent reads of applyArgs when not necessary
        !zone.callbackScheduled && !isSchedulerTick(applyArgs)) {
          delayChangeDetectionForEventsDelegate();
        }
        onLeave(zone);
      }
    },
    onHasTask: (delegate, current, target, hasTaskState) => {
      delegate.hasTask(target, hasTaskState);
      if (current === target) {
        if (hasTaskState.change == "microTask") {
          zone._hasPendingMicrotasks = hasTaskState.microTask;
          updateMicroTaskStatus(zone);
          checkStable(zone);
        } else if (hasTaskState.change == "macroTask") {
          zone.hasPendingMacrotasks = hasTaskState.macroTask;
        }
      }
    },
    onHandleError: (delegate, current, target, error) => {
      delegate.handleError(target, error);
      zone.runOutsideAngular(() => zone.onError.emit(error));
      return false;
    }
  });
}
function updateMicroTaskStatus(zone) {
  if (zone._hasPendingMicrotasks || (zone.shouldCoalesceEventChangeDetection || zone.shouldCoalesceRunChangeDetection) && zone.callbackScheduled === true) {
    zone.hasPendingMicrotasks = true;
  } else {
    zone.hasPendingMicrotasks = false;
  }
}
function onEnter(zone) {
  zone._nesting++;
  if (zone.isStable) {
    zone.isStable = false;
    zone.onUnstable.emit(null);
  }
}
function onLeave(zone) {
  zone._nesting--;
  checkStable(zone);
}
var NoopNgZone = class {
  constructor() {
    this.hasPendingMicrotasks = false;
    this.hasPendingMacrotasks = false;
    this.isStable = true;
    this.onUnstable = new EventEmitter();
    this.onMicrotaskEmpty = new EventEmitter();
    this.onStable = new EventEmitter();
    this.onError = new EventEmitter();
  }
  run(fn, applyThis, applyArgs) {
    return fn.apply(applyThis, applyArgs);
  }
  runGuarded(fn, applyThis, applyArgs) {
    return fn.apply(applyThis, applyArgs);
  }
  runOutsideAngular(fn) {
    return fn();
  }
  runTask(fn, applyThis, applyArgs, name) {
    return fn.apply(applyThis, applyArgs);
  }
};
function shouldBeIgnoredByZone(applyArgs) {
  return hasApplyArgsData(applyArgs, "__ignore_ng_zone__");
}
function isSchedulerTick(applyArgs) {
  return hasApplyArgsData(applyArgs, "__scheduler_tick__");
}
function hasApplyArgsData(applyArgs, key) {
  if (!Array.isArray(applyArgs)) {
    return false;
  }
  if (applyArgs.length !== 1) {
    return false;
  }
  return applyArgs[0]?.data?.[key] === true;
}
function getNgZone(ngZoneToUse = "zone.js", options) {
  if (ngZoneToUse === "noop") {
    return new NoopNgZone();
  }
  if (ngZoneToUse === "zone.js") {
    return new NgZone(options);
  }
  return ngZoneToUse;
}
var ErrorHandler = class {
  constructor() {
    this._console = console;
  }
  handleError(error) {
    const originalError = this._findOriginalError(error);
    this._console.error("ERROR", error);
    if (originalError) {
      this._console.error("ORIGINAL ERROR", originalError);
    }
  }
  /** @internal */
  _findOriginalError(error) {
    let e = error && getOriginalError(error);
    while (e && getOriginalError(e)) {
      e = getOriginalError(e);
    }
    return e || null;
  }
};
var INTERNAL_APPLICATION_ERROR_HANDLER = new InjectionToken(typeof ngDevMode === "undefined" || ngDevMode ? "internal error handler" : "", {
  providedIn: "root",
  factory: () => {
    const zone = inject(NgZone);
    const userErrorHandler = inject(ErrorHandler);
    return (e) => zone.runOutsideAngular(() => userErrorHandler.handleError(e));
  }
});
var OutputEmitterRef = class {
  constructor() {
    this.destroyed = false;
    this.listeners = null;
    this.errorHandler = inject(ErrorHandler, {
      optional: true
    });
    this.destroyRef = inject(DestroyRef);
    this.destroyRef.onDestroy(() => {
      this.destroyed = true;
      this.listeners = null;
    });
  }
  subscribe(callback) {
    if (this.destroyed) {
      throw new RuntimeError(953, ngDevMode && "Unexpected subscription to destroyed `OutputRef`. The owning directive/component is destroyed.");
    }
    (this.listeners ??= []).push(callback);
    return {
      unsubscribe: () => {
        const idx = this.listeners?.indexOf(callback);
        if (idx !== void 0 && idx !== -1) {
          this.listeners?.splice(idx, 1);
        }
      }
    };
  }
  /** Emits a new value to the output. */
  emit(value) {
    if (this.destroyed) {
      throw new RuntimeError(953, ngDevMode && "Unexpected emit for destroyed `OutputRef`. The owning directive/component is destroyed.");
    }
    if (this.listeners === null) {
      return;
    }
    const previousConsumer = setActiveConsumer(null);
    try {
      for (const listenerFn of this.listeners) {
        try {
          listenerFn(value);
        } catch (err) {
          this.errorHandler?.handleError(err);
        }
      }
    } finally {
      setActiveConsumer(previousConsumer);
    }
  }
};
function getOutputDestroyRef(ref) {
  return ref.destroyRef;
}
function output(opts) {
  ngDevMode && assertInInjectionContext(output);
  return new OutputEmitterRef();
}
function inputFunction(initialValue, opts) {
  ngDevMode && assertInInjectionContext(input);
  return createInputSignal(initialValue, opts);
}
function inputRequiredFunction(opts) {
  ngDevMode && assertInInjectionContext(input);
  return createInputSignal(REQUIRED_UNSET_VALUE, opts);
}
var input = (() => {
  inputFunction.required = inputRequiredFunction;
  return inputFunction;
})();
function injectElementRef() {
  return createElementRef(getCurrentTNode(), getLView());
}
function createElementRef(tNode, lView) {
  return new ElementRef(getNativeByTNode(tNode, lView));
}
var ElementRef = class {
  constructor(nativeElement) {
    this.nativeElement = nativeElement;
  }
  static {
    this.__NG_ELEMENT_ID__ = injectElementRef;
  }
};
function unwrapElementRef(value) {
  return value instanceof ElementRef ? value.nativeElement : value;
}
function symbolIterator() {
  return this._results[Symbol.iterator]();
}
var QueryList = class _QueryList {
  static {
    Symbol.iterator;
  }
  /**
   * Returns `Observable` of `QueryList` notifying the subscriber of changes.
   */
  get changes() {
    return this._changes ??= new EventEmitter();
  }
  /**
   * @param emitDistinctChangesOnly Whether `QueryList.changes` should fire only when actual change
   *     has occurred. Or if it should fire when query is recomputed. (recomputing could resolve in
   *     the same result)
   */
  constructor(_emitDistinctChangesOnly = false) {
    this._emitDistinctChangesOnly = _emitDistinctChangesOnly;
    this.dirty = true;
    this._onDirty = void 0;
    this._results = [];
    this._changesDetected = false;
    this._changes = void 0;
    this.length = 0;
    this.first = void 0;
    this.last = void 0;
    const proto = _QueryList.prototype;
    if (!proto[Symbol.iterator]) proto[Symbol.iterator] = symbolIterator;
  }
  /**
   * Returns the QueryList entry at `index`.
   */
  get(index) {
    return this._results[index];
  }
  /**
   * See
   * [Array.map](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map)
   */
  map(fn) {
    return this._results.map(fn);
  }
  filter(fn) {
    return this._results.filter(fn);
  }
  /**
   * See
   * [Array.find](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/find)
   */
  find(fn) {
    return this._results.find(fn);
  }
  /**
   * See
   * [Array.reduce](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce)
   */
  reduce(fn, init) {
    return this._results.reduce(fn, init);
  }
  /**
   * See
   * [Array.forEach](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach)
   */
  forEach(fn) {
    this._results.forEach(fn);
  }
  /**
   * See
   * [Array.some](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/some)
   */
  some(fn) {
    return this._results.some(fn);
  }
  /**
   * Returns a copy of the internal results list as an Array.
   */
  toArray() {
    return this._results.slice();
  }
  toString() {
    return this._results.toString();
  }
  /**
   * Updates the stored data of the query list, and resets the `dirty` flag to `false`, so that
   * on change detection, it will not notify of changes to the queries, unless a new change
   * occurs.
   *
   * @param resultsTree The query results to store
   * @param identityAccessor Optional function for extracting stable object identity from a value
   *    in the array. This function is executed for each element of the query result list while
   *    comparing current query list with the new one (provided as a first argument of the `reset`
   *    function) to detect if the lists are different. If the function is not provided, elements
   *    are compared as is (without any pre-processing).
   */
  reset(resultsTree, identityAccessor) {
    this.dirty = false;
    const newResultFlat = flatten(resultsTree);
    if (this._changesDetected = !arrayEquals(this._results, newResultFlat, identityAccessor)) {
      this._results = newResultFlat;
      this.length = newResultFlat.length;
      this.last = newResultFlat[this.length - 1];
      this.first = newResultFlat[0];
    }
  }
  /**
   * Triggers a change event by emitting on the `changes` {@link EventEmitter}.
   */
  notifyOnChanges() {
    if (this._changes !== void 0 && (this._changesDetected || !this._emitDistinctChangesOnly)) this._changes.emit(this);
  }
  /** @internal */
  onDirty(cb) {
    this._onDirty = cb;
  }
  /** internal */
  setDirty() {
    this.dirty = true;
    this._onDirty?.();
  }
  /** internal */
  destroy() {
    if (this._changes !== void 0) {
      this._changes.complete();
      this._changes.unsubscribe();
    }
  }
};
var SKIP_HYDRATION_ATTR_NAME = "ngSkipHydration";
var SKIP_HYDRATION_ATTR_NAME_LOWER_CASE = "ngskiphydration";
function hasSkipHydrationAttrOnTNode(tNode) {
  const attrs = tNode.mergedAttrs;
  if (attrs === null) return false;
  for (let i = 0; i < attrs.length; i += 2) {
    const value = attrs[i];
    if (typeof value === "number") return false;
    if (typeof value === "string" && value.toLowerCase() === SKIP_HYDRATION_ATTR_NAME_LOWER_CASE) {
      return true;
    }
  }
  return false;
}
function hasSkipHydrationAttrOnRElement(rNode) {
  return rNode.hasAttribute(SKIP_HYDRATION_ATTR_NAME);
}
function hasInSkipHydrationBlockFlag(tNode) {
  return (tNode.flags & 128) === 128;
}
function isInSkipHydrationBlock(tNode) {
  if (hasInSkipHydrationBlockFlag(tNode)) {
    return true;
  }
  let currentTNode = tNode.parent;
  while (currentTNode) {
    if (hasInSkipHydrationBlockFlag(tNode) || hasSkipHydrationAttrOnTNode(currentTNode)) {
      return true;
    }
    currentTNode = currentTNode.parent;
  }
  return false;
}
function isI18nInSkipHydrationBlock(parentTNode) {
  return hasInSkipHydrationBlockFlag(parentTNode) || hasSkipHydrationAttrOnTNode(parentTNode) || isInSkipHydrationBlock(parentTNode);
}
var TRACKED_LVIEWS = /* @__PURE__ */ new Map();
var uniqueIdCounter = 0;
function getUniqueLViewId() {
  return uniqueIdCounter++;
}
function registerLView(lView) {
  ngDevMode && assertNumber(lView[ID], "LView must have an ID in order to be registered");
  TRACKED_LVIEWS.set(lView[ID], lView);
}
function getLViewById(id) {
  ngDevMode && assertNumber(id, "ID used for LView lookup must be a number");
  return TRACKED_LVIEWS.get(id) || null;
}
function unregisterLView(lView) {
  ngDevMode && assertNumber(lView[ID], "Cannot stop tracking an LView that does not have an ID");
  TRACKED_LVIEWS.delete(lView[ID]);
}
var LContext = class {
  /** Component's parent view data. */
  get lView() {
    return getLViewById(this.lViewId);
  }
  constructor(lViewId, nodeIndex, native) {
    this.lViewId = lViewId;
    this.nodeIndex = nodeIndex;
    this.native = native;
  }
};
function getLContext(target) {
  let mpValue = readPatchedData(target);
  if (mpValue) {
    if (isLView(mpValue)) {
      const lView = mpValue;
      let nodeIndex;
      let component = void 0;
      let directives = void 0;
      if (isComponentInstance(target)) {
        nodeIndex = findViaComponent(lView, target);
        if (nodeIndex == -1) {
          throw new Error("The provided component was not found in the application");
        }
        component = target;
      } else if (isDirectiveInstance(target)) {
        nodeIndex = findViaDirective(lView, target);
        if (nodeIndex == -1) {
          throw new Error("The provided directive was not found in the application");
        }
        directives = getDirectivesAtNodeIndex(nodeIndex, lView);
      } else {
        nodeIndex = findViaNativeElement(lView, target);
        if (nodeIndex == -1) {
          return null;
        }
      }
      const native = unwrapRNode(lView[nodeIndex]);
      const existingCtx = readPatchedData(native);
      const context = existingCtx && !Array.isArray(existingCtx) ? existingCtx : createLContext(lView, nodeIndex, native);
      if (component && context.component === void 0) {
        context.component = component;
        attachPatchData(context.component, context);
      }
      if (directives && context.directives === void 0) {
        context.directives = directives;
        for (let i = 0; i < directives.length; i++) {
          attachPatchData(directives[i], context);
        }
      }
      attachPatchData(context.native, context);
      mpValue = context;
    }
  } else {
    const rElement = target;
    ngDevMode && assertDomNode(rElement);
    let parent = rElement;
    while (parent = parent.parentNode) {
      const parentContext = readPatchedData(parent);
      if (parentContext) {
        const lView = Array.isArray(parentContext) ? parentContext : parentContext.lView;
        if (!lView) {
          return null;
        }
        const index = findViaNativeElement(lView, rElement);
        if (index >= 0) {
          const native = unwrapRNode(lView[index]);
          const context = createLContext(lView, index, native);
          attachPatchData(native, context);
          mpValue = context;
          break;
        }
      }
    }
  }
  return mpValue || null;
}
function createLContext(lView, nodeIndex, native) {
  return new LContext(lView[ID], nodeIndex, native);
}
function getComponentViewByInstance(componentInstance) {
  let patchedData = readPatchedData(componentInstance);
  let lView;
  if (isLView(patchedData)) {
    const contextLView = patchedData;
    const nodeIndex = findViaComponent(contextLView, componentInstance);
    lView = getComponentLViewByIndex(nodeIndex, contextLView);
    const context = createLContext(contextLView, nodeIndex, lView[HOST]);
    context.component = componentInstance;
    attachPatchData(componentInstance, context);
    attachPatchData(context.native, context);
  } else {
    const context = patchedData;
    const contextLView = context.lView;
    ngDevMode && assertLView(contextLView);
    lView = getComponentLViewByIndex(context.nodeIndex, contextLView);
  }
  return lView;
}
var MONKEY_PATCH_KEY_NAME = "__ngContext__";
function attachPatchData(target, data) {
  ngDevMode && assertDefined(target, "Target expected");
  if (isLView(data)) {
    target[MONKEY_PATCH_KEY_NAME] = data[ID];
    registerLView(data);
  } else {
    target[MONKEY_PATCH_KEY_NAME] = data;
  }
}
function readPatchedData(target) {
  ngDevMode && assertDefined(target, "Target expected");
  const data = target[MONKEY_PATCH_KEY_NAME];
  return typeof data === "number" ? getLViewById(data) : data || null;
}
function readPatchedLView(target) {
  const value = readPatchedData(target);
  if (value) {
    return isLView(value) ? value : value.lView;
  }
  return null;
}
function isComponentInstance(instance) {
  return instance && instance.constructor && instance.constructor.ɵcmp;
}
function isDirectiveInstance(instance) {
  return instance && instance.constructor && instance.constructor.ɵdir;
}
function findViaNativeElement(lView, target) {
  const tView = lView[TVIEW];
  for (let i = HEADER_OFFSET; i < tView.bindingStartIndex; i++) {
    if (unwrapRNode(lView[i]) === target) {
      return i;
    }
  }
  return -1;
}
function traverseNextElement(tNode) {
  if (tNode.child) {
    return tNode.child;
  } else if (tNode.next) {
    return tNode.next;
  } else {
    while (tNode.parent && !tNode.parent.next) {
      tNode = tNode.parent;
    }
    return tNode.parent && tNode.parent.next;
  }
}
function findViaComponent(lView, componentInstance) {
  const componentIndices = lView[TVIEW].components;
  if (componentIndices) {
    for (let i = 0; i < componentIndices.length; i++) {
      const elementComponentIndex = componentIndices[i];
      const componentView = getComponentLViewByIndex(elementComponentIndex, lView);
      if (componentView[CONTEXT] === componentInstance) {
        return elementComponentIndex;
      }
    }
  } else {
    const rootComponentView = getComponentLViewByIndex(HEADER_OFFSET, lView);
    const rootComponent = rootComponentView[CONTEXT];
    if (rootComponent === componentInstance) {
      return HEADER_OFFSET;
    }
  }
  return -1;
}
function findViaDirective(lView, directiveInstance) {
  let tNode = lView[TVIEW].firstChild;
  while (tNode) {
    const directiveIndexStart = tNode.directiveStart;
    const directiveIndexEnd = tNode.directiveEnd;
    for (let i = directiveIndexStart; i < directiveIndexEnd; i++) {
      if (lView[i] === directiveInstance) {
        return tNode.index;
      }
    }
    tNode = traverseNextElement(tNode);
  }
  return -1;
}
function getDirectivesAtNodeIndex(nodeIndex, lView) {
  const tNode = lView[TVIEW].data[nodeIndex];
  if (tNode.directiveStart === 0) return EMPTY_ARRAY;
  const results = [];
  for (let i = tNode.directiveStart; i < tNode.directiveEnd; i++) {
    const directiveInstance = lView[i];
    if (!isComponentInstance(directiveInstance)) {
      results.push(directiveInstance);
    }
  }
  return results;
}
function getComponentAtNodeIndex(nodeIndex, lView) {
  const tNode = lView[TVIEW].data[nodeIndex];
  const {
    directiveStart,
    componentOffset
  } = tNode;
  return componentOffset > -1 ? lView[directiveStart + componentOffset] : null;
}
function discoverLocalRefs(lView, nodeIndex) {
  const tNode = lView[TVIEW].data[nodeIndex];
  if (tNode && tNode.localNames) {
    const result = {};
    let localIndex = tNode.index + 1;
    for (let i = 0; i < tNode.localNames.length; i += 2) {
      result[tNode.localNames[i]] = lView[localIndex];
      localIndex++;
    }
    return result;
  }
  return null;
}
function getRootView(componentOrLView) {
  ngDevMode && assertDefined(componentOrLView, "component");
  let lView = isLView(componentOrLView) ? componentOrLView : readPatchedLView(componentOrLView);
  while (lView && !(lView[FLAGS] & 512)) {
    lView = getLViewParent(lView);
  }
  ngDevMode && assertLView(lView);
  return lView;
}
function getRootContext(viewOrComponent) {
  const rootView = getRootView(viewOrComponent);
  ngDevMode && assertDefined(rootView[CONTEXT], "Root view has no context. Perhaps it is disconnected?");
  return rootView[CONTEXT];
}
function getFirstLContainer(lView) {
  return getNearestLContainer(lView[CHILD_HEAD]);
}
function getNextLContainer(container) {
  return getNearestLContainer(container[NEXT]);
}
function getNearestLContainer(viewOrContainer) {
  while (viewOrContainer !== null && !isLContainer(viewOrContainer)) {
    viewOrContainer = viewOrContainer[NEXT];
  }
  return viewOrContainer;
}
function getComponent$1(element) {
  ngDevMode && assertDomElement(element);
  const context = getLContext(element);
  if (context === null) return null;
  if (context.component === void 0) {
    const lView = context.lView;
    if (lView === null) {
      return null;
    }
    context.component = getComponentAtNodeIndex(context.nodeIndex, lView);
  }
  return context.component;
}
function getContext(element) {
  assertDomElement(element);
  const context = getLContext(element);
  const lView = context ? context.lView : null;
  return lView === null ? null : lView[CONTEXT];
}
function getOwningComponent(elementOrDir) {
  const context = getLContext(elementOrDir);
  let lView = context ? context.lView : null;
  if (lView === null) return null;
  let parent;
  while (lView[TVIEW].type === 2 && (parent = getLViewParent(lView))) {
    lView = parent;
  }
  return lView[FLAGS] & 512 ? null : lView[CONTEXT];
}
function getRootComponents(elementOrDir) {
  const lView = readPatchedLView(elementOrDir);
  return lView !== null ? [getRootContext(lView)] : [];
}
function getInjector(elementOrDir) {
  const context = getLContext(elementOrDir);
  const lView = context ? context.lView : null;
  if (lView === null) return Injector.NULL;
  const tNode = lView[TVIEW].data[context.nodeIndex];
  return new NodeInjector(tNode, lView);
}
function getInjectionTokens(element) {
  const context = getLContext(element);
  const lView = context ? context.lView : null;
  if (lView === null) return [];
  const tView = lView[TVIEW];
  const tNode = tView.data[context.nodeIndex];
  const providerTokens = [];
  const startIndex = tNode.providerIndexes & 1048575;
  const endIndex = tNode.directiveEnd;
  for (let i = startIndex; i < endIndex; i++) {
    let value = tView.data[i];
    if (isDirectiveDefHack(value)) {
      value = value.type;
    }
    providerTokens.push(value);
  }
  return providerTokens;
}
function getDirectives(node) {
  if (node instanceof Text) {
    return [];
  }
  const context = getLContext(node);
  const lView = context ? context.lView : null;
  if (lView === null) {
    return [];
  }
  const tView = lView[TVIEW];
  const nodeIndex = context.nodeIndex;
  if (!tView?.data[nodeIndex]) {
    return [];
  }
  if (context.directives === void 0) {
    context.directives = getDirectivesAtNodeIndex(nodeIndex, lView);
  }
  return context.directives === null ? [] : [...context.directives];
}
function getDirectiveMetadata$1(directiveOrComponentInstance) {
  const {
    constructor
  } = directiveOrComponentInstance;
  if (!constructor) {
    throw new Error("Unable to find the instance constructor");
  }
  const componentDef = getComponentDef(constructor);
  if (componentDef) {
    const inputs = extractInputDebugMetadata(componentDef.inputs);
    return {
      inputs,
      outputs: componentDef.outputs,
      encapsulation: componentDef.encapsulation,
      changeDetection: componentDef.onPush ? ChangeDetectionStrategy.OnPush : ChangeDetectionStrategy.Default
    };
  }
  const directiveDef = getDirectiveDef(constructor);
  if (directiveDef) {
    const inputs = extractInputDebugMetadata(directiveDef.inputs);
    return {
      inputs,
      outputs: directiveDef.outputs
    };
  }
  return null;
}
function getLocalRefs(target) {
  const context = getLContext(target);
  if (context === null) return {};
  if (context.localRefs === void 0) {
    const lView = context.lView;
    if (lView === null) {
      return {};
    }
    context.localRefs = discoverLocalRefs(lView, context.nodeIndex);
  }
  return context.localRefs || {};
}
function getHostElement(componentOrDirective) {
  return getLContext(componentOrDirective).native;
}
function getListeners(element) {
  ngDevMode && assertDomElement(element);
  const lContext = getLContext(element);
  const lView = lContext === null ? null : lContext.lView;
  if (lView === null) return [];
  const tView = lView[TVIEW];
  const lCleanup = lView[CLEANUP];
  const tCleanup = tView.cleanup;
  const listeners = [];
  if (tCleanup && lCleanup) {
    for (let i = 0; i < tCleanup.length; ) {
      const firstParam = tCleanup[i++];
      const secondParam = tCleanup[i++];
      if (typeof firstParam === "string") {
        const name = firstParam;
        const listenerElement = unwrapRNode(lView[secondParam]);
        const callback = lCleanup[tCleanup[i++]];
        const useCaptureOrIndx = tCleanup[i++];
        const type = typeof useCaptureOrIndx === "boolean" || useCaptureOrIndx >= 0 ? "dom" : "output";
        const useCapture = typeof useCaptureOrIndx === "boolean" ? useCaptureOrIndx : false;
        if (element == listenerElement) {
          listeners.push({
            element,
            name,
            callback,
            useCapture,
            type
          });
        }
      }
    }
  }
  listeners.sort(sortListeners);
  return listeners;
}
function sortListeners(a, b) {
  if (a.name == b.name) return 0;
  return a.name < b.name ? -1 : 1;
}
function isDirectiveDefHack(obj) {
  return obj.type !== void 0 && obj.declaredInputs !== void 0 && obj.findHostDirectiveDefs !== void 0;
}
function assertDomElement(value) {
  if (typeof Element !== "undefined" && !(value instanceof Element)) {
    throw new Error("Expecting instance of DOM Element");
  }
}
function extractInputDebugMetadata(inputs) {
  const res = {};
  for (const key in inputs) {
    if (!inputs.hasOwnProperty(key)) {
      continue;
    }
    const value = inputs[key];
    if (value === void 0) {
      continue;
    }
    let minifiedName;
    if (Array.isArray(value)) {
      minifiedName = value[0];
    } else {
      minifiedName = value;
    }
    res[key] = minifiedName;
  }
  return res;
}
var DOCUMENT = void 0;
function setDocument(document2) {
  DOCUMENT = document2;
}
function getDocument() {
  if (DOCUMENT !== void 0) {
    return DOCUMENT;
  } else if (typeof document !== "undefined") {
    return document;
  }
  throw new RuntimeError(210, (typeof ngDevMode === "undefined" || ngDevMode) && `The document object is not available in this context. Make sure the DOCUMENT injection token is provided.`);
}
var APP_ID = new InjectionToken(ngDevMode ? "AppId" : "", {
  providedIn: "root",
  factory: () => DEFAULT_APP_ID
});
var DEFAULT_APP_ID = "ng";
var PLATFORM_INITIALIZER = new InjectionToken(ngDevMode ? "Platform Initializer" : "");
var PLATFORM_ID = new InjectionToken(ngDevMode ? "Platform ID" : "", {
  providedIn: "platform",
  factory: () => "unknown"
  // set a default platform name, when none set explicitly
});
var PACKAGE_ROOT_URL = new InjectionToken(ngDevMode ? "Application Packages Root URL" : "");
var ANIMATION_MODULE_TYPE = new InjectionToken(ngDevMode ? "AnimationModuleType" : "");
var CSP_NONCE = new InjectionToken(ngDevMode ? "CSP nonce" : "", {
  providedIn: "root",
  factory: () => {
    return getDocument().body?.querySelector("[ngCspNonce]")?.getAttribute("ngCspNonce") || null;
  }
});
var IMAGE_CONFIG_DEFAULTS = {
  breakpoints: [16, 32, 48, 64, 96, 128, 256, 384, 640, 750, 828, 1080, 1200, 1920, 2048, 3840],
  placeholderResolution: 30,
  disableImageSizeWarning: false,
  disableImageLazyLoadWarning: false
};
var IMAGE_CONFIG = new InjectionToken(ngDevMode ? "ImageConfig" : "", {
  providedIn: "root",
  factory: () => IMAGE_CONFIG_DEFAULTS
});
function makeStateKey(key) {
  return key;
}
function initTransferState() {
  const transferState = new TransferState();
  if (inject(PLATFORM_ID) === "browser") {
    transferState.store = retrieveTransferredState(getDocument(), inject(APP_ID));
  }
  return transferState;
}
var TransferState = class _TransferState {
  constructor() {
    this.store = {};
    this.onSerializeCallbacks = {};
  }
  static {
    this.ɵprov = ɵɵdefineInjectable({
      token: _TransferState,
      providedIn: "root",
      factory: initTransferState
    });
  }
  /**
   * Get the value corresponding to a key. Return `defaultValue` if key is not found.
   */
  get(key, defaultValue) {
    return this.store[key] !== void 0 ? this.store[key] : defaultValue;
  }
  /**
   * Set the value corresponding to a key.
   */
  set(key, value) {
    this.store[key] = value;
  }
  /**
   * Remove a key from the store.
   */
  remove(key) {
    delete this.store[key];
  }
  /**
   * Test whether a key exists in the store.
   */
  hasKey(key) {
    return this.store.hasOwnProperty(key);
  }
  /**
   * Indicates whether the state is empty.
   */
  get isEmpty() {
    return Object.keys(this.store).length === 0;
  }
  /**
   * Register a callback to provide the value for a key when `toJson` is called.
   */
  onSerialize(key, callback) {
    this.onSerializeCallbacks[key] = callback;
  }
  /**
   * Serialize the current state of the store to JSON.
   */
  toJson() {
    for (const key in this.onSerializeCallbacks) {
      if (this.onSerializeCallbacks.hasOwnProperty(key)) {
        try {
          this.store[key] = this.onSerializeCallbacks[key]();
        } catch (e) {
          console.warn("Exception in onSerialize callback: ", e);
        }
      }
    }
    return JSON.stringify(this.store).replace(/</g, "\\u003C");
  }
};
function retrieveTransferredState(doc, appId) {
  const script = doc.getElementById(appId + "-state");
  if (script?.textContent) {
    try {
      return JSON.parse(script.textContent);
    } catch (e) {
      console.warn("Exception while restoring TransferState for app " + appId, e);
    }
  }
  return {};
}
var REFERENCE_NODE_HOST = "h";
var REFERENCE_NODE_BODY = "b";
var NodeNavigationStep;
(function(NodeNavigationStep2) {
  NodeNavigationStep2["FirstChild"] = "f";
  NodeNavigationStep2["NextSibling"] = "n";
})(NodeNavigationStep || (NodeNavigationStep = {}));
var ELEMENT_CONTAINERS = "e";
var TEMPLATES = "t";
var CONTAINERS = "c";
var MULTIPLIER = "x";
var NUM_ROOT_NODES = "r";
var TEMPLATE_ID = "i";
var NODES = "n";
var DISCONNECTED_NODES = "d";
var I18N_DATA = "l";
var TRANSFER_STATE_TOKEN_ID = "__nghData__";
var NGH_DATA_KEY = makeStateKey(TRANSFER_STATE_TOKEN_ID);
var NGH_ATTR_NAME = "ngh";
var SSR_CONTENT_INTEGRITY_MARKER = "nghm";
var _retrieveHydrationInfoImpl = () => null;
function retrieveHydrationInfoImpl(rNode, injector, isRootView2 = false) {
  let nghAttrValue = rNode.getAttribute(NGH_ATTR_NAME);
  if (nghAttrValue == null) return null;
  const [componentViewNgh, rootViewNgh] = nghAttrValue.split("|");
  nghAttrValue = isRootView2 ? rootViewNgh : componentViewNgh;
  if (!nghAttrValue) return null;
  const rootNgh = rootViewNgh ? `|${rootViewNgh}` : "";
  const remainingNgh = isRootView2 ? componentViewNgh : rootNgh;
  let data = {};
  if (nghAttrValue !== "") {
    const transferState = injector.get(TransferState, null, {
      optional: true
    });
    if (transferState !== null) {
      const nghData = transferState.get(NGH_DATA_KEY, []);
      data = nghData[Number(nghAttrValue)];
      ngDevMode && assertDefined(data, "Unable to retrieve hydration info from the TransferState.");
    }
  }
  const dehydratedView = {
    data,
    firstChild: rNode.firstChild ?? null
  };
  if (isRootView2) {
    dehydratedView.firstChild = rNode;
    setSegmentHead(dehydratedView, 0, rNode.nextSibling);
  }
  if (remainingNgh) {
    rNode.setAttribute(NGH_ATTR_NAME, remainingNgh);
  } else {
    rNode.removeAttribute(NGH_ATTR_NAME);
  }
  ngDevMode && markRNodeAsClaimedByHydration(
    rNode,
    /* checkIfAlreadyClaimed */
    false
  );
  ngDevMode && ngDevMode.hydratedComponents++;
  return dehydratedView;
}
function enableRetrieveHydrationInfoImpl() {
  _retrieveHydrationInfoImpl = retrieveHydrationInfoImpl;
}
function retrieveHydrationInfo(rNode, injector, isRootView2 = false) {
  return _retrieveHydrationInfoImpl(rNode, injector, isRootView2);
}
function getLNodeForHydration(viewRef) {
  let lView = viewRef._lView;
  const tView = lView[TVIEW];
  if (tView.type === 2) {
    return null;
  }
  if (isRootView(lView)) {
    lView = lView[HEADER_OFFSET];
  }
  return lView;
}
function getTextNodeContent(node) {
  return node.textContent?.replace(/\s/gm, "");
}
function processTextNodeMarkersBeforeHydration(node) {
  const doc = getDocument();
  const commentNodesIterator = doc.createNodeIterator(node, NodeFilter.SHOW_COMMENT, {
    acceptNode(node2) {
      const content = getTextNodeContent(node2);
      const isTextNodeMarker = content === "ngetn" || content === "ngtns";
      return isTextNodeMarker ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_REJECT;
    }
  });
  let currentNode;
  const nodes = [];
  while (currentNode = commentNodesIterator.nextNode()) {
    nodes.push(currentNode);
  }
  for (const node2 of nodes) {
    if (node2.textContent === "ngetn") {
      node2.replaceWith(doc.createTextNode(""));
    } else {
      node2.remove();
    }
  }
}
var HydrationStatus;
(function(HydrationStatus2) {
  HydrationStatus2["Hydrated"] = "hydrated";
  HydrationStatus2["Skipped"] = "skipped";
  HydrationStatus2["Mismatched"] = "mismatched";
})(HydrationStatus || (HydrationStatus = {}));
var HYDRATION_INFO_KEY = "__ngDebugHydrationInfo__";
function patchHydrationInfo(node, info) {
  node[HYDRATION_INFO_KEY] = info;
}
function readHydrationInfo(node) {
  return node[HYDRATION_INFO_KEY] ?? null;
}
function markRNodeAsClaimedByHydration(node, checkIfAlreadyClaimed = true) {
  if (!ngDevMode) {
    throw new Error("Calling `markRNodeAsClaimedByHydration` in prod mode is not supported and likely a mistake.");
  }
  if (checkIfAlreadyClaimed && isRNodeClaimedForHydration(node)) {
    throw new Error("Trying to claim a node, which was claimed already.");
  }
  patchHydrationInfo(node, {
    status: HydrationStatus.Hydrated
  });
  ngDevMode.hydratedNodes++;
}
function markRNodeAsSkippedByHydration(node) {
  if (!ngDevMode) {
    throw new Error("Calling `markRNodeAsSkippedByHydration` in prod mode is not supported and likely a mistake.");
  }
  patchHydrationInfo(node, {
    status: HydrationStatus.Skipped
  });
  ngDevMode.componentsSkippedHydration++;
}
function markRNodeAsHavingHydrationMismatch(node, expectedNodeDetails = null, actualNodeDetails = null) {
  if (!ngDevMode) {
    throw new Error("Calling `markRNodeAsMismatchedByHydration` in prod mode is not supported and likely a mistake.");
  }
  while (node && !getComponent$1(node)) {
    node = node?.parentNode;
  }
  if (node) {
    patchHydrationInfo(node, {
      status: HydrationStatus.Mismatched,
      expectedNodeDetails,
      actualNodeDetails
    });
  }
}
function isRNodeClaimedForHydration(node) {
  return readHydrationInfo(node)?.status === HydrationStatus.Hydrated;
}
function setSegmentHead(hydrationInfo, index, node) {
  hydrationInfo.segmentHeads ??= {};
  hydrationInfo.segmentHeads[index] = node;
}
function getSegmentHead(hydrationInfo, index) {
  return hydrationInfo.segmentHeads?.[index] ?? null;
}
function getNgContainerSize(hydrationInfo, index) {
  const data = hydrationInfo.data;
  let size = data[ELEMENT_CONTAINERS]?.[index] ?? null;
  if (size === null && data[CONTAINERS]?.[index]) {
    size = calcSerializedContainerSize(hydrationInfo, index);
  }
  return size;
}
function isSerializedElementContainer(hydrationInfo, index) {
  return hydrationInfo.data[ELEMENT_CONTAINERS]?.[index] !== void 0;
}
function getSerializedContainerViews(hydrationInfo, index) {
  return hydrationInfo.data[CONTAINERS]?.[index] ?? null;
}
function calcSerializedContainerSize(hydrationInfo, index) {
  const views = getSerializedContainerViews(hydrationInfo, index) ?? [];
  let numNodes = 0;
  for (let view of views) {
    numNodes += view[NUM_ROOT_NODES] * (view[MULTIPLIER] ?? 1);
  }
  return numNodes;
}
function initDisconnectedNodes(hydrationInfo) {
  if (typeof hydrationInfo.disconnectedNodes === "undefined") {
    const nodeIds = hydrationInfo.data[DISCONNECTED_NODES];
    hydrationInfo.disconnectedNodes = nodeIds ? new Set(nodeIds) : null;
  }
  return hydrationInfo.disconnectedNodes;
}
function isDisconnectedNode$1(hydrationInfo, index) {
  if (typeof hydrationInfo.disconnectedNodes === "undefined") {
    const nodeIds = hydrationInfo.data[DISCONNECTED_NODES];
    hydrationInfo.disconnectedNodes = nodeIds ? new Set(nodeIds) : null;
  }
  return !!initDisconnectedNodes(hydrationInfo)?.has(index);
}
function processTextNodeBeforeSerialization(context, node) {
  const el = node;
  const corruptedTextNodes = context.corruptedTextNodes;
  if (el.textContent === "") {
    corruptedTextNodes.set(
      el,
      "ngetn"
      /* TextNodeMarker.EmptyNode */
    );
  } else if (el.nextSibling?.nodeType === Node.TEXT_NODE) {
    corruptedTextNodes.set(
      el,
      "ngtns"
      /* TextNodeMarker.Separator */
    );
  }
}
var IS_HYDRATION_DOM_REUSE_ENABLED = new InjectionToken(typeof ngDevMode === "undefined" || !!ngDevMode ? "IS_HYDRATION_DOM_REUSE_ENABLED" : "");
var PRESERVE_HOST_CONTENT_DEFAULT = false;
var PRESERVE_HOST_CONTENT = new InjectionToken(typeof ngDevMode === "undefined" || !!ngDevMode ? "PRESERVE_HOST_CONTENT" : "", {
  providedIn: "root",
  factory: () => PRESERVE_HOST_CONTENT_DEFAULT
});
var IS_I18N_HYDRATION_ENABLED = new InjectionToken(typeof ngDevMode === "undefined" || !!ngDevMode ? "IS_I18N_HYDRATION_ENABLED" : "");
var IS_EVENT_REPLAY_ENABLED = new InjectionToken(typeof ngDevMode === "undefined" || !!ngDevMode ? "IS_EVENT_REPLAY_ENABLED" : "");
var EVENT_REPLAY_ENABLED_DEFAULT = false;
var IS_GLOBAL_EVENT_DELEGATION_ENABLED = new InjectionToken(typeof ngDevMode === "undefined" || !!ngDevMode ? "IS_GLOBAL_EVENT_DELEGATION_ENABLED" : "");
var policy$1;
function getPolicy$1() {
  if (policy$1 === void 0) {
    policy$1 = null;
    if (_global.trustedTypes) {
      try {
        policy$1 = _global.trustedTypes.createPolicy("angular", {
          createHTML: (s) => s,
          createScript: (s) => s,
          createScriptURL: (s) => s
        });
      } catch {
      }
    }
  }
  return policy$1;
}
function trustedHTMLFromString(html) {
  return getPolicy$1()?.createHTML(html) || html;
}
function trustedScriptURLFromString(url) {
  return getPolicy$1()?.createScriptURL(url) || url;
}
var policy;
function getPolicy() {
  if (policy === void 0) {
    policy = null;
    if (_global.trustedTypes) {
      try {
        policy = _global.trustedTypes.createPolicy("angular#unsafe-bypass", {
          createHTML: (s) => s,
          createScript: (s) => s,
          createScriptURL: (s) => s
        });
      } catch {
      }
    }
  }
  return policy;
}
function trustedHTMLFromStringBypass(html) {
  return getPolicy()?.createHTML(html) || html;
}
function trustedScriptFromStringBypass(script) {
  return getPolicy()?.createScript(script) || script;
}
function trustedScriptURLFromStringBypass(url) {
  return getPolicy()?.createScriptURL(url) || url;
}
var SafeValueImpl = class {
  constructor(changingThisBreaksApplicationSecurity) {
    this.changingThisBreaksApplicationSecurity = changingThisBreaksApplicationSecurity;
  }
  toString() {
    return `SafeValue must use [property]=binding: ${this.changingThisBreaksApplicationSecurity} (see ${XSS_SECURITY_URL})`;
  }
};
var SafeHtmlImpl = class extends SafeValueImpl {
  getTypeName() {
    return "HTML";
  }
};
var SafeStyleImpl = class extends SafeValueImpl {
  getTypeName() {
    return "Style";
  }
};
var SafeScriptImpl = class extends SafeValueImpl {
  getTypeName() {
    return "Script";
  }
};
var SafeUrlImpl = class extends SafeValueImpl {
  getTypeName() {
    return "URL";
  }
};
var SafeResourceUrlImpl = class extends SafeValueImpl {
  getTypeName() {
    return "ResourceURL";
  }
};
function unwrapSafeValue(value) {
  return value instanceof SafeValueImpl ? value.changingThisBreaksApplicationSecurity : value;
}
function allowSanitizationBypassAndThrow(value, type) {
  const actualType = getSanitizationBypassType(value);
  if (actualType != null && actualType !== type) {
    if (actualType === "ResourceURL" && type === "URL") return true;
    throw new Error(`Required a safe ${type}, got a ${actualType} (see ${XSS_SECURITY_URL})`);
  }
  return actualType === type;
}
function getSanitizationBypassType(value) {
  return value instanceof SafeValueImpl && value.getTypeName() || null;
}
function bypassSanitizationTrustHtml(trustedHtml) {
  return new SafeHtmlImpl(trustedHtml);
}
function bypassSanitizationTrustStyle(trustedStyle) {
  return new SafeStyleImpl(trustedStyle);
}
function bypassSanitizationTrustScript(trustedScript) {
  return new SafeScriptImpl(trustedScript);
}
function bypassSanitizationTrustUrl(trustedUrl) {
  return new SafeUrlImpl(trustedUrl);
}
function bypassSanitizationTrustResourceUrl(trustedResourceUrl) {
  return new SafeResourceUrlImpl(trustedResourceUrl);
}
function getInertBodyHelper(defaultDoc) {
  const inertDocumentHelper = new InertDocumentHelper(defaultDoc);
  return isDOMParserAvailable() ? new DOMParserHelper(inertDocumentHelper) : inertDocumentHelper;
}
var DOMParserHelper = class {
  constructor(inertDocumentHelper) {
    this.inertDocumentHelper = inertDocumentHelper;
  }
  getInertBodyElement(html) {
    html = "<body><remove></remove>" + html;
    try {
      const body = new window.DOMParser().parseFromString(trustedHTMLFromString(html), "text/html").body;
      if (body === null) {
        return this.inertDocumentHelper.getInertBodyElement(html);
      }
      body.firstChild?.remove();
      return body;
    } catch {
      return null;
    }
  }
};
var InertDocumentHelper = class {
  constructor(defaultDoc) {
    this.defaultDoc = defaultDoc;
    this.inertDocument = this.defaultDoc.implementation.createHTMLDocument("sanitization-inert");
  }
  getInertBodyElement(html) {
    const templateEl = this.inertDocument.createElement("template");
    templateEl.innerHTML = trustedHTMLFromString(html);
    return templateEl;
  }
};
function isDOMParserAvailable() {
  try {
    return !!new window.DOMParser().parseFromString(trustedHTMLFromString(""), "text/html");
  } catch {
    return false;
  }
}
var SAFE_URL_PATTERN = /^(?!javascript:)(?:[a-z0-9+.-]+:|[^&:\/?#]*(?:[\/?#]|$))/i;
function _sanitizeUrl(url) {
  url = String(url);
  if (url.match(SAFE_URL_PATTERN)) return url;
  if (typeof ngDevMode === "undefined" || ngDevMode) {
    console.warn(`WARNING: sanitizing unsafe URL value ${url} (see ${XSS_SECURITY_URL})`);
  }
  return "unsafe:" + url;
}
function tagSet(tags) {
  const res = {};
  for (const t of tags.split(",")) res[t] = true;
  return res;
}
function merge(...sets) {
  const res = {};
  for (const s of sets) {
    for (const v in s) {
      if (s.hasOwnProperty(v)) res[v] = true;
    }
  }
  return res;
}
var VOID_ELEMENTS = tagSet("area,br,col,hr,img,wbr");
var OPTIONAL_END_TAG_BLOCK_ELEMENTS = tagSet("colgroup,dd,dt,li,p,tbody,td,tfoot,th,thead,tr");
var OPTIONAL_END_TAG_INLINE_ELEMENTS = tagSet("rp,rt");
var OPTIONAL_END_TAG_ELEMENTS = merge(OPTIONAL_END_TAG_INLINE_ELEMENTS, OPTIONAL_END_TAG_BLOCK_ELEMENTS);
var BLOCK_ELEMENTS = merge(OPTIONAL_END_TAG_BLOCK_ELEMENTS, tagSet("address,article,aside,blockquote,caption,center,del,details,dialog,dir,div,dl,figure,figcaption,footer,h1,h2,h3,h4,h5,h6,header,hgroup,hr,ins,main,map,menu,nav,ol,pre,section,summary,table,ul"));
var INLINE_ELEMENTS = merge(OPTIONAL_END_TAG_INLINE_ELEMENTS, tagSet("a,abbr,acronym,audio,b,bdi,bdo,big,br,cite,code,del,dfn,em,font,i,img,ins,kbd,label,map,mark,picture,q,ruby,rp,rt,s,samp,small,source,span,strike,strong,sub,sup,time,track,tt,u,var,video"));
var VALID_ELEMENTS = merge(VOID_ELEMENTS, BLOCK_ELEMENTS, INLINE_ELEMENTS, OPTIONAL_END_TAG_ELEMENTS);
var URI_ATTRS = tagSet("background,cite,href,itemtype,longdesc,poster,src,xlink:href");
var HTML_ATTRS = tagSet("abbr,accesskey,align,alt,autoplay,axis,bgcolor,border,cellpadding,cellspacing,class,clear,color,cols,colspan,compact,controls,coords,datetime,default,dir,download,face,headers,height,hidden,hreflang,hspace,ismap,itemscope,itemprop,kind,label,lang,language,loop,media,muted,nohref,nowrap,open,preload,rel,rev,role,rows,rowspan,rules,scope,scrolling,shape,size,sizes,span,srclang,srcset,start,summary,tabindex,target,title,translate,type,usemap,valign,value,vspace,width");
var ARIA_ATTRS = tagSet("aria-activedescendant,aria-atomic,aria-autocomplete,aria-busy,aria-checked,aria-colcount,aria-colindex,aria-colspan,aria-controls,aria-current,aria-describedby,aria-details,aria-disabled,aria-dropeffect,aria-errormessage,aria-expanded,aria-flowto,aria-grabbed,aria-haspopup,aria-hidden,aria-invalid,aria-keyshortcuts,aria-label,aria-labelledby,aria-level,aria-live,aria-modal,aria-multiline,aria-multiselectable,aria-orientation,aria-owns,aria-placeholder,aria-posinset,aria-pressed,aria-readonly,aria-relevant,aria-required,aria-roledescription,aria-rowcount,aria-rowindex,aria-rowspan,aria-selected,aria-setsize,aria-sort,aria-valuemax,aria-valuemin,aria-valuenow,aria-valuetext");
var VALID_ATTRS = merge(URI_ATTRS, HTML_ATTRS, ARIA_ATTRS);
var SKIP_TRAVERSING_CONTENT_IF_INVALID_ELEMENTS = tagSet("script,style,template");
var SanitizingHtmlSerializer = class {
  constructor() {
    this.sanitizedSomething = false;
    this.buf = [];
  }
  sanitizeChildren(el) {
    let current = el.firstChild;
    let traverseContent = true;
    let parentNodes = [];
    while (current) {
      if (current.nodeType === Node.ELEMENT_NODE) {
        traverseContent = this.startElement(current);
      } else if (current.nodeType === Node.TEXT_NODE) {
        this.chars(current.nodeValue);
      } else {
        this.sanitizedSomething = true;
      }
      if (traverseContent && current.firstChild) {
        parentNodes.push(current);
        current = getFirstChild(current);
        continue;
      }
      while (current) {
        if (current.nodeType === Node.ELEMENT_NODE) {
          this.endElement(current);
        }
        let next = getNextSibling(current);
        if (next) {
          current = next;
          break;
        }
        current = parentNodes.pop();
      }
    }
    return this.buf.join("");
  }
  /**
   * Sanitizes an opening element tag (if valid) and returns whether the element's contents should
   * be traversed. Element content must always be traversed (even if the element itself is not
   * valid/safe), unless the element is one of `SKIP_TRAVERSING_CONTENT_IF_INVALID_ELEMENTS`.
   *
   * @param element The element to sanitize.
   * @return True if the element's contents should be traversed.
   */
  startElement(element) {
    const tagName = getNodeName(element).toLowerCase();
    if (!VALID_ELEMENTS.hasOwnProperty(tagName)) {
      this.sanitizedSomething = true;
      return !SKIP_TRAVERSING_CONTENT_IF_INVALID_ELEMENTS.hasOwnProperty(tagName);
    }
    this.buf.push("<");
    this.buf.push(tagName);
    const elAttrs = element.attributes;
    for (let i = 0; i < elAttrs.length; i++) {
      const elAttr = elAttrs.item(i);
      const attrName = elAttr.name;
      const lower = attrName.toLowerCase();
      if (!VALID_ATTRS.hasOwnProperty(lower)) {
        this.sanitizedSomething = true;
        continue;
      }
      let value = elAttr.value;
      if (URI_ATTRS[lower]) value = _sanitizeUrl(value);
      this.buf.push(" ", attrName, '="', encodeEntities(value), '"');
    }
    this.buf.push(">");
    return true;
  }
  endElement(current) {
    const tagName = getNodeName(current).toLowerCase();
    if (VALID_ELEMENTS.hasOwnProperty(tagName) && !VOID_ELEMENTS.hasOwnProperty(tagName)) {
      this.buf.push("</");
      this.buf.push(tagName);
      this.buf.push(">");
    }
  }
  chars(chars) {
    this.buf.push(encodeEntities(chars));
  }
};
function isClobberedElement(parentNode, childNode) {
  return (parentNode.compareDocumentPosition(childNode) & Node.DOCUMENT_POSITION_CONTAINED_BY) !== Node.DOCUMENT_POSITION_CONTAINED_BY;
}
function getNextSibling(node) {
  const nextSibling = node.nextSibling;
  if (nextSibling && node !== nextSibling.previousSibling) {
    throw clobberedElementError(nextSibling);
  }
  return nextSibling;
}
function getFirstChild(node) {
  const firstChild = node.firstChild;
  if (firstChild && isClobberedElement(node, firstChild)) {
    throw clobberedElementError(firstChild);
  }
  return firstChild;
}
function getNodeName(node) {
  const nodeName = node.nodeName;
  return typeof nodeName === "string" ? nodeName : "FORM";
}
function clobberedElementError(node) {
  return new Error(`Failed to sanitize html because the element is clobbered: ${node.outerHTML}`);
}
var SURROGATE_PAIR_REGEXP = /[\uD800-\uDBFF][\uDC00-\uDFFF]/g;
var NON_ALPHANUMERIC_REGEXP = /([^\#-~ |!])/g;
function encodeEntities(value) {
  return value.replace(/&/g, "&amp;").replace(SURROGATE_PAIR_REGEXP, function(match) {
    const hi = match.charCodeAt(0);
    const low = match.charCodeAt(1);
    return "&#" + ((hi - 55296) * 1024 + (low - 56320) + 65536) + ";";
  }).replace(NON_ALPHANUMERIC_REGEXP, function(match) {
    return "&#" + match.charCodeAt(0) + ";";
  }).replace(/</g, "&lt;").replace(/>/g, "&gt;");
}
var inertBodyHelper;
function _sanitizeHtml(defaultDoc, unsafeHtmlInput) {
  let inertBodyElement = null;
  try {
    inertBodyHelper = inertBodyHelper || getInertBodyHelper(defaultDoc);
    let unsafeHtml = unsafeHtmlInput ? String(unsafeHtmlInput) : "";
    inertBodyElement = inertBodyHelper.getInertBodyElement(unsafeHtml);
    let mXSSAttempts = 5;
    let parsedHtml = unsafeHtml;
    do {
      if (mXSSAttempts === 0) {
        throw new Error("Failed to sanitize html because the input is unstable");
      }
      mXSSAttempts--;
      unsafeHtml = parsedHtml;
      parsedHtml = inertBodyElement.innerHTML;
      inertBodyElement = inertBodyHelper.getInertBodyElement(unsafeHtml);
    } while (unsafeHtml !== parsedHtml);
    const sanitizer = new SanitizingHtmlSerializer();
    const safeHtml = sanitizer.sanitizeChildren(getTemplateContent(inertBodyElement) || inertBodyElement);
    if ((typeof ngDevMode === "undefined" || ngDevMode) && sanitizer.sanitizedSomething) {
      console.warn(`WARNING: sanitizing HTML stripped some content, see ${XSS_SECURITY_URL}`);
    }
    return trustedHTMLFromString(safeHtml);
  } finally {
    if (inertBodyElement) {
      const parent = getTemplateContent(inertBodyElement) || inertBodyElement;
      while (parent.firstChild) {
        parent.firstChild.remove();
      }
    }
  }
}
function getTemplateContent(el) {
  return "content" in el && isTemplateElement(el) ? el.content : null;
}
function isTemplateElement(el) {
  return el.nodeType === Node.ELEMENT_NODE && el.nodeName === "TEMPLATE";
}
var SecurityContext;
(function(SecurityContext2) {
  SecurityContext2[SecurityContext2["NONE"] = 0] = "NONE";
  SecurityContext2[SecurityContext2["HTML"] = 1] = "HTML";
  SecurityContext2[SecurityContext2["STYLE"] = 2] = "STYLE";
  SecurityContext2[SecurityContext2["SCRIPT"] = 3] = "SCRIPT";
  SecurityContext2[SecurityContext2["URL"] = 4] = "URL";
  SecurityContext2[SecurityContext2["RESOURCE_URL"] = 5] = "RESOURCE_URL";
})(SecurityContext || (SecurityContext = {}));
function ɵɵsanitizeHtml(unsafeHtml) {
  const sanitizer = getSanitizer();
  if (sanitizer) {
    return trustedHTMLFromStringBypass(sanitizer.sanitize(SecurityContext.HTML, unsafeHtml) || "");
  }
  if (allowSanitizationBypassAndThrow(
    unsafeHtml,
    "HTML"
    /* BypassType.Html */
  )) {
    return trustedHTMLFromStringBypass(unwrapSafeValue(unsafeHtml));
  }
  return _sanitizeHtml(getDocument(), renderStringify(unsafeHtml));
}
function ɵɵsanitizeStyle(unsafeStyle) {
  const sanitizer = getSanitizer();
  if (sanitizer) {
    return sanitizer.sanitize(SecurityContext.STYLE, unsafeStyle) || "";
  }
  if (allowSanitizationBypassAndThrow(
    unsafeStyle,
    "Style"
    /* BypassType.Style */
  )) {
    return unwrapSafeValue(unsafeStyle);
  }
  return renderStringify(unsafeStyle);
}
function ɵɵsanitizeUrl(unsafeUrl) {
  const sanitizer = getSanitizer();
  if (sanitizer) {
    return sanitizer.sanitize(SecurityContext.URL, unsafeUrl) || "";
  }
  if (allowSanitizationBypassAndThrow(
    unsafeUrl,
    "URL"
    /* BypassType.Url */
  )) {
    return unwrapSafeValue(unsafeUrl);
  }
  return _sanitizeUrl(renderStringify(unsafeUrl));
}
function ɵɵsanitizeResourceUrl(unsafeResourceUrl) {
  const sanitizer = getSanitizer();
  if (sanitizer) {
    return trustedScriptURLFromStringBypass(sanitizer.sanitize(SecurityContext.RESOURCE_URL, unsafeResourceUrl) || "");
  }
  if (allowSanitizationBypassAndThrow(
    unsafeResourceUrl,
    "ResourceURL"
    /* BypassType.ResourceUrl */
  )) {
    return trustedScriptURLFromStringBypass(unwrapSafeValue(unsafeResourceUrl));
  }
  throw new RuntimeError(904, ngDevMode && `unsafe value used in a resource URL context (see ${XSS_SECURITY_URL})`);
}
function ɵɵsanitizeScript(unsafeScript) {
  const sanitizer = getSanitizer();
  if (sanitizer) {
    return trustedScriptFromStringBypass(sanitizer.sanitize(SecurityContext.SCRIPT, unsafeScript) || "");
  }
  if (allowSanitizationBypassAndThrow(
    unsafeScript,
    "Script"
    /* BypassType.Script */
  )) {
    return trustedScriptFromStringBypass(unwrapSafeValue(unsafeScript));
  }
  throw new RuntimeError(905, ngDevMode && "unsafe value used in a script context");
}
function ɵɵtrustConstantHtml(html) {
  if (ngDevMode && (!Array.isArray(html) || !Array.isArray(html.raw) || html.length !== 1)) {
    throw new Error(`Unexpected interpolation in trusted HTML constant: ${html.join("?")}`);
  }
  return trustedHTMLFromString(html[0]);
}
function ɵɵtrustConstantResourceUrl(url) {
  if (ngDevMode && (!Array.isArray(url) || !Array.isArray(url.raw) || url.length !== 1)) {
    throw new Error(`Unexpected interpolation in trusted URL constant: ${url.join("?")}`);
  }
  return trustedScriptURLFromString(url[0]);
}
function getUrlSanitizer(tag, prop) {
  if (prop === "src" && (tag === "embed" || tag === "frame" || tag === "iframe" || tag === "media" || tag === "script") || prop === "href" && (tag === "base" || tag === "link")) {
    return ɵɵsanitizeResourceUrl;
  }
  return ɵɵsanitizeUrl;
}
function ɵɵsanitizeUrlOrResourceUrl(unsafeUrl, tag, prop) {
  return getUrlSanitizer(tag, prop)(unsafeUrl);
}
function validateAgainstEventProperties(name) {
  if (name.toLowerCase().startsWith("on")) {
    const errorMessage = `Binding to event property '${name}' is disallowed for security reasons, please use (${name.slice(2)})=...
If '${name}' is a directive input, make sure the directive is imported by the current module.`;
    throw new RuntimeError(306, errorMessage);
  }
}
function validateAgainstEventAttributes(name) {
  if (name.toLowerCase().startsWith("on")) {
    const errorMessage = `Binding to event attribute '${name}' is disallowed for security reasons, please use (${name.slice(2)})=...`;
    throw new RuntimeError(306, errorMessage);
  }
}
function getSanitizer() {
  const lView = getLView();
  return lView && lView[ENVIRONMENT].sanitizer;
}
var COMMENT_DISALLOWED = /^>|^->|<!--|-->|--!>|<!-$/g;
var COMMENT_DELIMITER = /(<|>)/g;
var COMMENT_DELIMITER_ESCAPED = "​$1​";
function escapeCommentText(value) {
  return value.replace(COMMENT_DISALLOWED, (text) => text.replace(COMMENT_DELIMITER, COMMENT_DELIMITER_ESCAPED));
}
function normalizeDebugBindingName(name) {
  name = camelCaseToDashCase(name.replace(/[$@]/g, "_"));
  return `ng-reflect-${name}`;
}
var CAMEL_CASE_REGEXP = /([A-Z])/g;
function camelCaseToDashCase(input2) {
  return input2.replace(CAMEL_CASE_REGEXP, (...m) => "-" + m[1].toLowerCase());
}
function normalizeDebugBindingValue(value) {
  try {
    return value != null ? value.toString().slice(0, 30) : value;
  } catch (e) {
    return "[ERROR] Exception while trying to serialize the value";
  }
}
var CUSTOM_ELEMENTS_SCHEMA = {
  name: "custom-elements"
};
var NO_ERRORS_SCHEMA = {
  name: "no-errors-schema"
};
var shouldThrowErrorOnUnknownElement = false;
function ɵsetUnknownElementStrictMode(shouldThrow) {
  shouldThrowErrorOnUnknownElement = shouldThrow;
}
function ɵgetUnknownElementStrictMode() {
  return shouldThrowErrorOnUnknownElement;
}
var shouldThrowErrorOnUnknownProperty = false;
function ɵsetUnknownPropertyStrictMode(shouldThrow) {
  shouldThrowErrorOnUnknownProperty = shouldThrow;
}
function ɵgetUnknownPropertyStrictMode() {
  return shouldThrowErrorOnUnknownProperty;
}
function validateElementIsKnown(element, lView, tagName, schemas, hasDirectives) {
  if (schemas === null) return;
  if (!hasDirectives && tagName !== null) {
    const isUnknown = (
      // Note that we can't check for `typeof HTMLUnknownElement === 'function'` because
      // Domino doesn't expose HTMLUnknownElement globally.
      typeof HTMLUnknownElement !== "undefined" && HTMLUnknownElement && element instanceof HTMLUnknownElement || typeof customElements !== "undefined" && tagName.indexOf("-") > -1 && !customElements.get(tagName)
    );
    if (isUnknown && !matchingSchemas(schemas, tagName)) {
      const isHostStandalone = isHostComponentStandalone(lView);
      const templateLocation = getTemplateLocationDetails(lView);
      const schemas2 = `'${isHostStandalone ? "@Component" : "@NgModule"}.schemas'`;
      let message = `'${tagName}' is not a known element${templateLocation}:
`;
      message += `1. If '${tagName}' is an Angular component, then verify that it is ${isHostStandalone ? "included in the '@Component.imports' of this component" : "a part of an @NgModule where this component is declared"}.
`;
      if (tagName && tagName.indexOf("-") > -1) {
        message += `2. If '${tagName}' is a Web Component then add 'CUSTOM_ELEMENTS_SCHEMA' to the ${schemas2} of this component to suppress this message.`;
      } else {
        message += `2. To allow any element add 'NO_ERRORS_SCHEMA' to the ${schemas2} of this component.`;
      }
      if (shouldThrowErrorOnUnknownElement) {
        throw new RuntimeError(304, message);
      } else {
        console.error(formatRuntimeError(304, message));
      }
    }
  }
}
function isPropertyValid(element, propName, tagName, schemas) {
  if (schemas === null) return true;
  if (matchingSchemas(schemas, tagName) || propName in element || isAnimationProp(propName)) {
    return true;
  }
  return typeof Node === "undefined" || Node === null || !(element instanceof Node);
}
function handleUnknownPropertyError(propName, tagName, nodeType, lView) {
  if (!tagName && nodeType === 4) {
    tagName = "ng-template";
  }
  const isHostStandalone = isHostComponentStandalone(lView);
  const templateLocation = getTemplateLocationDetails(lView);
  let message = `Can't bind to '${propName}' since it isn't a known property of '${tagName}'${templateLocation}.`;
  const schemas = `'${isHostStandalone ? "@Component" : "@NgModule"}.schemas'`;
  const importLocation = isHostStandalone ? "included in the '@Component.imports' of this component" : "a part of an @NgModule where this component is declared";
  if (KNOWN_CONTROL_FLOW_DIRECTIVES.has(propName)) {
    const correspondingImport = KNOWN_CONTROL_FLOW_DIRECTIVES.get(propName);
    message += `
If the '${propName}' is an Angular control flow directive, please make sure that either the '${correspondingImport}' directive or the 'CommonModule' is ${importLocation}.`;
  } else {
    message += `
1. If '${tagName}' is an Angular component and it has the '${propName}' input, then verify that it is ${importLocation}.`;
    if (tagName && tagName.indexOf("-") > -1) {
      message += `
2. If '${tagName}' is a Web Component then add 'CUSTOM_ELEMENTS_SCHEMA' to the ${schemas} of this component to suppress this message.`;
      message += `
3. To allow any property add 'NO_ERRORS_SCHEMA' to the ${schemas} of this component.`;
    } else {
      message += `
2. To allow any property add 'NO_ERRORS_SCHEMA' to the ${schemas} of this component.`;
    }
  }
  reportUnknownPropertyError(message);
}
function reportUnknownPropertyError(message) {
  if (shouldThrowErrorOnUnknownProperty) {
    throw new RuntimeError(303, message);
  } else {
    console.error(formatRuntimeError(303, message));
  }
}
function getDeclarationComponentDef(lView) {
  !ngDevMode && throwError("Must never be called in production mode");
  const declarationLView = lView[DECLARATION_COMPONENT_VIEW];
  const context = declarationLView[CONTEXT];
  if (!context) return null;
  return context.constructor ? getComponentDef(context.constructor) : null;
}
function isHostComponentStandalone(lView) {
  !ngDevMode && throwError("Must never be called in production mode");
  const componentDef = getDeclarationComponentDef(lView);
  return !!componentDef?.standalone;
}
function getTemplateLocationDetails(lView) {
  !ngDevMode && throwError("Must never be called in production mode");
  const hostComponentDef = getDeclarationComponentDef(lView);
  const componentClassName = hostComponentDef?.type?.name;
  return componentClassName ? ` (used in the '${componentClassName}' component template)` : "";
}
var KNOWN_CONTROL_FLOW_DIRECTIVES = /* @__PURE__ */ new Map([["ngIf", "NgIf"], ["ngFor", "NgFor"], ["ngSwitchCase", "NgSwitchCase"], ["ngSwitchDefault", "NgSwitchDefault"]]);
function matchingSchemas(schemas, tagName) {
  if (schemas !== null) {
    for (let i = 0; i < schemas.length; i++) {
      const schema = schemas[i];
      if (schema === NO_ERRORS_SCHEMA || schema === CUSTOM_ELEMENTS_SCHEMA && tagName && tagName.indexOf("-") > -1) {
        return true;
      }
    }
  }
  return false;
}
function ɵɵresolveWindow(element) {
  return element.ownerDocument.defaultView;
}
function ɵɵresolveDocument(element) {
  return element.ownerDocument;
}
function ɵɵresolveBody(element) {
  return element.ownerDocument.body;
}
var INTERPOLATION_DELIMITER = `�`;
function maybeUnwrapFn(value) {
  if (value instanceof Function) {
    return value();
  } else {
    return value;
  }
}
function isPlatformBrowser(injector) {
  return (injector ?? inject(Injector)).get(PLATFORM_ID) === "browser";
}
var VALUE_STRING_LENGTH_LIMIT = 200;
function assertStandaloneComponentType(type) {
  assertComponentDef(type);
  const componentDef = getComponentDef(type);
  if (!componentDef.standalone) {
    throw new RuntimeError(907, `The ${stringifyForError(type)} component is not marked as standalone, but Angular expects to have a standalone component here. Please make sure the ${stringifyForError(type)} component has the \`standalone: true\` flag in the decorator.`);
  }
}
function assertComponentDef(type) {
  if (!getComponentDef(type)) {
    throw new RuntimeError(906, `The ${stringifyForError(type)} is not an Angular component, make sure it has the \`@Component\` decorator.`);
  }
}
function throwMultipleComponentError(tNode, first2, second) {
  throw new RuntimeError(-300, `Multiple components match node with tagname ${tNode.value}: ${stringifyForError(first2)} and ${stringifyForError(second)}`);
}
function throwErrorIfNoChangesMode(creationMode, oldValue, currValue, propName, lView) {
  const hostComponentDef = getDeclarationComponentDef(lView);
  const componentClassName = hostComponentDef?.type?.name;
  const field = propName ? ` for '${propName}'` : "";
  let msg = `ExpressionChangedAfterItHasBeenCheckedError: Expression has changed after it was checked. Previous value${field}: '${formatValue(oldValue)}'. Current value: '${formatValue(currValue)}'.${componentClassName ? ` Expression location: ${componentClassName} component` : ""}`;
  if (creationMode) {
    msg += ` It seems like the view has been created after its parent and its children have been dirty checked. Has it been created in a change detection hook?`;
  }
  throw new RuntimeError(-100, msg);
}
function formatValue(value) {
  let strValue = String(value);
  try {
    if (Array.isArray(value) || strValue === "[object Object]") {
      strValue = JSON.stringify(value);
    }
  } catch (error) {
  }
  return strValue.length > VALUE_STRING_LENGTH_LIMIT ? strValue.substring(0, VALUE_STRING_LENGTH_LIMIT) + "…" : strValue;
}
function constructDetailsForInterpolation(lView, rootIndex, expressionIndex, meta, changedValue) {
  const [propName, prefix, ...chunks] = meta.split(INTERPOLATION_DELIMITER);
  let oldValue = prefix, newValue = prefix;
  for (let i = 0; i < chunks.length; i++) {
    const slotIdx = rootIndex + i;
    oldValue += `${lView[slotIdx]}${chunks[i]}`;
    newValue += `${slotIdx === expressionIndex ? changedValue : lView[slotIdx]}${chunks[i]}`;
  }
  return {
    propName,
    oldValue,
    newValue
  };
}
function getExpressionChangedErrorDetails(lView, bindingIndex, oldValue, newValue) {
  const tData = lView[TVIEW].data;
  const metadata = tData[bindingIndex];
  if (typeof metadata === "string") {
    if (metadata.indexOf(INTERPOLATION_DELIMITER) > -1) {
      return constructDetailsForInterpolation(lView, bindingIndex, bindingIndex, metadata, newValue);
    }
    return {
      propName: metadata,
      oldValue,
      newValue
    };
  }
  if (metadata === null) {
    let idx = bindingIndex - 1;
    while (typeof tData[idx] !== "string" && tData[idx + 1] === null) {
      idx--;
    }
    const meta = tData[idx];
    if (typeof meta === "string") {
      const matches = meta.match(new RegExp(INTERPOLATION_DELIMITER, "g"));
      if (matches && matches.length - 1 > bindingIndex - idx) {
        return constructDetailsForInterpolation(lView, idx, bindingIndex, meta, newValue);
      }
    }
  }
  return {
    propName: void 0,
    oldValue,
    newValue
  };
}
var RendererStyleFlags2;
(function(RendererStyleFlags22) {
  RendererStyleFlags22[RendererStyleFlags22["Important"] = 1] = "Important";
  RendererStyleFlags22[RendererStyleFlags22["DashCase"] = 2] = "DashCase";
})(RendererStyleFlags2 || (RendererStyleFlags2 = {}));
var _icuContainerIterate;
function icuContainerIterate(tIcuContainerNode, lView) {
  return _icuContainerIterate(tIcuContainerNode, lView);
}
function ensureIcuContainerVisitorLoaded(loader) {
  if (_icuContainerIterate === void 0) {
    _icuContainerIterate = loader();
  }
}
function applyToElementOrContainer(action, renderer, parent, lNodeToHandle, beforeNode) {
  if (lNodeToHandle != null) {
    let lContainer;
    let isComponent2 = false;
    if (isLContainer(lNodeToHandle)) {
      lContainer = lNodeToHandle;
    } else if (isLView(lNodeToHandle)) {
      isComponent2 = true;
      ngDevMode && assertDefined(lNodeToHandle[HOST], "HOST must be defined for a component LView");
      lNodeToHandle = lNodeToHandle[HOST];
    }
    const rNode = unwrapRNode(lNodeToHandle);
    if (action === 0 && parent !== null) {
      if (beforeNode == null) {
        nativeAppendChild(renderer, parent, rNode);
      } else {
        nativeInsertBefore(renderer, parent, rNode, beforeNode || null, true);
      }
    } else if (action === 1 && parent !== null) {
      nativeInsertBefore(renderer, parent, rNode, beforeNode || null, true);
    } else if (action === 2) {
      nativeRemoveNode(renderer, rNode, isComponent2);
    } else if (action === 3) {
      ngDevMode && ngDevMode.rendererDestroyNode++;
      renderer.destroyNode(rNode);
    }
    if (lContainer != null) {
      applyContainer(renderer, action, lContainer, parent, beforeNode);
    }
  }
}
function createTextNode(renderer, value) {
  ngDevMode && ngDevMode.rendererCreateTextNode++;
  ngDevMode && ngDevMode.rendererSetText++;
  return renderer.createText(value);
}
function updateTextNode(renderer, rNode, value) {
  ngDevMode && ngDevMode.rendererSetText++;
  renderer.setValue(rNode, value);
}
function createCommentNode(renderer, value) {
  ngDevMode && ngDevMode.rendererCreateComment++;
  return renderer.createComment(escapeCommentText(value));
}
function createElementNode(renderer, name, namespace) {
  ngDevMode && ngDevMode.rendererCreateElement++;
  return renderer.createElement(name, namespace);
}
function removeViewFromDOM(tView, lView) {
  detachViewFromDOM(tView, lView);
  lView[HOST] = null;
  lView[T_HOST] = null;
}
function addViewToDOM(tView, parentTNode, renderer, lView, parentNativeNode, beforeNode) {
  lView[HOST] = parentNativeNode;
  lView[T_HOST] = parentTNode;
  applyView(tView, lView, renderer, 1, parentNativeNode, beforeNode);
}
function detachViewFromDOM(tView, lView) {
  lView[ENVIRONMENT].changeDetectionScheduler?.notify(
    8
    /* NotificationSource.ViewDetachedFromDOM */
  );
  applyView(tView, lView, lView[RENDERER], 2, null, null);
}
function destroyViewTree(rootView) {
  let lViewOrLContainer = rootView[CHILD_HEAD];
  if (!lViewOrLContainer) {
    return cleanUpView(rootView[TVIEW], rootView);
  }
  while (lViewOrLContainer) {
    let next = null;
    if (isLView(lViewOrLContainer)) {
      next = lViewOrLContainer[CHILD_HEAD];
    } else {
      ngDevMode && assertLContainer(lViewOrLContainer);
      const firstView = lViewOrLContainer[CONTAINER_HEADER_OFFSET];
      if (firstView) next = firstView;
    }
    if (!next) {
      while (lViewOrLContainer && !lViewOrLContainer[NEXT] && lViewOrLContainer !== rootView) {
        if (isLView(lViewOrLContainer)) {
          cleanUpView(lViewOrLContainer[TVIEW], lViewOrLContainer);
        }
        lViewOrLContainer = lViewOrLContainer[PARENT];
      }
      if (lViewOrLContainer === null) lViewOrLContainer = rootView;
      if (isLView(lViewOrLContainer)) {
        cleanUpView(lViewOrLContainer[TVIEW], lViewOrLContainer);
      }
      next = lViewOrLContainer && lViewOrLContainer[NEXT];
    }
    lViewOrLContainer = next;
  }
}
function insertView(tView, lView, lContainer, index) {
  ngDevMode && assertLView(lView);
  ngDevMode && assertLContainer(lContainer);
  const indexInContainer = CONTAINER_HEADER_OFFSET + index;
  const containerLength = lContainer.length;
  if (index > 0) {
    lContainer[indexInContainer - 1][NEXT] = lView;
  }
  if (index < containerLength - CONTAINER_HEADER_OFFSET) {
    lView[NEXT] = lContainer[indexInContainer];
    addToArray(lContainer, CONTAINER_HEADER_OFFSET + index, lView);
  } else {
    lContainer.push(lView);
    lView[NEXT] = null;
  }
  lView[PARENT] = lContainer;
  const declarationLContainer = lView[DECLARATION_LCONTAINER];
  if (declarationLContainer !== null && lContainer !== declarationLContainer) {
    trackMovedView(declarationLContainer, lView);
  }
  const lQueries = lView[QUERIES];
  if (lQueries !== null) {
    lQueries.insertView(tView);
  }
  updateAncestorTraversalFlagsOnAttach(lView);
  lView[FLAGS] |= 128;
}
function trackMovedView(declarationContainer, lView) {
  ngDevMode && assertDefined(lView, "LView required");
  ngDevMode && assertLContainer(declarationContainer);
  const movedViews = declarationContainer[MOVED_VIEWS];
  const parent = lView[PARENT];
  ngDevMode && assertDefined(parent, "missing parent");
  if (isLView(parent)) {
    declarationContainer[FLAGS] |= LContainerFlags.HasTransplantedViews;
  } else {
    const insertedComponentLView = parent[PARENT][DECLARATION_COMPONENT_VIEW];
    ngDevMode && assertDefined(insertedComponentLView, "Missing insertedComponentLView");
    const declaredComponentLView = lView[DECLARATION_COMPONENT_VIEW];
    ngDevMode && assertDefined(declaredComponentLView, "Missing declaredComponentLView");
    if (declaredComponentLView !== insertedComponentLView) {
      declarationContainer[FLAGS] |= LContainerFlags.HasTransplantedViews;
    }
  }
  if (movedViews === null) {
    declarationContainer[MOVED_VIEWS] = [lView];
  } else {
    movedViews.push(lView);
  }
}
function detachMovedView(declarationContainer, lView) {
  ngDevMode && assertLContainer(declarationContainer);
  ngDevMode && assertDefined(declarationContainer[MOVED_VIEWS], "A projected view should belong to a non-empty projected views collection");
  const movedViews = declarationContainer[MOVED_VIEWS];
  const declarationViewIndex = movedViews.indexOf(lView);
  movedViews.splice(declarationViewIndex, 1);
}
function detachView(lContainer, removeIndex) {
  if (lContainer.length <= CONTAINER_HEADER_OFFSET) return;
  const indexInContainer = CONTAINER_HEADER_OFFSET + removeIndex;
  const viewToDetach = lContainer[indexInContainer];
  if (viewToDetach) {
    const declarationLContainer = viewToDetach[DECLARATION_LCONTAINER];
    if (declarationLContainer !== null && declarationLContainer !== lContainer) {
      detachMovedView(declarationLContainer, viewToDetach);
    }
    if (removeIndex > 0) {
      lContainer[indexInContainer - 1][NEXT] = viewToDetach[NEXT];
    }
    const removedLView = removeFromArray(lContainer, CONTAINER_HEADER_OFFSET + removeIndex);
    removeViewFromDOM(viewToDetach[TVIEW], viewToDetach);
    const lQueries = removedLView[QUERIES];
    if (lQueries !== null) {
      lQueries.detachView(removedLView[TVIEW]);
    }
    viewToDetach[PARENT] = null;
    viewToDetach[NEXT] = null;
    viewToDetach[FLAGS] &= ~128;
  }
  return viewToDetach;
}
function destroyLView(tView, lView) {
  if (!(lView[FLAGS] & 256)) {
    const renderer = lView[RENDERER];
    if (renderer.destroyNode) {
      applyView(tView, lView, renderer, 3, null, null);
    }
    destroyViewTree(lView);
  }
}
function cleanUpView(tView, lView) {
  if (lView[FLAGS] & 256) {
    return;
  }
  const prevConsumer = setActiveConsumer(null);
  try {
    lView[FLAGS] &= ~128;
    lView[FLAGS] |= 256;
    lView[REACTIVE_TEMPLATE_CONSUMER] && consumerDestroy(lView[REACTIVE_TEMPLATE_CONSUMER]);
    executeOnDestroys(tView, lView);
    processCleanups(tView, lView);
    if (lView[TVIEW].type === 1) {
      ngDevMode && ngDevMode.rendererDestroy++;
      lView[RENDERER].destroy();
    }
    const declarationContainer = lView[DECLARATION_LCONTAINER];
    if (declarationContainer !== null && isLContainer(lView[PARENT])) {
      if (declarationContainer !== lView[PARENT]) {
        detachMovedView(declarationContainer, lView);
      }
      const lQueries = lView[QUERIES];
      if (lQueries !== null) {
        lQueries.detachView(tView);
      }
    }
    unregisterLView(lView);
  } finally {
    setActiveConsumer(prevConsumer);
  }
}
function processCleanups(tView, lView) {
  ngDevMode && assertNotReactive(processCleanups.name);
  const tCleanup = tView.cleanup;
  const lCleanup = lView[CLEANUP];
  if (tCleanup !== null) {
    for (let i = 0; i < tCleanup.length - 1; i += 2) {
      if (typeof tCleanup[i] === "string") {
        const targetIdx = tCleanup[i + 3];
        ngDevMode && assertNumber(targetIdx, "cleanup target must be a number");
        if (targetIdx >= 0) {
          lCleanup[targetIdx]();
        } else {
          lCleanup[-targetIdx].unsubscribe();
        }
        i += 2;
      } else {
        const context = lCleanup[tCleanup[i + 1]];
        tCleanup[i].call(context);
      }
    }
  }
  if (lCleanup !== null) {
    lView[CLEANUP] = null;
  }
  const destroyHooks = lView[ON_DESTROY_HOOKS];
  if (destroyHooks !== null) {
    lView[ON_DESTROY_HOOKS] = null;
    for (let i = 0; i < destroyHooks.length; i++) {
      const destroyHooksFn = destroyHooks[i];
      ngDevMode && assertFunction(destroyHooksFn, "Expecting destroy hook to be a function.");
      destroyHooksFn();
    }
  }
}
function executeOnDestroys(tView, lView) {
  ngDevMode && assertNotReactive(executeOnDestroys.name);
  let destroyHooks;
  if (tView != null && (destroyHooks = tView.destroyHooks) != null) {
    for (let i = 0; i < destroyHooks.length; i += 2) {
      const context = lView[destroyHooks[i]];
      if (!(context instanceof NodeInjectorFactory)) {
        const toCall = destroyHooks[i + 1];
        if (Array.isArray(toCall)) {
          for (let j = 0; j < toCall.length; j += 2) {
            const callContext = context[toCall[j]];
            const hook = toCall[j + 1];
            profiler(4, callContext, hook);
            try {
              hook.call(callContext);
            } finally {
              profiler(5, callContext, hook);
            }
          }
        } else {
          profiler(4, context, toCall);
          try {
            toCall.call(context);
          } finally {
            profiler(5, context, toCall);
          }
        }
      }
    }
  }
}
function getParentRElement(tView, tNode, lView) {
  return getClosestRElement(tView, tNode.parent, lView);
}
function getClosestRElement(tView, tNode, lView) {
  let parentTNode = tNode;
  while (parentTNode !== null && parentTNode.type & (8 | 32 | 128)) {
    tNode = parentTNode;
    parentTNode = tNode.parent;
  }
  if (parentTNode === null) {
    return lView[HOST];
  } else {
    ngDevMode && assertTNodeType(
      parentTNode,
      3 | 4
      /* TNodeType.Container */
    );
    const {
      componentOffset
    } = parentTNode;
    if (componentOffset > -1) {
      ngDevMode && assertTNodeForLView(parentTNode, lView);
      const {
        encapsulation
      } = tView.data[parentTNode.directiveStart + componentOffset];
      if (encapsulation === ViewEncapsulation$1.None || encapsulation === ViewEncapsulation$1.Emulated) {
        return null;
      }
    }
    return getNativeByTNode(parentTNode, lView);
  }
}
function nativeInsertBefore(renderer, parent, child, beforeNode, isMove) {
  ngDevMode && ngDevMode.rendererInsertBefore++;
  renderer.insertBefore(parent, child, beforeNode, isMove);
}
function nativeAppendChild(renderer, parent, child) {
  ngDevMode && ngDevMode.rendererAppendChild++;
  ngDevMode && assertDefined(parent, "parent node must be defined");
  renderer.appendChild(parent, child);
}
function nativeAppendOrInsertBefore(renderer, parent, child, beforeNode, isMove) {
  if (beforeNode !== null) {
    nativeInsertBefore(renderer, parent, child, beforeNode, isMove);
  } else {
    nativeAppendChild(renderer, parent, child);
  }
}
function nativeParentNode(renderer, node) {
  return renderer.parentNode(node);
}
function nativeNextSibling(renderer, node) {
  return renderer.nextSibling(node);
}
function getInsertInFrontOfRNode(parentTNode, currentTNode, lView) {
  return _getInsertInFrontOfRNodeWithI18n(parentTNode, currentTNode, lView);
}
function getInsertInFrontOfRNodeWithNoI18n(parentTNode, currentTNode, lView) {
  if (parentTNode.type & (8 | 32)) {
    return getNativeByTNode(parentTNode, lView);
  }
  return null;
}
var _getInsertInFrontOfRNodeWithI18n = getInsertInFrontOfRNodeWithNoI18n;
var _processI18nInsertBefore;
function setI18nHandling(getInsertInFrontOfRNodeWithI18n2, processI18nInsertBefore2) {
  _getInsertInFrontOfRNodeWithI18n = getInsertInFrontOfRNodeWithI18n2;
  _processI18nInsertBefore = processI18nInsertBefore2;
}
function appendChild(tView, lView, childRNode, childTNode) {
  const parentRNode = getParentRElement(tView, childTNode, lView);
  const renderer = lView[RENDERER];
  const parentTNode = childTNode.parent || lView[T_HOST];
  const anchorNode = getInsertInFrontOfRNode(parentTNode, childTNode, lView);
  if (parentRNode != null) {
    if (Array.isArray(childRNode)) {
      for (let i = 0; i < childRNode.length; i++) {
        nativeAppendOrInsertBefore(renderer, parentRNode, childRNode[i], anchorNode, false);
      }
    } else {
      nativeAppendOrInsertBefore(renderer, parentRNode, childRNode, anchorNode, false);
    }
  }
  _processI18nInsertBefore !== void 0 && _processI18nInsertBefore(renderer, childTNode, lView, childRNode, parentRNode);
}
function getFirstNativeNode(lView, tNode) {
  if (tNode !== null) {
    ngDevMode && assertTNodeType(
      tNode,
      3 | 12 | 32 | 16 | 128
      /* TNodeType.LetDeclaration */
    );
    const tNodeType = tNode.type;
    if (tNodeType & 3) {
      return getNativeByTNode(tNode, lView);
    } else if (tNodeType & 4) {
      return getBeforeNodeForView(-1, lView[tNode.index]);
    } else if (tNodeType & 8) {
      const elIcuContainerChild = tNode.child;
      if (elIcuContainerChild !== null) {
        return getFirstNativeNode(lView, elIcuContainerChild);
      } else {
        const rNodeOrLContainer = lView[tNode.index];
        if (isLContainer(rNodeOrLContainer)) {
          return getBeforeNodeForView(-1, rNodeOrLContainer);
        } else {
          return unwrapRNode(rNodeOrLContainer);
        }
      }
    } else if (tNodeType & 128) {
      return getFirstNativeNode(lView, tNode.next);
    } else if (tNodeType & 32) {
      let nextRNode = icuContainerIterate(tNode, lView);
      let rNode = nextRNode();
      return rNode || unwrapRNode(lView[tNode.index]);
    } else {
      const projectionNodes = getProjectionNodes(lView, tNode);
      if (projectionNodes !== null) {
        if (Array.isArray(projectionNodes)) {
          return projectionNodes[0];
        }
        const parentView = getLViewParent(lView[DECLARATION_COMPONENT_VIEW]);
        ngDevMode && assertParentView(parentView);
        return getFirstNativeNode(parentView, projectionNodes);
      } else {
        return getFirstNativeNode(lView, tNode.next);
      }
    }
  }
  return null;
}
function getProjectionNodes(lView, tNode) {
  if (tNode !== null) {
    const componentView = lView[DECLARATION_COMPONENT_VIEW];
    const componentHost = componentView[T_HOST];
    const slotIdx = tNode.projection;
    ngDevMode && assertProjectionSlots(lView);
    return componentHost.projection[slotIdx];
  }
  return null;
}
function getBeforeNodeForView(viewIndexInContainer, lContainer) {
  const nextViewIndex = CONTAINER_HEADER_OFFSET + viewIndexInContainer + 1;
  if (nextViewIndex < lContainer.length) {
    const lView = lContainer[nextViewIndex];
    const firstTNodeOfView = lView[TVIEW].firstChild;
    if (firstTNodeOfView !== null) {
      return getFirstNativeNode(lView, firstTNodeOfView);
    }
  }
  return lContainer[NATIVE];
}
function nativeRemoveNode(renderer, rNode, isHostElement) {
  ngDevMode && ngDevMode.rendererRemoveNode++;
  renderer.removeChild(null, rNode, isHostElement);
}
function clearElementContents(rElement) {
  rElement.textContent = "";
}
function applyNodes(renderer, action, tNode, lView, parentRElement, beforeNode, isProjection) {
  while (tNode != null) {
    ngDevMode && assertTNodeForLView(tNode, lView);
    if (tNode.type === 128) {
      tNode = tNode.next;
      continue;
    }
    ngDevMode && assertTNodeType(
      tNode,
      3 | 12 | 16 | 32
      /* TNodeType.Icu */
    );
    const rawSlotValue = lView[tNode.index];
    const tNodeType = tNode.type;
    if (isProjection) {
      if (action === 0) {
        rawSlotValue && attachPatchData(unwrapRNode(rawSlotValue), lView);
        tNode.flags |= 2;
      }
    }
    if ((tNode.flags & 32) !== 32) {
      if (tNodeType & 8) {
        applyNodes(renderer, action, tNode.child, lView, parentRElement, beforeNode, false);
        applyToElementOrContainer(action, renderer, parentRElement, rawSlotValue, beforeNode);
      } else if (tNodeType & 32) {
        const nextRNode = icuContainerIterate(tNode, lView);
        let rNode;
        while (rNode = nextRNode()) {
          applyToElementOrContainer(action, renderer, parentRElement, rNode, beforeNode);
        }
        applyToElementOrContainer(action, renderer, parentRElement, rawSlotValue, beforeNode);
      } else if (tNodeType & 16) {
        applyProjectionRecursive(renderer, action, lView, tNode, parentRElement, beforeNode);
      } else {
        ngDevMode && assertTNodeType(
          tNode,
          3 | 4
          /* TNodeType.Container */
        );
        applyToElementOrContainer(action, renderer, parentRElement, rawSlotValue, beforeNode);
      }
    }
    tNode = isProjection ? tNode.projectionNext : tNode.next;
  }
}
function applyView(tView, lView, renderer, action, parentRElement, beforeNode) {
  applyNodes(renderer, action, tView.firstChild, lView, parentRElement, beforeNode, false);
}
function applyProjection(tView, lView, tProjectionNode) {
  const renderer = lView[RENDERER];
  const parentRNode = getParentRElement(tView, tProjectionNode, lView);
  const parentTNode = tProjectionNode.parent || lView[T_HOST];
  let beforeNode = getInsertInFrontOfRNode(parentTNode, tProjectionNode, lView);
  applyProjectionRecursive(renderer, 0, lView, tProjectionNode, parentRNode, beforeNode);
}
function applyProjectionRecursive(renderer, action, lView, tProjectionNode, parentRElement, beforeNode) {
  const componentLView = lView[DECLARATION_COMPONENT_VIEW];
  const componentNode = componentLView[T_HOST];
  ngDevMode && assertEqual(typeof tProjectionNode.projection, "number", "expecting projection index");
  const nodeToProjectOrRNodes = componentNode.projection[tProjectionNode.projection];
  if (Array.isArray(nodeToProjectOrRNodes)) {
    for (let i = 0; i < nodeToProjectOrRNodes.length; i++) {
      const rNode = nodeToProjectOrRNodes[i];
      applyToElementOrContainer(action, renderer, parentRElement, rNode, beforeNode);
    }
  } else {
    let nodeToProject = nodeToProjectOrRNodes;
    const projectedComponentLView = componentLView[PARENT];
    if (hasInSkipHydrationBlockFlag(tProjectionNode)) {
      nodeToProject.flags |= 128;
    }
    applyNodes(renderer, action, nodeToProject, projectedComponentLView, parentRElement, beforeNode, true);
  }
}
function applyContainer(renderer, action, lContainer, parentRElement, beforeNode) {
  ngDevMode && assertLContainer(lContainer);
  const anchor = lContainer[NATIVE];
  const native = unwrapRNode(lContainer);
  if (anchor !== native) {
    applyToElementOrContainer(action, renderer, parentRElement, anchor, beforeNode);
  }
  for (let i = CONTAINER_HEADER_OFFSET; i < lContainer.length; i++) {
    const lView = lContainer[i];
    applyView(lView[TVIEW], lView, renderer, action, parentRElement, anchor);
  }
}
function applyStyling(renderer, isClassBased, rNode, prop, value) {
  if (isClassBased) {
    if (!value) {
      ngDevMode && ngDevMode.rendererRemoveClass++;
      renderer.removeClass(rNode, prop);
    } else {
      ngDevMode && ngDevMode.rendererAddClass++;
      renderer.addClass(rNode, prop);
    }
  } else {
    let flags = prop.indexOf("-") === -1 ? void 0 : RendererStyleFlags2.DashCase;
    if (value == null) {
      ngDevMode && ngDevMode.rendererRemoveStyle++;
      renderer.removeStyle(rNode, prop, flags);
    } else {
      const isImportant = typeof value === "string" ? value.endsWith("!important") : false;
      if (isImportant) {
        value = value.slice(0, -10);
        flags |= RendererStyleFlags2.Important;
      }
      ngDevMode && ngDevMode.rendererSetStyle++;
      renderer.setStyle(rNode, prop, value, flags);
    }
  }
}
function writeDirectStyle(renderer, element, newValue) {
  ngDevMode && assertString(newValue, "'newValue' should be a string");
  renderer.setAttribute(element, "style", newValue);
  ngDevMode && ngDevMode.rendererSetStyle++;
}
function writeDirectClass(renderer, element, newValue) {
  ngDevMode && assertString(newValue, "'newValue' should be a string");
  if (newValue === "") {
    renderer.removeAttribute(element, "class");
  } else {
    renderer.setAttribute(element, "class", newValue);
  }
  ngDevMode && ngDevMode.rendererSetClassName++;
}
function setupStaticAttributes(renderer, element, tNode) {
  const {
    mergedAttrs,
    classes,
    styles
  } = tNode;
  if (mergedAttrs !== null) {
    setUpAttributes(renderer, element, mergedAttrs);
  }
  if (classes !== null) {
    writeDirectClass(renderer, element, classes);
  }
  if (styles !== null) {
    writeDirectStyle(renderer, element, styles);
  }
}
var NO_CHANGE = typeof ngDevMode === "undefined" || ngDevMode ? {
  __brand__: "NO_CHANGE"
} : {};
function ɵɵadvance(delta = 1) {
  ngDevMode && assertGreaterThan(delta, 0, "Can only advance forward");
  selectIndexInternal(getTView(), getLView(), getSelectedIndex() + delta, !!ngDevMode && isInCheckNoChangesMode());
}
function selectIndexInternal(tView, lView, index, checkNoChangesMode) {
  ngDevMode && assertIndexInDeclRange(lView[TVIEW], index);
  if (!checkNoChangesMode) {
    const hooksInitPhaseCompleted = (lView[FLAGS] & 3) === 3;
    if (hooksInitPhaseCompleted) {
      const preOrderCheckHooks = tView.preOrderCheckHooks;
      if (preOrderCheckHooks !== null) {
        executeCheckHooks(lView, preOrderCheckHooks, index);
      }
    } else {
      const preOrderHooks = tView.preOrderHooks;
      if (preOrderHooks !== null) {
        executeInitAndCheckHooks(lView, preOrderHooks, 0, index);
      }
    }
  }
  setSelectedIndex(index);
}
function ɵɵdirectiveInject(token, flags = InjectFlags.Default) {
  const lView = getLView();
  if (lView === null) {
    ngDevMode && assertInjectImplementationNotEqual(ɵɵdirectiveInject);
    return ɵɵinject(token, flags);
  }
  const tNode = getCurrentTNode();
  const value = getOrCreateInjectable(tNode, lView, resolveForwardRef(token), flags);
  ngDevMode && emitInjectEvent(token, value, flags);
  return value;
}
function ɵɵinvalidFactory() {
  const msg = ngDevMode ? `This constructor was not compatible with Dependency Injection.` : "invalid";
  throw new Error(msg);
}
function writeToDirectiveInput(def, instance, publicName, privateName, flags, value) {
  const prevConsumer = setActiveConsumer(null);
  try {
    let inputSignalNode = null;
    if ((flags & InputFlags.SignalBased) !== 0) {
      const field = instance[privateName];
      inputSignalNode = field[SIGNAL];
    }
    if (inputSignalNode !== null && inputSignalNode.transformFn !== void 0) {
      value = inputSignalNode.transformFn(value);
    }
    if ((flags & InputFlags.HasDecoratorInputTransform) !== 0) {
      value = def.inputTransforms[privateName].call(instance, value);
    }
    if (def.setInput !== null) {
      def.setInput(instance, inputSignalNode, value, publicName, privateName);
    } else {
      applyValueToInputField(instance, inputSignalNode, privateName, value);
    }
  } finally {
    setActiveConsumer(prevConsumer);
  }
}
function processHostBindingOpCodes(tView, lView) {
  const hostBindingOpCodes = tView.hostBindingOpCodes;
  if (hostBindingOpCodes === null) return;
  try {
    for (let i = 0; i < hostBindingOpCodes.length; i++) {
      const opCode = hostBindingOpCodes[i];
      if (opCode < 0) {
        setSelectedIndex(~opCode);
      } else {
        const directiveIdx = opCode;
        const bindingRootIndx = hostBindingOpCodes[++i];
        const hostBindingFn = hostBindingOpCodes[++i];
        setBindingRootForHostBindings(bindingRootIndx, directiveIdx);
        const context = lView[directiveIdx];
        hostBindingFn(2, context);
      }
    }
  } finally {
    setSelectedIndex(-1);
  }
}
function createLView(parentLView, tView, context, flags, host, tHostNode, environment, renderer, injector, embeddedViewInjector, hydrationInfo) {
  const lView = tView.blueprint.slice();
  lView[HOST] = host;
  lView[FLAGS] = flags | 4 | 128 | 8 | 64;
  if (embeddedViewInjector !== null || parentLView && parentLView[FLAGS] & 2048) {
    lView[FLAGS] |= 2048;
  }
  resetPreOrderHookFlags(lView);
  ngDevMode && tView.declTNode && parentLView && assertTNodeForLView(tView.declTNode, parentLView);
  lView[PARENT] = lView[DECLARATION_VIEW] = parentLView;
  lView[CONTEXT] = context;
  lView[ENVIRONMENT] = environment || parentLView && parentLView[ENVIRONMENT];
  ngDevMode && assertDefined(lView[ENVIRONMENT], "LViewEnvironment is required");
  lView[RENDERER] = renderer || parentLView && parentLView[RENDERER];
  ngDevMode && assertDefined(lView[RENDERER], "Renderer is required");
  lView[INJECTOR] = injector || parentLView && parentLView[INJECTOR] || null;
  lView[T_HOST] = tHostNode;
  lView[ID] = getUniqueLViewId();
  lView[HYDRATION] = hydrationInfo;
  lView[EMBEDDED_VIEW_INJECTOR] = embeddedViewInjector;
  ngDevMode && assertEqual(tView.type == 2 ? parentLView !== null : true, true, "Embedded views must have parentLView");
  lView[DECLARATION_COMPONENT_VIEW] = tView.type == 2 ? parentLView[DECLARATION_COMPONENT_VIEW] : lView;
  return lView;
}
function getOrCreateTNode(tView, index, type, name, attrs) {
  ngDevMode && index !== 0 && // 0 are bogus nodes and they are OK. See `createContainerRef` in
  // `view_engine_compatibility` for additional context.
  assertGreaterThanOrEqual(index, HEADER_OFFSET, "TNodes can't be in the LView header.");
  ngDevMode && assertPureTNodeType(type);
  let tNode = tView.data[index];
  if (tNode === null) {
    tNode = createTNodeAtIndex(tView, index, type, name, attrs);
    if (isInI18nBlock()) {
      tNode.flags |= 32;
    }
  } else if (tNode.type & 64) {
    tNode.type = type;
    tNode.value = name;
    tNode.attrs = attrs;
    const parent = getCurrentParentTNode();
    tNode.injectorIndex = parent === null ? -1 : parent.injectorIndex;
    ngDevMode && assertTNodeForTView(tNode, tView);
    ngDevMode && assertEqual(index, tNode.index, "Expecting same index");
  }
  setCurrentTNode(tNode, true);
  return tNode;
}
function createTNodeAtIndex(tView, index, type, name, attrs) {
  const currentTNode = getCurrentTNodePlaceholderOk();
  const isParent = isCurrentTNodeParent();
  const parent = isParent ? currentTNode : currentTNode && currentTNode.parent;
  const tNode = tView.data[index] = createTNode(tView, parent, type, index, name, attrs);
  if (tView.firstChild === null) {
    tView.firstChild = tNode;
  }
  if (currentTNode !== null) {
    if (isParent) {
      if (currentTNode.child == null && tNode.parent !== null) {
        currentTNode.child = tNode;
      }
    } else {
      if (currentTNode.next === null) {
        currentTNode.next = tNode;
        tNode.prev = currentTNode;
      }
    }
  }
  return tNode;
}
function allocExpando(tView, lView, numSlotsToAlloc, initialValue) {
  if (numSlotsToAlloc === 0) return -1;
  if (ngDevMode) {
    assertFirstCreatePass(tView);
    assertSame(tView, lView[TVIEW], "`LView` must be associated with `TView`!");
    assertEqual(tView.data.length, lView.length, "Expecting LView to be same size as TView");
    assertEqual(tView.data.length, tView.blueprint.length, "Expecting Blueprint to be same size as TView");
    assertFirstUpdatePass(tView);
  }
  const allocIdx = lView.length;
  for (let i = 0; i < numSlotsToAlloc; i++) {
    lView.push(initialValue);
    tView.blueprint.push(initialValue);
    tView.data.push(null);
  }
  return allocIdx;
}
function executeTemplate(tView, lView, templateFn, rf, context) {
  const prevSelectedIndex = getSelectedIndex();
  const isUpdatePhase = rf & 2;
  try {
    setSelectedIndex(-1);
    if (isUpdatePhase && lView.length > HEADER_OFFSET) {
      selectIndexInternal(tView, lView, HEADER_OFFSET, !!ngDevMode && isInCheckNoChangesMode());
    }
    const preHookType = isUpdatePhase ? 2 : 0;
    profiler(preHookType, context);
    templateFn(rf, context);
  } finally {
    setSelectedIndex(prevSelectedIndex);
    const postHookType = isUpdatePhase ? 3 : 1;
    profiler(postHookType, context);
  }
}
function executeContentQueries(tView, tNode, lView) {
  if (isContentQueryHost(tNode)) {
    const prevConsumer = setActiveConsumer(null);
    try {
      const start = tNode.directiveStart;
      const end = tNode.directiveEnd;
      for (let directiveIndex = start; directiveIndex < end; directiveIndex++) {
        const def = tView.data[directiveIndex];
        if (def.contentQueries) {
          const directiveInstance = lView[directiveIndex];
          ngDevMode && assertDefined(directiveIndex, "Incorrect reference to a directive defining a content query");
          def.contentQueries(1, directiveInstance, directiveIndex);
        }
      }
    } finally {
      setActiveConsumer(prevConsumer);
    }
  }
}
function createDirectivesInstances(tView, lView, tNode) {
  if (!getBindingsEnabled()) return;
  instantiateAllDirectives(tView, lView, tNode, getNativeByTNode(tNode, lView));
  if ((tNode.flags & 64) === 64) {
    invokeDirectivesHostBindings(tView, lView, tNode);
  }
}
function saveResolvedLocalsInData(viewData, tNode, localRefExtractor = getNativeByTNode) {
  const localNames = tNode.localNames;
  if (localNames !== null) {
    let localIndex = tNode.index + 1;
    for (let i = 0; i < localNames.length; i += 2) {
      const index = localNames[i + 1];
      const value = index === -1 ? localRefExtractor(tNode, viewData) : viewData[index];
      viewData[localIndex++] = value;
    }
  }
}
function getOrCreateComponentTView(def) {
  const tView = def.tView;
  if (tView === null || tView.incompleteFirstPass) {
    const declTNode = null;
    return def.tView = createTView(1, declTNode, def.template, def.decls, def.vars, def.directiveDefs, def.pipeDefs, def.viewQuery, def.schemas, def.consts, def.id);
  }
  return tView;
}
function createTView(type, declTNode, templateFn, decls, vars, directives, pipes, viewQuery, schemas, constsOrFactory, ssrId) {
  ngDevMode && ngDevMode.tView++;
  const bindingStartIndex = HEADER_OFFSET + decls;
  const initialViewLength = bindingStartIndex + vars;
  const blueprint = createViewBlueprint(bindingStartIndex, initialViewLength);
  const consts = typeof constsOrFactory === "function" ? constsOrFactory() : constsOrFactory;
  const tView = blueprint[TVIEW] = {
    type,
    blueprint,
    template: templateFn,
    queries: null,
    viewQuery,
    declTNode,
    data: blueprint.slice().fill(null, bindingStartIndex),
    bindingStartIndex,
    expandoStartIndex: initialViewLength,
    hostBindingOpCodes: null,
    firstCreatePass: true,
    firstUpdatePass: true,
    staticViewQueries: false,
    staticContentQueries: false,
    preOrderHooks: null,
    preOrderCheckHooks: null,
    contentHooks: null,
    contentCheckHooks: null,
    viewHooks: null,
    viewCheckHooks: null,
    destroyHooks: null,
    cleanup: null,
    contentQueries: null,
    components: null,
    directiveRegistry: typeof directives === "function" ? directives() : directives,
    pipeRegistry: typeof pipes === "function" ? pipes() : pipes,
    firstChild: null,
    schemas,
    consts,
    incompleteFirstPass: false,
    ssrId
  };
  if (ngDevMode) {
    Object.seal(tView);
  }
  return tView;
}
function createViewBlueprint(bindingStartIndex, initialViewLength) {
  const blueprint = [];
  for (let i = 0; i < initialViewLength; i++) {
    blueprint.push(i < bindingStartIndex ? null : NO_CHANGE);
  }
  return blueprint;
}
function locateHostElement(renderer, elementOrSelector, encapsulation, injector) {
  const preserveHostContent = injector.get(PRESERVE_HOST_CONTENT, PRESERVE_HOST_CONTENT_DEFAULT);
  const preserveContent = preserveHostContent || encapsulation === ViewEncapsulation$1.ShadowDom;
  const rootElement = renderer.selectRootElement(elementOrSelector, preserveContent);
  applyRootElementTransform(rootElement);
  return rootElement;
}
function applyRootElementTransform(rootElement) {
  _applyRootElementTransformImpl(rootElement);
}
var _applyRootElementTransformImpl = () => null;
function applyRootElementTransformImpl(rootElement) {
  if (hasSkipHydrationAttrOnRElement(rootElement)) {
    clearElementContents(rootElement);
  } else {
    processTextNodeMarkersBeforeHydration(rootElement);
  }
}
function enableApplyRootElementTransformImpl() {
  _applyRootElementTransformImpl = applyRootElementTransformImpl;
}
function storeCleanupWithContext(tView, lView, context, cleanupFn) {
  const lCleanup = getOrCreateLViewCleanup(lView);
  ngDevMode && assertDefined(context, "Cleanup context is mandatory when registering framework-level destroy hooks");
  lCleanup.push(context);
  if (tView.firstCreatePass) {
    getOrCreateTViewCleanup(tView).push(cleanupFn, lCleanup.length - 1);
  } else {
    if (ngDevMode) {
      Object.freeze(getOrCreateTViewCleanup(tView));
    }
  }
}
function createTNode(tView, tParent, type, index, value, attrs) {
  ngDevMode && index !== 0 && // 0 are bogus nodes and they are OK. See `createContainerRef` in
  // `view_engine_compatibility` for additional context.
  assertGreaterThanOrEqual(index, HEADER_OFFSET, "TNodes can't be in the LView header.");
  ngDevMode && assertNotSame(attrs, void 0, "'undefined' is not valid value for 'attrs'");
  ngDevMode && ngDevMode.tNode++;
  ngDevMode && tParent && assertTNodeForTView(tParent, tView);
  let injectorIndex = tParent ? tParent.injectorIndex : -1;
  let flags = 0;
  if (isInSkipHydrationBlock$1()) {
    flags |= 128;
  }
  const tNode = {
    type,
    index,
    insertBeforeIndex: null,
    injectorIndex,
    directiveStart: -1,
    directiveEnd: -1,
    directiveStylingLast: -1,
    componentOffset: -1,
    propertyBindings: null,
    flags,
    providerIndexes: 0,
    value,
    attrs,
    mergedAttrs: null,
    localNames: null,
    initialInputs: void 0,
    inputs: null,
    outputs: null,
    tView: null,
    next: null,
    prev: null,
    projectionNext: null,
    child: null,
    parent: tParent,
    projection: null,
    styles: null,
    stylesWithoutHost: null,
    residualStyles: void 0,
    classes: null,
    classesWithoutHost: null,
    residualClasses: void 0,
    classBindings: 0,
    styleBindings: 0
  };
  if (ngDevMode) {
    Object.seal(tNode);
  }
  return tNode;
}
function captureNodeBindings(mode, aliasMap, directiveIndex, bindingsResult, hostDirectiveAliasMap) {
  for (let publicName in aliasMap) {
    if (!aliasMap.hasOwnProperty(publicName)) {
      continue;
    }
    const value = aliasMap[publicName];
    if (value === void 0) {
      continue;
    }
    bindingsResult ??= {};
    let internalName;
    let inputFlags = InputFlags.None;
    if (Array.isArray(value)) {
      internalName = value[0];
      inputFlags = value[1];
    } else {
      internalName = value;
    }
    let finalPublicName = publicName;
    if (hostDirectiveAliasMap !== null) {
      if (!hostDirectiveAliasMap.hasOwnProperty(publicName)) {
        continue;
      }
      finalPublicName = hostDirectiveAliasMap[publicName];
    }
    if (mode === 0) {
      addPropertyBinding(bindingsResult, directiveIndex, finalPublicName, internalName, inputFlags);
    } else {
      addPropertyBinding(bindingsResult, directiveIndex, finalPublicName, internalName);
    }
  }
  return bindingsResult;
}
function addPropertyBinding(bindings, directiveIndex, publicName, internalName, inputFlags) {
  let values;
  if (bindings.hasOwnProperty(publicName)) {
    (values = bindings[publicName]).push(directiveIndex, internalName);
  } else {
    values = bindings[publicName] = [directiveIndex, internalName];
  }
  if (inputFlags !== void 0) {
    values.push(inputFlags);
  }
}
function initializeInputAndOutputAliases(tView, tNode, hostDirectiveDefinitionMap) {
  ngDevMode && assertFirstCreatePass(tView);
  const start = tNode.directiveStart;
  const end = tNode.directiveEnd;
  const tViewData = tView.data;
  const tNodeAttrs = tNode.attrs;
  const inputsFromAttrs = [];
  let inputsStore = null;
  let outputsStore = null;
  for (let directiveIndex = start; directiveIndex < end; directiveIndex++) {
    const directiveDef = tViewData[directiveIndex];
    const aliasData = hostDirectiveDefinitionMap ? hostDirectiveDefinitionMap.get(directiveDef) : null;
    const aliasedInputs = aliasData ? aliasData.inputs : null;
    const aliasedOutputs = aliasData ? aliasData.outputs : null;
    inputsStore = captureNodeBindings(0, directiveDef.inputs, directiveIndex, inputsStore, aliasedInputs);
    outputsStore = captureNodeBindings(1, directiveDef.outputs, directiveIndex, outputsStore, aliasedOutputs);
    const initialInputs = inputsStore !== null && tNodeAttrs !== null && !isInlineTemplate(tNode) ? generateInitialInputs(inputsStore, directiveIndex, tNodeAttrs) : null;
    inputsFromAttrs.push(initialInputs);
  }
  if (inputsStore !== null) {
    if (inputsStore.hasOwnProperty("class")) {
      tNode.flags |= 8;
    }
    if (inputsStore.hasOwnProperty("style")) {
      tNode.flags |= 16;
    }
  }
  tNode.initialInputs = inputsFromAttrs;
  tNode.inputs = inputsStore;
  tNode.outputs = outputsStore;
}
function mapPropName(name) {
  if (name === "class") return "className";
  if (name === "for") return "htmlFor";
  if (name === "formaction") return "formAction";
  if (name === "innerHtml") return "innerHTML";
  if (name === "readonly") return "readOnly";
  if (name === "tabindex") return "tabIndex";
  return name;
}
function elementPropertyInternal(tView, tNode, lView, propName, value, renderer, sanitizer, nativeOnly) {
  ngDevMode && assertNotSame(value, NO_CHANGE, "Incoming value should never be NO_CHANGE.");
  const element = getNativeByTNode(tNode, lView);
  let inputData = tNode.inputs;
  let dataValue;
  if (!nativeOnly && inputData != null && (dataValue = inputData[propName])) {
    setInputsForProperty(tView, lView, dataValue, propName, value);
    if (isComponentHost(tNode)) markDirtyIfOnPush(lView, tNode.index);
    if (ngDevMode) {
      setNgReflectProperties(lView, element, tNode.type, dataValue, value);
    }
  } else if (tNode.type & 3) {
    propName = mapPropName(propName);
    if (ngDevMode) {
      validateAgainstEventProperties(propName);
      if (!isPropertyValid(element, propName, tNode.value, tView.schemas)) {
        handleUnknownPropertyError(propName, tNode.value, tNode.type, lView);
      }
      ngDevMode.rendererSetProperty++;
    }
    value = sanitizer != null ? sanitizer(value, tNode.value || "", propName) : value;
    renderer.setProperty(element, propName, value);
  } else if (tNode.type & 12) {
    if (ngDevMode && !matchingSchemas(tView.schemas, tNode.value)) {
      handleUnknownPropertyError(propName, tNode.value, tNode.type, lView);
    }
  }
}
function markDirtyIfOnPush(lView, viewIndex) {
  ngDevMode && assertLView(lView);
  const childComponentLView = getComponentLViewByIndex(viewIndex, lView);
  if (!(childComponentLView[FLAGS] & 16)) {
    childComponentLView[FLAGS] |= 64;
  }
}
function setNgReflectProperty(lView, element, type, attrName, value) {
  const renderer = lView[RENDERER];
  attrName = normalizeDebugBindingName(attrName);
  const debugValue = normalizeDebugBindingValue(value);
  if (type & 3) {
    if (value == null) {
      renderer.removeAttribute(element, attrName);
    } else {
      renderer.setAttribute(element, attrName, debugValue);
    }
  } else {
    const textContent = escapeCommentText(`bindings=${JSON.stringify({
      [attrName]: debugValue
    }, null, 2)}`);
    renderer.setValue(element, textContent);
  }
}
function setNgReflectProperties(lView, element, type, dataValue, value) {
  if (type & (3 | 4)) {
    for (let i = 0; i < dataValue.length; i += 3) {
      setNgReflectProperty(lView, element, type, dataValue[i + 1], value);
    }
  }
}
function resolveDirectives(tView, lView, tNode, localRefs) {
  ngDevMode && assertFirstCreatePass(tView);
  if (getBindingsEnabled()) {
    const exportsMap = localRefs === null ? null : {
      "": -1
    };
    const matchResult = findDirectiveDefMatches(tView, tNode);
    let directiveDefs;
    let hostDirectiveDefs;
    if (matchResult === null) {
      directiveDefs = hostDirectiveDefs = null;
    } else {
      [directiveDefs, hostDirectiveDefs] = matchResult;
    }
    if (directiveDefs !== null) {
      initializeDirectives(tView, lView, tNode, directiveDefs, exportsMap, hostDirectiveDefs);
    }
    if (exportsMap) cacheMatchingLocalNames(tNode, localRefs, exportsMap);
  }
  tNode.mergedAttrs = mergeHostAttrs(tNode.mergedAttrs, tNode.attrs);
}
function initializeDirectives(tView, lView, tNode, directives, exportsMap, hostDirectiveDefs) {
  ngDevMode && assertFirstCreatePass(tView);
  for (let i = 0; i < directives.length; i++) {
    diPublicInInjector(getOrCreateNodeInjectorForNode(tNode, lView), tView, directives[i].type);
  }
  initTNodeFlags(tNode, tView.data.length, directives.length);
  for (let i = 0; i < directives.length; i++) {
    const def = directives[i];
    if (def.providersResolver) def.providersResolver(def);
  }
  let preOrderHooksFound = false;
  let preOrderCheckHooksFound = false;
  let directiveIdx = allocExpando(tView, lView, directives.length, null);
  ngDevMode && assertSame(directiveIdx, tNode.directiveStart, "TNode.directiveStart should point to just allocated space");
  for (let i = 0; i < directives.length; i++) {
    const def = directives[i];
    tNode.mergedAttrs = mergeHostAttrs(tNode.mergedAttrs, def.hostAttrs);
    configureViewWithDirective(tView, tNode, lView, directiveIdx, def);
    saveNameToExportMap(directiveIdx, def, exportsMap);
    if (def.contentQueries !== null) tNode.flags |= 4;
    if (def.hostBindings !== null || def.hostAttrs !== null || def.hostVars !== 0) tNode.flags |= 64;
    const lifeCycleHooks = def.type.prototype;
    if (!preOrderHooksFound && (lifeCycleHooks.ngOnChanges || lifeCycleHooks.ngOnInit || lifeCycleHooks.ngDoCheck)) {
      (tView.preOrderHooks ??= []).push(tNode.index);
      preOrderHooksFound = true;
    }
    if (!preOrderCheckHooksFound && (lifeCycleHooks.ngOnChanges || lifeCycleHooks.ngDoCheck)) {
      (tView.preOrderCheckHooks ??= []).push(tNode.index);
      preOrderCheckHooksFound = true;
    }
    directiveIdx++;
  }
  initializeInputAndOutputAliases(tView, tNode, hostDirectiveDefs);
}
function registerHostBindingOpCodes(tView, tNode, directiveIdx, directiveVarsIdx, def) {
  ngDevMode && assertFirstCreatePass(tView);
  const hostBindings = def.hostBindings;
  if (hostBindings) {
    let hostBindingOpCodes = tView.hostBindingOpCodes;
    if (hostBindingOpCodes === null) {
      hostBindingOpCodes = tView.hostBindingOpCodes = [];
    }
    const elementIndx = ~tNode.index;
    if (lastSelectedElementIdx(hostBindingOpCodes) != elementIndx) {
      hostBindingOpCodes.push(elementIndx);
    }
    hostBindingOpCodes.push(directiveIdx, directiveVarsIdx, hostBindings);
  }
}
function lastSelectedElementIdx(hostBindingOpCodes) {
  let i = hostBindingOpCodes.length;
  while (i > 0) {
    const value = hostBindingOpCodes[--i];
    if (typeof value === "number" && value < 0) {
      return value;
    }
  }
  return 0;
}
function instantiateAllDirectives(tView, lView, tNode, native) {
  const start = tNode.directiveStart;
  const end = tNode.directiveEnd;
  if (isComponentHost(tNode)) {
    ngDevMode && assertTNodeType(
      tNode,
      3
      /* TNodeType.AnyRNode */
    );
    addComponentLogic(lView, tNode, tView.data[start + tNode.componentOffset]);
  }
  if (!tView.firstCreatePass) {
    getOrCreateNodeInjectorForNode(tNode, lView);
  }
  attachPatchData(native, lView);
  const initialInputs = tNode.initialInputs;
  for (let i = start; i < end; i++) {
    const def = tView.data[i];
    const directive = getNodeInjectable(lView, tView, i, tNode);
    attachPatchData(directive, lView);
    if (initialInputs !== null) {
      setInputsFromAttrs(lView, i - start, directive, def, tNode, initialInputs);
    }
    if (isComponentDef(def)) {
      const componentView = getComponentLViewByIndex(tNode.index, lView);
      componentView[CONTEXT] = getNodeInjectable(lView, tView, i, tNode);
    }
  }
}
function invokeDirectivesHostBindings(tView, lView, tNode) {
  const start = tNode.directiveStart;
  const end = tNode.directiveEnd;
  const elementIndex = tNode.index;
  const currentDirectiveIndex = getCurrentDirectiveIndex();
  try {
    setSelectedIndex(elementIndex);
    for (let dirIndex = start; dirIndex < end; dirIndex++) {
      const def = tView.data[dirIndex];
      const directive = lView[dirIndex];
      setCurrentDirectiveIndex(dirIndex);
      if (def.hostBindings !== null || def.hostVars !== 0 || def.hostAttrs !== null) {
        invokeHostBindingsInCreationMode(def, directive);
      }
    }
  } finally {
    setSelectedIndex(-1);
    setCurrentDirectiveIndex(currentDirectiveIndex);
  }
}
function invokeHostBindingsInCreationMode(def, directive) {
  if (def.hostBindings !== null) {
    def.hostBindings(1, directive);
  }
}
function findDirectiveDefMatches(tView, tNode) {
  ngDevMode && assertFirstCreatePass(tView);
  ngDevMode && assertTNodeType(
    tNode,
    3 | 12
    /* TNodeType.AnyContainer */
  );
  const registry = tView.directiveRegistry;
  let matches = null;
  let hostDirectiveDefs = null;
  if (registry) {
    for (let i = 0; i < registry.length; i++) {
      const def = registry[i];
      if (isNodeMatchingSelectorList(
        tNode,
        def.selectors,
        /* isProjectionMode */
        false
      )) {
        matches || (matches = []);
        if (isComponentDef(def)) {
          if (ngDevMode) {
            assertTNodeType(tNode, 2, `"${tNode.value}" tags cannot be used as component hosts. Please use a different tag to activate the ${stringify(def.type)} component.`);
            if (isComponentHost(tNode)) {
              throwMultipleComponentError(tNode, matches.find(isComponentDef).type, def.type);
            }
          }
          if (def.findHostDirectiveDefs !== null) {
            const hostDirectiveMatches = [];
            hostDirectiveDefs = hostDirectiveDefs || /* @__PURE__ */ new Map();
            def.findHostDirectiveDefs(def, hostDirectiveMatches, hostDirectiveDefs);
            matches.unshift(...hostDirectiveMatches, def);
            const componentOffset = hostDirectiveMatches.length;
            markAsComponentHost(tView, tNode, componentOffset);
          } else {
            matches.unshift(def);
            markAsComponentHost(tView, tNode, 0);
          }
        } else {
          hostDirectiveDefs = hostDirectiveDefs || /* @__PURE__ */ new Map();
          def.findHostDirectiveDefs?.(def, matches, hostDirectiveDefs);
          matches.push(def);
        }
      }
    }
  }
  ngDevMode && matches !== null && assertNoDuplicateDirectives(matches);
  return matches === null ? null : [matches, hostDirectiveDefs];
}
function markAsComponentHost(tView, hostTNode, componentOffset) {
  ngDevMode && assertFirstCreatePass(tView);
  ngDevMode && assertGreaterThan(componentOffset, -1, "componentOffset must be great than -1");
  hostTNode.componentOffset = componentOffset;
  (tView.components ??= []).push(hostTNode.index);
}
function cacheMatchingLocalNames(tNode, localRefs, exportsMap) {
  if (localRefs) {
    const localNames = tNode.localNames = [];
    for (let i = 0; i < localRefs.length; i += 2) {
      const index = exportsMap[localRefs[i + 1]];
      if (index == null) throw new RuntimeError(-301, ngDevMode && `Export of name '${localRefs[i + 1]}' not found!`);
      localNames.push(localRefs[i], index);
    }
  }
}
function saveNameToExportMap(directiveIdx, def, exportsMap) {
  if (exportsMap) {
    if (def.exportAs) {
      for (let i = 0; i < def.exportAs.length; i++) {
        exportsMap[def.exportAs[i]] = directiveIdx;
      }
    }
    if (isComponentDef(def)) exportsMap[""] = directiveIdx;
  }
}
function initTNodeFlags(tNode, index, numberOfDirectives) {
  ngDevMode && assertNotEqual(numberOfDirectives, tNode.directiveEnd - tNode.directiveStart, "Reached the max number of directives");
  tNode.flags |= 1;
  tNode.directiveStart = index;
  tNode.directiveEnd = index + numberOfDirectives;
  tNode.providerIndexes = index;
}
function configureViewWithDirective(tView, tNode, lView, directiveIndex, def) {
  ngDevMode && assertGreaterThanOrEqual(directiveIndex, HEADER_OFFSET, "Must be in Expando section");
  tView.data[directiveIndex] = def;
  const directiveFactory = def.factory || (def.factory = getFactoryDef(def.type, true));
  const nodeInjectorFactory = new NodeInjectorFactory(directiveFactory, isComponentDef(def), ɵɵdirectiveInject);
  tView.blueprint[directiveIndex] = nodeInjectorFactory;
  lView[directiveIndex] = nodeInjectorFactory;
  registerHostBindingOpCodes(tView, tNode, directiveIndex, allocExpando(tView, lView, def.hostVars, NO_CHANGE), def);
}
function addComponentLogic(lView, hostTNode, def) {
  const native = getNativeByTNode(hostTNode, lView);
  const tView = getOrCreateComponentTView(def);
  const rendererFactory = lView[ENVIRONMENT].rendererFactory;
  let lViewFlags = 16;
  if (def.signals) {
    lViewFlags = 4096;
  } else if (def.onPush) {
    lViewFlags = 64;
  }
  const componentView = addToViewTree(lView, createLView(lView, tView, null, lViewFlags, native, hostTNode, null, rendererFactory.createRenderer(native, def), null, null, null));
  lView[hostTNode.index] = componentView;
}
function elementAttributeInternal(tNode, lView, name, value, sanitizer, namespace) {
  if (ngDevMode) {
    assertNotSame(value, NO_CHANGE, "Incoming value should never be NO_CHANGE.");
    validateAgainstEventAttributes(name);
    assertTNodeType(tNode, 2, `Attempted to set attribute \`${name}\` on a container node. Host bindings are not valid on ng-container or ng-template.`);
  }
  const element = getNativeByTNode(tNode, lView);
  setElementAttribute(lView[RENDERER], element, namespace, tNode.value, name, value, sanitizer);
}
function setElementAttribute(renderer, element, namespace, tagName, name, value, sanitizer) {
  if (value == null) {
    ngDevMode && ngDevMode.rendererRemoveAttribute++;
    renderer.removeAttribute(element, name, namespace);
  } else {
    ngDevMode && ngDevMode.rendererSetAttribute++;
    const strValue = sanitizer == null ? renderStringify(value) : sanitizer(value, tagName || "", name);
    renderer.setAttribute(element, name, strValue, namespace);
  }
}
function setInputsFromAttrs(lView, directiveIndex, instance, def, tNode, initialInputData) {
  const initialInputs = initialInputData[directiveIndex];
  if (initialInputs !== null) {
    for (let i = 0; i < initialInputs.length; ) {
      const publicName = initialInputs[i++];
      const privateName = initialInputs[i++];
      const flags = initialInputs[i++];
      const value = initialInputs[i++];
      writeToDirectiveInput(def, instance, publicName, privateName, flags, value);
      if (ngDevMode) {
        const nativeElement = getNativeByTNode(tNode, lView);
        setNgReflectProperty(lView, nativeElement, tNode.type, privateName, value);
      }
    }
  }
}
function generateInitialInputs(inputs, directiveIndex, attrs) {
  let inputsToStore = null;
  let i = 0;
  while (i < attrs.length) {
    const attrName = attrs[i];
    if (attrName === 0) {
      i += 4;
      continue;
    } else if (attrName === 5) {
      i += 2;
      continue;
    }
    if (typeof attrName === "number") break;
    if (inputs.hasOwnProperty(attrName)) {
      if (inputsToStore === null) inputsToStore = [];
      const inputConfig = inputs[attrName];
      for (let j = 0; j < inputConfig.length; j += 3) {
        if (inputConfig[j] === directiveIndex) {
          inputsToStore.push(attrName, inputConfig[j + 1], inputConfig[j + 2], attrs[i + 1]);
          break;
        }
      }
    }
    i += 2;
  }
  return inputsToStore;
}
function createLContainer(hostNative, currentView, native, tNode) {
  ngDevMode && assertLView(currentView);
  const lContainer = [
    hostNative,
    // host native
    true,
    // Boolean `true` in this position signifies that this is an `LContainer`
    0,
    // flags
    currentView,
    // parent
    null,
    // next
    tNode,
    // t_host
    null,
    // dehydrated views
    native,
    // native,
    null,
    // view refs
    null
    // moved views
  ];
  ngDevMode && assertEqual(lContainer.length, CONTAINER_HEADER_OFFSET, "Should allocate correct number of slots for LContainer header.");
  return lContainer;
}
function refreshContentQueries(tView, lView) {
  const contentQueries = tView.contentQueries;
  if (contentQueries !== null) {
    const prevConsumer = setActiveConsumer(null);
    try {
      for (let i = 0; i < contentQueries.length; i += 2) {
        const queryStartIdx = contentQueries[i];
        const directiveDefIdx = contentQueries[i + 1];
        if (directiveDefIdx !== -1) {
          const directiveDef = tView.data[directiveDefIdx];
          ngDevMode && assertDefined(directiveDef, "DirectiveDef not found.");
          ngDevMode && assertDefined(directiveDef.contentQueries, "contentQueries function should be defined");
          setCurrentQueryIndex(queryStartIdx);
          directiveDef.contentQueries(2, lView[directiveDefIdx], directiveDefIdx);
        }
      }
    } finally {
      setActiveConsumer(prevConsumer);
    }
  }
}
function addToViewTree(lView, lViewOrLContainer) {
  if (lView[CHILD_HEAD]) {
    lView[CHILD_TAIL][NEXT] = lViewOrLContainer;
  } else {
    lView[CHILD_HEAD] = lViewOrLContainer;
  }
  lView[CHILD_TAIL] = lViewOrLContainer;
  return lViewOrLContainer;
}
function executeViewQueryFn(flags, viewQueryFn, component) {
  ngDevMode && assertDefined(viewQueryFn, "View queries function to execute must be defined.");
  setCurrentQueryIndex(0);
  const prevConsumer = setActiveConsumer(null);
  try {
    viewQueryFn(flags, component);
  } finally {
    setActiveConsumer(prevConsumer);
  }
}
function storePropertyBindingMetadata(tData, tNode, propertyName, bindingIndex, ...interpolationParts) {
  if (tData[bindingIndex] === null) {
    if (tNode.inputs == null || !tNode.inputs[propertyName]) {
      const propBindingIdxs = tNode.propertyBindings || (tNode.propertyBindings = []);
      propBindingIdxs.push(bindingIndex);
      let bindingMetadata = propertyName;
      if (interpolationParts.length > 0) {
        bindingMetadata += INTERPOLATION_DELIMITER + interpolationParts.join(INTERPOLATION_DELIMITER);
      }
      tData[bindingIndex] = bindingMetadata;
    }
  }
}
function getOrCreateLViewCleanup(view) {
  return view[CLEANUP] ??= [];
}
function getOrCreateTViewCleanup(tView) {
  return tView.cleanup ??= [];
}
function loadComponentRenderer(currentDef, tNode, lView) {
  if (currentDef === null || isComponentDef(currentDef)) {
    lView = unwrapLView(lView[tNode.index]);
  }
  return lView[RENDERER];
}
function handleError(lView, error) {
  const injector = lView[INJECTOR];
  const errorHandler = injector ? injector.get(ErrorHandler, null) : null;
  errorHandler && errorHandler.handleError(error);
}
function setInputsForProperty(tView, lView, inputs, publicName, value) {
  for (let i = 0; i < inputs.length; ) {
    const index = inputs[i++];
    const privateName = inputs[i++];
    const flags = inputs[i++];
    const instance = lView[index];
    ngDevMode && assertIndexInRange(lView, index);
    const def = tView.data[index];
    writeToDirectiveInput(def, instance, publicName, privateName, flags, value);
  }
}
function textBindingInternal(lView, index, value) {
  ngDevMode && assertString(value, "Value should be a string");
  ngDevMode && assertNotSame(value, NO_CHANGE, "value should not be NO_CHANGE");
  ngDevMode && assertIndexInRange(lView, index);
  const element = getNativeByIndex(index, lView);
  ngDevMode && assertDefined(element, "native element should exist");
  updateTextNode(lView[RENDERER], element, value);
}
function renderComponent(hostLView, componentHostIdx) {
  ngDevMode && assertEqual(isCreationMode(hostLView), true, "Should be run in creation mode");
  const componentView = getComponentLViewByIndex(componentHostIdx, hostLView);
  const componentTView = componentView[TVIEW];
  syncViewWithBlueprint(componentTView, componentView);
  const hostRNode = componentView[HOST];
  if (hostRNode !== null && componentView[HYDRATION] === null) {
    componentView[HYDRATION] = retrieveHydrationInfo(hostRNode, componentView[INJECTOR]);
  }
  renderView(componentTView, componentView, componentView[CONTEXT]);
}
function syncViewWithBlueprint(tView, lView) {
  for (let i = lView.length; i < tView.blueprint.length; i++) {
    lView.push(tView.blueprint[i]);
  }
}
function renderView(tView, lView, context) {
  ngDevMode && assertEqual(isCreationMode(lView), true, "Should be run in creation mode");
  ngDevMode && assertNotReactive(renderView.name);
  enterView(lView);
  try {
    const viewQuery = tView.viewQuery;
    if (viewQuery !== null) {
      executeViewQueryFn(1, viewQuery, context);
    }
    const templateFn = tView.template;
    if (templateFn !== null) {
      executeTemplate(tView, lView, templateFn, 1, context);
    }
    if (tView.firstCreatePass) {
      tView.firstCreatePass = false;
    }
    lView[QUERIES]?.finishViewCreation(tView);
    if (tView.staticContentQueries) {
      refreshContentQueries(tView, lView);
    }
    if (tView.staticViewQueries) {
      executeViewQueryFn(2, tView.viewQuery, context);
    }
    const components = tView.components;
    if (components !== null) {
      renderChildComponents(lView, components);
    }
  } catch (error) {
    if (tView.firstCreatePass) {
      tView.incompleteFirstPass = true;
      tView.firstCreatePass = false;
    }
    throw error;
  } finally {
    lView[FLAGS] &= ~4;
    leaveView();
  }
}
function renderChildComponents(hostLView, components) {
  for (let i = 0; i < components.length; i++) {
    renderComponent(hostLView, components[i]);
  }
}
function createAndRenderEmbeddedLView(declarationLView, templateTNode, context, options) {
  const prevConsumer = setActiveConsumer(null);
  try {
    const embeddedTView = templateTNode.tView;
    ngDevMode && assertDefined(embeddedTView, "TView must be defined for a template node.");
    ngDevMode && assertTNodeForLView(templateTNode, declarationLView);
    const isSignalView = declarationLView[FLAGS] & 4096;
    const viewFlags = isSignalView ? 4096 : 16;
    const embeddedLView = createLView(declarationLView, embeddedTView, context, viewFlags, null, templateTNode, null, null, options?.injector ?? null, options?.embeddedViewInjector ?? null, options?.dehydratedView ?? null);
    const declarationLContainer = declarationLView[templateTNode.index];
    ngDevMode && assertLContainer(declarationLContainer);
    embeddedLView[DECLARATION_LCONTAINER] = declarationLContainer;
    const declarationViewLQueries = declarationLView[QUERIES];
    if (declarationViewLQueries !== null) {
      embeddedLView[QUERIES] = declarationViewLQueries.createEmbeddedView(embeddedTView);
    }
    renderView(embeddedTView, embeddedLView, context);
    return embeddedLView;
  } finally {
    setActiveConsumer(prevConsumer);
  }
}
function getLViewFromLContainer(lContainer, index) {
  const adjustedIndex = CONTAINER_HEADER_OFFSET + index;
  if (adjustedIndex < lContainer.length) {
    const lView = lContainer[adjustedIndex];
    ngDevMode && assertLView(lView);
    return lView;
  }
  return void 0;
}
function shouldAddViewToDom(tNode, dehydratedView) {
  return !dehydratedView || dehydratedView.firstChild === null || hasInSkipHydrationBlockFlag(tNode);
}
function addLViewToLContainer(lContainer, lView, index, addToDOM = true) {
  const tView = lView[TVIEW];
  insertView(tView, lView, lContainer, index);
  if (addToDOM) {
    const beforeNode = getBeforeNodeForView(index, lContainer);
    const renderer = lView[RENDERER];
    const parentRNode = nativeParentNode(renderer, lContainer[NATIVE]);
    if (parentRNode !== null) {
      addViewToDOM(tView, lContainer[T_HOST], renderer, lView, parentRNode, beforeNode);
    }
  }
  const hydrationInfo = lView[HYDRATION];
  if (hydrationInfo !== null && hydrationInfo.firstChild !== null) {
    hydrationInfo.firstChild = null;
  }
}
function removeLViewFromLContainer(lContainer, index) {
  const lView = detachView(lContainer, index);
  if (lView !== void 0) {
    destroyLView(lView[TVIEW], lView);
  }
  return lView;
}
function collectNativeNodes(tView, lView, tNode, result, isProjection = false) {
  while (tNode !== null) {
    if (tNode.type === 128) {
      tNode = isProjection ? tNode.projectionNext : tNode.next;
      continue;
    }
    ngDevMode && assertTNodeType(
      tNode,
      3 | 12 | 16 | 32
      /* TNodeType.Icu */
    );
    const lNode = lView[tNode.index];
    if (lNode !== null) {
      result.push(unwrapRNode(lNode));
    }
    if (isLContainer(lNode)) {
      collectNativeNodesInLContainer(lNode, result);
    }
    const tNodeType = tNode.type;
    if (tNodeType & 8) {
      collectNativeNodes(tView, lView, tNode.child, result);
    } else if (tNodeType & 32) {
      const nextRNode = icuContainerIterate(tNode, lView);
      let rNode;
      while (rNode = nextRNode()) {
        result.push(rNode);
      }
    } else if (tNodeType & 16) {
      const nodesInSlot = getProjectionNodes(lView, tNode);
      if (Array.isArray(nodesInSlot)) {
        result.push(...nodesInSlot);
      } else {
        const parentView = getLViewParent(lView[DECLARATION_COMPONENT_VIEW]);
        ngDevMode && assertParentView(parentView);
        collectNativeNodes(parentView[TVIEW], parentView, nodesInSlot, result, true);
      }
    }
    tNode = isProjection ? tNode.projectionNext : tNode.next;
  }
  return result;
}
function collectNativeNodesInLContainer(lContainer, result) {
  for (let i = CONTAINER_HEADER_OFFSET; i < lContainer.length; i++) {
    const lViewInAContainer = lContainer[i];
    const lViewFirstChildTNode = lViewInAContainer[TVIEW].firstChild;
    if (lViewFirstChildTNode !== null) {
      collectNativeNodes(lViewInAContainer[TVIEW], lViewInAContainer, lViewFirstChildTNode, result);
    }
  }
  if (lContainer[NATIVE] !== lContainer[HOST]) {
    result.push(lContainer[NATIVE]);
  }
}
var freeConsumers = [];
function getOrBorrowReactiveLViewConsumer(lView) {
  return lView[REACTIVE_TEMPLATE_CONSUMER] ?? borrowReactiveLViewConsumer(lView);
}
function borrowReactiveLViewConsumer(lView) {
  const consumer = freeConsumers.pop() ?? Object.create(REACTIVE_LVIEW_CONSUMER_NODE);
  consumer.lView = lView;
  return consumer;
}
function maybeReturnReactiveLViewConsumer(consumer) {
  if (consumer.lView[REACTIVE_TEMPLATE_CONSUMER] === consumer) {
    return;
  }
  consumer.lView = null;
  freeConsumers.push(consumer);
}
var REACTIVE_LVIEW_CONSUMER_NODE = __spreadProps(__spreadValues({}, REACTIVE_NODE), {
  consumerIsAlwaysLive: true,
  consumerMarkedDirty: (node) => {
    markAncestorsForTraversal(node.lView);
  },
  consumerOnSignalRead() {
    this.lView[REACTIVE_TEMPLATE_CONSUMER] = this;
  }
});
function getOrCreateTemporaryConsumer(lView) {
  const consumer = lView[REACTIVE_TEMPLATE_CONSUMER] ?? Object.create(TEMPORARY_CONSUMER_NODE);
  consumer.lView = lView;
  return consumer;
}
var TEMPORARY_CONSUMER_NODE = __spreadProps(__spreadValues({}, REACTIVE_NODE), {
  consumerIsAlwaysLive: true,
  consumerMarkedDirty: (node) => {
    let parent = getLViewParent(node.lView);
    while (parent && !viewShouldHaveReactiveConsumer(parent[TVIEW])) {
      parent = getLViewParent(parent);
    }
    if (!parent) {
      return;
    }
    markViewForRefresh(parent);
  },
  consumerOnSignalRead() {
    this.lView[REACTIVE_TEMPLATE_CONSUMER] = this;
  }
});
function viewShouldHaveReactiveConsumer(tView) {
  return tView.type !== 2;
}
var MAXIMUM_REFRESH_RERUNS$1 = 100;
function detectChangesInternal(lView, notifyErrorHandler = true, mode = 0) {
  const environment = lView[ENVIRONMENT];
  const rendererFactory = environment.rendererFactory;
  const checkNoChangesMode = !!ngDevMode && isInCheckNoChangesMode();
  if (!checkNoChangesMode) {
    rendererFactory.begin?.();
  }
  try {
    detectChangesInViewWhileDirty(lView, mode);
  } catch (error) {
    if (notifyErrorHandler) {
      handleError(lView, error);
    }
    throw error;
  } finally {
    if (!checkNoChangesMode) {
      rendererFactory.end?.();
      environment.inlineEffectRunner?.flush();
    }
  }
}
function detectChangesInViewWhileDirty(lView, mode) {
  const lastIsRefreshingViewsValue = isRefreshingViews();
  try {
    setIsRefreshingViews(true);
    detectChangesInView(lView, mode);
    if (ngDevMode && isExhaustiveCheckNoChanges()) {
      return;
    }
    let retries = 0;
    while (requiresRefreshOrTraversal(lView)) {
      if (retries === MAXIMUM_REFRESH_RERUNS$1) {
        throw new RuntimeError(103, ngDevMode && "Infinite change detection while trying to refresh views. There may be components which each cause the other to require a refresh, causing an infinite loop.");
      }
      retries++;
      detectChangesInView(
        lView,
        1
        /* ChangeDetectionMode.Targeted */
      );
    }
  } finally {
    setIsRefreshingViews(lastIsRefreshingViewsValue);
  }
}
function checkNoChangesInternal(lView, mode, notifyErrorHandler = true) {
  setIsInCheckNoChangesMode(mode);
  try {
    detectChangesInternal(lView, notifyErrorHandler);
  } finally {
    setIsInCheckNoChangesMode(CheckNoChangesMode.Off);
  }
}
function refreshView(tView, lView, templateFn, context) {
  ngDevMode && assertEqual(isCreationMode(lView), false, "Should be run in update mode");
  const flags = lView[FLAGS];
  if ((flags & 256) === 256) return;
  const isInCheckNoChangesPass = ngDevMode && isInCheckNoChangesMode();
  const isInExhaustiveCheckNoChangesPass = ngDevMode && isExhaustiveCheckNoChanges();
  !isInCheckNoChangesPass && lView[ENVIRONMENT].inlineEffectRunner?.flush();
  enterView(lView);
  let returnConsumerToPool = true;
  let prevConsumer = null;
  let currentConsumer = null;
  if (!isInCheckNoChangesPass) {
    if (viewShouldHaveReactiveConsumer(tView)) {
      currentConsumer = getOrBorrowReactiveLViewConsumer(lView);
      prevConsumer = consumerBeforeComputation(currentConsumer);
    } else if (getActiveConsumer() === null) {
      returnConsumerToPool = false;
      currentConsumer = getOrCreateTemporaryConsumer(lView);
      prevConsumer = consumerBeforeComputation(currentConsumer);
    } else if (lView[REACTIVE_TEMPLATE_CONSUMER]) {
      consumerDestroy(lView[REACTIVE_TEMPLATE_CONSUMER]);
      lView[REACTIVE_TEMPLATE_CONSUMER] = null;
    }
  }
  try {
    resetPreOrderHookFlags(lView);
    setBindingIndex(tView.bindingStartIndex);
    if (templateFn !== null) {
      executeTemplate(tView, lView, templateFn, 2, context);
    }
    const hooksInitPhaseCompleted = (flags & 3) === 3;
    if (!isInCheckNoChangesPass) {
      if (hooksInitPhaseCompleted) {
        const preOrderCheckHooks = tView.preOrderCheckHooks;
        if (preOrderCheckHooks !== null) {
          executeCheckHooks(lView, preOrderCheckHooks, null);
        }
      } else {
        const preOrderHooks = tView.preOrderHooks;
        if (preOrderHooks !== null) {
          executeInitAndCheckHooks(lView, preOrderHooks, 0, null);
        }
        incrementInitPhaseFlags(
          lView,
          0
          /* InitPhaseState.OnInitHooksToBeRun */
        );
      }
    }
    if (!isInExhaustiveCheckNoChangesPass) {
      markTransplantedViewsForRefresh(lView);
    }
    detectChangesInEmbeddedViews(
      lView,
      0
      /* ChangeDetectionMode.Global */
    );
    if (tView.contentQueries !== null) {
      refreshContentQueries(tView, lView);
    }
    if (!isInCheckNoChangesPass) {
      if (hooksInitPhaseCompleted) {
        const contentCheckHooks = tView.contentCheckHooks;
        if (contentCheckHooks !== null) {
          executeCheckHooks(lView, contentCheckHooks);
        }
      } else {
        const contentHooks = tView.contentHooks;
        if (contentHooks !== null) {
          executeInitAndCheckHooks(
            lView,
            contentHooks,
            1
            /* InitPhaseState.AfterContentInitHooksToBeRun */
          );
        }
        incrementInitPhaseFlags(
          lView,
          1
          /* InitPhaseState.AfterContentInitHooksToBeRun */
        );
      }
    }
    processHostBindingOpCodes(tView, lView);
    const components = tView.components;
    if (components !== null) {
      detectChangesInChildComponents(
        lView,
        components,
        0
        /* ChangeDetectionMode.Global */
      );
    }
    const viewQuery = tView.viewQuery;
    if (viewQuery !== null) {
      executeViewQueryFn(2, viewQuery, context);
    }
    if (!isInCheckNoChangesPass) {
      if (hooksInitPhaseCompleted) {
        const viewCheckHooks = tView.viewCheckHooks;
        if (viewCheckHooks !== null) {
          executeCheckHooks(lView, viewCheckHooks);
        }
      } else {
        const viewHooks = tView.viewHooks;
        if (viewHooks !== null) {
          executeInitAndCheckHooks(
            lView,
            viewHooks,
            2
            /* InitPhaseState.AfterViewInitHooksToBeRun */
          );
        }
        incrementInitPhaseFlags(
          lView,
          2
          /* InitPhaseState.AfterViewInitHooksToBeRun */
        );
      }
    }
    if (tView.firstUpdatePass === true) {
      tView.firstUpdatePass = false;
    }
    if (lView[EFFECTS_TO_SCHEDULE]) {
      for (const notifyEffect of lView[EFFECTS_TO_SCHEDULE]) {
        notifyEffect();
      }
      lView[EFFECTS_TO_SCHEDULE] = null;
    }
    if (!isInCheckNoChangesPass) {
      lView[FLAGS] &= ~(64 | 8);
    }
  } catch (e) {
    if (!isInCheckNoChangesPass) {
      markAncestorsForTraversal(lView);
    }
    throw e;
  } finally {
    if (currentConsumer !== null) {
      consumerAfterComputation(currentConsumer, prevConsumer);
      if (returnConsumerToPool) {
        maybeReturnReactiveLViewConsumer(currentConsumer);
      }
    }
    leaveView();
  }
}
function detectChangesInEmbeddedViews(lView, mode) {
  for (let lContainer = getFirstLContainer(lView); lContainer !== null; lContainer = getNextLContainer(lContainer)) {
    for (let i = CONTAINER_HEADER_OFFSET; i < lContainer.length; i++) {
      const embeddedLView = lContainer[i];
      detectChangesInViewIfAttached(embeddedLView, mode);
    }
  }
}
function markTransplantedViewsForRefresh(lView) {
  for (let lContainer = getFirstLContainer(lView); lContainer !== null; lContainer = getNextLContainer(lContainer)) {
    if (!(lContainer[FLAGS] & LContainerFlags.HasTransplantedViews)) continue;
    const movedViews = lContainer[MOVED_VIEWS];
    ngDevMode && assertDefined(movedViews, "Transplanted View flags set but missing MOVED_VIEWS");
    for (let i = 0; i < movedViews.length; i++) {
      const movedLView = movedViews[i];
      markViewForRefresh(movedLView);
    }
  }
}
function detectChangesInComponent(hostLView, componentHostIdx, mode) {
  ngDevMode && assertEqual(isCreationMode(hostLView), false, "Should be run in update mode");
  const componentView = getComponentLViewByIndex(componentHostIdx, hostLView);
  detectChangesInViewIfAttached(componentView, mode);
}
function detectChangesInViewIfAttached(lView, mode) {
  if (!viewAttachedToChangeDetector(lView)) {
    return;
  }
  detectChangesInView(lView, mode);
}
function detectChangesInView(lView, mode) {
  const isInCheckNoChangesPass = ngDevMode && isInCheckNoChangesMode();
  const tView = lView[TVIEW];
  const flags = lView[FLAGS];
  const consumer = lView[REACTIVE_TEMPLATE_CONSUMER];
  let shouldRefreshView = !!(mode === 0 && flags & 16);
  shouldRefreshView ||= !!(flags & 64 && mode === 0 && !isInCheckNoChangesPass);
  shouldRefreshView ||= !!(flags & 1024);
  shouldRefreshView ||= !!(consumer?.dirty && consumerPollProducersForChange(consumer));
  shouldRefreshView ||= !!(ngDevMode && isExhaustiveCheckNoChanges());
  if (consumer) {
    consumer.dirty = false;
  }
  lView[FLAGS] &= ~(8192 | 1024);
  if (shouldRefreshView) {
    refreshView(tView, lView, tView.template, lView[CONTEXT]);
  } else if (flags & 8192) {
    detectChangesInEmbeddedViews(
      lView,
      1
      /* ChangeDetectionMode.Targeted */
    );
    const components = tView.components;
    if (components !== null) {
      detectChangesInChildComponents(
        lView,
        components,
        1
        /* ChangeDetectionMode.Targeted */
      );
    }
  }
}
function detectChangesInChildComponents(hostLView, components, mode) {
  for (let i = 0; i < components.length; i++) {
    detectChangesInComponent(hostLView, components[i], mode);
  }
}
function markViewDirty(lView, source) {
  const dirtyBitsToUse = isRefreshingViews() ? (
    // When we are actively refreshing views, we only use the `Dirty` bit to mark a view
    64
  ) : (
    // When we are not actively refreshing a view tree, it is absolutely
    // valid to update state and mark views dirty. We use the `RefreshView` flag in this
    // case to allow synchronously rerunning change detection. This applies today to
    // afterRender hooks as well as animation listeners which execute after detecting
    // changes in a view when the render factory flushes.
    1024 | 64
  );
  lView[ENVIRONMENT].changeDetectionScheduler?.notify(source);
  while (lView) {
    lView[FLAGS] |= dirtyBitsToUse;
    const parent = getLViewParent(lView);
    if (isRootView(lView) && !parent) {
      return lView;
    }
    lView = parent;
  }
  return null;
}
var ViewRef$1 = class {
  get rootNodes() {
    const lView = this._lView;
    const tView = lView[TVIEW];
    return collectNativeNodes(tView, lView, tView.firstChild, []);
  }
  constructor(_lView, _cdRefInjectingView, notifyErrorHandler = true) {
    this._lView = _lView;
    this._cdRefInjectingView = _cdRefInjectingView;
    this.notifyErrorHandler = notifyErrorHandler;
    this._appRef = null;
    this._attachedToViewContainer = false;
  }
  get context() {
    return this._lView[CONTEXT];
  }
  /**
   * @deprecated Replacing the full context object is not supported. Modify the context
   *   directly, or consider using a `Proxy` if you need to replace the full object.
   * // TODO(devversion): Remove this.
   */
  set context(value) {
    if (ngDevMode) {
      console.warn("Angular: Replacing the `context` object of an `EmbeddedViewRef` is deprecated.");
    }
    this._lView[CONTEXT] = value;
  }
  get destroyed() {
    return (this._lView[FLAGS] & 256) === 256;
  }
  destroy() {
    if (this._appRef) {
      this._appRef.detachView(this);
    } else if (this._attachedToViewContainer) {
      const parent = this._lView[PARENT];
      if (isLContainer(parent)) {
        const viewRefs = parent[VIEW_REFS];
        const index = viewRefs ? viewRefs.indexOf(this) : -1;
        if (index > -1) {
          ngDevMode && assertEqual(index, parent.indexOf(this._lView) - CONTAINER_HEADER_OFFSET, "An attached view should be in the same position within its container as its ViewRef in the VIEW_REFS array.");
          detachView(parent, index);
          removeFromArray(viewRefs, index);
        }
      }
      this._attachedToViewContainer = false;
    }
    destroyLView(this._lView[TVIEW], this._lView);
  }
  onDestroy(callback) {
    storeLViewOnDestroy(this._lView, callback);
  }
  /**
   * Marks a view and all of its ancestors dirty.
   *
   * This can be used to ensure an {@link ChangeDetectionStrategy#OnPush} component is
   * checked when it needs to be re-rendered but the two normal triggers haven't marked it
   * dirty (i.e. inputs haven't changed and events haven't fired in the view).
   *
   * <!-- TODO: Add a link to a chapter on OnPush components -->
   *
   * @usageNotes
   * ### Example
   *
   * ```typescript
   * @Component({
   *   selector: 'app-root',
   *   template: `Number of ticks: {{numberOfTicks}}`
   *   changeDetection: ChangeDetectionStrategy.OnPush,
   * })
   * class AppComponent {
   *   numberOfTicks = 0;
   *
   *   constructor(private ref: ChangeDetectorRef) {
   *     setInterval(() => {
   *       this.numberOfTicks++;
   *       // the following is required, otherwise the view will not be updated
   *       this.ref.markForCheck();
   *     }, 1000);
   *   }
   * }
   * ```
   */
  markForCheck() {
    markViewDirty(
      this._cdRefInjectingView || this._lView,
      4
      /* NotificationSource.MarkForCheck */
    );
  }
  /**
   * Detaches the view from the change detection tree.
   *
   * Detached views will not be checked during change detection runs until they are
   * re-attached, even if they are dirty. `detach` can be used in combination with
   * {@link ChangeDetectorRef#detectChanges} to implement local change
   * detection checks.
   *
   * <!-- TODO: Add a link to a chapter on detach/reattach/local digest -->
   * <!-- TODO: Add a live demo once ref.detectChanges is merged into master -->
   *
   * @usageNotes
   * ### Example
   *
   * The following example defines a component with a large list of readonly data.
   * Imagine the data changes constantly, many times per second. For performance reasons,
   * we want to check and update the list every five seconds. We can do that by detaching
   * the component's change detector and doing a local check every five seconds.
   *
   * ```typescript
   * class DataProvider {
   *   // in a real application the returned data will be different every time
   *   get data() {
   *     return [1,2,3,4,5];
   *   }
   * }
   *
   * @Component({
   *   selector: 'giant-list',
   *   template: `
   *     <li *ngFor="let d of dataProvider.data">Data {{d}}</li>
   *   `,
   * })
   * class GiantList {
   *   constructor(private ref: ChangeDetectorRef, private dataProvider: DataProvider) {
   *     ref.detach();
   *     setInterval(() => {
   *       this.ref.detectChanges();
   *     }, 5000);
   *   }
   * }
   *
   * @Component({
   *   selector: 'app',
   *   providers: [DataProvider],
   *   template: `
   *     <giant-list><giant-list>
   *   `,
   * })
   * class App {
   * }
   * ```
   */
  detach() {
    this._lView[FLAGS] &= ~128;
  }
  /**
   * Re-attaches a view to the change detection tree.
   *
   * This can be used to re-attach views that were previously detached from the tree
   * using {@link ChangeDetectorRef#detach}. Views are attached to the tree by default.
   *
   * <!-- TODO: Add a link to a chapter on detach/reattach/local digest -->
   *
   * @usageNotes
   * ### Example
   *
   * The following example creates a component displaying `live` data. The component will detach
   * its change detector from the main change detector tree when the component's live property
   * is set to false.
   *
   * ```typescript
   * class DataProvider {
   *   data = 1;
   *
   *   constructor() {
   *     setInterval(() => {
   *       this.data = this.data * 2;
   *     }, 500);
   *   }
   * }
   *
   * @Component({
   *   selector: 'live-data',
   *   inputs: ['live'],
   *   template: 'Data: {{dataProvider.data}}'
   * })
   * class LiveData {
   *   constructor(private ref: ChangeDetectorRef, private dataProvider: DataProvider) {}
   *
   *   set live(value) {
   *     if (value) {
   *       this.ref.reattach();
   *     } else {
   *       this.ref.detach();
   *     }
   *   }
   * }
   *
   * @Component({
   *   selector: 'app-root',
   *   providers: [DataProvider],
   *   template: `
   *     Live Update: <input type="checkbox" [(ngModel)]="live">
   *     <live-data [live]="live"><live-data>
   *   `,
   * })
   * class AppComponent {
   *   live = true;
   * }
   * ```
   */
  reattach() {
    updateAncestorTraversalFlagsOnAttach(this._lView);
    this._lView[FLAGS] |= 128;
  }
  /**
   * Checks the view and its children.
   *
   * This can also be used in combination with {@link ChangeDetectorRef#detach} to implement
   * local change detection checks.
   *
   * <!-- TODO: Add a link to a chapter on detach/reattach/local digest -->
   * <!-- TODO: Add a live demo once ref.detectChanges is merged into master -->
   *
   * @usageNotes
   * ### Example
   *
   * The following example defines a component with a large list of readonly data.
   * Imagine, the data changes constantly, many times per second. For performance reasons,
   * we want to check and update the list every five seconds.
   *
   * We can do that by detaching the component's change detector and doing a local change detection
   * check every five seconds.
   *
   * See {@link ChangeDetectorRef#detach} for more information.
   */
  detectChanges() {
    this._lView[FLAGS] |= 1024;
    detectChangesInternal(this._lView, this.notifyErrorHandler);
  }
  /**
   * Checks the change detector and its children, and throws if any changes are detected.
   *
   * This is used in development mode to verify that running change detection doesn't
   * introduce other changes.
   */
  checkNoChanges() {
    if (ngDevMode) {
      checkNoChangesInternal(this._lView, CheckNoChangesMode.OnlyDirtyViews, this.notifyErrorHandler);
    }
  }
  attachToViewContainerRef() {
    if (this._appRef) {
      throw new RuntimeError(902, ngDevMode && "This view is already attached directly to the ApplicationRef!");
    }
    this._attachedToViewContainer = true;
  }
  detachFromAppRef() {
    this._appRef = null;
    const isRoot = isRootView(this._lView);
    const declarationContainer = this._lView[DECLARATION_LCONTAINER];
    if (declarationContainer !== null && !isRoot) {
      detachMovedView(declarationContainer, this._lView);
    }
    detachViewFromDOM(this._lView[TVIEW], this._lView);
  }
  attachToAppRef(appRef) {
    if (this._attachedToViewContainer) {
      throw new RuntimeError(902, ngDevMode && "This view is already attached to a ViewContainer!");
    }
    this._appRef = appRef;
    const isRoot = isRootView(this._lView);
    const declarationContainer = this._lView[DECLARATION_LCONTAINER];
    if (declarationContainer !== null && !isRoot) {
      trackMovedView(declarationContainer, this._lView);
    }
    updateAncestorTraversalFlagsOnAttach(this._lView);
  }
};
var TemplateRef = class {
  static {
    this.__NG_ELEMENT_ID__ = injectTemplateRef;
  }
};
var ViewEngineTemplateRef = TemplateRef;
var R3TemplateRef = class TemplateRef2 extends ViewEngineTemplateRef {
  constructor(_declarationLView, _declarationTContainer, elementRef) {
    super();
    this._declarationLView = _declarationLView;
    this._declarationTContainer = _declarationTContainer;
    this.elementRef = elementRef;
  }
  /**
   * Returns an `ssrId` associated with a TView, which was used to
   * create this instance of the `TemplateRef`.
   *
   * @internal
   */
  get ssrId() {
    return this._declarationTContainer.tView?.ssrId || null;
  }
  createEmbeddedView(context, injector) {
    return this.createEmbeddedViewImpl(context, injector);
  }
  /**
   * @internal
   */
  createEmbeddedViewImpl(context, injector, dehydratedView) {
    const embeddedLView = createAndRenderEmbeddedLView(this._declarationLView, this._declarationTContainer, context, {
      embeddedViewInjector: injector,
      dehydratedView
    });
    return new ViewRef$1(embeddedLView);
  }
};
function injectTemplateRef() {
  return createTemplateRef(getCurrentTNode(), getLView());
}
function createTemplateRef(hostTNode, hostLView) {
  if (hostTNode.type & 4) {
    ngDevMode && assertDefined(hostTNode.tView, "TView must be allocated");
    return new R3TemplateRef(hostLView, hostTNode, createElementRef(hostTNode, hostLView));
  }
  return null;
}
var AT_THIS_LOCATION = "<-- AT THIS LOCATION";
function getFriendlyStringFromTNodeType(tNodeType) {
  switch (tNodeType) {
    case 4:
      return "view container";
    case 2:
      return "element";
    case 8:
      return "ng-container";
    case 32:
      return "icu";
    case 64:
      return "i18n";
    case 16:
      return "projection";
    case 1:
      return "text";
    case 128:
      return "@let";
    default:
      return "<unknown>";
  }
}
function validateMatchingNode(node, nodeType, tagName, lView, tNode, isViewContainerAnchor = false) {
  if (!node || node.nodeType !== nodeType || node.nodeType === Node.ELEMENT_NODE && node.tagName.toLowerCase() !== tagName?.toLowerCase()) {
    const expectedNode = shortRNodeDescription(nodeType, tagName, null);
    let header = `During hydration Angular expected ${expectedNode} but `;
    const hostComponentDef = getDeclarationComponentDef(lView);
    const componentClassName = hostComponentDef?.type?.name;
    const expectedDom = describeExpectedDom(lView, tNode, isViewContainerAnchor);
    const expected = `Angular expected this DOM:

${expectedDom}

`;
    let actual = "";
    const componentHostElement = unwrapRNode(lView[HOST]);
    if (!node) {
      header += `the node was not found.

`;
      markRNodeAsHavingHydrationMismatch(componentHostElement, expectedDom);
    } else {
      const actualNode = shortRNodeDescription(node.nodeType, node.tagName ?? null, node.textContent ?? null);
      header += `found ${actualNode}.

`;
      const actualDom = describeDomFromNode(node);
      actual = `Actual DOM is:

${actualDom}

`;
      markRNodeAsHavingHydrationMismatch(componentHostElement, expectedDom, actualDom);
    }
    const footer = getHydrationErrorFooter(componentClassName);
    const message = header + expected + actual + getHydrationAttributeNote() + footer;
    throw new RuntimeError(-500, message);
  }
}
function validateSiblingNodeExists(node) {
  validateNodeExists(node);
  if (!node.nextSibling) {
    const header = "During hydration Angular expected more sibling nodes to be present.\n\n";
    const actual = `Actual DOM is:

${describeDomFromNode(node)}

`;
    const footer = getHydrationErrorFooter();
    const message = header + actual + footer;
    markRNodeAsHavingHydrationMismatch(node, "", actual);
    throw new RuntimeError(-501, message);
  }
}
function validateNodeExists(node, lView = null, tNode = null) {
  if (!node) {
    const header = "During hydration, Angular expected an element to be present at this location.\n\n";
    let expected = "";
    let footer = "";
    if (lView !== null && tNode !== null) {
      expected = describeExpectedDom(lView, tNode, false);
      footer = getHydrationErrorFooter();
      markRNodeAsHavingHydrationMismatch(unwrapRNode(lView[HOST]), expected, "");
    }
    throw new RuntimeError(-502, `${header}${expected}

${footer}`);
  }
}
function nodeNotFoundError(lView, tNode) {
  const header = "During serialization, Angular was unable to find an element in the DOM:\n\n";
  const expected = `${describeExpectedDom(lView, tNode, false)}

`;
  const footer = getHydrationErrorFooter();
  throw new RuntimeError(-502, header + expected + footer);
}
function nodeNotFoundAtPathError(host, path) {
  const header = `During hydration Angular was unable to locate a node using the "${path}" path, starting from the ${describeRNode(host)} node.

`;
  const footer = getHydrationErrorFooter();
  markRNodeAsHavingHydrationMismatch(host);
  throw new RuntimeError(-502, header + footer);
}
function unsupportedProjectionOfDomNodes(rNode) {
  const header = "During serialization, Angular detected DOM nodes that were created outside of Angular context and provided as projectable nodes (likely via `ViewContainerRef.createComponent` or `createComponent` APIs). Hydration is not supported for such cases, consider refactoring the code to avoid this pattern or using `ngSkipHydration` on the host element of the component.\n\n";
  const actual = `${describeDomFromNode(rNode)}

`;
  const message = header + actual + getHydrationAttributeNote();
  return new RuntimeError(-503, message);
}
function invalidSkipHydrationHost(rNode) {
  const header = "The `ngSkipHydration` flag is applied on a node that doesn't act as a component host. Hydration can be skipped only on per-component basis.\n\n";
  const actual = `${describeDomFromNode(rNode)}

`;
  const footer = "Please move the `ngSkipHydration` attribute to the component host element.\n\n";
  const message = header + actual + footer;
  return new RuntimeError(-504, message);
}
function stringifyTNodeAttrs(tNode) {
  const results = [];
  if (tNode.attrs) {
    for (let i = 0; i < tNode.attrs.length; ) {
      const attrName = tNode.attrs[i++];
      if (typeof attrName == "number") {
        break;
      }
      const attrValue = tNode.attrs[i++];
      results.push(`${attrName}="${shorten(attrValue)}"`);
    }
  }
  return results.join(" ");
}
var internalAttrs = /* @__PURE__ */ new Set(["ngh", "ng-version", "ng-server-context"]);
function stringifyRNodeAttrs(rNode) {
  const results = [];
  for (let i = 0; i < rNode.attributes.length; i++) {
    const attr = rNode.attributes[i];
    if (internalAttrs.has(attr.name)) continue;
    results.push(`${attr.name}="${shorten(attr.value)}"`);
  }
  return results.join(" ");
}
function describeTNode(tNode, innerContent = "…") {
  switch (tNode.type) {
    case 1:
      const content = tNode.value ? `(${tNode.value})` : "";
      return `#text${content}`;
    case 2:
      const attrs = stringifyTNodeAttrs(tNode);
      const tag = tNode.value.toLowerCase();
      return `<${tag}${attrs ? " " + attrs : ""}>${innerContent}</${tag}>`;
    case 8:
      return "<!-- ng-container -->";
    case 4:
      return "<!-- container -->";
    default:
      const typeAsString = getFriendlyStringFromTNodeType(tNode.type);
      return `#node(${typeAsString})`;
  }
}
function describeRNode(rNode, innerContent = "…") {
  const node = rNode;
  switch (node.nodeType) {
    case Node.ELEMENT_NODE:
      const tag = node.tagName.toLowerCase();
      const attrs = stringifyRNodeAttrs(node);
      return `<${tag}${attrs ? " " + attrs : ""}>${innerContent}</${tag}>`;
    case Node.TEXT_NODE:
      const content = node.textContent ? shorten(node.textContent) : "";
      return `#text${content ? `(${content})` : ""}`;
    case Node.COMMENT_NODE:
      return `<!-- ${shorten(node.textContent ?? "")} -->`;
    default:
      return `#node(${node.nodeType})`;
  }
}
function describeExpectedDom(lView, tNode, isViewContainerAnchor) {
  const spacer = "  ";
  let content = "";
  if (tNode.prev) {
    content += spacer + "…\n";
    content += spacer + describeTNode(tNode.prev) + "\n";
  } else if (tNode.type && tNode.type & 12) {
    content += spacer + "…\n";
  }
  if (isViewContainerAnchor) {
    content += spacer + describeTNode(tNode) + "\n";
    content += spacer + `<!-- container -->  ${AT_THIS_LOCATION}
`;
  } else {
    content += spacer + describeTNode(tNode) + `  ${AT_THIS_LOCATION}
`;
  }
  content += spacer + "…\n";
  const parentRNode = tNode.type ? getParentRElement(lView[TVIEW], tNode, lView) : null;
  if (parentRNode) {
    content = describeRNode(parentRNode, "\n" + content);
  }
  return content;
}
function describeDomFromNode(node) {
  const spacer = "  ";
  let content = "";
  const currentNode = node;
  if (currentNode.previousSibling) {
    content += spacer + "…\n";
    content += spacer + describeRNode(currentNode.previousSibling) + "\n";
  }
  content += spacer + describeRNode(currentNode) + `  ${AT_THIS_LOCATION}
`;
  if (node.nextSibling) {
    content += spacer + "…\n";
  }
  if (node.parentNode) {
    content = describeRNode(currentNode.parentNode, "\n" + content);
  }
  return content;
}
function shortRNodeDescription(nodeType, tagName, textContent) {
  switch (nodeType) {
    case Node.ELEMENT_NODE:
      return `<${tagName.toLowerCase()}>`;
    case Node.TEXT_NODE:
      const content = textContent ? ` (with the "${shorten(textContent)}" content)` : "";
      return `a text node${content}`;
    case Node.COMMENT_NODE:
      return "a comment node";
    default:
      return `#node(nodeType=${nodeType})`;
  }
}
function getHydrationErrorFooter(componentClassName) {
  const componentInfo = componentClassName ? `the "${componentClassName}"` : "corresponding";
  return `To fix this problem:
  * check ${componentInfo} component for hydration-related issues
  * check to see if your template has valid HTML structure
  * or skip hydration by adding the \`ngSkipHydration\` attribute to its host node in a template

`;
}
function getHydrationAttributeNote() {
  return "Note: attributes are only displayed to better represent the DOM but have no effect on hydration mismatches.\n\n";
}
function stripNewlines(input2) {
  return input2.replace(/\s+/gm, "");
}
function shorten(input2, maxLength = 50) {
  if (!input2) {
    return "";
  }
  input2 = stripNewlines(input2);
  return input2.length > maxLength ? `${input2.substring(0, maxLength - 1)}…` : input2;
}
function getInsertInFrontOfRNodeWithI18n(parentTNode, currentTNode, lView) {
  const tNodeInsertBeforeIndex = currentTNode.insertBeforeIndex;
  const insertBeforeIndex = Array.isArray(tNodeInsertBeforeIndex) ? tNodeInsertBeforeIndex[0] : tNodeInsertBeforeIndex;
  if (insertBeforeIndex === null) {
    return getInsertInFrontOfRNodeWithNoI18n(parentTNode, currentTNode, lView);
  } else {
    ngDevMode && assertIndexInRange(lView, insertBeforeIndex);
    return unwrapRNode(lView[insertBeforeIndex]);
  }
}
function processI18nInsertBefore(renderer, childTNode, lView, childRNode, parentRElement) {
  const tNodeInsertBeforeIndex = childTNode.insertBeforeIndex;
  if (Array.isArray(tNodeInsertBeforeIndex)) {
    ngDevMode && assertDomNode(childRNode);
    let i18nParent = childRNode;
    let anchorRNode = null;
    if (!(childTNode.type & 3)) {
      anchorRNode = i18nParent;
      i18nParent = parentRElement;
    }
    if (i18nParent !== null && childTNode.componentOffset === -1) {
      for (let i = 1; i < tNodeInsertBeforeIndex.length; i++) {
        const i18nChild = lView[tNodeInsertBeforeIndex[i]];
        nativeInsertBefore(renderer, i18nParent, i18nChild, anchorRNode, false);
      }
    }
  }
}
function addTNodeAndUpdateInsertBeforeIndex(previousTNodes, newTNode) {
  ngDevMode && assertEqual(newTNode.insertBeforeIndex, null, "We expect that insertBeforeIndex is not set");
  previousTNodes.push(newTNode);
  if (previousTNodes.length > 1) {
    for (let i = previousTNodes.length - 2; i >= 0; i--) {
      const existingTNode = previousTNodes[i];
      if (!isI18nText(existingTNode)) {
        if (isNewTNodeCreatedBefore(existingTNode, newTNode) && getInsertBeforeIndex(existingTNode) === null) {
          setInsertBeforeIndex(existingTNode, newTNode.index);
        }
      }
    }
  }
}
function isI18nText(tNode) {
  return !(tNode.type & 64);
}
function isNewTNodeCreatedBefore(existingTNode, newTNode) {
  return isI18nText(newTNode) || existingTNode.index > newTNode.index;
}
function getInsertBeforeIndex(tNode) {
  const index = tNode.insertBeforeIndex;
  return Array.isArray(index) ? index[0] : index;
}
function setInsertBeforeIndex(tNode, value) {
  const index = tNode.insertBeforeIndex;
  if (Array.isArray(index)) {
    index[0] = value;
  } else {
    setI18nHandling(getInsertInFrontOfRNodeWithI18n, processI18nInsertBefore);
    tNode.insertBeforeIndex = value;
  }
}
function getTIcu(tView, index) {
  const value = tView.data[index];
  if (value === null || typeof value === "string") return null;
  if (ngDevMode && !(value.hasOwnProperty("tView") || value.hasOwnProperty("currentCaseLViewIndex"))) {
    throwError("We expect to get 'null'|'TIcu'|'TIcuContainer', but got: " + value);
  }
  const tIcu = value.hasOwnProperty("currentCaseLViewIndex") ? value : value.value;
  ngDevMode && assertTIcu(tIcu);
  return tIcu;
}
function setTIcu(tView, index, tIcu) {
  const tNode = tView.data[index];
  ngDevMode && assertEqual(tNode === null || tNode.hasOwnProperty("tView"), true, "We expect to get 'null'|'TIcuContainer'");
  if (tNode === null) {
    tView.data[index] = tIcu;
  } else {
    ngDevMode && assertTNodeType(
      tNode,
      32
      /* TNodeType.Icu */
    );
    tNode.value = tIcu;
  }
}
function setTNodeInsertBeforeIndex(tNode, index) {
  ngDevMode && assertTNode(tNode);
  let insertBeforeIndex = tNode.insertBeforeIndex;
  if (insertBeforeIndex === null) {
    setI18nHandling(getInsertInFrontOfRNodeWithI18n, processI18nInsertBefore);
    insertBeforeIndex = tNode.insertBeforeIndex = [null, index];
  } else {
    assertEqual(Array.isArray(insertBeforeIndex), true, "Expecting array here");
    insertBeforeIndex.push(index);
  }
}
function createTNodePlaceholder(tView, previousTNodes, index) {
  const tNode = createTNodeAtIndex(tView, index, 64, null, null);
  addTNodeAndUpdateInsertBeforeIndex(previousTNodes, tNode);
  return tNode;
}
function getCurrentICUCaseIndex(tIcu, lView) {
  const currentCase = lView[tIcu.currentCaseLViewIndex];
  return currentCase === null ? currentCase : currentCase < 0 ? ~currentCase : currentCase;
}
function getParentFromIcuCreateOpCode(mergedCode) {
  return mergedCode >>> 17;
}
function getRefFromIcuCreateOpCode(mergedCode) {
  return (mergedCode & 131070) >>> 1;
}
function getInstructionFromIcuCreateOpCode(mergedCode) {
  return mergedCode & 1;
}
function icuCreateOpCode(opCode, parentIdx, refIdx) {
  ngDevMode && assertGreaterThanOrEqual(parentIdx, 0, "Missing parent index");
  ngDevMode && assertGreaterThan(refIdx, 0, "Missing ref index");
  return opCode | parentIdx << 17 | refIdx << 1;
}
function isRootTemplateMessage(subTemplateIndex) {
  return subTemplateIndex === -1;
}
function enterIcu(state, tIcu, lView) {
  state.index = 0;
  const currentCase = getCurrentICUCaseIndex(tIcu, lView);
  if (currentCase !== null) {
    ngDevMode && assertNumberInRange(currentCase, 0, tIcu.cases.length - 1);
    state.removes = tIcu.remove[currentCase];
  } else {
    state.removes = EMPTY_ARRAY;
  }
}
function icuContainerIteratorNext(state) {
  if (state.index < state.removes.length) {
    const removeOpCode = state.removes[state.index++];
    ngDevMode && assertNumber(removeOpCode, "Expecting OpCode number");
    if (removeOpCode > 0) {
      const rNode = state.lView[removeOpCode];
      ngDevMode && assertDomNode(rNode);
      return rNode;
    } else {
      state.stack.push(state.index, state.removes);
      const tIcuIndex = ~removeOpCode;
      const tIcu = state.lView[TVIEW].data[tIcuIndex];
      ngDevMode && assertTIcu(tIcu);
      enterIcu(state, tIcu, state.lView);
      return icuContainerIteratorNext(state);
    }
  } else {
    if (state.stack.length === 0) {
      return null;
    } else {
      state.removes = state.stack.pop();
      state.index = state.stack.pop();
      return icuContainerIteratorNext(state);
    }
  }
}
function loadIcuContainerVisitor() {
  const _state = {
    stack: [],
    index: -1
  };
  function icuContainerIteratorStart(tIcuContainerNode, lView) {
    _state.lView = lView;
    while (_state.stack.length) _state.stack.pop();
    ngDevMode && assertTNodeForLView(tIcuContainerNode, lView);
    enterIcu(_state, tIcuContainerNode.value, lView);
    return icuContainerIteratorNext.bind(null, _state);
  }
  return icuContainerIteratorStart;
}
function createIcuIterator(tIcu, lView) {
  const state = {
    stack: [],
    index: -1,
    lView
  };
  ngDevMode && assertTIcu(tIcu);
  enterIcu(state, tIcu, lView);
  return icuContainerIteratorNext.bind(null, state);
}
var REF_EXTRACTOR_REGEXP = new RegExp(`^(\\d+)*(${REFERENCE_NODE_BODY}|${REFERENCE_NODE_HOST})*(.*)`);
function compressNodeLocation(referenceNode, path) {
  const result = [referenceNode];
  for (const segment of path) {
    const lastIdx = result.length - 1;
    if (lastIdx > 0 && result[lastIdx - 1] === segment) {
      const value = result[lastIdx] || 1;
      result[lastIdx] = value + 1;
    } else {
      result.push(segment, "");
    }
  }
  return result.join("");
}
function decompressNodeLocation(path) {
  const matches = path.match(REF_EXTRACTOR_REGEXP);
  const [_, refNodeId, refNodeName, rest] = matches;
  const ref = refNodeId ? parseInt(refNodeId, 10) : refNodeName;
  const steps = [];
  for (const [_2, step, count] of rest.matchAll(/(f|n)(\d*)/g)) {
    const repeat = parseInt(count, 10) || 1;
    steps.push(step, repeat);
  }
  return [ref, ...steps];
}
function isFirstElementInNgContainer(tNode) {
  return !tNode.prev && tNode.parent?.type === 8;
}
function getNoOffsetIndex(tNode) {
  return tNode.index - HEADER_OFFSET;
}
function isDisconnectedNode(tNode, lView) {
  return !(tNode.type & (16 | 128)) && !!lView[tNode.index] && isDisconnectedRNode(unwrapRNode(lView[tNode.index]));
}
function isDisconnectedRNode(rNode) {
  return !!rNode && !rNode.isConnected;
}
function locateI18nRNodeByIndex(hydrationInfo, noOffsetIndex) {
  const i18nNodes = hydrationInfo.i18nNodes;
  if (i18nNodes) {
    return i18nNodes.get(noOffsetIndex);
  }
  return void 0;
}
function tryLocateRNodeByPath(hydrationInfo, lView, noOffsetIndex) {
  const nodes = hydrationInfo.data[NODES];
  const path = nodes?.[noOffsetIndex];
  return path ? locateRNodeByPath(path, lView) : null;
}
function locateNextRNode(hydrationInfo, tView, lView, tNode) {
  const noOffsetIndex = getNoOffsetIndex(tNode);
  let native = locateI18nRNodeByIndex(hydrationInfo, noOffsetIndex);
  if (native === void 0) {
    const nodes = hydrationInfo.data[NODES];
    if (nodes?.[noOffsetIndex]) {
      native = locateRNodeByPath(nodes[noOffsetIndex], lView);
    } else if (tView.firstChild === tNode) {
      native = hydrationInfo.firstChild;
    } else {
      const previousTNodeParent = tNode.prev === null;
      const previousTNode = tNode.prev ?? tNode.parent;
      ngDevMode && assertDefined(previousTNode, "Unexpected state: current TNode does not have a connection to the previous node or a parent node.");
      if (isFirstElementInNgContainer(tNode)) {
        const noOffsetParentIndex = getNoOffsetIndex(tNode.parent);
        native = getSegmentHead(hydrationInfo, noOffsetParentIndex);
      } else {
        let previousRElement = getNativeByTNode(previousTNode, lView);
        if (previousTNodeParent) {
          native = previousRElement.firstChild;
        } else {
          const noOffsetPrevSiblingIndex = getNoOffsetIndex(previousTNode);
          const segmentHead = getSegmentHead(hydrationInfo, noOffsetPrevSiblingIndex);
          if (previousTNode.type === 2 && segmentHead) {
            const numRootNodesToSkip = calcSerializedContainerSize(hydrationInfo, noOffsetPrevSiblingIndex);
            const nodesToSkip = numRootNodesToSkip + 1;
            native = siblingAfter(nodesToSkip, segmentHead);
          } else {
            native = previousRElement.nextSibling;
          }
        }
      }
    }
  }
  return native;
}
function siblingAfter(skip, from) {
  let currentNode = from;
  for (let i = 0; i < skip; i++) {
    ngDevMode && validateSiblingNodeExists(currentNode);
    currentNode = currentNode.nextSibling;
  }
  return currentNode;
}
function stringifyNavigationInstructions(instructions) {
  const container = [];
  for (let i = 0; i < instructions.length; i += 2) {
    const step = instructions[i];
    const repeat = instructions[i + 1];
    for (let r = 0; r < repeat; r++) {
      container.push(step === NodeNavigationStep.FirstChild ? "firstChild" : "nextSibling");
    }
  }
  return container.join(".");
}
function navigateToNode(from, instructions) {
  let node = from;
  for (let i = 0; i < instructions.length; i += 2) {
    const step = instructions[i];
    const repeat = instructions[i + 1];
    for (let r = 0; r < repeat; r++) {
      if (ngDevMode && !node) {
        throw nodeNotFoundAtPathError(from, stringifyNavigationInstructions(instructions));
      }
      switch (step) {
        case NodeNavigationStep.FirstChild:
          node = node.firstChild;
          break;
        case NodeNavigationStep.NextSibling:
          node = node.nextSibling;
          break;
      }
    }
  }
  if (ngDevMode && !node) {
    throw nodeNotFoundAtPathError(from, stringifyNavigationInstructions(instructions));
  }
  return node;
}
function locateRNodeByPath(path, lView) {
  const [referenceNode, ...navigationInstructions] = decompressNodeLocation(path);
  let ref;
  if (referenceNode === REFERENCE_NODE_HOST) {
    ref = lView[DECLARATION_COMPONENT_VIEW][HOST];
  } else if (referenceNode === REFERENCE_NODE_BODY) {
    ref = ɵɵresolveBody(lView[DECLARATION_COMPONENT_VIEW][HOST]);
  } else {
    const parentElementId = Number(referenceNode);
    ref = unwrapRNode(lView[parentElementId + HEADER_OFFSET]);
  }
  return navigateToNode(ref, navigationInstructions);
}
function navigateBetween(start, finish) {
  if (start === finish) {
    return [];
  } else if (start.parentElement == null || finish.parentElement == null) {
    return null;
  } else if (start.parentElement === finish.parentElement) {
    return navigateBetweenSiblings(start, finish);
  } else {
    const parent = finish.parentElement;
    const parentPath = navigateBetween(start, parent);
    const childPath = navigateBetween(parent.firstChild, finish);
    if (!parentPath || !childPath) return null;
    return [
      // First navigate to `finish`'s parent
      ...parentPath,
      // Then to its first child.
      NodeNavigationStep.FirstChild,
      // And finally from that node to `finish` (maybe a no-op if we're already there).
      ...childPath
    ];
  }
}
function navigateBetweenSiblings(start, finish) {
  const nav = [];
  let node = null;
  for (node = start; node != null && node !== finish; node = node.nextSibling) {
    nav.push(NodeNavigationStep.NextSibling);
  }
  return node == null ? null : nav;
}
function calcPathBetween(from, to, fromNodeName) {
  const path = navigateBetween(from, to);
  return path === null ? null : compressNodeLocation(fromNodeName, path);
}
function calcPathForNode(tNode, lView, excludedParentNodes) {
  let parentTNode = tNode.parent;
  let parentIndex;
  let parentRNode;
  let referenceNodeName;
  while (parentTNode !== null && (isDisconnectedNode(parentTNode, lView) || excludedParentNodes?.has(parentTNode.index))) {
    parentTNode = parentTNode.parent;
  }
  if (parentTNode === null || !(parentTNode.type & 3)) {
    parentIndex = referenceNodeName = REFERENCE_NODE_HOST;
    parentRNode = lView[DECLARATION_COMPONENT_VIEW][HOST];
  } else {
    parentIndex = parentTNode.index;
    parentRNode = unwrapRNode(lView[parentIndex]);
    referenceNodeName = renderStringify(parentIndex - HEADER_OFFSET);
  }
  let rNode = unwrapRNode(lView[tNode.index]);
  if (tNode.type & (12 | 32)) {
    const firstRNode = getFirstNativeNode(lView, tNode);
    if (firstRNode) {
      rNode = firstRNode;
    }
  }
  let path = calcPathBetween(parentRNode, rNode, referenceNodeName);
  if (path === null && parentRNode !== rNode) {
    const body = parentRNode.ownerDocument.body;
    path = calcPathBetween(body, rNode, REFERENCE_NODE_BODY);
    if (path === null) {
      throw nodeNotFoundError(lView, tNode);
    }
  }
  return path;
}
var _isI18nHydrationSupportEnabled = false;
var _prepareI18nBlockForHydrationImpl = () => {
};
function setIsI18nHydrationSupportEnabled(enabled) {
  _isI18nHydrationSupportEnabled = enabled;
}
function isI18nHydrationSupportEnabled() {
  return _isI18nHydrationSupportEnabled;
}
function prepareI18nBlockForHydration(lView, index, parentTNode, subTemplateIndex) {
  _prepareI18nBlockForHydrationImpl(lView, index, parentTNode, subTemplateIndex);
}
function enablePrepareI18nBlockForHydrationImpl() {
  _prepareI18nBlockForHydrationImpl = prepareI18nBlockForHydrationImpl;
}
function isI18nHydrationEnabled(injector) {
  injector = injector ?? inject(Injector);
  return injector.get(IS_I18N_HYDRATION_ENABLED, false);
}
function getOrComputeI18nChildren(tView, context) {
  let i18nChildren = context.i18nChildren.get(tView);
  if (i18nChildren === void 0) {
    i18nChildren = collectI18nChildren(tView);
    context.i18nChildren.set(tView, i18nChildren);
  }
  return i18nChildren;
}
function collectI18nChildren(tView) {
  const children = /* @__PURE__ */ new Set();
  function collectI18nViews(node) {
    children.add(node.index);
    switch (node.kind) {
      case 1:
      case 2: {
        for (const childNode of node.children) {
          collectI18nViews(childNode);
        }
        break;
      }
      case 3: {
        for (const caseNodes of node.cases) {
          for (const caseNode of caseNodes) {
            collectI18nViews(caseNode);
          }
        }
        break;
      }
    }
  }
  for (let i = HEADER_OFFSET; i < tView.bindingStartIndex; i++) {
    const tI18n = tView.data[i];
    if (!tI18n || !tI18n.ast) {
      continue;
    }
    for (const node of tI18n.ast) {
      collectI18nViews(node);
    }
  }
  return children.size === 0 ? null : children;
}
function trySerializeI18nBlock(lView, index, context) {
  if (!context.isI18nHydrationEnabled) {
    return null;
  }
  const tView = lView[TVIEW];
  const tI18n = tView.data[index];
  if (!tI18n || !tI18n.ast) {
    return null;
  }
  const parentTNode = tView.data[tI18n.parentTNodeIndex];
  if (parentTNode && isI18nInSkipHydrationBlock(parentTNode)) {
    return null;
  }
  const serializedI18nBlock = {
    caseQueue: [],
    disconnectedNodes: /* @__PURE__ */ new Set(),
    disjointNodes: /* @__PURE__ */ new Set()
  };
  serializeI18nBlock(lView, serializedI18nBlock, context, tI18n.ast);
  return serializedI18nBlock.caseQueue.length === 0 && serializedI18nBlock.disconnectedNodes.size === 0 && serializedI18nBlock.disjointNodes.size === 0 ? null : serializedI18nBlock;
}
function serializeI18nBlock(lView, serializedI18nBlock, context, nodes) {
  let prevRNode = null;
  for (const node of nodes) {
    const nextRNode = serializeI18nNode(lView, serializedI18nBlock, context, node);
    if (nextRNode) {
      if (isDisjointNode(prevRNode, nextRNode)) {
        serializedI18nBlock.disjointNodes.add(node.index - HEADER_OFFSET);
      }
      prevRNode = nextRNode;
    }
  }
  return prevRNode;
}
function isDisjointNode(prevNode, nextNode) {
  return prevNode && prevNode.nextSibling !== nextNode;
}
function serializeI18nNode(lView, serializedI18nBlock, context, node) {
  const maybeRNode = unwrapRNode(lView[node.index]);
  if (!maybeRNode || isDisconnectedRNode(maybeRNode)) {
    serializedI18nBlock.disconnectedNodes.add(node.index - HEADER_OFFSET);
    return null;
  }
  const rNode = maybeRNode;
  switch (node.kind) {
    case 0: {
      processTextNodeBeforeSerialization(context, rNode);
      break;
    }
    case 1:
    case 2: {
      serializeI18nBlock(lView, serializedI18nBlock, context, node.children);
      break;
    }
    case 3: {
      const currentCase = lView[node.currentCaseLViewIndex];
      if (currentCase != null) {
        const caseIdx = currentCase < 0 ? ~currentCase : currentCase;
        serializedI18nBlock.caseQueue.push(caseIdx);
        serializeI18nBlock(lView, serializedI18nBlock, context, node.cases[caseIdx]);
      }
      break;
    }
  }
  return getFirstNativeNodeForI18nNode(lView, node);
}
function getFirstNativeNodeForI18nNode(lView, node) {
  const tView = lView[TVIEW];
  const maybeTNode = tView.data[node.index];
  if (isTNodeShape(maybeTNode)) {
    return getFirstNativeNode(lView, maybeTNode);
  } else if (node.kind === 3) {
    const icuIterator = createIcuIterator(maybeTNode, lView);
    let rNode = icuIterator();
    return rNode ?? unwrapRNode(lView[node.index]);
  } else {
    return unwrapRNode(lView[node.index]) ?? null;
  }
}
function setCurrentNode(state, node) {
  state.currentNode = node;
}
function appendI18nNodeToCollection(context, state, astNode) {
  const noOffsetIndex = astNode.index - HEADER_OFFSET;
  const {
    disconnectedNodes
  } = context;
  const currentNode = state.currentNode;
  if (state.isConnected) {
    context.i18nNodes.set(noOffsetIndex, currentNode);
    disconnectedNodes.delete(noOffsetIndex);
  } else {
    disconnectedNodes.add(noOffsetIndex);
  }
  return currentNode;
}
function skipSiblingNodes(state, skip) {
  let currentNode = state.currentNode;
  for (let i = 0; i < skip; i++) {
    if (!currentNode) {
      break;
    }
    currentNode = currentNode?.nextSibling ?? null;
  }
  return currentNode;
}
function forkHydrationState(state, nextNode) {
  return {
    currentNode: nextNode,
    isConnected: state.isConnected
  };
}
function prepareI18nBlockForHydrationImpl(lView, index, parentTNode, subTemplateIndex) {
  const hydrationInfo = lView[HYDRATION];
  if (!hydrationInfo) {
    return;
  }
  if (!isI18nHydrationSupportEnabled() || parentTNode && (isI18nInSkipHydrationBlock(parentTNode) || isDisconnectedNode$1(hydrationInfo, parentTNode.index - HEADER_OFFSET))) {
    return;
  }
  const tView = lView[TVIEW];
  const tI18n = tView.data[index];
  ngDevMode && assertDefined(tI18n, "Expected i18n data to be present in a given TView slot during hydration");
  function findHydrationRoot() {
    if (isRootTemplateMessage(subTemplateIndex)) {
      ngDevMode && assertDefined(parentTNode, "Expected parent TNode while hydrating i18n root");
      const rootNode = locateNextRNode(hydrationInfo, tView, lView, parentTNode);
      return parentTNode.type & 8 ? rootNode : rootNode.firstChild;
    }
    return hydrationInfo?.firstChild;
  }
  const currentNode = findHydrationRoot();
  ngDevMode && assertDefined(currentNode, "Expected root i18n node during hydration");
  const disconnectedNodes = initDisconnectedNodes(hydrationInfo) ?? /* @__PURE__ */ new Set();
  const i18nNodes = hydrationInfo.i18nNodes ??= /* @__PURE__ */ new Map();
  const caseQueue = hydrationInfo.data[I18N_DATA]?.[index - HEADER_OFFSET] ?? [];
  const dehydratedIcuData = hydrationInfo.dehydratedIcuData ??= /* @__PURE__ */ new Map();
  collectI18nNodesFromDom({
    hydrationInfo,
    lView,
    i18nNodes,
    disconnectedNodes,
    caseQueue,
    dehydratedIcuData
  }, {
    currentNode,
    isConnected: true
  }, tI18n.ast);
  hydrationInfo.disconnectedNodes = disconnectedNodes.size === 0 ? null : disconnectedNodes;
}
function collectI18nNodesFromDom(context, state, nodeOrNodes) {
  if (Array.isArray(nodeOrNodes)) {
    let nextState = state;
    for (const node of nodeOrNodes) {
      const targetNode = tryLocateRNodeByPath(context.hydrationInfo, context.lView, node.index - HEADER_OFFSET);
      if (targetNode) {
        nextState = forkHydrationState(state, targetNode);
      }
      collectI18nNodesFromDom(context, nextState, node);
    }
  } else {
    if (context.disconnectedNodes.has(nodeOrNodes.index - HEADER_OFFSET)) {
      return;
    }
    switch (nodeOrNodes.kind) {
      case 0: {
        const currentNode = appendI18nNodeToCollection(context, state, nodeOrNodes);
        setCurrentNode(state, currentNode?.nextSibling ?? null);
        break;
      }
      case 1: {
        collectI18nNodesFromDom(context, forkHydrationState(state, state.currentNode?.firstChild ?? null), nodeOrNodes.children);
        const currentNode = appendI18nNodeToCollection(context, state, nodeOrNodes);
        setCurrentNode(state, currentNode?.nextSibling ?? null);
        break;
      }
      case 2: {
        const noOffsetIndex = nodeOrNodes.index - HEADER_OFFSET;
        const {
          hydrationInfo
        } = context;
        const containerSize = getNgContainerSize(hydrationInfo, noOffsetIndex);
        switch (nodeOrNodes.type) {
          case 0: {
            const currentNode = appendI18nNodeToCollection(context, state, nodeOrNodes);
            if (isSerializedElementContainer(hydrationInfo, noOffsetIndex)) {
              collectI18nNodesFromDom(context, state, nodeOrNodes.children);
              const nextNode = skipSiblingNodes(state, 1);
              setCurrentNode(state, nextNode);
            } else {
              collectI18nNodesFromDom(context, forkHydrationState(state, state.currentNode?.firstChild ?? null), nodeOrNodes.children);
              setCurrentNode(state, currentNode?.nextSibling ?? null);
              if (containerSize !== null) {
                const nextNode = skipSiblingNodes(state, containerSize + 1);
                setCurrentNode(state, nextNode);
              }
            }
            break;
          }
          case 1: {
            ngDevMode && assertNotEqual(containerSize, null, "Expected a container size while hydrating i18n subtemplate");
            appendI18nNodeToCollection(context, state, nodeOrNodes);
            const nextNode = skipSiblingNodes(state, containerSize + 1);
            setCurrentNode(state, nextNode);
            break;
          }
        }
        break;
      }
      case 3: {
        const selectedCase = state.isConnected ? context.caseQueue.shift() : null;
        const childState = {
          currentNode: null,
          isConnected: false
        };
        for (let i = 0; i < nodeOrNodes.cases.length; i++) {
          collectI18nNodesFromDom(context, i === selectedCase ? state : childState, nodeOrNodes.cases[i]);
        }
        if (selectedCase !== null) {
          context.dehydratedIcuData.set(nodeOrNodes.index, {
            case: selectedCase,
            node: nodeOrNodes
          });
        }
        const currentNode = appendI18nNodeToCollection(context, state, nodeOrNodes);
        setCurrentNode(state, currentNode?.nextSibling ?? null);
        break;
      }
    }
  }
}
var _claimDehydratedIcuCaseImpl = () => {
};
function claimDehydratedIcuCase(lView, icuIndex, caseIndex) {
  _claimDehydratedIcuCaseImpl(lView, icuIndex, caseIndex);
}
function enableClaimDehydratedIcuCaseImpl() {
  _claimDehydratedIcuCaseImpl = claimDehydratedIcuCaseImpl;
}
function claimDehydratedIcuCaseImpl(lView, icuIndex, caseIndex) {
  const dehydratedIcuDataMap = lView[HYDRATION]?.dehydratedIcuData;
  if (dehydratedIcuDataMap) {
    const dehydratedIcuData = dehydratedIcuDataMap.get(icuIndex);
    if (dehydratedIcuData?.case === caseIndex) {
      dehydratedIcuDataMap.delete(icuIndex);
    }
  }
}
function cleanupI18nHydrationData(lView) {
  const hydrationInfo = lView[HYDRATION];
  if (hydrationInfo) {
    const {
      i18nNodes,
      dehydratedIcuData: dehydratedIcuDataMap
    } = hydrationInfo;
    if (i18nNodes && dehydratedIcuDataMap) {
      const renderer = lView[RENDERER];
      for (const dehydratedIcuData of dehydratedIcuDataMap.values()) {
        cleanupDehydratedIcuData(renderer, i18nNodes, dehydratedIcuData);
      }
    }
    hydrationInfo.i18nNodes = void 0;
    hydrationInfo.dehydratedIcuData = void 0;
  }
}
function cleanupDehydratedIcuData(renderer, i18nNodes, dehydratedIcuData) {
  for (const node of dehydratedIcuData.node.cases[dehydratedIcuData.case]) {
    const rNode = i18nNodes.get(node.index - HEADER_OFFSET);
    if (rNode) {
      nativeRemoveNode(renderer, rNode, false);
    }
  }
}
function removeDehydratedViews(lContainer) {
  const views = lContainer[DEHYDRATED_VIEWS] ?? [];
  const parentLView = lContainer[PARENT];
  const renderer = parentLView[RENDERER];
  for (const view of views) {
    removeDehydratedView(view, renderer);
    ngDevMode && ngDevMode.dehydratedViewsRemoved++;
  }
  lContainer[DEHYDRATED_VIEWS] = EMPTY_ARRAY;
}
function removeDehydratedView(dehydratedView, renderer) {
  let nodesRemoved = 0;
  let currentRNode = dehydratedView.firstChild;
  if (currentRNode) {
    const numNodes = dehydratedView.data[NUM_ROOT_NODES];
    while (nodesRemoved < numNodes) {
      ngDevMode && validateSiblingNodeExists(currentRNode);
      const nextSibling = currentRNode.nextSibling;
      nativeRemoveNode(renderer, currentRNode, false);
      currentRNode = nextSibling;
      nodesRemoved++;
    }
  }
}
function cleanupLContainer(lContainer) {
  removeDehydratedViews(lContainer);
  const hostLView = lContainer[HOST];
  if (isLView(hostLView)) {
    cleanupLView(hostLView);
  }
  for (let i = CONTAINER_HEADER_OFFSET; i < lContainer.length; i++) {
    cleanupLView(lContainer[i]);
  }
}
function cleanupLView(lView) {
  cleanupI18nHydrationData(lView);
  const tView = lView[TVIEW];
  for (let i = HEADER_OFFSET; i < tView.bindingStartIndex; i++) {
    if (isLContainer(lView[i])) {
      const lContainer = lView[i];
      cleanupLContainer(lContainer);
    } else if (isLView(lView[i])) {
      cleanupLView(lView[i]);
    }
  }
}
function cleanupDehydratedViews(appRef) {
  const viewRefs = appRef._views;
  for (const viewRef of viewRefs) {
    const lNode = getLNodeForHydration(viewRef);
    if (lNode !== null && lNode[HOST] !== null) {
      if (isLView(lNode)) {
        cleanupLView(lNode);
      } else {
        cleanupLContainer(lNode);
      }
      ngDevMode && ngDevMode.dehydratedViewsCleanupRuns++;
    }
  }
}
function locateDehydratedViewsInContainer(currentRNode, serializedViews) {
  const dehydratedViews = [];
  for (const serializedView of serializedViews) {
    for (let i = 0; i < (serializedView[MULTIPLIER] ?? 1); i++) {
      const view = {
        data: serializedView,
        firstChild: null
      };
      if (serializedView[NUM_ROOT_NODES] > 0) {
        view.firstChild = currentRNode;
        currentRNode = siblingAfter(serializedView[NUM_ROOT_NODES], currentRNode);
      }
      dehydratedViews.push(view);
    }
  }
  return [currentRNode, dehydratedViews];
}
var _findMatchingDehydratedViewImpl = () => null;
function findMatchingDehydratedViewImpl(lContainer, template) {
  const views = lContainer[DEHYDRATED_VIEWS];
  if (!template || views === null || views.length === 0) {
    return null;
  }
  const view = views[0];
  if (view.data[TEMPLATE_ID] === template) {
    return views.shift();
  } else {
    removeDehydratedViews(lContainer);
    return null;
  }
}
function enableFindMatchingDehydratedViewImpl() {
  _findMatchingDehydratedViewImpl = findMatchingDehydratedViewImpl;
}
function findMatchingDehydratedView(lContainer, template) {
  return _findMatchingDehydratedViewImpl(lContainer, template);
}
var ChangeDetectionScheduler = class {
};
var ZONELESS_ENABLED = new InjectionToken(typeof ngDevMode === "undefined" || ngDevMode ? "Zoneless enabled" : "", {
  providedIn: "root",
  factory: () => false
});
var PROVIDED_ZONELESS = new InjectionToken(typeof ngDevMode === "undefined" || ngDevMode ? "Zoneless provided" : "", {
  providedIn: "root",
  factory: () => false
});
var ZONELESS_SCHEDULER_DISABLED = new InjectionToken(typeof ngDevMode === "undefined" || ngDevMode ? "scheduler disabled" : "");
var ComponentRef$1 = class {
};
var ComponentFactory$1 = class {
};
function noComponentFactoryError(component) {
  const error = Error(`No component factory found for ${stringify(component)}.`);
  error[ERROR_COMPONENT] = component;
  return error;
}
var ERROR_COMPONENT = "ngComponent";
var _NullComponentFactoryResolver = class {
  resolveComponentFactory(component) {
    throw noComponentFactoryError(component);
  }
};
var ComponentFactoryResolver$1 = class {
  static {
    this.NULL = new _NullComponentFactoryResolver();
  }
};
var RendererFactory2 = class {
};
var Renderer2 = class {
  constructor() {
    this.destroyNode = null;
  }
  static {
    this.__NG_ELEMENT_ID__ = () => injectRenderer2();
  }
};
function injectRenderer2() {
  const lView = getLView();
  const tNode = getCurrentTNode();
  const nodeAtIndex = getComponentLViewByIndex(tNode.index, lView);
  return (isLView(nodeAtIndex) ? nodeAtIndex : lView)[RENDERER];
}
var Sanitizer = class _Sanitizer {
  static {
    this.ɵprov = ɵɵdefineInjectable({
      token: _Sanitizer,
      providedIn: "root",
      factory: () => null
    });
  }
};
function assertNotInReactiveContext(debugFn, extraContext) {
  if (getActiveConsumer() !== null) {
    throw new RuntimeError(-602, ngDevMode && `${debugFn.name}() cannot be called from within a reactive context.${extraContext ? ` ${extraContext}` : ""}`);
  }
}
var markedFeatures = /* @__PURE__ */ new Set();
function performanceMarkFeature(feature) {
  if (markedFeatures.has(feature)) {
    return;
  }
  markedFeatures.add(feature);
  performance?.mark?.("mark_feature_usage", {
    detail: {
      feature
    }
  });
}
var AfterRenderPhase;
(function(AfterRenderPhase2) {
  AfterRenderPhase2[AfterRenderPhase2["EarlyRead"] = 0] = "EarlyRead";
  AfterRenderPhase2[AfterRenderPhase2["Write"] = 1] = "Write";
  AfterRenderPhase2[AfterRenderPhase2["MixedReadWrite"] = 2] = "MixedReadWrite";
  AfterRenderPhase2[AfterRenderPhase2["Read"] = 3] = "Read";
})(AfterRenderPhase || (AfterRenderPhase = {}));
var NOOP_AFTER_RENDER_REF = {
  destroy() {
  }
};
function internalAfterNextRender(callback, options) {
  const injector = options?.injector ?? inject(Injector);
  if (!options?.runOnServer && !isPlatformBrowser(injector)) return;
  const afterRenderEventManager = injector.get(AfterRenderEventManager);
  afterRenderEventManager.internalCallbacks.push(callback);
}
function afterRender(callbackOrSpec, options) {
  ngDevMode && assertNotInReactiveContext(afterRender, "Call `afterRender` outside of a reactive context. For example, schedule the render callback inside the component constructor`.");
  !options && assertInInjectionContext(afterRender);
  const injector = options?.injector ?? inject(Injector);
  if (!isPlatformBrowser(injector)) {
    return NOOP_AFTER_RENDER_REF;
  }
  performanceMarkFeature("NgAfterRender");
  return afterRenderImpl(
    callbackOrSpec,
    injector,
    /* once */
    false,
    options?.phase ?? AfterRenderPhase.MixedReadWrite
  );
}
function afterNextRender(callbackOrSpec, options) {
  !options && assertInInjectionContext(afterNextRender);
  const injector = options?.injector ?? inject(Injector);
  if (!isPlatformBrowser(injector)) {
    return NOOP_AFTER_RENDER_REF;
  }
  performanceMarkFeature("NgAfterNextRender");
  return afterRenderImpl(
    callbackOrSpec,
    injector,
    /* once */
    true,
    options?.phase ?? AfterRenderPhase.MixedReadWrite
  );
}
function getSpec(callbackOrSpec, phase) {
  if (callbackOrSpec instanceof Function) {
    switch (phase) {
      case AfterRenderPhase.EarlyRead:
        return {
          earlyRead: callbackOrSpec
        };
      case AfterRenderPhase.Write:
        return {
          write: callbackOrSpec
        };
      case AfterRenderPhase.MixedReadWrite:
        return {
          mixedReadWrite: callbackOrSpec
        };
      case AfterRenderPhase.Read:
        return {
          read: callbackOrSpec
        };
    }
  }
  return callbackOrSpec;
}
function afterRenderImpl(callbackOrSpec, injector, once, phase) {
  const spec = getSpec(callbackOrSpec, phase);
  const afterRenderEventManager = injector.get(AfterRenderEventManager);
  const callbackHandler = afterRenderEventManager.handler ??= new AfterRenderCallbackHandlerImpl();
  const pipelinedArgs = [];
  const instances = [];
  const destroy = () => {
    for (const instance of instances) {
      callbackHandler.unregister(instance);
    }
    unregisterFn();
  };
  const unregisterFn = injector.get(DestroyRef).onDestroy(destroy);
  let callbacksLeftToRun = 0;
  const registerCallback = (phase2, phaseCallback) => {
    if (!phaseCallback) {
      return;
    }
    const callback = once ? (...args) => {
      callbacksLeftToRun--;
      if (callbacksLeftToRun < 1) {
        destroy();
      }
      return phaseCallback(...args);
    } : phaseCallback;
    const instance = runInInjectionContext(injector, () => new AfterRenderCallback(phase2, pipelinedArgs, callback));
    callbackHandler.register(instance);
    instances.push(instance);
    callbacksLeftToRun++;
  };
  registerCallback(AfterRenderPhase.EarlyRead, spec.earlyRead);
  registerCallback(AfterRenderPhase.Write, spec.write);
  registerCallback(AfterRenderPhase.MixedReadWrite, spec.mixedReadWrite);
  registerCallback(AfterRenderPhase.Read, spec.read);
  return {
    destroy
  };
}
var AfterRenderCallback = class {
  constructor(phase, pipelinedArgs, callbackFn) {
    this.phase = phase;
    this.pipelinedArgs = pipelinedArgs;
    this.callbackFn = callbackFn;
    this.zone = inject(NgZone);
    this.errorHandler = inject(ErrorHandler, {
      optional: true
    });
    inject(ChangeDetectionScheduler, {
      optional: true
    })?.notify(
      6
      /* NotificationSource.NewRenderHook */
    );
  }
  invoke() {
    try {
      const result = this.zone.runOutsideAngular(() => this.callbackFn.apply(null, this.pipelinedArgs));
      this.pipelinedArgs.splice(0, this.pipelinedArgs.length, result);
    } catch (err) {
      this.errorHandler?.handleError(err);
    }
  }
};
var AfterRenderCallbackHandlerImpl = class {
  constructor() {
    this.executingCallbacks = false;
    this.buckets = {
      // Note: the order of these keys controls the order the phases are run.
      [AfterRenderPhase.EarlyRead]: /* @__PURE__ */ new Set(),
      [AfterRenderPhase.Write]: /* @__PURE__ */ new Set(),
      [AfterRenderPhase.MixedReadWrite]: /* @__PURE__ */ new Set(),
      [AfterRenderPhase.Read]: /* @__PURE__ */ new Set()
    };
    this.deferredCallbacks = /* @__PURE__ */ new Set();
  }
  register(callback) {
    const target = this.executingCallbacks ? this.deferredCallbacks : this.buckets[callback.phase];
    target.add(callback);
  }
  unregister(callback) {
    this.buckets[callback.phase].delete(callback);
    this.deferredCallbacks.delete(callback);
  }
  execute() {
    this.executingCallbacks = true;
    for (const bucket of Object.values(this.buckets)) {
      for (const callback of bucket) {
        callback.invoke();
      }
    }
    this.executingCallbacks = false;
    for (const callback of this.deferredCallbacks) {
      this.buckets[callback.phase].add(callback);
    }
    this.deferredCallbacks.clear();
  }
  destroy() {
    for (const bucket of Object.values(this.buckets)) {
      bucket.clear();
    }
    this.deferredCallbacks.clear();
  }
};
var AfterRenderEventManager = class _AfterRenderEventManager {
  constructor() {
    this.handler = null;
    this.internalCallbacks = [];
  }
  /**
   * Executes internal and user-provided callbacks.
   */
  execute() {
    this.executeInternalCallbacks();
    this.handler?.execute();
  }
  executeInternalCallbacks() {
    const callbacks = [...this.internalCallbacks];
    this.internalCallbacks.length = 0;
    for (const callback of callbacks) {
      callback();
    }
  }
  ngOnDestroy() {
    this.handler?.destroy();
    this.handler = null;
    this.internalCallbacks.length = 0;
  }
  static {
    this.ɵprov = ɵɵdefineInjectable({
      token: _AfterRenderEventManager,
      providedIn: "root",
      factory: () => new _AfterRenderEventManager()
    });
  }
};
function isModuleWithProviders(value) {
  return value.ngModule !== void 0;
}
function isNgModule(value) {
  return !!getNgModuleDef(value);
}
function isPipe(value) {
  return !!getPipeDef$1(value);
}
function isDirective(value) {
  return !!getDirectiveDef(value);
}
function isComponent(value) {
  return !!getComponentDef(value);
}
function getDependencyTypeForError(type) {
  if (getComponentDef(type)) return "component";
  if (getDirectiveDef(type)) return "directive";
  if (getPipeDef$1(type)) return "pipe";
  return "type";
}
function verifyStandaloneImport(depType, importingType) {
  if (isForwardRef(depType)) {
    depType = resolveForwardRef(depType);
    if (!depType) {
      throw new Error(`Expected forwardRef function, imported from "${stringifyForError(importingType)}", to return a standalone entity or NgModule but got "${stringifyForError(depType) || depType}".`);
    }
  }
  if (getNgModuleDef(depType) == null) {
    const def = getComponentDef(depType) || getDirectiveDef(depType) || getPipeDef$1(depType);
    if (def != null) {
      if (!def.standalone) {
        throw new Error(`The "${stringifyForError(depType)}" ${getDependencyTypeForError(depType)}, imported from "${stringifyForError(importingType)}", is not standalone. Did you forget to add the standalone: true flag?`);
      }
    } else {
      if (isModuleWithProviders(depType)) {
        throw new Error(`A module with providers was imported from "${stringifyForError(importingType)}". Modules with providers are not supported in standalone components imports.`);
      } else {
        throw new Error(`The "${stringifyForError(depType)}" type, imported from "${stringifyForError(importingType)}", must be a standalone component / directive / pipe or an NgModule. Did you forget to add the required @Component / @Directive / @Pipe or @NgModule annotation?`);
      }
    }
  }
}
var USE_RUNTIME_DEPS_TRACKER_FOR_JIT = true;
var DepsTracker = class {
  constructor() {
    this.ownerNgModule = /* @__PURE__ */ new Map();
    this.ngModulesWithSomeUnresolvedDecls = /* @__PURE__ */ new Set();
    this.ngModulesScopeCache = /* @__PURE__ */ new Map();
    this.standaloneComponentsScopeCache = /* @__PURE__ */ new Map();
  }
  /**
   * Attempts to resolve ng module's forward ref declarations as much as possible and add them to
   * the `ownerNgModule` map. This method normally should be called after the initial parsing when
   * all the forward refs are resolved (e.g., when trying to render a component)
   */
  resolveNgModulesDecls() {
    if (this.ngModulesWithSomeUnresolvedDecls.size === 0) {
      return;
    }
    for (const moduleType of this.ngModulesWithSomeUnresolvedDecls) {
      const def = getNgModuleDef(moduleType);
      if (def?.declarations) {
        for (const decl of maybeUnwrapFn(def.declarations)) {
          if (isComponent(decl)) {
            this.ownerNgModule.set(decl, moduleType);
          }
        }
      }
    }
    this.ngModulesWithSomeUnresolvedDecls.clear();
  }
  /** @override */
  getComponentDependencies(type, rawImports) {
    this.resolveNgModulesDecls();
    const def = getComponentDef(type);
    if (def === null) {
      throw new Error(`Attempting to get component dependencies for a type that is not a component: ${type}`);
    }
    if (def.standalone) {
      const scope = this.getStandaloneComponentScope(type, rawImports);
      if (scope.compilation.isPoisoned) {
        return {
          dependencies: []
        };
      }
      return {
        dependencies: [...scope.compilation.directives, ...scope.compilation.pipes, ...scope.compilation.ngModules]
      };
    } else {
      if (!this.ownerNgModule.has(type)) {
        return {
          dependencies: []
        };
      }
      const scope = this.getNgModuleScope(this.ownerNgModule.get(type));
      if (scope.compilation.isPoisoned) {
        return {
          dependencies: []
        };
      }
      return {
        dependencies: [...scope.compilation.directives, ...scope.compilation.pipes]
      };
    }
  }
  /**
   * @override
   * This implementation does not make use of param scopeInfo since it assumes the scope info is
   * already added to the type itself through methods like {@link ɵɵsetNgModuleScope}
   */
  registerNgModule(type, scopeInfo) {
    if (!isNgModule(type)) {
      throw new Error(`Attempting to register a Type which is not NgModule as NgModule: ${type}`);
    }
    this.ngModulesWithSomeUnresolvedDecls.add(type);
  }
  /** @override */
  clearScopeCacheFor(type) {
    this.ngModulesScopeCache.delete(type);
    this.standaloneComponentsScopeCache.delete(type);
  }
  /** @override */
  getNgModuleScope(type) {
    if (this.ngModulesScopeCache.has(type)) {
      return this.ngModulesScopeCache.get(type);
    }
    const scope = this.computeNgModuleScope(type);
    this.ngModulesScopeCache.set(type, scope);
    return scope;
  }
  /** Compute NgModule scope afresh. */
  computeNgModuleScope(type) {
    const def = getNgModuleDef(type, true);
    const scope = {
      exported: {
        directives: /* @__PURE__ */ new Set(),
        pipes: /* @__PURE__ */ new Set()
      },
      compilation: {
        directives: /* @__PURE__ */ new Set(),
        pipes: /* @__PURE__ */ new Set()
      }
    };
    for (const imported of maybeUnwrapFn(def.imports)) {
      if (isNgModule(imported)) {
        const importedScope = this.getNgModuleScope(imported);
        addSet(importedScope.exported.directives, scope.compilation.directives);
        addSet(importedScope.exported.pipes, scope.compilation.pipes);
      } else if (isStandalone(imported)) {
        if (isDirective(imported) || isComponent(imported)) {
          scope.compilation.directives.add(imported);
        } else if (isPipe(imported)) {
          scope.compilation.pipes.add(imported);
        } else {
          throw new RuntimeError(1e3, "The standalone imported type is neither a component nor a directive nor a pipe");
        }
      } else {
        scope.compilation.isPoisoned = true;
        break;
      }
    }
    if (!scope.compilation.isPoisoned) {
      for (const decl of maybeUnwrapFn(def.declarations)) {
        if (isNgModule(decl) || isStandalone(decl)) {
          scope.compilation.isPoisoned = true;
          break;
        }
        if (isPipe(decl)) {
          scope.compilation.pipes.add(decl);
        } else {
          scope.compilation.directives.add(decl);
        }
      }
    }
    for (const exported of maybeUnwrapFn(def.exports)) {
      if (isNgModule(exported)) {
        const exportedScope = this.getNgModuleScope(exported);
        addSet(exportedScope.exported.directives, scope.exported.directives);
        addSet(exportedScope.exported.pipes, scope.exported.pipes);
        addSet(exportedScope.exported.directives, scope.compilation.directives);
        addSet(exportedScope.exported.pipes, scope.compilation.pipes);
      } else if (isPipe(exported)) {
        scope.exported.pipes.add(exported);
      } else {
        scope.exported.directives.add(exported);
      }
    }
    return scope;
  }
  /** @override */
  getStandaloneComponentScope(type, rawImports) {
    if (this.standaloneComponentsScopeCache.has(type)) {
      return this.standaloneComponentsScopeCache.get(type);
    }
    const ans = this.computeStandaloneComponentScope(type, rawImports);
    this.standaloneComponentsScopeCache.set(type, ans);
    return ans;
  }
  computeStandaloneComponentScope(type, rawImports) {
    const ans = {
      compilation: {
        // Standalone components are always able to self-reference.
        directives: /* @__PURE__ */ new Set([type]),
        pipes: /* @__PURE__ */ new Set(),
        ngModules: /* @__PURE__ */ new Set()
      }
    };
    for (const rawImport of flatten(rawImports ?? [])) {
      const imported = resolveForwardRef(rawImport);
      try {
        verifyStandaloneImport(imported, type);
      } catch (e) {
        ans.compilation.isPoisoned = true;
        return ans;
      }
      if (isNgModule(imported)) {
        ans.compilation.ngModules.add(imported);
        const importedScope = this.getNgModuleScope(imported);
        if (importedScope.exported.isPoisoned) {
          ans.compilation.isPoisoned = true;
          return ans;
        }
        addSet(importedScope.exported.directives, ans.compilation.directives);
        addSet(importedScope.exported.pipes, ans.compilation.pipes);
      } else if (isPipe(imported)) {
        ans.compilation.pipes.add(imported);
      } else if (isDirective(imported) || isComponent(imported)) {
        ans.compilation.directives.add(imported);
      } else {
        ans.compilation.isPoisoned = true;
        return ans;
      }
    }
    return ans;
  }
  /** @override */
  isOrphanComponent(cmp) {
    const def = getComponentDef(cmp);
    if (!def || def.standalone) {
      return false;
    }
    this.resolveNgModulesDecls();
    return !this.ownerNgModule.has(cmp);
  }
};
function addSet(sourceSet, targetSet) {
  for (const m of sourceSet) {
    targetSet.add(m);
  }
}
var depsTracker = new DepsTracker();
function computeStaticStyling(tNode, attrs, writeToHost) {
  ngDevMode && assertFirstCreatePass(getTView(), "Expecting to be called in first template pass only");
  let styles = writeToHost ? tNode.styles : null;
  let classes = writeToHost ? tNode.classes : null;
  let mode = 0;
  if (attrs !== null) {
    for (let i = 0; i < attrs.length; i++) {
      const value = attrs[i];
      if (typeof value === "number") {
        mode = value;
      } else if (mode == 1) {
        classes = concatStringsWithSpace(classes, value);
      } else if (mode == 2) {
        const style = value;
        const styleValue = attrs[++i];
        styles = concatStringsWithSpace(styles, style + ": " + styleValue + ";");
      }
    }
  }
  writeToHost ? tNode.styles = styles : tNode.stylesWithoutHost = styles;
  writeToHost ? tNode.classes = classes : tNode.classesWithoutHost = classes;
}
var ComponentFactoryResolver = class extends ComponentFactoryResolver$1 {
  /**
   * @param ngModule The NgModuleRef to which all resolved factories are bound.
   */
  constructor(ngModule) {
    super();
    this.ngModule = ngModule;
  }
  resolveComponentFactory(component) {
    ngDevMode && assertComponentType(component);
    const componentDef = getComponentDef(component);
    return new ComponentFactory(componentDef, this.ngModule);
  }
};
function toRefArray(map2, isInputMap) {
  const array = [];
  for (const publicName in map2) {
    if (!map2.hasOwnProperty(publicName)) {
      continue;
    }
    const value = map2[publicName];
    if (value === void 0) {
      continue;
    }
    const isArray = Array.isArray(value);
    const propName = isArray ? value[0] : value;
    const flags = isArray ? value[1] : InputFlags.None;
    if (isInputMap) {
      array.push({
        propName,
        templateName: publicName,
        isSignal: (flags & InputFlags.SignalBased) !== 0
      });
    } else {
      array.push({
        propName,
        templateName: publicName
      });
    }
  }
  return array;
}
function getNamespace(elementName) {
  const name = elementName.toLowerCase();
  return name === "svg" ? SVG_NAMESPACE : name === "math" ? MATH_ML_NAMESPACE : null;
}
var ComponentFactory = class extends ComponentFactory$1 {
  get inputs() {
    const componentDef = this.componentDef;
    const inputTransforms = componentDef.inputTransforms;
    const refArray = toRefArray(componentDef.inputs, true);
    if (inputTransforms !== null) {
      for (const input2 of refArray) {
        if (inputTransforms.hasOwnProperty(input2.propName)) {
          input2.transform = inputTransforms[input2.propName];
        }
      }
    }
    return refArray;
  }
  get outputs() {
    return toRefArray(this.componentDef.outputs, false);
  }
  /**
   * @param componentDef The component definition.
   * @param ngModule The NgModuleRef to which the factory is bound.
   */
  constructor(componentDef, ngModule) {
    super();
    this.componentDef = componentDef;
    this.ngModule = ngModule;
    this.componentType = componentDef.type;
    this.selector = stringifyCSSSelectorList(componentDef.selectors);
    this.ngContentSelectors = componentDef.ngContentSelectors ? componentDef.ngContentSelectors : [];
    this.isBoundToModule = !!ngModule;
  }
  create(injector, projectableNodes, rootSelectorOrNode, environmentInjector) {
    const prevConsumer = setActiveConsumer(null);
    try {
      if (ngDevMode && (typeof ngJitMode === "undefined" || ngJitMode) && this.componentDef.debugInfo?.forbidOrphanRendering) {
        if (depsTracker.isOrphanComponent(this.componentType)) {
          throw new RuntimeError(1001, `Orphan component found! Trying to render the component ${debugStringifyTypeForError(this.componentType)} without first loading the NgModule that declares it. It is recommended to make this component standalone in order to avoid this error. If this is not possible now, import the component's NgModule in the appropriate NgModule, or the standalone component in which you are trying to render this component. If this is a lazy import, load the NgModule lazily as well and use its module injector.`);
        }
      }
      environmentInjector = environmentInjector || this.ngModule;
      let realEnvironmentInjector = environmentInjector instanceof EnvironmentInjector ? environmentInjector : environmentInjector?.injector;
      if (realEnvironmentInjector && this.componentDef.getStandaloneInjector !== null) {
        realEnvironmentInjector = this.componentDef.getStandaloneInjector(realEnvironmentInjector) || realEnvironmentInjector;
      }
      const rootViewInjector = realEnvironmentInjector ? new ChainedInjector(injector, realEnvironmentInjector) : injector;
      const rendererFactory = rootViewInjector.get(RendererFactory2, null);
      if (rendererFactory === null) {
        throw new RuntimeError(407, ngDevMode && "Angular was not able to inject a renderer (RendererFactory2). Likely this is due to a broken DI hierarchy. Make sure that any injector used to create this component has a correct parent.");
      }
      const sanitizer = rootViewInjector.get(Sanitizer, null);
      const afterRenderEventManager = rootViewInjector.get(AfterRenderEventManager, null);
      const changeDetectionScheduler = rootViewInjector.get(ChangeDetectionScheduler, null);
      const environment = {
        rendererFactory,
        sanitizer,
        // We don't use inline effects (yet).
        inlineEffectRunner: null,
        afterRenderEventManager,
        changeDetectionScheduler
      };
      const hostRenderer = rendererFactory.createRenderer(null, this.componentDef);
      const elementName = this.componentDef.selectors[0][0] || "div";
      const hostRNode = rootSelectorOrNode ? locateHostElement(hostRenderer, rootSelectorOrNode, this.componentDef.encapsulation, rootViewInjector) : createElementNode(hostRenderer, elementName, getNamespace(elementName));
      let rootFlags = 512;
      if (this.componentDef.signals) {
        rootFlags |= 4096;
      } else if (!this.componentDef.onPush) {
        rootFlags |= 16;
      }
      let hydrationInfo = null;
      if (hostRNode !== null) {
        hydrationInfo = retrieveHydrationInfo(
          hostRNode,
          rootViewInjector,
          true
          /* isRootView */
        );
      }
      const rootTView = createTView(0, null, null, 1, 0, null, null, null, null, null, null);
      const rootLView = createLView(null, rootTView, null, rootFlags, null, null, environment, hostRenderer, rootViewInjector, null, hydrationInfo);
      enterView(rootLView);
      let component;
      let tElementNode;
      try {
        const rootComponentDef = this.componentDef;
        let rootDirectives;
        let hostDirectiveDefs = null;
        if (rootComponentDef.findHostDirectiveDefs) {
          rootDirectives = [];
          hostDirectiveDefs = /* @__PURE__ */ new Map();
          rootComponentDef.findHostDirectiveDefs(rootComponentDef, rootDirectives, hostDirectiveDefs);
          rootDirectives.push(rootComponentDef);
          ngDevMode && assertNoDuplicateDirectives(rootDirectives);
        } else {
          rootDirectives = [rootComponentDef];
        }
        const hostTNode = createRootComponentTNode(rootLView, hostRNode);
        const componentView = createRootComponentView(hostTNode, hostRNode, rootComponentDef, rootDirectives, rootLView, environment, hostRenderer);
        tElementNode = getTNode(rootTView, HEADER_OFFSET);
        if (hostRNode) {
          setRootNodeAttributes(hostRenderer, rootComponentDef, hostRNode, rootSelectorOrNode);
        }
        if (projectableNodes !== void 0) {
          projectNodes(tElementNode, this.ngContentSelectors, projectableNodes);
        }
        component = createRootComponent(componentView, rootComponentDef, rootDirectives, hostDirectiveDefs, rootLView, [LifecycleHooksFeature]);
        renderView(rootTView, rootLView, null);
      } finally {
        leaveView();
      }
      return new ComponentRef(this.componentType, component, createElementRef(tElementNode, rootLView), rootLView, tElementNode);
    } finally {
      setActiveConsumer(prevConsumer);
    }
  }
};
var ComponentRef = class extends ComponentRef$1 {
  constructor(componentType, instance, location2, _rootLView, _tNode) {
    super();
    this.location = location2;
    this._rootLView = _rootLView;
    this._tNode = _tNode;
    this.previousInputValues = null;
    this.instance = instance;
    this.hostView = this.changeDetectorRef = new ViewRef$1(
      _rootLView,
      void 0,
      false
      /* notifyErrorHandler */
    );
    this.componentType = componentType;
  }
  setInput(name, value) {
    const inputData = this._tNode.inputs;
    let dataValue;
    if (inputData !== null && (dataValue = inputData[name])) {
      this.previousInputValues ??= /* @__PURE__ */ new Map();
      if (this.previousInputValues.has(name) && Object.is(this.previousInputValues.get(name), value)) {
        return;
      }
      const lView = this._rootLView;
      setInputsForProperty(lView[TVIEW], lView, dataValue, name, value);
      this.previousInputValues.set(name, value);
      const childComponentLView = getComponentLViewByIndex(this._tNode.index, lView);
      markViewDirty(
        childComponentLView,
        1
        /* NotificationSource.SetInput */
      );
    } else {
      if (ngDevMode) {
        const cmpNameForError = stringifyForError(this.componentType);
        let message = `Can't set value of the '${name}' input on the '${cmpNameForError}' component. `;
        message += `Make sure that the '${name}' property is annotated with @Input() or a mapped @Input('${name}') exists.`;
        reportUnknownPropertyError(message);
      }
    }
  }
  get injector() {
    return new NodeInjector(this._tNode, this._rootLView);
  }
  destroy() {
    this.hostView.destroy();
  }
  onDestroy(callback) {
    this.hostView.onDestroy(callback);
  }
};
function createRootComponentTNode(lView, rNode) {
  const tView = lView[TVIEW];
  const index = HEADER_OFFSET;
  ngDevMode && assertIndexInRange(lView, index);
  lView[index] = rNode;
  return getOrCreateTNode(tView, index, 2, "#host", null);
}
function createRootComponentView(tNode, hostRNode, rootComponentDef, rootDirectives, rootView, environment, hostRenderer) {
  const tView = rootView[TVIEW];
  applyRootComponentStyling(rootDirectives, tNode, hostRNode, hostRenderer);
  let hydrationInfo = null;
  if (hostRNode !== null) {
    hydrationInfo = retrieveHydrationInfo(hostRNode, rootView[INJECTOR]);
  }
  const viewRenderer = environment.rendererFactory.createRenderer(hostRNode, rootComponentDef);
  let lViewFlags = 16;
  if (rootComponentDef.signals) {
    lViewFlags = 4096;
  } else if (rootComponentDef.onPush) {
    lViewFlags = 64;
  }
  const componentView = createLView(rootView, getOrCreateComponentTView(rootComponentDef), null, lViewFlags, rootView[tNode.index], tNode, environment, viewRenderer, null, null, hydrationInfo);
  if (tView.firstCreatePass) {
    markAsComponentHost(tView, tNode, rootDirectives.length - 1);
  }
  addToViewTree(rootView, componentView);
  return rootView[tNode.index] = componentView;
}
function applyRootComponentStyling(rootDirectives, tNode, rNode, hostRenderer) {
  for (const def of rootDirectives) {
    tNode.mergedAttrs = mergeHostAttrs(tNode.mergedAttrs, def.hostAttrs);
  }
  if (tNode.mergedAttrs !== null) {
    computeStaticStyling(tNode, tNode.mergedAttrs, true);
    if (rNode !== null) {
      setupStaticAttributes(hostRenderer, rNode, tNode);
    }
  }
}
function createRootComponent(componentView, rootComponentDef, rootDirectives, hostDirectiveDefs, rootLView, hostFeatures) {
  const rootTNode = getCurrentTNode();
  ngDevMode && assertDefined(rootTNode, "tNode should have been already created");
  const tView = rootLView[TVIEW];
  const native = getNativeByTNode(rootTNode, rootLView);
  initializeDirectives(tView, rootLView, rootTNode, rootDirectives, null, hostDirectiveDefs);
  for (let i = 0; i < rootDirectives.length; i++) {
    const directiveIndex = rootTNode.directiveStart + i;
    const directiveInstance = getNodeInjectable(rootLView, tView, directiveIndex, rootTNode);
    attachPatchData(directiveInstance, rootLView);
  }
  invokeDirectivesHostBindings(tView, rootLView, rootTNode);
  if (native) {
    attachPatchData(native, rootLView);
  }
  ngDevMode && assertGreaterThan(rootTNode.componentOffset, -1, "componentOffset must be great than -1");
  const component = getNodeInjectable(rootLView, tView, rootTNode.directiveStart + rootTNode.componentOffset, rootTNode);
  componentView[CONTEXT] = rootLView[CONTEXT] = component;
  if (hostFeatures !== null) {
    for (const feature of hostFeatures) {
      feature(component, rootComponentDef);
    }
  }
  executeContentQueries(tView, rootTNode, rootLView);
  return component;
}
function setRootNodeAttributes(hostRenderer, componentDef, hostRNode, rootSelectorOrNode) {
  if (rootSelectorOrNode) {
    setUpAttributes(hostRenderer, hostRNode, ["ng-version", "18.2.0"]);
  } else {
    const {
      attrs,
      classes
    } = extractAttrsAndClassesFromSelector(componentDef.selectors[0]);
    if (attrs) {
      setUpAttributes(hostRenderer, hostRNode, attrs);
    }
    if (classes && classes.length > 0) {
      writeDirectClass(hostRenderer, hostRNode, classes.join(" "));
    }
  }
}
function projectNodes(tNode, ngContentSelectors, projectableNodes) {
  const projection = tNode.projection = [];
  for (let i = 0; i < ngContentSelectors.length; i++) {
    const nodesforSlot = projectableNodes[i];
    projection.push(nodesforSlot != null ? Array.from(nodesforSlot) : null);
  }
}
function LifecycleHooksFeature() {
  const tNode = getCurrentTNode();
  ngDevMode && assertDefined(tNode, "TNode is required");
  registerPostOrderHooks(getLView()[TVIEW], tNode);
}
var ViewContainerRef = class {
  static {
    this.__NG_ELEMENT_ID__ = injectViewContainerRef;
  }
};
function injectViewContainerRef() {
  const previousTNode = getCurrentTNode();
  return createContainerRef(previousTNode, getLView());
}
var VE_ViewContainerRef = ViewContainerRef;
var R3ViewContainerRef = class ViewContainerRef2 extends VE_ViewContainerRef {
  constructor(_lContainer, _hostTNode, _hostLView) {
    super();
    this._lContainer = _lContainer;
    this._hostTNode = _hostTNode;
    this._hostLView = _hostLView;
  }
  get element() {
    return createElementRef(this._hostTNode, this._hostLView);
  }
  get injector() {
    return new NodeInjector(this._hostTNode, this._hostLView);
  }
  /** @deprecated No replacement */
  get parentInjector() {
    const parentLocation = getParentInjectorLocation(this._hostTNode, this._hostLView);
    if (hasParentInjector(parentLocation)) {
      const parentView = getParentInjectorView(parentLocation, this._hostLView);
      const injectorIndex = getParentInjectorIndex(parentLocation);
      ngDevMode && assertNodeInjector(parentView, injectorIndex);
      const parentTNode = parentView[TVIEW].data[
        injectorIndex + 8
        /* NodeInjectorOffset.TNODE */
      ];
      return new NodeInjector(parentTNode, parentView);
    } else {
      return new NodeInjector(null, this._hostLView);
    }
  }
  clear() {
    while (this.length > 0) {
      this.remove(this.length - 1);
    }
  }
  get(index) {
    const viewRefs = getViewRefs(this._lContainer);
    return viewRefs !== null && viewRefs[index] || null;
  }
  get length() {
    return this._lContainer.length - CONTAINER_HEADER_OFFSET;
  }
  createEmbeddedView(templateRef, context, indexOrOptions) {
    let index;
    let injector;
    if (typeof indexOrOptions === "number") {
      index = indexOrOptions;
    } else if (indexOrOptions != null) {
      index = indexOrOptions.index;
      injector = indexOrOptions.injector;
    }
    const dehydratedView = findMatchingDehydratedView(this._lContainer, templateRef.ssrId);
    const viewRef = templateRef.createEmbeddedViewImpl(context || {}, injector, dehydratedView);
    this.insertImpl(viewRef, index, shouldAddViewToDom(this._hostTNode, dehydratedView));
    return viewRef;
  }
  createComponent(componentFactoryOrType, indexOrOptions, injector, projectableNodes, environmentInjector) {
    const isComponentFactory = componentFactoryOrType && !isType(componentFactoryOrType);
    let index;
    if (isComponentFactory) {
      if (ngDevMode) {
        assertEqual(typeof indexOrOptions !== "object", true, "It looks like Component factory was provided as the first argument and an options object as the second argument. This combination of arguments is incompatible. You can either change the first argument to provide Component type or change the second argument to be a number (representing an index at which to insert the new component's host view into this container)");
      }
      index = indexOrOptions;
    } else {
      if (ngDevMode) {
        assertDefined(getComponentDef(componentFactoryOrType), `Provided Component class doesn't contain Component definition. Please check whether provided class has @Component decorator.`);
        assertEqual(typeof indexOrOptions !== "number", true, "It looks like Component type was provided as the first argument and a number (representing an index at which to insert the new component's host view into this container as the second argument. This combination of arguments is incompatible. Please use an object as the second argument instead.");
      }
      const options = indexOrOptions || {};
      if (ngDevMode && options.environmentInjector && options.ngModuleRef) {
        throwError(`Cannot pass both environmentInjector and ngModuleRef options to createComponent().`);
      }
      index = options.index;
      injector = options.injector;
      projectableNodes = options.projectableNodes;
      environmentInjector = options.environmentInjector || options.ngModuleRef;
    }
    const componentFactory = isComponentFactory ? componentFactoryOrType : new ComponentFactory(getComponentDef(componentFactoryOrType));
    const contextInjector = injector || this.parentInjector;
    if (!environmentInjector && componentFactory.ngModule == null) {
      const _injector = isComponentFactory ? contextInjector : this.parentInjector;
      const result = _injector.get(EnvironmentInjector, null);
      if (result) {
        environmentInjector = result;
      }
    }
    const componentDef = getComponentDef(componentFactory.componentType ?? {});
    const dehydratedView = findMatchingDehydratedView(this._lContainer, componentDef?.id ?? null);
    const rNode = dehydratedView?.firstChild ?? null;
    const componentRef = componentFactory.create(contextInjector, projectableNodes, rNode, environmentInjector);
    this.insertImpl(componentRef.hostView, index, shouldAddViewToDom(this._hostTNode, dehydratedView));
    return componentRef;
  }
  insert(viewRef, index) {
    return this.insertImpl(viewRef, index, true);
  }
  insertImpl(viewRef, index, addToDOM) {
    const lView = viewRef._lView;
    if (ngDevMode && viewRef.destroyed) {
      throw new Error("Cannot insert a destroyed View in a ViewContainer!");
    }
    if (viewAttachedToContainer(lView)) {
      const prevIdx = this.indexOf(viewRef);
      if (prevIdx !== -1) {
        this.detach(prevIdx);
      } else {
        const prevLContainer = lView[PARENT];
        ngDevMode && assertEqual(isLContainer(prevLContainer), true, "An attached view should have its PARENT point to a container.");
        const prevVCRef = new R3ViewContainerRef(prevLContainer, prevLContainer[T_HOST], prevLContainer[PARENT]);
        prevVCRef.detach(prevVCRef.indexOf(viewRef));
      }
    }
    const adjustedIdx = this._adjustIndex(index);
    const lContainer = this._lContainer;
    addLViewToLContainer(lContainer, lView, adjustedIdx, addToDOM);
    viewRef.attachToViewContainerRef();
    addToArray(getOrCreateViewRefs(lContainer), adjustedIdx, viewRef);
    return viewRef;
  }
  move(viewRef, newIndex) {
    if (ngDevMode && viewRef.destroyed) {
      throw new Error("Cannot move a destroyed View in a ViewContainer!");
    }
    return this.insert(viewRef, newIndex);
  }
  indexOf(viewRef) {
    const viewRefsArr = getViewRefs(this._lContainer);
    return viewRefsArr !== null ? viewRefsArr.indexOf(viewRef) : -1;
  }
  remove(index) {
    const adjustedIdx = this._adjustIndex(index, -1);
    const detachedView = detachView(this._lContainer, adjustedIdx);
    if (detachedView) {
      removeFromArray(getOrCreateViewRefs(this._lContainer), adjustedIdx);
      destroyLView(detachedView[TVIEW], detachedView);
    }
  }
  detach(index) {
    const adjustedIdx = this._adjustIndex(index, -1);
    const view = detachView(this._lContainer, adjustedIdx);
    const wasDetached = view && removeFromArray(getOrCreateViewRefs(this._lContainer), adjustedIdx) != null;
    return wasDetached ? new ViewRef$1(view) : null;
  }
  _adjustIndex(index, shift = 0) {
    if (index == null) {
      return this.length + shift;
    }
    if (ngDevMode) {
      assertGreaterThan(index, -1, `ViewRef index must be positive, got ${index}`);
      assertLessThan(index, this.length + 1 + shift, "index");
    }
    return index;
  }
};
function getViewRefs(lContainer) {
  return lContainer[VIEW_REFS];
}
function getOrCreateViewRefs(lContainer) {
  return lContainer[VIEW_REFS] || (lContainer[VIEW_REFS] = []);
}
function createContainerRef(hostTNode, hostLView) {
  ngDevMode && assertTNodeType(
    hostTNode,
    12 | 3
    /* TNodeType.AnyRNode */
  );
  let lContainer;
  const slotValue = hostLView[hostTNode.index];
  if (isLContainer(slotValue)) {
    lContainer = slotValue;
  } else {
    lContainer = createLContainer(slotValue, hostLView, null, hostTNode);
    hostLView[hostTNode.index] = lContainer;
    addToViewTree(hostLView, lContainer);
  }
  _locateOrCreateAnchorNode(lContainer, hostLView, hostTNode, slotValue);
  return new R3ViewContainerRef(lContainer, hostTNode, hostLView);
}
function insertAnchorNode(hostLView, hostTNode) {
  const renderer = hostLView[RENDERER];
  ngDevMode && ngDevMode.rendererCreateComment++;
  const commentNode = renderer.createComment(ngDevMode ? "container" : "");
  const hostNative = getNativeByTNode(hostTNode, hostLView);
  const parentOfHostNative = nativeParentNode(renderer, hostNative);
  nativeInsertBefore(renderer, parentOfHostNative, commentNode, nativeNextSibling(renderer, hostNative), false);
  return commentNode;
}
var _locateOrCreateAnchorNode = createAnchorNode;
var _populateDehydratedViewsInLContainer = () => false;
function populateDehydratedViewsInLContainer(lContainer, tNode, hostLView) {
  return _populateDehydratedViewsInLContainer(lContainer, tNode, hostLView);
}
function createAnchorNode(lContainer, hostLView, hostTNode, slotValue) {
  if (lContainer[NATIVE]) return;
  let commentNode;
  if (hostTNode.type & 8) {
    commentNode = unwrapRNode(slotValue);
  } else {
    commentNode = insertAnchorNode(hostLView, hostTNode);
  }
  lContainer[NATIVE] = commentNode;
}
function populateDehydratedViewsInLContainerImpl(lContainer, tNode, hostLView) {
  if (lContainer[NATIVE] && lContainer[DEHYDRATED_VIEWS]) {
    return true;
  }
  const hydrationInfo = hostLView[HYDRATION];
  const noOffsetIndex = tNode.index - HEADER_OFFSET;
  const isNodeCreationMode = !hydrationInfo || isInSkipHydrationBlock(tNode) || isDisconnectedNode$1(hydrationInfo, noOffsetIndex);
  if (isNodeCreationMode) {
    return false;
  }
  const currentRNode = getSegmentHead(hydrationInfo, noOffsetIndex);
  const serializedViews = hydrationInfo.data[CONTAINERS]?.[noOffsetIndex];
  ngDevMode && assertDefined(serializedViews, "Unexpected state: no hydration info available for a given TNode, which represents a view container.");
  const [commentNode, dehydratedViews] = locateDehydratedViewsInContainer(currentRNode, serializedViews);
  if (ngDevMode) {
    validateMatchingNode(commentNode, Node.COMMENT_NODE, null, hostLView, tNode, true);
    markRNodeAsClaimedByHydration(commentNode, false);
  }
  lContainer[NATIVE] = commentNode;
  lContainer[DEHYDRATED_VIEWS] = dehydratedViews;
  return true;
}
function locateOrCreateAnchorNode(lContainer, hostLView, hostTNode, slotValue) {
  if (!_populateDehydratedViewsInLContainer(lContainer, hostTNode, hostLView)) {
    createAnchorNode(lContainer, hostLView, hostTNode, slotValue);
  }
}
function enableLocateOrCreateContainerRefImpl() {
  _locateOrCreateAnchorNode = locateOrCreateAnchorNode;
  _populateDehydratedViewsInLContainer = populateDehydratedViewsInLContainerImpl;
}
var LQuery_ = class _LQuery_ {
  constructor(queryList) {
    this.queryList = queryList;
    this.matches = null;
  }
  clone() {
    return new _LQuery_(this.queryList);
  }
  setDirty() {
    this.queryList.setDirty();
  }
};
var LQueries_ = class _LQueries_ {
  constructor(queries = []) {
    this.queries = queries;
  }
  createEmbeddedView(tView) {
    const tQueries = tView.queries;
    if (tQueries !== null) {
      const noOfInheritedQueries = tView.contentQueries !== null ? tView.contentQueries[0] : tQueries.length;
      const viewLQueries = [];
      for (let i = 0; i < noOfInheritedQueries; i++) {
        const tQuery = tQueries.getByIndex(i);
        const parentLQuery = this.queries[tQuery.indexInDeclarationView];
        viewLQueries.push(parentLQuery.clone());
      }
      return new _LQueries_(viewLQueries);
    }
    return null;
  }
  insertView(tView) {
    this.dirtyQueriesWithMatches(tView);
  }
  detachView(tView) {
    this.dirtyQueriesWithMatches(tView);
  }
  finishViewCreation(tView) {
    this.dirtyQueriesWithMatches(tView);
  }
  dirtyQueriesWithMatches(tView) {
    for (let i = 0; i < this.queries.length; i++) {
      if (getTQuery(tView, i).matches !== null) {
        this.queries[i].setDirty();
      }
    }
  }
};
var TQueryMetadata_ = class {
  constructor(predicate, flags, read = null) {
    this.flags = flags;
    this.read = read;
    if (typeof predicate === "string") {
      this.predicate = splitQueryMultiSelectors(predicate);
    } else {
      this.predicate = predicate;
    }
  }
};
var TQueries_ = class _TQueries_ {
  constructor(queries = []) {
    this.queries = queries;
  }
  elementStart(tView, tNode) {
    ngDevMode && assertFirstCreatePass(tView, "Queries should collect results on the first template pass only");
    for (let i = 0; i < this.queries.length; i++) {
      this.queries[i].elementStart(tView, tNode);
    }
  }
  elementEnd(tNode) {
    for (let i = 0; i < this.queries.length; i++) {
      this.queries[i].elementEnd(tNode);
    }
  }
  embeddedTView(tNode) {
    let queriesForTemplateRef = null;
    for (let i = 0; i < this.length; i++) {
      const childQueryIndex = queriesForTemplateRef !== null ? queriesForTemplateRef.length : 0;
      const tqueryClone = this.getByIndex(i).embeddedTView(tNode, childQueryIndex);
      if (tqueryClone) {
        tqueryClone.indexInDeclarationView = i;
        if (queriesForTemplateRef !== null) {
          queriesForTemplateRef.push(tqueryClone);
        } else {
          queriesForTemplateRef = [tqueryClone];
        }
      }
    }
    return queriesForTemplateRef !== null ? new _TQueries_(queriesForTemplateRef) : null;
  }
  template(tView, tNode) {
    ngDevMode && assertFirstCreatePass(tView, "Queries should collect results on the first template pass only");
    for (let i = 0; i < this.queries.length; i++) {
      this.queries[i].template(tView, tNode);
    }
  }
  getByIndex(index) {
    ngDevMode && assertIndexInRange(this.queries, index);
    return this.queries[index];
  }
  get length() {
    return this.queries.length;
  }
  track(tquery) {
    this.queries.push(tquery);
  }
};
var TQuery_ = class _TQuery_ {
  constructor(metadata, nodeIndex = -1) {
    this.metadata = metadata;
    this.matches = null;
    this.indexInDeclarationView = -1;
    this.crossesNgTemplate = false;
    this._appliesToNextNode = true;
    this._declarationNodeIndex = nodeIndex;
  }
  elementStart(tView, tNode) {
    if (this.isApplyingToNode(tNode)) {
      this.matchTNode(tView, tNode);
    }
  }
  elementEnd(tNode) {
    if (this._declarationNodeIndex === tNode.index) {
      this._appliesToNextNode = false;
    }
  }
  template(tView, tNode) {
    this.elementStart(tView, tNode);
  }
  embeddedTView(tNode, childQueryIndex) {
    if (this.isApplyingToNode(tNode)) {
      this.crossesNgTemplate = true;
      this.addMatch(-tNode.index, childQueryIndex);
      return new _TQuery_(this.metadata);
    }
    return null;
  }
  isApplyingToNode(tNode) {
    if (this._appliesToNextNode && (this.metadata.flags & 1) !== 1) {
      const declarationNodeIdx = this._declarationNodeIndex;
      let parent = tNode.parent;
      while (parent !== null && parent.type & 8 && parent.index !== declarationNodeIdx) {
        parent = parent.parent;
      }
      return declarationNodeIdx === (parent !== null ? parent.index : -1);
    }
    return this._appliesToNextNode;
  }
  matchTNode(tView, tNode) {
    const predicate = this.metadata.predicate;
    if (Array.isArray(predicate)) {
      for (let i = 0; i < predicate.length; i++) {
        const name = predicate[i];
        this.matchTNodeWithReadOption(tView, tNode, getIdxOfMatchingSelector(tNode, name));
        this.matchTNodeWithReadOption(tView, tNode, locateDirectiveOrProvider(tNode, tView, name, false, false));
      }
    } else {
      if (predicate === TemplateRef) {
        if (tNode.type & 4) {
          this.matchTNodeWithReadOption(tView, tNode, -1);
        }
      } else {
        this.matchTNodeWithReadOption(tView, tNode, locateDirectiveOrProvider(tNode, tView, predicate, false, false));
      }
    }
  }
  matchTNodeWithReadOption(tView, tNode, nodeMatchIdx) {
    if (nodeMatchIdx !== null) {
      const read = this.metadata.read;
      if (read !== null) {
        if (read === ElementRef || read === ViewContainerRef || read === TemplateRef && tNode.type & 4) {
          this.addMatch(tNode.index, -2);
        } else {
          const directiveOrProviderIdx = locateDirectiveOrProvider(tNode, tView, read, false, false);
          if (directiveOrProviderIdx !== null) {
            this.addMatch(tNode.index, directiveOrProviderIdx);
          }
        }
      } else {
        this.addMatch(tNode.index, nodeMatchIdx);
      }
    }
  }
  addMatch(tNodeIdx, matchIdx) {
    if (this.matches === null) {
      this.matches = [tNodeIdx, matchIdx];
    } else {
      this.matches.push(tNodeIdx, matchIdx);
    }
  }
};
function getIdxOfMatchingSelector(tNode, selector) {
  const localNames = tNode.localNames;
  if (localNames !== null) {
    for (let i = 0; i < localNames.length; i += 2) {
      if (localNames[i] === selector) {
        return localNames[i + 1];
      }
    }
  }
  return null;
}
function createResultByTNodeType(tNode, currentView) {
  if (tNode.type & (3 | 8)) {
    return createElementRef(tNode, currentView);
  } else if (tNode.type & 4) {
    return createTemplateRef(tNode, currentView);
  }
  return null;
}
function createResultForNode(lView, tNode, matchingIdx, read) {
  if (matchingIdx === -1) {
    return createResultByTNodeType(tNode, lView);
  } else if (matchingIdx === -2) {
    return createSpecialToken(lView, tNode, read);
  } else {
    return getNodeInjectable(lView, lView[TVIEW], matchingIdx, tNode);
  }
}
function createSpecialToken(lView, tNode, read) {
  if (read === ElementRef) {
    return createElementRef(tNode, lView);
  } else if (read === TemplateRef) {
    return createTemplateRef(tNode, lView);
  } else if (read === ViewContainerRef) {
    ngDevMode && assertTNodeType(
      tNode,
      3 | 12
      /* TNodeType.AnyContainer */
    );
    return createContainerRef(tNode, lView);
  } else {
    ngDevMode && throwError(`Special token to read should be one of ElementRef, TemplateRef or ViewContainerRef but got ${stringify(read)}.`);
  }
}
function materializeViewResults(tView, lView, tQuery, queryIndex) {
  const lQuery = lView[QUERIES].queries[queryIndex];
  if (lQuery.matches === null) {
    const tViewData = tView.data;
    const tQueryMatches = tQuery.matches;
    const result = [];
    for (let i = 0; tQueryMatches !== null && i < tQueryMatches.length; i += 2) {
      const matchedNodeIdx = tQueryMatches[i];
      if (matchedNodeIdx < 0) {
        result.push(null);
      } else {
        ngDevMode && assertIndexInRange(tViewData, matchedNodeIdx);
        const tNode = tViewData[matchedNodeIdx];
        result.push(createResultForNode(lView, tNode, tQueryMatches[i + 1], tQuery.metadata.read));
      }
    }
    lQuery.matches = result;
  }
  return lQuery.matches;
}
function collectQueryResults(tView, lView, queryIndex, result) {
  const tQuery = tView.queries.getByIndex(queryIndex);
  const tQueryMatches = tQuery.matches;
  if (tQueryMatches !== null) {
    const lViewResults = materializeViewResults(tView, lView, tQuery, queryIndex);
    for (let i = 0; i < tQueryMatches.length; i += 2) {
      const tNodeIdx = tQueryMatches[i];
      if (tNodeIdx > 0) {
        result.push(lViewResults[i / 2]);
      } else {
        const childQueryIndex = tQueryMatches[i + 1];
        const declarationLContainer = lView[-tNodeIdx];
        ngDevMode && assertLContainer(declarationLContainer);
        for (let i2 = CONTAINER_HEADER_OFFSET; i2 < declarationLContainer.length; i2++) {
          const embeddedLView = declarationLContainer[i2];
          if (embeddedLView[DECLARATION_LCONTAINER] === embeddedLView[PARENT]) {
            collectQueryResults(embeddedLView[TVIEW], embeddedLView, childQueryIndex, result);
          }
        }
        if (declarationLContainer[MOVED_VIEWS] !== null) {
          const embeddedLViews = declarationLContainer[MOVED_VIEWS];
          for (let i2 = 0; i2 < embeddedLViews.length; i2++) {
            const embeddedLView = embeddedLViews[i2];
            collectQueryResults(embeddedLView[TVIEW], embeddedLView, childQueryIndex, result);
          }
        }
      }
    }
  }
  return result;
}
function loadQueryInternal(lView, queryIndex) {
  ngDevMode && assertDefined(lView[QUERIES], "LQueries should be defined when trying to load a query");
  ngDevMode && assertIndexInRange(lView[QUERIES].queries, queryIndex);
  return lView[QUERIES].queries[queryIndex].queryList;
}
function createLQuery(tView, lView, flags) {
  const queryList = new QueryList(
    (flags & 4) === 4
    /* QueryFlags.emitDistinctChangesOnly */
  );
  storeCleanupWithContext(tView, lView, queryList, queryList.destroy);
  const lQueries = (lView[QUERIES] ??= new LQueries_()).queries;
  return lQueries.push(new LQuery_(queryList)) - 1;
}
function createViewQuery(predicate, flags, read) {
  ngDevMode && assertNumber(flags, "Expecting flags");
  const tView = getTView();
  if (tView.firstCreatePass) {
    createTQuery(tView, new TQueryMetadata_(predicate, flags, read), -1);
    if ((flags & 2) === 2) {
      tView.staticViewQueries = true;
    }
  }
  return createLQuery(tView, getLView(), flags);
}
function createContentQuery(directiveIndex, predicate, flags, read) {
  ngDevMode && assertNumber(flags, "Expecting flags");
  const tView = getTView();
  if (tView.firstCreatePass) {
    const tNode = getCurrentTNode();
    createTQuery(tView, new TQueryMetadata_(predicate, flags, read), tNode.index);
    saveContentQueryAndDirectiveIndex(tView, directiveIndex);
    if ((flags & 2) === 2) {
      tView.staticContentQueries = true;
    }
  }
  return createLQuery(tView, getLView(), flags);
}
function splitQueryMultiSelectors(locator) {
  return locator.split(",").map((s) => s.trim());
}
function createTQuery(tView, metadata, nodeIndex) {
  if (tView.queries === null) tView.queries = new TQueries_();
  tView.queries.track(new TQuery_(metadata, nodeIndex));
}
function saveContentQueryAndDirectiveIndex(tView, directiveIndex) {
  const tViewContentQueries = tView.contentQueries || (tView.contentQueries = []);
  const lastSavedDirectiveIndex = tViewContentQueries.length ? tViewContentQueries[tViewContentQueries.length - 1] : -1;
  if (directiveIndex !== lastSavedDirectiveIndex) {
    tViewContentQueries.push(tView.queries.length - 1, directiveIndex);
  }
}
function getTQuery(tView, index) {
  ngDevMode && assertDefined(tView.queries, "TQueries must be defined to retrieve a TQuery");
  return tView.queries.getByIndex(index);
}
function getQueryResults(lView, queryIndex) {
  const tView = lView[TVIEW];
  const tQuery = getTQuery(tView, queryIndex);
  return tQuery.crossesNgTemplate ? collectQueryResults(tView, lView, queryIndex, []) : materializeViewResults(tView, lView, tQuery, queryIndex);
}
function isSignal(value) {
  return typeof value === "function" && value[SIGNAL] !== void 0;
}
var ɵWRITABLE_SIGNAL = Symbol("WRITABLE_SIGNAL");
function ɵunwrapWritableSignal(value) {
  return null;
}
function signal(initialValue, options) {
  performanceMarkFeature("NgSignals");
  const signalFn = createSignal(initialValue);
  const node = signalFn[SIGNAL];
  if (options?.equal) {
    node.equal = options.equal;
  }
  signalFn.set = (newValue) => signalSetFn(node, newValue);
  signalFn.update = (updateFn) => signalUpdateFn(node, updateFn);
  signalFn.asReadonly = signalAsReadonlyFn.bind(signalFn);
  if (ngDevMode) {
    signalFn.toString = () => `[Signal: ${signalFn()}]`;
  }
  return signalFn;
}
function signalAsReadonlyFn() {
  const node = this[SIGNAL];
  if (node.readonlyFn === void 0) {
    const readonlyFn = () => this();
    readonlyFn[SIGNAL] = node;
    node.readonlyFn = readonlyFn;
  }
  return node.readonlyFn;
}
function isWritableSignal(value) {
  return isSignal(value) && typeof value.set === "function";
}
function createQuerySignalFn(firstOnly, required) {
  let node;
  const signalFn = createComputed(() => {
    node._dirtyCounter();
    const value = refreshSignalQuery(node, firstOnly);
    if (required && value === void 0) {
      throw new RuntimeError(-951, ngDevMode && "Child query result is required but no value is available.");
    }
    return value;
  });
  node = signalFn[SIGNAL];
  node._dirtyCounter = signal(0);
  node._flatValue = void 0;
  if (ngDevMode) {
    signalFn.toString = () => `[Query Signal]`;
  }
  return signalFn;
}
function createSingleResultOptionalQuerySignalFn() {
  return createQuerySignalFn(
    /* firstOnly */
    true,
    /* required */
    false
  );
}
function createSingleResultRequiredQuerySignalFn() {
  return createQuerySignalFn(
    /* firstOnly */
    true,
    /* required */
    true
  );
}
function createMultiResultQuerySignalFn() {
  return createQuerySignalFn(
    /* firstOnly */
    false,
    /* required */
    false
  );
}
function bindQueryToSignal(target, queryIndex) {
  const node = target[SIGNAL];
  node._lView = getLView();
  node._queryIndex = queryIndex;
  node._queryList = loadQueryInternal(node._lView, queryIndex);
  node._queryList.onDirty(() => node._dirtyCounter.update((v) => v + 1));
}
function refreshSignalQuery(node, firstOnly) {
  const lView = node._lView;
  const queryIndex = node._queryIndex;
  if (lView === void 0 || queryIndex === void 0 || lView[FLAGS] & 4) {
    return firstOnly ? void 0 : EMPTY_ARRAY;
  }
  const queryList = loadQueryInternal(lView, queryIndex);
  const results = getQueryResults(lView, queryIndex);
  queryList.reset(results, unwrapElementRef);
  if (firstOnly) {
    return queryList.first;
  } else {
    const resultChanged = queryList._changesDetected;
    if (resultChanged || node._flatValue === void 0) {
      return node._flatValue = queryList.toArray();
    }
    return node._flatValue;
  }
}
function viewChildFn(locator, opts) {
  ngDevMode && assertInInjectionContext(viewChild);
  return createSingleResultOptionalQuerySignalFn();
}
function viewChildRequiredFn(locator, opts) {
  ngDevMode && assertInInjectionContext(viewChild);
  return createSingleResultRequiredQuerySignalFn();
}
var viewChild = (() => {
  viewChildFn.required = viewChildRequiredFn;
  return viewChildFn;
})();
function viewChildren(locator, opts) {
  ngDevMode && assertInInjectionContext(viewChildren);
  return createMultiResultQuerySignalFn();
}
function contentChildFn(locator, opts) {
  ngDevMode && assertInInjectionContext(contentChild);
  return createSingleResultOptionalQuerySignalFn();
}
function contentChildRequiredFn(locator, opts) {
  ngDevMode && assertInInjectionContext(contentChildren);
  return createSingleResultRequiredQuerySignalFn();
}
var contentChild = (() => {
  contentChildFn.required = contentChildRequiredFn;
  return contentChildFn;
})();
function contentChildren(locator, opts) {
  return createMultiResultQuerySignalFn();
}
function createModelSignal(initialValue) {
  const node = Object.create(INPUT_SIGNAL_NODE);
  const emitterRef = new OutputEmitterRef();
  node.value = initialValue;
  function getter() {
    producerAccessed(node);
    assertModelSet(node.value);
    return node.value;
  }
  getter[SIGNAL] = node;
  getter.asReadonly = signalAsReadonlyFn.bind(getter);
  getter.set = (newValue) => {
    if (!node.equal(node.value, newValue)) {
      signalSetFn(node, newValue);
      emitterRef.emit(newValue);
    }
  };
  getter.update = (updateFn) => {
    assertModelSet(node.value);
    getter.set(updateFn(node.value));
  };
  getter.subscribe = emitterRef.subscribe.bind(emitterRef);
  getter.destroyRef = emitterRef.destroyRef;
  if (ngDevMode) {
    getter.toString = () => `[Model Signal: ${getter()}]`;
  }
  return getter;
}
function assertModelSet(value) {
  if (value === REQUIRED_UNSET_VALUE) {
    throw new RuntimeError(952, ngDevMode && "Model is required but no value is available yet.");
  }
}
function modelFunction(initialValue) {
  ngDevMode && assertInInjectionContext(model);
  return createModelSignal(initialValue);
}
function modelRequiredFunction() {
  ngDevMode && assertInInjectionContext(model);
  return createModelSignal(REQUIRED_UNSET_VALUE);
}
var model = (() => {
  modelFunction.required = modelRequiredFunction;
  return modelFunction;
})();
var emitDistinctChangesOnlyDefaultValue = true;
var Query = class {
};
var ContentChildren = makePropDecorator("ContentChildren", (selector, opts = {}) => __spreadValues({
  selector,
  first: false,
  isViewQuery: false,
  descendants: false,
  emitDistinctChangesOnly: emitDistinctChangesOnlyDefaultValue
}, opts), Query);
var ContentChild = makePropDecorator("ContentChild", (selector, opts = {}) => __spreadValues({
  selector,
  first: true,
  isViewQuery: false,
  descendants: true
}, opts), Query);
var ViewChildren = makePropDecorator("ViewChildren", (selector, opts = {}) => __spreadValues({
  selector,
  first: false,
  isViewQuery: true,
  descendants: true,
  emitDistinctChangesOnly: emitDistinctChangesOnlyDefaultValue
}, opts), Query);
var ViewChild = makePropDecorator("ViewChild", (selector, opts) => __spreadValues({
  selector,
  first: true,
  isViewQuery: true,
  descendants: true
}, opts), Query);
function resolveComponentResources(resourceResolver) {
  const componentResolved = [];
  const urlMap = /* @__PURE__ */ new Map();
  function cachedResourceResolve(url) {
    let promise = urlMap.get(url);
    if (!promise) {
      const resp = resourceResolver(url);
      urlMap.set(url, promise = resp.then(unwrapResponse));
    }
    return promise;
  }
  componentResourceResolutionQueue.forEach((component, type) => {
    const promises = [];
    if (component.templateUrl) {
      promises.push(cachedResourceResolve(component.templateUrl).then((template) => {
        component.template = template;
      }));
    }
    const styles = typeof component.styles === "string" ? [component.styles] : component.styles || [];
    component.styles = styles;
    if (component.styleUrl && component.styleUrls?.length) {
      throw new Error("@Component cannot define both `styleUrl` and `styleUrls`. Use `styleUrl` if the component has one stylesheet, or `styleUrls` if it has multiple");
    } else if (component.styleUrls?.length) {
      const styleOffset = component.styles.length;
      const styleUrls = component.styleUrls;
      component.styleUrls.forEach((styleUrl, index) => {
        styles.push("");
        promises.push(cachedResourceResolve(styleUrl).then((style) => {
          styles[styleOffset + index] = style;
          styleUrls.splice(styleUrls.indexOf(styleUrl), 1);
          if (styleUrls.length == 0) {
            component.styleUrls = void 0;
          }
        }));
      });
    } else if (component.styleUrl) {
      promises.push(cachedResourceResolve(component.styleUrl).then((style) => {
        styles.push(style);
        component.styleUrl = void 0;
      }));
    }
    const fullyResolved = Promise.all(promises).then(() => componentDefResolved(type));
    componentResolved.push(fullyResolved);
  });
  clearResolutionOfComponentResourcesQueue();
  return Promise.all(componentResolved).then(() => void 0);
}
var componentResourceResolutionQueue = /* @__PURE__ */ new Map();
var componentDefPendingResolution = /* @__PURE__ */ new Set();
function maybeQueueResolutionOfComponentResources(type, metadata) {
  if (componentNeedsResolution(metadata)) {
    componentResourceResolutionQueue.set(type, metadata);
    componentDefPendingResolution.add(type);
  }
}
function isComponentDefPendingResolution(type) {
  return componentDefPendingResolution.has(type);
}
function componentNeedsResolution(component) {
  return !!(component.templateUrl && !component.hasOwnProperty("template") || component.styleUrls && component.styleUrls.length || component.styleUrl);
}
function clearResolutionOfComponentResourcesQueue() {
  const old = componentResourceResolutionQueue;
  componentResourceResolutionQueue = /* @__PURE__ */ new Map();
  return old;
}
function restoreComponentResolutionQueue(queue) {
  componentDefPendingResolution.clear();
  queue.forEach((_, type) => componentDefPendingResolution.add(type));
  componentResourceResolutionQueue = queue;
}
function isComponentResourceResolutionQueueEmpty() {
  return componentResourceResolutionQueue.size === 0;
}
function unwrapResponse(response) {
  return typeof response == "string" ? response : response.text();
}
function componentDefResolved(type) {
  componentDefPendingResolution.delete(type);
}
var modules = /* @__PURE__ */ new Map();
var checkForDuplicateNgModules = true;
function assertSameOrNotExisting(id, type, incoming) {
  if (type && type !== incoming && checkForDuplicateNgModules) {
    throw new Error(`Duplicate module registered for ${id} - ${stringify(type)} vs ${stringify(type.name)}`);
  }
}
function registerNgModuleType(ngModuleType, id) {
  const existing = modules.get(id) || null;
  assertSameOrNotExisting(id, existing, ngModuleType);
  modules.set(id, ngModuleType);
}
function getRegisteredNgModuleType(id) {
  return modules.get(id);
}
function setAllowDuplicateNgModuleIdsForTest(allowDuplicates) {
  checkForDuplicateNgModules = !allowDuplicates;
}
function ɵɵvalidateIframeAttribute(attrValue, tagName, attrName) {
  const lView = getLView();
  const tNode = getSelectedTNode();
  const element = getNativeByTNode(tNode, lView);
  if (tNode.type === 2 && tagName.toLowerCase() === "iframe") {
    const iframe = element;
    iframe.src = "";
    iframe.srcdoc = trustedHTMLFromString("");
    nativeRemoveNode(lView[RENDERER], iframe);
    const errorMessage = ngDevMode && `Angular has detected that the \`${attrName}\` was applied as a binding to an <iframe>${getTemplateLocationDetails(lView)}. For security reasons, the \`${attrName}\` can be set on an <iframe> as a static attribute only. 
To fix this, switch the \`${attrName}\` binding to a static attribute in a template or in host bindings section.`;
    throw new RuntimeError(-910, errorMessage);
  }
  return attrValue;
}
function getSuperType(type) {
  return Object.getPrototypeOf(type.prototype).constructor;
}
function ɵɵInheritDefinitionFeature(definition) {
  let superType = getSuperType(definition.type);
  let shouldInheritFields = true;
  const inheritanceChain = [definition];
  while (superType) {
    let superDef = void 0;
    if (isComponentDef(definition)) {
      superDef = superType.ɵcmp || superType.ɵdir;
    } else {
      if (superType.ɵcmp) {
        throw new RuntimeError(903, ngDevMode && `Directives cannot inherit Components. Directive ${stringifyForError(definition.type)} is attempting to extend component ${stringifyForError(superType)}`);
      }
      superDef = superType.ɵdir;
    }
    if (superDef) {
      if (shouldInheritFields) {
        inheritanceChain.push(superDef);
        const writeableDef = definition;
        writeableDef.inputs = maybeUnwrapEmpty(definition.inputs);
        writeableDef.inputTransforms = maybeUnwrapEmpty(definition.inputTransforms);
        writeableDef.declaredInputs = maybeUnwrapEmpty(definition.declaredInputs);
        writeableDef.outputs = maybeUnwrapEmpty(definition.outputs);
        const superHostBindings = superDef.hostBindings;
        superHostBindings && inheritHostBindings(definition, superHostBindings);
        const superViewQuery = superDef.viewQuery;
        const superContentQueries = superDef.contentQueries;
        superViewQuery && inheritViewQuery(definition, superViewQuery);
        superContentQueries && inheritContentQueries(definition, superContentQueries);
        mergeInputsWithTransforms(definition, superDef);
        fillProperties(definition.outputs, superDef.outputs);
        if (isComponentDef(superDef) && superDef.data.animation) {
          const defData = definition.data;
          defData.animation = (defData.animation || []).concat(superDef.data.animation);
        }
      }
      const features = superDef.features;
      if (features) {
        for (let i = 0; i < features.length; i++) {
          const feature = features[i];
          if (feature && feature.ngInherit) {
            feature(definition);
          }
          if (feature === ɵɵInheritDefinitionFeature) {
            shouldInheritFields = false;
          }
        }
      }
    }
    superType = Object.getPrototypeOf(superType);
  }
  mergeHostAttrsAcrossInheritance(inheritanceChain);
}
function mergeInputsWithTransforms(target, source) {
  for (const key in source.inputs) {
    if (!source.inputs.hasOwnProperty(key)) {
      continue;
    }
    if (target.inputs.hasOwnProperty(key)) {
      continue;
    }
    const value = source.inputs[key];
    if (value === void 0) {
      continue;
    }
    target.inputs[key] = value;
    target.declaredInputs[key] = source.declaredInputs[key];
    if (source.inputTransforms !== null) {
      const minifiedName = Array.isArray(value) ? value[0] : value;
      if (!source.inputTransforms.hasOwnProperty(minifiedName)) {
        continue;
      }
      target.inputTransforms ??= {};
      target.inputTransforms[minifiedName] = source.inputTransforms[minifiedName];
    }
  }
}
function mergeHostAttrsAcrossInheritance(inheritanceChain) {
  let hostVars = 0;
  let hostAttrs = null;
  for (let i = inheritanceChain.length - 1; i >= 0; i--) {
    const def = inheritanceChain[i];
    def.hostVars = hostVars += def.hostVars;
    def.hostAttrs = mergeHostAttrs(def.hostAttrs, hostAttrs = mergeHostAttrs(hostAttrs, def.hostAttrs));
  }
}
function maybeUnwrapEmpty(value) {
  if (value === EMPTY_OBJ) {
    return {};
  } else if (value === EMPTY_ARRAY) {
    return [];
  } else {
    return value;
  }
}
function inheritViewQuery(definition, superViewQuery) {
  const prevViewQuery = definition.viewQuery;
  if (prevViewQuery) {
    definition.viewQuery = (rf, ctx) => {
      superViewQuery(rf, ctx);
      prevViewQuery(rf, ctx);
    };
  } else {
    definition.viewQuery = superViewQuery;
  }
}
function inheritContentQueries(definition, superContentQueries) {
  const prevContentQueries = definition.contentQueries;
  if (prevContentQueries) {
    definition.contentQueries = (rf, ctx, directiveIndex) => {
      superContentQueries(rf, ctx, directiveIndex);
      prevContentQueries(rf, ctx, directiveIndex);
    };
  } else {
    definition.contentQueries = superContentQueries;
  }
}
function inheritHostBindings(definition, superHostBindings) {
  const prevHostBindings = definition.hostBindings;
  if (prevHostBindings) {
    definition.hostBindings = (rf, ctx) => {
      superHostBindings(rf, ctx);
      prevHostBindings(rf, ctx);
    };
  } else {
    definition.hostBindings = superHostBindings;
  }
}
var COPY_DIRECTIVE_FIELDS = [
  // The child class should use the providers of its parent.
  "providersResolver"
  // Not listed here are any fields which are handled by the `ɵɵInheritDefinitionFeature`, such
  // as inputs, outputs, and host binding functions.
];
var COPY_COMPONENT_FIELDS = [
  // The child class should use the template function of its parent, including all template
  // semantics.
  "template",
  "decls",
  "consts",
  "vars",
  "onPush",
  "ngContentSelectors",
  // The child class should use the CSS styles of its parent, including all styling semantics.
  "styles",
  "encapsulation",
  // The child class should be checked by the runtime in the same way as its parent.
  "schemas"
];
function ɵɵCopyDefinitionFeature(definition) {
  let superType = getSuperType(definition.type);
  let superDef = void 0;
  if (isComponentDef(definition)) {
    superDef = superType.ɵcmp;
  } else {
    superDef = superType.ɵdir;
  }
  const defAny = definition;
  for (const field of COPY_DIRECTIVE_FIELDS) {
    defAny[field] = superDef[field];
  }
  if (isComponentDef(superDef)) {
    for (const field of COPY_COMPONENT_FIELDS) {
      defAny[field] = superDef[field];
    }
  }
}
function ɵɵHostDirectivesFeature(rawHostDirectives) {
  const feature = (definition) => {
    const resolved = (Array.isArray(rawHostDirectives) ? rawHostDirectives : rawHostDirectives()).map((dir) => {
      return typeof dir === "function" ? {
        directive: resolveForwardRef(dir),
        inputs: EMPTY_OBJ,
        outputs: EMPTY_OBJ
      } : {
        directive: resolveForwardRef(dir.directive),
        inputs: bindingArrayToMap(dir.inputs),
        outputs: bindingArrayToMap(dir.outputs)
      };
    });
    if (definition.hostDirectives === null) {
      definition.findHostDirectiveDefs = findHostDirectiveDefs;
      definition.hostDirectives = resolved;
    } else {
      definition.hostDirectives.unshift(...resolved);
    }
  };
  feature.ngInherit = true;
  return feature;
}
function findHostDirectiveDefs(currentDef, matchedDefs, hostDirectiveDefs) {
  if (currentDef.hostDirectives !== null) {
    for (const hostDirectiveConfig of currentDef.hostDirectives) {
      const hostDirectiveDef = getDirectiveDef(hostDirectiveConfig.directive);
      if (typeof ngDevMode === "undefined" || ngDevMode) {
        validateHostDirective(hostDirectiveConfig, hostDirectiveDef);
      }
      patchDeclaredInputs(hostDirectiveDef.declaredInputs, hostDirectiveConfig.inputs);
      findHostDirectiveDefs(hostDirectiveDef, matchedDefs, hostDirectiveDefs);
      hostDirectiveDefs.set(hostDirectiveDef, hostDirectiveConfig);
      matchedDefs.push(hostDirectiveDef);
    }
  }
}
function bindingArrayToMap(bindings) {
  if (bindings === void 0 || bindings.length === 0) {
    return EMPTY_OBJ;
  }
  const result = {};
  for (let i = 0; i < bindings.length; i += 2) {
    result[bindings[i]] = bindings[i + 1];
  }
  return result;
}
function patchDeclaredInputs(declaredInputs, exposedInputs) {
  for (const publicName in exposedInputs) {
    if (exposedInputs.hasOwnProperty(publicName)) {
      const remappedPublicName = exposedInputs[publicName];
      const privateName = declaredInputs[publicName];
      if ((typeof ngDevMode === "undefined" || ngDevMode) && declaredInputs.hasOwnProperty(remappedPublicName)) {
        assertEqual(declaredInputs[remappedPublicName], declaredInputs[publicName], `Conflicting host directive input alias ${publicName}.`);
      }
      declaredInputs[remappedPublicName] = privateName;
    }
  }
}
function validateHostDirective(hostDirectiveConfig, directiveDef) {
  const type = hostDirectiveConfig.directive;
  if (directiveDef === null) {
    if (getComponentDef(type) !== null) {
      throw new RuntimeError(310, `Host directive ${type.name} cannot be a component.`);
    }
    throw new RuntimeError(307, `Could not resolve metadata for host directive ${type.name}. Make sure that the ${type.name} class is annotated with an @Directive decorator.`);
  }
  if (!directiveDef.standalone) {
    throw new RuntimeError(308, `Host directive ${directiveDef.type.name} must be standalone.`);
  }
  validateMappings("input", directiveDef, hostDirectiveConfig.inputs);
  validateMappings("output", directiveDef, hostDirectiveConfig.outputs);
}
function validateMappings(bindingType, def, hostDirectiveBindings) {
  const className = def.type.name;
  const bindings = bindingType === "input" ? def.inputs : def.outputs;
  for (const publicName in hostDirectiveBindings) {
    if (hostDirectiveBindings.hasOwnProperty(publicName)) {
      if (!bindings.hasOwnProperty(publicName)) {
        throw new RuntimeError(311, `Directive ${className} does not have an ${bindingType} with a public name of ${publicName}.`);
      }
      const remappedPublicName = hostDirectiveBindings[publicName];
      if (bindings.hasOwnProperty(remappedPublicName) && remappedPublicName !== publicName) {
        throw new RuntimeError(312, `Cannot alias ${bindingType} ${publicName} of host directive ${className} to ${remappedPublicName}, because it already has a different ${bindingType} with the same public name.`);
      }
    }
  }
}
function ɵɵInputTransformsFeature(definition) {
  const inputs = definition.inputConfig;
  const inputTransforms = {};
  for (const minifiedKey in inputs) {
    if (inputs.hasOwnProperty(minifiedKey)) {
      const value = inputs[minifiedKey];
      if (Array.isArray(value) && value[3]) {
        inputTransforms[minifiedKey] = value[3];
      }
    }
  }
  definition.inputTransforms = inputTransforms;
}
var NgModuleRef$1 = class {
};
var NgModuleFactory$1 = class {
};
function createNgModule(ngModule, parentInjector) {
  return new NgModuleRef(ngModule, parentInjector ?? null, []);
}
var createNgModuleRef = createNgModule;
var NgModuleRef = class extends NgModuleRef$1 {
  constructor(ngModuleType, _parent, additionalProviders, runInjectorInitializers = true) {
    super();
    this.ngModuleType = ngModuleType;
    this._parent = _parent;
    this._bootstrapComponents = [];
    this.destroyCbs = [];
    this.componentFactoryResolver = new ComponentFactoryResolver(this);
    const ngModuleDef = getNgModuleDef(ngModuleType);
    ngDevMode && assertDefined(ngModuleDef, `NgModule '${stringify(ngModuleType)}' is not a subtype of 'NgModuleType'.`);
    this._bootstrapComponents = maybeUnwrapFn(ngModuleDef.bootstrap);
    this._r3Injector = createInjectorWithoutInjectorInstances(ngModuleType, _parent, [{
      provide: NgModuleRef$1,
      useValue: this
    }, {
      provide: ComponentFactoryResolver$1,
      useValue: this.componentFactoryResolver
    }, ...additionalProviders], stringify(ngModuleType), /* @__PURE__ */ new Set(["environment"]));
    if (runInjectorInitializers) {
      this.resolveInjectorInitializers();
    }
  }
  resolveInjectorInitializers() {
    this._r3Injector.resolveInjectorInitializers();
    this.instance = this._r3Injector.get(this.ngModuleType);
  }
  get injector() {
    return this._r3Injector;
  }
  destroy() {
    ngDevMode && assertDefined(this.destroyCbs, "NgModule already destroyed");
    const injector = this._r3Injector;
    !injector.destroyed && injector.destroy();
    this.destroyCbs.forEach((fn) => fn());
    this.destroyCbs = null;
  }
  onDestroy(callback) {
    ngDevMode && assertDefined(this.destroyCbs, "NgModule already destroyed");
    this.destroyCbs.push(callback);
  }
};
var NgModuleFactory = class extends NgModuleFactory$1 {
  constructor(moduleType) {
    super();
    this.moduleType = moduleType;
  }
  create(parentInjector) {
    return new NgModuleRef(this.moduleType, parentInjector, []);
  }
};
function createNgModuleRefWithProviders(moduleType, parentInjector, additionalProviders) {
  return new NgModuleRef(moduleType, parentInjector, additionalProviders, false);
}
var EnvironmentNgModuleRefAdapter = class extends NgModuleRef$1 {
  constructor(config) {
    super();
    this.componentFactoryResolver = new ComponentFactoryResolver(this);
    this.instance = null;
    const injector = new R3Injector([...config.providers, {
      provide: NgModuleRef$1,
      useValue: this
    }, {
      provide: ComponentFactoryResolver$1,
      useValue: this.componentFactoryResolver
    }], config.parent || getNullInjector(), config.debugName, /* @__PURE__ */ new Set(["environment"]));
    this.injector = injector;
    if (config.runEnvironmentInitializers) {
      injector.resolveInjectorInitializers();
    }
  }
  destroy() {
    this.injector.destroy();
  }
  onDestroy(callback) {
    this.injector.onDestroy(callback);
  }
};
function createEnvironmentInjector(providers, parent, debugName = null) {
  const adapter = new EnvironmentNgModuleRefAdapter({
    providers,
    parent,
    debugName,
    runEnvironmentInitializers: true
  });
  return adapter.injector;
}
var CachedInjectorService = class _CachedInjectorService {
  constructor() {
    this.cachedInjectors = /* @__PURE__ */ new Map();
  }
  getOrCreateInjector(key, parentInjector, providers, debugName) {
    if (!this.cachedInjectors.has(key)) {
      const injector = providers.length > 0 ? createEnvironmentInjector(providers, parentInjector, debugName) : null;
      this.cachedInjectors.set(key, injector);
    }
    return this.cachedInjectors.get(key);
  }
  ngOnDestroy() {
    try {
      for (const injector of this.cachedInjectors.values()) {
        if (injector !== null) {
          injector.destroy();
        }
      }
    } finally {
      this.cachedInjectors.clear();
    }
  }
  static {
    this.ɵprov = ɵɵdefineInjectable({
      token: _CachedInjectorService,
      providedIn: "environment",
      factory: () => new _CachedInjectorService()
    });
  }
};
function isListLikeIterable(obj) {
  if (!isJsObject(obj)) return false;
  return Array.isArray(obj) || !(obj instanceof Map) && // JS Map are iterables but return entries as [k, v]
  Symbol.iterator in obj;
}
function areIterablesEqual(a, b, comparator) {
  const iterator1 = a[Symbol.iterator]();
  const iterator2 = b[Symbol.iterator]();
  while (true) {
    const item1 = iterator1.next();
    const item2 = iterator2.next();
    if (item1.done && item2.done) return true;
    if (item1.done || item2.done) return false;
    if (!comparator(item1.value, item2.value)) return false;
  }
}
function iterateListLike(obj, fn) {
  if (Array.isArray(obj)) {
    for (let i = 0; i < obj.length; i++) {
      fn(obj[i]);
    }
  } else {
    const iterator = obj[Symbol.iterator]();
    let item;
    while (!(item = iterator.next()).done) {
      fn(item.value);
    }
  }
}
function isJsObject(o) {
  return o !== null && (typeof o === "function" || typeof o === "object");
}
function devModeEqual(a, b) {
  const isListLikeIterableA = isListLikeIterable(a);
  const isListLikeIterableB = isListLikeIterable(b);
  if (isListLikeIterableA && isListLikeIterableB) {
    return areIterablesEqual(a, b, devModeEqual);
  } else {
    const isAObject = a && (typeof a === "object" || typeof a === "function");
    const isBObject = b && (typeof b === "object" || typeof b === "function");
    if (!isListLikeIterableA && isAObject && !isListLikeIterableB && isBObject) {
      return true;
    } else {
      return Object.is(a, b);
    }
  }
}
function updateBinding(lView, bindingIndex, value) {
  return lView[bindingIndex] = value;
}
function getBinding(lView, bindingIndex) {
  ngDevMode && assertIndexInRange(lView, bindingIndex);
  ngDevMode && assertNotSame(lView[bindingIndex], NO_CHANGE, "Stored value should never be NO_CHANGE.");
  return lView[bindingIndex];
}
function bindingUpdated(lView, bindingIndex, value) {
  ngDevMode && assertNotSame(value, NO_CHANGE, "Incoming value should never be NO_CHANGE.");
  ngDevMode && assertLessThan(bindingIndex, lView.length, `Slot should have been initialized to NO_CHANGE`);
  const oldValue = lView[bindingIndex];
  if (Object.is(oldValue, value)) {
    return false;
  } else {
    if (ngDevMode && isInCheckNoChangesMode()) {
      const oldValueToCompare = oldValue !== NO_CHANGE ? oldValue : void 0;
      if (!devModeEqual(oldValueToCompare, value)) {
        const details = getExpressionChangedErrorDetails(lView, bindingIndex, oldValueToCompare, value);
        throwErrorIfNoChangesMode(oldValue === NO_CHANGE, details.oldValue, details.newValue, details.propName, lView);
      }
      return false;
    }
    lView[bindingIndex] = value;
    return true;
  }
}
function bindingUpdated2(lView, bindingIndex, exp1, exp2) {
  const different = bindingUpdated(lView, bindingIndex, exp1);
  return bindingUpdated(lView, bindingIndex + 1, exp2) || different;
}
function bindingUpdated3(lView, bindingIndex, exp1, exp2, exp3) {
  const different = bindingUpdated2(lView, bindingIndex, exp1, exp2);
  return bindingUpdated(lView, bindingIndex + 2, exp3) || different;
}
function bindingUpdated4(lView, bindingIndex, exp1, exp2, exp3, exp4) {
  const different = bindingUpdated2(lView, bindingIndex, exp1, exp2);
  return bindingUpdated2(lView, bindingIndex + 2, exp3, exp4) || different;
}
function isDetachedByI18n(tNode) {
  return (tNode.flags & 32) === 32;
}
function templateFirstCreatePass(index, tView, lView, templateFn, decls, vars, tagName, attrs, localRefsIndex) {
  ngDevMode && assertFirstCreatePass(tView);
  ngDevMode && ngDevMode.firstCreatePass++;
  const tViewConsts = tView.consts;
  const tNode = getOrCreateTNode(tView, index, 4, tagName || null, attrs || null);
  resolveDirectives(tView, lView, tNode, getConstant(tViewConsts, localRefsIndex));
  registerPostOrderHooks(tView, tNode);
  const embeddedTView = tNode.tView = createTView(
    2,
    tNode,
    templateFn,
    decls,
    vars,
    tView.directiveRegistry,
    tView.pipeRegistry,
    null,
    tView.schemas,
    tViewConsts,
    null
    /* ssrId */
  );
  if (tView.queries !== null) {
    tView.queries.template(tView, tNode);
    embeddedTView.queries = tView.queries.embeddedTView(tNode);
  }
  return tNode;
}
function declareTemplate(declarationLView, declarationTView, index, templateFn, decls, vars, tagName, attrs, localRefsIndex, localRefExtractor) {
  const adjustedIndex = index + HEADER_OFFSET;
  const tNode = declarationTView.firstCreatePass ? templateFirstCreatePass(adjustedIndex, declarationTView, declarationLView, templateFn, decls, vars, tagName, attrs, localRefsIndex) : declarationTView.data[adjustedIndex];
  setCurrentTNode(tNode, false);
  const comment = _locateOrCreateContainerAnchor(declarationTView, declarationLView, tNode, index);
  if (wasLastNodeCreated()) {
    appendChild(declarationTView, declarationLView, comment, tNode);
  }
  attachPatchData(comment, declarationLView);
  const lContainer = createLContainer(comment, declarationLView, comment, tNode);
  declarationLView[adjustedIndex] = lContainer;
  addToViewTree(declarationLView, lContainer);
  populateDehydratedViewsInLContainer(lContainer, tNode, declarationLView);
  if (isDirectiveHost(tNode)) {
    createDirectivesInstances(declarationTView, declarationLView, tNode);
  }
  if (localRefsIndex != null) {
    saveResolvedLocalsInData(declarationLView, tNode, localRefExtractor);
  }
  return tNode;
}
function ɵɵtemplate(index, templateFn, decls, vars, tagName, attrsIndex, localRefsIndex, localRefExtractor) {
  const lView = getLView();
  const tView = getTView();
  const attrs = getConstant(tView.consts, attrsIndex);
  declareTemplate(lView, tView, index, templateFn, decls, vars, tagName, attrs, localRefsIndex, localRefExtractor);
  return ɵɵtemplate;
}
var _locateOrCreateContainerAnchor = createContainerAnchorImpl;
function createContainerAnchorImpl(tView, lView, tNode, index) {
  lastNodeWasCreated(true);
  return lView[RENDERER].createComment(ngDevMode ? "container" : "");
}
function locateOrCreateContainerAnchorImpl(tView, lView, tNode, index) {
  const hydrationInfo = lView[HYDRATION];
  const isNodeCreationMode = !hydrationInfo || isInSkipHydrationBlock$1() || isDetachedByI18n(tNode) || isDisconnectedNode$1(hydrationInfo, index);
  lastNodeWasCreated(isNodeCreationMode);
  if (isNodeCreationMode) {
    return createContainerAnchorImpl(tView, lView, tNode, index);
  }
  const ssrId = hydrationInfo.data[TEMPLATES]?.[index] ?? null;
  if (ssrId !== null && tNode.tView !== null) {
    if (tNode.tView.ssrId === null) {
      tNode.tView.ssrId = ssrId;
    } else {
      ngDevMode && assertEqual(tNode.tView.ssrId, ssrId, "Unexpected value of the `ssrId` for this TView");
    }
  }
  const currentRNode = locateNextRNode(hydrationInfo, tView, lView, tNode);
  ngDevMode && validateNodeExists(currentRNode, lView, tNode);
  setSegmentHead(hydrationInfo, index, currentRNode);
  const viewContainerSize = calcSerializedContainerSize(hydrationInfo, index);
  const comment = siblingAfter(viewContainerSize, currentRNode);
  if (ngDevMode) {
    validateMatchingNode(comment, Node.COMMENT_NODE, null, lView, tNode);
    markRNodeAsClaimedByHydration(comment);
  }
  return comment;
}
function enableLocateOrCreateContainerAnchorImpl() {
  _locateOrCreateContainerAnchor = locateOrCreateContainerAnchorImpl;
}
var DeferDependenciesLoadingState;
(function(DeferDependenciesLoadingState2) {
  DeferDependenciesLoadingState2[DeferDependenciesLoadingState2["NOT_STARTED"] = 0] = "NOT_STARTED";
  DeferDependenciesLoadingState2[DeferDependenciesLoadingState2["IN_PROGRESS"] = 1] = "IN_PROGRESS";
  DeferDependenciesLoadingState2[DeferDependenciesLoadingState2["COMPLETE"] = 2] = "COMPLETE";
  DeferDependenciesLoadingState2[DeferDependenciesLoadingState2["FAILED"] = 3] = "FAILED";
})(DeferDependenciesLoadingState || (DeferDependenciesLoadingState = {}));
var MINIMUM_SLOT = 0;
var LOADING_AFTER_SLOT = 1;
var DeferBlockState;
(function(DeferBlockState2) {
  DeferBlockState2[DeferBlockState2["Placeholder"] = 0] = "Placeholder";
  DeferBlockState2[DeferBlockState2["Loading"] = 1] = "Loading";
  DeferBlockState2[DeferBlockState2["Complete"] = 2] = "Complete";
  DeferBlockState2[DeferBlockState2["Error"] = 3] = "Error";
})(DeferBlockState || (DeferBlockState = {}));
var DeferBlockInternalState;
(function(DeferBlockInternalState2) {
  DeferBlockInternalState2[DeferBlockInternalState2["Initial"] = -1] = "Initial";
})(DeferBlockInternalState || (DeferBlockInternalState = {}));
var NEXT_DEFER_BLOCK_STATE = 0;
var DEFER_BLOCK_STATE = 1;
var STATE_IS_FROZEN_UNTIL = 2;
var LOADING_AFTER_CLEANUP_FN = 3;
var TRIGGER_CLEANUP_FNS = 4;
var PREFETCH_TRIGGER_CLEANUP_FNS = 5;
var DeferBlockBehavior;
(function(DeferBlockBehavior2) {
  DeferBlockBehavior2[DeferBlockBehavior2["Manual"] = 0] = "Manual";
  DeferBlockBehavior2[DeferBlockBehavior2["Playthrough"] = 1] = "Playthrough";
})(DeferBlockBehavior || (DeferBlockBehavior = {}));
function storeTriggerCleanupFn(type, lDetails, cleanupFn) {
  const key = type === 1 ? PREFETCH_TRIGGER_CLEANUP_FNS : TRIGGER_CLEANUP_FNS;
  if (lDetails[key] === null) {
    lDetails[key] = [];
  }
  lDetails[key].push(cleanupFn);
}
function invokeTriggerCleanupFns(type, lDetails) {
  const key = type === 1 ? PREFETCH_TRIGGER_CLEANUP_FNS : TRIGGER_CLEANUP_FNS;
  const cleanupFns = lDetails[key];
  if (cleanupFns !== null) {
    for (const cleanupFn of cleanupFns) {
      cleanupFn();
    }
    lDetails[key] = null;
  }
}
function invokeAllTriggerCleanupFns(lDetails) {
  invokeTriggerCleanupFns(1, lDetails);
  invokeTriggerCleanupFns(0, lDetails);
}
function getDeferBlockDataIndex(deferBlockIndex) {
  return deferBlockIndex + 1;
}
function getLDeferBlockDetails(lView, tNode) {
  const tView = lView[TVIEW];
  const slotIndex = getDeferBlockDataIndex(tNode.index);
  ngDevMode && assertIndexInDeclRange(tView, slotIndex);
  return lView[slotIndex];
}
function setLDeferBlockDetails(lView, deferBlockIndex, lDetails) {
  const tView = lView[TVIEW];
  const slotIndex = getDeferBlockDataIndex(deferBlockIndex);
  ngDevMode && assertIndexInDeclRange(tView, slotIndex);
  lView[slotIndex] = lDetails;
}
function getTDeferBlockDetails(tView, tNode) {
  const slotIndex = getDeferBlockDataIndex(tNode.index);
  ngDevMode && assertIndexInDeclRange(tView, slotIndex);
  return tView.data[slotIndex];
}
function setTDeferBlockDetails(tView, deferBlockIndex, deferBlockConfig) {
  const slotIndex = getDeferBlockDataIndex(deferBlockIndex);
  ngDevMode && assertIndexInDeclRange(tView, slotIndex);
  tView.data[slotIndex] = deferBlockConfig;
}
function getTemplateIndexForState(newState, hostLView, tNode) {
  const tView = hostLView[TVIEW];
  const tDetails = getTDeferBlockDetails(tView, tNode);
  switch (newState) {
    case DeferBlockState.Complete:
      return tDetails.primaryTmplIndex;
    case DeferBlockState.Loading:
      return tDetails.loadingTmplIndex;
    case DeferBlockState.Error:
      return tDetails.errorTmplIndex;
    case DeferBlockState.Placeholder:
      return tDetails.placeholderTmplIndex;
    default:
      ngDevMode && throwError(`Unexpected defer block state: ${newState}`);
      return null;
  }
}
function getMinimumDurationForState(tDetails, currentState) {
  if (currentState === DeferBlockState.Placeholder) {
    return tDetails.placeholderBlockConfig?.[MINIMUM_SLOT] ?? null;
  } else if (currentState === DeferBlockState.Loading) {
    return tDetails.loadingBlockConfig?.[MINIMUM_SLOT] ?? null;
  }
  return null;
}
function getLoadingBlockAfter(tDetails) {
  return tDetails.loadingBlockConfig?.[LOADING_AFTER_SLOT] ?? null;
}
function addDepsToRegistry(currentDeps, newDeps) {
  if (!currentDeps || currentDeps.length === 0) {
    return newDeps;
  }
  const currentDepSet = new Set(currentDeps);
  for (const dep of newDeps) {
    currentDepSet.add(dep);
  }
  return currentDeps.length === currentDepSet.size ? currentDeps : Array.from(currentDepSet);
}
function getPrimaryBlockTNode(tView, tDetails) {
  const adjustedIndex = tDetails.primaryTmplIndex + HEADER_OFFSET;
  return getTNode(tView, adjustedIndex);
}
function assertDeferredDependenciesLoaded(tDetails) {
  assertEqual(tDetails.loadingState, DeferDependenciesLoadingState.COMPLETE, "Expecting all deferred dependencies to be loaded.");
}
function isTDeferBlockDetails(value) {
  return value !== null && typeof value === "object" && typeof value.primaryTmplIndex === "number";
}
var eventListenerOptions = {
  passive: true,
  capture: true
};
var hoverTriggers = /* @__PURE__ */ new WeakMap();
var interactionTriggers = /* @__PURE__ */ new WeakMap();
var viewportTriggers = /* @__PURE__ */ new WeakMap();
var interactionEventNames = ["click", "keydown"];
var hoverEventNames = ["mouseenter", "focusin"];
var intersectionObserver = null;
var observedViewportElements = 0;
var DeferEventEntry = class {
  constructor() {
    this.callbacks = /* @__PURE__ */ new Set();
    this.listener = () => {
      for (const callback of this.callbacks) {
        callback();
      }
    };
  }
};
function onInteraction(trigger, callback) {
  let entry = interactionTriggers.get(trigger);
  if (!entry) {
    entry = new DeferEventEntry();
    interactionTriggers.set(trigger, entry);
    for (const name of interactionEventNames) {
      trigger.addEventListener(name, entry.listener, eventListenerOptions);
    }
  }
  entry.callbacks.add(callback);
  return () => {
    const {
      callbacks,
      listener
    } = entry;
    callbacks.delete(callback);
    if (callbacks.size === 0) {
      interactionTriggers.delete(trigger);
      for (const name of interactionEventNames) {
        trigger.removeEventListener(name, listener, eventListenerOptions);
      }
    }
  };
}
function onHover(trigger, callback) {
  let entry = hoverTriggers.get(trigger);
  if (!entry) {
    entry = new DeferEventEntry();
    hoverTriggers.set(trigger, entry);
    for (const name of hoverEventNames) {
      trigger.addEventListener(name, entry.listener, eventListenerOptions);
    }
  }
  entry.callbacks.add(callback);
  return () => {
    const {
      callbacks,
      listener
    } = entry;
    callbacks.delete(callback);
    if (callbacks.size === 0) {
      for (const name of hoverEventNames) {
        trigger.removeEventListener(name, listener, eventListenerOptions);
      }
      hoverTriggers.delete(trigger);
    }
  };
}
function onViewport(trigger, callback, injector) {
  const ngZone = injector.get(NgZone);
  let entry = viewportTriggers.get(trigger);
  intersectionObserver = intersectionObserver || ngZone.runOutsideAngular(() => {
    return new IntersectionObserver((entries) => {
      for (const current of entries) {
        if (current.isIntersecting && viewportTriggers.has(current.target)) {
          ngZone.run(viewportTriggers.get(current.target).listener);
        }
      }
    });
  });
  if (!entry) {
    entry = new DeferEventEntry();
    ngZone.runOutsideAngular(() => intersectionObserver.observe(trigger));
    viewportTriggers.set(trigger, entry);
    observedViewportElements++;
  }
  entry.callbacks.add(callback);
  return () => {
    if (!viewportTriggers.has(trigger)) {
      return;
    }
    entry.callbacks.delete(callback);
    if (entry.callbacks.size === 0) {
      intersectionObserver?.unobserve(trigger);
      viewportTriggers.delete(trigger);
      observedViewportElements--;
    }
    if (observedViewportElements === 0) {
      intersectionObserver?.disconnect();
      intersectionObserver = null;
    }
  };
}
function getTriggerLView(deferredHostLView, deferredTNode, walkUpTimes) {
  if (walkUpTimes == null) {
    return deferredHostLView;
  }
  if (walkUpTimes >= 0) {
    return walkUpViews(walkUpTimes, deferredHostLView);
  }
  const deferredContainer = deferredHostLView[deferredTNode.index];
  ngDevMode && assertLContainer(deferredContainer);
  const triggerLView = deferredContainer[CONTAINER_HEADER_OFFSET] ?? null;
  if (ngDevMode && triggerLView !== null) {
    const lDetails = getLDeferBlockDetails(deferredHostLView, deferredTNode);
    const renderedState = lDetails[DEFER_BLOCK_STATE];
    assertEqual(renderedState, DeferBlockState.Placeholder, "Expected a placeholder to be rendered in this defer block.");
    assertLView(triggerLView);
  }
  return triggerLView;
}
function getTriggerElement(triggerLView, triggerIndex) {
  const element = getNativeByIndex(HEADER_OFFSET + triggerIndex, triggerLView);
  ngDevMode && assertElement(element);
  return element;
}
function registerDomTrigger(initialLView, tNode, triggerIndex, walkUpTimes, registerFn, callback, type) {
  const injector = initialLView[INJECTOR];
  function pollDomTrigger() {
    if (isDestroyed(initialLView)) {
      return;
    }
    const lDetails = getLDeferBlockDetails(initialLView, tNode);
    const renderedState = lDetails[DEFER_BLOCK_STATE];
    if (renderedState !== DeferBlockInternalState.Initial && renderedState !== DeferBlockState.Placeholder) {
      return;
    }
    const triggerLView = getTriggerLView(initialLView, tNode, walkUpTimes);
    if (!triggerLView) {
      internalAfterNextRender(pollDomTrigger, {
        injector
      });
      return;
    }
    if (isDestroyed(triggerLView)) {
      return;
    }
    const element = getTriggerElement(triggerLView, triggerIndex);
    const cleanup = registerFn(element, () => {
      if (initialLView !== triggerLView) {
        removeLViewOnDestroy(triggerLView, cleanup);
      }
      callback();
    }, injector);
    if (initialLView !== triggerLView) {
      storeLViewOnDestroy(triggerLView, cleanup);
    }
    storeTriggerCleanupFn(type, lDetails, cleanup);
  }
  internalAfterNextRender(pollDomTrigger, {
    injector
  });
}
function onIdle(callback, lView) {
  const injector = lView[INJECTOR];
  const scheduler = injector.get(IdleScheduler);
  const cleanupFn = () => scheduler.remove(callback);
  scheduler.add(callback);
  return cleanupFn;
}
var _requestIdleCallback = () => typeof requestIdleCallback !== "undefined" ? requestIdleCallback : setTimeout;
var _cancelIdleCallback = () => typeof requestIdleCallback !== "undefined" ? cancelIdleCallback : clearTimeout;
var IdleScheduler = class _IdleScheduler {
  constructor() {
    this.executingCallbacks = false;
    this.idleId = null;
    this.current = /* @__PURE__ */ new Set();
    this.deferred = /* @__PURE__ */ new Set();
    this.ngZone = inject(NgZone);
    this.requestIdleCallbackFn = _requestIdleCallback().bind(globalThis);
    this.cancelIdleCallbackFn = _cancelIdleCallback().bind(globalThis);
  }
  add(callback) {
    const target = this.executingCallbacks ? this.deferred : this.current;
    target.add(callback);
    if (this.idleId === null) {
      this.scheduleIdleCallback();
    }
  }
  remove(callback) {
    const {
      current,
      deferred
    } = this;
    current.delete(callback);
    deferred.delete(callback);
    if (current.size === 0 && deferred.size === 0) {
      this.cancelIdleCallback();
    }
  }
  scheduleIdleCallback() {
    const callback = () => {
      this.cancelIdleCallback();
      this.executingCallbacks = true;
      for (const callback2 of this.current) {
        callback2();
      }
      this.current.clear();
      this.executingCallbacks = false;
      if (this.deferred.size > 0) {
        for (const callback2 of this.deferred) {
          this.current.add(callback2);
        }
        this.deferred.clear();
        this.scheduleIdleCallback();
      }
    };
    this.idleId = this.requestIdleCallbackFn(() => this.ngZone.run(callback));
  }
  cancelIdleCallback() {
    if (this.idleId !== null) {
      this.cancelIdleCallbackFn(this.idleId);
      this.idleId = null;
    }
  }
  ngOnDestroy() {
    this.cancelIdleCallback();
    this.current.clear();
    this.deferred.clear();
  }
  static {
    this.ɵprov = ɵɵdefineInjectable({
      token: _IdleScheduler,
      providedIn: "root",
      factory: () => new _IdleScheduler()
    });
  }
};
function onTimer(delay) {
  return (callback, lView) => scheduleTimerTrigger(delay, callback, lView);
}
function scheduleTimerTrigger(delay, callback, lView) {
  const injector = lView[INJECTOR];
  const scheduler = injector.get(TimerScheduler);
  const cleanupFn = () => scheduler.remove(callback);
  scheduler.add(delay, callback);
  return cleanupFn;
}
var TimerScheduler = class _TimerScheduler {
  constructor() {
    this.executingCallbacks = false;
    this.timeoutId = null;
    this.invokeTimerAt = null;
    this.current = [];
    this.deferred = [];
  }
  add(delay, callback) {
    const target = this.executingCallbacks ? this.deferred : this.current;
    this.addToQueue(target, Date.now() + delay, callback);
    this.scheduleTimer();
  }
  remove(callback) {
    const {
      current,
      deferred
    } = this;
    const callbackIndex = this.removeFromQueue(current, callback);
    if (callbackIndex === -1) {
      this.removeFromQueue(deferred, callback);
    }
    if (current.length === 0 && deferred.length === 0) {
      this.clearTimeout();
    }
  }
  addToQueue(target, invokeAt, callback) {
    let insertAtIndex = target.length;
    for (let i = 0; i < target.length; i += 2) {
      const invokeQueuedCallbackAt = target[i];
      if (invokeQueuedCallbackAt > invokeAt) {
        insertAtIndex = i;
        break;
      }
    }
    arrayInsert2(target, insertAtIndex, invokeAt, callback);
  }
  removeFromQueue(target, callback) {
    let index = -1;
    for (let i = 0; i < target.length; i += 2) {
      const queuedCallback = target[i + 1];
      if (queuedCallback === callback) {
        index = i;
        break;
      }
    }
    if (index > -1) {
      arraySplice(target, index, 2);
    }
    return index;
  }
  scheduleTimer() {
    const callback = () => {
      this.clearTimeout();
      this.executingCallbacks = true;
      const current = [...this.current];
      const now = Date.now();
      for (let i = 0; i < current.length; i += 2) {
        const invokeAt = current[i];
        const callback2 = current[i + 1];
        if (invokeAt <= now) {
          callback2();
        } else {
          break;
        }
      }
      let lastCallbackIndex = -1;
      for (let i = 0; i < this.current.length; i += 2) {
        const invokeAt = this.current[i];
        if (invokeAt <= now) {
          lastCallbackIndex = i + 1;
        } else {
          break;
        }
      }
      if (lastCallbackIndex >= 0) {
        arraySplice(this.current, 0, lastCallbackIndex + 1);
      }
      this.executingCallbacks = false;
      if (this.deferred.length > 0) {
        for (let i = 0; i < this.deferred.length; i += 2) {
          const invokeAt = this.deferred[i];
          const callback2 = this.deferred[i + 1];
          this.addToQueue(this.current, invokeAt, callback2);
        }
        this.deferred.length = 0;
      }
      this.scheduleTimer();
    };
    const FRAME_DURATION_MS = 16;
    if (this.current.length > 0) {
      const now = Date.now();
      const invokeAt = this.current[0];
      if (this.timeoutId === null || // Reschedule a timer in case a queue contains an item with
      // an earlier timestamp and the delta is more than an average
      // frame duration.
      this.invokeTimerAt && this.invokeTimerAt - invokeAt > FRAME_DURATION_MS) {
        this.clearTimeout();
        const timeout = Math.max(invokeAt - now, FRAME_DURATION_MS);
        this.invokeTimerAt = invokeAt;
        this.timeoutId = setTimeout(callback, timeout);
      }
    }
  }
  clearTimeout() {
    if (this.timeoutId !== null) {
      clearTimeout(this.timeoutId);
      this.timeoutId = null;
    }
  }
  ngOnDestroy() {
    this.clearTimeout();
    this.current.length = 0;
    this.deferred.length = 0;
  }
  static {
    this.ɵprov = ɵɵdefineInjectable({
      token: _TimerScheduler,
      providedIn: "root",
      factory: () => new _TimerScheduler()
    });
  }
};
var DEFER_BLOCK_DEPENDENCY_INTERCEPTOR = new InjectionToken("DEFER_BLOCK_DEPENDENCY_INTERCEPTOR");
var DEFER_BLOCK_CONFIG = new InjectionToken(ngDevMode ? "DEFER_BLOCK_CONFIG" : "");
function shouldTriggerDeferBlock(injector) {
  const config = injector.get(DEFER_BLOCK_CONFIG, null, {
    optional: true
  });
  if (config?.behavior === DeferBlockBehavior.Manual) {
    return false;
  }
  return isPlatformBrowser(injector);
}
var applyDeferBlockStateWithSchedulingImpl = null;
function ɵɵdeferEnableTimerScheduling(tView, tDetails, placeholderConfigIndex, loadingConfigIndex) {
  const tViewConsts = tView.consts;
  if (placeholderConfigIndex != null) {
    tDetails.placeholderBlockConfig = getConstant(tViewConsts, placeholderConfigIndex);
  }
  if (loadingConfigIndex != null) {
    tDetails.loadingBlockConfig = getConstant(tViewConsts, loadingConfigIndex);
  }
  if (applyDeferBlockStateWithSchedulingImpl === null) {
    applyDeferBlockStateWithSchedulingImpl = applyDeferBlockStateWithScheduling;
  }
}
function ɵɵdefer(index, primaryTmplIndex, dependencyResolverFn, loadingTmplIndex, placeholderTmplIndex, errorTmplIndex, loadingConfigIndex, placeholderConfigIndex, enableTimerScheduling) {
  const lView = getLView();
  const tView = getTView();
  const adjustedIndex = index + HEADER_OFFSET;
  const tNode = declareTemplate(lView, tView, index, null, 0, 0);
  if (tView.firstCreatePass) {
    performanceMarkFeature("NgDefer");
    const tDetails = {
      primaryTmplIndex,
      loadingTmplIndex: loadingTmplIndex ?? null,
      placeholderTmplIndex: placeholderTmplIndex ?? null,
      errorTmplIndex: errorTmplIndex ?? null,
      placeholderBlockConfig: null,
      loadingBlockConfig: null,
      dependencyResolverFn: dependencyResolverFn ?? null,
      loadingState: DeferDependenciesLoadingState.NOT_STARTED,
      loadingPromise: null,
      providers: null
    };
    enableTimerScheduling?.(tView, tDetails, placeholderConfigIndex, loadingConfigIndex);
    setTDeferBlockDetails(tView, adjustedIndex, tDetails);
  }
  const lContainer = lView[adjustedIndex];
  populateDehydratedViewsInLContainer(lContainer, tNode, lView);
  const lDetails = [
    null,
    // NEXT_DEFER_BLOCK_STATE
    DeferBlockInternalState.Initial,
    // DEFER_BLOCK_STATE
    null,
    // STATE_IS_FROZEN_UNTIL
    null,
    // LOADING_AFTER_CLEANUP_FN
    null,
    // TRIGGER_CLEANUP_FNS
    null
    // PREFETCH_TRIGGER_CLEANUP_FNS
  ];
  setLDeferBlockDetails(lView, adjustedIndex, lDetails);
  const cleanupTriggersFn = () => invokeAllTriggerCleanupFns(lDetails);
  storeTriggerCleanupFn(0, lDetails, () => removeLViewOnDestroy(lView, cleanupTriggersFn));
  storeLViewOnDestroy(lView, cleanupTriggersFn);
}
function ɵɵdeferWhen(rawValue) {
  const lView = getLView();
  const bindingIndex = nextBindingIndex();
  if (bindingUpdated(lView, bindingIndex, rawValue)) {
    const prevConsumer = setActiveConsumer(null);
    try {
      const value = Boolean(rawValue);
      const tNode = getSelectedTNode();
      const lDetails = getLDeferBlockDetails(lView, tNode);
      const renderedState = lDetails[DEFER_BLOCK_STATE];
      if (value === false && renderedState === DeferBlockInternalState.Initial) {
        renderPlaceholder(lView, tNode);
      } else if (value === true && (renderedState === DeferBlockInternalState.Initial || renderedState === DeferBlockState.Placeholder)) {
        triggerDeferBlock(lView, tNode);
      }
    } finally {
      setActiveConsumer(prevConsumer);
    }
  }
}
function ɵɵdeferPrefetchWhen(rawValue) {
  const lView = getLView();
  const bindingIndex = nextBindingIndex();
  if (bindingUpdated(lView, bindingIndex, rawValue)) {
    const prevConsumer = setActiveConsumer(null);
    try {
      const value = Boolean(rawValue);
      const tView = lView[TVIEW];
      const tNode = getSelectedTNode();
      const tDetails = getTDeferBlockDetails(tView, tNode);
      if (value === true && tDetails.loadingState === DeferDependenciesLoadingState.NOT_STARTED) {
        triggerPrefetching(tDetails, lView, tNode);
      }
    } finally {
      setActiveConsumer(prevConsumer);
    }
  }
}
function ɵɵdeferOnIdle() {
  scheduleDelayedTrigger(onIdle);
}
function ɵɵdeferPrefetchOnIdle() {
  scheduleDelayedPrefetching(onIdle);
}
function ɵɵdeferOnImmediate() {
  const lView = getLView();
  const tNode = getCurrentTNode();
  const tView = lView[TVIEW];
  const injector = lView[INJECTOR];
  const tDetails = getTDeferBlockDetails(tView, tNode);
  if (!shouldTriggerDeferBlock(injector) || tDetails.loadingTmplIndex === null) {
    renderPlaceholder(lView, tNode);
  }
  triggerDeferBlock(lView, tNode);
}
function ɵɵdeferPrefetchOnImmediate() {
  const lView = getLView();
  const tNode = getCurrentTNode();
  const tView = lView[TVIEW];
  const tDetails = getTDeferBlockDetails(tView, tNode);
  if (tDetails.loadingState === DeferDependenciesLoadingState.NOT_STARTED) {
    triggerResourceLoading(tDetails, lView, tNode);
  }
}
function ɵɵdeferOnTimer(delay) {
  scheduleDelayedTrigger(onTimer(delay));
}
function ɵɵdeferPrefetchOnTimer(delay) {
  scheduleDelayedPrefetching(onTimer(delay));
}
function ɵɵdeferOnHover(triggerIndex, walkUpTimes) {
  const lView = getLView();
  const tNode = getCurrentTNode();
  renderPlaceholder(lView, tNode);
  registerDomTrigger(
    lView,
    tNode,
    triggerIndex,
    walkUpTimes,
    onHover,
    () => triggerDeferBlock(lView, tNode),
    0
    /* TriggerType.Regular */
  );
}
function ɵɵdeferPrefetchOnHover(triggerIndex, walkUpTimes) {
  const lView = getLView();
  const tNode = getCurrentTNode();
  const tView = lView[TVIEW];
  const tDetails = getTDeferBlockDetails(tView, tNode);
  if (tDetails.loadingState === DeferDependenciesLoadingState.NOT_STARTED) {
    registerDomTrigger(
      lView,
      tNode,
      triggerIndex,
      walkUpTimes,
      onHover,
      () => triggerPrefetching(tDetails, lView, tNode),
      1
      /* TriggerType.Prefetch */
    );
  }
}
function ɵɵdeferOnInteraction(triggerIndex, walkUpTimes) {
  const lView = getLView();
  const tNode = getCurrentTNode();
  renderPlaceholder(lView, tNode);
  registerDomTrigger(
    lView,
    tNode,
    triggerIndex,
    walkUpTimes,
    onInteraction,
    () => triggerDeferBlock(lView, tNode),
    0
    /* TriggerType.Regular */
  );
}
function ɵɵdeferPrefetchOnInteraction(triggerIndex, walkUpTimes) {
  const lView = getLView();
  const tNode = getCurrentTNode();
  const tView = lView[TVIEW];
  const tDetails = getTDeferBlockDetails(tView, tNode);
  if (tDetails.loadingState === DeferDependenciesLoadingState.NOT_STARTED) {
    registerDomTrigger(
      lView,
      tNode,
      triggerIndex,
      walkUpTimes,
      onInteraction,
      () => triggerPrefetching(tDetails, lView, tNode),
      1
      /* TriggerType.Prefetch */
    );
  }
}
function ɵɵdeferOnViewport(triggerIndex, walkUpTimes) {
  const lView = getLView();
  const tNode = getCurrentTNode();
  renderPlaceholder(lView, tNode);
  registerDomTrigger(
    lView,
    tNode,
    triggerIndex,
    walkUpTimes,
    onViewport,
    () => triggerDeferBlock(lView, tNode),
    0
    /* TriggerType.Regular */
  );
}
function ɵɵdeferPrefetchOnViewport(triggerIndex, walkUpTimes) {
  const lView = getLView();
  const tNode = getCurrentTNode();
  const tView = lView[TVIEW];
  const tDetails = getTDeferBlockDetails(tView, tNode);
  if (tDetails.loadingState === DeferDependenciesLoadingState.NOT_STARTED) {
    registerDomTrigger(
      lView,
      tNode,
      triggerIndex,
      walkUpTimes,
      onViewport,
      () => triggerPrefetching(tDetails, lView, tNode),
      1
      /* TriggerType.Prefetch */
    );
  }
}
function scheduleDelayedTrigger(scheduleFn) {
  const lView = getLView();
  const tNode = getCurrentTNode();
  renderPlaceholder(lView, tNode);
  if (isPlatformBrowser(lView[INJECTOR])) {
    const cleanupFn = scheduleFn(() => triggerDeferBlock(lView, tNode), lView);
    const lDetails = getLDeferBlockDetails(lView, tNode);
    storeTriggerCleanupFn(0, lDetails, cleanupFn);
  }
}
function scheduleDelayedPrefetching(scheduleFn) {
  const lView = getLView();
  if (isPlatformBrowser(lView[INJECTOR])) {
    const tNode = getCurrentTNode();
    const tView = lView[TVIEW];
    const tDetails = getTDeferBlockDetails(tView, tNode);
    if (tDetails.loadingState === DeferDependenciesLoadingState.NOT_STARTED) {
      const lDetails = getLDeferBlockDetails(lView, tNode);
      const prefetch = () => triggerPrefetching(tDetails, lView, tNode);
      const cleanupFn = scheduleFn(prefetch, lView);
      storeTriggerCleanupFn(1, lDetails, cleanupFn);
    }
  }
}
function renderDeferBlockState(newState, tNode, lContainer, skipTimerScheduling = false) {
  const hostLView = lContainer[PARENT];
  const hostTView = hostLView[TVIEW];
  if (isDestroyed(hostLView)) return;
  ngDevMode && assertTNodeForLView(tNode, hostLView);
  const lDetails = getLDeferBlockDetails(hostLView, tNode);
  ngDevMode && assertDefined(lDetails, "Expected a defer block state defined");
  const currentState = lDetails[DEFER_BLOCK_STATE];
  if (isValidStateChange(currentState, newState) && isValidStateChange(lDetails[NEXT_DEFER_BLOCK_STATE] ?? -1, newState)) {
    const injector = hostLView[INJECTOR];
    const tDetails = getTDeferBlockDetails(hostTView, tNode);
    const needsScheduling = !skipTimerScheduling && isPlatformBrowser(injector) && (getLoadingBlockAfter(tDetails) !== null || getMinimumDurationForState(tDetails, DeferBlockState.Loading) !== null || getMinimumDurationForState(tDetails, DeferBlockState.Placeholder));
    if (ngDevMode && needsScheduling) {
      assertDefined(applyDeferBlockStateWithSchedulingImpl, "Expected scheduling function to be defined");
    }
    const applyStateFn = needsScheduling ? applyDeferBlockStateWithSchedulingImpl : applyDeferBlockState;
    try {
      applyStateFn(newState, lDetails, lContainer, tNode, hostLView);
    } catch (error) {
      handleError(hostLView, error);
    }
  }
}
function getOrCreateEnvironmentInjector(parentInjector, tDetails, providers) {
  return parentInjector.get(CachedInjectorService).getOrCreateInjector(tDetails, parentInjector, providers, ngDevMode ? "DeferBlock Injector" : "");
}
function createDeferBlockInjector(parentInjector, tDetails, providers) {
  if (parentInjector instanceof ChainedInjector) {
    const origInjector = parentInjector.injector;
    const parentEnvInjector2 = parentInjector.parentInjector;
    const envInjector = getOrCreateEnvironmentInjector(parentEnvInjector2, tDetails, providers);
    return new ChainedInjector(origInjector, envInjector);
  }
  const parentEnvInjector = parentInjector.get(EnvironmentInjector);
  if (parentEnvInjector !== parentInjector) {
    const envInjector = getOrCreateEnvironmentInjector(parentEnvInjector, tDetails, providers);
    return new ChainedInjector(parentInjector, envInjector);
  }
  return getOrCreateEnvironmentInjector(parentInjector, tDetails, providers);
}
function applyDeferBlockState(newState, lDetails, lContainer, tNode, hostLView) {
  const stateTmplIndex = getTemplateIndexForState(newState, hostLView, tNode);
  if (stateTmplIndex !== null) {
    lDetails[DEFER_BLOCK_STATE] = newState;
    const hostTView = hostLView[TVIEW];
    const adjustedIndex = stateTmplIndex + HEADER_OFFSET;
    const activeBlockTNode = getTNode(hostTView, adjustedIndex);
    const viewIndex = 0;
    removeLViewFromLContainer(lContainer, viewIndex);
    let injector;
    if (newState === DeferBlockState.Complete) {
      const tDetails = getTDeferBlockDetails(hostTView, tNode);
      const providers = tDetails.providers;
      if (providers && providers.length > 0) {
        injector = createDeferBlockInjector(hostLView[INJECTOR], tDetails, providers);
      }
    }
    const dehydratedView = findMatchingDehydratedView(lContainer, activeBlockTNode.tView.ssrId);
    const embeddedLView = createAndRenderEmbeddedLView(hostLView, activeBlockTNode, null, {
      dehydratedView,
      injector
    });
    addLViewToLContainer(lContainer, embeddedLView, viewIndex, shouldAddViewToDom(activeBlockTNode, dehydratedView));
    markViewDirty(
      embeddedLView,
      2
      /* NotificationSource.DeferBlockStateUpdate */
    );
  }
}
function applyDeferBlockStateWithScheduling(newState, lDetails, lContainer, tNode, hostLView) {
  const now = Date.now();
  const hostTView = hostLView[TVIEW];
  const tDetails = getTDeferBlockDetails(hostTView, tNode);
  if (lDetails[STATE_IS_FROZEN_UNTIL] === null || lDetails[STATE_IS_FROZEN_UNTIL] <= now) {
    lDetails[STATE_IS_FROZEN_UNTIL] = null;
    const loadingAfter = getLoadingBlockAfter(tDetails);
    const inLoadingAfterPhase = lDetails[LOADING_AFTER_CLEANUP_FN] !== null;
    if (newState === DeferBlockState.Loading && loadingAfter !== null && !inLoadingAfterPhase) {
      lDetails[NEXT_DEFER_BLOCK_STATE] = newState;
      const cleanupFn = scheduleDeferBlockUpdate(loadingAfter, lDetails, tNode, lContainer, hostLView);
      lDetails[LOADING_AFTER_CLEANUP_FN] = cleanupFn;
    } else {
      if (newState > DeferBlockState.Loading && inLoadingAfterPhase) {
        lDetails[LOADING_AFTER_CLEANUP_FN]();
        lDetails[LOADING_AFTER_CLEANUP_FN] = null;
        lDetails[NEXT_DEFER_BLOCK_STATE] = null;
      }
      applyDeferBlockState(newState, lDetails, lContainer, tNode, hostLView);
      const duration = getMinimumDurationForState(tDetails, newState);
      if (duration !== null) {
        lDetails[STATE_IS_FROZEN_UNTIL] = now + duration;
        scheduleDeferBlockUpdate(duration, lDetails, tNode, lContainer, hostLView);
      }
    }
  } else {
    lDetails[NEXT_DEFER_BLOCK_STATE] = newState;
  }
}
function scheduleDeferBlockUpdate(timeout, lDetails, tNode, lContainer, hostLView) {
  const callback = () => {
    const nextState = lDetails[NEXT_DEFER_BLOCK_STATE];
    lDetails[STATE_IS_FROZEN_UNTIL] = null;
    lDetails[NEXT_DEFER_BLOCK_STATE] = null;
    if (nextState !== null) {
      renderDeferBlockState(nextState, tNode, lContainer);
    }
  };
  return scheduleTimerTrigger(timeout, callback, hostLView);
}
function isValidStateChange(currentState, newState) {
  return currentState < newState;
}
function triggerPrefetching(tDetails, lView, tNode) {
  if (lView[INJECTOR] && shouldTriggerDeferBlock(lView[INJECTOR])) {
    triggerResourceLoading(tDetails, lView, tNode);
  }
}
function triggerResourceLoading(tDetails, lView, tNode) {
  const injector = lView[INJECTOR];
  const tView = lView[TVIEW];
  if (tDetails.loadingState !== DeferDependenciesLoadingState.NOT_STARTED) {
    return tDetails.loadingPromise ?? Promise.resolve();
  }
  const lDetails = getLDeferBlockDetails(lView, tNode);
  const primaryBlockTNode = getPrimaryBlockTNode(tView, tDetails);
  tDetails.loadingState = DeferDependenciesLoadingState.IN_PROGRESS;
  invokeTriggerCleanupFns(1, lDetails);
  let dependenciesFn = tDetails.dependencyResolverFn;
  if (ngDevMode) {
    const deferDependencyInterceptor = injector.get(DEFER_BLOCK_DEPENDENCY_INTERCEPTOR, null, {
      optional: true
    });
    if (deferDependencyInterceptor) {
      dependenciesFn = deferDependencyInterceptor.intercept(dependenciesFn);
    }
  }
  const pendingTasks = injector.get(PendingTasks);
  const taskId = pendingTasks.add();
  if (!dependenciesFn) {
    tDetails.loadingPromise = Promise.resolve().then(() => {
      tDetails.loadingPromise = null;
      tDetails.loadingState = DeferDependenciesLoadingState.COMPLETE;
      pendingTasks.remove(taskId);
    });
    return tDetails.loadingPromise;
  }
  tDetails.loadingPromise = Promise.allSettled(dependenciesFn()).then((results) => {
    let failed = false;
    const directiveDefs = [];
    const pipeDefs = [];
    for (const result of results) {
      if (result.status === "fulfilled") {
        const dependency = result.value;
        const directiveDef = getComponentDef(dependency) || getDirectiveDef(dependency);
        if (directiveDef) {
          directiveDefs.push(directiveDef);
        } else {
          const pipeDef = getPipeDef$1(dependency);
          if (pipeDef) {
            pipeDefs.push(pipeDef);
          }
        }
      } else {
        failed = true;
        break;
      }
    }
    tDetails.loadingPromise = null;
    pendingTasks.remove(taskId);
    if (failed) {
      tDetails.loadingState = DeferDependenciesLoadingState.FAILED;
      if (tDetails.errorTmplIndex === null) {
        const templateLocation = ngDevMode ? getTemplateLocationDetails(lView) : "";
        const error = new RuntimeError(750, ngDevMode && `Loading dependencies for \`@defer\` block failed, but no \`@error\` block was configured${templateLocation}. Consider using the \`@error\` block to render an error state.`);
        handleError(lView, error);
      }
    } else {
      tDetails.loadingState = DeferDependenciesLoadingState.COMPLETE;
      const primaryBlockTView = primaryBlockTNode.tView;
      if (directiveDefs.length > 0) {
        primaryBlockTView.directiveRegistry = addDepsToRegistry(primaryBlockTView.directiveRegistry, directiveDefs);
        const directiveTypes = directiveDefs.map((def) => def.type);
        const providers = internalImportProvidersFrom(false, ...directiveTypes);
        tDetails.providers = providers;
      }
      if (pipeDefs.length > 0) {
        primaryBlockTView.pipeRegistry = addDepsToRegistry(primaryBlockTView.pipeRegistry, pipeDefs);
      }
    }
  });
  return tDetails.loadingPromise;
}
function renderPlaceholder(lView, tNode) {
  const lContainer = lView[tNode.index];
  ngDevMode && assertLContainer(lContainer);
  renderDeferBlockState(DeferBlockState.Placeholder, tNode, lContainer);
}
function renderDeferStateAfterResourceLoading(tDetails, tNode, lContainer) {
  ngDevMode && assertDefined(tDetails.loadingPromise, "Expected loading Promise to exist on this defer block");
  tDetails.loadingPromise.then(() => {
    if (tDetails.loadingState === DeferDependenciesLoadingState.COMPLETE) {
      ngDevMode && assertDeferredDependenciesLoaded(tDetails);
      renderDeferBlockState(DeferBlockState.Complete, tNode, lContainer);
    } else if (tDetails.loadingState === DeferDependenciesLoadingState.FAILED) {
      renderDeferBlockState(DeferBlockState.Error, tNode, lContainer);
    }
  });
}
function triggerDeferBlock(lView, tNode) {
  const tView = lView[TVIEW];
  const lContainer = lView[tNode.index];
  const injector = lView[INJECTOR];
  ngDevMode && assertLContainer(lContainer);
  if (!shouldTriggerDeferBlock(injector)) return;
  const lDetails = getLDeferBlockDetails(lView, tNode);
  const tDetails = getTDeferBlockDetails(tView, tNode);
  invokeAllTriggerCleanupFns(lDetails);
  switch (tDetails.loadingState) {
    case DeferDependenciesLoadingState.NOT_STARTED:
      renderDeferBlockState(DeferBlockState.Loading, tNode, lContainer);
      triggerResourceLoading(tDetails, lView, tNode);
      if (tDetails.loadingState === DeferDependenciesLoadingState.IN_PROGRESS) {
        renderDeferStateAfterResourceLoading(tDetails, tNode, lContainer);
      }
      break;
    case DeferDependenciesLoadingState.IN_PROGRESS:
      renderDeferBlockState(DeferBlockState.Loading, tNode, lContainer);
      renderDeferStateAfterResourceLoading(tDetails, tNode, lContainer);
      break;
    case DeferDependenciesLoadingState.COMPLETE:
      ngDevMode && assertDeferredDependenciesLoaded(tDetails);
      renderDeferBlockState(DeferBlockState.Complete, tNode, lContainer);
      break;
    case DeferDependenciesLoadingState.FAILED:
      renderDeferBlockState(DeferBlockState.Error, tNode, lContainer);
      break;
    default:
      if (ngDevMode) {
        throwError("Unknown defer block state");
      }
  }
}
function ɵɵattribute(name, value, sanitizer, namespace) {
  const lView = getLView();
  const bindingIndex = nextBindingIndex();
  if (bindingUpdated(lView, bindingIndex, value)) {
    const tView = getTView();
    const tNode = getSelectedTNode();
    elementAttributeInternal(tNode, lView, name, value, sanitizer, namespace);
    ngDevMode && storePropertyBindingMetadata(tView.data, tNode, "attr." + name, bindingIndex);
  }
  return ɵɵattribute;
}
function interpolationV(lView, values) {
  ngDevMode && assertLessThan(2, values.length, "should have at least 3 values");
  ngDevMode && assertEqual(values.length % 2, 1, "should have an odd number of values");
  let isBindingUpdated = false;
  let bindingIndex = getBindingIndex();
  for (let i = 1; i < values.length; i += 2) {
    isBindingUpdated = bindingUpdated(lView, bindingIndex++, values[i]) || isBindingUpdated;
  }
  setBindingIndex(bindingIndex);
  if (!isBindingUpdated) {
    return NO_CHANGE;
  }
  let content = values[0];
  for (let i = 1; i < values.length; i += 2) {
    content += renderStringify(values[i]) + values[i + 1];
  }
  return content;
}
function interpolation1(lView, prefix, v0, suffix) {
  const different = bindingUpdated(lView, nextBindingIndex(), v0);
  return different ? prefix + renderStringify(v0) + suffix : NO_CHANGE;
}
function interpolation2(lView, prefix, v0, i0, v1, suffix) {
  const bindingIndex = getBindingIndex();
  const different = bindingUpdated2(lView, bindingIndex, v0, v1);
  incrementBindingIndex(2);
  return different ? prefix + renderStringify(v0) + i0 + renderStringify(v1) + suffix : NO_CHANGE;
}
function interpolation3(lView, prefix, v0, i0, v1, i1, v2, suffix) {
  const bindingIndex = getBindingIndex();
  const different = bindingUpdated3(lView, bindingIndex, v0, v1, v2);
  incrementBindingIndex(3);
  return different ? prefix + renderStringify(v0) + i0 + renderStringify(v1) + i1 + renderStringify(v2) + suffix : NO_CHANGE;
}
function interpolation4(lView, prefix, v0, i0, v1, i1, v2, i2, v3, suffix) {
  const bindingIndex = getBindingIndex();
  const different = bindingUpdated4(lView, bindingIndex, v0, v1, v2, v3);
  incrementBindingIndex(4);
  return different ? prefix + renderStringify(v0) + i0 + renderStringify(v1) + i1 + renderStringify(v2) + i2 + renderStringify(v3) + suffix : NO_CHANGE;
}
function interpolation5(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, suffix) {
  const bindingIndex = getBindingIndex();
  let different = bindingUpdated4(lView, bindingIndex, v0, v1, v2, v3);
  different = bindingUpdated(lView, bindingIndex + 4, v4) || different;
  incrementBindingIndex(5);
  return different ? prefix + renderStringify(v0) + i0 + renderStringify(v1) + i1 + renderStringify(v2) + i2 + renderStringify(v3) + i3 + renderStringify(v4) + suffix : NO_CHANGE;
}
function interpolation6(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, suffix) {
  const bindingIndex = getBindingIndex();
  let different = bindingUpdated4(lView, bindingIndex, v0, v1, v2, v3);
  different = bindingUpdated2(lView, bindingIndex + 4, v4, v5) || different;
  incrementBindingIndex(6);
  return different ? prefix + renderStringify(v0) + i0 + renderStringify(v1) + i1 + renderStringify(v2) + i2 + renderStringify(v3) + i3 + renderStringify(v4) + i4 + renderStringify(v5) + suffix : NO_CHANGE;
}
function interpolation7(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, suffix) {
  const bindingIndex = getBindingIndex();
  let different = bindingUpdated4(lView, bindingIndex, v0, v1, v2, v3);
  different = bindingUpdated3(lView, bindingIndex + 4, v4, v5, v6) || different;
  incrementBindingIndex(7);
  return different ? prefix + renderStringify(v0) + i0 + renderStringify(v1) + i1 + renderStringify(v2) + i2 + renderStringify(v3) + i3 + renderStringify(v4) + i4 + renderStringify(v5) + i5 + renderStringify(v6) + suffix : NO_CHANGE;
}
function interpolation8(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, i6, v7, suffix) {
  const bindingIndex = getBindingIndex();
  let different = bindingUpdated4(lView, bindingIndex, v0, v1, v2, v3);
  different = bindingUpdated4(lView, bindingIndex + 4, v4, v5, v6, v7) || different;
  incrementBindingIndex(8);
  return different ? prefix + renderStringify(v0) + i0 + renderStringify(v1) + i1 + renderStringify(v2) + i2 + renderStringify(v3) + i3 + renderStringify(v4) + i4 + renderStringify(v5) + i5 + renderStringify(v6) + i6 + renderStringify(v7) + suffix : NO_CHANGE;
}
function ɵɵattributeInterpolate1(attrName, prefix, v0, suffix, sanitizer, namespace) {
  const lView = getLView();
  const interpolatedValue = interpolation1(lView, prefix, v0, suffix);
  if (interpolatedValue !== NO_CHANGE) {
    const tNode = getSelectedTNode();
    elementAttributeInternal(tNode, lView, attrName, interpolatedValue, sanitizer, namespace);
    ngDevMode && storePropertyBindingMetadata(getTView().data, tNode, "attr." + attrName, getBindingIndex() - 1, prefix, suffix);
  }
  return ɵɵattributeInterpolate1;
}
function ɵɵattributeInterpolate2(attrName, prefix, v0, i0, v1, suffix, sanitizer, namespace) {
  const lView = getLView();
  const interpolatedValue = interpolation2(lView, prefix, v0, i0, v1, suffix);
  if (interpolatedValue !== NO_CHANGE) {
    const tNode = getSelectedTNode();
    elementAttributeInternal(tNode, lView, attrName, interpolatedValue, sanitizer, namespace);
    ngDevMode && storePropertyBindingMetadata(getTView().data, tNode, "attr." + attrName, getBindingIndex() - 2, prefix, i0, suffix);
  }
  return ɵɵattributeInterpolate2;
}
function ɵɵattributeInterpolate3(attrName, prefix, v0, i0, v1, i1, v2, suffix, sanitizer, namespace) {
  const lView = getLView();
  const interpolatedValue = interpolation3(lView, prefix, v0, i0, v1, i1, v2, suffix);
  if (interpolatedValue !== NO_CHANGE) {
    const tNode = getSelectedTNode();
    elementAttributeInternal(tNode, lView, attrName, interpolatedValue, sanitizer, namespace);
    ngDevMode && storePropertyBindingMetadata(getTView().data, tNode, "attr." + attrName, getBindingIndex() - 3, prefix, i0, i1, suffix);
  }
  return ɵɵattributeInterpolate3;
}
function ɵɵattributeInterpolate4(attrName, prefix, v0, i0, v1, i1, v2, i2, v3, suffix, sanitizer, namespace) {
  const lView = getLView();
  const interpolatedValue = interpolation4(lView, prefix, v0, i0, v1, i1, v2, i2, v3, suffix);
  if (interpolatedValue !== NO_CHANGE) {
    const tNode = getSelectedTNode();
    elementAttributeInternal(tNode, lView, attrName, interpolatedValue, sanitizer, namespace);
    ngDevMode && storePropertyBindingMetadata(getTView().data, tNode, "attr." + attrName, getBindingIndex() - 4, prefix, i0, i1, i2, suffix);
  }
  return ɵɵattributeInterpolate4;
}
function ɵɵattributeInterpolate5(attrName, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, suffix, sanitizer, namespace) {
  const lView = getLView();
  const interpolatedValue = interpolation5(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, suffix);
  if (interpolatedValue !== NO_CHANGE) {
    const tNode = getSelectedTNode();
    elementAttributeInternal(tNode, lView, attrName, interpolatedValue, sanitizer, namespace);
    ngDevMode && storePropertyBindingMetadata(getTView().data, tNode, "attr." + attrName, getBindingIndex() - 5, prefix, i0, i1, i2, i3, suffix);
  }
  return ɵɵattributeInterpolate5;
}
function ɵɵattributeInterpolate6(attrName, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, suffix, sanitizer, namespace) {
  const lView = getLView();
  const interpolatedValue = interpolation6(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, suffix);
  if (interpolatedValue !== NO_CHANGE) {
    const tNode = getSelectedTNode();
    elementAttributeInternal(tNode, lView, attrName, interpolatedValue, sanitizer, namespace);
    ngDevMode && storePropertyBindingMetadata(getTView().data, tNode, "attr." + attrName, getBindingIndex() - 6, prefix, i0, i1, i2, i3, i4, suffix);
  }
  return ɵɵattributeInterpolate6;
}
function ɵɵattributeInterpolate7(attrName, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, suffix, sanitizer, namespace) {
  const lView = getLView();
  const interpolatedValue = interpolation7(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, suffix);
  if (interpolatedValue !== NO_CHANGE) {
    const tNode = getSelectedTNode();
    elementAttributeInternal(tNode, lView, attrName, interpolatedValue, sanitizer, namespace);
    ngDevMode && storePropertyBindingMetadata(getTView().data, tNode, "attr." + attrName, getBindingIndex() - 7, prefix, i0, i1, i2, i3, i4, i5, suffix);
  }
  return ɵɵattributeInterpolate7;
}
function ɵɵattributeInterpolate8(attrName, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, i6, v7, suffix, sanitizer, namespace) {
  const lView = getLView();
  const interpolatedValue = interpolation8(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, i6, v7, suffix);
  if (interpolatedValue !== NO_CHANGE) {
    const tNode = getSelectedTNode();
    elementAttributeInternal(tNode, lView, attrName, interpolatedValue, sanitizer, namespace);
    ngDevMode && storePropertyBindingMetadata(getTView().data, tNode, "attr." + attrName, getBindingIndex() - 8, prefix, i0, i1, i2, i3, i4, i5, i6, suffix);
  }
  return ɵɵattributeInterpolate8;
}
function ɵɵattributeInterpolateV(attrName, values, sanitizer, namespace) {
  const lView = getLView();
  const interpolated = interpolationV(lView, values);
  if (interpolated !== NO_CHANGE) {
    const tNode = getSelectedTNode();
    elementAttributeInternal(tNode, lView, attrName, interpolated, sanitizer, namespace);
    if (ngDevMode) {
      const interpolationInBetween = [values[0]];
      for (let i = 2; i < values.length; i += 2) {
        interpolationInBetween.push(values[i]);
      }
      storePropertyBindingMetadata(getTView().data, tNode, "attr." + attrName, getBindingIndex() - interpolationInBetween.length + 1, ...interpolationInBetween);
    }
  }
  return ɵɵattributeInterpolateV;
}
function toTStylingRange(prev, next) {
  ngDevMode && assertNumberInRange(
    prev,
    0,
    32767
    /* StylingRange.UNSIGNED_MASK */
  );
  ngDevMode && assertNumberInRange(
    next,
    0,
    32767
    /* StylingRange.UNSIGNED_MASK */
  );
  return prev << 17 | next << 2;
}
function getTStylingRangePrev(tStylingRange) {
  ngDevMode && assertNumber(tStylingRange, "expected number");
  return tStylingRange >> 17 & 32767;
}
function getTStylingRangePrevDuplicate(tStylingRange) {
  ngDevMode && assertNumber(tStylingRange, "expected number");
  return (tStylingRange & 2) == 2;
}
function setTStylingRangePrev(tStylingRange, previous) {
  ngDevMode && assertNumber(tStylingRange, "expected number");
  ngDevMode && assertNumberInRange(
    previous,
    0,
    32767
    /* StylingRange.UNSIGNED_MASK */
  );
  return tStylingRange & ~4294836224 | previous << 17;
}
function setTStylingRangePrevDuplicate(tStylingRange) {
  ngDevMode && assertNumber(tStylingRange, "expected number");
  return tStylingRange | 2;
}
function getTStylingRangeNext(tStylingRange) {
  ngDevMode && assertNumber(tStylingRange, "expected number");
  return (tStylingRange & 131068) >> 2;
}
function setTStylingRangeNext(tStylingRange, next) {
  ngDevMode && assertNumber(tStylingRange, "expected number");
  ngDevMode && assertNumberInRange(
    next,
    0,
    32767
    /* StylingRange.UNSIGNED_MASK */
  );
  return tStylingRange & ~131068 | //
  next << 2;
}
function getTStylingRangeNextDuplicate(tStylingRange) {
  ngDevMode && assertNumber(tStylingRange, "expected number");
  return (tStylingRange & 1) === 1;
}
function setTStylingRangeNextDuplicate(tStylingRange) {
  ngDevMode && assertNumber(tStylingRange, "expected number");
  return tStylingRange | 1;
}
function insertTStylingBinding(tData, tNode, tStylingKeyWithStatic, index, isHostBinding, isClassBinding) {
  ngDevMode && assertFirstUpdatePass(getTView());
  let tBindings = isClassBinding ? tNode.classBindings : tNode.styleBindings;
  let tmplHead = getTStylingRangePrev(tBindings);
  let tmplTail = getTStylingRangeNext(tBindings);
  tData[index] = tStylingKeyWithStatic;
  let isKeyDuplicateOfStatic = false;
  let tStylingKey;
  if (Array.isArray(tStylingKeyWithStatic)) {
    const staticKeyValueArray = tStylingKeyWithStatic;
    tStylingKey = staticKeyValueArray[1];
    if (tStylingKey === null || keyValueArrayIndexOf(staticKeyValueArray, tStylingKey) > 0) {
      isKeyDuplicateOfStatic = true;
    }
  } else {
    tStylingKey = tStylingKeyWithStatic;
  }
  if (isHostBinding) {
    const hasTemplateBindings = tmplTail !== 0;
    if (hasTemplateBindings) {
      const previousNode = getTStylingRangePrev(tData[tmplHead + 1]);
      tData[index + 1] = toTStylingRange(previousNode, tmplHead);
      if (previousNode !== 0) {
        tData[previousNode + 1] = setTStylingRangeNext(tData[previousNode + 1], index);
      }
      tData[tmplHead + 1] = setTStylingRangePrev(tData[tmplHead + 1], index);
    } else {
      tData[index + 1] = toTStylingRange(tmplHead, 0);
      if (tmplHead !== 0) {
        tData[tmplHead + 1] = setTStylingRangeNext(tData[tmplHead + 1], index);
      }
      tmplHead = index;
    }
  } else {
    tData[index + 1] = toTStylingRange(tmplTail, 0);
    ngDevMode && assertEqual(tmplHead !== 0 && tmplTail === 0, false, "Adding template bindings after hostBindings is not allowed.");
    if (tmplHead === 0) {
      tmplHead = index;
    } else {
      tData[tmplTail + 1] = setTStylingRangeNext(tData[tmplTail + 1], index);
    }
    tmplTail = index;
  }
  if (isKeyDuplicateOfStatic) {
    tData[index + 1] = setTStylingRangePrevDuplicate(tData[index + 1]);
  }
  markDuplicates(tData, tStylingKey, index, true);
  markDuplicates(tData, tStylingKey, index, false);
  markDuplicateOfResidualStyling(tNode, tStylingKey, tData, index, isClassBinding);
  tBindings = toTStylingRange(tmplHead, tmplTail);
  if (isClassBinding) {
    tNode.classBindings = tBindings;
  } else {
    tNode.styleBindings = tBindings;
  }
}
function markDuplicateOfResidualStyling(tNode, tStylingKey, tData, index, isClassBinding) {
  const residual = isClassBinding ? tNode.residualClasses : tNode.residualStyles;
  if (residual != null && typeof tStylingKey == "string" && keyValueArrayIndexOf(residual, tStylingKey) >= 0) {
    tData[index + 1] = setTStylingRangeNextDuplicate(tData[index + 1]);
  }
}
function markDuplicates(tData, tStylingKey, index, isPrevDir) {
  const tStylingAtIndex = tData[index + 1];
  const isMap = tStylingKey === null;
  let cursor = isPrevDir ? getTStylingRangePrev(tStylingAtIndex) : getTStylingRangeNext(tStylingAtIndex);
  let foundDuplicate = false;
  while (cursor !== 0 && (foundDuplicate === false || isMap)) {
    ngDevMode && assertIndexInRange(tData, cursor);
    const tStylingValueAtCursor = tData[cursor];
    const tStyleRangeAtCursor = tData[cursor + 1];
    if (isStylingMatch(tStylingValueAtCursor, tStylingKey)) {
      foundDuplicate = true;
      tData[cursor + 1] = isPrevDir ? setTStylingRangeNextDuplicate(tStyleRangeAtCursor) : setTStylingRangePrevDuplicate(tStyleRangeAtCursor);
    }
    cursor = isPrevDir ? getTStylingRangePrev(tStyleRangeAtCursor) : getTStylingRangeNext(tStyleRangeAtCursor);
  }
  if (foundDuplicate) {
    tData[index + 1] = isPrevDir ? setTStylingRangePrevDuplicate(tStylingAtIndex) : setTStylingRangeNextDuplicate(tStylingAtIndex);
  }
}
function isStylingMatch(tStylingKeyCursor, tStylingKey) {
  ngDevMode && assertNotEqual(Array.isArray(tStylingKey), true, "Expected that 'tStylingKey' has been unwrapped");
  if (tStylingKeyCursor === null || // If the cursor is `null` it means that we have map at that
  // location so we must assume that we have a match.
  tStylingKey == null || // If `tStylingKey` is `null` then it is a map therefor assume that it
  // contains a match.
  (Array.isArray(tStylingKeyCursor) ? tStylingKeyCursor[1] : tStylingKeyCursor) === tStylingKey) {
    return true;
  } else if (Array.isArray(tStylingKeyCursor) && typeof tStylingKey === "string") {
    return keyValueArrayIndexOf(tStylingKeyCursor, tStylingKey) >= 0;
  }
  return false;
}
var parserState = {
  textEnd: 0,
  key: 0,
  keyEnd: 0,
  value: 0,
  valueEnd: 0
};
function getLastParsedKey(text) {
  return text.substring(parserState.key, parserState.keyEnd);
}
function getLastParsedValue(text) {
  return text.substring(parserState.value, parserState.valueEnd);
}
function parseClassName(text) {
  resetParserState(text);
  return parseClassNameNext(text, consumeWhitespace(text, 0, parserState.textEnd));
}
function parseClassNameNext(text, index) {
  const end = parserState.textEnd;
  if (end === index) {
    return -1;
  }
  index = parserState.keyEnd = consumeClassToken(text, parserState.key = index, end);
  return consumeWhitespace(text, index, end);
}
function parseStyle(text) {
  resetParserState(text);
  return parseStyleNext(text, consumeWhitespace(text, 0, parserState.textEnd));
}
function parseStyleNext(text, startIndex) {
  const end = parserState.textEnd;
  let index = parserState.key = consumeWhitespace(text, startIndex, end);
  if (end === index) {
    return -1;
  }
  index = parserState.keyEnd = consumeStyleKey(text, index, end);
  index = consumeSeparator(
    text,
    index,
    end,
    58
    /* CharCode.COLON */
  );
  index = parserState.value = consumeWhitespace(text, index, end);
  index = parserState.valueEnd = consumeStyleValue(text, index, end);
  return consumeSeparator(
    text,
    index,
    end,
    59
    /* CharCode.SEMI_COLON */
  );
}
function resetParserState(text) {
  parserState.key = 0;
  parserState.keyEnd = 0;
  parserState.value = 0;
  parserState.valueEnd = 0;
  parserState.textEnd = text.length;
}
function consumeWhitespace(text, startIndex, endIndex) {
  while (startIndex < endIndex && text.charCodeAt(startIndex) <= 32) {
    startIndex++;
  }
  return startIndex;
}
function consumeClassToken(text, startIndex, endIndex) {
  while (startIndex < endIndex && text.charCodeAt(startIndex) > 32) {
    startIndex++;
  }
  return startIndex;
}
function consumeStyleKey(text, startIndex, endIndex) {
  let ch;
  while (startIndex < endIndex && ((ch = text.charCodeAt(startIndex)) === 45 || ch === 95 || (ch & -33) >= 65 && (ch & -33) <= 90 || ch >= 48 && ch <= 57)) {
    startIndex++;
  }
  return startIndex;
}
function consumeSeparator(text, startIndex, endIndex, separator) {
  startIndex = consumeWhitespace(text, startIndex, endIndex);
  if (startIndex < endIndex) {
    if (ngDevMode && text.charCodeAt(startIndex) !== separator) {
      malformedStyleError(text, String.fromCharCode(separator), startIndex);
    }
    startIndex++;
  }
  return startIndex;
}
function consumeStyleValue(text, startIndex, endIndex) {
  let ch1 = -1;
  let ch2 = -1;
  let ch3 = -1;
  let i = startIndex;
  let lastChIndex = i;
  while (i < endIndex) {
    const ch = text.charCodeAt(i++);
    if (ch === 59) {
      return lastChIndex;
    } else if (ch === 34 || ch === 39) {
      lastChIndex = i = consumeQuotedText(text, ch, i, endIndex);
    } else if (startIndex === i - 4 && // We have seen only 4 characters so far "URL(" (Ignore "foo_URL()")
    ch3 === 85 && ch2 === 82 && ch1 === 76 && ch === 40) {
      lastChIndex = i = consumeQuotedText(text, 41, i, endIndex);
    } else if (ch > 32) {
      lastChIndex = i;
    }
    ch3 = ch2;
    ch2 = ch1;
    ch1 = ch & -33;
  }
  return lastChIndex;
}
function consumeQuotedText(text, quoteCharCode, startIndex, endIndex) {
  let ch1 = -1;
  let index = startIndex;
  while (index < endIndex) {
    const ch = text.charCodeAt(index++);
    if (ch == quoteCharCode && ch1 !== 92) {
      return index;
    }
    if (ch == 92 && ch1 === 92) {
      ch1 = 0;
    } else {
      ch1 = ch;
    }
  }
  throw ngDevMode ? malformedStyleError(text, String.fromCharCode(quoteCharCode), endIndex) : new Error();
}
function malformedStyleError(text, expecting, index) {
  ngDevMode && assertEqual(typeof text === "string", true, "String expected here");
  throw throwError(`Malformed style at location ${index} in string '` + text.substring(0, index) + "[>>" + text.substring(index, index + 1) + "<<]" + text.slice(index + 1) + `'. Expecting '${expecting}'.`);
}
function ɵɵproperty(propName, value, sanitizer) {
  const lView = getLView();
  const bindingIndex = nextBindingIndex();
  if (bindingUpdated(lView, bindingIndex, value)) {
    const tView = getTView();
    const tNode = getSelectedTNode();
    elementPropertyInternal(tView, tNode, lView, propName, value, lView[RENDERER], sanitizer, false);
    ngDevMode && storePropertyBindingMetadata(tView.data, tNode, propName, bindingIndex);
  }
  return ɵɵproperty;
}
function setDirectiveInputsWhichShadowsStyling(tView, tNode, lView, value, isClassBased) {
  const inputs = tNode.inputs;
  const property = isClassBased ? "class" : "style";
  setInputsForProperty(tView, lView, inputs[property], property, value);
}
function ɵɵstyleProp(prop, value, suffix) {
  checkStylingProperty(prop, value, suffix, false);
  return ɵɵstyleProp;
}
function ɵɵclassProp(className, value) {
  checkStylingProperty(className, value, null, true);
  return ɵɵclassProp;
}
function ɵɵstyleMap(styles) {
  checkStylingMap(styleKeyValueArraySet, styleStringParser, styles, false);
}
function styleStringParser(keyValueArray, text) {
  for (let i = parseStyle(text); i >= 0; i = parseStyleNext(text, i)) {
    styleKeyValueArraySet(keyValueArray, getLastParsedKey(text), getLastParsedValue(text));
  }
}
function ɵɵclassMap(classes) {
  checkStylingMap(classKeyValueArraySet, classStringParser, classes, true);
}
function classStringParser(keyValueArray, text) {
  for (let i = parseClassName(text); i >= 0; i = parseClassNameNext(text, i)) {
    keyValueArraySet(keyValueArray, getLastParsedKey(text), true);
  }
}
function checkStylingProperty(prop, value, suffix, isClassBased) {
  const lView = getLView();
  const tView = getTView();
  const bindingIndex = incrementBindingIndex(2);
  if (tView.firstUpdatePass) {
    stylingFirstUpdatePass(tView, prop, bindingIndex, isClassBased);
  }
  if (value !== NO_CHANGE && bindingUpdated(lView, bindingIndex, value)) {
    const tNode = tView.data[getSelectedIndex()];
    updateStyling(tView, tNode, lView, lView[RENDERER], prop, lView[bindingIndex + 1] = normalizeSuffix(value, suffix), isClassBased, bindingIndex);
  }
}
function checkStylingMap(keyValueArraySet2, stringParser, value, isClassBased) {
  const tView = getTView();
  const bindingIndex = incrementBindingIndex(2);
  if (tView.firstUpdatePass) {
    stylingFirstUpdatePass(tView, null, bindingIndex, isClassBased);
  }
  const lView = getLView();
  if (value !== NO_CHANGE && bindingUpdated(lView, bindingIndex, value)) {
    const tNode = tView.data[getSelectedIndex()];
    if (hasStylingInputShadow(tNode, isClassBased) && !isInHostBindings(tView, bindingIndex)) {
      if (ngDevMode) {
        const tStylingKey = tView.data[bindingIndex];
        assertEqual(Array.isArray(tStylingKey) ? tStylingKey[1] : tStylingKey, false, "Styling linked list shadow input should be marked as 'false'");
      }
      let staticPrefix = isClassBased ? tNode.classesWithoutHost : tNode.stylesWithoutHost;
      ngDevMode && isClassBased === false && staticPrefix !== null && assertEqual(staticPrefix.endsWith(";"), true, "Expecting static portion to end with ';'");
      if (staticPrefix !== null) {
        value = concatStringsWithSpace(staticPrefix, value ? value : "");
      }
      setDirectiveInputsWhichShadowsStyling(tView, tNode, lView, value, isClassBased);
    } else {
      updateStylingMap(tView, tNode, lView, lView[RENDERER], lView[bindingIndex + 1], lView[bindingIndex + 1] = toStylingKeyValueArray(keyValueArraySet2, stringParser, value), isClassBased, bindingIndex);
    }
  }
}
function isInHostBindings(tView, bindingIndex) {
  return bindingIndex >= tView.expandoStartIndex;
}
function stylingFirstUpdatePass(tView, tStylingKey, bindingIndex, isClassBased) {
  ngDevMode && assertFirstUpdatePass(tView);
  const tData = tView.data;
  if (tData[bindingIndex + 1] === null) {
    const tNode = tData[getSelectedIndex()];
    ngDevMode && assertDefined(tNode, "TNode expected");
    const isHostBindings = isInHostBindings(tView, bindingIndex);
    if (hasStylingInputShadow(tNode, isClassBased) && tStylingKey === null && !isHostBindings) {
      tStylingKey = false;
    }
    tStylingKey = wrapInStaticStylingKey(tData, tNode, tStylingKey, isClassBased);
    insertTStylingBinding(tData, tNode, tStylingKey, bindingIndex, isHostBindings, isClassBased);
  }
}
function wrapInStaticStylingKey(tData, tNode, stylingKey, isClassBased) {
  const hostDirectiveDef = getCurrentDirectiveDef(tData);
  let residual = isClassBased ? tNode.residualClasses : tNode.residualStyles;
  if (hostDirectiveDef === null) {
    const isFirstStylingInstructionInTemplate = (isClassBased ? tNode.classBindings : tNode.styleBindings) === 0;
    if (isFirstStylingInstructionInTemplate) {
      stylingKey = collectStylingFromDirectives(null, tData, tNode, stylingKey, isClassBased);
      stylingKey = collectStylingFromTAttrs(stylingKey, tNode.attrs, isClassBased);
      residual = null;
    }
  } else {
    const directiveStylingLast = tNode.directiveStylingLast;
    const isFirstStylingInstructionInHostBinding = directiveStylingLast === -1 || tData[directiveStylingLast] !== hostDirectiveDef;
    if (isFirstStylingInstructionInHostBinding) {
      stylingKey = collectStylingFromDirectives(hostDirectiveDef, tData, tNode, stylingKey, isClassBased);
      if (residual === null) {
        let templateStylingKey = getTemplateHeadTStylingKey(tData, tNode, isClassBased);
        if (templateStylingKey !== void 0 && Array.isArray(templateStylingKey)) {
          templateStylingKey = collectStylingFromDirectives(null, tData, tNode, templateStylingKey[1], isClassBased);
          templateStylingKey = collectStylingFromTAttrs(templateStylingKey, tNode.attrs, isClassBased);
          setTemplateHeadTStylingKey(tData, tNode, isClassBased, templateStylingKey);
        }
      } else {
        residual = collectResidual(tData, tNode, isClassBased);
      }
    }
  }
  if (residual !== void 0) {
    isClassBased ? tNode.residualClasses = residual : tNode.residualStyles = residual;
  }
  return stylingKey;
}
function getTemplateHeadTStylingKey(tData, tNode, isClassBased) {
  const bindings = isClassBased ? tNode.classBindings : tNode.styleBindings;
  if (getTStylingRangeNext(bindings) === 0) {
    return void 0;
  }
  return tData[getTStylingRangePrev(bindings)];
}
function setTemplateHeadTStylingKey(tData, tNode, isClassBased, tStylingKey) {
  const bindings = isClassBased ? tNode.classBindings : tNode.styleBindings;
  ngDevMode && assertNotEqual(getTStylingRangeNext(bindings), 0, "Expecting to have at least one template styling binding.");
  tData[getTStylingRangePrev(bindings)] = tStylingKey;
}
function collectResidual(tData, tNode, isClassBased) {
  let residual = void 0;
  const directiveEnd = tNode.directiveEnd;
  ngDevMode && assertNotEqual(tNode.directiveStylingLast, -1, "By the time this function gets called at least one hostBindings-node styling instruction must have executed.");
  for (let i = 1 + tNode.directiveStylingLast; i < directiveEnd; i++) {
    const attrs = tData[i].hostAttrs;
    residual = collectStylingFromTAttrs(residual, attrs, isClassBased);
  }
  return collectStylingFromTAttrs(residual, tNode.attrs, isClassBased);
}
function collectStylingFromDirectives(hostDirectiveDef, tData, tNode, stylingKey, isClassBased) {
  let currentDirective = null;
  const directiveEnd = tNode.directiveEnd;
  let directiveStylingLast = tNode.directiveStylingLast;
  if (directiveStylingLast === -1) {
    directiveStylingLast = tNode.directiveStart;
  } else {
    directiveStylingLast++;
  }
  while (directiveStylingLast < directiveEnd) {
    currentDirective = tData[directiveStylingLast];
    ngDevMode && assertDefined(currentDirective, "expected to be defined");
    stylingKey = collectStylingFromTAttrs(stylingKey, currentDirective.hostAttrs, isClassBased);
    if (currentDirective === hostDirectiveDef) break;
    directiveStylingLast++;
  }
  if (hostDirectiveDef !== null) {
    tNode.directiveStylingLast = directiveStylingLast;
  }
  return stylingKey;
}
function collectStylingFromTAttrs(stylingKey, attrs, isClassBased) {
  const desiredMarker = isClassBased ? 1 : 2;
  let currentMarker = -1;
  if (attrs !== null) {
    for (let i = 0; i < attrs.length; i++) {
      const item = attrs[i];
      if (typeof item === "number") {
        currentMarker = item;
      } else {
        if (currentMarker === desiredMarker) {
          if (!Array.isArray(stylingKey)) {
            stylingKey = stylingKey === void 0 ? [] : ["", stylingKey];
          }
          keyValueArraySet(stylingKey, item, isClassBased ? true : attrs[++i]);
        }
      }
    }
  }
  return stylingKey === void 0 ? null : stylingKey;
}
function toStylingKeyValueArray(keyValueArraySet2, stringParser, value) {
  if (value == null || value === "") return EMPTY_ARRAY;
  const styleKeyValueArray = [];
  const unwrappedValue = unwrapSafeValue(value);
  if (Array.isArray(unwrappedValue)) {
    for (let i = 0; i < unwrappedValue.length; i++) {
      keyValueArraySet2(styleKeyValueArray, unwrappedValue[i], true);
    }
  } else if (typeof unwrappedValue === "object") {
    for (const key in unwrappedValue) {
      if (unwrappedValue.hasOwnProperty(key)) {
        keyValueArraySet2(styleKeyValueArray, key, unwrappedValue[key]);
      }
    }
  } else if (typeof unwrappedValue === "string") {
    stringParser(styleKeyValueArray, unwrappedValue);
  } else {
    ngDevMode && throwError("Unsupported styling type " + typeof unwrappedValue + ": " + unwrappedValue);
  }
  return styleKeyValueArray;
}
function styleKeyValueArraySet(keyValueArray, key, value) {
  keyValueArraySet(keyValueArray, key, unwrapSafeValue(value));
}
function classKeyValueArraySet(keyValueArray, key, value) {
  const stringKey = String(key);
  if (stringKey !== "" && !stringKey.includes(" ")) {
    keyValueArraySet(keyValueArray, stringKey, value);
  }
}
function updateStylingMap(tView, tNode, lView, renderer, oldKeyValueArray, newKeyValueArray, isClassBased, bindingIndex) {
  if (oldKeyValueArray === NO_CHANGE) {
    oldKeyValueArray = EMPTY_ARRAY;
  }
  let oldIndex = 0;
  let newIndex = 0;
  let oldKey = 0 < oldKeyValueArray.length ? oldKeyValueArray[0] : null;
  let newKey = 0 < newKeyValueArray.length ? newKeyValueArray[0] : null;
  while (oldKey !== null || newKey !== null) {
    ngDevMode && assertLessThan(oldIndex, 999, "Are we stuck in infinite loop?");
    ngDevMode && assertLessThan(newIndex, 999, "Are we stuck in infinite loop?");
    const oldValue = oldIndex < oldKeyValueArray.length ? oldKeyValueArray[oldIndex + 1] : void 0;
    const newValue = newIndex < newKeyValueArray.length ? newKeyValueArray[newIndex + 1] : void 0;
    let setKey = null;
    let setValue = void 0;
    if (oldKey === newKey) {
      oldIndex += 2;
      newIndex += 2;
      if (oldValue !== newValue) {
        setKey = newKey;
        setValue = newValue;
      }
    } else if (newKey === null || oldKey !== null && oldKey < newKey) {
      oldIndex += 2;
      setKey = oldKey;
    } else {
      ngDevMode && assertDefined(newKey, "Expecting to have a valid key");
      newIndex += 2;
      setKey = newKey;
      setValue = newValue;
    }
    if (setKey !== null) {
      updateStyling(tView, tNode, lView, renderer, setKey, setValue, isClassBased, bindingIndex);
    }
    oldKey = oldIndex < oldKeyValueArray.length ? oldKeyValueArray[oldIndex] : null;
    newKey = newIndex < newKeyValueArray.length ? newKeyValueArray[newIndex] : null;
  }
}
function updateStyling(tView, tNode, lView, renderer, prop, value, isClassBased, bindingIndex) {
  if (!(tNode.type & 3)) {
    return;
  }
  const tData = tView.data;
  const tRange = tData[bindingIndex + 1];
  const higherPriorityValue = getTStylingRangeNextDuplicate(tRange) ? findStylingValue(tData, tNode, lView, prop, getTStylingRangeNext(tRange), isClassBased) : void 0;
  if (!isStylingValuePresent(higherPriorityValue)) {
    if (!isStylingValuePresent(value)) {
      if (getTStylingRangePrevDuplicate(tRange)) {
        value = findStylingValue(tData, null, lView, prop, bindingIndex, isClassBased);
      }
    }
    const rNode = getNativeByIndex(getSelectedIndex(), lView);
    applyStyling(renderer, isClassBased, rNode, prop, value);
  }
}
function findStylingValue(tData, tNode, lView, prop, index, isClassBased) {
  const isPrevDirection = tNode === null;
  let value = void 0;
  while (index > 0) {
    const rawKey = tData[index];
    const containsStatics = Array.isArray(rawKey);
    const key = containsStatics ? rawKey[1] : rawKey;
    const isStylingMap = key === null;
    let valueAtLViewIndex = lView[index + 1];
    if (valueAtLViewIndex === NO_CHANGE) {
      valueAtLViewIndex = isStylingMap ? EMPTY_ARRAY : void 0;
    }
    let currentValue = isStylingMap ? keyValueArrayGet(valueAtLViewIndex, prop) : key === prop ? valueAtLViewIndex : void 0;
    if (containsStatics && !isStylingValuePresent(currentValue)) {
      currentValue = keyValueArrayGet(rawKey, prop);
    }
    if (isStylingValuePresent(currentValue)) {
      value = currentValue;
      if (isPrevDirection) {
        return value;
      }
    }
    const tRange = tData[index + 1];
    index = isPrevDirection ? getTStylingRangePrev(tRange) : getTStylingRangeNext(tRange);
  }
  if (tNode !== null) {
    let residual = isClassBased ? tNode.residualClasses : tNode.residualStyles;
    if (residual != null) {
      value = keyValueArrayGet(residual, prop);
    }
  }
  return value;
}
function isStylingValuePresent(value) {
  return value !== void 0;
}
function normalizeSuffix(value, suffix) {
  if (value == null || value === "") {
  } else if (typeof suffix === "string") {
    value = value + suffix;
  } else if (typeof value === "object") {
    value = stringify(unwrapSafeValue(value));
  }
  return value;
}
function hasStylingInputShadow(tNode, isClassBased) {
  return (tNode.flags & (isClassBased ? 8 : 16)) !== 0;
}
function ɵɵclassMapInterpolate1(prefix, v0, suffix) {
  const lView = getLView();
  const interpolatedValue = interpolation1(lView, prefix, v0, suffix);
  checkStylingMap(keyValueArraySet, classStringParser, interpolatedValue, true);
}
function ɵɵclassMapInterpolate2(prefix, v0, i0, v1, suffix) {
  const lView = getLView();
  const interpolatedValue = interpolation2(lView, prefix, v0, i0, v1, suffix);
  checkStylingMap(keyValueArraySet, classStringParser, interpolatedValue, true);
}
function ɵɵclassMapInterpolate3(prefix, v0, i0, v1, i1, v2, suffix) {
  const lView = getLView();
  const interpolatedValue = interpolation3(lView, prefix, v0, i0, v1, i1, v2, suffix);
  checkStylingMap(keyValueArraySet, classStringParser, interpolatedValue, true);
}
function ɵɵclassMapInterpolate4(prefix, v0, i0, v1, i1, v2, i2, v3, suffix) {
  const lView = getLView();
  const interpolatedValue = interpolation4(lView, prefix, v0, i0, v1, i1, v2, i2, v3, suffix);
  checkStylingMap(keyValueArraySet, classStringParser, interpolatedValue, true);
}
function ɵɵclassMapInterpolate5(prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, suffix) {
  const lView = getLView();
  const interpolatedValue = interpolation5(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, suffix);
  checkStylingMap(keyValueArraySet, classStringParser, interpolatedValue, true);
}
function ɵɵclassMapInterpolate6(prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, suffix) {
  const lView = getLView();
  const interpolatedValue = interpolation6(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, suffix);
  checkStylingMap(keyValueArraySet, classStringParser, interpolatedValue, true);
}
function ɵɵclassMapInterpolate7(prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, suffix) {
  const lView = getLView();
  const interpolatedValue = interpolation7(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, suffix);
  checkStylingMap(keyValueArraySet, classStringParser, interpolatedValue, true);
}
function ɵɵclassMapInterpolate8(prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, i6, v7, suffix) {
  const lView = getLView();
  const interpolatedValue = interpolation8(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, i6, v7, suffix);
  checkStylingMap(keyValueArraySet, classStringParser, interpolatedValue, true);
}
function ɵɵclassMapInterpolateV(values) {
  const lView = getLView();
  const interpolatedValue = interpolationV(lView, values);
  checkStylingMap(keyValueArraySet, classStringParser, interpolatedValue, true);
}
function ɵɵcomponentInstance() {
  const instance = getLView()[DECLARATION_COMPONENT_VIEW][CONTEXT];
  ngDevMode && assertDefined(instance, "Expected component instance to be defined");
  return instance;
}
var LiveCollection = class {
  destroy(item) {
  }
  updateValue(index, value) {
  }
  // operations below could be implemented on top of the operations defined so far, but having
  // them explicitly allow clear expression of intent and potentially more performant
  // implementations
  swap(index1, index2) {
    const startIdx = Math.min(index1, index2);
    const endIdx = Math.max(index1, index2);
    const endItem = this.detach(endIdx);
    if (endIdx - startIdx > 1) {
      const startItem = this.detach(startIdx);
      this.attach(startIdx, endItem);
      this.attach(endIdx, startItem);
    } else {
      this.attach(startIdx, endItem);
    }
  }
  move(prevIndex, newIdx) {
    this.attach(newIdx, this.detach(prevIndex));
  }
};
function valuesMatching(liveIdx, liveValue, newIdx, newValue, trackBy) {
  if (liveIdx === newIdx && Object.is(liveValue, newValue)) {
    return 1;
  } else if (Object.is(trackBy(liveIdx, liveValue), trackBy(newIdx, newValue))) {
    return -1;
  }
  return 0;
}
function recordDuplicateKeys(keyToIdx, key, idx) {
  const idxSoFar = keyToIdx.get(key);
  if (idxSoFar !== void 0) {
    idxSoFar.add(idx);
  } else {
    keyToIdx.set(key, /* @__PURE__ */ new Set([idx]));
  }
}
function reconcile(liveCollection, newCollection, trackByFn) {
  let detachedItems = void 0;
  let liveKeysInTheFuture = void 0;
  let liveStartIdx = 0;
  let liveEndIdx = liveCollection.length - 1;
  const duplicateKeys = ngDevMode ? /* @__PURE__ */ new Map() : void 0;
  if (Array.isArray(newCollection)) {
    let newEndIdx = newCollection.length - 1;
    while (liveStartIdx <= liveEndIdx && liveStartIdx <= newEndIdx) {
      const liveStartValue = liveCollection.at(liveStartIdx);
      const newStartValue = newCollection[liveStartIdx];
      if (ngDevMode) {
        recordDuplicateKeys(duplicateKeys, trackByFn(liveStartIdx, newStartValue), liveStartIdx);
      }
      const isStartMatching = valuesMatching(liveStartIdx, liveStartValue, liveStartIdx, newStartValue, trackByFn);
      if (isStartMatching !== 0) {
        if (isStartMatching < 0) {
          liveCollection.updateValue(liveStartIdx, newStartValue);
        }
        liveStartIdx++;
        continue;
      }
      const liveEndValue = liveCollection.at(liveEndIdx);
      const newEndValue = newCollection[newEndIdx];
      if (ngDevMode) {
        recordDuplicateKeys(duplicateKeys, trackByFn(newEndIdx, newEndValue), newEndIdx);
      }
      const isEndMatching = valuesMatching(liveEndIdx, liveEndValue, newEndIdx, newEndValue, trackByFn);
      if (isEndMatching !== 0) {
        if (isEndMatching < 0) {
          liveCollection.updateValue(liveEndIdx, newEndValue);
        }
        liveEndIdx--;
        newEndIdx--;
        continue;
      }
      const liveStartKey = trackByFn(liveStartIdx, liveStartValue);
      const liveEndKey = trackByFn(liveEndIdx, liveEndValue);
      const newStartKey = trackByFn(liveStartIdx, newStartValue);
      if (Object.is(newStartKey, liveEndKey)) {
        const newEndKey = trackByFn(newEndIdx, newEndValue);
        if (Object.is(newEndKey, liveStartKey)) {
          liveCollection.swap(liveStartIdx, liveEndIdx);
          liveCollection.updateValue(liveEndIdx, newEndValue);
          newEndIdx--;
          liveEndIdx--;
        } else {
          liveCollection.move(liveEndIdx, liveStartIdx);
        }
        liveCollection.updateValue(liveStartIdx, newStartValue);
        liveStartIdx++;
        continue;
      }
      detachedItems ??= new UniqueValueMultiKeyMap();
      liveKeysInTheFuture ??= initLiveItemsInTheFuture(liveCollection, liveStartIdx, liveEndIdx, trackByFn);
      if (attachPreviouslyDetached(liveCollection, detachedItems, liveStartIdx, newStartKey)) {
        liveCollection.updateValue(liveStartIdx, newStartValue);
        liveStartIdx++;
        liveEndIdx++;
      } else if (!liveKeysInTheFuture.has(newStartKey)) {
        const newItem = liveCollection.create(liveStartIdx, newCollection[liveStartIdx]);
        liveCollection.attach(liveStartIdx, newItem);
        liveStartIdx++;
        liveEndIdx++;
      } else {
        detachedItems.set(liveStartKey, liveCollection.detach(liveStartIdx));
        liveEndIdx--;
      }
    }
    while (liveStartIdx <= newEndIdx) {
      createOrAttach(liveCollection, detachedItems, trackByFn, liveStartIdx, newCollection[liveStartIdx]);
      liveStartIdx++;
    }
  } else if (newCollection != null) {
    const newCollectionIterator = newCollection[Symbol.iterator]();
    let newIterationResult = newCollectionIterator.next();
    while (!newIterationResult.done && liveStartIdx <= liveEndIdx) {
      const liveValue = liveCollection.at(liveStartIdx);
      const newValue = newIterationResult.value;
      if (ngDevMode) {
        recordDuplicateKeys(duplicateKeys, trackByFn(liveStartIdx, newValue), liveStartIdx);
      }
      const isStartMatching = valuesMatching(liveStartIdx, liveValue, liveStartIdx, newValue, trackByFn);
      if (isStartMatching !== 0) {
        if (isStartMatching < 0) {
          liveCollection.updateValue(liveStartIdx, newValue);
        }
        liveStartIdx++;
        newIterationResult = newCollectionIterator.next();
      } else {
        detachedItems ??= new UniqueValueMultiKeyMap();
        liveKeysInTheFuture ??= initLiveItemsInTheFuture(liveCollection, liveStartIdx, liveEndIdx, trackByFn);
        const newKey = trackByFn(liveStartIdx, newValue);
        if (attachPreviouslyDetached(liveCollection, detachedItems, liveStartIdx, newKey)) {
          liveCollection.updateValue(liveStartIdx, newValue);
          liveStartIdx++;
          liveEndIdx++;
          newIterationResult = newCollectionIterator.next();
        } else if (!liveKeysInTheFuture.has(newKey)) {
          liveCollection.attach(liveStartIdx, liveCollection.create(liveStartIdx, newValue));
          liveStartIdx++;
          liveEndIdx++;
          newIterationResult = newCollectionIterator.next();
        } else {
          const liveKey = trackByFn(liveStartIdx, liveValue);
          detachedItems.set(liveKey, liveCollection.detach(liveStartIdx));
          liveEndIdx--;
        }
      }
    }
    while (!newIterationResult.done) {
      createOrAttach(liveCollection, detachedItems, trackByFn, liveCollection.length, newIterationResult.value);
      newIterationResult = newCollectionIterator.next();
    }
  }
  while (liveStartIdx <= liveEndIdx) {
    liveCollection.destroy(liveCollection.detach(liveEndIdx--));
  }
  detachedItems?.forEach((item) => {
    liveCollection.destroy(item);
  });
  if (ngDevMode) {
    let duplicatedKeysMsg = [];
    for (const [key, idxSet] of duplicateKeys) {
      if (idxSet.size > 1) {
        const idx = [...idxSet].sort((a, b) => a - b);
        for (let i = 1; i < idx.length; i++) {
          duplicatedKeysMsg.push(`key "${stringifyForError(key)}" at index "${idx[i - 1]}" and "${idx[i]}"`);
        }
      }
    }
    if (duplicatedKeysMsg.length > 0) {
      const message = formatRuntimeError(-955, "The provided track expression resulted in duplicated keys for a given collection. Adjust the tracking expression such that it uniquely identifies all the items in the collection. Duplicated keys were: \n" + duplicatedKeysMsg.join(", \n") + ".");
      console.warn(message);
    }
  }
}
function attachPreviouslyDetached(prevCollection, detachedItems, index, key) {
  if (detachedItems !== void 0 && detachedItems.has(key)) {
    prevCollection.attach(index, detachedItems.get(key));
    detachedItems.delete(key);
    return true;
  }
  return false;
}
function createOrAttach(liveCollection, detachedItems, trackByFn, index, value) {
  if (!attachPreviouslyDetached(liveCollection, detachedItems, index, trackByFn(index, value))) {
    const newItem = liveCollection.create(index, value);
    liveCollection.attach(index, newItem);
  } else {
    liveCollection.updateValue(index, value);
  }
}
function initLiveItemsInTheFuture(liveCollection, start, end, trackByFn) {
  const keys = /* @__PURE__ */ new Set();
  for (let i = start; i <= end; i++) {
    keys.add(trackByFn(i, liveCollection.at(i)));
  }
  return keys;
}
var UniqueValueMultiKeyMap = class {
  constructor() {
    this.kvMap = /* @__PURE__ */ new Map();
    this._vMap = void 0;
  }
  has(key) {
    return this.kvMap.has(key);
  }
  delete(key) {
    if (!this.has(key)) return false;
    const value = this.kvMap.get(key);
    if (this._vMap !== void 0 && this._vMap.has(value)) {
      this.kvMap.set(key, this._vMap.get(value));
      this._vMap.delete(value);
    } else {
      this.kvMap.delete(key);
    }
    return true;
  }
  get(key) {
    return this.kvMap.get(key);
  }
  set(key, value) {
    if (this.kvMap.has(key)) {
      let prevValue = this.kvMap.get(key);
      ngDevMode && assertNotSame(prevValue, value, `Detected a duplicated value ${value} for the key ${key}`);
      if (this._vMap === void 0) {
        this._vMap = /* @__PURE__ */ new Map();
      }
      const vMap = this._vMap;
      while (vMap.has(prevValue)) {
        prevValue = vMap.get(prevValue);
      }
      vMap.set(prevValue, value);
    } else {
      this.kvMap.set(key, value);
    }
  }
  forEach(cb) {
    for (let [key, value] of this.kvMap) {
      cb(value, key);
      if (this._vMap !== void 0) {
        const vMap = this._vMap;
        while (vMap.has(value)) {
          value = vMap.get(value);
          cb(value, key);
        }
      }
    }
  }
};
function ɵɵconditional(matchingTemplateIndex, contextValue) {
  performanceMarkFeature("NgControlFlow");
  const hostLView = getLView();
  const bindingIndex = nextBindingIndex();
  const prevMatchingTemplateIndex = hostLView[bindingIndex] !== NO_CHANGE ? hostLView[bindingIndex] : -1;
  const prevContainer = prevMatchingTemplateIndex !== -1 ? getLContainer(hostLView, HEADER_OFFSET + prevMatchingTemplateIndex) : void 0;
  const viewInContainerIdx = 0;
  if (bindingUpdated(hostLView, bindingIndex, matchingTemplateIndex)) {
    const prevConsumer = setActiveConsumer(null);
    try {
      if (prevContainer !== void 0) {
        removeLViewFromLContainer(prevContainer, viewInContainerIdx);
      }
      if (matchingTemplateIndex !== -1) {
        const nextLContainerIndex = HEADER_OFFSET + matchingTemplateIndex;
        const nextContainer = getLContainer(hostLView, nextLContainerIndex);
        const templateTNode = getExistingTNode(hostLView[TVIEW], nextLContainerIndex);
        const dehydratedView = findMatchingDehydratedView(nextContainer, templateTNode.tView.ssrId);
        const embeddedLView = createAndRenderEmbeddedLView(hostLView, templateTNode, contextValue, {
          dehydratedView
        });
        addLViewToLContainer(nextContainer, embeddedLView, viewInContainerIdx, shouldAddViewToDom(templateTNode, dehydratedView));
      }
    } finally {
      setActiveConsumer(prevConsumer);
    }
  } else if (prevContainer !== void 0) {
    const lView = getLViewFromLContainer(prevContainer, viewInContainerIdx);
    if (lView !== void 0) {
      lView[CONTEXT] = contextValue;
    }
  }
}
var RepeaterContext = class {
  constructor(lContainer, $implicit, $index) {
    this.lContainer = lContainer;
    this.$implicit = $implicit;
    this.$index = $index;
  }
  get $count() {
    return this.lContainer.length - CONTAINER_HEADER_OFFSET;
  }
};
function ɵɵrepeaterTrackByIndex(index) {
  return index;
}
function ɵɵrepeaterTrackByIdentity(_, value) {
  return value;
}
var RepeaterMetadata = class {
  constructor(hasEmptyBlock, trackByFn, liveCollection) {
    this.hasEmptyBlock = hasEmptyBlock;
    this.trackByFn = trackByFn;
    this.liveCollection = liveCollection;
  }
};
function ɵɵrepeaterCreate(index, templateFn, decls, vars, tagName, attrsIndex, trackByFn, trackByUsesComponentInstance, emptyTemplateFn, emptyDecls, emptyVars, emptyTagName, emptyAttrsIndex) {
  performanceMarkFeature("NgControlFlow");
  ngDevMode && assertFunction(trackByFn, `A track expression must be a function, was ${typeof trackByFn} instead.`);
  const lView = getLView();
  const tView = getTView();
  const hasEmptyBlock = emptyTemplateFn !== void 0;
  const hostLView = getLView();
  const boundTrackBy = trackByUsesComponentInstance ? (
    // We only want to bind when necessary, because it produces a
    // new function. For pure functions it's not necessary.
    trackByFn.bind(hostLView[DECLARATION_COMPONENT_VIEW][CONTEXT])
  ) : trackByFn;
  const metadata = new RepeaterMetadata(hasEmptyBlock, boundTrackBy);
  hostLView[HEADER_OFFSET + index] = metadata;
  declareTemplate(lView, tView, index + 1, templateFn, decls, vars, tagName, getConstant(tView.consts, attrsIndex));
  if (hasEmptyBlock) {
    ngDevMode && assertDefined(emptyDecls, "Missing number of declarations for the empty repeater block.");
    ngDevMode && assertDefined(emptyVars, "Missing number of bindings for the empty repeater block.");
    declareTemplate(lView, tView, index + 2, emptyTemplateFn, emptyDecls, emptyVars, emptyTagName, getConstant(tView.consts, emptyAttrsIndex));
  }
}
function isViewExpensiveToRecreate(lView) {
  return lView.length - HEADER_OFFSET > 2;
}
var OperationsCounter = class {
  constructor() {
    this.created = 0;
    this.destroyed = 0;
  }
  reset() {
    this.created = 0;
    this.destroyed = 0;
  }
  recordCreate() {
    this.created++;
  }
  recordDestroy() {
    this.destroyed++;
  }
  /**
   * A method indicating if the entire collection was re-created as part of the reconciliation pass.
   * Used to warn developers about the usage of a tracking function that might result in excessive
   * amount of view creation / destroy operations.
   *
   * @returns boolean value indicating if a live collection was re-created
   */
  wasReCreated(collectionLen) {
    return collectionLen > 0 && this.created === this.destroyed && this.created === collectionLen;
  }
};
var LiveCollectionLContainerImpl = class extends LiveCollection {
  constructor(lContainer, hostLView, templateTNode) {
    super();
    this.lContainer = lContainer;
    this.hostLView = hostLView;
    this.templateTNode = templateTNode;
    this.operationsCounter = ngDevMode ? new OperationsCounter() : void 0;
    this.needsIndexUpdate = false;
  }
  get length() {
    return this.lContainer.length - CONTAINER_HEADER_OFFSET;
  }
  at(index) {
    return this.getLView(index)[CONTEXT].$implicit;
  }
  attach(index, lView) {
    const dehydratedView = lView[HYDRATION];
    this.needsIndexUpdate ||= index !== this.length;
    addLViewToLContainer(this.lContainer, lView, index, shouldAddViewToDom(this.templateTNode, dehydratedView));
  }
  detach(index) {
    this.needsIndexUpdate ||= index !== this.length - 1;
    return detachExistingView(this.lContainer, index);
  }
  create(index, value) {
    const dehydratedView = findMatchingDehydratedView(this.lContainer, this.templateTNode.tView.ssrId);
    const embeddedLView = createAndRenderEmbeddedLView(this.hostLView, this.templateTNode, new RepeaterContext(this.lContainer, value, index), {
      dehydratedView
    });
    this.operationsCounter?.recordCreate();
    return embeddedLView;
  }
  destroy(lView) {
    destroyLView(lView[TVIEW], lView);
    this.operationsCounter?.recordDestroy();
  }
  updateValue(index, value) {
    this.getLView(index)[CONTEXT].$implicit = value;
  }
  reset() {
    this.needsIndexUpdate = false;
    this.operationsCounter?.reset();
  }
  updateIndexes() {
    if (this.needsIndexUpdate) {
      for (let i = 0; i < this.length; i++) {
        this.getLView(i)[CONTEXT].$index = i;
      }
    }
  }
  getLView(index) {
    return getExistingLViewFromLContainer(this.lContainer, index);
  }
};
function ɵɵrepeater(collection) {
  const prevConsumer = setActiveConsumer(null);
  const metadataSlotIdx = getSelectedIndex();
  try {
    const hostLView = getLView();
    const hostTView = hostLView[TVIEW];
    const metadata = hostLView[metadataSlotIdx];
    const containerIndex = metadataSlotIdx + 1;
    const lContainer = getLContainer(hostLView, containerIndex);
    if (metadata.liveCollection === void 0) {
      const itemTemplateTNode = getExistingTNode(hostTView, containerIndex);
      metadata.liveCollection = new LiveCollectionLContainerImpl(lContainer, hostLView, itemTemplateTNode);
    } else {
      metadata.liveCollection.reset();
    }
    const liveCollection = metadata.liveCollection;
    reconcile(liveCollection, collection, metadata.trackByFn);
    if (ngDevMode && metadata.trackByFn === ɵɵrepeaterTrackByIdentity && liveCollection.operationsCounter?.wasReCreated(liveCollection.length) && isViewExpensiveToRecreate(getExistingLViewFromLContainer(lContainer, 0))) {
      const message = formatRuntimeError(-956, `The configured tracking expression (track by identity) caused re-creation of the entire collection of size ${liveCollection.length}. This is an expensive operation requiring destruction and subsequent creation of DOM nodes, directives, components etc. Please review the "track expression" and make sure that it uniquely identifies items in a collection.`);
      console.warn(message);
    }
    liveCollection.updateIndexes();
    if (metadata.hasEmptyBlock) {
      const bindingIndex = nextBindingIndex();
      const isCollectionEmpty = liveCollection.length === 0;
      if (bindingUpdated(hostLView, bindingIndex, isCollectionEmpty)) {
        const emptyTemplateIndex = metadataSlotIdx + 2;
        const lContainerForEmpty = getLContainer(hostLView, emptyTemplateIndex);
        if (isCollectionEmpty) {
          const emptyTemplateTNode = getExistingTNode(hostTView, emptyTemplateIndex);
          const dehydratedView = findMatchingDehydratedView(lContainerForEmpty, emptyTemplateTNode.tView.ssrId);
          const embeddedLView = createAndRenderEmbeddedLView(hostLView, emptyTemplateTNode, void 0, {
            dehydratedView
          });
          addLViewToLContainer(lContainerForEmpty, embeddedLView, 0, shouldAddViewToDom(emptyTemplateTNode, dehydratedView));
        } else {
          removeLViewFromLContainer(lContainerForEmpty, 0);
        }
      }
    }
  } finally {
    setActiveConsumer(prevConsumer);
  }
}
function getLContainer(lView, index) {
  const lContainer = lView[index];
  ngDevMode && assertLContainer(lContainer);
  return lContainer;
}
function detachExistingView(lContainer, index) {
  const existingLView = detachView(lContainer, index);
  ngDevMode && assertLView(existingLView);
  return existingLView;
}
function getExistingLViewFromLContainer(lContainer, index) {
  const existingLView = getLViewFromLContainer(lContainer, index);
  ngDevMode && assertLView(existingLView);
  return existingLView;
}
function getExistingTNode(tView, index) {
  const tNode = getTNode(tView, index);
  ngDevMode && assertTNode(tNode);
  return tNode;
}
function elementStartFirstCreatePass(index, tView, lView, name, attrsIndex, localRefsIndex) {
  ngDevMode && assertFirstCreatePass(tView);
  ngDevMode && ngDevMode.firstCreatePass++;
  const tViewConsts = tView.consts;
  const attrs = getConstant(tViewConsts, attrsIndex);
  const tNode = getOrCreateTNode(tView, index, 2, name, attrs);
  resolveDirectives(tView, lView, tNode, getConstant(tViewConsts, localRefsIndex));
  if (tNode.attrs !== null) {
    computeStaticStyling(tNode, tNode.attrs, false);
  }
  if (tNode.mergedAttrs !== null) {
    computeStaticStyling(tNode, tNode.mergedAttrs, true);
  }
  if (tView.queries !== null) {
    tView.queries.elementStart(tView, tNode);
  }
  return tNode;
}
function ɵɵelementStart(index, name, attrsIndex, localRefsIndex) {
  const lView = getLView();
  const tView = getTView();
  const adjustedIndex = HEADER_OFFSET + index;
  ngDevMode && assertEqual(getBindingIndex(), tView.bindingStartIndex, "elements should be created before any bindings");
  ngDevMode && assertIndexInRange(lView, adjustedIndex);
  const renderer = lView[RENDERER];
  const tNode = tView.firstCreatePass ? elementStartFirstCreatePass(adjustedIndex, tView, lView, name, attrsIndex, localRefsIndex) : tView.data[adjustedIndex];
  const native = _locateOrCreateElementNode(tView, lView, tNode, renderer, name, index);
  lView[adjustedIndex] = native;
  const hasDirectives = isDirectiveHost(tNode);
  if (ngDevMode && tView.firstCreatePass) {
    validateElementIsKnown(native, lView, tNode.value, tView.schemas, hasDirectives);
  }
  setCurrentTNode(tNode, true);
  setupStaticAttributes(renderer, native, tNode);
  if (!isDetachedByI18n(tNode) && wasLastNodeCreated()) {
    appendChild(tView, lView, native, tNode);
  }
  if (getElementDepthCount() === 0) {
    attachPatchData(native, lView);
  }
  increaseElementDepthCount();
  if (hasDirectives) {
    createDirectivesInstances(tView, lView, tNode);
    executeContentQueries(tView, tNode, lView);
  }
  if (localRefsIndex !== null) {
    saveResolvedLocalsInData(lView, tNode);
  }
  return ɵɵelementStart;
}
function ɵɵelementEnd() {
  let currentTNode = getCurrentTNode();
  ngDevMode && assertDefined(currentTNode, "No parent node to close.");
  if (isCurrentTNodeParent()) {
    setCurrentTNodeAsNotParent();
  } else {
    ngDevMode && assertHasParent(getCurrentTNode());
    currentTNode = currentTNode.parent;
    setCurrentTNode(currentTNode, false);
  }
  const tNode = currentTNode;
  ngDevMode && assertTNodeType(
    tNode,
    3
    /* TNodeType.AnyRNode */
  );
  if (isSkipHydrationRootTNode(tNode)) {
    leaveSkipHydrationBlock();
  }
  decreaseElementDepthCount();
  const tView = getTView();
  if (tView.firstCreatePass) {
    registerPostOrderHooks(tView, currentTNode);
    if (isContentQueryHost(currentTNode)) {
      tView.queries.elementEnd(currentTNode);
    }
  }
  if (tNode.classesWithoutHost != null && hasClassInput(tNode)) {
    setDirectiveInputsWhichShadowsStyling(tView, tNode, getLView(), tNode.classesWithoutHost, true);
  }
  if (tNode.stylesWithoutHost != null && hasStyleInput(tNode)) {
    setDirectiveInputsWhichShadowsStyling(tView, tNode, getLView(), tNode.stylesWithoutHost, false);
  }
  return ɵɵelementEnd;
}
function ɵɵelement(index, name, attrsIndex, localRefsIndex) {
  ɵɵelementStart(index, name, attrsIndex, localRefsIndex);
  ɵɵelementEnd();
  return ɵɵelement;
}
var _locateOrCreateElementNode = (tView, lView, tNode, renderer, name, index) => {
  lastNodeWasCreated(true);
  return createElementNode(renderer, name, getNamespace$1());
};
function locateOrCreateElementNodeImpl(tView, lView, tNode, renderer, name, index) {
  const hydrationInfo = lView[HYDRATION];
  const isNodeCreationMode = !hydrationInfo || isInSkipHydrationBlock$1() || isDetachedByI18n(tNode) || isDisconnectedNode$1(hydrationInfo, index);
  lastNodeWasCreated(isNodeCreationMode);
  if (isNodeCreationMode) {
    return createElementNode(renderer, name, getNamespace$1());
  }
  const native = locateNextRNode(hydrationInfo, tView, lView, tNode);
  ngDevMode && validateMatchingNode(native, Node.ELEMENT_NODE, name, lView, tNode);
  ngDevMode && markRNodeAsClaimedByHydration(native);
  if (getSerializedContainerViews(hydrationInfo, index)) {
    ngDevMode && validateNodeExists(native.nextSibling, lView, tNode);
    setSegmentHead(hydrationInfo, index, native.nextSibling);
  }
  if (hydrationInfo && (hasSkipHydrationAttrOnTNode(tNode) || hasSkipHydrationAttrOnRElement(native))) {
    if (isComponentHost(tNode)) {
      enterSkipHydrationBlock(tNode);
      clearElementContents(native);
      ngDevMode && markRNodeAsSkippedByHydration(native);
    } else if (ngDevMode) {
      throw invalidSkipHydrationHost(native);
    }
  }
  return native;
}
function enableLocateOrCreateElementNodeImpl() {
  _locateOrCreateElementNode = locateOrCreateElementNodeImpl;
}
function elementContainerStartFirstCreatePass(index, tView, lView, attrsIndex, localRefsIndex) {
  ngDevMode && ngDevMode.firstCreatePass++;
  const tViewConsts = tView.consts;
  const attrs = getConstant(tViewConsts, attrsIndex);
  const tNode = getOrCreateTNode(tView, index, 8, "ng-container", attrs);
  if (attrs !== null) {
    computeStaticStyling(tNode, attrs, true);
  }
  const localRefs = getConstant(tViewConsts, localRefsIndex);
  resolveDirectives(tView, lView, tNode, localRefs);
  if (tView.queries !== null) {
    tView.queries.elementStart(tView, tNode);
  }
  return tNode;
}
function ɵɵelementContainerStart(index, attrsIndex, localRefsIndex) {
  const lView = getLView();
  const tView = getTView();
  const adjustedIndex = index + HEADER_OFFSET;
  ngDevMode && assertIndexInRange(lView, adjustedIndex);
  ngDevMode && assertEqual(getBindingIndex(), tView.bindingStartIndex, "element containers should be created before any bindings");
  const tNode = tView.firstCreatePass ? elementContainerStartFirstCreatePass(adjustedIndex, tView, lView, attrsIndex, localRefsIndex) : tView.data[adjustedIndex];
  setCurrentTNode(tNode, true);
  const comment = _locateOrCreateElementContainerNode(tView, lView, tNode, index);
  lView[adjustedIndex] = comment;
  if (wasLastNodeCreated()) {
    appendChild(tView, lView, comment, tNode);
  }
  attachPatchData(comment, lView);
  if (isDirectiveHost(tNode)) {
    createDirectivesInstances(tView, lView, tNode);
    executeContentQueries(tView, tNode, lView);
  }
  if (localRefsIndex != null) {
    saveResolvedLocalsInData(lView, tNode);
  }
  return ɵɵelementContainerStart;
}
function ɵɵelementContainerEnd() {
  let currentTNode = getCurrentTNode();
  const tView = getTView();
  if (isCurrentTNodeParent()) {
    setCurrentTNodeAsNotParent();
  } else {
    ngDevMode && assertHasParent(currentTNode);
    currentTNode = currentTNode.parent;
    setCurrentTNode(currentTNode, false);
  }
  ngDevMode && assertTNodeType(
    currentTNode,
    8
    /* TNodeType.ElementContainer */
  );
  if (tView.firstCreatePass) {
    registerPostOrderHooks(tView, currentTNode);
    if (isContentQueryHost(currentTNode)) {
      tView.queries.elementEnd(currentTNode);
    }
  }
  return ɵɵelementContainerEnd;
}
function ɵɵelementContainer(index, attrsIndex, localRefsIndex) {
  ɵɵelementContainerStart(index, attrsIndex, localRefsIndex);
  ɵɵelementContainerEnd();
  return ɵɵelementContainer;
}
var _locateOrCreateElementContainerNode = (tView, lView, tNode, index) => {
  lastNodeWasCreated(true);
  return createCommentNode(lView[RENDERER], ngDevMode ? "ng-container" : "");
};
function locateOrCreateElementContainerNode(tView, lView, tNode, index) {
  let comment;
  const hydrationInfo = lView[HYDRATION];
  const isNodeCreationMode = !hydrationInfo || isInSkipHydrationBlock$1() || isDisconnectedNode$1(hydrationInfo, index) || isDetachedByI18n(tNode);
  lastNodeWasCreated(isNodeCreationMode);
  if (isNodeCreationMode) {
    return createCommentNode(lView[RENDERER], ngDevMode ? "ng-container" : "");
  }
  const currentRNode = locateNextRNode(hydrationInfo, tView, lView, tNode);
  ngDevMode && validateNodeExists(currentRNode, lView, tNode);
  const ngContainerSize = getNgContainerSize(hydrationInfo, index);
  ngDevMode && assertNumber(ngContainerSize, "Unexpected state: hydrating an <ng-container>, but no hydration info is available.");
  setSegmentHead(hydrationInfo, index, currentRNode);
  comment = siblingAfter(ngContainerSize, currentRNode);
  if (ngDevMode) {
    validateMatchingNode(comment, Node.COMMENT_NODE, null, lView, tNode);
    markRNodeAsClaimedByHydration(comment);
  }
  return comment;
}
function enableLocateOrCreateElementContainerNodeImpl() {
  _locateOrCreateElementContainerNode = locateOrCreateElementContainerNode;
}
function ɵɵgetCurrentView() {
  return getLView();
}
function ɵɵhostProperty(propName, value, sanitizer) {
  const lView = getLView();
  const bindingIndex = nextBindingIndex();
  if (bindingUpdated(lView, bindingIndex, value)) {
    const tView = getTView();
    const tNode = getSelectedTNode();
    elementPropertyInternal(tView, tNode, lView, propName, value, lView[RENDERER], sanitizer, true);
    ngDevMode && storePropertyBindingMetadata(tView.data, tNode, propName, bindingIndex);
  }
  return ɵɵhostProperty;
}
function ɵɵsyntheticHostProperty(propName, value, sanitizer) {
  const lView = getLView();
  const bindingIndex = nextBindingIndex();
  if (bindingUpdated(lView, bindingIndex, value)) {
    const tView = getTView();
    const tNode = getSelectedTNode();
    const currentDef = getCurrentDirectiveDef(tView.data);
    const renderer = loadComponentRenderer(currentDef, tNode, lView);
    elementPropertyInternal(tView, tNode, lView, propName, value, renderer, sanitizer, true);
    ngDevMode && storePropertyBindingMetadata(tView.data, tNode, propName, bindingIndex);
  }
  return ɵɵsyntheticHostProperty;
}
if (typeof ngI18nClosureMode === "undefined") {
  (function() {
    _global["ngI18nClosureMode"] = // TODO(FW-1250): validate that this actually, you know, works.
    // tslint:disable-next-line:no-toplevel-property-access
    typeof goog !== "undefined" && typeof goog.getMsg === "function";
  })();
}
var u = void 0;
function plural(val) {
  const n = val, i = Math.floor(Math.abs(val)), v = val.toString().replace(/^[^.]*\.?/, "").length;
  if (i === 1 && v === 0) return 1;
  return 5;
}
var localeEn = ["en", [["a", "p"], ["AM", "PM"], u], [["AM", "PM"], u, u], [["S", "M", "T", "W", "T", "F", "S"], ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"], ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"], ["Su", "Mo", "Tu", "We", "Th", "Fr", "Sa"]], u, [["J", "F", "M", "A", "M", "J", "J", "A", "S", "O", "N", "D"], ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"], ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"]], u, [["B", "A"], ["BC", "AD"], ["Before Christ", "Anno Domini"]], 0, [6, 0], ["M/d/yy", "MMM d, y", "MMMM d, y", "EEEE, MMMM d, y"], ["h:mm a", "h:mm:ss a", "h:mm:ss a z", "h:mm:ss a zzzz"], ["{1}, {0}", u, "{1} 'at' {0}", u], [".", ",", ";", "%", "+", "-", "E", "×", "‰", "∞", "NaN", ":"], ["#,##0.###", "#,##0%", "¤#,##0.00", "#E0"], "USD", "$", "US Dollar", {}, "ltr", plural];
var LOCALE_DATA = {};
function registerLocaleData(data, localeId, extraData) {
  if (typeof localeId !== "string") {
    extraData = localeId;
    localeId = data[LocaleDataIndex.LocaleId];
  }
  localeId = localeId.toLowerCase().replace(/_/g, "-");
  LOCALE_DATA[localeId] = data;
  if (extraData) {
    LOCALE_DATA[localeId][LocaleDataIndex.ExtraData] = extraData;
  }
}
function findLocaleData(locale) {
  const normalizedLocale = normalizeLocale(locale);
  let match = getLocaleData(normalizedLocale);
  if (match) {
    return match;
  }
  const parentLocale = normalizedLocale.split("-")[0];
  match = getLocaleData(parentLocale);
  if (match) {
    return match;
  }
  if (parentLocale === "en") {
    return localeEn;
  }
  throw new RuntimeError(701, ngDevMode && `Missing locale data for the locale "${locale}".`);
}
function getLocaleCurrencyCode(locale) {
  const data = findLocaleData(locale);
  return data[LocaleDataIndex.CurrencyCode] || null;
}
function getLocalePluralCase(locale) {
  const data = findLocaleData(locale);
  return data[LocaleDataIndex.PluralCase];
}
function getLocaleData(normalizedLocale) {
  if (!(normalizedLocale in LOCALE_DATA)) {
    LOCALE_DATA[normalizedLocale] = _global.ng && _global.ng.common && _global.ng.common.locales && _global.ng.common.locales[normalizedLocale];
  }
  return LOCALE_DATA[normalizedLocale];
}
function unregisterAllLocaleData() {
  LOCALE_DATA = {};
}
var LocaleDataIndex;
(function(LocaleDataIndex2) {
  LocaleDataIndex2[LocaleDataIndex2["LocaleId"] = 0] = "LocaleId";
  LocaleDataIndex2[LocaleDataIndex2["DayPeriodsFormat"] = 1] = "DayPeriodsFormat";
  LocaleDataIndex2[LocaleDataIndex2["DayPeriodsStandalone"] = 2] = "DayPeriodsStandalone";
  LocaleDataIndex2[LocaleDataIndex2["DaysFormat"] = 3] = "DaysFormat";
  LocaleDataIndex2[LocaleDataIndex2["DaysStandalone"] = 4] = "DaysStandalone";
  LocaleDataIndex2[LocaleDataIndex2["MonthsFormat"] = 5] = "MonthsFormat";
  LocaleDataIndex2[LocaleDataIndex2["MonthsStandalone"] = 6] = "MonthsStandalone";
  LocaleDataIndex2[LocaleDataIndex2["Eras"] = 7] = "Eras";
  LocaleDataIndex2[LocaleDataIndex2["FirstDayOfWeek"] = 8] = "FirstDayOfWeek";
  LocaleDataIndex2[LocaleDataIndex2["WeekendRange"] = 9] = "WeekendRange";
  LocaleDataIndex2[LocaleDataIndex2["DateFormat"] = 10] = "DateFormat";
  LocaleDataIndex2[LocaleDataIndex2["TimeFormat"] = 11] = "TimeFormat";
  LocaleDataIndex2[LocaleDataIndex2["DateTimeFormat"] = 12] = "DateTimeFormat";
  LocaleDataIndex2[LocaleDataIndex2["NumberSymbols"] = 13] = "NumberSymbols";
  LocaleDataIndex2[LocaleDataIndex2["NumberFormats"] = 14] = "NumberFormats";
  LocaleDataIndex2[LocaleDataIndex2["CurrencyCode"] = 15] = "CurrencyCode";
  LocaleDataIndex2[LocaleDataIndex2["CurrencySymbol"] = 16] = "CurrencySymbol";
  LocaleDataIndex2[LocaleDataIndex2["CurrencyName"] = 17] = "CurrencyName";
  LocaleDataIndex2[LocaleDataIndex2["Currencies"] = 18] = "Currencies";
  LocaleDataIndex2[LocaleDataIndex2["Directionality"] = 19] = "Directionality";
  LocaleDataIndex2[LocaleDataIndex2["PluralCase"] = 20] = "PluralCase";
  LocaleDataIndex2[LocaleDataIndex2["ExtraData"] = 21] = "ExtraData";
})(LocaleDataIndex || (LocaleDataIndex = {}));
function normalizeLocale(locale) {
  return locale.toLowerCase().replace(/_/g, "-");
}
var pluralMapping = ["zero", "one", "two", "few", "many"];
function getPluralCase(value, locale) {
  const plural2 = getLocalePluralCase(locale)(parseInt(value, 10));
  const result = pluralMapping[plural2];
  return result !== void 0 ? result : "other";
}
var DEFAULT_LOCALE_ID = "en-US";
var USD_CURRENCY_CODE = "USD";
var ELEMENT_MARKER = {
  marker: "element"
};
var ICU_MARKER = {
  marker: "ICU"
};
var I18nCreateOpCode;
(function(I18nCreateOpCode2) {
  I18nCreateOpCode2[I18nCreateOpCode2["SHIFT"] = 2] = "SHIFT";
  I18nCreateOpCode2[I18nCreateOpCode2["APPEND_EAGERLY"] = 1] = "APPEND_EAGERLY";
  I18nCreateOpCode2[I18nCreateOpCode2["COMMENT"] = 2] = "COMMENT";
})(I18nCreateOpCode || (I18nCreateOpCode = {}));
var LOCALE_ID$1 = DEFAULT_LOCALE_ID;
function setLocaleId(localeId) {
  ngDevMode && assertDefined(localeId, `Expected localeId to be defined`);
  if (typeof localeId === "string") {
    LOCALE_ID$1 = localeId.toLowerCase().replace(/_/g, "-");
  }
}
function getLocaleId() {
  return LOCALE_ID$1;
}
var changeMask = 0;
var changeMaskCounter = 0;
function setMaskBit(hasChange) {
  if (hasChange) {
    changeMask = changeMask | 1 << Math.min(changeMaskCounter, 31);
  }
  changeMaskCounter++;
}
function applyI18n(tView, lView, index) {
  if (changeMaskCounter > 0) {
    ngDevMode && assertDefined(tView, `tView should be defined`);
    const tI18n = tView.data[index];
    const updateOpCodes = Array.isArray(tI18n) ? tI18n : tI18n.update;
    const bindingsStartIndex = getBindingIndex() - changeMaskCounter - 1;
    applyUpdateOpCodes(tView, lView, updateOpCodes, bindingsStartIndex, changeMask);
  }
  changeMask = 0;
  changeMaskCounter = 0;
}
function createNodeWithoutHydration(lView, textOrName, nodeType) {
  const renderer = lView[RENDERER];
  switch (nodeType) {
    case Node.COMMENT_NODE:
      return createCommentNode(renderer, textOrName);
    case Node.TEXT_NODE:
      return createTextNode(renderer, textOrName);
    case Node.ELEMENT_NODE:
      return createElementNode(renderer, textOrName, null);
  }
}
var _locateOrCreateNode = (lView, index, textOrName, nodeType) => {
  lastNodeWasCreated(true);
  return createNodeWithoutHydration(lView, textOrName, nodeType);
};
function locateOrCreateNodeImpl(lView, index, textOrName, nodeType) {
  const hydrationInfo = lView[HYDRATION];
  const noOffsetIndex = index - HEADER_OFFSET;
  const isNodeCreationMode = !isI18nHydrationSupportEnabled() || !hydrationInfo || isInSkipHydrationBlock$1() || isDisconnectedNode$1(hydrationInfo, noOffsetIndex);
  lastNodeWasCreated(isNodeCreationMode);
  if (isNodeCreationMode) {
    return createNodeWithoutHydration(lView, textOrName, nodeType);
  }
  const native = locateI18nRNodeByIndex(hydrationInfo, noOffsetIndex);
  ngDevMode && assertDefined(native, "expected native element");
  ngDevMode && assertEqual(native.nodeType, nodeType, "expected matching nodeType");
  ngDevMode && nodeType === Node.ELEMENT_NODE && assertEqual(native.tagName.toLowerCase(), textOrName.toLowerCase(), "expecting matching tagName");
  ngDevMode && markRNodeAsClaimedByHydration(native);
  return native;
}
function enableLocateOrCreateI18nNodeImpl() {
  _locateOrCreateNode = locateOrCreateNodeImpl;
}
function applyCreateOpCodes(lView, createOpCodes, parentRNode, insertInFrontOf) {
  const renderer = lView[RENDERER];
  for (let i = 0; i < createOpCodes.length; i++) {
    const opCode = createOpCodes[i++];
    const text = createOpCodes[i];
    const isComment = (opCode & I18nCreateOpCode.COMMENT) === I18nCreateOpCode.COMMENT;
    const appendNow = (opCode & I18nCreateOpCode.APPEND_EAGERLY) === I18nCreateOpCode.APPEND_EAGERLY;
    const index = opCode >>> I18nCreateOpCode.SHIFT;
    let rNode = lView[index];
    let lastNodeWasCreated2 = false;
    if (rNode === null) {
      rNode = lView[index] = _locateOrCreateNode(lView, index, text, isComment ? Node.COMMENT_NODE : Node.TEXT_NODE);
      lastNodeWasCreated2 = wasLastNodeCreated();
    }
    if (appendNow && parentRNode !== null && lastNodeWasCreated2) {
      nativeInsertBefore(renderer, parentRNode, rNode, insertInFrontOf, false);
    }
  }
}
function applyMutableOpCodes(tView, mutableOpCodes, lView, anchorRNode) {
  ngDevMode && assertDomNode(anchorRNode);
  const renderer = lView[RENDERER];
  let rootIdx = null;
  let rootRNode;
  for (let i = 0; i < mutableOpCodes.length; i++) {
    const opCode = mutableOpCodes[i];
    if (typeof opCode == "string") {
      const textNodeIndex = mutableOpCodes[++i];
      if (lView[textNodeIndex] === null) {
        ngDevMode && ngDevMode.rendererCreateTextNode++;
        ngDevMode && assertIndexInRange(lView, textNodeIndex);
        lView[textNodeIndex] = _locateOrCreateNode(lView, textNodeIndex, opCode, Node.TEXT_NODE);
      }
    } else if (typeof opCode == "number") {
      switch (opCode & 1) {
        case 0:
          const parentIdx = getParentFromIcuCreateOpCode(opCode);
          if (rootIdx === null) {
            rootIdx = parentIdx;
            rootRNode = nativeParentNode(renderer, anchorRNode);
          }
          let insertInFrontOf;
          let parentRNode;
          if (parentIdx === rootIdx) {
            insertInFrontOf = anchorRNode;
            parentRNode = rootRNode;
          } else {
            insertInFrontOf = null;
            parentRNode = unwrapRNode(lView[parentIdx]);
          }
          if (parentRNode !== null) {
            ngDevMode && assertDomNode(parentRNode);
            const refIdx = getRefFromIcuCreateOpCode(opCode);
            ngDevMode && assertGreaterThan(refIdx, HEADER_OFFSET, "Missing ref");
            const child = lView[refIdx];
            ngDevMode && assertDomNode(child);
            nativeInsertBefore(renderer, parentRNode, child, insertInFrontOf, false);
            const tIcu = getTIcu(tView, refIdx);
            if (tIcu !== null && typeof tIcu === "object") {
              ngDevMode && assertTIcu(tIcu);
              const caseIndex = getCurrentICUCaseIndex(tIcu, lView);
              if (caseIndex !== null) {
                applyMutableOpCodes(tView, tIcu.create[caseIndex], lView, lView[tIcu.anchorIdx]);
              }
            }
          }
          break;
        case 1:
          const elementNodeIndex = opCode >>> 1;
          const attrName = mutableOpCodes[++i];
          const attrValue = mutableOpCodes[++i];
          setElementAttribute(renderer, getNativeByIndex(elementNodeIndex, lView), null, null, attrName, attrValue, null);
          break;
        default:
          if (ngDevMode) {
            throw new RuntimeError(700, `Unable to determine the type of mutate operation for "${opCode}"`);
          }
      }
    } else {
      switch (opCode) {
        case ICU_MARKER:
          const commentValue = mutableOpCodes[++i];
          const commentNodeIndex = mutableOpCodes[++i];
          if (lView[commentNodeIndex] === null) {
            ngDevMode && assertEqual(typeof commentValue, "string", `Expected "${commentValue}" to be a comment node value`);
            ngDevMode && ngDevMode.rendererCreateComment++;
            ngDevMode && assertIndexInExpandoRange(lView, commentNodeIndex);
            const commentRNode = lView[commentNodeIndex] = _locateOrCreateNode(lView, commentNodeIndex, commentValue, Node.COMMENT_NODE);
            attachPatchData(commentRNode, lView);
          }
          break;
        case ELEMENT_MARKER:
          const tagName = mutableOpCodes[++i];
          const elementNodeIndex = mutableOpCodes[++i];
          if (lView[elementNodeIndex] === null) {
            ngDevMode && assertEqual(typeof tagName, "string", `Expected "${tagName}" to be an element node tag name`);
            ngDevMode && ngDevMode.rendererCreateElement++;
            ngDevMode && assertIndexInExpandoRange(lView, elementNodeIndex);
            const elementRNode = lView[elementNodeIndex] = _locateOrCreateNode(lView, elementNodeIndex, tagName, Node.ELEMENT_NODE);
            attachPatchData(elementRNode, lView);
          }
          break;
        default:
          ngDevMode && throwError(`Unable to determine the type of mutate operation for "${opCode}"`);
      }
    }
  }
}
function applyUpdateOpCodes(tView, lView, updateOpCodes, bindingsStartIndex, changeMask2) {
  for (let i = 0; i < updateOpCodes.length; i++) {
    const checkBit = updateOpCodes[i];
    const skipCodes = updateOpCodes[++i];
    if (checkBit & changeMask2) {
      let value = "";
      for (let j = i + 1; j <= i + skipCodes; j++) {
        const opCode = updateOpCodes[j];
        if (typeof opCode == "string") {
          value += opCode;
        } else if (typeof opCode == "number") {
          if (opCode < 0) {
            value += renderStringify(lView[bindingsStartIndex - opCode]);
          } else {
            const nodeIndex = opCode >>> 2;
            switch (opCode & 3) {
              case 1:
                const propName = updateOpCodes[++j];
                const sanitizeFn = updateOpCodes[++j];
                const tNodeOrTagName = tView.data[nodeIndex];
                ngDevMode && assertDefined(tNodeOrTagName, "Experting TNode or string");
                if (typeof tNodeOrTagName === "string") {
                  setElementAttribute(lView[RENDERER], lView[nodeIndex], null, tNodeOrTagName, propName, value, sanitizeFn);
                } else {
                  elementPropertyInternal(tView, tNodeOrTagName, lView, propName, value, lView[RENDERER], sanitizeFn, false);
                }
                break;
              case 0:
                const rText = lView[nodeIndex];
                rText !== null && updateTextNode(lView[RENDERER], rText, value);
                break;
              case 2:
                applyIcuSwitchCase(tView, getTIcu(tView, nodeIndex), lView, value);
                break;
              case 3:
                applyIcuUpdateCase(tView, getTIcu(tView, nodeIndex), bindingsStartIndex, lView);
                break;
            }
          }
        }
      }
    } else {
      const opCode = updateOpCodes[i + 1];
      if (opCode > 0 && (opCode & 3) === 3) {
        const nodeIndex = opCode >>> 2;
        const tIcu = getTIcu(tView, nodeIndex);
        const currentIndex = lView[tIcu.currentCaseLViewIndex];
        if (currentIndex < 0) {
          applyIcuUpdateCase(tView, tIcu, bindingsStartIndex, lView);
        }
      }
    }
    i += skipCodes;
  }
}
function applyIcuUpdateCase(tView, tIcu, bindingsStartIndex, lView) {
  ngDevMode && assertIndexInRange(lView, tIcu.currentCaseLViewIndex);
  let activeCaseIndex = lView[tIcu.currentCaseLViewIndex];
  if (activeCaseIndex !== null) {
    let mask = changeMask;
    if (activeCaseIndex < 0) {
      activeCaseIndex = lView[tIcu.currentCaseLViewIndex] = ~activeCaseIndex;
      mask = -1;
    }
    applyUpdateOpCodes(tView, lView, tIcu.update[activeCaseIndex], bindingsStartIndex, mask);
  }
}
function applyIcuSwitchCase(tView, tIcu, lView, value) {
  const caseIndex = getCaseIndex(tIcu, value);
  let activeCaseIndex = getCurrentICUCaseIndex(tIcu, lView);
  if (activeCaseIndex !== caseIndex) {
    applyIcuSwitchCaseRemove(tView, tIcu, lView);
    lView[tIcu.currentCaseLViewIndex] = caseIndex === null ? null : ~caseIndex;
    if (caseIndex !== null) {
      const anchorRNode = lView[tIcu.anchorIdx];
      if (anchorRNode) {
        ngDevMode && assertDomNode(anchorRNode);
        applyMutableOpCodes(tView, tIcu.create[caseIndex], lView, anchorRNode);
      }
      claimDehydratedIcuCase(lView, tIcu.anchorIdx, caseIndex);
    }
  }
}
function applyIcuSwitchCaseRemove(tView, tIcu, lView) {
  let activeCaseIndex = getCurrentICUCaseIndex(tIcu, lView);
  if (activeCaseIndex !== null) {
    const removeCodes = tIcu.remove[activeCaseIndex];
    for (let i = 0; i < removeCodes.length; i++) {
      const nodeOrIcuIndex = removeCodes[i];
      if (nodeOrIcuIndex > 0) {
        const rNode = getNativeByIndex(nodeOrIcuIndex, lView);
        rNode !== null && nativeRemoveNode(lView[RENDERER], rNode);
      } else {
        applyIcuSwitchCaseRemove(tView, getTIcu(tView, ~nodeOrIcuIndex), lView);
      }
    }
  }
}
function getCaseIndex(icuExpression, bindingValue) {
  let index = icuExpression.cases.indexOf(bindingValue);
  if (index === -1) {
    switch (icuExpression.type) {
      case 1: {
        const resolvedCase = getPluralCase(bindingValue, getLocaleId());
        index = icuExpression.cases.indexOf(resolvedCase);
        if (index === -1 && resolvedCase !== "other") {
          index = icuExpression.cases.indexOf("other");
        }
        break;
      }
      case 0: {
        index = icuExpression.cases.indexOf("other");
        break;
      }
    }
  }
  return index === -1 ? null : index;
}
function i18nCreateOpCodesToString(opcodes) {
  const createOpCodes = opcodes || (Array.isArray(this) ? this : []);
  let lines = [];
  for (let i = 0; i < createOpCodes.length; i++) {
    const opCode = createOpCodes[i++];
    const text = createOpCodes[i];
    const isComment = (opCode & I18nCreateOpCode.COMMENT) === I18nCreateOpCode.COMMENT;
    const appendNow = (opCode & I18nCreateOpCode.APPEND_EAGERLY) === I18nCreateOpCode.APPEND_EAGERLY;
    const index = opCode >>> I18nCreateOpCode.SHIFT;
    lines.push(`lView[${index}] = document.${isComment ? "createComment" : "createText"}(${JSON.stringify(text)});`);
    if (appendNow) {
      lines.push(`parent.appendChild(lView[${index}]);`);
    }
  }
  return lines;
}
function i18nUpdateOpCodesToString(opcodes) {
  const parser = new OpCodeParser(opcodes || (Array.isArray(this) ? this : []));
  let lines = [];
  function consumeOpCode(value) {
    const ref = value >>> 2;
    const opCode = value & 3;
    switch (opCode) {
      case 0:
        return `(lView[${ref}] as Text).textContent = $$$`;
      case 1:
        const attrName = parser.consumeString();
        const sanitizationFn = parser.consumeFunction();
        const value2 = sanitizationFn ? `(${sanitizationFn})($$$)` : "$$$";
        return `(lView[${ref}] as Element).setAttribute('${attrName}', ${value2})`;
      case 2:
        return `icuSwitchCase(${ref}, $$$)`;
      case 3:
        return `icuUpdateCase(${ref})`;
    }
    throw new Error("unexpected OpCode");
  }
  while (parser.hasMore()) {
    let mask = parser.consumeNumber();
    let size = parser.consumeNumber();
    const end = parser.i + size;
    const statements = [];
    let statement = "";
    while (parser.i < end) {
      let value = parser.consumeNumberOrString();
      if (typeof value === "string") {
        statement += value;
      } else if (value < 0) {
        statement += "${lView[i" + value + "]}";
      } else {
        const opCodeText = consumeOpCode(value);
        statements.push(opCodeText.replace("$$$", "`" + statement + "`") + ";");
        statement = "";
      }
    }
    lines.push(`if (mask & 0b${mask.toString(2)}) { ${statements.join(" ")} }`);
  }
  return lines;
}
function icuCreateOpCodesToString(opcodes) {
  const parser = new OpCodeParser(opcodes || (Array.isArray(this) ? this : []));
  let lines = [];
  function consumeOpCode(opCode) {
    const parent = getParentFromIcuCreateOpCode(opCode);
    const ref = getRefFromIcuCreateOpCode(opCode);
    switch (getInstructionFromIcuCreateOpCode(opCode)) {
      case 0:
        return `(lView[${parent}] as Element).appendChild(lView[${lastRef}])`;
      case 1:
        return `(lView[${ref}] as Element).setAttribute("${parser.consumeString()}", "${parser.consumeString()}")`;
    }
    throw new Error("Unexpected OpCode: " + getInstructionFromIcuCreateOpCode(opCode));
  }
  let lastRef = -1;
  while (parser.hasMore()) {
    let value = parser.consumeNumberStringOrMarker();
    if (value === ICU_MARKER) {
      const text = parser.consumeString();
      lastRef = parser.consumeNumber();
      lines.push(`lView[${lastRef}] = document.createComment("${text}")`);
    } else if (value === ELEMENT_MARKER) {
      const text = parser.consumeString();
      lastRef = parser.consumeNumber();
      lines.push(`lView[${lastRef}] = document.createElement("${text}")`);
    } else if (typeof value === "string") {
      lastRef = parser.consumeNumber();
      lines.push(`lView[${lastRef}] = document.createTextNode("${value}")`);
    } else if (typeof value === "number") {
      const line = consumeOpCode(value);
      line && lines.push(line);
    } else {
      throw new Error("Unexpected value");
    }
  }
  return lines;
}
function i18nRemoveOpCodesToString(opcodes) {
  const removeCodes = opcodes || (Array.isArray(this) ? this : []);
  let lines = [];
  for (let i = 0; i < removeCodes.length; i++) {
    const nodeOrIcuIndex = removeCodes[i];
    if (nodeOrIcuIndex > 0) {
      lines.push(`remove(lView[${nodeOrIcuIndex}])`);
    } else {
      lines.push(`removeNestedICU(${~nodeOrIcuIndex})`);
    }
  }
  return lines;
}
var OpCodeParser = class {
  constructor(codes) {
    this.i = 0;
    this.codes = codes;
  }
  hasMore() {
    return this.i < this.codes.length;
  }
  consumeNumber() {
    let value = this.codes[this.i++];
    assertNumber(value, "expecting number in OpCode");
    return value;
  }
  consumeString() {
    let value = this.codes[this.i++];
    assertString(value, "expecting string in OpCode");
    return value;
  }
  consumeFunction() {
    let value = this.codes[this.i++];
    if (value === null || typeof value === "function") {
      return value;
    }
    throw new Error("expecting function in OpCode");
  }
  consumeNumberOrString() {
    let value = this.codes[this.i++];
    if (typeof value === "string") {
      return value;
    }
    assertNumber(value, "expecting number or string in OpCode");
    return value;
  }
  consumeNumberStringOrMarker() {
    let value = this.codes[this.i++];
    if (typeof value === "string" || typeof value === "number" || value == ICU_MARKER || value == ELEMENT_MARKER) {
      return value;
    }
    assertNumber(value, "expecting number, string, ICU_MARKER or ELEMENT_MARKER in OpCode");
    return value;
  }
};
var BINDING_REGEXP = /�(\d+):?\d*�/gi;
var ICU_REGEXP = /({\s*�\d+:?\d*�\s*,\s*\S{6}\s*,[\s\S]*})/gi;
var NESTED_ICU = /�(\d+)�/;
var ICU_BLOCK_REGEXP = /^\s*(�\d+:?\d*�)\s*,\s*(select|plural)\s*,/;
var MARKER = `�`;
var SUBTEMPLATE_REGEXP = /�\/?\*(\d+:\d+)�/gi;
var PH_REGEXP = /�(\/?[#*]\d+):?\d*�/gi;
var NGSP_UNICODE_REGEXP = /\uE500/g;
function replaceNgsp(value) {
  return value.replace(NGSP_UNICODE_REGEXP, " ");
}
function attachDebugGetter(obj, debugGetter) {
  if (ngDevMode) {
    Object.defineProperty(obj, "debug", {
      get: debugGetter,
      enumerable: false
    });
  } else {
    throw new Error("This method should be guarded with `ngDevMode` so that it can be tree shaken in production!");
  }
}
function i18nStartFirstCreatePass(tView, parentTNodeIndex, lView, index, message, subTemplateIndex) {
  const rootTNode = getCurrentParentTNode();
  const createOpCodes = [];
  const updateOpCodes = [];
  const existingTNodeStack = [[]];
  const astStack = [[]];
  if (ngDevMode) {
    attachDebugGetter(createOpCodes, i18nCreateOpCodesToString);
    attachDebugGetter(updateOpCodes, i18nUpdateOpCodesToString);
  }
  message = getTranslationForTemplate(message, subTemplateIndex);
  const msgParts = replaceNgsp(message).split(PH_REGEXP);
  for (let i = 0; i < msgParts.length; i++) {
    let value = msgParts[i];
    if ((i & 1) === 0) {
      const parts = i18nParseTextIntoPartsAndICU(value);
      for (let j = 0; j < parts.length; j++) {
        let part = parts[j];
        if ((j & 1) === 0) {
          const text = part;
          ngDevMode && assertString(text, "Parsed ICU part should be string");
          if (text !== "") {
            i18nStartFirstCreatePassProcessTextNode(astStack[0], tView, rootTNode, existingTNodeStack[0], createOpCodes, updateOpCodes, lView, text);
          }
        } else {
          const icuExpression = part;
          if (typeof icuExpression !== "object") {
            throw new Error(`Unable to parse ICU expression in "${message}" message.`);
          }
          const icuContainerTNode = createTNodeAndAddOpCode(tView, rootTNode, existingTNodeStack[0], lView, createOpCodes, ngDevMode ? `ICU ${index}:${icuExpression.mainBinding}` : "", true);
          const icuNodeIndex = icuContainerTNode.index;
          ngDevMode && assertGreaterThanOrEqual(icuNodeIndex, HEADER_OFFSET, "Index must be in absolute LView offset");
          icuStart(astStack[0], tView, lView, updateOpCodes, parentTNodeIndex, icuExpression, icuNodeIndex);
        }
      }
    } else {
      const isClosing = value.charCodeAt(0) === 47;
      const type = value.charCodeAt(isClosing ? 1 : 0);
      ngDevMode && assertOneOf(
        type,
        42,
        35
        /* CharCode.HASH */
      );
      const index2 = HEADER_OFFSET + Number.parseInt(value.substring(isClosing ? 2 : 1));
      if (isClosing) {
        existingTNodeStack.shift();
        astStack.shift();
        setCurrentTNode(getCurrentParentTNode(), false);
      } else {
        const tNode = createTNodePlaceholder(tView, existingTNodeStack[0], index2);
        existingTNodeStack.unshift([]);
        setCurrentTNode(tNode, true);
        const placeholderNode = {
          kind: 2,
          index: index2,
          children: [],
          type: type === 35 ? 0 : 1
          /* I18nPlaceholderType.SUBTEMPLATE */
        };
        astStack[0].push(placeholderNode);
        astStack.unshift(placeholderNode.children);
      }
    }
  }
  tView.data[index] = {
    create: createOpCodes,
    update: updateOpCodes,
    ast: astStack[0],
    parentTNodeIndex
  };
}
function createTNodeAndAddOpCode(tView, rootTNode, existingTNodes, lView, createOpCodes, text, isICU) {
  const i18nNodeIdx = allocExpando(tView, lView, 1, null);
  let opCode = i18nNodeIdx << I18nCreateOpCode.SHIFT;
  let parentTNode = getCurrentParentTNode();
  if (rootTNode === parentTNode) {
    parentTNode = null;
  }
  if (parentTNode === null) {
    opCode |= I18nCreateOpCode.APPEND_EAGERLY;
  }
  if (isICU) {
    opCode |= I18nCreateOpCode.COMMENT;
    ensureIcuContainerVisitorLoaded(loadIcuContainerVisitor);
  }
  createOpCodes.push(opCode, text === null ? "" : text);
  const tNode = createTNodeAtIndex(tView, i18nNodeIdx, isICU ? 32 : 1, text === null ? ngDevMode ? "{{?}}" : "" : text, null);
  addTNodeAndUpdateInsertBeforeIndex(existingTNodes, tNode);
  const tNodeIdx = tNode.index;
  setCurrentTNode(
    tNode,
    false
    /* Text nodes are self closing */
  );
  if (parentTNode !== null && rootTNode !== parentTNode) {
    setTNodeInsertBeforeIndex(parentTNode, tNodeIdx);
  }
  return tNode;
}
function i18nStartFirstCreatePassProcessTextNode(ast, tView, rootTNode, existingTNodes, createOpCodes, updateOpCodes, lView, text) {
  const hasBinding = text.match(BINDING_REGEXP);
  const tNode = createTNodeAndAddOpCode(tView, rootTNode, existingTNodes, lView, createOpCodes, hasBinding ? null : text, false);
  const index = tNode.index;
  if (hasBinding) {
    generateBindingUpdateOpCodes(updateOpCodes, text, index, null, 0, null);
  }
  ast.push({
    kind: 0,
    index
  });
}
function i18nAttributesFirstPass(tView, index, values) {
  const previousElement = getCurrentTNode();
  const previousElementIndex = previousElement.index;
  const updateOpCodes = [];
  if (ngDevMode) {
    attachDebugGetter(updateOpCodes, i18nUpdateOpCodesToString);
  }
  if (tView.firstCreatePass && tView.data[index] === null) {
    for (let i = 0; i < values.length; i += 2) {
      const attrName = values[i];
      const message = values[i + 1];
      if (message !== "") {
        if (ICU_REGEXP.test(message)) {
          throw new Error(`ICU expressions are not supported in attributes. Message: "${message}".`);
        }
        generateBindingUpdateOpCodes(updateOpCodes, message, previousElementIndex, attrName, countBindings(updateOpCodes), null);
      }
    }
    tView.data[index] = updateOpCodes;
  }
}
function generateBindingUpdateOpCodes(updateOpCodes, str, destinationNode, attrName, bindingStart, sanitizeFn) {
  ngDevMode && assertGreaterThanOrEqual(destinationNode, HEADER_OFFSET, "Index must be in absolute LView offset");
  const maskIndex = updateOpCodes.length;
  const sizeIndex = maskIndex + 1;
  updateOpCodes.push(null, null);
  const startIndex = maskIndex + 2;
  if (ngDevMode) {
    attachDebugGetter(updateOpCodes, i18nUpdateOpCodesToString);
  }
  const textParts = str.split(BINDING_REGEXP);
  let mask = 0;
  for (let j = 0; j < textParts.length; j++) {
    const textValue = textParts[j];
    if (j & 1) {
      const bindingIndex = bindingStart + parseInt(textValue, 10);
      updateOpCodes.push(-1 - bindingIndex);
      mask = mask | toMaskBit(bindingIndex);
    } else if (textValue !== "") {
      updateOpCodes.push(textValue);
    }
  }
  updateOpCodes.push(destinationNode << 2 | (attrName ? 1 : 0));
  if (attrName) {
    updateOpCodes.push(attrName, sanitizeFn);
  }
  updateOpCodes[maskIndex] = mask;
  updateOpCodes[sizeIndex] = updateOpCodes.length - startIndex;
  return mask;
}
function countBindings(opCodes) {
  let count = 0;
  for (let i = 0; i < opCodes.length; i++) {
    const opCode = opCodes[i];
    if (typeof opCode === "number" && opCode < 0) {
      count++;
    }
  }
  return count;
}
function toMaskBit(bindingIndex) {
  return 1 << Math.min(bindingIndex, 31);
}
function removeInnerTemplateTranslation(message) {
  let match;
  let res = "";
  let index = 0;
  let inTemplate = false;
  let tagMatched;
  while ((match = SUBTEMPLATE_REGEXP.exec(message)) !== null) {
    if (!inTemplate) {
      res += message.substring(index, match.index + match[0].length);
      tagMatched = match[1];
      inTemplate = true;
    } else {
      if (match[0] === `${MARKER}/*${tagMatched}${MARKER}`) {
        index = match.index;
        inTemplate = false;
      }
    }
  }
  ngDevMode && assertEqual(inTemplate, false, `Tag mismatch: unable to find the end of the sub-template in the translation "${message}"`);
  res += message.slice(index);
  return res;
}
function getTranslationForTemplate(message, subTemplateIndex) {
  if (isRootTemplateMessage(subTemplateIndex)) {
    return removeInnerTemplateTranslation(message);
  } else {
    const start = message.indexOf(`:${subTemplateIndex}${MARKER}`) + 2 + subTemplateIndex.toString().length;
    const end = message.search(new RegExp(`${MARKER}\\/\\*\\d+:${subTemplateIndex}${MARKER}`));
    return removeInnerTemplateTranslation(message.substring(start, end));
  }
}
function icuStart(ast, tView, lView, updateOpCodes, parentIdx, icuExpression, anchorIdx) {
  ngDevMode && assertDefined(icuExpression, "ICU expression must be defined");
  let bindingMask = 0;
  const tIcu = {
    type: icuExpression.type,
    currentCaseLViewIndex: allocExpando(tView, lView, 1, null),
    anchorIdx,
    cases: [],
    create: [],
    remove: [],
    update: []
  };
  addUpdateIcuSwitch(updateOpCodes, icuExpression, anchorIdx);
  setTIcu(tView, anchorIdx, tIcu);
  const values = icuExpression.values;
  const cases = [];
  for (let i = 0; i < values.length; i++) {
    const valueArr = values[i];
    const nestedIcus = [];
    for (let j = 0; j < valueArr.length; j++) {
      const value = valueArr[j];
      if (typeof value !== "string") {
        const icuIndex = nestedIcus.push(value) - 1;
        valueArr[j] = `<!--�${icuIndex}�-->`;
      }
    }
    const caseAst = [];
    cases.push(caseAst);
    bindingMask = parseIcuCase(caseAst, tView, tIcu, lView, updateOpCodes, parentIdx, icuExpression.cases[i], valueArr.join(""), nestedIcus) | bindingMask;
  }
  if (bindingMask) {
    addUpdateIcuUpdate(updateOpCodes, bindingMask, anchorIdx);
  }
  ast.push({
    kind: 3,
    index: anchorIdx,
    cases,
    currentCaseLViewIndex: tIcu.currentCaseLViewIndex
  });
}
function parseICUBlock(pattern) {
  const cases = [];
  const values = [];
  let icuType = 1;
  let mainBinding = 0;
  pattern = pattern.replace(ICU_BLOCK_REGEXP, function(str, binding, type) {
    if (type === "select") {
      icuType = 0;
    } else {
      icuType = 1;
    }
    mainBinding = parseInt(binding.slice(1), 10);
    return "";
  });
  const parts = i18nParseTextIntoPartsAndICU(pattern);
  for (let pos = 0; pos < parts.length; ) {
    let key = parts[pos++].trim();
    if (icuType === 1) {
      key = key.replace(/\s*(?:=)?(\w+)\s*/, "$1");
    }
    if (key.length) {
      cases.push(key);
    }
    const blocks = i18nParseTextIntoPartsAndICU(parts[pos++]);
    if (cases.length > values.length) {
      values.push(blocks);
    }
  }
  return {
    type: icuType,
    mainBinding,
    cases,
    values
  };
}
function i18nParseTextIntoPartsAndICU(pattern) {
  if (!pattern) {
    return [];
  }
  let prevPos = 0;
  const braceStack = [];
  const results = [];
  const braces = /[{}]/g;
  braces.lastIndex = 0;
  let match;
  while (match = braces.exec(pattern)) {
    const pos = match.index;
    if (match[0] == "}") {
      braceStack.pop();
      if (braceStack.length == 0) {
        const block = pattern.substring(prevPos, pos);
        if (ICU_BLOCK_REGEXP.test(block)) {
          results.push(parseICUBlock(block));
        } else {
          results.push(block);
        }
        prevPos = pos + 1;
      }
    } else {
      if (braceStack.length == 0) {
        const substring2 = pattern.substring(prevPos, pos);
        results.push(substring2);
        prevPos = pos + 1;
      }
      braceStack.push("{");
    }
  }
  const substring = pattern.substring(prevPos);
  results.push(substring);
  return results;
}
function parseIcuCase(ast, tView, tIcu, lView, updateOpCodes, parentIdx, caseName, unsafeCaseHtml, nestedIcus) {
  const create = [];
  const remove2 = [];
  const update = [];
  if (ngDevMode) {
    attachDebugGetter(create, icuCreateOpCodesToString);
    attachDebugGetter(remove2, i18nRemoveOpCodesToString);
    attachDebugGetter(update, i18nUpdateOpCodesToString);
  }
  tIcu.cases.push(caseName);
  tIcu.create.push(create);
  tIcu.remove.push(remove2);
  tIcu.update.push(update);
  const inertBodyHelper2 = getInertBodyHelper(getDocument());
  const inertBodyElement = inertBodyHelper2.getInertBodyElement(unsafeCaseHtml);
  ngDevMode && assertDefined(inertBodyElement, "Unable to generate inert body element");
  const inertRootNode = getTemplateContent(inertBodyElement) || inertBodyElement;
  if (inertRootNode) {
    return walkIcuTree(ast, tView, tIcu, lView, updateOpCodes, create, remove2, update, inertRootNode, parentIdx, nestedIcus, 0);
  } else {
    return 0;
  }
}
function walkIcuTree(ast, tView, tIcu, lView, sharedUpdateOpCodes, create, remove2, update, parentNode, parentIdx, nestedIcus, depth) {
  let bindingMask = 0;
  let currentNode = parentNode.firstChild;
  while (currentNode) {
    const newIndex = allocExpando(tView, lView, 1, null);
    switch (currentNode.nodeType) {
      case Node.ELEMENT_NODE:
        const element = currentNode;
        const tagName = element.tagName.toLowerCase();
        if (VALID_ELEMENTS.hasOwnProperty(tagName)) {
          addCreateNodeAndAppend(create, ELEMENT_MARKER, tagName, parentIdx, newIndex);
          tView.data[newIndex] = tagName;
          const elAttrs = element.attributes;
          for (let i = 0; i < elAttrs.length; i++) {
            const attr = elAttrs.item(i);
            const lowerAttrName = attr.name.toLowerCase();
            const hasBinding2 = !!attr.value.match(BINDING_REGEXP);
            if (hasBinding2) {
              if (VALID_ATTRS.hasOwnProperty(lowerAttrName)) {
                if (URI_ATTRS[lowerAttrName]) {
                  generateBindingUpdateOpCodes(update, attr.value, newIndex, attr.name, 0, _sanitizeUrl);
                } else {
                  generateBindingUpdateOpCodes(update, attr.value, newIndex, attr.name, 0, null);
                }
              } else {
                ngDevMode && console.warn(`WARNING: ignoring unsafe attribute value ${lowerAttrName} on element ${tagName} (see ${XSS_SECURITY_URL})`);
              }
            } else {
              addCreateAttribute(create, newIndex, attr);
            }
          }
          const elementNode = {
            kind: 1,
            index: newIndex,
            children: []
          };
          ast.push(elementNode);
          bindingMask = walkIcuTree(elementNode.children, tView, tIcu, lView, sharedUpdateOpCodes, create, remove2, update, currentNode, newIndex, nestedIcus, depth + 1) | bindingMask;
          addRemoveNode(remove2, newIndex, depth);
        }
        break;
      case Node.TEXT_NODE:
        const value = currentNode.textContent || "";
        const hasBinding = value.match(BINDING_REGEXP);
        addCreateNodeAndAppend(create, null, hasBinding ? "" : value, parentIdx, newIndex);
        addRemoveNode(remove2, newIndex, depth);
        if (hasBinding) {
          bindingMask = generateBindingUpdateOpCodes(update, value, newIndex, null, 0, null) | bindingMask;
        }
        ast.push({
          kind: 0,
          index: newIndex
        });
        break;
      case Node.COMMENT_NODE:
        const isNestedIcu = NESTED_ICU.exec(currentNode.textContent || "");
        if (isNestedIcu) {
          const nestedIcuIndex = parseInt(isNestedIcu[1], 10);
          const icuExpression = nestedIcus[nestedIcuIndex];
          addCreateNodeAndAppend(create, ICU_MARKER, ngDevMode ? `nested ICU ${nestedIcuIndex}` : "", parentIdx, newIndex);
          icuStart(ast, tView, lView, sharedUpdateOpCodes, parentIdx, icuExpression, newIndex);
          addRemoveNestedIcu(remove2, newIndex, depth);
        }
        break;
    }
    currentNode = currentNode.nextSibling;
  }
  return bindingMask;
}
function addRemoveNode(remove2, index, depth) {
  if (depth === 0) {
    remove2.push(index);
  }
}
function addRemoveNestedIcu(remove2, index, depth) {
  if (depth === 0) {
    remove2.push(~index);
    remove2.push(index);
  }
}
function addUpdateIcuSwitch(update, icuExpression, index) {
  update.push(
    toMaskBit(icuExpression.mainBinding),
    2,
    -1 - icuExpression.mainBinding,
    index << 2 | 2
    /* I18nUpdateOpCode.IcuSwitch */
  );
}
function addUpdateIcuUpdate(update, bindingMask, index) {
  update.push(
    bindingMask,
    1,
    index << 2 | 3
    /* I18nUpdateOpCode.IcuUpdate */
  );
}
function addCreateNodeAndAppend(create, marker, text, appendToParentIdx, createAtIdx) {
  if (marker !== null) {
    create.push(marker);
  }
  create.push(text, createAtIdx, icuCreateOpCode(0, appendToParentIdx, createAtIdx));
}
function addCreateAttribute(create, newIndex, attr) {
  create.push(newIndex << 1 | 1, attr.name, attr.value);
}
var ROOT_TEMPLATE_ID = 0;
var PP_MULTI_VALUE_PLACEHOLDERS_REGEXP = /\[(�.+?�?)\]/;
var PP_PLACEHOLDERS_REGEXP = /\[(�.+?�?)\]|(�\/?\*\d+:\d+�)/g;
var PP_ICU_VARS_REGEXP = /({\s*)(VAR_(PLURAL|SELECT)(_\d+)?)(\s*,)/g;
var PP_ICU_PLACEHOLDERS_REGEXP = /{([A-Z0-9_]+)}/g;
var PP_ICUS_REGEXP = /�I18N_EXP_(ICU(_\d+)?)�/g;
var PP_CLOSE_TEMPLATE_REGEXP = /\/\*/;
var PP_TEMPLATE_ID_REGEXP = /\d+\:(\d+)/;
function i18nPostprocess(message, replacements = {}) {
  let result = message;
  if (PP_MULTI_VALUE_PLACEHOLDERS_REGEXP.test(message)) {
    const matches = {};
    const templateIdsStack = [ROOT_TEMPLATE_ID];
    result = result.replace(PP_PLACEHOLDERS_REGEXP, (m, phs, tmpl) => {
      const content = phs || tmpl;
      const placeholders = matches[content] || [];
      if (!placeholders.length) {
        content.split("|").forEach((placeholder2) => {
          const match = placeholder2.match(PP_TEMPLATE_ID_REGEXP);
          const templateId2 = match ? parseInt(match[1], 10) : ROOT_TEMPLATE_ID;
          const isCloseTemplateTag2 = PP_CLOSE_TEMPLATE_REGEXP.test(placeholder2);
          placeholders.push([templateId2, isCloseTemplateTag2, placeholder2]);
        });
        matches[content] = placeholders;
      }
      if (!placeholders.length) {
        throw new Error(`i18n postprocess: unmatched placeholder - ${content}`);
      }
      const currentTemplateId = templateIdsStack[templateIdsStack.length - 1];
      let idx = 0;
      for (let i = 0; i < placeholders.length; i++) {
        if (placeholders[i][0] === currentTemplateId) {
          idx = i;
          break;
        }
      }
      const [templateId, isCloseTemplateTag, placeholder] = placeholders[idx];
      if (isCloseTemplateTag) {
        templateIdsStack.pop();
      } else if (currentTemplateId !== templateId) {
        templateIdsStack.push(templateId);
      }
      placeholders.splice(idx, 1);
      return placeholder;
    });
  }
  if (!Object.keys(replacements).length) {
    return result;
  }
  result = result.replace(PP_ICU_VARS_REGEXP, (match, start, key, _type, _idx, end) => {
    return replacements.hasOwnProperty(key) ? `${start}${replacements[key]}${end}` : match;
  });
  result = result.replace(PP_ICU_PLACEHOLDERS_REGEXP, (match, key) => {
    return replacements.hasOwnProperty(key) ? replacements[key] : match;
  });
  result = result.replace(PP_ICUS_REGEXP, (match, key) => {
    if (replacements.hasOwnProperty(key)) {
      const list = replacements[key];
      if (!list.length) {
        throw new Error(`i18n postprocess: unmatched ICU - ${match} with key: ${key}`);
      }
      return list.shift();
    }
    return match;
  });
  return result;
}
function ɵɵi18nStart(index, messageIndex, subTemplateIndex = -1) {
  const tView = getTView();
  const lView = getLView();
  const adjustedIndex = HEADER_OFFSET + index;
  ngDevMode && assertDefined(tView, `tView should be defined`);
  const message = getConstant(tView.consts, messageIndex);
  const parentTNode = getCurrentParentTNode();
  if (tView.firstCreatePass) {
    i18nStartFirstCreatePass(tView, parentTNode === null ? 0 : parentTNode.index, lView, adjustedIndex, message, subTemplateIndex);
  }
  if (tView.type === 2) {
    const componentLView = lView[DECLARATION_COMPONENT_VIEW];
    componentLView[FLAGS] |= 32;
  } else {
    lView[FLAGS] |= 32;
  }
  const tI18n = tView.data[adjustedIndex];
  const sameViewParentTNode = parentTNode === lView[T_HOST] ? null : parentTNode;
  const parentRNode = getClosestRElement(tView, sameViewParentTNode, lView);
  const insertInFrontOf = parentTNode && parentTNode.type & 8 ? lView[parentTNode.index] : null;
  prepareI18nBlockForHydration(lView, adjustedIndex, parentTNode, subTemplateIndex);
  applyCreateOpCodes(lView, tI18n.create, parentRNode, insertInFrontOf);
  setInI18nBlock(true);
}
function ɵɵi18nEnd() {
  setInI18nBlock(false);
}
function ɵɵi18n(index, messageIndex, subTemplateIndex) {
  ɵɵi18nStart(index, messageIndex, subTemplateIndex);
  ɵɵi18nEnd();
}
function ɵɵi18nAttributes(index, attrsIndex) {
  const tView = getTView();
  ngDevMode && assertDefined(tView, `tView should be defined`);
  const attrs = getConstant(tView.consts, attrsIndex);
  i18nAttributesFirstPass(tView, index + HEADER_OFFSET, attrs);
}
function ɵɵi18nExp(value) {
  const lView = getLView();
  setMaskBit(bindingUpdated(lView, nextBindingIndex(), value));
  return ɵɵi18nExp;
}
function ɵɵi18nApply(index) {
  applyI18n(getTView(), getLView(), index + HEADER_OFFSET);
}
function ɵɵi18nPostprocess(message, replacements = {}) {
  return i18nPostprocess(message, replacements);
}
var stashEventListener = (el, eventName, listenerFn) => {
};
function setStashFn(fn) {
  stashEventListener = fn;
}
function ɵɵlistener(eventName, listenerFn, useCapture, eventTargetResolver) {
  const lView = getLView();
  const tView = getTView();
  const tNode = getCurrentTNode();
  listenerInternal(tView, lView, lView[RENDERER], tNode, eventName, listenerFn, eventTargetResolver);
  return ɵɵlistener;
}
function ɵɵsyntheticHostListener(eventName, listenerFn) {
  const tNode = getCurrentTNode();
  const lView = getLView();
  const tView = getTView();
  const currentDef = getCurrentDirectiveDef(tView.data);
  const renderer = loadComponentRenderer(currentDef, tNode, lView);
  listenerInternal(tView, lView, renderer, tNode, eventName, listenerFn);
  return ɵɵsyntheticHostListener;
}
function findExistingListener(tView, lView, eventName, tNodeIdx) {
  const tCleanup = tView.cleanup;
  if (tCleanup != null) {
    for (let i = 0; i < tCleanup.length - 1; i += 2) {
      const cleanupEventName = tCleanup[i];
      if (cleanupEventName === eventName && tCleanup[i + 1] === tNodeIdx) {
        const lCleanup = lView[CLEANUP];
        const listenerIdxInLCleanup = tCleanup[i + 2];
        return lCleanup.length > listenerIdxInLCleanup ? lCleanup[listenerIdxInLCleanup] : null;
      }
      if (typeof cleanupEventName === "string") {
        i += 2;
      }
    }
  }
  return null;
}
function listenerInternal(tView, lView, renderer, tNode, eventName, listenerFn, eventTargetResolver) {
  const isTNodeDirectiveHost = isDirectiveHost(tNode);
  const firstCreatePass = tView.firstCreatePass;
  const tCleanup = firstCreatePass && getOrCreateTViewCleanup(tView);
  const context = lView[CONTEXT];
  const lCleanup = getOrCreateLViewCleanup(lView);
  ngDevMode && assertTNodeType(
    tNode,
    3 | 12
    /* TNodeType.AnyContainer */
  );
  let processOutputs = true;
  if (tNode.type & 3 || eventTargetResolver) {
    const native = getNativeByTNode(tNode, lView);
    const target = eventTargetResolver ? eventTargetResolver(native) : native;
    const lCleanupIndex = lCleanup.length;
    const idxOrTargetGetter = eventTargetResolver ? (_lView) => eventTargetResolver(unwrapRNode(_lView[tNode.index])) : tNode.index;
    let existingListener = null;
    if (!eventTargetResolver && isTNodeDirectiveHost) {
      existingListener = findExistingListener(tView, lView, eventName, tNode.index);
    }
    if (existingListener !== null) {
      const lastListenerFn = existingListener.__ngLastListenerFn__ || existingListener;
      lastListenerFn.__ngNextListenerFn__ = listenerFn;
      existingListener.__ngLastListenerFn__ = listenerFn;
      processOutputs = false;
    } else {
      listenerFn = wrapListener(tNode, lView, context, listenerFn);
      stashEventListener(native, eventName, listenerFn);
      const cleanupFn = renderer.listen(target, eventName, listenerFn);
      ngDevMode && ngDevMode.rendererAddEventListener++;
      lCleanup.push(listenerFn, cleanupFn);
      tCleanup && tCleanup.push(eventName, idxOrTargetGetter, lCleanupIndex, lCleanupIndex + 1);
    }
  } else {
    listenerFn = wrapListener(tNode, lView, context, listenerFn);
  }
  const outputs = tNode.outputs;
  let props;
  if (processOutputs && outputs !== null && (props = outputs[eventName])) {
    const propsLength = props.length;
    if (propsLength) {
      for (let i = 0; i < propsLength; i += 2) {
        const index = props[i];
        ngDevMode && assertIndexInRange(lView, index);
        const minifiedName = props[i + 1];
        const directiveInstance = lView[index];
        const output2 = directiveInstance[minifiedName];
        if (ngDevMode && !isOutputSubscribable(output2)) {
          throw new Error(`@Output ${minifiedName} not initialized in '${directiveInstance.constructor.name}'.`);
        }
        const subscription = output2.subscribe(listenerFn);
        const idx = lCleanup.length;
        lCleanup.push(listenerFn, subscription);
        tCleanup && tCleanup.push(eventName, tNode.index, idx, -(idx + 1));
      }
    }
  }
}
function executeListenerWithErrorHandling(lView, context, listenerFn, e) {
  const prevConsumer = setActiveConsumer(null);
  try {
    profiler(6, context, listenerFn);
    return listenerFn(e) !== false;
  } catch (error) {
    handleError(lView, error);
    return false;
  } finally {
    profiler(7, context, listenerFn);
    setActiveConsumer(prevConsumer);
  }
}
function wrapListener(tNode, lView, context, listenerFn) {
  return function wrapListenerIn_markDirtyAndPreventDefault(e) {
    if (e === Function) {
      return listenerFn;
    }
    const startView = tNode.componentOffset > -1 ? getComponentLViewByIndex(tNode.index, lView) : lView;
    markViewDirty(
      startView,
      5
      /* NotificationSource.Listener */
    );
    let result = executeListenerWithErrorHandling(lView, context, listenerFn, e);
    let nextListenerFn = wrapListenerIn_markDirtyAndPreventDefault.__ngNextListenerFn__;
    while (nextListenerFn) {
      result = executeListenerWithErrorHandling(lView, context, nextListenerFn, e) && result;
      nextListenerFn = nextListenerFn.__ngNextListenerFn__;
    }
    return result;
  };
}
function isOutputSubscribable(value) {
  return value != null && typeof value.subscribe === "function";
}
function ɵɵnextContext(level = 1) {
  return nextContextImpl(level);
}
function matchingProjectionSlotIndex(tNode, projectionSlots) {
  let wildcardNgContentIndex = null;
  const ngProjectAsAttrVal = getProjectAsAttrValue(tNode);
  for (let i = 0; i < projectionSlots.length; i++) {
    const slotValue = projectionSlots[i];
    if (slotValue === "*") {
      wildcardNgContentIndex = i;
      continue;
    }
    if (ngProjectAsAttrVal === null ? isNodeMatchingSelectorList(
      tNode,
      slotValue,
      /* isProjectionMode */
      true
    ) : isSelectorInSelectorList(ngProjectAsAttrVal, slotValue)) {
      return i;
    }
  }
  return wildcardNgContentIndex;
}
function ɵɵprojectionDef(projectionSlots) {
  const componentNode = getLView()[DECLARATION_COMPONENT_VIEW][T_HOST];
  if (!componentNode.projection) {
    const numProjectionSlots = projectionSlots ? projectionSlots.length : 1;
    const projectionHeads = componentNode.projection = newArray(numProjectionSlots, null);
    const tails = projectionHeads.slice();
    let componentChild = componentNode.child;
    while (componentChild !== null) {
      if (componentChild.type !== 128) {
        const slotIndex = projectionSlots ? matchingProjectionSlotIndex(componentChild, projectionSlots) : 0;
        if (slotIndex !== null) {
          if (tails[slotIndex]) {
            tails[slotIndex].projectionNext = componentChild;
          } else {
            projectionHeads[slotIndex] = componentChild;
          }
          tails[slotIndex] = componentChild;
        }
      }
      componentChild = componentChild.next;
    }
  }
}
function ɵɵprojection(nodeIndex, selectorIndex = 0, attrs, fallbackTemplateFn, fallbackDecls, fallbackVars) {
  const lView = getLView();
  const tView = getTView();
  const fallbackIndex = fallbackTemplateFn ? nodeIndex + 1 : null;
  if (fallbackIndex !== null) {
    declareTemplate(lView, tView, fallbackIndex, fallbackTemplateFn, fallbackDecls, fallbackVars, null, attrs);
  }
  const tProjectionNode = getOrCreateTNode(tView, HEADER_OFFSET + nodeIndex, 16, null, attrs || null);
  if (tProjectionNode.projection === null) {
    tProjectionNode.projection = selectorIndex;
  }
  setCurrentTNodeAsNotParent();
  const hydrationInfo = lView[HYDRATION];
  const isNodeCreationMode = !hydrationInfo || isInSkipHydrationBlock$1();
  const componentHostNode = lView[DECLARATION_COMPONENT_VIEW][T_HOST];
  const isEmpty = componentHostNode.projection[tProjectionNode.projection] === null;
  if (isEmpty && fallbackIndex !== null) {
    insertFallbackContent(lView, tView, fallbackIndex);
  } else if (isNodeCreationMode && (tProjectionNode.flags & 32) !== 32) {
    applyProjection(tView, lView, tProjectionNode);
  }
}
function insertFallbackContent(lView, tView, fallbackIndex) {
  const adjustedIndex = HEADER_OFFSET + fallbackIndex;
  const fallbackTNode = tView.data[adjustedIndex];
  const fallbackLContainer = lView[adjustedIndex];
  ngDevMode && assertTNode(fallbackTNode);
  ngDevMode && assertLContainer(fallbackLContainer);
  const dehydratedView = findMatchingDehydratedView(fallbackLContainer, fallbackTNode.tView.ssrId);
  const fallbackLView = createAndRenderEmbeddedLView(lView, fallbackTNode, void 0, {
    dehydratedView
  });
  addLViewToLContainer(fallbackLContainer, fallbackLView, 0, shouldAddViewToDom(fallbackTNode, dehydratedView));
}
function ɵɵpropertyInterpolate(propName, v0, sanitizer) {
  ɵɵpropertyInterpolate1(propName, "", v0, "", sanitizer);
  return ɵɵpropertyInterpolate;
}
function ɵɵpropertyInterpolate1(propName, prefix, v0, suffix, sanitizer) {
  const lView = getLView();
  const interpolatedValue = interpolation1(lView, prefix, v0, suffix);
  if (interpolatedValue !== NO_CHANGE) {
    const tView = getTView();
    const tNode = getSelectedTNode();
    elementPropertyInternal(tView, tNode, lView, propName, interpolatedValue, lView[RENDERER], sanitizer, false);
    ngDevMode && storePropertyBindingMetadata(tView.data, tNode, propName, getBindingIndex() - 1, prefix, suffix);
  }
  return ɵɵpropertyInterpolate1;
}
function ɵɵpropertyInterpolate2(propName, prefix, v0, i0, v1, suffix, sanitizer) {
  const lView = getLView();
  const interpolatedValue = interpolation2(lView, prefix, v0, i0, v1, suffix);
  if (interpolatedValue !== NO_CHANGE) {
    const tView = getTView();
    const tNode = getSelectedTNode();
    elementPropertyInternal(tView, tNode, lView, propName, interpolatedValue, lView[RENDERER], sanitizer, false);
    ngDevMode && storePropertyBindingMetadata(tView.data, tNode, propName, getBindingIndex() - 2, prefix, i0, suffix);
  }
  return ɵɵpropertyInterpolate2;
}
function ɵɵpropertyInterpolate3(propName, prefix, v0, i0, v1, i1, v2, suffix, sanitizer) {
  const lView = getLView();
  const interpolatedValue = interpolation3(lView, prefix, v0, i0, v1, i1, v2, suffix);
  if (interpolatedValue !== NO_CHANGE) {
    const tView = getTView();
    const tNode = getSelectedTNode();
    elementPropertyInternal(tView, tNode, lView, propName, interpolatedValue, lView[RENDERER], sanitizer, false);
    ngDevMode && storePropertyBindingMetadata(tView.data, tNode, propName, getBindingIndex() - 3, prefix, i0, i1, suffix);
  }
  return ɵɵpropertyInterpolate3;
}
function ɵɵpropertyInterpolate4(propName, prefix, v0, i0, v1, i1, v2, i2, v3, suffix, sanitizer) {
  const lView = getLView();
  const interpolatedValue = interpolation4(lView, prefix, v0, i0, v1, i1, v2, i2, v3, suffix);
  if (interpolatedValue !== NO_CHANGE) {
    const tView = getTView();
    const tNode = getSelectedTNode();
    elementPropertyInternal(tView, tNode, lView, propName, interpolatedValue, lView[RENDERER], sanitizer, false);
    ngDevMode && storePropertyBindingMetadata(tView.data, tNode, propName, getBindingIndex() - 4, prefix, i0, i1, i2, suffix);
  }
  return ɵɵpropertyInterpolate4;
}
function ɵɵpropertyInterpolate5(propName, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, suffix, sanitizer) {
  const lView = getLView();
  const interpolatedValue = interpolation5(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, suffix);
  if (interpolatedValue !== NO_CHANGE) {
    const tView = getTView();
    const tNode = getSelectedTNode();
    elementPropertyInternal(tView, tNode, lView, propName, interpolatedValue, lView[RENDERER], sanitizer, false);
    ngDevMode && storePropertyBindingMetadata(tView.data, tNode, propName, getBindingIndex() - 5, prefix, i0, i1, i2, i3, suffix);
  }
  return ɵɵpropertyInterpolate5;
}
function ɵɵpropertyInterpolate6(propName, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, suffix, sanitizer) {
  const lView = getLView();
  const interpolatedValue = interpolation6(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, suffix);
  if (interpolatedValue !== NO_CHANGE) {
    const tView = getTView();
    const tNode = getSelectedTNode();
    elementPropertyInternal(tView, tNode, lView, propName, interpolatedValue, lView[RENDERER], sanitizer, false);
    ngDevMode && storePropertyBindingMetadata(tView.data, tNode, propName, getBindingIndex() - 6, prefix, i0, i1, i2, i3, i4, suffix);
  }
  return ɵɵpropertyInterpolate6;
}
function ɵɵpropertyInterpolate7(propName, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, suffix, sanitizer) {
  const lView = getLView();
  const interpolatedValue = interpolation7(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, suffix);
  if (interpolatedValue !== NO_CHANGE) {
    const tView = getTView();
    const tNode = getSelectedTNode();
    elementPropertyInternal(tView, tNode, lView, propName, interpolatedValue, lView[RENDERER], sanitizer, false);
    ngDevMode && storePropertyBindingMetadata(tView.data, tNode, propName, getBindingIndex() - 7, prefix, i0, i1, i2, i3, i4, i5, suffix);
  }
  return ɵɵpropertyInterpolate7;
}
function ɵɵpropertyInterpolate8(propName, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, i6, v7, suffix, sanitizer) {
  const lView = getLView();
  const interpolatedValue = interpolation8(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, i6, v7, suffix);
  if (interpolatedValue !== NO_CHANGE) {
    const tView = getTView();
    const tNode = getSelectedTNode();
    elementPropertyInternal(tView, tNode, lView, propName, interpolatedValue, lView[RENDERER], sanitizer, false);
    ngDevMode && storePropertyBindingMetadata(tView.data, tNode, propName, getBindingIndex() - 8, prefix, i0, i1, i2, i3, i4, i5, i6, suffix);
  }
  return ɵɵpropertyInterpolate8;
}
function ɵɵpropertyInterpolateV(propName, values, sanitizer) {
  const lView = getLView();
  const interpolatedValue = interpolationV(lView, values);
  if (interpolatedValue !== NO_CHANGE) {
    const tView = getTView();
    const tNode = getSelectedTNode();
    elementPropertyInternal(tView, tNode, lView, propName, interpolatedValue, lView[RENDERER], sanitizer, false);
    if (ngDevMode) {
      const interpolationInBetween = [values[0]];
      for (let i = 2; i < values.length; i += 2) {
        interpolationInBetween.push(values[i]);
      }
      storePropertyBindingMetadata(tView.data, tNode, propName, getBindingIndex() - interpolationInBetween.length + 1, ...interpolationInBetween);
    }
  }
  return ɵɵpropertyInterpolateV;
}
function ɵɵcontentQuery(directiveIndex, predicate, flags, read) {
  createContentQuery(directiveIndex, predicate, flags, read);
}
function ɵɵviewQuery(predicate, flags, read) {
  createViewQuery(predicate, flags, read);
}
function ɵɵqueryRefresh(queryList) {
  const lView = getLView();
  const tView = getTView();
  const queryIndex = getCurrentQueryIndex();
  setCurrentQueryIndex(queryIndex + 1);
  const tQuery = getTQuery(tView, queryIndex);
  if (queryList.dirty && isCreationMode(lView) === ((tQuery.metadata.flags & 2) === 2)) {
    if (tQuery.matches === null) {
      queryList.reset([]);
    } else {
      const result = getQueryResults(lView, queryIndex);
      queryList.reset(result, unwrapElementRef);
      queryList.notifyOnChanges();
    }
    return true;
  }
  return false;
}
function ɵɵloadQuery() {
  return loadQueryInternal(getLView(), getCurrentQueryIndex());
}
function ɵɵcontentQuerySignal(directiveIndex, target, predicate, flags, read) {
  bindQueryToSignal(target, createContentQuery(directiveIndex, predicate, flags, read));
}
function ɵɵviewQuerySignal(target, predicate, flags, read) {
  bindQueryToSignal(target, createViewQuery(predicate, flags, read));
}
function ɵɵqueryAdvance(indexOffset = 1) {
  setCurrentQueryIndex(getCurrentQueryIndex() + indexOffset);
}
function store(tView, lView, index, value) {
  if (index >= tView.data.length) {
    tView.data[index] = null;
    tView.blueprint[index] = null;
  }
  lView[index] = value;
}
function ɵɵreference(index) {
  const contextLView = getContextLView();
  return load(contextLView, HEADER_OFFSET + index);
}
function ɵɵstyleMapInterpolate1(prefix, v0, suffix) {
  const lView = getLView();
  const interpolatedValue = interpolation1(lView, prefix, v0, suffix);
  ɵɵstyleMap(interpolatedValue);
}
function ɵɵstyleMapInterpolate2(prefix, v0, i0, v1, suffix) {
  const lView = getLView();
  const interpolatedValue = interpolation2(lView, prefix, v0, i0, v1, suffix);
  ɵɵstyleMap(interpolatedValue);
}
function ɵɵstyleMapInterpolate3(prefix, v0, i0, v1, i1, v2, suffix) {
  const lView = getLView();
  const interpolatedValue = interpolation3(lView, prefix, v0, i0, v1, i1, v2, suffix);
  ɵɵstyleMap(interpolatedValue);
}
function ɵɵstyleMapInterpolate4(prefix, v0, i0, v1, i1, v2, i2, v3, suffix) {
  const lView = getLView();
  const interpolatedValue = interpolation4(lView, prefix, v0, i0, v1, i1, v2, i2, v3, suffix);
  ɵɵstyleMap(interpolatedValue);
}
function ɵɵstyleMapInterpolate5(prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, suffix) {
  const lView = getLView();
  const interpolatedValue = interpolation5(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, suffix);
  ɵɵstyleMap(interpolatedValue);
}
function ɵɵstyleMapInterpolate6(prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, suffix) {
  const lView = getLView();
  const interpolatedValue = interpolation6(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, suffix);
  ɵɵstyleMap(interpolatedValue);
}
function ɵɵstyleMapInterpolate7(prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, suffix) {
  const lView = getLView();
  const interpolatedValue = interpolation7(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, suffix);
  ɵɵstyleMap(interpolatedValue);
}
function ɵɵstyleMapInterpolate8(prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, i6, v7, suffix) {
  const lView = getLView();
  const interpolatedValue = interpolation8(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, i6, v7, suffix);
  ɵɵstyleMap(interpolatedValue);
}
function ɵɵstyleMapInterpolateV(values) {
  const lView = getLView();
  const interpolatedValue = interpolationV(lView, values);
  ɵɵstyleMap(interpolatedValue);
}
function ɵɵstylePropInterpolate1(prop, prefix, v0, suffix, valueSuffix) {
  const lView = getLView();
  const interpolatedValue = interpolation1(lView, prefix, v0, suffix);
  checkStylingProperty(prop, interpolatedValue, valueSuffix, false);
  return ɵɵstylePropInterpolate1;
}
function ɵɵstylePropInterpolate2(prop, prefix, v0, i0, v1, suffix, valueSuffix) {
  const lView = getLView();
  const interpolatedValue = interpolation2(lView, prefix, v0, i0, v1, suffix);
  checkStylingProperty(prop, interpolatedValue, valueSuffix, false);
  return ɵɵstylePropInterpolate2;
}
function ɵɵstylePropInterpolate3(prop, prefix, v0, i0, v1, i1, v2, suffix, valueSuffix) {
  const lView = getLView();
  const interpolatedValue = interpolation3(lView, prefix, v0, i0, v1, i1, v2, suffix);
  checkStylingProperty(prop, interpolatedValue, valueSuffix, false);
  return ɵɵstylePropInterpolate3;
}
function ɵɵstylePropInterpolate4(prop, prefix, v0, i0, v1, i1, v2, i2, v3, suffix, valueSuffix) {
  const lView = getLView();
  const interpolatedValue = interpolation4(lView, prefix, v0, i0, v1, i1, v2, i2, v3, suffix);
  checkStylingProperty(prop, interpolatedValue, valueSuffix, false);
  return ɵɵstylePropInterpolate4;
}
function ɵɵstylePropInterpolate5(prop, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, suffix, valueSuffix) {
  const lView = getLView();
  const interpolatedValue = interpolation5(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, suffix);
  checkStylingProperty(prop, interpolatedValue, valueSuffix, false);
  return ɵɵstylePropInterpolate5;
}
function ɵɵstylePropInterpolate6(prop, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, suffix, valueSuffix) {
  const lView = getLView();
  const interpolatedValue = interpolation6(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, suffix);
  checkStylingProperty(prop, interpolatedValue, valueSuffix, false);
  return ɵɵstylePropInterpolate6;
}
function ɵɵstylePropInterpolate7(prop, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, suffix, valueSuffix) {
  const lView = getLView();
  const interpolatedValue = interpolation7(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, suffix);
  checkStylingProperty(prop, interpolatedValue, valueSuffix, false);
  return ɵɵstylePropInterpolate7;
}
function ɵɵstylePropInterpolate8(prop, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, i6, v7, suffix, valueSuffix) {
  const lView = getLView();
  const interpolatedValue = interpolation8(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, i6, v7, suffix);
  checkStylingProperty(prop, interpolatedValue, valueSuffix, false);
  return ɵɵstylePropInterpolate8;
}
function ɵɵstylePropInterpolateV(prop, values, valueSuffix) {
  const lView = getLView();
  const interpolatedValue = interpolationV(lView, values);
  checkStylingProperty(prop, interpolatedValue, valueSuffix, false);
  return ɵɵstylePropInterpolateV;
}
function ɵɵtext(index, value = "") {
  const lView = getLView();
  const tView = getTView();
  const adjustedIndex = index + HEADER_OFFSET;
  ngDevMode && assertEqual(getBindingIndex(), tView.bindingStartIndex, "text nodes should be created before any bindings");
  ngDevMode && assertIndexInRange(lView, adjustedIndex);
  const tNode = tView.firstCreatePass ? getOrCreateTNode(tView, adjustedIndex, 1, value, null) : tView.data[adjustedIndex];
  const textNative = _locateOrCreateTextNode(tView, lView, tNode, value, index);
  lView[adjustedIndex] = textNative;
  if (wasLastNodeCreated()) {
    appendChild(tView, lView, textNative, tNode);
  }
  setCurrentTNode(tNode, false);
}
var _locateOrCreateTextNode = (tView, lView, tNode, value, index) => {
  lastNodeWasCreated(true);
  return createTextNode(lView[RENDERER], value);
};
function locateOrCreateTextNodeImpl(tView, lView, tNode, value, index) {
  const hydrationInfo = lView[HYDRATION];
  const isNodeCreationMode = !hydrationInfo || isInSkipHydrationBlock$1() || isDetachedByI18n(tNode) || isDisconnectedNode$1(hydrationInfo, index);
  lastNodeWasCreated(isNodeCreationMode);
  if (isNodeCreationMode) {
    return createTextNode(lView[RENDERER], value);
  }
  const textNative = locateNextRNode(hydrationInfo, tView, lView, tNode);
  ngDevMode && validateMatchingNode(textNative, Node.TEXT_NODE, null, lView, tNode);
  ngDevMode && markRNodeAsClaimedByHydration(textNative);
  return textNative;
}
function enableLocateOrCreateTextNodeImpl() {
  _locateOrCreateTextNode = locateOrCreateTextNodeImpl;
}
function ɵɵtextInterpolate(v0) {
  ɵɵtextInterpolate1("", v0, "");
  return ɵɵtextInterpolate;
}
function ɵɵtextInterpolate1(prefix, v0, suffix) {
  const lView = getLView();
  const interpolated = interpolation1(lView, prefix, v0, suffix);
  if (interpolated !== NO_CHANGE) {
    textBindingInternal(lView, getSelectedIndex(), interpolated);
  }
  return ɵɵtextInterpolate1;
}
function ɵɵtextInterpolate2(prefix, v0, i0, v1, suffix) {
  const lView = getLView();
  const interpolated = interpolation2(lView, prefix, v0, i0, v1, suffix);
  if (interpolated !== NO_CHANGE) {
    textBindingInternal(lView, getSelectedIndex(), interpolated);
  }
  return ɵɵtextInterpolate2;
}
function ɵɵtextInterpolate3(prefix, v0, i0, v1, i1, v2, suffix) {
  const lView = getLView();
  const interpolated = interpolation3(lView, prefix, v0, i0, v1, i1, v2, suffix);
  if (interpolated !== NO_CHANGE) {
    textBindingInternal(lView, getSelectedIndex(), interpolated);
  }
  return ɵɵtextInterpolate3;
}
function ɵɵtextInterpolate4(prefix, v0, i0, v1, i1, v2, i2, v3, suffix) {
  const lView = getLView();
  const interpolated = interpolation4(lView, prefix, v0, i0, v1, i1, v2, i2, v3, suffix);
  if (interpolated !== NO_CHANGE) {
    textBindingInternal(lView, getSelectedIndex(), interpolated);
  }
  return ɵɵtextInterpolate4;
}
function ɵɵtextInterpolate5(prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, suffix) {
  const lView = getLView();
  const interpolated = interpolation5(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, suffix);
  if (interpolated !== NO_CHANGE) {
    textBindingInternal(lView, getSelectedIndex(), interpolated);
  }
  return ɵɵtextInterpolate5;
}
function ɵɵtextInterpolate6(prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, suffix) {
  const lView = getLView();
  const interpolated = interpolation6(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, suffix);
  if (interpolated !== NO_CHANGE) {
    textBindingInternal(lView, getSelectedIndex(), interpolated);
  }
  return ɵɵtextInterpolate6;
}
function ɵɵtextInterpolate7(prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, suffix) {
  const lView = getLView();
  const interpolated = interpolation7(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, suffix);
  if (interpolated !== NO_CHANGE) {
    textBindingInternal(lView, getSelectedIndex(), interpolated);
  }
  return ɵɵtextInterpolate7;
}
function ɵɵtextInterpolate8(prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, i6, v7, suffix) {
  const lView = getLView();
  const interpolated = interpolation8(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, i6, v7, suffix);
  if (interpolated !== NO_CHANGE) {
    textBindingInternal(lView, getSelectedIndex(), interpolated);
  }
  return ɵɵtextInterpolate8;
}
function ɵɵtextInterpolateV(values) {
  const lView = getLView();
  const interpolated = interpolationV(lView, values);
  if (interpolated !== NO_CHANGE) {
    textBindingInternal(lView, getSelectedIndex(), interpolated);
  }
  return ɵɵtextInterpolateV;
}
function ɵɵtwoWayProperty(propName, value, sanitizer) {
  if (isWritableSignal(value)) {
    value = value();
  }
  const lView = getLView();
  const bindingIndex = nextBindingIndex();
  if (bindingUpdated(lView, bindingIndex, value)) {
    const tView = getTView();
    const tNode = getSelectedTNode();
    elementPropertyInternal(tView, tNode, lView, propName, value, lView[RENDERER], sanitizer, false);
    ngDevMode && storePropertyBindingMetadata(tView.data, tNode, propName, bindingIndex);
  }
  return ɵɵtwoWayProperty;
}
function ɵɵtwoWayBindingSet(target, value) {
  const canWrite = isWritableSignal(target);
  canWrite && target.set(value);
  return canWrite;
}
function ɵɵtwoWayListener(eventName, listenerFn) {
  const lView = getLView();
  const tView = getTView();
  const tNode = getCurrentTNode();
  listenerInternal(tView, lView, lView[RENDERER], tNode, eventName, listenerFn);
  return ɵɵtwoWayListener;
}
var UNINITIALIZED_LET = {};
function ɵɵdeclareLet(index) {
  const tView = getTView();
  const lView = getLView();
  const adjustedIndex = index + HEADER_OFFSET;
  const tNode = getOrCreateTNode(tView, adjustedIndex, 128, null, null);
  setCurrentTNode(tNode, false);
  store(tView, lView, adjustedIndex, UNINITIALIZED_LET);
  return ɵɵdeclareLet;
}
function ɵɵstoreLet(value) {
  performanceMarkFeature("NgLet");
  const tView = getTView();
  const lView = getLView();
  const index = getSelectedIndex();
  store(tView, lView, index, value);
  return value;
}
function ɵɵreadContextLet(index) {
  const contextLView = getContextLView();
  const value = load(contextLView, HEADER_OFFSET + index);
  if (value === UNINITIALIZED_LET) {
    throw new RuntimeError(314, ngDevMode && "Attempting to access a @let declaration whose value is not available yet");
  }
  return value;
}
function providersResolver(def, providers, viewProviders) {
  const tView = getTView();
  if (tView.firstCreatePass) {
    const isComponent2 = isComponentDef(def);
    resolveProvider(viewProviders, tView.data, tView.blueprint, isComponent2, true);
    resolveProvider(providers, tView.data, tView.blueprint, isComponent2, false);
  }
}
function resolveProvider(provider, tInjectables, lInjectablesBlueprint, isComponent2, isViewProvider) {
  provider = resolveForwardRef(provider);
  if (Array.isArray(provider)) {
    for (let i = 0; i < provider.length; i++) {
      resolveProvider(provider[i], tInjectables, lInjectablesBlueprint, isComponent2, isViewProvider);
    }
  } else {
    const tView = getTView();
    const lView = getLView();
    const tNode = getCurrentTNode();
    let token = isTypeProvider(provider) ? provider : resolveForwardRef(provider.provide);
    const providerFactory = providerToFactory(provider);
    if (ngDevMode) {
      const injector = new NodeInjector(tNode, lView);
      runInInjectorProfilerContext(injector, token, () => {
        emitProviderConfiguredEvent(provider, isViewProvider);
      });
    }
    const beginIndex = tNode.providerIndexes & 1048575;
    const endIndex = tNode.directiveStart;
    const cptViewProvidersCount = tNode.providerIndexes >> 20;
    if (isTypeProvider(provider) || !provider.multi) {
      const factory = new NodeInjectorFactory(providerFactory, isViewProvider, ɵɵdirectiveInject);
      const existingFactoryIndex = indexOf(token, tInjectables, isViewProvider ? beginIndex : beginIndex + cptViewProvidersCount, endIndex);
      if (existingFactoryIndex === -1) {
        diPublicInInjector(getOrCreateNodeInjectorForNode(tNode, lView), tView, token);
        registerDestroyHooksIfSupported(tView, provider, tInjectables.length);
        tInjectables.push(token);
        tNode.directiveStart++;
        tNode.directiveEnd++;
        if (isViewProvider) {
          tNode.providerIndexes += 1048576;
        }
        lInjectablesBlueprint.push(factory);
        lView.push(factory);
      } else {
        lInjectablesBlueprint[existingFactoryIndex] = factory;
        lView[existingFactoryIndex] = factory;
      }
    } else {
      const existingProvidersFactoryIndex = indexOf(token, tInjectables, beginIndex + cptViewProvidersCount, endIndex);
      const existingViewProvidersFactoryIndex = indexOf(token, tInjectables, beginIndex, beginIndex + cptViewProvidersCount);
      const doesProvidersFactoryExist = existingProvidersFactoryIndex >= 0 && lInjectablesBlueprint[existingProvidersFactoryIndex];
      const doesViewProvidersFactoryExist = existingViewProvidersFactoryIndex >= 0 && lInjectablesBlueprint[existingViewProvidersFactoryIndex];
      if (isViewProvider && !doesViewProvidersFactoryExist || !isViewProvider && !doesProvidersFactoryExist) {
        diPublicInInjector(getOrCreateNodeInjectorForNode(tNode, lView), tView, token);
        const factory = multiFactory(isViewProvider ? multiViewProvidersFactoryResolver : multiProvidersFactoryResolver, lInjectablesBlueprint.length, isViewProvider, isComponent2, providerFactory);
        if (!isViewProvider && doesViewProvidersFactoryExist) {
          lInjectablesBlueprint[existingViewProvidersFactoryIndex].providerFactory = factory;
        }
        registerDestroyHooksIfSupported(tView, provider, tInjectables.length, 0);
        tInjectables.push(token);
        tNode.directiveStart++;
        tNode.directiveEnd++;
        if (isViewProvider) {
          tNode.providerIndexes += 1048576;
        }
        lInjectablesBlueprint.push(factory);
        lView.push(factory);
      } else {
        const indexInFactory = multiFactoryAdd(lInjectablesBlueprint[isViewProvider ? existingViewProvidersFactoryIndex : existingProvidersFactoryIndex], providerFactory, !isViewProvider && isComponent2);
        registerDestroyHooksIfSupported(tView, provider, existingProvidersFactoryIndex > -1 ? existingProvidersFactoryIndex : existingViewProvidersFactoryIndex, indexInFactory);
      }
      if (!isViewProvider && isComponent2 && doesViewProvidersFactoryExist) {
        lInjectablesBlueprint[existingViewProvidersFactoryIndex].componentProviders++;
      }
    }
  }
}
function registerDestroyHooksIfSupported(tView, provider, contextIndex, indexInFactory) {
  const providerIsTypeProvider = isTypeProvider(provider);
  const providerIsClassProvider = isClassProvider(provider);
  if (providerIsTypeProvider || providerIsClassProvider) {
    const classToken = providerIsClassProvider ? resolveForwardRef(provider.useClass) : provider;
    const prototype = classToken.prototype;
    const ngOnDestroy = prototype.ngOnDestroy;
    if (ngOnDestroy) {
      const hooks = tView.destroyHooks || (tView.destroyHooks = []);
      if (!providerIsTypeProvider && provider.multi) {
        ngDevMode && assertDefined(indexInFactory, "indexInFactory when registering multi factory destroy hook");
        const existingCallbacksIndex = hooks.indexOf(contextIndex);
        if (existingCallbacksIndex === -1) {
          hooks.push(contextIndex, [indexInFactory, ngOnDestroy]);
        } else {
          hooks[existingCallbacksIndex + 1].push(indexInFactory, ngOnDestroy);
        }
      } else {
        hooks.push(contextIndex, ngOnDestroy);
      }
    }
  }
}
function multiFactoryAdd(multiFactory2, factory, isComponentProvider) {
  if (isComponentProvider) {
    multiFactory2.componentProviders++;
  }
  return multiFactory2.multi.push(factory) - 1;
}
function indexOf(item, arr, begin, end) {
  for (let i = begin; i < end; i++) {
    if (arr[i] === item) return i;
  }
  return -1;
}
function multiProvidersFactoryResolver(_, tData, lData, tNode) {
  return multiResolve(this.multi, []);
}
function multiViewProvidersFactoryResolver(_, tData, lView, tNode) {
  const factories = this.multi;
  let result;
  if (this.providerFactory) {
    const componentCount = this.providerFactory.componentProviders;
    const multiProviders = getNodeInjectable(lView, lView[TVIEW], this.providerFactory.index, tNode);
    result = multiProviders.slice(0, componentCount);
    multiResolve(factories, result);
    for (let i = componentCount; i < multiProviders.length; i++) {
      result.push(multiProviders[i]);
    }
  } else {
    result = [];
    multiResolve(factories, result);
  }
  return result;
}
function multiResolve(factories, result) {
  for (let i = 0; i < factories.length; i++) {
    const factory = factories[i];
    result.push(factory());
  }
  return result;
}
function multiFactory(factoryFn, index, isViewProvider, isComponent2, f) {
  const factory = new NodeInjectorFactory(factoryFn, isViewProvider, ɵɵdirectiveInject);
  factory.multi = [];
  factory.index = index;
  factory.componentProviders = 0;
  multiFactoryAdd(factory, f, isComponent2 && !isViewProvider);
  return factory;
}
function ɵɵProvidersFeature(providers, viewProviders = []) {
  return (definition) => {
    definition.providersResolver = (def, processProvidersFn) => {
      return providersResolver(
        def,
        //
        processProvidersFn ? processProvidersFn(providers) : providers,
        //
        viewProviders
      );
    };
  };
}
var StandaloneService = class _StandaloneService {
  constructor(_injector) {
    this._injector = _injector;
    this.cachedInjectors = /* @__PURE__ */ new Map();
  }
  getOrCreateStandaloneInjector(componentDef) {
    if (!componentDef.standalone) {
      return null;
    }
    if (!this.cachedInjectors.has(componentDef)) {
      const providers = internalImportProvidersFrom(false, componentDef.type);
      const standaloneInjector = providers.length > 0 ? createEnvironmentInjector([providers], this._injector, `Standalone[${componentDef.type.name}]`) : null;
      this.cachedInjectors.set(componentDef, standaloneInjector);
    }
    return this.cachedInjectors.get(componentDef);
  }
  ngOnDestroy() {
    try {
      for (const injector of this.cachedInjectors.values()) {
        if (injector !== null) {
          injector.destroy();
        }
      }
    } finally {
      this.cachedInjectors.clear();
    }
  }
  static {
    this.ɵprov = ɵɵdefineInjectable({
      token: _StandaloneService,
      providedIn: "environment",
      factory: () => new _StandaloneService(ɵɵinject(EnvironmentInjector))
    });
  }
};
function ɵɵStandaloneFeature(definition) {
  performanceMarkFeature("NgStandalone");
  definition.getStandaloneInjector = (parentInjector) => {
    return parentInjector.get(StandaloneService).getOrCreateStandaloneInjector(definition);
  };
}
function ɵɵsetComponentScope(type, directives, pipes) {
  const def = type.ɵcmp;
  def.directiveDefs = extractDefListOrFactory(
    directives,
    /* pipeDef */
    false
  );
  def.pipeDefs = extractDefListOrFactory(
    pipes,
    /* pipeDef */
    true
  );
}
function ɵɵsetNgModuleScope(type, scope) {
  return noSideEffects(() => {
    const ngModuleDef = getNgModuleDef(type, true);
    ngModuleDef.declarations = convertToTypeArray(scope.declarations || EMPTY_ARRAY);
    ngModuleDef.imports = convertToTypeArray(scope.imports || EMPTY_ARRAY);
    ngModuleDef.exports = convertToTypeArray(scope.exports || EMPTY_ARRAY);
    if (scope.bootstrap) {
      ngModuleDef.bootstrap = convertToTypeArray(scope.bootstrap);
    }
    depsTracker.registerNgModule(type, scope);
  });
}
function convertToTypeArray(values) {
  if (typeof values === "function") {
    return values;
  }
  const flattenValues = flatten(values);
  if (flattenValues.some(isForwardRef)) {
    return () => flattenValues.map(resolveForwardRef).map(maybeUnwrapModuleWithProviders);
  } else {
    return flattenValues.map(maybeUnwrapModuleWithProviders);
  }
}
function maybeUnwrapModuleWithProviders(value) {
  return isModuleWithProviders(value) ? value.ngModule : value;
}
var ASYNC_COMPONENT_METADATA_FN = "__ngAsyncComponentMetadataFn__";
function getAsyncClassMetadataFn(type) {
  const componentClass = type;
  return componentClass[ASYNC_COMPONENT_METADATA_FN] ?? null;
}
function setClassMetadataAsync(type, dependencyLoaderFn, metadataSetterFn) {
  const componentClass = type;
  componentClass[ASYNC_COMPONENT_METADATA_FN] = () => Promise.all(dependencyLoaderFn()).then((dependencies) => {
    metadataSetterFn(...dependencies);
    componentClass[ASYNC_COMPONENT_METADATA_FN] = null;
    return dependencies;
  });
  return componentClass[ASYNC_COMPONENT_METADATA_FN];
}
function setClassMetadata(type, decorators, ctorParameters, propDecorators) {
  return noSideEffects(() => {
    const clazz = type;
    if (decorators !== null) {
      if (clazz.hasOwnProperty("decorators") && clazz.decorators !== void 0) {
        clazz.decorators.push(...decorators);
      } else {
        clazz.decorators = decorators;
      }
    }
    if (ctorParameters !== null) {
      clazz.ctorParameters = ctorParameters;
    }
    if (propDecorators !== null) {
      if (clazz.hasOwnProperty("propDecorators") && clazz.propDecorators !== void 0) {
        clazz.propDecorators = __spreadValues(__spreadValues({}, clazz.propDecorators), propDecorators);
      } else {
        clazz.propDecorators = propDecorators;
      }
    }
  });
}
function ɵɵpureFunction0(slotOffset, pureFn, thisArg) {
  const bindingIndex = getBindingRoot() + slotOffset;
  const lView = getLView();
  return lView[bindingIndex] === NO_CHANGE ? updateBinding(lView, bindingIndex, thisArg ? pureFn.call(thisArg) : pureFn()) : getBinding(lView, bindingIndex);
}
function ɵɵpureFunction1(slotOffset, pureFn, exp, thisArg) {
  return pureFunction1Internal(getLView(), getBindingRoot(), slotOffset, pureFn, exp, thisArg);
}
function ɵɵpureFunction2(slotOffset, pureFn, exp1, exp2, thisArg) {
  return pureFunction2Internal(getLView(), getBindingRoot(), slotOffset, pureFn, exp1, exp2, thisArg);
}
function ɵɵpureFunction3(slotOffset, pureFn, exp1, exp2, exp3, thisArg) {
  return pureFunction3Internal(getLView(), getBindingRoot(), slotOffset, pureFn, exp1, exp2, exp3, thisArg);
}
function ɵɵpureFunction4(slotOffset, pureFn, exp1, exp2, exp3, exp4, thisArg) {
  return pureFunction4Internal(getLView(), getBindingRoot(), slotOffset, pureFn, exp1, exp2, exp3, exp4, thisArg);
}
function ɵɵpureFunction5(slotOffset, pureFn, exp1, exp2, exp3, exp4, exp5, thisArg) {
  const bindingIndex = getBindingRoot() + slotOffset;
  const lView = getLView();
  const different = bindingUpdated4(lView, bindingIndex, exp1, exp2, exp3, exp4);
  return bindingUpdated(lView, bindingIndex + 4, exp5) || different ? updateBinding(lView, bindingIndex + 5, thisArg ? pureFn.call(thisArg, exp1, exp2, exp3, exp4, exp5) : pureFn(exp1, exp2, exp3, exp4, exp5)) : getBinding(lView, bindingIndex + 5);
}
function ɵɵpureFunction6(slotOffset, pureFn, exp1, exp2, exp3, exp4, exp5, exp6, thisArg) {
  const bindingIndex = getBindingRoot() + slotOffset;
  const lView = getLView();
  const different = bindingUpdated4(lView, bindingIndex, exp1, exp2, exp3, exp4);
  return bindingUpdated2(lView, bindingIndex + 4, exp5, exp6) || different ? updateBinding(lView, bindingIndex + 6, thisArg ? pureFn.call(thisArg, exp1, exp2, exp3, exp4, exp5, exp6) : pureFn(exp1, exp2, exp3, exp4, exp5, exp6)) : getBinding(lView, bindingIndex + 6);
}
function ɵɵpureFunction7(slotOffset, pureFn, exp1, exp2, exp3, exp4, exp5, exp6, exp7, thisArg) {
  const bindingIndex = getBindingRoot() + slotOffset;
  const lView = getLView();
  let different = bindingUpdated4(lView, bindingIndex, exp1, exp2, exp3, exp4);
  return bindingUpdated3(lView, bindingIndex + 4, exp5, exp6, exp7) || different ? updateBinding(lView, bindingIndex + 7, thisArg ? pureFn.call(thisArg, exp1, exp2, exp3, exp4, exp5, exp6, exp7) : pureFn(exp1, exp2, exp3, exp4, exp5, exp6, exp7)) : getBinding(lView, bindingIndex + 7);
}
function ɵɵpureFunction8(slotOffset, pureFn, exp1, exp2, exp3, exp4, exp5, exp6, exp7, exp8, thisArg) {
  const bindingIndex = getBindingRoot() + slotOffset;
  const lView = getLView();
  const different = bindingUpdated4(lView, bindingIndex, exp1, exp2, exp3, exp4);
  return bindingUpdated4(lView, bindingIndex + 4, exp5, exp6, exp7, exp8) || different ? updateBinding(lView, bindingIndex + 8, thisArg ? pureFn.call(thisArg, exp1, exp2, exp3, exp4, exp5, exp6, exp7, exp8) : pureFn(exp1, exp2, exp3, exp4, exp5, exp6, exp7, exp8)) : getBinding(lView, bindingIndex + 8);
}
function ɵɵpureFunctionV(slotOffset, pureFn, exps, thisArg) {
  return pureFunctionVInternal(getLView(), getBindingRoot(), slotOffset, pureFn, exps, thisArg);
}
function getPureFunctionReturnValue(lView, returnValueIndex) {
  ngDevMode && assertIndexInRange(lView, returnValueIndex);
  const lastReturnValue = lView[returnValueIndex];
  return lastReturnValue === NO_CHANGE ? void 0 : lastReturnValue;
}
function pureFunction1Internal(lView, bindingRoot, slotOffset, pureFn, exp, thisArg) {
  const bindingIndex = bindingRoot + slotOffset;
  return bindingUpdated(lView, bindingIndex, exp) ? updateBinding(lView, bindingIndex + 1, thisArg ? pureFn.call(thisArg, exp) : pureFn(exp)) : getPureFunctionReturnValue(lView, bindingIndex + 1);
}
function pureFunction2Internal(lView, bindingRoot, slotOffset, pureFn, exp1, exp2, thisArg) {
  const bindingIndex = bindingRoot + slotOffset;
  return bindingUpdated2(lView, bindingIndex, exp1, exp2) ? updateBinding(lView, bindingIndex + 2, thisArg ? pureFn.call(thisArg, exp1, exp2) : pureFn(exp1, exp2)) : getPureFunctionReturnValue(lView, bindingIndex + 2);
}
function pureFunction3Internal(lView, bindingRoot, slotOffset, pureFn, exp1, exp2, exp3, thisArg) {
  const bindingIndex = bindingRoot + slotOffset;
  return bindingUpdated3(lView, bindingIndex, exp1, exp2, exp3) ? updateBinding(lView, bindingIndex + 3, thisArg ? pureFn.call(thisArg, exp1, exp2, exp3) : pureFn(exp1, exp2, exp3)) : getPureFunctionReturnValue(lView, bindingIndex + 3);
}
function pureFunction4Internal(lView, bindingRoot, slotOffset, pureFn, exp1, exp2, exp3, exp4, thisArg) {
  const bindingIndex = bindingRoot + slotOffset;
  return bindingUpdated4(lView, bindingIndex, exp1, exp2, exp3, exp4) ? updateBinding(lView, bindingIndex + 4, thisArg ? pureFn.call(thisArg, exp1, exp2, exp3, exp4) : pureFn(exp1, exp2, exp3, exp4)) : getPureFunctionReturnValue(lView, bindingIndex + 4);
}
function pureFunctionVInternal(lView, bindingRoot, slotOffset, pureFn, exps, thisArg) {
  let bindingIndex = bindingRoot + slotOffset;
  let different = false;
  for (let i = 0; i < exps.length; i++) {
    bindingUpdated(lView, bindingIndex++, exps[i]) && (different = true);
  }
  return different ? updateBinding(lView, bindingIndex, pureFn.apply(thisArg, exps)) : getPureFunctionReturnValue(lView, bindingIndex);
}
function ɵɵpipe(index, pipeName) {
  const tView = getTView();
  let pipeDef;
  const adjustedIndex = index + HEADER_OFFSET;
  if (tView.firstCreatePass) {
    pipeDef = getPipeDef(pipeName, tView.pipeRegistry);
    tView.data[adjustedIndex] = pipeDef;
    if (pipeDef.onDestroy) {
      (tView.destroyHooks ??= []).push(adjustedIndex, pipeDef.onDestroy);
    }
  } else {
    pipeDef = tView.data[adjustedIndex];
  }
  const pipeFactory = pipeDef.factory || (pipeDef.factory = getFactoryDef(pipeDef.type, true));
  let previousInjectorProfilerContext;
  if (ngDevMode) {
    previousInjectorProfilerContext = setInjectorProfilerContext({
      injector: new NodeInjector(getCurrentTNode(), getLView()),
      token: pipeDef.type
    });
  }
  const previousInjectImplementation = setInjectImplementation(ɵɵdirectiveInject);
  try {
    const previousIncludeViewProviders = setIncludeViewProviders(false);
    const pipeInstance = pipeFactory();
    setIncludeViewProviders(previousIncludeViewProviders);
    store(tView, getLView(), adjustedIndex, pipeInstance);
    return pipeInstance;
  } finally {
    setInjectImplementation(previousInjectImplementation);
    ngDevMode && setInjectorProfilerContext(previousInjectorProfilerContext);
  }
}
function getPipeDef(name, registry) {
  if (registry) {
    if (ngDevMode) {
      const pipes = registry.filter((pipe) => pipe.name === name);
      if (pipes.length > 1) {
        console.warn(formatRuntimeError(313, getMultipleMatchingPipesMessage(name)));
      }
    }
    for (let i = registry.length - 1; i >= 0; i--) {
      const pipeDef = registry[i];
      if (name === pipeDef.name) {
        return pipeDef;
      }
    }
  }
  if (ngDevMode) {
    throw new RuntimeError(-302, getPipeNotFoundErrorMessage(name));
  }
  return;
}
function getMultipleMatchingPipesMessage(name) {
  const lView = getLView();
  const declarationLView = lView[DECLARATION_COMPONENT_VIEW];
  const context = declarationLView[CONTEXT];
  const hostIsStandalone = isHostComponentStandalone(lView);
  const componentInfoMessage = context ? ` in the '${context.constructor.name}' component` : "";
  const verifyMessage = `check ${hostIsStandalone ? "'@Component.imports' of this component" : "the imports of this module"}`;
  const errorMessage = `Multiple pipes match the name \`${name}\`${componentInfoMessage}. ${verifyMessage}`;
  return errorMessage;
}
function getPipeNotFoundErrorMessage(name) {
  const lView = getLView();
  const declarationLView = lView[DECLARATION_COMPONENT_VIEW];
  const context = declarationLView[CONTEXT];
  const hostIsStandalone = isHostComponentStandalone(lView);
  const componentInfoMessage = context ? ` in the '${context.constructor.name}' component` : "";
  const verifyMessage = `Verify that it is ${hostIsStandalone ? "included in the '@Component.imports' of this component" : "declared or imported in this module"}`;
  const errorMessage = `The pipe '${name}' could not be found${componentInfoMessage}. ${verifyMessage}`;
  return errorMessage;
}
function ɵɵpipeBind1(index, offset, v1) {
  const adjustedIndex = index + HEADER_OFFSET;
  const lView = getLView();
  const pipeInstance = load(lView, adjustedIndex);
  return isPure(lView, adjustedIndex) ? pureFunction1Internal(lView, getBindingRoot(), offset, pipeInstance.transform, v1, pipeInstance) : pipeInstance.transform(v1);
}
function ɵɵpipeBind2(index, slotOffset, v1, v2) {
  const adjustedIndex = index + HEADER_OFFSET;
  const lView = getLView();
  const pipeInstance = load(lView, adjustedIndex);
  return isPure(lView, adjustedIndex) ? pureFunction2Internal(lView, getBindingRoot(), slotOffset, pipeInstance.transform, v1, v2, pipeInstance) : pipeInstance.transform(v1, v2);
}
function ɵɵpipeBind3(index, slotOffset, v1, v2, v3) {
  const adjustedIndex = index + HEADER_OFFSET;
  const lView = getLView();
  const pipeInstance = load(lView, adjustedIndex);
  return isPure(lView, adjustedIndex) ? pureFunction3Internal(lView, getBindingRoot(), slotOffset, pipeInstance.transform, v1, v2, v3, pipeInstance) : pipeInstance.transform(v1, v2, v3);
}
function ɵɵpipeBind4(index, slotOffset, v1, v2, v3, v4) {
  const adjustedIndex = index + HEADER_OFFSET;
  const lView = getLView();
  const pipeInstance = load(lView, adjustedIndex);
  return isPure(lView, adjustedIndex) ? pureFunction4Internal(lView, getBindingRoot(), slotOffset, pipeInstance.transform, v1, v2, v3, v4, pipeInstance) : pipeInstance.transform(v1, v2, v3, v4);
}
function ɵɵpipeBindV(index, slotOffset, values) {
  const adjustedIndex = index + HEADER_OFFSET;
  const lView = getLView();
  const pipeInstance = load(lView, adjustedIndex);
  return isPure(lView, adjustedIndex) ? pureFunctionVInternal(lView, getBindingRoot(), slotOffset, pipeInstance.transform, values, pipeInstance) : pipeInstance.transform.apply(pipeInstance, values);
}
function isPure(lView, index) {
  return lView[TVIEW].data[index].pure;
}
function ɵɵtemplateRefExtractor(tNode, lView) {
  return createTemplateRef(tNode, lView);
}
function ɵɵgetComponentDepsFactory(type, rawImports) {
  return () => {
    try {
      return depsTracker.getComponentDependencies(type, rawImports).dependencies;
    } catch (e) {
      console.error(`Computing dependencies in local compilation mode for the component "${type.name}" failed with the exception:`, e);
      throw e;
    }
  };
}
function ɵsetClassDebugInfo(type, debugInfo) {
  const def = getComponentDef(type);
  if (def !== null) {
    def.debugInfo = debugInfo;
  }
}
var angularCoreEnv = /* @__PURE__ */ (() => ({
  "ɵɵattribute": ɵɵattribute,
  "ɵɵattributeInterpolate1": ɵɵattributeInterpolate1,
  "ɵɵattributeInterpolate2": ɵɵattributeInterpolate2,
  "ɵɵattributeInterpolate3": ɵɵattributeInterpolate3,
  "ɵɵattributeInterpolate4": ɵɵattributeInterpolate4,
  "ɵɵattributeInterpolate5": ɵɵattributeInterpolate5,
  "ɵɵattributeInterpolate6": ɵɵattributeInterpolate6,
  "ɵɵattributeInterpolate7": ɵɵattributeInterpolate7,
  "ɵɵattributeInterpolate8": ɵɵattributeInterpolate8,
  "ɵɵattributeInterpolateV": ɵɵattributeInterpolateV,
  "ɵɵdefineComponent": ɵɵdefineComponent,
  "ɵɵdefineDirective": ɵɵdefineDirective,
  "ɵɵdefineInjectable": ɵɵdefineInjectable,
  "ɵɵdefineInjector": ɵɵdefineInjector,
  "ɵɵdefineNgModule": ɵɵdefineNgModule,
  "ɵɵdefinePipe": ɵɵdefinePipe,
  "ɵɵdirectiveInject": ɵɵdirectiveInject,
  "ɵɵgetInheritedFactory": ɵɵgetInheritedFactory,
  "ɵɵinject": ɵɵinject,
  "ɵɵinjectAttribute": ɵɵinjectAttribute,
  "ɵɵinvalidFactory": ɵɵinvalidFactory,
  "ɵɵinvalidFactoryDep": ɵɵinvalidFactoryDep,
  "ɵɵtemplateRefExtractor": ɵɵtemplateRefExtractor,
  "ɵɵresetView": ɵɵresetView,
  "ɵɵHostDirectivesFeature": ɵɵHostDirectivesFeature,
  "ɵɵNgOnChangesFeature": ɵɵNgOnChangesFeature,
  "ɵɵProvidersFeature": ɵɵProvidersFeature,
  "ɵɵCopyDefinitionFeature": ɵɵCopyDefinitionFeature,
  "ɵɵInheritDefinitionFeature": ɵɵInheritDefinitionFeature,
  "ɵɵInputTransformsFeature": ɵɵInputTransformsFeature,
  "ɵɵStandaloneFeature": ɵɵStandaloneFeature,
  "ɵɵnextContext": ɵɵnextContext,
  "ɵɵnamespaceHTML": ɵɵnamespaceHTML,
  "ɵɵnamespaceMathML": ɵɵnamespaceMathML,
  "ɵɵnamespaceSVG": ɵɵnamespaceSVG,
  "ɵɵenableBindings": ɵɵenableBindings,
  "ɵɵdisableBindings": ɵɵdisableBindings,
  "ɵɵelementStart": ɵɵelementStart,
  "ɵɵelementEnd": ɵɵelementEnd,
  "ɵɵelement": ɵɵelement,
  "ɵɵelementContainerStart": ɵɵelementContainerStart,
  "ɵɵelementContainerEnd": ɵɵelementContainerEnd,
  "ɵɵelementContainer": ɵɵelementContainer,
  "ɵɵpureFunction0": ɵɵpureFunction0,
  "ɵɵpureFunction1": ɵɵpureFunction1,
  "ɵɵpureFunction2": ɵɵpureFunction2,
  "ɵɵpureFunction3": ɵɵpureFunction3,
  "ɵɵpureFunction4": ɵɵpureFunction4,
  "ɵɵpureFunction5": ɵɵpureFunction5,
  "ɵɵpureFunction6": ɵɵpureFunction6,
  "ɵɵpureFunction7": ɵɵpureFunction7,
  "ɵɵpureFunction8": ɵɵpureFunction8,
  "ɵɵpureFunctionV": ɵɵpureFunctionV,
  "ɵɵgetCurrentView": ɵɵgetCurrentView,
  "ɵɵrestoreView": ɵɵrestoreView,
  "ɵɵlistener": ɵɵlistener,
  "ɵɵprojection": ɵɵprojection,
  "ɵɵsyntheticHostProperty": ɵɵsyntheticHostProperty,
  "ɵɵsyntheticHostListener": ɵɵsyntheticHostListener,
  "ɵɵpipeBind1": ɵɵpipeBind1,
  "ɵɵpipeBind2": ɵɵpipeBind2,
  "ɵɵpipeBind3": ɵɵpipeBind3,
  "ɵɵpipeBind4": ɵɵpipeBind4,
  "ɵɵpipeBindV": ɵɵpipeBindV,
  "ɵɵprojectionDef": ɵɵprojectionDef,
  "ɵɵhostProperty": ɵɵhostProperty,
  "ɵɵproperty": ɵɵproperty,
  "ɵɵpropertyInterpolate": ɵɵpropertyInterpolate,
  "ɵɵpropertyInterpolate1": ɵɵpropertyInterpolate1,
  "ɵɵpropertyInterpolate2": ɵɵpropertyInterpolate2,
  "ɵɵpropertyInterpolate3": ɵɵpropertyInterpolate3,
  "ɵɵpropertyInterpolate4": ɵɵpropertyInterpolate4,
  "ɵɵpropertyInterpolate5": ɵɵpropertyInterpolate5,
  "ɵɵpropertyInterpolate6": ɵɵpropertyInterpolate6,
  "ɵɵpropertyInterpolate7": ɵɵpropertyInterpolate7,
  "ɵɵpropertyInterpolate8": ɵɵpropertyInterpolate8,
  "ɵɵpropertyInterpolateV": ɵɵpropertyInterpolateV,
  "ɵɵpipe": ɵɵpipe,
  "ɵɵqueryRefresh": ɵɵqueryRefresh,
  "ɵɵqueryAdvance": ɵɵqueryAdvance,
  "ɵɵviewQuery": ɵɵviewQuery,
  "ɵɵviewQuerySignal": ɵɵviewQuerySignal,
  "ɵɵloadQuery": ɵɵloadQuery,
  "ɵɵcontentQuery": ɵɵcontentQuery,
  "ɵɵcontentQuerySignal": ɵɵcontentQuerySignal,
  "ɵɵreference": ɵɵreference,
  "ɵɵclassMap": ɵɵclassMap,
  "ɵɵclassMapInterpolate1": ɵɵclassMapInterpolate1,
  "ɵɵclassMapInterpolate2": ɵɵclassMapInterpolate2,
  "ɵɵclassMapInterpolate3": ɵɵclassMapInterpolate3,
  "ɵɵclassMapInterpolate4": ɵɵclassMapInterpolate4,
  "ɵɵclassMapInterpolate5": ɵɵclassMapInterpolate5,
  "ɵɵclassMapInterpolate6": ɵɵclassMapInterpolate6,
  "ɵɵclassMapInterpolate7": ɵɵclassMapInterpolate7,
  "ɵɵclassMapInterpolate8": ɵɵclassMapInterpolate8,
  "ɵɵclassMapInterpolateV": ɵɵclassMapInterpolateV,
  "ɵɵstyleMap": ɵɵstyleMap,
  "ɵɵstyleMapInterpolate1": ɵɵstyleMapInterpolate1,
  "ɵɵstyleMapInterpolate2": ɵɵstyleMapInterpolate2,
  "ɵɵstyleMapInterpolate3": ɵɵstyleMapInterpolate3,
  "ɵɵstyleMapInterpolate4": ɵɵstyleMapInterpolate4,
  "ɵɵstyleMapInterpolate5": ɵɵstyleMapInterpolate5,
  "ɵɵstyleMapInterpolate6": ɵɵstyleMapInterpolate6,
  "ɵɵstyleMapInterpolate7": ɵɵstyleMapInterpolate7,
  "ɵɵstyleMapInterpolate8": ɵɵstyleMapInterpolate8,
  "ɵɵstyleMapInterpolateV": ɵɵstyleMapInterpolateV,
  "ɵɵstyleProp": ɵɵstyleProp,
  "ɵɵstylePropInterpolate1": ɵɵstylePropInterpolate1,
  "ɵɵstylePropInterpolate2": ɵɵstylePropInterpolate2,
  "ɵɵstylePropInterpolate3": ɵɵstylePropInterpolate3,
  "ɵɵstylePropInterpolate4": ɵɵstylePropInterpolate4,
  "ɵɵstylePropInterpolate5": ɵɵstylePropInterpolate5,
  "ɵɵstylePropInterpolate6": ɵɵstylePropInterpolate6,
  "ɵɵstylePropInterpolate7": ɵɵstylePropInterpolate7,
  "ɵɵstylePropInterpolate8": ɵɵstylePropInterpolate8,
  "ɵɵstylePropInterpolateV": ɵɵstylePropInterpolateV,
  "ɵɵclassProp": ɵɵclassProp,
  "ɵɵadvance": ɵɵadvance,
  "ɵɵtemplate": ɵɵtemplate,
  "ɵɵconditional": ɵɵconditional,
  "ɵɵdefer": ɵɵdefer,
  "ɵɵdeferWhen": ɵɵdeferWhen,
  "ɵɵdeferOnIdle": ɵɵdeferOnIdle,
  "ɵɵdeferOnImmediate": ɵɵdeferOnImmediate,
  "ɵɵdeferOnTimer": ɵɵdeferOnTimer,
  "ɵɵdeferOnHover": ɵɵdeferOnHover,
  "ɵɵdeferOnInteraction": ɵɵdeferOnInteraction,
  "ɵɵdeferOnViewport": ɵɵdeferOnViewport,
  "ɵɵdeferPrefetchWhen": ɵɵdeferPrefetchWhen,
  "ɵɵdeferPrefetchOnIdle": ɵɵdeferPrefetchOnIdle,
  "ɵɵdeferPrefetchOnImmediate": ɵɵdeferPrefetchOnImmediate,
  "ɵɵdeferPrefetchOnTimer": ɵɵdeferPrefetchOnTimer,
  "ɵɵdeferPrefetchOnHover": ɵɵdeferPrefetchOnHover,
  "ɵɵdeferPrefetchOnInteraction": ɵɵdeferPrefetchOnInteraction,
  "ɵɵdeferPrefetchOnViewport": ɵɵdeferPrefetchOnViewport,
  "ɵɵdeferEnableTimerScheduling": ɵɵdeferEnableTimerScheduling,
  "ɵɵrepeater": ɵɵrepeater,
  "ɵɵrepeaterCreate": ɵɵrepeaterCreate,
  "ɵɵrepeaterTrackByIndex": ɵɵrepeaterTrackByIndex,
  "ɵɵrepeaterTrackByIdentity": ɵɵrepeaterTrackByIdentity,
  "ɵɵcomponentInstance": ɵɵcomponentInstance,
  "ɵɵtext": ɵɵtext,
  "ɵɵtextInterpolate": ɵɵtextInterpolate,
  "ɵɵtextInterpolate1": ɵɵtextInterpolate1,
  "ɵɵtextInterpolate2": ɵɵtextInterpolate2,
  "ɵɵtextInterpolate3": ɵɵtextInterpolate3,
  "ɵɵtextInterpolate4": ɵɵtextInterpolate4,
  "ɵɵtextInterpolate5": ɵɵtextInterpolate5,
  "ɵɵtextInterpolate6": ɵɵtextInterpolate6,
  "ɵɵtextInterpolate7": ɵɵtextInterpolate7,
  "ɵɵtextInterpolate8": ɵɵtextInterpolate8,
  "ɵɵtextInterpolateV": ɵɵtextInterpolateV,
  "ɵɵi18n": ɵɵi18n,
  "ɵɵi18nAttributes": ɵɵi18nAttributes,
  "ɵɵi18nExp": ɵɵi18nExp,
  "ɵɵi18nStart": ɵɵi18nStart,
  "ɵɵi18nEnd": ɵɵi18nEnd,
  "ɵɵi18nApply": ɵɵi18nApply,
  "ɵɵi18nPostprocess": ɵɵi18nPostprocess,
  "ɵɵresolveWindow": ɵɵresolveWindow,
  "ɵɵresolveDocument": ɵɵresolveDocument,
  "ɵɵresolveBody": ɵɵresolveBody,
  "ɵɵsetComponentScope": ɵɵsetComponentScope,
  "ɵɵsetNgModuleScope": ɵɵsetNgModuleScope,
  "ɵɵregisterNgModuleType": registerNgModuleType,
  "ɵɵgetComponentDepsFactory": ɵɵgetComponentDepsFactory,
  "ɵsetClassDebugInfo": ɵsetClassDebugInfo,
  "ɵɵdeclareLet": ɵɵdeclareLet,
  "ɵɵstoreLet": ɵɵstoreLet,
  "ɵɵreadContextLet": ɵɵreadContextLet,
  "ɵɵsanitizeHtml": ɵɵsanitizeHtml,
  "ɵɵsanitizeStyle": ɵɵsanitizeStyle,
  "ɵɵsanitizeResourceUrl": ɵɵsanitizeResourceUrl,
  "ɵɵsanitizeScript": ɵɵsanitizeScript,
  "ɵɵsanitizeUrl": ɵɵsanitizeUrl,
  "ɵɵsanitizeUrlOrResourceUrl": ɵɵsanitizeUrlOrResourceUrl,
  "ɵɵtrustConstantHtml": ɵɵtrustConstantHtml,
  "ɵɵtrustConstantResourceUrl": ɵɵtrustConstantResourceUrl,
  "ɵɵvalidateIframeAttribute": ɵɵvalidateIframeAttribute,
  "forwardRef": forwardRef,
  "resolveForwardRef": resolveForwardRef,
  "ɵɵtwoWayProperty": ɵɵtwoWayProperty,
  "ɵɵtwoWayBindingSet": ɵɵtwoWayBindingSet,
  "ɵɵtwoWayListener": ɵɵtwoWayListener
}))();
var jitOptions = null;
function setJitOptions(options) {
  if (jitOptions !== null) {
    if (options.defaultEncapsulation !== jitOptions.defaultEncapsulation) {
      ngDevMode && console.error("Provided value for `defaultEncapsulation` can not be changed once it has been set.");
      return;
    }
    if (options.preserveWhitespaces !== jitOptions.preserveWhitespaces) {
      ngDevMode && console.error("Provided value for `preserveWhitespaces` can not be changed once it has been set.");
      return;
    }
  }
  jitOptions = options;
}
function getJitOptions() {
  return jitOptions;
}
function resetJitOptions() {
  jitOptions = null;
}
function patchModuleCompilation() {
}
var moduleQueue = [];
function enqueueModuleForDelayedScoping(moduleType, ngModule) {
  moduleQueue.push({
    moduleType,
    ngModule
  });
}
var flushingModuleQueue = false;
function flushModuleScopingQueueAsMuchAsPossible() {
  if (!flushingModuleQueue) {
    flushingModuleQueue = true;
    try {
      for (let i = moduleQueue.length - 1; i >= 0; i--) {
        const {
          moduleType,
          ngModule
        } = moduleQueue[i];
        if (ngModule.declarations && ngModule.declarations.every(isResolvedDeclaration)) {
          moduleQueue.splice(i, 1);
          setScopeOnDeclaredComponents(moduleType, ngModule);
        }
      }
    } finally {
      flushingModuleQueue = false;
    }
  }
}
function isResolvedDeclaration(declaration) {
  if (Array.isArray(declaration)) {
    return declaration.every(isResolvedDeclaration);
  }
  return !!resolveForwardRef(declaration);
}
function compileNgModule(moduleType, ngModule = {}) {
  patchModuleCompilation();
  compileNgModuleDefs(moduleType, ngModule);
  if (ngModule.id !== void 0) {
    registerNgModuleType(moduleType, ngModule.id);
  }
  enqueueModuleForDelayedScoping(moduleType, ngModule);
}
function compileNgModuleDefs(moduleType, ngModule, allowDuplicateDeclarationsInRoot = false) {
  ngDevMode && assertDefined(moduleType, "Required value moduleType");
  ngDevMode && assertDefined(ngModule, "Required value ngModule");
  const declarations = flatten(ngModule.declarations || EMPTY_ARRAY);
  let ngModuleDef = null;
  Object.defineProperty(moduleType, NG_MOD_DEF, {
    configurable: true,
    get: () => {
      if (ngModuleDef === null) {
        if (ngDevMode && ngModule.imports && ngModule.imports.indexOf(moduleType) > -1) {
          throw new Error(`'${stringifyForError(moduleType)}' module can't import itself`);
        }
        const compiler = getCompilerFacade({
          usage: 0,
          kind: "NgModule",
          type: moduleType
        });
        ngModuleDef = compiler.compileNgModule(angularCoreEnv, `ng:///${moduleType.name}/ɵmod.js`, {
          type: moduleType,
          bootstrap: flatten(ngModule.bootstrap || EMPTY_ARRAY).map(resolveForwardRef),
          declarations: declarations.map(resolveForwardRef),
          imports: flatten(ngModule.imports || EMPTY_ARRAY).map(resolveForwardRef).map(expandModuleWithProviders),
          exports: flatten(ngModule.exports || EMPTY_ARRAY).map(resolveForwardRef).map(expandModuleWithProviders),
          schemas: ngModule.schemas ? flatten(ngModule.schemas) : null,
          id: ngModule.id || null
        });
        if (!ngModuleDef.schemas) {
          ngModuleDef.schemas = [];
        }
      }
      return ngModuleDef;
    }
  });
  let ngFactoryDef = null;
  Object.defineProperty(moduleType, NG_FACTORY_DEF, {
    get: () => {
      if (ngFactoryDef === null) {
        const compiler = getCompilerFacade({
          usage: 0,
          kind: "NgModule",
          type: moduleType
        });
        ngFactoryDef = compiler.compileFactory(angularCoreEnv, `ng:///${moduleType.name}/ɵfac.js`, {
          name: moduleType.name,
          type: moduleType,
          deps: reflectDependencies(moduleType),
          target: compiler.FactoryTarget.NgModule,
          typeArgumentCount: 0
        });
      }
      return ngFactoryDef;
    },
    // Make the property configurable in dev mode to allow overriding in tests
    configurable: !!ngDevMode
  });
  let ngInjectorDef = null;
  Object.defineProperty(moduleType, NG_INJ_DEF, {
    get: () => {
      if (ngInjectorDef === null) {
        ngDevMode && verifySemanticsOfNgModuleDef(moduleType, allowDuplicateDeclarationsInRoot);
        const meta = {
          name: moduleType.name,
          type: moduleType,
          providers: ngModule.providers || EMPTY_ARRAY,
          imports: [(ngModule.imports || EMPTY_ARRAY).map(resolveForwardRef), (ngModule.exports || EMPTY_ARRAY).map(resolveForwardRef)]
        };
        const compiler = getCompilerFacade({
          usage: 0,
          kind: "NgModule",
          type: moduleType
        });
        ngInjectorDef = compiler.compileInjector(angularCoreEnv, `ng:///${moduleType.name}/ɵinj.js`, meta);
      }
      return ngInjectorDef;
    },
    // Make the property configurable in dev mode to allow overriding in tests
    configurable: !!ngDevMode
  });
}
function generateStandaloneInDeclarationsError(type, location2) {
  const prefix = `Unexpected "${stringifyForError(type)}" found in the "declarations" array of the`;
  const suffix = `"${stringifyForError(type)}" is marked as standalone and can't be declared in any NgModule - did you intend to import it instead (by adding it to the "imports" array)?`;
  return `${prefix} ${location2}, ${suffix}`;
}
function verifySemanticsOfNgModuleDef(moduleType, allowDuplicateDeclarationsInRoot, importingModule) {
  if (verifiedNgModule.get(moduleType)) return;
  if (isStandalone(moduleType)) return;
  verifiedNgModule.set(moduleType, true);
  moduleType = resolveForwardRef(moduleType);
  let ngModuleDef;
  if (importingModule) {
    ngModuleDef = getNgModuleDef(moduleType);
    if (!ngModuleDef) {
      throw new Error(`Unexpected value '${moduleType.name}' imported by the module '${importingModule.name}'. Please add an @NgModule annotation.`);
    }
  } else {
    ngModuleDef = getNgModuleDef(moduleType, true);
  }
  const errors = [];
  const declarations = maybeUnwrapFn(ngModuleDef.declarations);
  const imports = maybeUnwrapFn(ngModuleDef.imports);
  flatten(imports).map(unwrapModuleWithProvidersImports).forEach((modOrStandaloneCmpt) => {
    verifySemanticsOfNgModuleImport(modOrStandaloneCmpt, moduleType);
    verifySemanticsOfNgModuleDef(modOrStandaloneCmpt, false, moduleType);
  });
  const exports = maybeUnwrapFn(ngModuleDef.exports);
  declarations.forEach(verifyDeclarationsHaveDefinitions);
  declarations.forEach(verifyDirectivesHaveSelector);
  declarations.forEach((declarationType) => verifyNotStandalone(declarationType, moduleType));
  const combinedDeclarations = [...declarations.map(resolveForwardRef), ...flatten(imports.map(computeCombinedExports)).map(resolveForwardRef)];
  exports.forEach(verifyExportsAreDeclaredOrReExported);
  declarations.forEach((decl) => verifyDeclarationIsUnique(decl, allowDuplicateDeclarationsInRoot));
  const ngModule = getAnnotation(moduleType, "NgModule");
  if (ngModule) {
    ngModule.imports && flatten(ngModule.imports).map(unwrapModuleWithProvidersImports).forEach((mod) => {
      verifySemanticsOfNgModuleImport(mod, moduleType);
      verifySemanticsOfNgModuleDef(mod, false, moduleType);
    });
    ngModule.bootstrap && deepForEach(ngModule.bootstrap, verifyCorrectBootstrapType);
    ngModule.bootstrap && deepForEach(ngModule.bootstrap, verifyComponentIsPartOfNgModule);
  }
  if (errors.length) {
    throw new Error(errors.join("\n"));
  }
  function verifyDeclarationsHaveDefinitions(type) {
    type = resolveForwardRef(type);
    const def = getComponentDef(type) || getDirectiveDef(type) || getPipeDef$1(type);
    if (!def) {
      errors.push(`Unexpected value '${stringifyForError(type)}' declared by the module '${stringifyForError(moduleType)}'. Please add a @Pipe/@Directive/@Component annotation.`);
    }
  }
  function verifyDirectivesHaveSelector(type) {
    type = resolveForwardRef(type);
    const def = getDirectiveDef(type);
    if (!getComponentDef(type) && def && def.selectors.length == 0) {
      errors.push(`Directive ${stringifyForError(type)} has no selector, please add it!`);
    }
  }
  function verifyNotStandalone(type, moduleType2) {
    type = resolveForwardRef(type);
    const def = getComponentDef(type) || getDirectiveDef(type) || getPipeDef$1(type);
    if (def?.standalone) {
      const location2 = `"${stringifyForError(moduleType2)}" NgModule`;
      errors.push(generateStandaloneInDeclarationsError(type, location2));
    }
  }
  function verifyExportsAreDeclaredOrReExported(type) {
    type = resolveForwardRef(type);
    const kind = getComponentDef(type) && "component" || getDirectiveDef(type) && "directive" || getPipeDef$1(type) && "pipe";
    if (kind) {
      if (combinedDeclarations.lastIndexOf(type) === -1) {
        errors.push(`Can't export ${kind} ${stringifyForError(type)} from ${stringifyForError(moduleType)} as it was neither declared nor imported!`);
      }
    }
  }
  function verifyDeclarationIsUnique(type, suppressErrors) {
    type = resolveForwardRef(type);
    const existingModule = ownerNgModule.get(type);
    if (existingModule && existingModule !== moduleType) {
      if (!suppressErrors) {
        const modules2 = [existingModule, moduleType].map(stringifyForError).sort();
        errors.push(`Type ${stringifyForError(type)} is part of the declarations of 2 modules: ${modules2[0]} and ${modules2[1]}! Please consider moving ${stringifyForError(type)} to a higher module that imports ${modules2[0]} and ${modules2[1]}. You can also create a new NgModule that exports and includes ${stringifyForError(type)} then import that NgModule in ${modules2[0]} and ${modules2[1]}.`);
      }
    } else {
      ownerNgModule.set(type, moduleType);
    }
  }
  function verifyComponentIsPartOfNgModule(type) {
    type = resolveForwardRef(type);
    const existingModule = ownerNgModule.get(type);
    if (!existingModule && !isStandalone(type)) {
      errors.push(`Component ${stringifyForError(type)} is not part of any NgModule or the module has not been imported into your module.`);
    }
  }
  function verifyCorrectBootstrapType(type) {
    type = resolveForwardRef(type);
    if (!getComponentDef(type)) {
      errors.push(`${stringifyForError(type)} cannot be used as an entry component.`);
    }
    if (isStandalone(type)) {
      errors.push(`The \`${stringifyForError(type)}\` class is a standalone component, which can not be used in the \`@NgModule.bootstrap\` array. Use the \`bootstrapApplication\` function for bootstrap instead.`);
    }
  }
  function verifySemanticsOfNgModuleImport(type, importingModule2) {
    type = resolveForwardRef(type);
    const directiveDef = getComponentDef(type) || getDirectiveDef(type);
    if (directiveDef !== null && !directiveDef.standalone) {
      throw new Error(`Unexpected directive '${type.name}' imported by the module '${importingModule2.name}'. Please add an @NgModule annotation.`);
    }
    const pipeDef = getPipeDef$1(type);
    if (pipeDef !== null && !pipeDef.standalone) {
      throw new Error(`Unexpected pipe '${type.name}' imported by the module '${importingModule2.name}'. Please add an @NgModule annotation.`);
    }
  }
}
function unwrapModuleWithProvidersImports(typeOrWithProviders) {
  typeOrWithProviders = resolveForwardRef(typeOrWithProviders);
  return typeOrWithProviders.ngModule || typeOrWithProviders;
}
function getAnnotation(type, name) {
  let annotation = null;
  collect(type.__annotations__);
  collect(type.decorators);
  return annotation;
  function collect(annotations) {
    if (annotations) {
      annotations.forEach(readAnnotation);
    }
  }
  function readAnnotation(decorator) {
    if (!annotation) {
      const proto = Object.getPrototypeOf(decorator);
      if (proto.ngMetadataName == name) {
        annotation = decorator;
      } else if (decorator.type) {
        const proto2 = Object.getPrototypeOf(decorator.type);
        if (proto2.ngMetadataName == name) {
          annotation = decorator.args[0];
        }
      }
    }
  }
}
var ownerNgModule = /* @__PURE__ */ new WeakMap();
var verifiedNgModule = /* @__PURE__ */ new WeakMap();
function resetCompiledComponents() {
  ownerNgModule = /* @__PURE__ */ new WeakMap();
  verifiedNgModule = /* @__PURE__ */ new WeakMap();
  moduleQueue.length = 0;
  GENERATED_COMP_IDS.clear();
}
function computeCombinedExports(type) {
  type = resolveForwardRef(type);
  const ngModuleDef = getNgModuleDef(type);
  if (ngModuleDef === null) {
    return [type];
  }
  return flatten(maybeUnwrapFn(ngModuleDef.exports).map((type2) => {
    const ngModuleDef2 = getNgModuleDef(type2);
    if (ngModuleDef2) {
      verifySemanticsOfNgModuleDef(type2, false);
      return computeCombinedExports(type2);
    } else {
      return type2;
    }
  }));
}
function setScopeOnDeclaredComponents(moduleType, ngModule) {
  const declarations = flatten(ngModule.declarations || EMPTY_ARRAY);
  const transitiveScopes = transitiveScopesFor(moduleType);
  declarations.forEach((declaration) => {
    declaration = resolveForwardRef(declaration);
    if (declaration.hasOwnProperty(NG_COMP_DEF)) {
      const component = declaration;
      const componentDef = getComponentDef(component);
      patchComponentDefWithScope(componentDef, transitiveScopes);
    } else if (!declaration.hasOwnProperty(NG_DIR_DEF) && !declaration.hasOwnProperty(NG_PIPE_DEF)) {
      declaration.ngSelectorScope = moduleType;
    }
  });
}
function patchComponentDefWithScope(componentDef, transitiveScopes) {
  componentDef.directiveDefs = () => Array.from(transitiveScopes.compilation.directives).map((dir) => dir.hasOwnProperty(NG_COMP_DEF) ? getComponentDef(dir) : getDirectiveDef(dir)).filter((def) => !!def);
  componentDef.pipeDefs = () => Array.from(transitiveScopes.compilation.pipes).map((pipe) => getPipeDef$1(pipe));
  componentDef.schemas = transitiveScopes.schemas;
  componentDef.tView = null;
}
function transitiveScopesFor(type) {
  if (isNgModule(type)) {
    if (USE_RUNTIME_DEPS_TRACKER_FOR_JIT) {
      const scope = depsTracker.getNgModuleScope(type);
      const def = getNgModuleDef(type, true);
      return __spreadValues({
        schemas: def.schemas || null
      }, scope);
    } else {
      return transitiveScopesForNgModule(type);
    }
  } else if (isStandalone(type)) {
    const directiveDef = getComponentDef(type) || getDirectiveDef(type);
    if (directiveDef !== null) {
      return {
        schemas: null,
        compilation: {
          directives: /* @__PURE__ */ new Set(),
          pipes: /* @__PURE__ */ new Set()
        },
        exported: {
          directives: /* @__PURE__ */ new Set([type]),
          pipes: /* @__PURE__ */ new Set()
        }
      };
    }
    const pipeDef = getPipeDef$1(type);
    if (pipeDef !== null) {
      return {
        schemas: null,
        compilation: {
          directives: /* @__PURE__ */ new Set(),
          pipes: /* @__PURE__ */ new Set()
        },
        exported: {
          directives: /* @__PURE__ */ new Set(),
          pipes: /* @__PURE__ */ new Set([type])
        }
      };
    }
  }
  throw new Error(`${type.name} does not have a module def (ɵmod property)`);
}
function transitiveScopesForNgModule(moduleType) {
  const def = getNgModuleDef(moduleType, true);
  if (def.transitiveCompileScopes !== null) {
    return def.transitiveCompileScopes;
  }
  const scopes = {
    schemas: def.schemas || null,
    compilation: {
      directives: /* @__PURE__ */ new Set(),
      pipes: /* @__PURE__ */ new Set()
    },
    exported: {
      directives: /* @__PURE__ */ new Set(),
      pipes: /* @__PURE__ */ new Set()
    }
  };
  maybeUnwrapFn(def.imports).forEach((imported) => {
    const importedScope = transitiveScopesFor(imported);
    importedScope.exported.directives.forEach((entry) => scopes.compilation.directives.add(entry));
    importedScope.exported.pipes.forEach((entry) => scopes.compilation.pipes.add(entry));
  });
  maybeUnwrapFn(def.declarations).forEach((declared) => {
    const declaredWithDefs = declared;
    if (getPipeDef$1(declaredWithDefs)) {
      scopes.compilation.pipes.add(declared);
    } else {
      scopes.compilation.directives.add(declared);
    }
  });
  maybeUnwrapFn(def.exports).forEach((exported) => {
    const exportedType = exported;
    if (isNgModule(exportedType)) {
      const exportedScope = transitiveScopesFor(exportedType);
      exportedScope.exported.directives.forEach((entry) => {
        scopes.compilation.directives.add(entry);
        scopes.exported.directives.add(entry);
      });
      exportedScope.exported.pipes.forEach((entry) => {
        scopes.compilation.pipes.add(entry);
        scopes.exported.pipes.add(entry);
      });
    } else if (getPipeDef$1(exportedType)) {
      scopes.exported.pipes.add(exportedType);
    } else {
      scopes.exported.directives.add(exportedType);
    }
  });
  def.transitiveCompileScopes = scopes;
  return scopes;
}
function expandModuleWithProviders(value) {
  if (isModuleWithProviders(value)) {
    return value.ngModule;
  }
  return value;
}
var compilationDepth = 0;
function compileComponent(type, metadata) {
  (typeof ngDevMode === "undefined" || ngDevMode) && initNgDevMode();
  let ngComponentDef = null;
  maybeQueueResolutionOfComponentResources(type, metadata);
  addDirectiveFactoryDef(type, metadata);
  Object.defineProperty(type, NG_COMP_DEF, {
    get: () => {
      if (ngComponentDef === null) {
        const compiler = getCompilerFacade({
          usage: 0,
          kind: "component",
          type
        });
        if (componentNeedsResolution(metadata)) {
          const error = [`Component '${type.name}' is not resolved:`];
          if (metadata.templateUrl) {
            error.push(` - templateUrl: ${metadata.templateUrl}`);
          }
          if (metadata.styleUrls && metadata.styleUrls.length) {
            error.push(` - styleUrls: ${JSON.stringify(metadata.styleUrls)}`);
          }
          if (metadata.styleUrl) {
            error.push(` - styleUrl: ${metadata.styleUrl}`);
          }
          error.push(`Did you run and wait for 'resolveComponentResources()'?`);
          throw new Error(error.join("\n"));
        }
        const options = getJitOptions();
        let preserveWhitespaces = metadata.preserveWhitespaces;
        if (preserveWhitespaces === void 0) {
          if (options !== null && options.preserveWhitespaces !== void 0) {
            preserveWhitespaces = options.preserveWhitespaces;
          } else {
            preserveWhitespaces = false;
          }
        }
        let encapsulation = metadata.encapsulation;
        if (encapsulation === void 0) {
          if (options !== null && options.defaultEncapsulation !== void 0) {
            encapsulation = options.defaultEncapsulation;
          } else {
            encapsulation = ViewEncapsulation$1.Emulated;
          }
        }
        const templateUrl = metadata.templateUrl || `ng:///${type.name}/template.html`;
        const meta = __spreadProps(__spreadValues({}, directiveMetadata(type, metadata)), {
          typeSourceSpan: compiler.createParseSourceSpan("Component", type.name, templateUrl),
          template: metadata.template || "",
          preserveWhitespaces,
          styles: typeof metadata.styles === "string" ? [metadata.styles] : metadata.styles || EMPTY_ARRAY,
          animations: metadata.animations,
          // JIT components are always compiled against an empty set of `declarations`. Instead, the
          // `directiveDefs` and `pipeDefs` are updated at a later point:
          //  * for NgModule-based components, they're set when the NgModule which declares the
          //    component resolves in the module scoping queue
          //  * for standalone components, they're set just below, after `compileComponent`.
          declarations: [],
          changeDetection: metadata.changeDetection,
          encapsulation,
          interpolation: metadata.interpolation,
          viewProviders: metadata.viewProviders || null
        });
        compilationDepth++;
        try {
          if (meta.usesInheritance) {
            addDirectiveDefToUndecoratedParents(type);
          }
          ngComponentDef = compiler.compileComponent(angularCoreEnv, templateUrl, meta);
          if (metadata.standalone) {
            const imports = flatten(metadata.imports || EMPTY_ARRAY);
            const {
              directiveDefs,
              pipeDefs
            } = getStandaloneDefFunctions(type, imports);
            ngComponentDef.directiveDefs = directiveDefs;
            ngComponentDef.pipeDefs = pipeDefs;
            ngComponentDef.dependencies = () => imports.map(resolveForwardRef);
          }
        } finally {
          compilationDepth--;
        }
        if (compilationDepth === 0) {
          flushModuleScopingQueueAsMuchAsPossible();
        }
        if (hasSelectorScope(type)) {
          const scopes = transitiveScopesFor(type.ngSelectorScope);
          patchComponentDefWithScope(ngComponentDef, scopes);
        }
        if (metadata.schemas) {
          if (metadata.standalone) {
            ngComponentDef.schemas = metadata.schemas;
          } else {
            throw new Error(`The 'schemas' was specified for the ${stringifyForError(type)} but is only valid on a component that is standalone.`);
          }
        } else if (metadata.standalone) {
          ngComponentDef.schemas = [];
        }
      }
      return ngComponentDef;
    },
    // Make the property configurable in dev mode to allow overriding in tests
    configurable: !!ngDevMode
  });
}
function getStandaloneDefFunctions(type, imports) {
  let cachedDirectiveDefs = null;
  let cachedPipeDefs = null;
  const directiveDefs = () => {
    if (!USE_RUNTIME_DEPS_TRACKER_FOR_JIT) {
      if (cachedDirectiveDefs === null) {
        cachedDirectiveDefs = [getComponentDef(type)];
        const seen = /* @__PURE__ */ new Set([type]);
        for (const rawDep of imports) {
          ngDevMode && verifyStandaloneImport(rawDep, type);
          const dep = resolveForwardRef(rawDep);
          if (seen.has(dep)) {
            continue;
          }
          seen.add(dep);
          if (!!getNgModuleDef(dep)) {
            const scope = transitiveScopesFor(dep);
            for (const dir of scope.exported.directives) {
              const def = getComponentDef(dir) || getDirectiveDef(dir);
              if (def && !seen.has(dir)) {
                seen.add(dir);
                cachedDirectiveDefs.push(def);
              }
            }
          } else {
            const def = getComponentDef(dep) || getDirectiveDef(dep);
            if (def) {
              cachedDirectiveDefs.push(def);
            }
          }
        }
      }
      return cachedDirectiveDefs;
    } else {
      if (ngDevMode) {
        for (const rawDep of imports) {
          verifyStandaloneImport(rawDep, type);
        }
      }
      if (!isComponent(type)) {
        return [];
      }
      const scope = depsTracker.getStandaloneComponentScope(type, imports);
      return [...scope.compilation.directives].map((p) => getComponentDef(p) || getDirectiveDef(p)).filter((d) => d !== null);
    }
  };
  const pipeDefs = () => {
    if (!USE_RUNTIME_DEPS_TRACKER_FOR_JIT) {
      if (cachedPipeDefs === null) {
        cachedPipeDefs = [];
        const seen = /* @__PURE__ */ new Set();
        for (const rawDep of imports) {
          const dep = resolveForwardRef(rawDep);
          if (seen.has(dep)) {
            continue;
          }
          seen.add(dep);
          if (!!getNgModuleDef(dep)) {
            const scope = transitiveScopesFor(dep);
            for (const pipe of scope.exported.pipes) {
              const def = getPipeDef$1(pipe);
              if (def && !seen.has(pipe)) {
                seen.add(pipe);
                cachedPipeDefs.push(def);
              }
            }
          } else {
            const def = getPipeDef$1(dep);
            if (def) {
              cachedPipeDefs.push(def);
            }
          }
        }
      }
      return cachedPipeDefs;
    } else {
      if (ngDevMode) {
        for (const rawDep of imports) {
          verifyStandaloneImport(rawDep, type);
        }
      }
      if (!isComponent(type)) {
        return [];
      }
      const scope = depsTracker.getStandaloneComponentScope(type, imports);
      return [...scope.compilation.pipes].map((p) => getPipeDef$1(p)).filter((d) => d !== null);
    }
  };
  return {
    directiveDefs,
    pipeDefs
  };
}
function hasSelectorScope(component) {
  return component.ngSelectorScope !== void 0;
}
function compileDirective(type, directive) {
  let ngDirectiveDef = null;
  addDirectiveFactoryDef(type, directive || {});
  Object.defineProperty(type, NG_DIR_DEF, {
    get: () => {
      if (ngDirectiveDef === null) {
        const meta = getDirectiveMetadata(type, directive || {});
        const compiler = getCompilerFacade({
          usage: 0,
          kind: "directive",
          type
        });
        ngDirectiveDef = compiler.compileDirective(angularCoreEnv, meta.sourceMapUrl, meta.metadata);
      }
      return ngDirectiveDef;
    },
    // Make the property configurable in dev mode to allow overriding in tests
    configurable: !!ngDevMode
  });
}
function getDirectiveMetadata(type, metadata) {
  const name = type && type.name;
  const sourceMapUrl = `ng:///${name}/ɵdir.js`;
  const compiler = getCompilerFacade({
    usage: 0,
    kind: "directive",
    type
  });
  const facade = directiveMetadata(type, metadata);
  facade.typeSourceSpan = compiler.createParseSourceSpan("Directive", name, sourceMapUrl);
  if (facade.usesInheritance) {
    addDirectiveDefToUndecoratedParents(type);
  }
  return {
    metadata: facade,
    sourceMapUrl
  };
}
function addDirectiveFactoryDef(type, metadata) {
  let ngFactoryDef = null;
  Object.defineProperty(type, NG_FACTORY_DEF, {
    get: () => {
      if (ngFactoryDef === null) {
        const meta = getDirectiveMetadata(type, metadata);
        const compiler = getCompilerFacade({
          usage: 0,
          kind: "directive",
          type
        });
        ngFactoryDef = compiler.compileFactory(angularCoreEnv, `ng:///${type.name}/ɵfac.js`, {
          name: meta.metadata.name,
          type: meta.metadata.type,
          typeArgumentCount: 0,
          deps: reflectDependencies(type),
          target: compiler.FactoryTarget.Directive
        });
      }
      return ngFactoryDef;
    },
    // Make the property configurable in dev mode to allow overriding in tests
    configurable: !!ngDevMode
  });
}
function extendsDirectlyFromObject(type) {
  return Object.getPrototypeOf(type.prototype) === Object.prototype;
}
function directiveMetadata(type, metadata) {
  const reflect = getReflect();
  const propMetadata = reflect.ownPropMetadata(type);
  return {
    name: type.name,
    type,
    selector: metadata.selector !== void 0 ? metadata.selector : null,
    host: metadata.host || EMPTY_OBJ,
    propMetadata,
    inputs: metadata.inputs || EMPTY_ARRAY,
    outputs: metadata.outputs || EMPTY_ARRAY,
    queries: extractQueriesMetadata(type, propMetadata, isContentQuery),
    lifecycle: {
      usesOnChanges: reflect.hasLifecycleHook(type, "ngOnChanges")
    },
    typeSourceSpan: null,
    usesInheritance: !extendsDirectlyFromObject(type),
    exportAs: extractExportAs(metadata.exportAs),
    providers: metadata.providers || null,
    viewQueries: extractQueriesMetadata(type, propMetadata, isViewQuery),
    isStandalone: !!metadata.standalone,
    isSignal: !!metadata.signals,
    hostDirectives: metadata.hostDirectives?.map((directive) => typeof directive === "function" ? {
      directive
    } : directive) || null
  };
}
function addDirectiveDefToUndecoratedParents(type) {
  const objPrototype = Object.prototype;
  let parent = Object.getPrototypeOf(type.prototype).constructor;
  while (parent && parent !== objPrototype) {
    if (!getDirectiveDef(parent) && !getComponentDef(parent) && shouldAddAbstractDirective(parent)) {
      compileDirective(parent, null);
    }
    parent = Object.getPrototypeOf(parent);
  }
}
function convertToR3QueryPredicate(selector) {
  return typeof selector === "string" ? splitByComma(selector) : resolveForwardRef(selector);
}
function convertToR3QueryMetadata(propertyName, ann) {
  return {
    propertyName,
    predicate: convertToR3QueryPredicate(ann.selector),
    descendants: ann.descendants,
    first: ann.first,
    read: ann.read ? ann.read : null,
    static: !!ann.static,
    emitDistinctChangesOnly: !!ann.emitDistinctChangesOnly,
    isSignal: !!ann.isSignal
  };
}
function extractQueriesMetadata(type, propMetadata, isQueryAnn) {
  const queriesMeta = [];
  for (const field in propMetadata) {
    if (propMetadata.hasOwnProperty(field)) {
      const annotations = propMetadata[field];
      annotations.forEach((ann) => {
        if (isQueryAnn(ann)) {
          if (!ann.selector) {
            throw new Error(`Can't construct a query for the property "${field}" of "${stringifyForError(type)}" since the query selector wasn't defined.`);
          }
          if (annotations.some(isInputAnnotation)) {
            throw new Error(`Cannot combine @Input decorators with query decorators`);
          }
          queriesMeta.push(convertToR3QueryMetadata(field, ann));
        }
      });
    }
  }
  return queriesMeta;
}
function extractExportAs(exportAs) {
  return exportAs === void 0 ? null : splitByComma(exportAs);
}
function isContentQuery(value) {
  const name = value.ngMetadataName;
  return name === "ContentChild" || name === "ContentChildren";
}
function isViewQuery(value) {
  const name = value.ngMetadataName;
  return name === "ViewChild" || name === "ViewChildren";
}
function isInputAnnotation(value) {
  return value.ngMetadataName === "Input";
}
function splitByComma(value) {
  return value.split(",").map((piece) => piece.trim());
}
var LIFECYCLE_HOOKS = ["ngOnChanges", "ngOnInit", "ngOnDestroy", "ngDoCheck", "ngAfterViewInit", "ngAfterViewChecked", "ngAfterContentInit", "ngAfterContentChecked"];
function shouldAddAbstractDirective(type) {
  const reflect = getReflect();
  if (LIFECYCLE_HOOKS.some((hookName) => reflect.hasLifecycleHook(type, hookName))) {
    return true;
  }
  const propMetadata = reflect.propMetadata(type);
  for (const field in propMetadata) {
    const annotations = propMetadata[field];
    for (let i = 0; i < annotations.length; i++) {
      const current = annotations[i];
      const metadataName = current.ngMetadataName;
      if (isInputAnnotation(current) || isContentQuery(current) || isViewQuery(current) || metadataName === "Output" || metadataName === "HostBinding" || metadataName === "HostListener") {
        return true;
      }
    }
  }
  return false;
}
function compilePipe(type, meta) {
  let ngPipeDef = null;
  let ngFactoryDef = null;
  Object.defineProperty(type, NG_FACTORY_DEF, {
    get: () => {
      if (ngFactoryDef === null) {
        const metadata = getPipeMetadata(type, meta);
        const compiler = getCompilerFacade({
          usage: 0,
          kind: "pipe",
          type: metadata.type
        });
        ngFactoryDef = compiler.compileFactory(angularCoreEnv, `ng:///${metadata.name}/ɵfac.js`, {
          name: metadata.name,
          type: metadata.type,
          typeArgumentCount: 0,
          deps: reflectDependencies(type),
          target: compiler.FactoryTarget.Pipe
        });
      }
      return ngFactoryDef;
    },
    // Make the property configurable in dev mode to allow overriding in tests
    configurable: !!ngDevMode
  });
  Object.defineProperty(type, NG_PIPE_DEF, {
    get: () => {
      if (ngPipeDef === null) {
        const metadata = getPipeMetadata(type, meta);
        const compiler = getCompilerFacade({
          usage: 0,
          kind: "pipe",
          type: metadata.type
        });
        ngPipeDef = compiler.compilePipe(angularCoreEnv, `ng:///${metadata.name}/ɵpipe.js`, metadata);
      }
      return ngPipeDef;
    },
    // Make the property configurable in dev mode to allow overriding in tests
    configurable: !!ngDevMode
  });
}
function getPipeMetadata(type, meta) {
  return {
    type,
    name: type.name,
    pipeName: meta.name,
    pure: meta.pure !== void 0 ? meta.pure : true,
    isStandalone: !!meta.standalone
  };
}
var Directive = makeDecorator("Directive", (dir = {}) => dir, void 0, void 0, (type, meta) => compileDirective(type, meta));
var Component = makeDecorator("Component", (c = {}) => __spreadValues({
  changeDetection: ChangeDetectionStrategy.Default
}, c), Directive, void 0, (type, meta) => compileComponent(type, meta));
var Pipe = makeDecorator("Pipe", (p) => __spreadValues({
  pure: true
}, p), void 0, void 0, (type, meta) => compilePipe(type, meta));
var Input = makePropDecorator("Input", (arg) => {
  if (!arg) {
    return {};
  }
  return typeof arg === "string" ? {
    alias: arg
  } : arg;
});
var Output = makePropDecorator("Output", (alias) => ({
  alias
}));
var HostBinding = makePropDecorator("HostBinding", (hostPropertyName) => ({
  hostPropertyName
}));
var HostListener = makePropDecorator("HostListener", (eventName, args) => ({
  eventName,
  args
}));
var NgModule = makeDecorator(
  "NgModule",
  (ngModule) => ngModule,
  void 0,
  void 0,
  /**
   * Decorator that marks the following class as an NgModule, and supplies
   * configuration metadata for it.
   *
   * * The `declarations` option configures the compiler
   * with information about what belongs to the NgModule.
   * * The `providers` options configures the NgModule's injector to provide
   * dependencies the NgModule members.
   * * The `imports` and `exports` options bring in members from other modules, and make
   * this module's members available to others.
   */
  (type, meta) => compileNgModule(type, meta)
);
var Version = class {
  constructor(full) {
    this.full = full;
    const parts = full.split(".");
    this.major = parts[0];
    this.minor = parts[1];
    this.patch = parts.slice(2).join(".");
  }
};
var VERSION = new Version("18.2.0");
var Console = class _Console {
  log(message) {
    console.log(message);
  }
  // Note: for reporting errors use `DOM.logError()` as it is platform specific
  warn(message) {
    console.warn(message);
  }
  static {
    this.ɵfac = function Console_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _Console)();
    };
  }
  static {
    this.ɵprov = ɵɵdefineInjectable({
      token: _Console,
      factory: _Console.ɵfac,
      providedIn: "platform"
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(Console, [{
    type: Injectable,
    args: [{
      providedIn: "platform"
    }]
  }], null, null);
})();
var DIDebugData = class {
  constructor() {
    this.resolverToTokenToDependencies = /* @__PURE__ */ new WeakMap();
    this.resolverToProviders = /* @__PURE__ */ new WeakMap();
    this.standaloneInjectorToComponent = /* @__PURE__ */ new WeakMap();
  }
  reset() {
    this.resolverToTokenToDependencies = /* @__PURE__ */ new WeakMap();
    this.resolverToProviders = /* @__PURE__ */ new WeakMap();
    this.standaloneInjectorToComponent = /* @__PURE__ */ new WeakMap();
  }
};
var frameworkDIDebugData = new DIDebugData();
function getFrameworkDIDebugData() {
  return frameworkDIDebugData;
}
function setupFrameworkInjectorProfiler() {
  frameworkDIDebugData.reset();
  setInjectorProfiler((injectorProfilerEvent) => handleInjectorProfilerEvent(injectorProfilerEvent));
}
function handleInjectorProfilerEvent(injectorProfilerEvent) {
  const {
    context,
    type
  } = injectorProfilerEvent;
  if (type === 0) {
    handleInjectEvent(context, injectorProfilerEvent.service);
  } else if (type === 1) {
    handleInstanceCreatedByInjectorEvent(context, injectorProfilerEvent.instance);
  } else if (type === 2) {
    handleProviderConfiguredEvent(context, injectorProfilerEvent.providerRecord);
  }
}
function handleInjectEvent(context, data) {
  const diResolver = getDIResolver(context.injector);
  if (diResolver === null) {
    throwError("An Inject event must be run within an injection context.");
  }
  const diResolverToInstantiatedToken = frameworkDIDebugData.resolverToTokenToDependencies;
  if (!diResolverToInstantiatedToken.has(diResolver)) {
    diResolverToInstantiatedToken.set(diResolver, /* @__PURE__ */ new WeakMap());
  }
  if (!canBeHeldWeakly(context.token)) {
    return;
  }
  const instantiatedTokenToDependencies = diResolverToInstantiatedToken.get(diResolver);
  if (!instantiatedTokenToDependencies.has(context.token)) {
    instantiatedTokenToDependencies.set(context.token, []);
  }
  const {
    token,
    value,
    flags
  } = data;
  assertDefined(context.token, "Injector profiler context token is undefined.");
  const dependencies = instantiatedTokenToDependencies.get(context.token);
  assertDefined(dependencies, "Could not resolve dependencies for token.");
  if (context.injector instanceof NodeInjector) {
    dependencies.push({
      token,
      value,
      flags,
      injectedIn: getNodeInjectorContext(context.injector)
    });
  } else {
    dependencies.push({
      token,
      value,
      flags
    });
  }
}
function getNodeInjectorContext(injector) {
  if (!(injector instanceof NodeInjector)) {
    throwError("getNodeInjectorContext must be called with a NodeInjector");
  }
  const lView = getNodeInjectorLView(injector);
  const tNode = getNodeInjectorTNode(injector);
  if (tNode === null) {
    return;
  }
  assertTNodeForLView(tNode, lView);
  return {
    lView,
    tNode
  };
}
function handleInstanceCreatedByInjectorEvent(context, data) {
  const {
    value
  } = data;
  if (getDIResolver(context.injector) === null) {
    throwError("An InjectorCreatedInstance event must be run within an injection context.");
  }
  let standaloneComponent = void 0;
  if (typeof value === "object") {
    standaloneComponent = value?.constructor;
  }
  if (standaloneComponent == void 0 || !isStandaloneComponent(standaloneComponent)) {
    return;
  }
  const environmentInjector = context.injector.get(EnvironmentInjector, null, {
    optional: true
  });
  if (environmentInjector === null) {
    return;
  }
  const {
    standaloneInjectorToComponent
  } = frameworkDIDebugData;
  if (standaloneInjectorToComponent.has(environmentInjector)) {
    return;
  }
  standaloneInjectorToComponent.set(environmentInjector, standaloneComponent);
}
function isStandaloneComponent(value) {
  const def = getComponentDef(value);
  return !!def?.standalone;
}
function handleProviderConfiguredEvent(context, data) {
  const {
    resolverToProviders
  } = frameworkDIDebugData;
  let diResolver;
  if (context?.injector instanceof NodeInjector) {
    diResolver = getNodeInjectorTNode(context.injector);
  } else {
    diResolver = context.injector;
  }
  if (diResolver === null) {
    throwError("A ProviderConfigured event must be run within an injection context.");
  }
  if (!resolverToProviders.has(diResolver)) {
    resolverToProviders.set(diResolver, []);
  }
  resolverToProviders.get(diResolver).push(data);
}
function getDIResolver(injector) {
  let diResolver = null;
  if (injector === void 0) {
    return diResolver;
  }
  if (injector instanceof NodeInjector) {
    diResolver = getNodeInjectorLView(injector);
  } else {
    diResolver = injector;
  }
  return diResolver;
}
function canBeHeldWeakly(value) {
  return value !== null && (typeof value === "object" || typeof value === "function" || typeof value === "symbol");
}
function applyChanges(component) {
  ngDevMode && assertDefined(component, "component");
  markViewDirty(
    getComponentViewByInstance(component),
    3
    /* NotificationSource.DebugApplyChanges */
  );
  getRootComponents(component).forEach((rootComponent) => detectChanges(rootComponent));
}
function detectChanges(component) {
  const view = getComponentViewByInstance(component);
  view[FLAGS] |= 1024;
  detectChangesInternal(view);
}
function getDependenciesFromInjectable(injector, token) {
  const instance = injector.get(token, null, {
    self: true,
    optional: true
  });
  if (instance === null) {
    throw new Error(`Unable to determine instance of ${token} in given injector`);
  }
  const unformattedDependencies = getDependenciesForTokenInInjector(token, injector);
  const resolutionPath = getInjectorResolutionPath(injector);
  const dependencies = unformattedDependencies.map((dep) => {
    const formattedDependency = {
      value: dep.value
    };
    const flags = dep.flags;
    formattedDependency.flags = {
      optional: (8 & flags) === 8,
      host: (1 & flags) === 1,
      self: (2 & flags) === 2,
      skipSelf: (4 & flags) === 4
      /* InternalInjectFlags.SkipSelf */
    };
    for (let i = 0; i < resolutionPath.length; i++) {
      const injectorToCheck = resolutionPath[i];
      if (i === 0 && formattedDependency.flags.skipSelf) {
        continue;
      }
      if (formattedDependency.flags.host && injectorToCheck instanceof EnvironmentInjector) {
        break;
      }
      const instance2 = injectorToCheck.get(dep.token, null, {
        self: true,
        optional: true
      });
      if (instance2 !== null) {
        if (formattedDependency.flags.host) {
          const firstInjector = resolutionPath[0];
          const lookupFromFirstInjector = firstInjector.get(dep.token, null, __spreadProps(__spreadValues({}, formattedDependency.flags), {
            optional: true
          }));
          if (lookupFromFirstInjector !== null) {
            formattedDependency.providedIn = injectorToCheck;
          }
          break;
        }
        formattedDependency.providedIn = injectorToCheck;
        break;
      }
      if (i === 0 && formattedDependency.flags.self) {
        break;
      }
    }
    if (dep.token) formattedDependency.token = dep.token;
    return formattedDependency;
  });
  return {
    instance,
    dependencies
  };
}
function getDependenciesForTokenInInjector(token, injector) {
  const {
    resolverToTokenToDependencies
  } = getFrameworkDIDebugData();
  if (!(injector instanceof NodeInjector)) {
    return resolverToTokenToDependencies.get(injector)?.get?.(token) ?? [];
  }
  const lView = getNodeInjectorLView(injector);
  const tokenDependencyMap = resolverToTokenToDependencies.get(lView);
  const dependencies = tokenDependencyMap?.get(token) ?? [];
  return dependencies.filter((dependency) => {
    const dependencyNode = dependency.injectedIn?.tNode;
    if (dependencyNode === void 0) {
      return false;
    }
    const instanceNode = getNodeInjectorTNode(injector);
    assertTNode(dependencyNode);
    assertTNode(instanceNode);
    return dependencyNode === instanceNode;
  });
}
function getProviderImportsContainer(injector) {
  const {
    standaloneInjectorToComponent
  } = getFrameworkDIDebugData();
  if (standaloneInjectorToComponent.has(injector)) {
    return standaloneInjectorToComponent.get(injector);
  }
  const defTypeRef = injector.get(NgModuleRef$1, null, {
    self: true,
    optional: true
  });
  if (defTypeRef === null) {
    return null;
  }
  if (defTypeRef.instance === null) {
    return null;
  }
  return defTypeRef.instance.constructor;
}
function getNodeInjectorProviders(injector) {
  const diResolver = getNodeInjectorTNode(injector);
  const {
    resolverToProviders
  } = getFrameworkDIDebugData();
  return resolverToProviders.get(diResolver) ?? [];
}
function getProviderImportPaths(providerImportsContainer) {
  const providerToPath = /* @__PURE__ */ new Map();
  const visitedContainers = /* @__PURE__ */ new Set();
  const visitor = walkProviderTreeToDiscoverImportPaths(providerToPath, visitedContainers);
  walkProviderTree(providerImportsContainer, visitor, [], /* @__PURE__ */ new Set());
  return providerToPath;
}
function walkProviderTreeToDiscoverImportPaths(providerToPath, visitedContainers) {
  return (provider, container) => {
    if (!providerToPath.has(provider)) {
      providerToPath.set(provider, [container]);
    }
    if (!visitedContainers.has(container)) {
      for (const prov of providerToPath.keys()) {
        const existingImportPath = providerToPath.get(prov);
        let containerDef = getInjectorDef(container);
        if (!containerDef) {
          const ngModule = container.ngModule;
          containerDef = getInjectorDef(ngModule);
        }
        if (!containerDef) {
          return;
        }
        const lastContainerAddedToPath = existingImportPath[0];
        let isNextStepInPath = false;
        deepForEach(containerDef.imports, (moduleImport) => {
          if (isNextStepInPath) {
            return;
          }
          isNextStepInPath = moduleImport.ngModule === lastContainerAddedToPath || moduleImport === lastContainerAddedToPath;
          if (isNextStepInPath) {
            providerToPath.get(prov)?.unshift(container);
          }
        });
      }
    }
    visitedContainers.add(container);
  };
}
function getEnvironmentInjectorProviders(injector) {
  const providerRecordsWithoutImportPaths = getFrameworkDIDebugData().resolverToProviders.get(injector) ?? [];
  if (isPlatformInjector(injector)) {
    return providerRecordsWithoutImportPaths;
  }
  const providerImportsContainer = getProviderImportsContainer(injector);
  if (providerImportsContainer === null) {
    return providerRecordsWithoutImportPaths;
  }
  const providerToPath = getProviderImportPaths(providerImportsContainer);
  const providerRecords = [];
  for (const providerRecord of providerRecordsWithoutImportPaths) {
    const provider = providerRecord.provider;
    const token = provider.provide;
    if (token === ENVIRONMENT_INITIALIZER || token === INJECTOR_DEF_TYPES) {
      continue;
    }
    let importPath = providerToPath.get(provider) ?? [];
    const def = getComponentDef(providerImportsContainer);
    const isStandaloneComponent2 = !!def?.standalone;
    if (isStandaloneComponent2) {
      importPath = [providerImportsContainer, ...importPath];
    }
    providerRecords.push(__spreadProps(__spreadValues({}, providerRecord), {
      importPath
    }));
  }
  return providerRecords;
}
function isPlatformInjector(injector) {
  return injector instanceof R3Injector && injector.scopes.has("platform");
}
function getInjectorProviders(injector) {
  if (injector instanceof NodeInjector) {
    return getNodeInjectorProviders(injector);
  } else if (injector instanceof EnvironmentInjector) {
    return getEnvironmentInjectorProviders(injector);
  }
  throwError("getInjectorProviders only supports NodeInjector and EnvironmentInjector");
}
function getInjectorMetadata(injector) {
  if (injector instanceof NodeInjector) {
    const lView = getNodeInjectorLView(injector);
    const tNode = getNodeInjectorTNode(injector);
    assertTNodeForLView(tNode, lView);
    return {
      type: "element",
      source: getNativeByTNode(tNode, lView)
    };
  }
  if (injector instanceof R3Injector) {
    return {
      type: "environment",
      source: injector.source ?? null
    };
  }
  if (injector instanceof NullInjector) {
    return {
      type: "null",
      source: null
    };
  }
  return null;
}
function getInjectorResolutionPath(injector) {
  const resolutionPath = [injector];
  getInjectorResolutionPathHelper(injector, resolutionPath);
  return resolutionPath;
}
function getInjectorResolutionPathHelper(injector, resolutionPath) {
  const parent = getInjectorParent(injector);
  if (parent === null) {
    if (injector instanceof NodeInjector) {
      const firstInjector = resolutionPath[0];
      if (firstInjector instanceof NodeInjector) {
        const moduleInjector = getModuleInjectorOfNodeInjector(firstInjector);
        if (moduleInjector === null) {
          throwError("NodeInjector must have some connection to the module injector tree");
        }
        resolutionPath.push(moduleInjector);
        getInjectorResolutionPathHelper(moduleInjector, resolutionPath);
      }
      return resolutionPath;
    }
  } else {
    resolutionPath.push(parent);
    getInjectorResolutionPathHelper(parent, resolutionPath);
  }
  return resolutionPath;
}
function getInjectorParent(injector) {
  if (injector instanceof R3Injector) {
    const parent = injector.parent;
    if (isRouterOutletInjector(parent)) {
      return parent.parentInjector;
    }
    return parent;
  }
  let tNode;
  let lView;
  if (injector instanceof NodeInjector) {
    tNode = getNodeInjectorTNode(injector);
    lView = getNodeInjectorLView(injector);
  } else if (injector instanceof NullInjector) {
    return null;
  } else if (injector instanceof ChainedInjector) {
    return injector.parentInjector;
  } else {
    throwError("getInjectorParent only support injectors of type R3Injector, NodeInjector, NullInjector");
  }
  const parentLocation = getParentInjectorLocation(tNode, lView);
  if (hasParentInjector(parentLocation)) {
    const parentInjectorIndex = getParentInjectorIndex(parentLocation);
    const parentLView = getParentInjectorView(parentLocation, lView);
    const parentTView = parentLView[TVIEW];
    const parentTNode = parentTView.data[
      parentInjectorIndex + 8
      /* NodeInjectorOffset.TNODE */
    ];
    return new NodeInjector(parentTNode, parentLView);
  } else {
    const chainedInjector = lView[INJECTOR];
    const injectorParent = chainedInjector.injector?.parent;
    if (injectorParent instanceof NodeInjector) {
      return injectorParent;
    }
  }
  return null;
}
function getModuleInjectorOfNodeInjector(injector) {
  let lView;
  if (injector instanceof NodeInjector) {
    lView = getNodeInjectorLView(injector);
  } else {
    throwError("getModuleInjectorOfNodeInjector must be called with a NodeInjector");
  }
  const inj = lView[INJECTOR];
  const moduleInjector = inj instanceof ChainedInjector ? inj.parentInjector : inj.parent;
  if (!moduleInjector) {
    throwError("NodeInjector must have some connection to the module injector tree");
  }
  return moduleInjector;
}
var GLOBAL_PUBLISH_EXPANDO_KEY = "ng";
var globalUtilsFunctions = {
  /**
   * Warning: functions that start with `ɵ` are considered *INTERNAL* and should not be relied upon
   * in application's code. The contract of those functions might be changed in any release and/or a
   * function can be removed completely.
   */
  "ɵgetDependenciesFromInjectable": getDependenciesFromInjectable,
  "ɵgetInjectorProviders": getInjectorProviders,
  "ɵgetInjectorResolutionPath": getInjectorResolutionPath,
  "ɵgetInjectorMetadata": getInjectorMetadata,
  "ɵsetProfiler": setProfiler,
  "getDirectiveMetadata": getDirectiveMetadata$1,
  "getComponent": getComponent$1,
  "getContext": getContext,
  "getListeners": getListeners,
  "getOwningComponent": getOwningComponent,
  "getHostElement": getHostElement,
  "getInjector": getInjector,
  "getRootComponents": getRootComponents,
  "getDirectives": getDirectives,
  "applyChanges": applyChanges,
  "isSignal": isSignal
};
var _published = false;
function publishDefaultGlobalUtils$1() {
  if (!_published) {
    _published = true;
    if (typeof window !== "undefined") {
      setupFrameworkInjectorProfiler();
    }
    for (const [methodName, method] of Object.entries(globalUtilsFunctions)) {
      publishGlobalUtil(methodName, method);
    }
  }
}
function publishGlobalUtil(name, fn) {
  if (typeof COMPILED === "undefined" || !COMPILED) {
    const w = _global;
    ngDevMode && assertDefined(fn, "function not defined");
    w[GLOBAL_PUBLISH_EXPANDO_KEY] ??= {};
    w[GLOBAL_PUBLISH_EXPANDO_KEY][name] = fn;
  }
}
var TESTABILITY = new InjectionToken("");
var TESTABILITY_GETTER = new InjectionToken("");
var Testability = class _Testability {
  constructor(_ngZone, registry, testabilityGetter) {
    this._ngZone = _ngZone;
    this.registry = registry;
    this._isZoneStable = true;
    this._callbacks = [];
    this.taskTrackingZone = null;
    if (!_testabilityGetter) {
      setTestabilityGetter(testabilityGetter);
      testabilityGetter.addToWindow(registry);
    }
    this._watchAngularEvents();
    _ngZone.run(() => {
      this.taskTrackingZone = typeof Zone == "undefined" ? null : Zone.current.get("TaskTrackingZone");
    });
  }
  _watchAngularEvents() {
    this._ngZone.onUnstable.subscribe({
      next: () => {
        this._isZoneStable = false;
      }
    });
    this._ngZone.runOutsideAngular(() => {
      this._ngZone.onStable.subscribe({
        next: () => {
          NgZone.assertNotInAngularZone();
          queueMicrotask(() => {
            this._isZoneStable = true;
            this._runCallbacksIfReady();
          });
        }
      });
    });
  }
  /**
   * Whether an associated application is stable
   */
  isStable() {
    return this._isZoneStable && !this._ngZone.hasPendingMacrotasks;
  }
  _runCallbacksIfReady() {
    if (this.isStable()) {
      queueMicrotask(() => {
        while (this._callbacks.length !== 0) {
          let cb = this._callbacks.pop();
          clearTimeout(cb.timeoutId);
          cb.doneCb();
        }
      });
    } else {
      let pending = this.getPendingTasks();
      this._callbacks = this._callbacks.filter((cb) => {
        if (cb.updateCb && cb.updateCb(pending)) {
          clearTimeout(cb.timeoutId);
          return false;
        }
        return true;
      });
    }
  }
  getPendingTasks() {
    if (!this.taskTrackingZone) {
      return [];
    }
    return this.taskTrackingZone.macroTasks.map((t) => {
      return {
        source: t.source,
        // From TaskTrackingZone:
        // https://github.com/angular/zone.js/blob/master/lib/zone-spec/task-tracking.ts#L40
        creationLocation: t.creationLocation,
        data: t.data
      };
    });
  }
  addCallback(cb, timeout, updateCb) {
    let timeoutId = -1;
    if (timeout && timeout > 0) {
      timeoutId = setTimeout(() => {
        this._callbacks = this._callbacks.filter((cb2) => cb2.timeoutId !== timeoutId);
        cb();
      }, timeout);
    }
    this._callbacks.push({
      doneCb: cb,
      timeoutId,
      updateCb
    });
  }
  /**
   * Wait for the application to be stable with a timeout. If the timeout is reached before that
   * happens, the callback receives a list of the macro tasks that were pending, otherwise null.
   *
   * @param doneCb The callback to invoke when Angular is stable or the timeout expires
   *    whichever comes first.
   * @param timeout Optional. The maximum time to wait for Angular to become stable. If not
   *    specified, whenStable() will wait forever.
   * @param updateCb Optional. If specified, this callback will be invoked whenever the set of
   *    pending macrotasks changes. If this callback returns true doneCb will not be invoked
   *    and no further updates will be issued.
   */
  whenStable(doneCb, timeout, updateCb) {
    if (updateCb && !this.taskTrackingZone) {
      throw new Error('Task tracking zone is required when passing an update callback to whenStable(). Is "zone.js/plugins/task-tracking" loaded?');
    }
    this.addCallback(doneCb, timeout, updateCb);
    this._runCallbacksIfReady();
  }
  /**
   * Registers an application with a testability hook so that it can be tracked.
   * @param token token of application, root element
   *
   * @internal
   */
  registerApplication(token) {
    this.registry.registerApplication(token, this);
  }
  /**
   * Unregisters an application.
   * @param token token of application, root element
   *
   * @internal
   */
  unregisterApplication(token) {
    this.registry.unregisterApplication(token);
  }
  /**
   * Find providers by name
   * @param using The root element to search from
   * @param provider The name of binding variable
   * @param exactMatch Whether using exactMatch
   */
  findProviders(using, provider, exactMatch) {
    return [];
  }
  static {
    this.ɵfac = function Testability_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _Testability)(ɵɵinject(NgZone), ɵɵinject(TestabilityRegistry), ɵɵinject(TESTABILITY_GETTER));
    };
  }
  static {
    this.ɵprov = ɵɵdefineInjectable({
      token: _Testability,
      factory: _Testability.ɵfac
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(Testability, [{
    type: Injectable
  }], () => [{
    type: NgZone
  }, {
    type: TestabilityRegistry
  }, {
    type: void 0,
    decorators: [{
      type: Inject,
      args: [TESTABILITY_GETTER]
    }]
  }], null);
})();
var TestabilityRegistry = class _TestabilityRegistry {
  constructor() {
    this._applications = /* @__PURE__ */ new Map();
  }
  /**
   * Registers an application with a testability hook so that it can be tracked
   * @param token token of application, root element
   * @param testability Testability hook
   */
  registerApplication(token, testability) {
    this._applications.set(token, testability);
  }
  /**
   * Unregisters an application.
   * @param token token of application, root element
   */
  unregisterApplication(token) {
    this._applications.delete(token);
  }
  /**
   * Unregisters all applications
   */
  unregisterAllApplications() {
    this._applications.clear();
  }
  /**
   * Get a testability hook associated with the application
   * @param elem root element
   */
  getTestability(elem) {
    return this._applications.get(elem) || null;
  }
  /**
   * Get all registered testabilities
   */
  getAllTestabilities() {
    return Array.from(this._applications.values());
  }
  /**
   * Get all registered applications(root elements)
   */
  getAllRootElements() {
    return Array.from(this._applications.keys());
  }
  /**
   * Find testability of a node in the Tree
   * @param elem node
   * @param findInAncestors whether finding testability in ancestors if testability was not found in
   * current node
   */
  findTestabilityInTree(elem, findInAncestors = true) {
    return _testabilityGetter?.findTestabilityInTree(this, elem, findInAncestors) ?? null;
  }
  static {
    this.ɵfac = function TestabilityRegistry_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _TestabilityRegistry)();
    };
  }
  static {
    this.ɵprov = ɵɵdefineInjectable({
      token: _TestabilityRegistry,
      factory: _TestabilityRegistry.ɵfac,
      providedIn: "platform"
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(TestabilityRegistry, [{
    type: Injectable,
    args: [{
      providedIn: "platform"
    }]
  }], null, null);
})();
function setTestabilityGetter(getter) {
  _testabilityGetter = getter;
}
var _testabilityGetter;
function isPromise(obj) {
  return !!obj && typeof obj.then === "function";
}
function isSubscribable(obj) {
  return !!obj && typeof obj.subscribe === "function";
}
var APP_INITIALIZER = new InjectionToken(ngDevMode ? "Application Initializer" : "");
var ApplicationInitStatus = class _ApplicationInitStatus {
  constructor() {
    this.initialized = false;
    this.done = false;
    this.donePromise = new Promise((res, rej) => {
      this.resolve = res;
      this.reject = rej;
    });
    this.appInits = inject(APP_INITIALIZER, {
      optional: true
    }) ?? [];
    if ((typeof ngDevMode === "undefined" || ngDevMode) && !Array.isArray(this.appInits)) {
      throw new RuntimeError(-209, `Unexpected type of the \`APP_INITIALIZER\` token value (expected an array, but got ${typeof this.appInits}). Please check that the \`APP_INITIALIZER\` token is configured as a \`multi: true\` provider.`);
    }
  }
  /** @internal */
  runInitializers() {
    if (this.initialized) {
      return;
    }
    const asyncInitPromises = [];
    for (const appInits of this.appInits) {
      const initResult = appInits();
      if (isPromise(initResult)) {
        asyncInitPromises.push(initResult);
      } else if (isSubscribable(initResult)) {
        const observableAsPromise = new Promise((resolve, reject) => {
          initResult.subscribe({
            complete: resolve,
            error: reject
          });
        });
        asyncInitPromises.push(observableAsPromise);
      }
    }
    const complete = () => {
      this.done = true;
      this.resolve();
    };
    Promise.all(asyncInitPromises).then(() => {
      complete();
    }).catch((e) => {
      this.reject(e);
    });
    if (asyncInitPromises.length === 0) {
      complete();
    }
    this.initialized = true;
  }
  static {
    this.ɵfac = function ApplicationInitStatus_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _ApplicationInitStatus)();
    };
  }
  static {
    this.ɵprov = ɵɵdefineInjectable({
      token: _ApplicationInitStatus,
      factory: _ApplicationInitStatus.ɵfac,
      providedIn: "root"
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ApplicationInitStatus, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], () => [], null);
})();
var APP_BOOTSTRAP_LISTENER = new InjectionToken(ngDevMode ? "appBootstrapListener" : "");
function publishDefaultGlobalUtils() {
  ngDevMode && publishDefaultGlobalUtils$1();
}
function publishSignalConfiguration() {
  setThrowInvalidWriteToSignalError(() => {
    throw new RuntimeError(600, ngDevMode && "Writing to signals is not allowed in a `computed` or an `effect` by default. Use `allowSignalWrites` in the `CreateEffectOptions` to enable this inside effects.");
  });
}
function isBoundToModule(cf) {
  return cf.isBoundToModule;
}
var NgProbeToken = class {
  constructor(name, token) {
    this.name = name;
    this.token = token;
  }
};
var MAXIMUM_REFRESH_RERUNS = 10;
function _callAndReportToErrorHandler(errorHandler, ngZone, callback) {
  try {
    const result = callback();
    if (isPromise(result)) {
      return result.catch((e) => {
        ngZone.runOutsideAngular(() => errorHandler.handleError(e));
        throw e;
      });
    }
    return result;
  } catch (e) {
    ngZone.runOutsideAngular(() => errorHandler.handleError(e));
    throw e;
  }
}
function optionsReducer(dst, objs) {
  if (Array.isArray(objs)) {
    return objs.reduce(optionsReducer, dst);
  }
  return __spreadValues(__spreadValues({}, dst), objs);
}
var ApplicationRef = class _ApplicationRef {
  constructor() {
    this._bootstrapListeners = [];
    this._runningTick = false;
    this._destroyed = false;
    this._destroyListeners = [];
    this._views = [];
    this.internalErrorHandler = inject(INTERNAL_APPLICATION_ERROR_HANDLER);
    this.afterRenderEffectManager = inject(AfterRenderEventManager);
    this.zonelessEnabled = inject(ZONELESS_ENABLED);
    this.externalTestViews = /* @__PURE__ */ new Set();
    this.beforeRender = new Subject();
    this.afterTick = new Subject();
    this.componentTypes = [];
    this.components = [];
    this.isStable = inject(PendingTasks).hasPendingTasks.pipe(map((pending) => !pending));
    this._injector = inject(EnvironmentInjector);
  }
  /** @internal */
  get allViews() {
    return [...this.externalTestViews.keys(), ...this._views];
  }
  /**
   * Indicates whether this instance was destroyed.
   */
  get destroyed() {
    return this._destroyed;
  }
  /**
   * @returns A promise that resolves when the application becomes stable
   */
  whenStable() {
    let subscription;
    return new Promise((resolve) => {
      subscription = this.isStable.subscribe({
        next: (stable) => {
          if (stable) {
            resolve();
          }
        }
      });
    }).finally(() => {
      subscription.unsubscribe();
    });
  }
  /**
   * The `EnvironmentInjector` used to create this application.
   */
  get injector() {
    return this._injector;
  }
  /**
   * Bootstrap a component onto the element identified by its selector or, optionally, to a
   * specified element.
   *
   * @usageNotes
   * ### Bootstrap process
   *
   * When bootstrapping a component, Angular mounts it onto a target DOM element
   * and kicks off automatic change detection. The target DOM element can be
   * provided using the `rootSelectorOrNode` argument.
   *
   * If the target DOM element is not provided, Angular tries to find one on a page
   * using the `selector` of the component that is being bootstrapped
   * (first matched element is used).
   *
   * ### Example
   *
   * Generally, we define the component to bootstrap in the `bootstrap` array of `NgModule`,
   * but it requires us to know the component while writing the application code.
   *
   * Imagine a situation where we have to wait for an API call to decide about the component to
   * bootstrap. We can use the `ngDoBootstrap` hook of the `NgModule` and call this method to
   * dynamically bootstrap a component.
   *
   * {@example core/ts/platform/platform.ts region='componentSelector'}
   *
   * Optionally, a component can be mounted onto a DOM element that does not match the
   * selector of the bootstrapped component.
   *
   * In the following example, we are providing a CSS selector to match the target element.
   *
   * {@example core/ts/platform/platform.ts region='cssSelector'}
   *
   * While in this example, we are providing reference to a DOM node.
   *
   * {@example core/ts/platform/platform.ts region='domNode'}
   */
  bootstrap(componentOrFactory, rootSelectorOrNode) {
    (typeof ngDevMode === "undefined" || ngDevMode) && this.warnIfDestroyed();
    const isComponentFactory = componentOrFactory instanceof ComponentFactory$1;
    const initStatus = this._injector.get(ApplicationInitStatus);
    if (!initStatus.done) {
      const standalone = !isComponentFactory && isStandalone(componentOrFactory);
      const errorMessage = (typeof ngDevMode === "undefined" || ngDevMode) && "Cannot bootstrap as there are still asynchronous initializers running." + (standalone ? "" : " Bootstrap components in the `ngDoBootstrap` method of the root module.");
      throw new RuntimeError(405, errorMessage);
    }
    let componentFactory;
    if (isComponentFactory) {
      componentFactory = componentOrFactory;
    } else {
      const resolver = this._injector.get(ComponentFactoryResolver$1);
      componentFactory = resolver.resolveComponentFactory(componentOrFactory);
    }
    this.componentTypes.push(componentFactory.componentType);
    const ngModule = isBoundToModule(componentFactory) ? void 0 : this._injector.get(NgModuleRef$1);
    const selectorOrNode = rootSelectorOrNode || componentFactory.selector;
    const compRef = componentFactory.create(Injector.NULL, [], selectorOrNode, ngModule);
    const nativeElement = compRef.location.nativeElement;
    const testability = compRef.injector.get(TESTABILITY, null);
    testability?.registerApplication(nativeElement);
    compRef.onDestroy(() => {
      this.detachView(compRef.hostView);
      remove(this.components, compRef);
      testability?.unregisterApplication(nativeElement);
    });
    this._loadComponent(compRef);
    if (typeof ngDevMode === "undefined" || ngDevMode) {
      const _console = this._injector.get(Console);
      _console.log(`Angular is running in development mode.`);
    }
    return compRef;
  }
  /**
   * Invoke this method to explicitly process change detection and its side-effects.
   *
   * In development mode, `tick()` also performs a second change detection cycle to ensure that no
   * further changes are detected. If additional changes are picked up during this second cycle,
   * bindings in the app have side-effects that cannot be resolved in a single change detection
   * pass.
   * In this case, Angular throws an error, since an Angular application can only have one change
   * detection pass during which all change detection must complete.
   */
  tick() {
    this._tick(true);
  }
  /** @internal */
  _tick(refreshViews) {
    (typeof ngDevMode === "undefined" || ngDevMode) && this.warnIfDestroyed();
    if (this._runningTick) {
      throw new RuntimeError(101, ngDevMode && "ApplicationRef.tick is called recursively");
    }
    const prevConsumer = setActiveConsumer(null);
    try {
      this._runningTick = true;
      this.detectChangesInAttachedViews(refreshViews);
      if (typeof ngDevMode === "undefined" || ngDevMode) {
        for (let view of this._views) {
          view.checkNoChanges();
        }
      }
    } catch (e) {
      this.internalErrorHandler(e);
    } finally {
      this._runningTick = false;
      setActiveConsumer(prevConsumer);
      this.afterTick.next();
    }
  }
  detectChangesInAttachedViews(refreshViews) {
    let rendererFactory = null;
    if (!this._injector.destroyed) {
      rendererFactory = this._injector.get(RendererFactory2, null, {
        optional: true
      });
    }
    let runs = 0;
    const afterRenderEffectManager = this.afterRenderEffectManager;
    while (runs < MAXIMUM_REFRESH_RERUNS) {
      const isFirstPass = runs === 0;
      if (refreshViews || !isFirstPass) {
        this.beforeRender.next(isFirstPass);
        for (let {
          _lView,
          notifyErrorHandler
        } of this._views) {
          detectChangesInViewIfRequired(_lView, notifyErrorHandler, isFirstPass, this.zonelessEnabled);
        }
      } else {
        rendererFactory?.begin?.();
        rendererFactory?.end?.();
      }
      runs++;
      afterRenderEffectManager.executeInternalCallbacks();
      if (this.allViews.some(({
        _lView
      }) => requiresRefreshOrTraversal(_lView))) {
        continue;
      }
      afterRenderEffectManager.execute();
      if (!this.allViews.some(({
        _lView
      }) => requiresRefreshOrTraversal(_lView))) {
        break;
      }
    }
    if ((typeof ngDevMode === "undefined" || ngDevMode) && runs >= MAXIMUM_REFRESH_RERUNS) {
      throw new RuntimeError(103, ngDevMode && "Infinite change detection while refreshing application views. Ensure views are not calling `markForCheck` on every template execution or that afterRender hooks always mark views for check.");
    }
  }
  /**
   * Attaches a view so that it will be dirty checked.
   * The view will be automatically detached when it is destroyed.
   * This will throw if the view is already attached to a ViewContainer.
   */
  attachView(viewRef) {
    (typeof ngDevMode === "undefined" || ngDevMode) && this.warnIfDestroyed();
    const view = viewRef;
    this._views.push(view);
    view.attachToAppRef(this);
  }
  /**
   * Detaches a view from dirty checking again.
   */
  detachView(viewRef) {
    (typeof ngDevMode === "undefined" || ngDevMode) && this.warnIfDestroyed();
    const view = viewRef;
    remove(this._views, view);
    view.detachFromAppRef();
  }
  _loadComponent(componentRef) {
    this.attachView(componentRef.hostView);
    this.tick();
    this.components.push(componentRef);
    const listeners = this._injector.get(APP_BOOTSTRAP_LISTENER, []);
    if (ngDevMode && !Array.isArray(listeners)) {
      throw new RuntimeError(-209, `Unexpected type of the \`APP_BOOTSTRAP_LISTENER\` token value (expected an array, but got ${typeof listeners}). Please check that the \`APP_BOOTSTRAP_LISTENER\` token is configured as a \`multi: true\` provider.`);
    }
    [...this._bootstrapListeners, ...listeners].forEach((listener) => listener(componentRef));
  }
  /** @internal */
  ngOnDestroy() {
    if (this._destroyed) return;
    try {
      this._destroyListeners.forEach((listener) => listener());
      this._views.slice().forEach((view) => view.destroy());
    } finally {
      this._destroyed = true;
      this._views = [];
      this._bootstrapListeners = [];
      this._destroyListeners = [];
    }
  }
  /**
   * Registers a listener to be called when an instance is destroyed.
   *
   * @param callback A callback function to add as a listener.
   * @returns A function which unregisters a listener.
   */
  onDestroy(callback) {
    (typeof ngDevMode === "undefined" || ngDevMode) && this.warnIfDestroyed();
    this._destroyListeners.push(callback);
    return () => remove(this._destroyListeners, callback);
  }
  /**
   * Destroys an Angular application represented by this `ApplicationRef`. Calling this function
   * will destroy the associated environment injectors as well as all the bootstrapped components
   * with their views.
   */
  destroy() {
    if (this._destroyed) {
      throw new RuntimeError(406, ngDevMode && "This instance of the `ApplicationRef` has already been destroyed.");
    }
    const injector = this._injector;
    if (injector.destroy && !injector.destroyed) {
      injector.destroy();
    }
  }
  /**
   * Returns the number of attached views.
   */
  get viewCount() {
    return this._views.length;
  }
  warnIfDestroyed() {
    if ((typeof ngDevMode === "undefined" || ngDevMode) && this._destroyed) {
      console.warn(formatRuntimeError(406, "This instance of the `ApplicationRef` has already been destroyed."));
    }
  }
  static {
    this.ɵfac = function ApplicationRef_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _ApplicationRef)();
    };
  }
  static {
    this.ɵprov = ɵɵdefineInjectable({
      token: _ApplicationRef,
      factory: _ApplicationRef.ɵfac,
      providedIn: "root"
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ApplicationRef, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], null, null);
})();
function remove(list, el) {
  const index = list.indexOf(el);
  if (index > -1) {
    list.splice(index, 1);
  }
}
var whenStableStore;
function whenStable(applicationRef) {
  whenStableStore ??= /* @__PURE__ */ new WeakMap();
  const cachedWhenStable = whenStableStore.get(applicationRef);
  if (cachedWhenStable) {
    return cachedWhenStable;
  }
  const whenStablePromise = applicationRef.isStable.pipe(first((isStable) => isStable)).toPromise().then(() => void 0);
  whenStableStore.set(applicationRef, whenStablePromise);
  applicationRef.onDestroy(() => whenStableStore?.delete(applicationRef));
  return whenStablePromise;
}
function detectChangesInViewIfRequired(lView, notifyErrorHandler, isFirstPass, zonelessEnabled) {
  if (!isFirstPass && !requiresRefreshOrTraversal(lView)) {
    return;
  }
  const mode = isFirstPass && !zonelessEnabled ? (
    // The first pass is always in Global mode, which includes `CheckAlways` views.
    0
  ) : (
    // Only refresh views with the `RefreshView` flag or views is a changed signal
    1
  );
  detectChangesInternal(lView, notifyErrorHandler, mode);
}
var ModuleWithComponentFactories = class {
  constructor(ngModuleFactory, componentFactories) {
    this.ngModuleFactory = ngModuleFactory;
    this.componentFactories = componentFactories;
  }
};
var Compiler = class _Compiler {
  /**
   * Compiles the given NgModule and all of its components. All templates of the components
   * have to be inlined.
   */
  compileModuleSync(moduleType) {
    return new NgModuleFactory(moduleType);
  }
  /**
   * Compiles the given NgModule and all of its components
   */
  compileModuleAsync(moduleType) {
    return Promise.resolve(this.compileModuleSync(moduleType));
  }
  /**
   * Same as {@link #compileModuleSync} but also creates ComponentFactories for all components.
   */
  compileModuleAndAllComponentsSync(moduleType) {
    const ngModuleFactory = this.compileModuleSync(moduleType);
    const moduleDef = getNgModuleDef(moduleType);
    const componentFactories = maybeUnwrapFn(moduleDef.declarations).reduce((factories, declaration) => {
      const componentDef = getComponentDef(declaration);
      componentDef && factories.push(new ComponentFactory(componentDef));
      return factories;
    }, []);
    return new ModuleWithComponentFactories(ngModuleFactory, componentFactories);
  }
  /**
   * Same as {@link #compileModuleAsync} but also creates ComponentFactories for all components.
   */
  compileModuleAndAllComponentsAsync(moduleType) {
    return Promise.resolve(this.compileModuleAndAllComponentsSync(moduleType));
  }
  /**
   * Clears all caches.
   */
  clearCache() {
  }
  /**
   * Clears the cache for the given component/ngModule.
   */
  clearCacheFor(type) {
  }
  /**
   * Returns the id for a given NgModule, if one is defined and known to the compiler.
   */
  getModuleId(moduleType) {
    return void 0;
  }
  static {
    this.ɵfac = function Compiler_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _Compiler)();
    };
  }
  static {
    this.ɵprov = ɵɵdefineInjectable({
      token: _Compiler,
      factory: _Compiler.ɵfac,
      providedIn: "root"
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(Compiler, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], null, null);
})();
var COMPILER_OPTIONS = new InjectionToken(ngDevMode ? "compilerOptions" : "");
var CompilerFactory = class {
};
function compileNgModuleFactory(injector, options, moduleType) {
  ngDevMode && assertNgModuleType(moduleType);
  const moduleFactory = new NgModuleFactory(moduleType);
  if (typeof ngJitMode !== "undefined" && !ngJitMode) {
    return Promise.resolve(moduleFactory);
  }
  const compilerOptions = injector.get(COMPILER_OPTIONS, []).concat(options);
  setJitOptions({
    defaultEncapsulation: _lastDefined(compilerOptions.map((opts) => opts.defaultEncapsulation)),
    preserveWhitespaces: _lastDefined(compilerOptions.map((opts) => opts.preserveWhitespaces))
  });
  if (isComponentResourceResolutionQueueEmpty()) {
    return Promise.resolve(moduleFactory);
  }
  const compilerProviders = compilerOptions.flatMap((option) => option.providers ?? []);
  if (compilerProviders.length === 0) {
    return Promise.resolve(moduleFactory);
  }
  const compiler = getCompilerFacade({
    usage: 0,
    kind: "NgModule",
    type: moduleType
  });
  const compilerInjector = Injector.create({
    providers: compilerProviders
  });
  const resourceLoader = compilerInjector.get(compiler.ResourceLoader);
  return resolveComponentResources((url) => Promise.resolve(resourceLoader.get(url))).then(() => moduleFactory);
}
function _lastDefined(args) {
  for (let i = args.length - 1; i >= 0; i--) {
    if (args[i] !== void 0) {
      return args[i];
    }
  }
  return void 0;
}
var NgZoneChangeDetectionScheduler = class _NgZoneChangeDetectionScheduler {
  constructor() {
    this.zone = inject(NgZone);
    this.changeDetectionScheduler = inject(ChangeDetectionScheduler);
    this.applicationRef = inject(ApplicationRef);
  }
  initialize() {
    if (this._onMicrotaskEmptySubscription) {
      return;
    }
    this._onMicrotaskEmptySubscription = this.zone.onMicrotaskEmpty.subscribe({
      next: () => {
        if (this.changeDetectionScheduler.runningTick) {
          return;
        }
        this.zone.run(() => {
          this.applicationRef.tick();
        });
      }
    });
  }
  ngOnDestroy() {
    this._onMicrotaskEmptySubscription?.unsubscribe();
  }
  static {
    this.ɵfac = function NgZoneChangeDetectionScheduler_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _NgZoneChangeDetectionScheduler)();
    };
  }
  static {
    this.ɵprov = ɵɵdefineInjectable({
      token: _NgZoneChangeDetectionScheduler,
      factory: _NgZoneChangeDetectionScheduler.ɵfac,
      providedIn: "root"
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NgZoneChangeDetectionScheduler, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], null, null);
})();
var PROVIDED_NG_ZONE = new InjectionToken(typeof ngDevMode === "undefined" || ngDevMode ? "provideZoneChangeDetection token" : "", {
  factory: () => false
});
function internalProvideZoneChangeDetection({
  ngZoneFactory,
  ignoreChangesOutsideZone
}) {
  ngZoneFactory ??= () => new NgZone(getNgZoneOptions());
  return [
    {
      provide: NgZone,
      useFactory: ngZoneFactory
    },
    {
      provide: ENVIRONMENT_INITIALIZER,
      multi: true,
      useFactory: () => {
        const ngZoneChangeDetectionScheduler = inject(NgZoneChangeDetectionScheduler, {
          optional: true
        });
        if ((typeof ngDevMode === "undefined" || ngDevMode) && ngZoneChangeDetectionScheduler === null) {
          throw new RuntimeError(402, `A required Injectable was not found in the dependency injection tree. If you are bootstrapping an NgModule, make sure that the \`BrowserModule\` is imported.`);
        }
        return () => ngZoneChangeDetectionScheduler.initialize();
      }
    },
    {
      provide: ENVIRONMENT_INITIALIZER,
      multi: true,
      useFactory: () => {
        const service = inject(ZoneStablePendingTask);
        return () => {
          service.initialize();
        };
      }
    },
    // Always disable scheduler whenever explicitly disabled, even if another place called
    // `provideZoneChangeDetection` without the 'ignore' option.
    ignoreChangesOutsideZone === true ? {
      provide: ZONELESS_SCHEDULER_DISABLED,
      useValue: true
    } : []
  ];
}
function provideZoneChangeDetection(options) {
  const ignoreChangesOutsideZone = options?.ignoreChangesOutsideZone;
  const zoneProviders = internalProvideZoneChangeDetection({
    ngZoneFactory: () => {
      const ngZoneOptions = getNgZoneOptions(options);
      if (ngZoneOptions.shouldCoalesceEventChangeDetection) {
        performanceMarkFeature("NgZone_CoalesceEvent");
      }
      return new NgZone(ngZoneOptions);
    },
    ignoreChangesOutsideZone
  });
  return makeEnvironmentProviders([{
    provide: PROVIDED_NG_ZONE,
    useValue: true
  }, {
    provide: ZONELESS_ENABLED,
    useValue: false
  }, zoneProviders]);
}
function getNgZoneOptions(options) {
  return {
    enableLongStackTrace: typeof ngDevMode === "undefined" ? false : !!ngDevMode,
    shouldCoalesceEventChangeDetection: options?.eventCoalescing ?? false,
    shouldCoalesceRunChangeDetection: options?.runCoalescing ?? false
  };
}
var ZoneStablePendingTask = class _ZoneStablePendingTask {
  constructor() {
    this.subscription = new Subscription();
    this.initialized = false;
    this.zone = inject(NgZone);
    this.pendingTasks = inject(PendingTasks);
  }
  initialize() {
    if (this.initialized) {
      return;
    }
    this.initialized = true;
    let task = null;
    if (!this.zone.isStable && !this.zone.hasPendingMacrotasks && !this.zone.hasPendingMicrotasks) {
      task = this.pendingTasks.add();
    }
    this.zone.runOutsideAngular(() => {
      this.subscription.add(this.zone.onStable.subscribe(() => {
        NgZone.assertNotInAngularZone();
        queueMicrotask(() => {
          if (task !== null && !this.zone.hasPendingMacrotasks && !this.zone.hasPendingMicrotasks) {
            this.pendingTasks.remove(task);
            task = null;
          }
        });
      }));
    });
    this.subscription.add(this.zone.onUnstable.subscribe(() => {
      NgZone.assertInAngularZone();
      task ??= this.pendingTasks.add();
    }));
  }
  ngOnDestroy() {
    this.subscription.unsubscribe();
  }
  static {
    this.ɵfac = function ZoneStablePendingTask_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _ZoneStablePendingTask)();
    };
  }
  static {
    this.ɵprov = ɵɵdefineInjectable({
      token: _ZoneStablePendingTask,
      factory: _ZoneStablePendingTask.ɵfac,
      providedIn: "root"
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ZoneStablePendingTask, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], null, null);
})();
var CONSECUTIVE_MICROTASK_NOTIFICATION_LIMIT = 100;
var consecutiveMicrotaskNotifications = 0;
var stackFromLastFewNotifications = [];
function trackMicrotaskNotificationForDebugging() {
  consecutiveMicrotaskNotifications++;
  if (CONSECUTIVE_MICROTASK_NOTIFICATION_LIMIT - consecutiveMicrotaskNotifications < 5) {
    const stack = new Error().stack;
    if (stack) {
      stackFromLastFewNotifications.push(stack);
    }
  }
  if (consecutiveMicrotaskNotifications === CONSECUTIVE_MICROTASK_NOTIFICATION_LIMIT) {
    throw new RuntimeError(103, "Angular could not stabilize because there were endless change notifications within the browser event loop. The stack from the last several notifications: \n" + stackFromLastFewNotifications.join("\n"));
  }
}
var ChangeDetectionSchedulerImpl = class _ChangeDetectionSchedulerImpl {
  constructor() {
    this.appRef = inject(ApplicationRef);
    this.taskService = inject(PendingTasks);
    this.ngZone = inject(NgZone);
    this.zonelessEnabled = inject(ZONELESS_ENABLED);
    this.disableScheduling = inject(ZONELESS_SCHEDULER_DISABLED, {
      optional: true
    }) ?? false;
    this.zoneIsDefined = typeof Zone !== "undefined" && !!Zone.root.run;
    this.schedulerTickApplyArgs = [{
      data: {
        "__scheduler_tick__": true
      }
    }];
    this.subscriptions = new Subscription();
    this.angularZoneId = this.zoneIsDefined ? this.ngZone._inner?.get(angularZoneInstanceIdProperty) : null;
    this.cancelScheduledCallback = null;
    this.shouldRefreshViews = false;
    this.useMicrotaskScheduler = false;
    this.runningTick = false;
    this.pendingRenderTaskId = null;
    this.subscriptions.add(this.appRef.afterTick.subscribe(() => {
      if (!this.runningTick) {
        this.cleanup();
      }
    }));
    this.subscriptions.add(this.ngZone.onUnstable.subscribe(() => {
      if (!this.runningTick) {
        this.cleanup();
      }
    }));
    this.disableScheduling ||= !this.zonelessEnabled && // NoopNgZone without enabling zoneless means no scheduling whatsoever
    (this.ngZone instanceof NoopNgZone || // The same goes for the lack of Zone without enabling zoneless scheduling
    !this.zoneIsDefined);
  }
  notify(source) {
    if (!this.zonelessEnabled && source === 5) {
      return;
    }
    switch (source) {
      case 3:
      case 2:
      case 0:
      case 4:
      case 5:
      case 1: {
        this.shouldRefreshViews = true;
        break;
      }
      case 8:
      case 7:
      case 6:
      case 9:
      default: {
      }
    }
    if (!this.shouldScheduleTick()) {
      return;
    }
    if (typeof ngDevMode === "undefined" || ngDevMode) {
      if (this.useMicrotaskScheduler) {
        trackMicrotaskNotificationForDebugging();
      } else {
        consecutiveMicrotaskNotifications = 0;
        stackFromLastFewNotifications.length = 0;
      }
    }
    const scheduleCallback = this.useMicrotaskScheduler ? scheduleCallbackWithMicrotask : scheduleCallbackWithRafRace;
    this.pendingRenderTaskId = this.taskService.add();
    if (this.zoneIsDefined) {
      Zone.root.run(() => {
        this.cancelScheduledCallback = scheduleCallback(() => {
          this.tick(this.shouldRefreshViews);
        });
      });
    } else {
      this.cancelScheduledCallback = scheduleCallback(() => {
        this.tick(this.shouldRefreshViews);
      });
    }
  }
  shouldScheduleTick() {
    if (this.disableScheduling) {
      return false;
    }
    if (this.pendingRenderTaskId !== null || this.runningTick || this.appRef._runningTick) {
      return false;
    }
    if (!this.zonelessEnabled && this.zoneIsDefined && Zone.current.get(angularZoneInstanceIdProperty + this.angularZoneId)) {
      return false;
    }
    return true;
  }
  /**
   * Calls ApplicationRef._tick inside the `NgZone`.
   *
   * Calling `tick` directly runs change detection and cancels any change detection that had been
   * scheduled previously.
   *
   * @param shouldRefreshViews Passed directly to `ApplicationRef._tick` and skips straight to
   *     render hooks when `false`.
   */
  tick(shouldRefreshViews) {
    if (this.runningTick || this.appRef.destroyed) {
      return;
    }
    const task = this.taskService.add();
    try {
      this.ngZone.run(() => {
        this.runningTick = true;
        this.appRef._tick(shouldRefreshViews);
      }, void 0, this.schedulerTickApplyArgs);
    } catch (e) {
      this.taskService.remove(task);
      throw e;
    } finally {
      this.cleanup();
    }
    this.useMicrotaskScheduler = true;
    scheduleCallbackWithMicrotask(() => {
      this.useMicrotaskScheduler = false;
      this.taskService.remove(task);
    });
  }
  ngOnDestroy() {
    this.subscriptions.unsubscribe();
    this.cleanup();
  }
  cleanup() {
    this.shouldRefreshViews = false;
    this.runningTick = false;
    this.cancelScheduledCallback?.();
    this.cancelScheduledCallback = null;
    if (this.pendingRenderTaskId !== null) {
      const taskId = this.pendingRenderTaskId;
      this.pendingRenderTaskId = null;
      this.taskService.remove(taskId);
    }
  }
  static {
    this.ɵfac = function ChangeDetectionSchedulerImpl_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _ChangeDetectionSchedulerImpl)();
    };
  }
  static {
    this.ɵprov = ɵɵdefineInjectable({
      token: _ChangeDetectionSchedulerImpl,
      factory: _ChangeDetectionSchedulerImpl.ɵfac,
      providedIn: "root"
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ChangeDetectionSchedulerImpl, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], () => [], null);
})();
function provideExperimentalZonelessChangeDetection() {
  performanceMarkFeature("NgZoneless");
  if ((typeof ngDevMode === "undefined" || ngDevMode) && typeof Zone !== "undefined" && Zone) {
    const message = formatRuntimeError(914, `The application is using zoneless change detection, but is still loading Zone.js. Consider removing Zone.js to get the full benefits of zoneless. In applications using the Angular CLI, Zone.js is typically included in the "polyfills" section of the angular.json file.`);
    console.warn(message);
  }
  return makeEnvironmentProviders([{
    provide: ChangeDetectionScheduler,
    useExisting: ChangeDetectionSchedulerImpl
  }, {
    provide: NgZone,
    useClass: NoopNgZone
  }, {
    provide: ZONELESS_ENABLED,
    useValue: true
  }, typeof ngDevMode === "undefined" || ngDevMode ? [{
    provide: PROVIDED_ZONELESS,
    useValue: true
  }] : []]);
}
function getGlobalLocale() {
  if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode && typeof goog !== "undefined" && goog.LOCALE !== "en") {
    return goog.LOCALE;
  } else {
    return typeof $localize !== "undefined" && $localize.locale || DEFAULT_LOCALE_ID;
  }
}
var LOCALE_ID = new InjectionToken(ngDevMode ? "LocaleId" : "", {
  providedIn: "root",
  factory: () => inject(LOCALE_ID, InjectFlags.Optional | InjectFlags.SkipSelf) || getGlobalLocale()
});
var DEFAULT_CURRENCY_CODE = new InjectionToken(ngDevMode ? "DefaultCurrencyCode" : "", {
  providedIn: "root",
  factory: () => USD_CURRENCY_CODE
});
var TRANSLATIONS = new InjectionToken(ngDevMode ? "Translations" : "");
var TRANSLATIONS_FORMAT = new InjectionToken(ngDevMode ? "TranslationsFormat" : "");
var MissingTranslationStrategy;
(function(MissingTranslationStrategy2) {
  MissingTranslationStrategy2[MissingTranslationStrategy2["Error"] = 0] = "Error";
  MissingTranslationStrategy2[MissingTranslationStrategy2["Warning"] = 1] = "Warning";
  MissingTranslationStrategy2[MissingTranslationStrategy2["Ignore"] = 2] = "Ignore";
})(MissingTranslationStrategy || (MissingTranslationStrategy = {}));
var SCAN_DELAY = 200;
var OVERSIZED_IMAGE_TOLERANCE = 1200;
var ImagePerformanceWarning = class _ImagePerformanceWarning {
  constructor() {
    this.window = null;
    this.observer = null;
    this.options = inject(IMAGE_CONFIG);
    this.isBrowser = inject(PLATFORM_ID) === "browser";
  }
  start() {
    if (!this.isBrowser || typeof PerformanceObserver === "undefined" || this.options?.disableImageSizeWarning && this.options?.disableImageLazyLoadWarning) {
      return;
    }
    this.observer = this.initPerformanceObserver();
    const doc = getDocument();
    const win = doc.defaultView;
    if (typeof win !== "undefined") {
      this.window = win;
      const waitToScan = () => {
        setTimeout(this.scanImages.bind(this), SCAN_DELAY);
      };
      const setup = () => {
        if (doc.readyState === "complete") {
          waitToScan();
        } else {
          this.window?.addEventListener("load", waitToScan, {
            once: true
          });
        }
      };
      if (typeof Zone !== "undefined") {
        Zone.root.run(() => setup());
      } else {
        setup();
      }
    }
  }
  ngOnDestroy() {
    this.observer?.disconnect();
  }
  initPerformanceObserver() {
    if (typeof PerformanceObserver === "undefined") {
      return null;
    }
    const observer = new PerformanceObserver((entryList) => {
      const entries = entryList.getEntries();
      if (entries.length === 0) return;
      const lcpElement = entries[entries.length - 1];
      const imgSrc = lcpElement.element?.src ?? "";
      if (imgSrc.startsWith("data:") || imgSrc.startsWith("blob:")) return;
      this.lcpImageUrl = imgSrc;
    });
    observer.observe({
      type: "largest-contentful-paint",
      buffered: true
    });
    return observer;
  }
  scanImages() {
    const images = getDocument().querySelectorAll("img");
    let lcpElementFound, lcpElementLoadedCorrectly = false;
    images.forEach((image) => {
      if (!this.options?.disableImageSizeWarning) {
        for (const image2 of images) {
          if (!image2.getAttribute("ng-img") && this.isOversized(image2)) {
            logOversizedImageWarning(image2.src);
          }
        }
      }
      if (!this.options?.disableImageLazyLoadWarning && this.lcpImageUrl) {
        if (image.src === this.lcpImageUrl) {
          lcpElementFound = true;
          if (image.loading !== "lazy" || image.getAttribute("ng-img")) {
            lcpElementLoadedCorrectly = true;
          }
        }
      }
    });
    if (lcpElementFound && !lcpElementLoadedCorrectly && this.lcpImageUrl && !this.options?.disableImageLazyLoadWarning) {
      logLazyLCPWarning(this.lcpImageUrl);
    }
  }
  isOversized(image) {
    if (!this.window) {
      return false;
    }
    const computedStyle = this.window.getComputedStyle(image);
    let renderedWidth = parseFloat(computedStyle.getPropertyValue("width"));
    let renderedHeight = parseFloat(computedStyle.getPropertyValue("height"));
    const boxSizing = computedStyle.getPropertyValue("box-sizing");
    const objectFit = computedStyle.getPropertyValue("object-fit");
    if (objectFit === `cover`) {
      return false;
    }
    if (boxSizing === "border-box") {
      const paddingTop = computedStyle.getPropertyValue("padding-top");
      const paddingRight = computedStyle.getPropertyValue("padding-right");
      const paddingBottom = computedStyle.getPropertyValue("padding-bottom");
      const paddingLeft = computedStyle.getPropertyValue("padding-left");
      renderedWidth -= parseFloat(paddingRight) + parseFloat(paddingLeft);
      renderedHeight -= parseFloat(paddingTop) + parseFloat(paddingBottom);
    }
    const intrinsicWidth = image.naturalWidth;
    const intrinsicHeight = image.naturalHeight;
    const recommendedWidth = this.window.devicePixelRatio * renderedWidth;
    const recommendedHeight = this.window.devicePixelRatio * renderedHeight;
    const oversizedWidth = intrinsicWidth - recommendedWidth >= OVERSIZED_IMAGE_TOLERANCE;
    const oversizedHeight = intrinsicHeight - recommendedHeight >= OVERSIZED_IMAGE_TOLERANCE;
    return oversizedWidth || oversizedHeight;
  }
  static {
    this.ɵfac = function ImagePerformanceWarning_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _ImagePerformanceWarning)();
    };
  }
  static {
    this.ɵprov = ɵɵdefineInjectable({
      token: _ImagePerformanceWarning,
      factory: _ImagePerformanceWarning.ɵfac,
      providedIn: "root"
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ImagePerformanceWarning, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], null, null);
})();
function logLazyLCPWarning(src) {
  console.warn(formatRuntimeError(-913, `An image with src ${src} is the Largest Contentful Paint (LCP) element but was given a "loading" value of "lazy", which can negatively impact application loading performance. This warning can be addressed by changing the loading value of the LCP image to "eager", or by using the NgOptimizedImage directive's prioritization utilities. For more information about addressing or disabling this warning, see https://angular.dev/errors/NG0913`));
}
function logOversizedImageWarning(src) {
  console.warn(formatRuntimeError(-913, `An image with src ${src} has intrinsic file dimensions much larger than its rendered size. This can negatively impact application loading performance. For more information about addressing or disabling this warning, see https://angular.dev/errors/NG0913`));
}
var PLATFORM_DESTROY_LISTENERS = new InjectionToken(ngDevMode ? "PlatformDestroyListeners" : "");
function isApplicationBootstrapConfig(config) {
  return !!config.platformInjector;
}
function bootstrap(config) {
  const envInjector = isApplicationBootstrapConfig(config) ? config.r3Injector : config.moduleRef.injector;
  const ngZone = envInjector.get(NgZone);
  return ngZone.run(() => {
    if (isApplicationBootstrapConfig(config)) {
      config.r3Injector.resolveInjectorInitializers();
    } else {
      config.moduleRef.resolveInjectorInitializers();
    }
    const exceptionHandler = envInjector.get(ErrorHandler, null);
    if (typeof ngDevMode === "undefined" || ngDevMode) {
      if (exceptionHandler === null) {
        const errorMessage = isApplicationBootstrapConfig(config) ? "No `ErrorHandler` found in the Dependency Injection tree." : "No ErrorHandler. Is platform module (BrowserModule) included";
        throw new RuntimeError(402, errorMessage);
      }
      if (envInjector.get(PROVIDED_ZONELESS) && envInjector.get(PROVIDED_NG_ZONE)) {
        throw new RuntimeError(408, "Invalid change detection configuration: provideZoneChangeDetection and provideExperimentalZonelessChangeDetection cannot be used together.");
      }
    }
    let onErrorSubscription;
    ngZone.runOutsideAngular(() => {
      onErrorSubscription = ngZone.onError.subscribe({
        next: (error) => {
          exceptionHandler.handleError(error);
        }
      });
    });
    if (isApplicationBootstrapConfig(config)) {
      const destroyListener = () => envInjector.destroy();
      const onPlatformDestroyListeners = config.platformInjector.get(PLATFORM_DESTROY_LISTENERS);
      onPlatformDestroyListeners.add(destroyListener);
      envInjector.onDestroy(() => {
        onErrorSubscription.unsubscribe();
        onPlatformDestroyListeners.delete(destroyListener);
      });
    } else {
      config.moduleRef.onDestroy(() => {
        remove(config.allPlatformModules, config.moduleRef);
        onErrorSubscription.unsubscribe();
      });
    }
    return _callAndReportToErrorHandler(exceptionHandler, ngZone, () => {
      const initStatus = envInjector.get(ApplicationInitStatus);
      initStatus.runInitializers();
      return initStatus.donePromise.then(() => {
        const localeId = envInjector.get(LOCALE_ID, DEFAULT_LOCALE_ID);
        setLocaleId(localeId || DEFAULT_LOCALE_ID);
        if (typeof ngDevMode === "undefined" || ngDevMode) {
          const imagePerformanceService = envInjector.get(ImagePerformanceWarning);
          imagePerformanceService.start();
        }
        if (isApplicationBootstrapConfig(config)) {
          const appRef = envInjector.get(ApplicationRef);
          if (config.rootComponent !== void 0) {
            appRef.bootstrap(config.rootComponent);
          }
          return appRef;
        } else {
          moduleDoBootstrap(config.moduleRef, config.allPlatformModules);
          return config.moduleRef;
        }
      });
    });
  });
}
function moduleDoBootstrap(moduleRef, allPlatformModules) {
  const appRef = moduleRef.injector.get(ApplicationRef);
  if (moduleRef._bootstrapComponents.length > 0) {
    moduleRef._bootstrapComponents.forEach((f) => appRef.bootstrap(f));
  } else if (moduleRef.instance.ngDoBootstrap) {
    moduleRef.instance.ngDoBootstrap(appRef);
  } else {
    throw new RuntimeError(-403, ngDevMode && `The module ${stringify(moduleRef.instance.constructor)} was bootstrapped, but it does not declare "@NgModule.bootstrap" components nor a "ngDoBootstrap" method. Please define one of these.`);
  }
  allPlatformModules.push(moduleRef);
}
var PlatformRef = class _PlatformRef {
  /** @internal */
  constructor(_injector) {
    this._injector = _injector;
    this._modules = [];
    this._destroyListeners = [];
    this._destroyed = false;
  }
  /**
   * Creates an instance of an `@NgModule` for the given platform.
   *
   * @deprecated Passing NgModule factories as the `PlatformRef.bootstrapModuleFactory` function
   *     argument is deprecated. Use the `PlatformRef.bootstrapModule` API instead.
   */
  bootstrapModuleFactory(moduleFactory, options) {
    const ngZoneFactory = () => getNgZone(options?.ngZone, getNgZoneOptions({
      eventCoalescing: options?.ngZoneEventCoalescing,
      runCoalescing: options?.ngZoneRunCoalescing
    }));
    const ignoreChangesOutsideZone = options?.ignoreChangesOutsideZone;
    const allAppProviders = [internalProvideZoneChangeDetection({
      ngZoneFactory,
      ignoreChangesOutsideZone
    }), {
      provide: ChangeDetectionScheduler,
      useExisting: ChangeDetectionSchedulerImpl
    }];
    const moduleRef = createNgModuleRefWithProviders(moduleFactory.moduleType, this.injector, allAppProviders);
    return bootstrap({
      moduleRef,
      allPlatformModules: this._modules
    });
  }
  /**
   * Creates an instance of an `@NgModule` for a given platform.
   *
   * @usageNotes
   * ### Simple Example
   *
   * ```typescript
   * @NgModule({
   *   imports: [BrowserModule]
   * })
   * class MyModule {}
   *
   * let moduleRef = platformBrowser().bootstrapModule(MyModule);
   * ```
   *
   */
  bootstrapModule(moduleType, compilerOptions = []) {
    const options = optionsReducer({}, compilerOptions);
    return compileNgModuleFactory(this.injector, options, moduleType).then((moduleFactory) => this.bootstrapModuleFactory(moduleFactory, options));
  }
  /**
   * Registers a listener to be called when the platform is destroyed.
   */
  onDestroy(callback) {
    this._destroyListeners.push(callback);
  }
  /**
   * Retrieves the platform {@link Injector}, which is the parent injector for
   * every Angular application on the page and provides singleton providers.
   */
  get injector() {
    return this._injector;
  }
  /**
   * Destroys the current Angular platform and all Angular applications on the page.
   * Destroys all modules and listeners registered with the platform.
   */
  destroy() {
    if (this._destroyed) {
      throw new RuntimeError(404, ngDevMode && "The platform has already been destroyed!");
    }
    this._modules.slice().forEach((module) => module.destroy());
    this._destroyListeners.forEach((listener) => listener());
    const destroyListeners = this._injector.get(PLATFORM_DESTROY_LISTENERS, null);
    if (destroyListeners) {
      destroyListeners.forEach((listener) => listener());
      destroyListeners.clear();
    }
    this._destroyed = true;
  }
  /**
   * Indicates whether this instance was destroyed.
   */
  get destroyed() {
    return this._destroyed;
  }
  static {
    this.ɵfac = function PlatformRef_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _PlatformRef)(ɵɵinject(Injector));
    };
  }
  static {
    this.ɵprov = ɵɵdefineInjectable({
      token: _PlatformRef,
      factory: _PlatformRef.ɵfac,
      providedIn: "platform"
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PlatformRef, [{
    type: Injectable,
    args: [{
      providedIn: "platform"
    }]
  }], () => [{
    type: Injector
  }], null);
})();
var _platformInjector = null;
var ALLOW_MULTIPLE_PLATFORMS = new InjectionToken(ngDevMode ? "AllowMultipleToken" : "");
function createPlatform(injector) {
  if (_platformInjector && !_platformInjector.get(ALLOW_MULTIPLE_PLATFORMS, false)) {
    throw new RuntimeError(400, ngDevMode && "There can be only one platform. Destroy the previous one to create a new one.");
  }
  publishDefaultGlobalUtils();
  publishSignalConfiguration();
  _platformInjector = injector;
  const platform = injector.get(PlatformRef);
  runPlatformInitializers(injector);
  return platform;
}
function createPlatformFactory(parentPlatformFactory, name, providers = []) {
  const desc = `Platform: ${name}`;
  const marker = new InjectionToken(desc);
  return (extraProviders = []) => {
    let platform = getPlatform();
    if (!platform || platform.injector.get(ALLOW_MULTIPLE_PLATFORMS, false)) {
      const platformProviders = [...providers, ...extraProviders, {
        provide: marker,
        useValue: true
      }];
      if (parentPlatformFactory) {
        parentPlatformFactory(platformProviders);
      } else {
        createPlatform(createPlatformInjector(platformProviders, desc));
      }
    }
    return assertPlatform(marker);
  };
}
function createPlatformInjector(providers = [], name) {
  return Injector.create({
    name,
    providers: [{
      provide: INJECTOR_SCOPE,
      useValue: "platform"
    }, {
      provide: PLATFORM_DESTROY_LISTENERS,
      useValue: /* @__PURE__ */ new Set([() => _platformInjector = null])
    }, ...providers]
  });
}
function assertPlatform(requiredToken) {
  const platform = getPlatform();
  if (!platform) {
    throw new RuntimeError(401, ngDevMode && "No platform exists!");
  }
  if ((typeof ngDevMode === "undefined" || ngDevMode) && !platform.injector.get(requiredToken, null)) {
    throw new RuntimeError(400, "A platform with a different configuration has been created. Please destroy it first.");
  }
  return platform;
}
function getPlatform() {
  return _platformInjector?.get(PlatformRef) ?? null;
}
function destroyPlatform() {
  getPlatform()?.destroy();
}
function createOrReusePlatformInjector(providers = []) {
  if (_platformInjector) return _platformInjector;
  publishDefaultGlobalUtils();
  const injector = createPlatformInjector(providers);
  _platformInjector = injector;
  publishSignalConfiguration();
  runPlatformInitializers(injector);
  return injector;
}
function runPlatformInitializers(injector) {
  const inits = injector.get(PLATFORM_INITIALIZER, null);
  inits?.forEach((init) => init());
}
function provideExperimentalCheckNoChangesForDebug(options) {
  if (typeof ngDevMode === "undefined" || ngDevMode) {
    if (options.interval === void 0 && !options.useNgZoneOnStable) {
      throw new Error("Must provide one of `useNgZoneOnStable` or `interval`");
    }
    const checkNoChangesMode = options?.exhaustive === false ? CheckNoChangesMode.OnlyDirtyViews : CheckNoChangesMode.Exhaustive;
    return makeEnvironmentProviders([options?.useNgZoneOnStable ? {
      provide: NgZone,
      useFactory: () => new DebugNgZoneForCheckNoChanges(checkNoChangesMode)
    } : [], options?.interval !== void 0 ? exhaustiveCheckNoChangesInterval(options.interval, checkNoChangesMode) : [], {
      provide: ENVIRONMENT_INITIALIZER,
      multi: true,
      useValue: () => {
        if (options?.useNgZoneOnStable && !(inject(NgZone) instanceof DebugNgZoneForCheckNoChanges)) {
          throw new Error("`provideExperimentalCheckNoChangesForDebug` with `useNgZoneOnStable` must be after any other provider for `NgZone`.");
        }
      }
    }]);
  } else {
    return makeEnvironmentProviders([]);
  }
}
var DebugNgZoneForCheckNoChanges = class extends NgZone {
  constructor(checkNoChangesMode) {
    const zonelessEnabled = inject(ZONELESS_ENABLED);
    super({
      shouldCoalesceEventChangeDetection: true,
      shouldCoalesceRunChangeDetection: zonelessEnabled
    });
    this.checkNoChangesMode = checkNoChangesMode;
    this.injector = inject(EnvironmentInjector);
    if (zonelessEnabled) {
      this.onMicrotaskEmpty.emit = () => {
      };
      this.onStable.emit = () => {
        this.scheduler ||= this.injector.get(ChangeDetectionSchedulerImpl);
        if (this.scheduler.pendingRenderTaskId || this.scheduler.runningTick) {
          return;
        }
        this.checkApplicationViews();
      };
      this.onUnstable.emit = () => {
      };
    } else {
      this.runOutsideAngular(() => {
        this.onStable.subscribe(() => {
          this.checkApplicationViews();
        });
      });
    }
  }
  checkApplicationViews() {
    this.applicationRef ||= this.injector.get(ApplicationRef);
    for (const view of this.applicationRef.allViews) {
      try {
        checkNoChangesInternal(view._lView, this.checkNoChangesMode, view.notifyErrorHandler);
      } catch (e) {
        this.errorHandler ||= this.injector.get(ErrorHandler);
        this.errorHandler.handleError(e);
      }
    }
  }
};
function exhaustiveCheckNoChangesInterval(interval, checkNoChangesMode) {
  return {
    provide: ENVIRONMENT_INITIALIZER,
    multi: true,
    useFactory: () => {
      const applicationRef = inject(ApplicationRef);
      const errorHandler = inject(ErrorHandler);
      const scheduler = inject(ChangeDetectionSchedulerImpl);
      const ngZone = inject(NgZone);
      return () => {
        function scheduleCheckNoChanges() {
          ngZone.runOutsideAngular(() => {
            setTimeout(() => {
              if (applicationRef.destroyed) {
                return;
              }
              if (scheduler.pendingRenderTaskId || scheduler.runningTick) {
                scheduleCheckNoChanges();
                return;
              }
              for (const view of applicationRef.allViews) {
                try {
                  checkNoChangesInternal(view._lView, checkNoChangesMode, view.notifyErrorHandler);
                } catch (e) {
                  errorHandler.handleError(e);
                }
              }
              scheduleCheckNoChanges();
            }, interval);
          });
        }
        scheduleCheckNoChanges();
      };
    }
  };
}
function isDevMode() {
  return typeof ngDevMode === "undefined" || !!ngDevMode;
}
function enableProdMode() {
  if (typeof ngDevMode === "undefined" || ngDevMode) {
    _global["ngDevMode"] = false;
  }
}
function getModuleFactory(id) {
  const type = getRegisteredNgModuleType(id);
  if (!type) throw noModuleError(id);
  return new NgModuleFactory(type);
}
function getNgModuleById(id) {
  const type = getRegisteredNgModuleType(id);
  if (!type) throw noModuleError(id);
  return type;
}
function noModuleError(id) {
  return new Error(`No module with ID ${id} loaded`);
}
var ChangeDetectorRef = class {
  static {
    this.__NG_ELEMENT_ID__ = injectChangeDetectorRef;
  }
};
function injectChangeDetectorRef(flags) {
  return createViewRef(
    getCurrentTNode(),
    getLView(),
    (flags & 16) === 16
    /* InternalInjectFlags.ForPipe */
  );
}
function createViewRef(tNode, lView, isPipe2) {
  if (isComponentHost(tNode) && !isPipe2) {
    const componentView = getComponentLViewByIndex(tNode.index, lView);
    return new ViewRef$1(componentView, componentView);
  } else if (tNode.type & (3 | 12 | 32 | 128)) {
    const hostComponentView = lView[DECLARATION_COMPONENT_VIEW];
    return new ViewRef$1(hostComponentView, lView);
  }
  return null;
}
var ViewRef = class extends ChangeDetectorRef {
};
var EmbeddedViewRef = class extends ViewRef {
};
var DebugEventListener = class {
  constructor(name, callback) {
    this.name = name;
    this.callback = callback;
  }
};
function asNativeElements(debugEls) {
  return debugEls.map((el) => el.nativeElement);
}
var DebugNode = class {
  constructor(nativeNode) {
    this.nativeNode = nativeNode;
  }
  /**
   * The `DebugElement` parent. Will be `null` if this is the root element.
   */
  get parent() {
    const parent = this.nativeNode.parentNode;
    return parent ? new DebugElement(parent) : null;
  }
  /**
   * The host dependency injector. For example, the root element's component instance injector.
   */
  get injector() {
    return getInjector(this.nativeNode);
  }
  /**
   * The element's own component instance, if it has one.
   */
  get componentInstance() {
    const nativeElement = this.nativeNode;
    return nativeElement && (getComponent$1(nativeElement) || getOwningComponent(nativeElement));
  }
  /**
   * An object that provides parent context for this element. Often an ancestor component instance
   * that governs this element.
   *
   * When an element is repeated within *ngFor, the context is an `NgForOf` whose `$implicit`
   * property is the value of the row instance value. For example, the `hero` in `*ngFor="let hero
   * of heroes"`.
   */
  get context() {
    return getComponent$1(this.nativeNode) || getContext(this.nativeNode);
  }
  /**
   * The callbacks attached to the component's @Output properties and/or the element's event
   * properties.
   */
  get listeners() {
    return getListeners(this.nativeNode).filter((listener) => listener.type === "dom");
  }
  /**
   * Dictionary of objects associated with template local variables (e.g. #foo), keyed by the local
   * variable name.
   */
  get references() {
    return getLocalRefs(this.nativeNode);
  }
  /**
   * This component's injector lookup tokens. Includes the component itself plus the tokens that the
   * component lists in its providers metadata.
   */
  get providerTokens() {
    return getInjectionTokens(this.nativeNode);
  }
};
var DebugElement = class extends DebugNode {
  constructor(nativeNode) {
    ngDevMode && assertDomNode(nativeNode);
    super(nativeNode);
  }
  /**
   * The underlying DOM element at the root of the component.
   */
  get nativeElement() {
    return this.nativeNode.nodeType == Node.ELEMENT_NODE ? this.nativeNode : null;
  }
  /**
   * The element tag name, if it is an element.
   */
  get name() {
    const context = getLContext(this.nativeNode);
    const lView = context ? context.lView : null;
    if (lView !== null) {
      const tData = lView[TVIEW].data;
      const tNode = tData[context.nodeIndex];
      return tNode.value;
    } else {
      return this.nativeNode.nodeName;
    }
  }
  /**
   *  Gets a map of property names to property values for an element.
   *
   *  This map includes:
   *  - Regular property bindings (e.g. `[id]="id"`)
   *  - Host property bindings (e.g. `host: { '[id]': "id" }`)
   *  - Interpolated property bindings (e.g. `id="{{ value }}")
   *
   *  It does not include:
   *  - input property bindings (e.g. `[myCustomInput]="value"`)
   *  - attribute bindings (e.g. `[attr.role]="menu"`)
   */
  get properties() {
    const context = getLContext(this.nativeNode);
    const lView = context ? context.lView : null;
    if (lView === null) {
      return {};
    }
    const tData = lView[TVIEW].data;
    const tNode = tData[context.nodeIndex];
    const properties = {};
    copyDomProperties(this.nativeElement, properties);
    collectPropertyBindings(properties, tNode, lView, tData);
    return properties;
  }
  /**
   *  A map of attribute names to attribute values for an element.
   */
  // TODO: replace null by undefined in the return type
  get attributes() {
    const attributes = {};
    const element = this.nativeElement;
    if (!element) {
      return attributes;
    }
    const context = getLContext(element);
    const lView = context ? context.lView : null;
    if (lView === null) {
      return {};
    }
    const tNodeAttrs = lView[TVIEW].data[context.nodeIndex].attrs;
    const lowercaseTNodeAttrs = [];
    if (tNodeAttrs) {
      let i = 0;
      while (i < tNodeAttrs.length) {
        const attrName = tNodeAttrs[i];
        if (typeof attrName !== "string") break;
        const attrValue = tNodeAttrs[i + 1];
        attributes[attrName] = attrValue;
        lowercaseTNodeAttrs.push(attrName.toLowerCase());
        i += 2;
      }
    }
    for (const attr of element.attributes) {
      if (!lowercaseTNodeAttrs.includes(attr.name)) {
        attributes[attr.name] = attr.value;
      }
    }
    return attributes;
  }
  /**
   * The inline styles of the DOM element.
   */
  // TODO: replace null by undefined in the return type
  get styles() {
    const element = this.nativeElement;
    return element?.style ?? {};
  }
  /**
   * A map containing the class names on the element as keys.
   *
   * This map is derived from the `className` property of the DOM element.
   *
   * Note: The values of this object will always be `true`. The class key will not appear in the KV
   * object if it does not exist on the element.
   *
   * @see [Element.className](https://developer.mozilla.org/en-US/docs/Web/API/Element/className)
   */
  get classes() {
    const result = {};
    const element = this.nativeElement;
    const className = element.className;
    const classes = typeof className !== "string" ? className.baseVal.split(" ") : className.split(" ");
    classes.forEach((value) => result[value] = true);
    return result;
  }
  /**
   * The `childNodes` of the DOM element as a `DebugNode` array.
   *
   * @see [Node.childNodes](https://developer.mozilla.org/en-US/docs/Web/API/Node/childNodes)
   */
  get childNodes() {
    const childNodes = this.nativeNode.childNodes;
    const children = [];
    for (let i = 0; i < childNodes.length; i++) {
      const element = childNodes[i];
      children.push(getDebugNode(element));
    }
    return children;
  }
  /**
   * The immediate `DebugElement` children. Walk the tree by descending through `children`.
   */
  get children() {
    const nativeElement = this.nativeElement;
    if (!nativeElement) return [];
    const childNodes = nativeElement.children;
    const children = [];
    for (let i = 0; i < childNodes.length; i++) {
      const element = childNodes[i];
      children.push(getDebugNode(element));
    }
    return children;
  }
  /**
   * @returns the first `DebugElement` that matches the predicate at any depth in the subtree.
   */
  query(predicate) {
    const results = this.queryAll(predicate);
    return results[0] || null;
  }
  /**
   * @returns All `DebugElement` matches for the predicate at any depth in the subtree.
   */
  queryAll(predicate) {
    const matches = [];
    _queryAll(this, predicate, matches, true);
    return matches;
  }
  /**
   * @returns All `DebugNode` matches for the predicate at any depth in the subtree.
   */
  queryAllNodes(predicate) {
    const matches = [];
    _queryAll(this, predicate, matches, false);
    return matches;
  }
  /**
   * Triggers the event by its name if there is a corresponding listener in the element's
   * `listeners` collection.
   *
   * If the event lacks a listener or there's some other problem, consider
   * calling `nativeElement.dispatchEvent(eventObject)`.
   *
   * @param eventName The name of the event to trigger
   * @param eventObj The _event object_ expected by the handler
   *
   * @see [Testing components scenarios](guide/testing/components-scenarios#trigger-event-handler)
   */
  triggerEventHandler(eventName, eventObj) {
    const node = this.nativeNode;
    const invokedListeners = [];
    this.listeners.forEach((listener) => {
      if (listener.name === eventName) {
        const callback = listener.callback;
        callback.call(node, eventObj);
        invokedListeners.push(callback);
      }
    });
    if (typeof node.eventListeners === "function") {
      node.eventListeners(eventName).forEach((listener) => {
        if (listener.toString().indexOf("__ngUnwrap__") !== -1) {
          const unwrappedListener = listener("__ngUnwrap__");
          return invokedListeners.indexOf(unwrappedListener) === -1 && unwrappedListener.call(node, eventObj);
        }
      });
    }
  }
};
function copyDomProperties(element, properties) {
  if (element) {
    let obj = Object.getPrototypeOf(element);
    const NodePrototype = Node.prototype;
    while (obj !== null && obj !== NodePrototype) {
      const descriptors = Object.getOwnPropertyDescriptors(obj);
      for (let key in descriptors) {
        if (!key.startsWith("__") && !key.startsWith("on")) {
          const value = element[key];
          if (isPrimitiveValue(value)) {
            properties[key] = value;
          }
        }
      }
      obj = Object.getPrototypeOf(obj);
    }
  }
}
function isPrimitiveValue(value) {
  return typeof value === "string" || typeof value === "boolean" || typeof value === "number" || value === null;
}
function _queryAll(parentElement, predicate, matches, elementsOnly) {
  const context = getLContext(parentElement.nativeNode);
  const lView = context ? context.lView : null;
  if (lView !== null) {
    const parentTNode = lView[TVIEW].data[context.nodeIndex];
    _queryNodeChildren(parentTNode, lView, predicate, matches, elementsOnly, parentElement.nativeNode);
  } else {
    _queryNativeNodeDescendants(parentElement.nativeNode, predicate, matches, elementsOnly);
  }
}
function _queryNodeChildren(tNode, lView, predicate, matches, elementsOnly, rootNativeNode) {
  ngDevMode && assertTNodeForLView(tNode, lView);
  const nativeNode = getNativeByTNodeOrNull(tNode, lView);
  if (tNode.type & (3 | 8)) {
    _addQueryMatch(nativeNode, predicate, matches, elementsOnly, rootNativeNode);
    if (isComponentHost(tNode)) {
      const componentView = getComponentLViewByIndex(tNode.index, lView);
      if (componentView && componentView[TVIEW].firstChild) {
        _queryNodeChildren(componentView[TVIEW].firstChild, componentView, predicate, matches, elementsOnly, rootNativeNode);
      }
    } else {
      if (tNode.child) {
        _queryNodeChildren(tNode.child, lView, predicate, matches, elementsOnly, rootNativeNode);
      }
      nativeNode && _queryNativeNodeDescendants(nativeNode, predicate, matches, elementsOnly);
    }
    const nodeOrContainer = lView[tNode.index];
    if (isLContainer(nodeOrContainer)) {
      _queryNodeChildrenInContainer(nodeOrContainer, predicate, matches, elementsOnly, rootNativeNode);
    }
  } else if (tNode.type & 4) {
    const lContainer = lView[tNode.index];
    _addQueryMatch(lContainer[NATIVE], predicate, matches, elementsOnly, rootNativeNode);
    _queryNodeChildrenInContainer(lContainer, predicate, matches, elementsOnly, rootNativeNode);
  } else if (tNode.type & 16) {
    const componentView = lView[DECLARATION_COMPONENT_VIEW];
    const componentHost = componentView[T_HOST];
    const head = componentHost.projection[tNode.projection];
    if (Array.isArray(head)) {
      for (let nativeNode2 of head) {
        _addQueryMatch(nativeNode2, predicate, matches, elementsOnly, rootNativeNode);
      }
    } else if (head) {
      const nextLView = componentView[PARENT];
      const nextTNode = nextLView[TVIEW].data[head.index];
      _queryNodeChildren(nextTNode, nextLView, predicate, matches, elementsOnly, rootNativeNode);
    }
  } else if (tNode.child) {
    _queryNodeChildren(tNode.child, lView, predicate, matches, elementsOnly, rootNativeNode);
  }
  if (rootNativeNode !== nativeNode) {
    const nextTNode = tNode.flags & 2 ? tNode.projectionNext : tNode.next;
    if (nextTNode) {
      _queryNodeChildren(nextTNode, lView, predicate, matches, elementsOnly, rootNativeNode);
    }
  }
}
function _queryNodeChildrenInContainer(lContainer, predicate, matches, elementsOnly, rootNativeNode) {
  for (let i = CONTAINER_HEADER_OFFSET; i < lContainer.length; i++) {
    const childView = lContainer[i];
    const firstChild = childView[TVIEW].firstChild;
    if (firstChild) {
      _queryNodeChildren(firstChild, childView, predicate, matches, elementsOnly, rootNativeNode);
    }
  }
}
function _addQueryMatch(nativeNode, predicate, matches, elementsOnly, rootNativeNode) {
  if (rootNativeNode !== nativeNode) {
    const debugNode = getDebugNode(nativeNode);
    if (!debugNode) {
      return;
    }
    if (elementsOnly && debugNode instanceof DebugElement && predicate(debugNode) && matches.indexOf(debugNode) === -1) {
      matches.push(debugNode);
    } else if (!elementsOnly && predicate(debugNode) && matches.indexOf(debugNode) === -1) {
      matches.push(debugNode);
    }
  }
}
function _queryNativeNodeDescendants(parentNode, predicate, matches, elementsOnly) {
  const nodes = parentNode.childNodes;
  const length = nodes.length;
  for (let i = 0; i < length; i++) {
    const node = nodes[i];
    const debugNode = getDebugNode(node);
    if (debugNode) {
      if (elementsOnly && debugNode instanceof DebugElement && predicate(debugNode) && matches.indexOf(debugNode) === -1) {
        matches.push(debugNode);
      } else if (!elementsOnly && predicate(debugNode) && matches.indexOf(debugNode) === -1) {
        matches.push(debugNode);
      }
      _queryNativeNodeDescendants(node, predicate, matches, elementsOnly);
    }
  }
}
function collectPropertyBindings(properties, tNode, lView, tData) {
  let bindingIndexes = tNode.propertyBindings;
  if (bindingIndexes !== null) {
    for (let i = 0; i < bindingIndexes.length; i++) {
      const bindingIndex = bindingIndexes[i];
      const propMetadata = tData[bindingIndex];
      const metadataParts = propMetadata.split(INTERPOLATION_DELIMITER);
      const propertyName = metadataParts[0];
      if (metadataParts.length > 1) {
        let value = metadataParts[1];
        for (let j = 1; j < metadataParts.length - 1; j++) {
          value += renderStringify(lView[bindingIndex + j - 1]) + metadataParts[j + 1];
        }
        properties[propertyName] = value;
      } else {
        properties[propertyName] = lView[bindingIndex];
      }
    }
  }
}
var NG_DEBUG_PROPERTY = "__ng_debug__";
function getDebugNode(nativeNode) {
  if (nativeNode instanceof Node) {
    if (!nativeNode.hasOwnProperty(NG_DEBUG_PROPERTY)) {
      nativeNode[NG_DEBUG_PROPERTY] = nativeNode.nodeType == Node.ELEMENT_NODE ? new DebugElement(nativeNode) : new DebugNode(nativeNode);
    }
    return nativeNode[NG_DEBUG_PROPERTY];
  }
  return null;
}
var DefaultIterableDifferFactory = class {
  constructor() {
  }
  supports(obj) {
    return isListLikeIterable(obj);
  }
  create(trackByFn) {
    return new DefaultIterableDiffer(trackByFn);
  }
};
var trackByIdentity = (index, item) => item;
var DefaultIterableDiffer = class {
  constructor(trackByFn) {
    this.length = 0;
    this._linkedRecords = null;
    this._unlinkedRecords = null;
    this._previousItHead = null;
    this._itHead = null;
    this._itTail = null;
    this._additionsHead = null;
    this._additionsTail = null;
    this._movesHead = null;
    this._movesTail = null;
    this._removalsHead = null;
    this._removalsTail = null;
    this._identityChangesHead = null;
    this._identityChangesTail = null;
    this._trackByFn = trackByFn || trackByIdentity;
  }
  forEachItem(fn) {
    let record;
    for (record = this._itHead; record !== null; record = record._next) {
      fn(record);
    }
  }
  forEachOperation(fn) {
    let nextIt = this._itHead;
    let nextRemove = this._removalsHead;
    let addRemoveOffset = 0;
    let moveOffsets = null;
    while (nextIt || nextRemove) {
      const record = !nextRemove || nextIt && nextIt.currentIndex < getPreviousIndex(nextRemove, addRemoveOffset, moveOffsets) ? nextIt : nextRemove;
      const adjPreviousIndex = getPreviousIndex(record, addRemoveOffset, moveOffsets);
      const currentIndex = record.currentIndex;
      if (record === nextRemove) {
        addRemoveOffset--;
        nextRemove = nextRemove._nextRemoved;
      } else {
        nextIt = nextIt._next;
        if (record.previousIndex == null) {
          addRemoveOffset++;
        } else {
          if (!moveOffsets) moveOffsets = [];
          const localMovePreviousIndex = adjPreviousIndex - addRemoveOffset;
          const localCurrentIndex = currentIndex - addRemoveOffset;
          if (localMovePreviousIndex != localCurrentIndex) {
            for (let i = 0; i < localMovePreviousIndex; i++) {
              const offset = i < moveOffsets.length ? moveOffsets[i] : moveOffsets[i] = 0;
              const index = offset + i;
              if (localCurrentIndex <= index && index < localMovePreviousIndex) {
                moveOffsets[i] = offset + 1;
              }
            }
            const previousIndex = record.previousIndex;
            moveOffsets[previousIndex] = localCurrentIndex - localMovePreviousIndex;
          }
        }
      }
      if (adjPreviousIndex !== currentIndex) {
        fn(record, adjPreviousIndex, currentIndex);
      }
    }
  }
  forEachPreviousItem(fn) {
    let record;
    for (record = this._previousItHead; record !== null; record = record._nextPrevious) {
      fn(record);
    }
  }
  forEachAddedItem(fn) {
    let record;
    for (record = this._additionsHead; record !== null; record = record._nextAdded) {
      fn(record);
    }
  }
  forEachMovedItem(fn) {
    let record;
    for (record = this._movesHead; record !== null; record = record._nextMoved) {
      fn(record);
    }
  }
  forEachRemovedItem(fn) {
    let record;
    for (record = this._removalsHead; record !== null; record = record._nextRemoved) {
      fn(record);
    }
  }
  forEachIdentityChange(fn) {
    let record;
    for (record = this._identityChangesHead; record !== null; record = record._nextIdentityChange) {
      fn(record);
    }
  }
  diff(collection) {
    if (collection == null) collection = [];
    if (!isListLikeIterable(collection)) {
      throw new RuntimeError(900, ngDevMode && `Error trying to diff '${stringify(collection)}'. Only arrays and iterables are allowed`);
    }
    if (this.check(collection)) {
      return this;
    } else {
      return null;
    }
  }
  onDestroy() {
  }
  check(collection) {
    this._reset();
    let record = this._itHead;
    let mayBeDirty = false;
    let index;
    let item;
    let itemTrackBy;
    if (Array.isArray(collection)) {
      this.length = collection.length;
      for (let index2 = 0; index2 < this.length; index2++) {
        item = collection[index2];
        itemTrackBy = this._trackByFn(index2, item);
        if (record === null || !Object.is(record.trackById, itemTrackBy)) {
          record = this._mismatch(record, item, itemTrackBy, index2);
          mayBeDirty = true;
        } else {
          if (mayBeDirty) {
            record = this._verifyReinsertion(record, item, itemTrackBy, index2);
          }
          if (!Object.is(record.item, item)) this._addIdentityChange(record, item);
        }
        record = record._next;
      }
    } else {
      index = 0;
      iterateListLike(collection, (item2) => {
        itemTrackBy = this._trackByFn(index, item2);
        if (record === null || !Object.is(record.trackById, itemTrackBy)) {
          record = this._mismatch(record, item2, itemTrackBy, index);
          mayBeDirty = true;
        } else {
          if (mayBeDirty) {
            record = this._verifyReinsertion(record, item2, itemTrackBy, index);
          }
          if (!Object.is(record.item, item2)) this._addIdentityChange(record, item2);
        }
        record = record._next;
        index++;
      });
      this.length = index;
    }
    this._truncate(record);
    this.collection = collection;
    return this.isDirty;
  }
  /* CollectionChanges is considered dirty if it has any additions, moves, removals, or identity
   * changes.
   */
  get isDirty() {
    return this._additionsHead !== null || this._movesHead !== null || this._removalsHead !== null || this._identityChangesHead !== null;
  }
  /**
   * Reset the state of the change objects to show no changes. This means set previousKey to
   * currentKey, and clear all of the queues (additions, moves, removals).
   * Set the previousIndexes of moved and added items to their currentIndexes
   * Reset the list of additions, moves and removals
   *
   * @internal
   */
  _reset() {
    if (this.isDirty) {
      let record;
      for (record = this._previousItHead = this._itHead; record !== null; record = record._next) {
        record._nextPrevious = record._next;
      }
      for (record = this._additionsHead; record !== null; record = record._nextAdded) {
        record.previousIndex = record.currentIndex;
      }
      this._additionsHead = this._additionsTail = null;
      for (record = this._movesHead; record !== null; record = record._nextMoved) {
        record.previousIndex = record.currentIndex;
      }
      this._movesHead = this._movesTail = null;
      this._removalsHead = this._removalsTail = null;
      this._identityChangesHead = this._identityChangesTail = null;
    }
  }
  /**
   * This is the core function which handles differences between collections.
   *
   * - `record` is the record which we saw at this position last time. If null then it is a new
   *   item.
   * - `item` is the current item in the collection
   * - `index` is the position of the item in the collection
   *
   * @internal
   */
  _mismatch(record, item, itemTrackBy, index) {
    let previousRecord;
    if (record === null) {
      previousRecord = this._itTail;
    } else {
      previousRecord = record._prev;
      this._remove(record);
    }
    record = this._unlinkedRecords === null ? null : this._unlinkedRecords.get(itemTrackBy, null);
    if (record !== null) {
      if (!Object.is(record.item, item)) this._addIdentityChange(record, item);
      this._reinsertAfter(record, previousRecord, index);
    } else {
      record = this._linkedRecords === null ? null : this._linkedRecords.get(itemTrackBy, index);
      if (record !== null) {
        if (!Object.is(record.item, item)) this._addIdentityChange(record, item);
        this._moveAfter(record, previousRecord, index);
      } else {
        record = this._addAfter(new IterableChangeRecord_(item, itemTrackBy), previousRecord, index);
      }
    }
    return record;
  }
  /**
   * This check is only needed if an array contains duplicates. (Short circuit of nothing dirty)
   *
   * Use case: `[a, a]` => `[b, a, a]`
   *
   * If we did not have this check then the insertion of `b` would:
   *   1) evict first `a`
   *   2) insert `b` at `0` index.
   *   3) leave `a` at index `1` as is. <-- this is wrong!
   *   3) reinsert `a` at index 2. <-- this is wrong!
   *
   * The correct behavior is:
   *   1) evict first `a`
   *   2) insert `b` at `0` index.
   *   3) reinsert `a` at index 1.
   *   3) move `a` at from `1` to `2`.
   *
   *
   * Double check that we have not evicted a duplicate item. We need to check if the item type may
   * have already been removed:
   * The insertion of b will evict the first 'a'. If we don't reinsert it now it will be reinserted
   * at the end. Which will show up as the two 'a's switching position. This is incorrect, since a
   * better way to think of it is as insert of 'b' rather then switch 'a' with 'b' and then add 'a'
   * at the end.
   *
   * @internal
   */
  _verifyReinsertion(record, item, itemTrackBy, index) {
    let reinsertRecord = this._unlinkedRecords === null ? null : this._unlinkedRecords.get(itemTrackBy, null);
    if (reinsertRecord !== null) {
      record = this._reinsertAfter(reinsertRecord, record._prev, index);
    } else if (record.currentIndex != index) {
      record.currentIndex = index;
      this._addToMoves(record, index);
    }
    return record;
  }
  /**
   * Get rid of any excess {@link IterableChangeRecord_}s from the previous collection
   *
   * - `record` The first excess {@link IterableChangeRecord_}.
   *
   * @internal
   */
  _truncate(record) {
    while (record !== null) {
      const nextRecord = record._next;
      this._addToRemovals(this._unlink(record));
      record = nextRecord;
    }
    if (this._unlinkedRecords !== null) {
      this._unlinkedRecords.clear();
    }
    if (this._additionsTail !== null) {
      this._additionsTail._nextAdded = null;
    }
    if (this._movesTail !== null) {
      this._movesTail._nextMoved = null;
    }
    if (this._itTail !== null) {
      this._itTail._next = null;
    }
    if (this._removalsTail !== null) {
      this._removalsTail._nextRemoved = null;
    }
    if (this._identityChangesTail !== null) {
      this._identityChangesTail._nextIdentityChange = null;
    }
  }
  /** @internal */
  _reinsertAfter(record, prevRecord, index) {
    if (this._unlinkedRecords !== null) {
      this._unlinkedRecords.remove(record);
    }
    const prev = record._prevRemoved;
    const next = record._nextRemoved;
    if (prev === null) {
      this._removalsHead = next;
    } else {
      prev._nextRemoved = next;
    }
    if (next === null) {
      this._removalsTail = prev;
    } else {
      next._prevRemoved = prev;
    }
    this._insertAfter(record, prevRecord, index);
    this._addToMoves(record, index);
    return record;
  }
  /** @internal */
  _moveAfter(record, prevRecord, index) {
    this._unlink(record);
    this._insertAfter(record, prevRecord, index);
    this._addToMoves(record, index);
    return record;
  }
  /** @internal */
  _addAfter(record, prevRecord, index) {
    this._insertAfter(record, prevRecord, index);
    if (this._additionsTail === null) {
      this._additionsTail = this._additionsHead = record;
    } else {
      this._additionsTail = this._additionsTail._nextAdded = record;
    }
    return record;
  }
  /** @internal */
  _insertAfter(record, prevRecord, index) {
    const next = prevRecord === null ? this._itHead : prevRecord._next;
    record._next = next;
    record._prev = prevRecord;
    if (next === null) {
      this._itTail = record;
    } else {
      next._prev = record;
    }
    if (prevRecord === null) {
      this._itHead = record;
    } else {
      prevRecord._next = record;
    }
    if (this._linkedRecords === null) {
      this._linkedRecords = new _DuplicateMap();
    }
    this._linkedRecords.put(record);
    record.currentIndex = index;
    return record;
  }
  /** @internal */
  _remove(record) {
    return this._addToRemovals(this._unlink(record));
  }
  /** @internal */
  _unlink(record) {
    if (this._linkedRecords !== null) {
      this._linkedRecords.remove(record);
    }
    const prev = record._prev;
    const next = record._next;
    if (prev === null) {
      this._itHead = next;
    } else {
      prev._next = next;
    }
    if (next === null) {
      this._itTail = prev;
    } else {
      next._prev = prev;
    }
    return record;
  }
  /** @internal */
  _addToMoves(record, toIndex) {
    if (record.previousIndex === toIndex) {
      return record;
    }
    if (this._movesTail === null) {
      this._movesTail = this._movesHead = record;
    } else {
      this._movesTail = this._movesTail._nextMoved = record;
    }
    return record;
  }
  _addToRemovals(record) {
    if (this._unlinkedRecords === null) {
      this._unlinkedRecords = new _DuplicateMap();
    }
    this._unlinkedRecords.put(record);
    record.currentIndex = null;
    record._nextRemoved = null;
    if (this._removalsTail === null) {
      this._removalsTail = this._removalsHead = record;
      record._prevRemoved = null;
    } else {
      record._prevRemoved = this._removalsTail;
      this._removalsTail = this._removalsTail._nextRemoved = record;
    }
    return record;
  }
  /** @internal */
  _addIdentityChange(record, item) {
    record.item = item;
    if (this._identityChangesTail === null) {
      this._identityChangesTail = this._identityChangesHead = record;
    } else {
      this._identityChangesTail = this._identityChangesTail._nextIdentityChange = record;
    }
    return record;
  }
};
var IterableChangeRecord_ = class {
  constructor(item, trackById) {
    this.item = item;
    this.trackById = trackById;
    this.currentIndex = null;
    this.previousIndex = null;
    this._nextPrevious = null;
    this._prev = null;
    this._next = null;
    this._prevDup = null;
    this._nextDup = null;
    this._prevRemoved = null;
    this._nextRemoved = null;
    this._nextAdded = null;
    this._nextMoved = null;
    this._nextIdentityChange = null;
  }
};
var _DuplicateItemRecordList = class {
  constructor() {
    this._head = null;
    this._tail = null;
  }
  /**
   * Append the record to the list of duplicates.
   *
   * Note: by design all records in the list of duplicates hold the same value in record.item.
   */
  add(record) {
    if (this._head === null) {
      this._head = this._tail = record;
      record._nextDup = null;
      record._prevDup = null;
    } else {
      this._tail._nextDup = record;
      record._prevDup = this._tail;
      record._nextDup = null;
      this._tail = record;
    }
  }
  // Returns a IterableChangeRecord_ having IterableChangeRecord_.trackById == trackById and
  // IterableChangeRecord_.currentIndex >= atOrAfterIndex
  get(trackById, atOrAfterIndex) {
    let record;
    for (record = this._head; record !== null; record = record._nextDup) {
      if ((atOrAfterIndex === null || atOrAfterIndex <= record.currentIndex) && Object.is(record.trackById, trackById)) {
        return record;
      }
    }
    return null;
  }
  /**
   * Remove one {@link IterableChangeRecord_} from the list of duplicates.
   *
   * Returns whether the list of duplicates is empty.
   */
  remove(record) {
    const prev = record._prevDup;
    const next = record._nextDup;
    if (prev === null) {
      this._head = next;
    } else {
      prev._nextDup = next;
    }
    if (next === null) {
      this._tail = prev;
    } else {
      next._prevDup = prev;
    }
    return this._head === null;
  }
};
var _DuplicateMap = class {
  constructor() {
    this.map = /* @__PURE__ */ new Map();
  }
  put(record) {
    const key = record.trackById;
    let duplicates = this.map.get(key);
    if (!duplicates) {
      duplicates = new _DuplicateItemRecordList();
      this.map.set(key, duplicates);
    }
    duplicates.add(record);
  }
  /**
   * Retrieve the `value` using key. Because the IterableChangeRecord_ value may be one which we
   * have already iterated over, we use the `atOrAfterIndex` to pretend it is not there.
   *
   * Use case: `[a, b, c, a, a]` if we are at index `3` which is the second `a` then asking if we
   * have any more `a`s needs to return the second `a`.
   */
  get(trackById, atOrAfterIndex) {
    const key = trackById;
    const recordList = this.map.get(key);
    return recordList ? recordList.get(trackById, atOrAfterIndex) : null;
  }
  /**
   * Removes a {@link IterableChangeRecord_} from the list of duplicates.
   *
   * The list of duplicates also is removed from the map if it gets empty.
   */
  remove(record) {
    const key = record.trackById;
    const recordList = this.map.get(key);
    if (recordList.remove(record)) {
      this.map.delete(key);
    }
    return record;
  }
  get isEmpty() {
    return this.map.size === 0;
  }
  clear() {
    this.map.clear();
  }
};
function getPreviousIndex(item, addRemoveOffset, moveOffsets) {
  const previousIndex = item.previousIndex;
  if (previousIndex === null) return previousIndex;
  let moveOffset = 0;
  if (moveOffsets && previousIndex < moveOffsets.length) {
    moveOffset = moveOffsets[previousIndex];
  }
  return previousIndex + addRemoveOffset + moveOffset;
}
var DefaultKeyValueDifferFactory = class {
  constructor() {
  }
  supports(obj) {
    return obj instanceof Map || isJsObject(obj);
  }
  create() {
    return new DefaultKeyValueDiffer();
  }
};
var DefaultKeyValueDiffer = class {
  constructor() {
    this._records = /* @__PURE__ */ new Map();
    this._mapHead = null;
    this._appendAfter = null;
    this._previousMapHead = null;
    this._changesHead = null;
    this._changesTail = null;
    this._additionsHead = null;
    this._additionsTail = null;
    this._removalsHead = null;
    this._removalsTail = null;
  }
  get isDirty() {
    return this._additionsHead !== null || this._changesHead !== null || this._removalsHead !== null;
  }
  forEachItem(fn) {
    let record;
    for (record = this._mapHead; record !== null; record = record._next) {
      fn(record);
    }
  }
  forEachPreviousItem(fn) {
    let record;
    for (record = this._previousMapHead; record !== null; record = record._nextPrevious) {
      fn(record);
    }
  }
  forEachChangedItem(fn) {
    let record;
    for (record = this._changesHead; record !== null; record = record._nextChanged) {
      fn(record);
    }
  }
  forEachAddedItem(fn) {
    let record;
    for (record = this._additionsHead; record !== null; record = record._nextAdded) {
      fn(record);
    }
  }
  forEachRemovedItem(fn) {
    let record;
    for (record = this._removalsHead; record !== null; record = record._nextRemoved) {
      fn(record);
    }
  }
  diff(map2) {
    if (!map2) {
      map2 = /* @__PURE__ */ new Map();
    } else if (!(map2 instanceof Map || isJsObject(map2))) {
      throw new RuntimeError(900, ngDevMode && `Error trying to diff '${stringify(map2)}'. Only maps and objects are allowed`);
    }
    return this.check(map2) ? this : null;
  }
  onDestroy() {
  }
  /**
   * Check the current state of the map vs the previous.
   * The algorithm is optimised for when the keys do no change.
   */
  check(map2) {
    this._reset();
    let insertBefore = this._mapHead;
    this._appendAfter = null;
    this._forEach(map2, (value, key) => {
      if (insertBefore && insertBefore.key === key) {
        this._maybeAddToChanges(insertBefore, value);
        this._appendAfter = insertBefore;
        insertBefore = insertBefore._next;
      } else {
        const record = this._getOrCreateRecordForKey(key, value);
        insertBefore = this._insertBeforeOrAppend(insertBefore, record);
      }
    });
    if (insertBefore) {
      if (insertBefore._prev) {
        insertBefore._prev._next = null;
      }
      this._removalsHead = insertBefore;
      for (let record = insertBefore; record !== null; record = record._nextRemoved) {
        if (record === this._mapHead) {
          this._mapHead = null;
        }
        this._records.delete(record.key);
        record._nextRemoved = record._next;
        record.previousValue = record.currentValue;
        record.currentValue = null;
        record._prev = null;
        record._next = null;
      }
    }
    if (this._changesTail) this._changesTail._nextChanged = null;
    if (this._additionsTail) this._additionsTail._nextAdded = null;
    return this.isDirty;
  }
  /**
   * Inserts a record before `before` or append at the end of the list when `before` is null.
   *
   * Notes:
   * - This method appends at `this._appendAfter`,
   * - This method updates `this._appendAfter`,
   * - The return value is the new value for the insertion pointer.
   */
  _insertBeforeOrAppend(before, record) {
    if (before) {
      const prev = before._prev;
      record._next = before;
      record._prev = prev;
      before._prev = record;
      if (prev) {
        prev._next = record;
      }
      if (before === this._mapHead) {
        this._mapHead = record;
      }
      this._appendAfter = before;
      return before;
    }
    if (this._appendAfter) {
      this._appendAfter._next = record;
      record._prev = this._appendAfter;
    } else {
      this._mapHead = record;
    }
    this._appendAfter = record;
    return null;
  }
  _getOrCreateRecordForKey(key, value) {
    if (this._records.has(key)) {
      const record2 = this._records.get(key);
      this._maybeAddToChanges(record2, value);
      const prev = record2._prev;
      const next = record2._next;
      if (prev) {
        prev._next = next;
      }
      if (next) {
        next._prev = prev;
      }
      record2._next = null;
      record2._prev = null;
      return record2;
    }
    const record = new KeyValueChangeRecord_(key);
    this._records.set(key, record);
    record.currentValue = value;
    this._addToAdditions(record);
    return record;
  }
  /** @internal */
  _reset() {
    if (this.isDirty) {
      let record;
      this._previousMapHead = this._mapHead;
      for (record = this._previousMapHead; record !== null; record = record._next) {
        record._nextPrevious = record._next;
      }
      for (record = this._changesHead; record !== null; record = record._nextChanged) {
        record.previousValue = record.currentValue;
      }
      for (record = this._additionsHead; record != null; record = record._nextAdded) {
        record.previousValue = record.currentValue;
      }
      this._changesHead = this._changesTail = null;
      this._additionsHead = this._additionsTail = null;
      this._removalsHead = null;
    }
  }
  // Add the record or a given key to the list of changes only when the value has actually changed
  _maybeAddToChanges(record, newValue) {
    if (!Object.is(newValue, record.currentValue)) {
      record.previousValue = record.currentValue;
      record.currentValue = newValue;
      this._addToChanges(record);
    }
  }
  _addToAdditions(record) {
    if (this._additionsHead === null) {
      this._additionsHead = this._additionsTail = record;
    } else {
      this._additionsTail._nextAdded = record;
      this._additionsTail = record;
    }
  }
  _addToChanges(record) {
    if (this._changesHead === null) {
      this._changesHead = this._changesTail = record;
    } else {
      this._changesTail._nextChanged = record;
      this._changesTail = record;
    }
  }
  /** @internal */
  _forEach(obj, fn) {
    if (obj instanceof Map) {
      obj.forEach(fn);
    } else {
      Object.keys(obj).forEach((k) => fn(obj[k], k));
    }
  }
};
var KeyValueChangeRecord_ = class {
  constructor(key) {
    this.key = key;
    this.previousValue = null;
    this.currentValue = null;
    this._nextPrevious = null;
    this._next = null;
    this._prev = null;
    this._nextAdded = null;
    this._nextRemoved = null;
    this._nextChanged = null;
  }
};
function defaultIterableDiffersFactory() {
  return new IterableDiffers([new DefaultIterableDifferFactory()]);
}
var IterableDiffers = class _IterableDiffers {
  static {
    this.ɵprov = ɵɵdefineInjectable({
      token: _IterableDiffers,
      providedIn: "root",
      factory: defaultIterableDiffersFactory
    });
  }
  constructor(factories) {
    this.factories = factories;
  }
  static create(factories, parent) {
    if (parent != null) {
      const copied = parent.factories.slice();
      factories = factories.concat(copied);
    }
    return new _IterableDiffers(factories);
  }
  /**
   * Takes an array of {@link IterableDifferFactory} and returns a provider used to extend the
   * inherited {@link IterableDiffers} instance with the provided factories and return a new
   * {@link IterableDiffers} instance.
   *
   * @usageNotes
   * ### Example
   *
   * The following example shows how to extend an existing list of factories,
   * which will only be applied to the injector for this component and its children.
   * This step is all that's required to make a new {@link IterableDiffer} available.
   *
   * ```
   * @Component({
   *   viewProviders: [
   *     IterableDiffers.extend([new ImmutableListDiffer()])
   *   ]
   * })
   * ```
   */
  static extend(factories) {
    return {
      provide: _IterableDiffers,
      useFactory: (parent) => {
        return _IterableDiffers.create(factories, parent || defaultIterableDiffersFactory());
      },
      // Dependency technically isn't optional, but we can provide a better error message this way.
      deps: [[_IterableDiffers, new SkipSelf(), new Optional()]]
    };
  }
  find(iterable) {
    const factory = this.factories.find((f) => f.supports(iterable));
    if (factory != null) {
      return factory;
    } else {
      throw new RuntimeError(901, ngDevMode && `Cannot find a differ supporting object '${iterable}' of type '${getTypeNameForDebugging(iterable)}'`);
    }
  }
};
function getTypeNameForDebugging(type) {
  return type["name"] || typeof type;
}
function defaultKeyValueDiffersFactory() {
  return new KeyValueDiffers([new DefaultKeyValueDifferFactory()]);
}
var KeyValueDiffers = class _KeyValueDiffers {
  static {
    this.ɵprov = ɵɵdefineInjectable({
      token: _KeyValueDiffers,
      providedIn: "root",
      factory: defaultKeyValueDiffersFactory
    });
  }
  constructor(factories) {
    this.factories = factories;
  }
  static create(factories, parent) {
    if (parent) {
      const copied = parent.factories.slice();
      factories = factories.concat(copied);
    }
    return new _KeyValueDiffers(factories);
  }
  /**
   * Takes an array of {@link KeyValueDifferFactory} and returns a provider used to extend the
   * inherited {@link KeyValueDiffers} instance with the provided factories and return a new
   * {@link KeyValueDiffers} instance.
   *
   * @usageNotes
   * ### Example
   *
   * The following example shows how to extend an existing list of factories,
   * which will only be applied to the injector for this component and its children.
   * This step is all that's required to make a new {@link KeyValueDiffer} available.
   *
   * ```
   * @Component({
   *   viewProviders: [
   *     KeyValueDiffers.extend([new ImmutableMapDiffer()])
   *   ]
   * })
   * ```
   */
  static extend(factories) {
    return {
      provide: _KeyValueDiffers,
      useFactory: (parent) => {
        return _KeyValueDiffers.create(factories, parent || defaultKeyValueDiffersFactory());
      },
      // Dependency technically isn't optional, but we can provide a better error message this way.
      deps: [[_KeyValueDiffers, new SkipSelf(), new Optional()]]
    };
  }
  find(kv) {
    const factory = this.factories.find((f) => f.supports(kv));
    if (factory) {
      return factory;
    }
    throw new RuntimeError(901, ngDevMode && `Cannot find a differ supporting object '${kv}'`);
  }
};
var keyValDiff = [new DefaultKeyValueDifferFactory()];
var iterableDiff = [new DefaultIterableDifferFactory()];
var defaultIterableDiffers = new IterableDiffers(iterableDiff);
var defaultKeyValueDiffers = new KeyValueDiffers(keyValDiff);
var platformCore = createPlatformFactory(null, "core", []);
var ApplicationModule = class _ApplicationModule {
  // Inject ApplicationRef to make it eager...
  constructor(appRef) {
  }
  static {
    this.ɵfac = function ApplicationModule_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _ApplicationModule)(ɵɵinject(ApplicationRef));
    };
  }
  static {
    this.ɵmod = ɵɵdefineNgModule({
      type: _ApplicationModule
    });
  }
  static {
    this.ɵinj = ɵɵdefineInjector({});
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ApplicationModule, [{
    type: NgModule
  }], () => [{
    type: ApplicationRef
  }], null);
})();
function defaultEquals(a, b) {
  return Object.is(a, b);
}
var activeConsumer = null;
var SIGNAL2 = Symbol("SIGNAL");
function setActiveConsumer2(consumer) {
  const prev = activeConsumer;
  activeConsumer = consumer;
  return prev;
}
var REACTIVE_NODE2 = {
  version: 0,
  lastCleanEpoch: 0,
  dirty: false,
  producerNode: void 0,
  producerLastReadVersion: void 0,
  producerIndexOfThis: void 0,
  nextProducerIndex: 0,
  liveConsumerNode: void 0,
  liveConsumerIndexOfThis: void 0,
  consumerAllowSignalWrites: false,
  consumerIsAlwaysLive: false,
  producerMustRecompute: () => false,
  producerRecomputeValue: () => {
  },
  consumerMarkedDirty: () => {
  },
  consumerOnSignalRead: () => {
  }
};
function consumerBeforeComputation2(node) {
  node && (node.nextProducerIndex = 0);
  return setActiveConsumer2(node);
}
function consumerAfterComputation2(node, prevConsumer) {
  setActiveConsumer2(prevConsumer);
  if (!node || node.producerNode === void 0 || node.producerIndexOfThis === void 0 || node.producerLastReadVersion === void 0) {
    return;
  }
  if (consumerIsLive(node)) {
    for (let i = node.nextProducerIndex; i < node.producerNode.length; i++) {
      producerRemoveLiveConsumerAtIndex(node.producerNode[i], node.producerIndexOfThis[i]);
    }
  }
  while (node.producerNode.length > node.nextProducerIndex) {
    node.producerNode.pop();
    node.producerLastReadVersion.pop();
    node.producerIndexOfThis.pop();
  }
}
function producerRemoveLiveConsumerAtIndex(node, idx) {
  assertProducerNode(node);
  if (typeof ngDevMode !== "undefined" && ngDevMode && idx >= node.liveConsumerNode.length) {
    throw new Error(`Assertion error: active consumer index ${idx} is out of bounds of ${node.liveConsumerNode.length} consumers)`);
  }
  if (node.liveConsumerNode.length === 1 && isConsumerNode(node)) {
    for (let i = 0; i < node.producerNode.length; i++) {
      producerRemoveLiveConsumerAtIndex(node.producerNode[i], node.producerIndexOfThis[i]);
    }
  }
  const lastIdx = node.liveConsumerNode.length - 1;
  node.liveConsumerNode[idx] = node.liveConsumerNode[lastIdx];
  node.liveConsumerIndexOfThis[idx] = node.liveConsumerIndexOfThis[lastIdx];
  node.liveConsumerNode.length--;
  node.liveConsumerIndexOfThis.length--;
  if (idx < node.liveConsumerNode.length) {
    const idxProducer = node.liveConsumerIndexOfThis[idx];
    const consumer = node.liveConsumerNode[idx];
    assertConsumerNode(consumer);
    consumer.producerIndexOfThis[idxProducer] = idx;
  }
}
function consumerIsLive(node) {
  return node.consumerIsAlwaysLive || (node?.liveConsumerNode?.length ?? 0) > 0;
}
function assertConsumerNode(node) {
  node.producerNode ??= [];
  node.producerIndexOfThis ??= [];
  node.producerLastReadVersion ??= [];
}
function assertProducerNode(node) {
  node.liveConsumerNode ??= [];
  node.liveConsumerIndexOfThis ??= [];
}
function isConsumerNode(node) {
  return node.producerNode !== void 0;
}
var UNSET = Symbol("UNSET");
var COMPUTING = Symbol("COMPUTING");
var ERRORED = Symbol("ERRORED");
var COMPUTED_NODE = (() => {
  return __spreadProps(__spreadValues({}, REACTIVE_NODE2), {
    value: UNSET,
    dirty: true,
    error: null,
    equal: defaultEquals,
    producerMustRecompute(node) {
      return node.value === UNSET || node.value === COMPUTING;
    },
    producerRecomputeValue(node) {
      if (node.value === COMPUTING) {
        throw new Error("Detected cycle in computations.");
      }
      const oldValue = node.value;
      node.value = COMPUTING;
      const prevConsumer = consumerBeforeComputation2(node);
      let newValue;
      try {
        newValue = node.computation();
      } catch (err) {
        newValue = ERRORED;
        node.error = err;
      } finally {
        consumerAfterComputation2(node, prevConsumer);
      }
      if (oldValue !== UNSET && oldValue !== ERRORED && newValue !== ERRORED && node.equal(oldValue, newValue)) {
        node.value = oldValue;
        return;
      }
      node.value = newValue;
      node.version++;
    }
  });
})();
var SIGNAL_NODE2 = (() => {
  return __spreadProps(__spreadValues({}, REACTIVE_NODE2), {
    equal: defaultEquals,
    value: void 0
  });
})();
var NOOP_CLEANUP_FN = () => {
};
var WATCH_NODE = (() => {
  return __spreadProps(__spreadValues({}, REACTIVE_NODE2), {
    consumerIsAlwaysLive: true,
    consumerAllowSignalWrites: false,
    consumerMarkedDirty: (node) => {
      if (node.schedule !== null) {
        node.schedule(node.ref);
      }
    },
    hasRun: false,
    cleanupFn: NOOP_CLEANUP_FN
  });
})();
function setAlternateWeakRefImpl(impl) {
}
function internalCreateApplication(config) {
  try {
    const {
      rootComponent,
      appProviders,
      platformProviders
    } = config;
    if ((typeof ngDevMode === "undefined" || ngDevMode) && rootComponent !== void 0) {
      assertStandaloneComponentType(rootComponent);
    }
    const platformInjector = createOrReusePlatformInjector(platformProviders);
    const allAppProviders = [internalProvideZoneChangeDetection({}), {
      provide: ChangeDetectionScheduler,
      useExisting: ChangeDetectionSchedulerImpl
    }, ...appProviders || []];
    const adapter = new EnvironmentNgModuleRefAdapter({
      providers: allAppProviders,
      parent: platformInjector,
      debugName: typeof ngDevMode === "undefined" || ngDevMode ? "Environment Injector" : "",
      // We skip environment initializers because we need to run them inside the NgZone, which
      // happens after we get the NgZone instance from the Injector.
      runEnvironmentInitializers: false
    });
    return bootstrap({
      r3Injector: adapter.injector,
      platformInjector,
      rootComponent
    });
  } catch (e) {
    return Promise.reject(e);
  }
}
function getDeferBlocks(lView, deferBlocks) {
  const tView = lView[TVIEW];
  for (let i = HEADER_OFFSET; i < tView.bindingStartIndex; i++) {
    if (isLContainer(lView[i])) {
      const lContainer = lView[i];
      const isLast = i === tView.bindingStartIndex - 1;
      if (!isLast) {
        const tNode = tView.data[i];
        const tDetails = getTDeferBlockDetails(tView, tNode);
        if (isTDeferBlockDetails(tDetails)) {
          deferBlocks.push({
            lContainer,
            lView,
            tNode,
            tDetails
          });
          continue;
        }
      }
      for (let i2 = CONTAINER_HEADER_OFFSET; i2 < lContainer.length; i2++) {
        getDeferBlocks(lContainer[i2], deferBlocks);
      }
    } else if (isLView(lView[i])) {
      getDeferBlocks(lView[i], deferBlocks);
    }
  }
}
function invokeRegisteredListeners(event) {
  const handlerFns = event.currentTarget?.__jsaction_fns?.get(event.type);
  if (!handlerFns) {
    return;
  }
  for (const handler of handlerFns) {
    handler(event);
  }
}
function setJSActionAttributes(nativeElement, eventTypes) {
  if (!eventTypes.length) {
    return;
  }
  const parts = eventTypes.reduce((prev, curr) => prev + curr + ":;", "");
  const existingAttr = nativeElement.getAttribute(Attribute.JSACTION);
  nativeElement.setAttribute(Attribute.JSACTION, `${existingAttr ?? ""}${parts}`);
}
var sharedStashFunction = (rEl, eventType, listenerFn) => {
  const el = rEl;
  const eventListenerMap = el.__jsaction_fns ?? /* @__PURE__ */ new Map();
  const eventListeners = eventListenerMap.get(eventType) ?? [];
  eventListeners.push(listenerFn);
  eventListenerMap.set(eventType, eventListeners);
  el.__jsaction_fns = eventListenerMap;
};
var removeListeners = (el) => {
  el.removeAttribute(Attribute.JSACTION);
  el.__jsaction_fns = void 0;
};
var JSACTION_EVENT_CONTRACT = new InjectionToken(ngDevMode ? "EVENT_CONTRACT_DETAILS" : "", {
  providedIn: "root",
  factory: () => ({})
});
var GLOBAL_EVENT_DELEGATION = new InjectionToken(ngDevMode ? "GLOBAL_EVENT_DELEGATION" : "");
var GlobalEventDelegation = class _GlobalEventDelegation {
  constructor() {
    this.eventContractDetails = inject(JSACTION_EVENT_CONTRACT);
  }
  ngOnDestroy() {
    this.eventContractDetails.instance?.cleanUp();
  }
  supports(eventType) {
    return isEarlyEventType(eventType);
  }
  addEventListener(element, eventType, handler) {
    if (element.nodeType === Node.ELEMENT_NODE) {
      this.eventContractDetails.instance.addEvent(eventType);
      getDefaulted(element)[eventType] = "";
      sharedStashFunction(element, eventType, handler);
    } else {
      element.addEventListener(eventType, handler);
    }
    return () => this.removeEventListener(element, eventType, handler);
  }
  removeEventListener(element, eventType, callback) {
    if (element.nodeType === Node.ELEMENT_NODE) {
      getDefaulted(element)[eventType] = void 0;
    } else {
      element.removeEventListener(eventType, callback);
    }
  }
  static {
    this.ɵfac = function GlobalEventDelegation_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _GlobalEventDelegation)();
    };
  }
  static {
    this.ɵprov = ɵɵdefineInjectable({
      token: _GlobalEventDelegation,
      factory: _GlobalEventDelegation.ɵfac
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(GlobalEventDelegation, [{
    type: Injectable
  }], null, null);
})();
var initGlobalEventDelegation = (eventContractDetails, injector) => {
  if (injector.get(IS_EVENT_REPLAY_ENABLED, EVENT_REPLAY_ENABLED_DEFAULT)) {
    return;
  }
  const eventContract = eventContractDetails.instance = new EventContract(new EventContractContainer(document.body));
  const dispatcher = new EventDispatcher(
    invokeRegisteredListeners,
    /** clickModSupport */
    false
  );
  registerDispatcher$1(eventContract, dispatcher);
};
var jsactionSet = /* @__PURE__ */ new Set();
function isGlobalEventDelegationEnabled(injector) {
  return injector.get(IS_GLOBAL_EVENT_DELEGATION_ENABLED, false);
}
function shouldEnableEventReplay(injector) {
  return injector.get(IS_EVENT_REPLAY_ENABLED, EVENT_REPLAY_ENABLED_DEFAULT) && !isGlobalEventDelegationEnabled(injector);
}
function withEventReplay() {
  return [{
    provide: IS_EVENT_REPLAY_ENABLED,
    useFactory: () => {
      let isEnabled = true;
      if (isPlatformBrowser()) {
        const appId = inject(APP_ID);
        isEnabled = !!window._ejsas?.[appId];
      }
      if (isEnabled) {
        performanceMarkFeature("NgEventReplay");
      }
      return isEnabled;
    }
  }, {
    provide: ENVIRONMENT_INITIALIZER,
    useValue: () => {
      const injector = inject(Injector);
      if (isPlatformBrowser(injector) && shouldEnableEventReplay(injector)) {
        setStashFn((rEl, eventName, listenerFn) => {
          sharedStashFunction(rEl, eventName, listenerFn);
          jsactionSet.add(rEl);
        });
      }
    },
    multi: true
  }, {
    provide: APP_BOOTSTRAP_LISTENER,
    useFactory: () => {
      if (isPlatformBrowser()) {
        const injector = inject(Injector);
        const appRef = inject(ApplicationRef);
        return () => {
          if (!shouldEnableEventReplay(injector)) {
            return;
          }
          whenStable(appRef).then(() => {
            const eventContractDetails = injector.get(JSACTION_EVENT_CONTRACT);
            initEventReplay(eventContractDetails, injector);
            jsactionSet.forEach(removeListeners);
            setStashFn(() => {
            });
          });
        };
      }
      return () => {
      };
    },
    multi: true
  }];
}
var initEventReplay = (eventDelegation, injector) => {
  const appId = injector.get(APP_ID);
  const earlyJsactionData = window._ejsas[appId];
  const eventContract = eventDelegation.instance = new EventContract(new EventContractContainer(earlyJsactionData.c));
  for (const et of earlyJsactionData.et) {
    eventContract.addEvent(et);
  }
  for (const et of earlyJsactionData.etc) {
    eventContract.addEvent(et);
  }
  const eventInfos = getAppScopedQueuedEventInfos(appId);
  eventContract.replayEarlyEventInfos(eventInfos);
  clearAppScopedEarlyEventContract(appId);
  const dispatcher = new EventDispatcher(invokeRegisteredListeners);
  registerDispatcher$1(eventContract, dispatcher);
};
function collectDomEventsInfo(tView, lView, eventTypesToReplay) {
  const domEventsInfo = /* @__PURE__ */ new Map();
  const lCleanup = lView[CLEANUP];
  const tCleanup = tView.cleanup;
  if (!tCleanup || !lCleanup) {
    return domEventsInfo;
  }
  for (let i = 0; i < tCleanup.length; ) {
    const firstParam = tCleanup[i++];
    const secondParam = tCleanup[i++];
    if (typeof firstParam !== "string") {
      continue;
    }
    const eventType = firstParam;
    if (!isEarlyEventType(eventType)) {
      continue;
    }
    if (isCaptureEventType(eventType)) {
      eventTypesToReplay.capture.add(eventType);
    } else {
      eventTypesToReplay.regular.add(eventType);
    }
    const listenerElement = unwrapRNode(lView[secondParam]);
    i++;
    const useCaptureOrIndx = tCleanup[i++];
    const isDomEvent = typeof useCaptureOrIndx === "boolean" || useCaptureOrIndx >= 0;
    if (!isDomEvent) {
      continue;
    }
    if (!domEventsInfo.has(listenerElement)) {
      domEventsInfo.set(listenerElement, [eventType]);
    } else {
      domEventsInfo.get(listenerElement).push(eventType);
    }
  }
  return domEventsInfo;
}
var SerializedViewCollection = class {
  constructor() {
    this.views = [];
    this.indexByContent = /* @__PURE__ */ new Map();
  }
  add(serializedView) {
    const viewAsString = JSON.stringify(serializedView);
    if (!this.indexByContent.has(viewAsString)) {
      const index = this.views.length;
      this.views.push(serializedView);
      this.indexByContent.set(viewAsString, index);
      return index;
    }
    return this.indexByContent.get(viewAsString);
  }
  getAll() {
    return this.views;
  }
};
var tViewSsrId = 0;
function getSsrId(tView) {
  if (!tView.ssrId) {
    tView.ssrId = `t${tViewSsrId++}`;
  }
  return tView.ssrId;
}
function calcNumRootNodes(tView, lView, tNode) {
  const rootNodes = [];
  collectNativeNodes(tView, lView, tNode, rootNodes);
  return rootNodes.length;
}
function calcNumRootNodesInLContainer(lContainer) {
  const rootNodes = [];
  collectNativeNodesInLContainer(lContainer, rootNodes);
  return rootNodes.length;
}
function annotateComponentLViewForHydration(lView, context) {
  const hostElement = lView[HOST];
  if (hostElement && !hostElement.hasAttribute(SKIP_HYDRATION_ATTR_NAME)) {
    return annotateHostElementForHydration(hostElement, lView, context);
  }
  return null;
}
function annotateLContainerForHydration(lContainer, context) {
  const componentLView = unwrapLView(lContainer[HOST]);
  const componentLViewNghIndex = annotateComponentLViewForHydration(componentLView, context);
  if (componentLViewNghIndex === null) {
    return;
  }
  const hostElement = unwrapRNode(componentLView[HOST]);
  const rootLView = lContainer[PARENT];
  const rootLViewNghIndex = annotateHostElementForHydration(hostElement, rootLView, context);
  const renderer = componentLView[RENDERER];
  const finalIndex = `${componentLViewNghIndex}|${rootLViewNghIndex}`;
  renderer.setAttribute(hostElement, NGH_ATTR_NAME, finalIndex);
}
function annotateForHydration(appRef, doc) {
  const injector = appRef.injector;
  const isI18nHydrationEnabledVal = isI18nHydrationEnabled(injector);
  const serializedViewCollection = new SerializedViewCollection();
  const corruptedTextNodes = /* @__PURE__ */ new Map();
  const viewRefs = appRef._views;
  const shouldReplayEvents = injector.get(IS_EVENT_REPLAY_ENABLED, EVENT_REPLAY_ENABLED_DEFAULT);
  const eventTypesToReplay = {
    regular: /* @__PURE__ */ new Set(),
    capture: /* @__PURE__ */ new Set()
  };
  for (const viewRef of viewRefs) {
    const lNode = getLNodeForHydration(viewRef);
    if (lNode !== null) {
      const context = {
        serializedViewCollection,
        corruptedTextNodes,
        isI18nHydrationEnabled: isI18nHydrationEnabledVal,
        i18nChildren: /* @__PURE__ */ new Map(),
        eventTypesToReplay,
        shouldReplayEvents
      };
      if (isLContainer(lNode)) {
        annotateLContainerForHydration(lNode, context);
      } else {
        annotateComponentLViewForHydration(lNode, context);
      }
      insertCorruptedTextNodeMarkers(corruptedTextNodes, doc);
    }
  }
  const serializedViews = serializedViewCollection.getAll();
  const transferState = injector.get(TransferState);
  transferState.set(NGH_DATA_KEY, serializedViews);
  return eventTypesToReplay;
}
function serializeLContainer(lContainer, context) {
  const views = [];
  let lastViewAsString = "";
  for (let i = CONTAINER_HEADER_OFFSET; i < lContainer.length; i++) {
    let childLView = lContainer[i];
    let template;
    let numRootNodes;
    let serializedView;
    if (isRootView(childLView)) {
      childLView = childLView[HEADER_OFFSET];
      if (isLContainer(childLView)) {
        numRootNodes = calcNumRootNodesInLContainer(childLView) + 1;
        annotateLContainerForHydration(childLView, context);
        const componentLView = unwrapLView(childLView[HOST]);
        serializedView = {
          [TEMPLATE_ID]: componentLView[TVIEW].ssrId,
          [NUM_ROOT_NODES]: numRootNodes
        };
      }
    }
    if (!serializedView) {
      const childTView = childLView[TVIEW];
      if (childTView.type === 1) {
        template = childTView.ssrId;
        numRootNodes = 1;
      } else {
        template = getSsrId(childTView);
        numRootNodes = calcNumRootNodes(childTView, childLView, childTView.firstChild);
      }
      serializedView = __spreadValues({
        [TEMPLATE_ID]: template,
        [NUM_ROOT_NODES]: numRootNodes
      }, serializeLView(lContainer[i], context));
    }
    const currentViewAsString = JSON.stringify(serializedView);
    if (views.length > 0 && currentViewAsString === lastViewAsString) {
      const previousView = views[views.length - 1];
      previousView[MULTIPLIER] ??= 1;
      previousView[MULTIPLIER]++;
    } else {
      lastViewAsString = currentViewAsString;
      views.push(serializedView);
    }
  }
  return views;
}
function appendSerializedNodePath(ngh, tNode, lView, excludedParentNodes) {
  const noOffsetIndex = tNode.index - HEADER_OFFSET;
  ngh[NODES] ??= {};
  ngh[NODES][noOffsetIndex] ??= calcPathForNode(tNode, lView, excludedParentNodes);
}
function appendDisconnectedNodeIndex(ngh, tNodeOrNoOffsetIndex) {
  const noOffsetIndex = typeof tNodeOrNoOffsetIndex === "number" ? tNodeOrNoOffsetIndex : tNodeOrNoOffsetIndex.index - HEADER_OFFSET;
  ngh[DISCONNECTED_NODES] ??= [];
  if (!ngh[DISCONNECTED_NODES].includes(noOffsetIndex)) {
    ngh[DISCONNECTED_NODES].push(noOffsetIndex);
  }
}
function serializeLView(lView, context) {
  const ngh = {};
  const tView = lView[TVIEW];
  const i18nChildren = getOrComputeI18nChildren(tView, context);
  const nativeElementsToEventTypes = context.shouldReplayEvents ? collectDomEventsInfo(tView, lView, context.eventTypesToReplay) : null;
  for (let i = HEADER_OFFSET; i < tView.bindingStartIndex; i++) {
    const tNode = tView.data[i];
    const noOffsetIndex = i - HEADER_OFFSET;
    const i18nData = trySerializeI18nBlock(lView, i, context);
    if (i18nData) {
      ngh[I18N_DATA] ??= {};
      ngh[I18N_DATA][noOffsetIndex] = i18nData.caseQueue;
      for (const nodeNoOffsetIndex of i18nData.disconnectedNodes) {
        appendDisconnectedNodeIndex(ngh, nodeNoOffsetIndex);
      }
      for (const nodeNoOffsetIndex of i18nData.disjointNodes) {
        const tNode2 = tView.data[nodeNoOffsetIndex + HEADER_OFFSET];
        ngDevMode && assertTNode(tNode2);
        appendSerializedNodePath(ngh, tNode2, lView, i18nChildren);
      }
      continue;
    }
    if (!isTNodeShape(tNode)) {
      continue;
    }
    if (isDetachedByI18n(tNode)) {
      continue;
    }
    if (isDisconnectedNode(tNode, lView) && isContentProjectedNode(tNode)) {
      appendDisconnectedNodeIndex(ngh, tNode);
      continue;
    }
    if (nativeElementsToEventTypes && tNode.type & 2) {
      const nativeElement = unwrapRNode(lView[i]);
      if (nativeElementsToEventTypes.has(nativeElement)) {
        setJSActionAttributes(nativeElement, nativeElementsToEventTypes.get(nativeElement));
      }
    }
    if (Array.isArray(tNode.projection)) {
      for (const projectionHeadTNode of tNode.projection) {
        if (!projectionHeadTNode) continue;
        if (!Array.isArray(projectionHeadTNode)) {
          if (!isProjectionTNode(projectionHeadTNode) && !isInSkipHydrationBlock(projectionHeadTNode)) {
            if (isDisconnectedNode(projectionHeadTNode, lView)) {
              appendDisconnectedNodeIndex(ngh, projectionHeadTNode);
            } else {
              appendSerializedNodePath(ngh, projectionHeadTNode, lView, i18nChildren);
            }
          }
        } else {
          throw unsupportedProjectionOfDomNodes(unwrapRNode(lView[i]));
        }
      }
    }
    conditionallyAnnotateNodePath(ngh, tNode, lView, i18nChildren);
    if (isLContainer(lView[i])) {
      const embeddedTView = tNode.tView;
      if (embeddedTView !== null) {
        ngh[TEMPLATES] ??= {};
        ngh[TEMPLATES][noOffsetIndex] = getSsrId(embeddedTView);
      }
      const hostNode = lView[i][HOST];
      if (Array.isArray(hostNode)) {
        const targetNode = unwrapRNode(hostNode);
        if (!targetNode.hasAttribute(SKIP_HYDRATION_ATTR_NAME)) {
          annotateHostElementForHydration(targetNode, hostNode, context);
        }
      }
      ngh[CONTAINERS] ??= {};
      ngh[CONTAINERS][noOffsetIndex] = serializeLContainer(lView[i], context);
    } else if (Array.isArray(lView[i])) {
      const targetNode = unwrapRNode(lView[i][HOST]);
      if (!targetNode.hasAttribute(SKIP_HYDRATION_ATTR_NAME)) {
        annotateHostElementForHydration(targetNode, lView[i], context);
      }
    } else {
      if (tNode.type & 8) {
        ngh[ELEMENT_CONTAINERS] ??= {};
        ngh[ELEMENT_CONTAINERS][noOffsetIndex] = calcNumRootNodes(tView, lView, tNode.child);
      } else if (tNode.type & (16 | 128)) {
        let nextTNode = tNode.next;
        while (nextTNode !== null && nextTNode.type & (16 | 128)) {
          nextTNode = nextTNode.next;
        }
        if (nextTNode && !isInSkipHydrationBlock(nextTNode)) {
          appendSerializedNodePath(ngh, nextTNode, lView, i18nChildren);
        }
      } else if (tNode.type & 1) {
        const rNode = unwrapRNode(lView[i]);
        processTextNodeBeforeSerialization(context, rNode);
      }
    }
  }
  return ngh;
}
function conditionallyAnnotateNodePath(ngh, tNode, lView, excludedParentNodes) {
  if (tNode.projectionNext && tNode.projectionNext !== tNode.next && !isInSkipHydrationBlock(tNode.projectionNext)) {
    appendSerializedNodePath(ngh, tNode.projectionNext, lView, excludedParentNodes);
  }
  if (tNode.prev === null && tNode.parent !== null && isDisconnectedNode(tNode.parent, lView) && !isDisconnectedNode(tNode, lView)) {
    appendSerializedNodePath(ngh, tNode, lView, excludedParentNodes);
  }
}
function componentUsesShadowDomEncapsulation(lView) {
  const instance = lView[CONTEXT];
  return instance?.constructor ? getComponentDef(instance.constructor)?.encapsulation === ViewEncapsulation$1.ShadowDom : false;
}
function annotateHostElementForHydration(element, lView, context) {
  const renderer = lView[RENDERER];
  if (hasI18n(lView) && !isI18nHydrationSupportEnabled() || componentUsesShadowDomEncapsulation(lView)) {
    renderer.setAttribute(element, SKIP_HYDRATION_ATTR_NAME, "");
    return null;
  } else {
    const ngh = serializeLView(lView, context);
    const index = context.serializedViewCollection.add(ngh);
    renderer.setAttribute(element, NGH_ATTR_NAME, index.toString());
    return index;
  }
}
function insertCorruptedTextNodeMarkers(corruptedTextNodes, doc) {
  for (const [textNode, marker] of corruptedTextNodes) {
    textNode.after(doc.createComment(marker));
  }
}
function isContentProjectedNode(tNode) {
  let currentTNode = tNode;
  while (currentTNode != null) {
    if (isComponentHost(currentTNode)) {
      return true;
    }
    currentTNode = currentTNode.parent;
  }
  return false;
}
var isHydrationSupportEnabled = false;
var isI18nHydrationRuntimeSupportEnabled = false;
var APPLICATION_IS_STABLE_TIMEOUT = 1e4;
function enableHydrationRuntimeSupport() {
  if (!isHydrationSupportEnabled) {
    isHydrationSupportEnabled = true;
    enableRetrieveHydrationInfoImpl();
    enableLocateOrCreateElementNodeImpl();
    enableLocateOrCreateTextNodeImpl();
    enableLocateOrCreateElementContainerNodeImpl();
    enableLocateOrCreateContainerAnchorImpl();
    enableLocateOrCreateContainerRefImpl();
    enableFindMatchingDehydratedViewImpl();
    enableApplyRootElementTransformImpl();
  }
}
function enableI18nHydrationRuntimeSupport() {
  if (!isI18nHydrationRuntimeSupportEnabled) {
    isI18nHydrationRuntimeSupportEnabled = true;
    enableLocateOrCreateI18nNodeImpl();
    enablePrepareI18nBlockForHydrationImpl();
    enableClaimDehydratedIcuCaseImpl();
  }
}
function printHydrationStats(injector) {
  const console2 = injector.get(Console);
  const message = `Angular hydrated ${ngDevMode.hydratedComponents} component(s) and ${ngDevMode.hydratedNodes} node(s), ${ngDevMode.componentsSkippedHydration} component(s) were skipped. Learn more at https://angular.dev/guide/hydration.`;
  console2.log(message);
}
function whenStableWithTimeout(appRef, injector) {
  const whenStablePromise = whenStable(appRef);
  if (typeof ngDevMode !== "undefined" && ngDevMode) {
    const timeoutTime = APPLICATION_IS_STABLE_TIMEOUT;
    const console2 = injector.get(Console);
    const ngZone = injector.get(NgZone);
    const timeoutId = ngZone.runOutsideAngular(() => {
      return setTimeout(() => logWarningOnStableTimedout(timeoutTime, console2), timeoutTime);
    });
    whenStablePromise.finally(() => clearTimeout(timeoutId));
  }
  return whenStablePromise;
}
function withDomHydration() {
  return makeEnvironmentProviders([{
    provide: IS_HYDRATION_DOM_REUSE_ENABLED,
    useFactory: () => {
      let isEnabled = true;
      if (isPlatformBrowser()) {
        const transferState = inject(TransferState, {
          optional: true
        });
        isEnabled = !!transferState?.get(NGH_DATA_KEY, null);
        if (!isEnabled && typeof ngDevMode !== "undefined" && ngDevMode) {
          const console2 = inject(Console);
          const message = formatRuntimeError(-505, "Angular hydration was requested on the client, but there was no serialized information present in the server response, thus hydration was not enabled. Make sure the `provideClientHydration()` is included into the list of providers in the server part of the application configuration.");
          console2.warn(message);
        }
      }
      if (isEnabled) {
        performanceMarkFeature("NgHydration");
      }
      return isEnabled;
    }
  }, {
    provide: ENVIRONMENT_INITIALIZER,
    useValue: () => {
      setIsI18nHydrationSupportEnabled(false);
      if (isPlatformBrowser() && inject(IS_HYDRATION_DOM_REUSE_ENABLED)) {
        verifySsrContentsIntegrity();
        enableHydrationRuntimeSupport();
      }
    },
    multi: true
  }, {
    provide: PRESERVE_HOST_CONTENT,
    useFactory: () => {
      return isPlatformBrowser() && inject(IS_HYDRATION_DOM_REUSE_ENABLED);
    }
  }, {
    provide: APP_BOOTSTRAP_LISTENER,
    useFactory: () => {
      if (isPlatformBrowser() && inject(IS_HYDRATION_DOM_REUSE_ENABLED)) {
        const appRef = inject(ApplicationRef);
        const injector = inject(Injector);
        return () => {
          whenStableWithTimeout(appRef, injector).then(() => {
            cleanupDehydratedViews(appRef);
            if (typeof ngDevMode !== "undefined" && ngDevMode) {
              printHydrationStats(injector);
            }
          });
        };
      }
      return () => {
      };
    },
    multi: true
  }]);
}
function withI18nSupport() {
  return [{
    provide: IS_I18N_HYDRATION_ENABLED,
    useValue: true
  }, {
    provide: ENVIRONMENT_INITIALIZER,
    useValue: () => {
      enableI18nHydrationRuntimeSupport();
      setIsI18nHydrationSupportEnabled(true);
      performanceMarkFeature("NgI18nHydration");
    },
    multi: true
  }];
}
function logWarningOnStableTimedout(time, console2) {
  const message = `Angular hydration expected the ApplicationRef.isStable() to emit \`true\`, but it didn't happen within ${time}ms. Angular hydration logic depends on the application becoming stable as a signal to complete hydration process.`;
  console2.warn(formatRuntimeError(-506, message));
}
function verifySsrContentsIntegrity() {
  const doc = getDocument();
  let hydrationMarker;
  for (const node of doc.body.childNodes) {
    if (node.nodeType === Node.COMMENT_NODE && node.textContent?.trim() === SSR_CONTENT_INTEGRITY_MARKER) {
      hydrationMarker = node;
      break;
    }
  }
  if (!hydrationMarker) {
    throw new RuntimeError(-507, typeof ngDevMode !== "undefined" && ngDevMode && "Angular hydration logic detected that HTML content of this page was modified after it was produced during server side rendering. Make sure that there are no optimizations that remove comment nodes from HTML enabled on your CDN. Angular hydration relies on HTML produced by the server, including whitespaces and comment nodes.");
  }
}
function provideGlobalEventDelegation(multiContract = false) {
  return [{
    provide: IS_GLOBAL_EVENT_DELEGATION_ENABLED,
    useValue: true
  }, {
    provide: ENVIRONMENT_INITIALIZER,
    useValue: () => {
      const injector = inject(Injector);
      const eventContractDetails = injector.get(JSACTION_EVENT_CONTRACT);
      if (multiContract && window.__jsaction_contract) {
        eventContractDetails.instance = window.__jsaction_contract;
        return;
      }
      initGlobalEventDelegation(eventContractDetails, injector);
      window.__jsaction_contract = eventContractDetails.instance;
    },
    multi: true
  }, {
    provide: GLOBAL_EVENT_DELEGATION,
    useClass: GlobalEventDelegation
  }];
}
function queueStateUpdate(callback, options) {
  !options && assertInInjectionContext(queueStateUpdate);
  const injector = options?.injector ?? inject(Injector);
  const appRef = injector.get(ApplicationRef);
  let executed = false;
  const runCallbackOnce = () => {
    if (executed || appRef.destroyed) return;
    executed = true;
    callback();
  };
  internalAfterNextRender(runCallbackOnce, {
    injector,
    runOnServer: true
  });
  queueMicrotask(runCallbackOnce);
}
function booleanAttribute(value) {
  return typeof value === "boolean" ? value : value != null && value !== "false";
}
function numberAttribute(value, fallbackValue = NaN) {
  const isNumberValue = !isNaN(parseFloat(value)) && !isNaN(Number(value));
  return isNumberValue ? Number(value) : fallbackValue;
}
function ɵɵngDeclareDirective(decl) {
  const compiler = getCompilerFacade({
    usage: 1,
    kind: "directive",
    type: decl.type
  });
  return compiler.compileDirectiveDeclaration(angularCoreEnv, `ng:///${decl.type.name}/ɵfac.js`, decl);
}
function ɵɵngDeclareClassMetadata(decl) {
  setClassMetadata(decl.type, decl.decorators, decl.ctorParameters ?? null, decl.propDecorators ?? null);
}
function ɵɵngDeclareClassMetadataAsync(decl) {
  setClassMetadataAsync(decl.type, decl.resolveDeferredDeps, (...types) => {
    const meta = decl.resolveMetadata(...types);
    setClassMetadata(decl.type, meta.decorators, meta.ctorParameters, meta.propDecorators);
  });
}
function ɵɵngDeclareComponent(decl) {
  const compiler = getCompilerFacade({
    usage: 1,
    kind: "component",
    type: decl.type
  });
  return compiler.compileComponentDeclaration(angularCoreEnv, `ng:///${decl.type.name}/ɵcmp.js`, decl);
}
function ɵɵngDeclareFactory(decl) {
  const compiler = getCompilerFacade({
    usage: 1,
    kind: getFactoryKind(decl.target),
    type: decl.type
  });
  return compiler.compileFactoryDeclaration(angularCoreEnv, `ng:///${decl.type.name}/ɵfac.js`, decl);
}
function getFactoryKind(target) {
  switch (target) {
    case FactoryTarget.Directive:
      return "directive";
    case FactoryTarget.Component:
      return "component";
    case FactoryTarget.Injectable:
      return "injectable";
    case FactoryTarget.Pipe:
      return "pipe";
    case FactoryTarget.NgModule:
      return "NgModule";
  }
}
function ɵɵngDeclareInjectable(decl) {
  const compiler = getCompilerFacade({
    usage: 1,
    kind: "injectable",
    type: decl.type
  });
  return compiler.compileInjectableDeclaration(angularCoreEnv, `ng:///${decl.type.name}/ɵprov.js`, decl);
}
function ɵɵngDeclareInjector(decl) {
  const compiler = getCompilerFacade({
    usage: 1,
    kind: "NgModule",
    type: decl.type
  });
  return compiler.compileInjectorDeclaration(angularCoreEnv, `ng:///${decl.type.name}/ɵinj.js`, decl);
}
function ɵɵngDeclareNgModule(decl) {
  const compiler = getCompilerFacade({
    usage: 1,
    kind: "NgModule",
    type: decl.type
  });
  return compiler.compileNgModuleDeclaration(angularCoreEnv, `ng:///${decl.type.name}/ɵmod.js`, decl);
}
function ɵɵngDeclarePipe(decl) {
  const compiler = getCompilerFacade({
    usage: 1,
    kind: "pipe",
    type: decl.type
  });
  return compiler.compilePipeDeclaration(angularCoreEnv, `ng:///${decl.type.name}/ɵpipe.js`, decl);
}
function computed(computation, options) {
  performanceMarkFeature("NgSignals");
  const getter = createComputed(computation);
  if (options?.equal) {
    getter[SIGNAL].equal = options.equal;
  }
  if (ngDevMode) {
    getter.toString = () => `[Computed: ${getter()}]`;
  }
  return getter;
}
function untracked(nonReactiveReadsFn) {
  const prevConsumer = setActiveConsumer(null);
  try {
    return nonReactiveReadsFn();
  } finally {
    setActiveConsumer(prevConsumer);
  }
}
var APP_EFFECT_SCHEDULER = new InjectionToken("", {
  providedIn: "root",
  factory: () => inject(EffectScheduler)
});
var EffectScheduler = class _EffectScheduler {
  static {
    this.ɵprov = ɵɵdefineInjectable({
      token: _EffectScheduler,
      providedIn: "root",
      factory: () => new ZoneAwareEffectScheduler()
    });
  }
};
var ZoneAwareEffectScheduler = class {
  constructor() {
    this.queuedEffectCount = 0;
    this.queues = /* @__PURE__ */ new Map();
    this.pendingTasks = inject(PendingTasks);
    this.taskId = null;
  }
  scheduleEffect(handle) {
    this.enqueue(handle);
    if (this.taskId === null) {
      const taskId = this.taskId = this.pendingTasks.add();
      queueMicrotask(() => {
        this.flush();
        this.pendingTasks.remove(taskId);
        this.taskId = null;
      });
    }
  }
  enqueue(handle) {
    const zone = handle.creationZone;
    if (!this.queues.has(zone)) {
      this.queues.set(zone, /* @__PURE__ */ new Set());
    }
    const queue = this.queues.get(zone);
    if (queue.has(handle)) {
      return;
    }
    this.queuedEffectCount++;
    queue.add(handle);
  }
  /**
   * Run all scheduled effects.
   *
   * Execution order of effects within the same zone is guaranteed to be FIFO, but there is no
   * ordering guarantee between effects scheduled in different zones.
   */
  flush() {
    while (this.queuedEffectCount > 0) {
      for (const [zone, queue] of this.queues) {
        if (zone === null) {
          this.flushQueue(queue);
        } else {
          zone.run(() => this.flushQueue(queue));
        }
      }
    }
  }
  flushQueue(queue) {
    for (const handle of queue) {
      queue.delete(handle);
      this.queuedEffectCount--;
      handle.run();
    }
  }
};
var EffectHandle = class {
  constructor(scheduler, effectFn, creationZone, destroyRef, injector, allowSignalWrites) {
    this.scheduler = scheduler;
    this.effectFn = effectFn;
    this.creationZone = creationZone;
    this.injector = injector;
    this.watcher = createWatch((onCleanup) => this.runEffect(onCleanup), () => this.schedule(), allowSignalWrites);
    this.unregisterOnDestroy = destroyRef?.onDestroy(() => this.destroy());
  }
  runEffect(onCleanup) {
    try {
      this.effectFn(onCleanup);
    } catch (err) {
      const errorHandler = this.injector.get(ErrorHandler, null, {
        optional: true
      });
      errorHandler?.handleError(err);
    }
  }
  run() {
    this.watcher.run();
  }
  schedule() {
    this.scheduler.scheduleEffect(this);
  }
  destroy() {
    this.watcher.destroy();
    this.unregisterOnDestroy?.();
  }
};
function effect(effectFn, options) {
  performanceMarkFeature("NgSignals");
  ngDevMode && assertNotInReactiveContext(effect, "Call `effect` outside of a reactive context. For example, schedule the effect inside the component constructor.");
  !options?.injector && assertInInjectionContext(effect);
  const injector = options?.injector ?? inject(Injector);
  const destroyRef = options?.manualCleanup !== true ? injector.get(DestroyRef) : null;
  const handle = new EffectHandle(injector.get(APP_EFFECT_SCHEDULER), effectFn, typeof Zone === "undefined" ? null : Zone.current, destroyRef, injector, options?.allowSignalWrites ?? false);
  const cdr = injector.get(ChangeDetectorRef, null, {
    optional: true
  });
  if (!cdr || !(cdr._lView[FLAGS] & 8)) {
    handle.watcher.notify();
  } else {
    (cdr._lView[EFFECTS_TO_SCHEDULE] ??= []).push(handle.watcher.notify);
  }
  return handle;
}
function createComponent(component, options) {
  ngDevMode && assertComponentDef(component);
  const componentDef = getComponentDef(component);
  const elementInjector = options.elementInjector || getNullInjector();
  const factory = new ComponentFactory(componentDef);
  return factory.create(elementInjector, options.projectableNodes, options.hostElement, options.environmentInjector);
}
function reflectComponentType(component) {
  const componentDef = getComponentDef(component);
  if (!componentDef) return null;
  const factory = new ComponentFactory(componentDef);
  return {
    get selector() {
      return factory.selector;
    },
    get type() {
      return factory.componentType;
    },
    get inputs() {
      return factory.inputs;
    },
    get outputs() {
      return factory.outputs;
    },
    get ngContentSelectors() {
      return factory.ngContentSelectors;
    },
    get isStandalone() {
      return componentDef.standalone;
    },
    get isSignal() {
      return componentDef.signals;
    }
  };
}
function mergeApplicationConfig(...configs) {
  return configs.reduce((prev, curr) => {
    return Object.assign(prev, curr, {
      providers: [...prev.providers, ...curr.providers]
    });
  }, {
    providers: []
  });
}
if (typeof ngDevMode !== "undefined" && ngDevMode) {
  _global.$localize ??= function() {
    throw new Error("It looks like your application or one of its dependencies is using i18n.\nAngular 9 introduced a global `$localize()` function that needs to be loaded.\nPlease run `ng add @angular/localize` from the Angular CLI.\n(For non-CLI projects, add `import '@angular/localize/init';` to your `polyfills.ts` file.\nFor server-side rendering applications add the import to your `main.server.ts` file.)");
  };
}

export {
  XSS_SECURITY_URL,
  RuntimeError,
  formatRuntimeError,
  ɵINPUT_SIGNAL_BRAND_WRITE_TYPE,
  noSideEffects,
  _global,
  stringify,
  truncateMiddle,
  forwardRef,
  resolveForwardRef,
  ɵɵdefineInjectable,
  defineInjectable,
  ɵɵdefineInjector,
  getInjectableDef,
  isInjectable,
  NG_PROV_DEF,
  NG_INJ_DEF,
  InjectionToken,
  setInjectorProfilerContext,
  isEnvironmentProviders,
  NG_COMP_DEF,
  NG_DIR_DEF,
  NG_PIPE_DEF,
  NG_MOD_DEF,
  NG_ELEMENT_ID,
  InjectFlags,
  setCurrentInjector,
  ɵɵinject,
  ɵɵinvalidFactoryDep,
  inject,
  convertToBitFlags,
  Inject,
  Optional,
  Self,
  SkipSelf,
  Host,
  ENVIRONMENT_INITIALIZER,
  INJECTOR$1,
  ChangeDetectionStrategy,
  ViewEncapsulation$1,
  ɵɵdefineComponent,
  ɵɵdefineNgModule,
  ɵɵdefineDirective,
  ɵɵdefinePipe,
  isStandalone,
  makeEnvironmentProviders,
  importProvidersFrom,
  INJECTOR_SCOPE,
  EnvironmentInjector,
  runInInjectionContext,
  assertInInjectionContext,
  FactoryTarget,
  Type,
  ReflectionCapabilities,
  CONTAINER_HEADER_OFFSET,
  SimpleChange,
  ɵɵNgOnChangesFeature,
  ɵɵenableBindings,
  ɵɵdisableBindings,
  ɵɵrestoreView,
  ɵɵresetView,
  ɵɵnamespaceSVG,
  ɵɵnamespaceMathML,
  ɵɵnamespaceHTML,
  NOT_FOUND_CHECK_ONLY_ELEMENT_INJECTOR,
  ɵɵgetInheritedFactory,
  ɵɵinjectAttribute,
  Attribute2 as Attribute,
  Injectable,
  createInjector,
  Injector,
  HostAttributeToken,
  HOST_TAG_NAME,
  DestroyRef,
  PendingTasks,
  ExperimentalPendingTasks,
  EventEmitter,
  NgZone,
  NoopNgZone,
  ErrorHandler,
  INTERNAL_APPLICATION_ERROR_HANDLER,
  OutputEmitterRef,
  getOutputDestroyRef,
  output,
  input,
  ElementRef,
  QueryList,
  LContext,
  getLContext,
  getDirectives,
  getHostElement,
  setDocument,
  APP_ID,
  PLATFORM_INITIALIZER,
  PLATFORM_ID,
  PACKAGE_ROOT_URL,
  ANIMATION_MODULE_TYPE,
  CSP_NONCE,
  IMAGE_CONFIG_DEFAULTS,
  IMAGE_CONFIG,
  makeStateKey,
  TransferState,
  SSR_CONTENT_INTEGRITY_MARKER,
  readHydrationInfo,
  IS_HYDRATION_DOM_REUSE_ENABLED,
  unwrapSafeValue,
  allowSanitizationBypassAndThrow,
  getSanitizationBypassType,
  bypassSanitizationTrustHtml,
  bypassSanitizationTrustStyle,
  bypassSanitizationTrustScript,
  bypassSanitizationTrustUrl,
  bypassSanitizationTrustResourceUrl,
  _sanitizeUrl,
  _sanitizeHtml,
  SecurityContext,
  ɵɵsanitizeHtml,
  ɵɵsanitizeStyle,
  ɵɵsanitizeUrl,
  ɵɵsanitizeResourceUrl,
  ɵɵsanitizeScript,
  ɵɵtrustConstantHtml,
  ɵɵtrustConstantResourceUrl,
  ɵɵsanitizeUrlOrResourceUrl,
  CUSTOM_ELEMENTS_SCHEMA,
  NO_ERRORS_SCHEMA,
  ɵsetUnknownElementStrictMode,
  ɵgetUnknownElementStrictMode,
  ɵsetUnknownPropertyStrictMode,
  ɵgetUnknownPropertyStrictMode,
  ɵɵresolveWindow,
  ɵɵresolveDocument,
  ɵɵresolveBody,
  RendererStyleFlags2,
  NO_CHANGE,
  ɵɵadvance,
  ɵɵdirectiveInject,
  ɵɵinvalidFactory,
  ViewRef$1,
  TemplateRef,
  ChangeDetectionScheduler,
  ZONELESS_ENABLED,
  ComponentRef$1,
  ComponentFactory$1,
  ComponentFactoryResolver$1,
  RendererFactory2,
  Renderer2,
  Sanitizer,
  assertNotInReactiveContext,
  performanceMarkFeature,
  AfterRenderPhase,
  internalAfterNextRender,
  afterRender,
  afterNextRender,
  AfterRenderEventManager,
  isNgModule,
  USE_RUNTIME_DEPS_TRACKER_FOR_JIT,
  depsTracker,
  ComponentFactory,
  ComponentRef,
  LifecycleHooksFeature,
  ViewContainerRef,
  isSignal,
  ɵunwrapWritableSignal,
  signal,
  viewChild,
  viewChildren,
  contentChild,
  contentChildren,
  model,
  Query,
  ContentChildren,
  ContentChild,
  ViewChildren,
  ViewChild,
  resolveComponentResources,
  isComponentDefPendingResolution,
  clearResolutionOfComponentResourcesQueue,
  restoreComponentResolutionQueue,
  registerNgModuleType,
  setAllowDuplicateNgModuleIdsForTest,
  ɵɵvalidateIframeAttribute,
  ɵɵInheritDefinitionFeature,
  ɵɵCopyDefinitionFeature,
  ɵɵHostDirectivesFeature,
  ɵɵInputTransformsFeature,
  NgModuleRef$1,
  NgModuleFactory$1,
  createNgModule,
  createNgModuleRef,
  NgModuleRef,
  NgModuleFactory,
  createEnvironmentInjector,
  devModeEqual,
  ɵɵtemplate,
  DeferBlockState,
  DeferBlockBehavior,
  DEFER_BLOCK_DEPENDENCY_INTERCEPTOR,
  DEFER_BLOCK_CONFIG,
  ɵɵdeferEnableTimerScheduling,
  ɵɵdefer,
  ɵɵdeferWhen,
  ɵɵdeferPrefetchWhen,
  ɵɵdeferOnIdle,
  ɵɵdeferPrefetchOnIdle,
  ɵɵdeferOnImmediate,
  ɵɵdeferPrefetchOnImmediate,
  ɵɵdeferOnTimer,
  ɵɵdeferPrefetchOnTimer,
  ɵɵdeferOnHover,
  ɵɵdeferPrefetchOnHover,
  ɵɵdeferOnInteraction,
  ɵɵdeferPrefetchOnInteraction,
  ɵɵdeferOnViewport,
  ɵɵdeferPrefetchOnViewport,
  renderDeferBlockState,
  triggerResourceLoading,
  ɵɵattribute,
  ɵɵattributeInterpolate1,
  ɵɵattributeInterpolate2,
  ɵɵattributeInterpolate3,
  ɵɵattributeInterpolate4,
  ɵɵattributeInterpolate5,
  ɵɵattributeInterpolate6,
  ɵɵattributeInterpolate7,
  ɵɵattributeInterpolate8,
  ɵɵattributeInterpolateV,
  ɵɵproperty,
  ɵɵstyleProp,
  ɵɵclassProp,
  ɵɵstyleMap,
  ɵɵclassMap,
  ɵɵclassMapInterpolate1,
  ɵɵclassMapInterpolate2,
  ɵɵclassMapInterpolate3,
  ɵɵclassMapInterpolate4,
  ɵɵclassMapInterpolate5,
  ɵɵclassMapInterpolate6,
  ɵɵclassMapInterpolate7,
  ɵɵclassMapInterpolate8,
  ɵɵclassMapInterpolateV,
  ɵɵcomponentInstance,
  ɵɵconditional,
  ɵɵrepeaterTrackByIndex,
  ɵɵrepeaterTrackByIdentity,
  ɵɵrepeaterCreate,
  ɵɵrepeater,
  ɵɵelementStart,
  ɵɵelementEnd,
  ɵɵelement,
  ɵɵelementContainerStart,
  ɵɵelementContainerEnd,
  ɵɵelementContainer,
  ɵɵgetCurrentView,
  ɵɵhostProperty,
  ɵɵsyntheticHostProperty,
  registerLocaleData,
  findLocaleData,
  getLocaleCurrencyCode,
  getLocalePluralCase,
  unregisterAllLocaleData,
  LocaleDataIndex,
  DEFAULT_LOCALE_ID,
  setLocaleId,
  ɵɵi18nStart,
  ɵɵi18nEnd,
  ɵɵi18n,
  ɵɵi18nAttributes,
  ɵɵi18nExp,
  ɵɵi18nApply,
  ɵɵi18nPostprocess,
  ɵɵlistener,
  ɵɵsyntheticHostListener,
  ɵɵnextContext,
  ɵɵprojectionDef,
  ɵɵprojection,
  ɵɵpropertyInterpolate,
  ɵɵpropertyInterpolate1,
  ɵɵpropertyInterpolate2,
  ɵɵpropertyInterpolate3,
  ɵɵpropertyInterpolate4,
  ɵɵpropertyInterpolate5,
  ɵɵpropertyInterpolate6,
  ɵɵpropertyInterpolate7,
  ɵɵpropertyInterpolate8,
  ɵɵpropertyInterpolateV,
  ɵɵcontentQuery,
  ɵɵviewQuery,
  ɵɵqueryRefresh,
  ɵɵloadQuery,
  ɵɵcontentQuerySignal,
  ɵɵviewQuerySignal,
  ɵɵqueryAdvance,
  store,
  ɵɵreference,
  ɵɵstyleMapInterpolate1,
  ɵɵstyleMapInterpolate2,
  ɵɵstyleMapInterpolate3,
  ɵɵstyleMapInterpolate4,
  ɵɵstyleMapInterpolate5,
  ɵɵstyleMapInterpolate6,
  ɵɵstyleMapInterpolate7,
  ɵɵstyleMapInterpolate8,
  ɵɵstyleMapInterpolateV,
  ɵɵstylePropInterpolate1,
  ɵɵstylePropInterpolate2,
  ɵɵstylePropInterpolate3,
  ɵɵstylePropInterpolate4,
  ɵɵstylePropInterpolate5,
  ɵɵstylePropInterpolate6,
  ɵɵstylePropInterpolate7,
  ɵɵstylePropInterpolate8,
  ɵɵstylePropInterpolateV,
  ɵɵtext,
  ɵɵtextInterpolate,
  ɵɵtextInterpolate1,
  ɵɵtextInterpolate2,
  ɵɵtextInterpolate3,
  ɵɵtextInterpolate4,
  ɵɵtextInterpolate5,
  ɵɵtextInterpolate6,
  ɵɵtextInterpolate7,
  ɵɵtextInterpolate8,
  ɵɵtextInterpolateV,
  ɵɵtwoWayProperty,
  ɵɵtwoWayBindingSet,
  ɵɵtwoWayListener,
  ɵɵdeclareLet,
  ɵɵstoreLet,
  ɵɵreadContextLet,
  ɵɵProvidersFeature,
  ɵɵStandaloneFeature,
  ɵɵsetComponentScope,
  ɵɵsetNgModuleScope,
  getAsyncClassMetadataFn,
  setClassMetadataAsync,
  setClassMetadata,
  ɵɵpureFunction0,
  ɵɵpureFunction1,
  ɵɵpureFunction2,
  ɵɵpureFunction3,
  ɵɵpureFunction4,
  ɵɵpureFunction5,
  ɵɵpureFunction6,
  ɵɵpureFunction7,
  ɵɵpureFunction8,
  ɵɵpureFunctionV,
  ɵɵpipe,
  ɵɵpipeBind1,
  ɵɵpipeBind2,
  ɵɵpipeBind3,
  ɵɵpipeBind4,
  ɵɵpipeBindV,
  ɵɵtemplateRefExtractor,
  ɵɵgetComponentDepsFactory,
  ɵsetClassDebugInfo,
  resetJitOptions,
  flushModuleScopingQueueAsMuchAsPossible,
  compileNgModule,
  compileNgModuleDefs,
  generateStandaloneInDeclarationsError,
  resetCompiledComponents,
  patchComponentDefWithScope,
  transitiveScopesFor,
  compileComponent,
  compileDirective,
  compilePipe,
  Directive,
  Component,
  Pipe,
  Input,
  Output,
  HostBinding,
  HostListener,
  NgModule,
  Version,
  VERSION,
  Console,
  TESTABILITY,
  TESTABILITY_GETTER,
  Testability,
  TestabilityRegistry,
  setTestabilityGetter,
  isPromise,
  isSubscribable,
  APP_INITIALIZER,
  ApplicationInitStatus,
  APP_BOOTSTRAP_LISTENER,
  isBoundToModule,
  NgProbeToken,
  ApplicationRef,
  whenStable,
  detectChangesInViewIfRequired,
  ModuleWithComponentFactories,
  Compiler,
  COMPILER_OPTIONS,
  CompilerFactory,
  compileNgModuleFactory,
  PROVIDED_NG_ZONE,
  internalProvideZoneChangeDetection,
  provideZoneChangeDetection,
  ChangeDetectionSchedulerImpl,
  provideExperimentalZonelessChangeDetection,
  LOCALE_ID,
  DEFAULT_CURRENCY_CODE,
  TRANSLATIONS,
  TRANSLATIONS_FORMAT,
  MissingTranslationStrategy,
  PlatformRef,
  ALLOW_MULTIPLE_PLATFORMS,
  createPlatform,
  createPlatformFactory,
  assertPlatform,
  getPlatform,
  destroyPlatform,
  provideExperimentalCheckNoChangesForDebug,
  isDevMode,
  enableProdMode,
  getModuleFactory,
  getNgModuleById,
  ChangeDetectorRef,
  injectChangeDetectorRef,
  ViewRef,
  EmbeddedViewRef,
  DebugEventListener,
  asNativeElements,
  DebugNode,
  DebugElement,
  getDebugNode,
  DefaultIterableDiffer,
  IterableDiffers,
  KeyValueDiffers,
  defaultIterableDiffers,
  defaultKeyValueDiffers,
  platformCore,
  ApplicationModule,
  setAlternateWeakRefImpl,
  internalCreateApplication,
  getDeferBlocks,
  JSACTION_EVENT_CONTRACT,
  GLOBAL_EVENT_DELEGATION,
  withEventReplay,
  annotateForHydration,
  withDomHydration,
  withI18nSupport,
  provideGlobalEventDelegation,
  queueStateUpdate,
  booleanAttribute,
  numberAttribute,
  ɵɵngDeclareDirective,
  ɵɵngDeclareClassMetadata,
  ɵɵngDeclareClassMetadataAsync,
  ɵɵngDeclareComponent,
  ɵɵngDeclareFactory,
  ɵɵngDeclareInjectable,
  ɵɵngDeclareInjector,
  ɵɵngDeclareNgModule,
  ɵɵngDeclarePipe,
  computed,
  untracked,
  EffectScheduler,
  effect,
  createComponent,
  reflectComponentType,
  mergeApplicationConfig
};
/*! Bundled license information:

@angular/core/fesm2022/core.mjs:
  (**
   * @license Angular v18.2.0
   * (c) 2010-2024 Google LLC. https://angular.io/
   * License: MIT
   *)

@angular/core/fesm2022/core.mjs:
  (*!
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   *)

@angular/core/fesm2022/core.mjs:
  (*!
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   *)

@angular/core/fesm2022/core.mjs:
  (*!
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   *)
*/
//# sourceMappingURL=chunk-2VVDJA4L.js.map



================================================
FILE: .angular/cache/18.2.20/angular-pivothead-example/vite/deps/chunk-5NODSH2C.js
================================================
import {
  __spreadProps,
  __spreadValues
} from "./chunk-WDMUDEB6.js";

// node_modules/@angular/core/fesm2022/primitives/signals.mjs
function defaultEquals(a, b) {
  return Object.is(a, b);
}
var activeConsumer = null;
var inNotificationPhase = false;
var epoch = 1;
var SIGNAL = Symbol("SIGNAL");
function setActiveConsumer(consumer) {
  const prev = activeConsumer;
  activeConsumer = consumer;
  return prev;
}
function getActiveConsumer() {
  return activeConsumer;
}
function isInNotificationPhase() {
  return inNotificationPhase;
}
function isReactive(value) {
  return value[SIGNAL] !== void 0;
}
var REACTIVE_NODE = {
  version: 0,
  lastCleanEpoch: 0,
  dirty: false,
  producerNode: void 0,
  producerLastReadVersion: void 0,
  producerIndexOfThis: void 0,
  nextProducerIndex: 0,
  liveConsumerNode: void 0,
  liveConsumerIndexOfThis: void 0,
  consumerAllowSignalWrites: false,
  consumerIsAlwaysLive: false,
  producerMustRecompute: () => false,
  producerRecomputeValue: () => {
  },
  consumerMarkedDirty: () => {
  },
  consumerOnSignalRead: () => {
  }
};
function producerAccessed(node) {
  if (inNotificationPhase) {
    throw new Error(typeof ngDevMode !== "undefined" && ngDevMode ? `Assertion error: signal read during notification phase` : "");
  }
  if (activeConsumer === null) {
    return;
  }
  activeConsumer.consumerOnSignalRead(node);
  const idx = activeConsumer.nextProducerIndex++;
  assertConsumerNode(activeConsumer);
  if (idx < activeConsumer.producerNode.length && activeConsumer.producerNode[idx] !== node) {
    if (consumerIsLive(activeConsumer)) {
      const staleProducer = activeConsumer.producerNode[idx];
      producerRemoveLiveConsumerAtIndex(staleProducer, activeConsumer.producerIndexOfThis[idx]);
    }
  }
  if (activeConsumer.producerNode[idx] !== node) {
    activeConsumer.producerNode[idx] = node;
    activeConsumer.producerIndexOfThis[idx] = consumerIsLive(activeConsumer) ? producerAddLiveConsumer(node, activeConsumer, idx) : 0;
  }
  activeConsumer.producerLastReadVersion[idx] = node.version;
}
function producerIncrementEpoch() {
  epoch++;
}
function producerUpdateValueVersion(node) {
  if (consumerIsLive(node) && !node.dirty) {
    return;
  }
  if (!node.dirty && node.lastCleanEpoch === epoch) {
    return;
  }
  if (!node.producerMustRecompute(node) && !consumerPollProducersForChange(node)) {
    node.dirty = false;
    node.lastCleanEpoch = epoch;
    return;
  }
  node.producerRecomputeValue(node);
  node.dirty = false;
  node.lastCleanEpoch = epoch;
}
function producerNotifyConsumers(node) {
  if (node.liveConsumerNode === void 0) {
    return;
  }
  const prev = inNotificationPhase;
  inNotificationPhase = true;
  try {
    for (const consumer of node.liveConsumerNode) {
      if (!consumer.dirty) {
        consumerMarkDirty(consumer);
      }
    }
  } finally {
    inNotificationPhase = prev;
  }
}
function producerUpdatesAllowed() {
  return activeConsumer?.consumerAllowSignalWrites !== false;
}
function consumerMarkDirty(node) {
  node.dirty = true;
  producerNotifyConsumers(node);
  node.consumerMarkedDirty?.(node);
}
function consumerBeforeComputation(node) {
  node && (node.nextProducerIndex = 0);
  return setActiveConsumer(node);
}
function consumerAfterComputation(node, prevConsumer) {
  setActiveConsumer(prevConsumer);
  if (!node || node.producerNode === void 0 || node.producerIndexOfThis === void 0 || node.producerLastReadVersion === void 0) {
    return;
  }
  if (consumerIsLive(node)) {
    for (let i = node.nextProducerIndex; i < node.producerNode.length; i++) {
      producerRemoveLiveConsumerAtIndex(node.producerNode[i], node.producerIndexOfThis[i]);
    }
  }
  while (node.producerNode.length > node.nextProducerIndex) {
    node.producerNode.pop();
    node.producerLastReadVersion.pop();
    node.producerIndexOfThis.pop();
  }
}
function consumerPollProducersForChange(node) {
  assertConsumerNode(node);
  for (let i = 0; i < node.producerNode.length; i++) {
    const producer = node.producerNode[i];
    const seenVersion = node.producerLastReadVersion[i];
    if (seenVersion !== producer.version) {
      return true;
    }
    producerUpdateValueVersion(producer);
    if (seenVersion !== producer.version) {
      return true;
    }
  }
  return false;
}
function consumerDestroy(node) {
  assertConsumerNode(node);
  if (consumerIsLive(node)) {
    for (let i = 0; i < node.producerNode.length; i++) {
      producerRemoveLiveConsumerAtIndex(node.producerNode[i], node.producerIndexOfThis[i]);
    }
  }
  node.producerNode.length = node.producerLastReadVersion.length = node.producerIndexOfThis.length = 0;
  if (node.liveConsumerNode) {
    node.liveConsumerNode.length = node.liveConsumerIndexOfThis.length = 0;
  }
}
function producerAddLiveConsumer(node, consumer, indexOfThis) {
  assertProducerNode(node);
  if (node.liveConsumerNode.length === 0 && isConsumerNode(node)) {
    for (let i = 0; i < node.producerNode.length; i++) {
      node.producerIndexOfThis[i] = producerAddLiveConsumer(node.producerNode[i], node, i);
    }
  }
  node.liveConsumerIndexOfThis.push(indexOfThis);
  return node.liveConsumerNode.push(consumer) - 1;
}
function producerRemoveLiveConsumerAtIndex(node, idx) {
  assertProducerNode(node);
  if (typeof ngDevMode !== "undefined" && ngDevMode && idx >= node.liveConsumerNode.length) {
    throw new Error(`Assertion error: active consumer index ${idx} is out of bounds of ${node.liveConsumerNode.length} consumers)`);
  }
  if (node.liveConsumerNode.length === 1 && isConsumerNode(node)) {
    for (let i = 0; i < node.producerNode.length; i++) {
      producerRemoveLiveConsumerAtIndex(node.producerNode[i], node.producerIndexOfThis[i]);
    }
  }
  const lastIdx = node.liveConsumerNode.length - 1;
  node.liveConsumerNode[idx] = node.liveConsumerNode[lastIdx];
  node.liveConsumerIndexOfThis[idx] = node.liveConsumerIndexOfThis[lastIdx];
  node.liveConsumerNode.length--;
  node.liveConsumerIndexOfThis.length--;
  if (idx < node.liveConsumerNode.length) {
    const idxProducer = node.liveConsumerIndexOfThis[idx];
    const consumer = node.liveConsumerNode[idx];
    assertConsumerNode(consumer);
    consumer.producerIndexOfThis[idxProducer] = idx;
  }
}
function consumerIsLive(node) {
  return node.consumerIsAlwaysLive || (node?.liveConsumerNode?.length ?? 0) > 0;
}
function assertConsumerNode(node) {
  node.producerNode ??= [];
  node.producerIndexOfThis ??= [];
  node.producerLastReadVersion ??= [];
}
function assertProducerNode(node) {
  node.liveConsumerNode ??= [];
  node.liveConsumerIndexOfThis ??= [];
}
function isConsumerNode(node) {
  return node.producerNode !== void 0;
}
function createComputed(computation) {
  const node = Object.create(COMPUTED_NODE);
  node.computation = computation;
  const computed = () => {
    producerUpdateValueVersion(node);
    producerAccessed(node);
    if (node.value === ERRORED) {
      throw node.error;
    }
    return node.value;
  };
  computed[SIGNAL] = node;
  return computed;
}
var UNSET = Symbol("UNSET");
var COMPUTING = Symbol("COMPUTING");
var ERRORED = Symbol("ERRORED");
var COMPUTED_NODE = (() => {
  return __spreadProps(__spreadValues({}, REACTIVE_NODE), {
    value: UNSET,
    dirty: true,
    error: null,
    equal: defaultEquals,
    producerMustRecompute(node) {
      return node.value === UNSET || node.value === COMPUTING;
    },
    producerRecomputeValue(node) {
      if (node.value === COMPUTING) {
        throw new Error("Detected cycle in computations.");
      }
      const oldValue = node.value;
      node.value = COMPUTING;
      const prevConsumer = consumerBeforeComputation(node);
      let newValue;
      try {
        newValue = node.computation();
      } catch (err) {
        newValue = ERRORED;
        node.error = err;
      } finally {
        consumerAfterComputation(node, prevConsumer);
      }
      if (oldValue !== UNSET && oldValue !== ERRORED && newValue !== ERRORED && node.equal(oldValue, newValue)) {
        node.value = oldValue;
        return;
      }
      node.value = newValue;
      node.version++;
    }
  });
})();
function defaultThrowError() {
  throw new Error();
}
var throwInvalidWriteToSignalErrorFn = defaultThrowError;
function throwInvalidWriteToSignalError() {
  throwInvalidWriteToSignalErrorFn();
}
function setThrowInvalidWriteToSignalError(fn) {
  throwInvalidWriteToSignalErrorFn = fn;
}
var postSignalSetFn = null;
function createSignal(initialValue) {
  const node = Object.create(SIGNAL_NODE);
  node.value = initialValue;
  const getter = () => {
    producerAccessed(node);
    return node.value;
  };
  getter[SIGNAL] = node;
  return getter;
}
function setPostSignalSetFn(fn) {
  const prev = postSignalSetFn;
  postSignalSetFn = fn;
  return prev;
}
function signalSetFn(node, newValue) {
  if (!producerUpdatesAllowed()) {
    throwInvalidWriteToSignalError();
  }
  if (!node.equal(node.value, newValue)) {
    node.value = newValue;
    signalValueChanged(node);
  }
}
function signalUpdateFn(node, updater) {
  if (!producerUpdatesAllowed()) {
    throwInvalidWriteToSignalError();
  }
  signalSetFn(node, updater(node.value));
}
function runPostSignalSetFn() {
  postSignalSetFn?.();
}
var SIGNAL_NODE = (() => {
  return __spreadProps(__spreadValues({}, REACTIVE_NODE), {
    equal: defaultEquals,
    value: void 0
  });
})();
function signalValueChanged(node) {
  node.version++;
  producerIncrementEpoch();
  producerNotifyConsumers(node);
  postSignalSetFn?.();
}
function createWatch(fn, schedule, allowSignalWrites) {
  const node = Object.create(WATCH_NODE);
  if (allowSignalWrites) {
    node.consumerAllowSignalWrites = true;
  }
  node.fn = fn;
  node.schedule = schedule;
  const registerOnCleanup = (cleanupFn) => {
    node.cleanupFn = cleanupFn;
  };
  function isWatchNodeDestroyed(node2) {
    return node2.fn === null && node2.schedule === null;
  }
  function destroyWatchNode(node2) {
    if (!isWatchNodeDestroyed(node2)) {
      consumerDestroy(node2);
      node2.cleanupFn();
      node2.fn = null;
      node2.schedule = null;
      node2.cleanupFn = NOOP_CLEANUP_FN;
    }
  }
  const run = () => {
    if (node.fn === null) {
      return;
    }
    if (isInNotificationPhase()) {
      throw new Error(`Schedulers cannot synchronously execute watches while scheduling.`);
    }
    node.dirty = false;
    if (node.hasRun && !consumerPollProducersForChange(node)) {
      return;
    }
    node.hasRun = true;
    const prevConsumer = consumerBeforeComputation(node);
    try {
      node.cleanupFn();
      node.cleanupFn = NOOP_CLEANUP_FN;
      node.fn(registerOnCleanup);
    } finally {
      consumerAfterComputation(node, prevConsumer);
    }
  };
  node.ref = {
    notify: () => consumerMarkDirty(node),
    run,
    cleanup: () => node.cleanupFn(),
    destroy: () => destroyWatchNode(node),
    [SIGNAL]: node
  };
  return node.ref;
}
var NOOP_CLEANUP_FN = () => {
};
var WATCH_NODE = (() => {
  return __spreadProps(__spreadValues({}, REACTIVE_NODE), {
    consumerIsAlwaysLive: true,
    consumerAllowSignalWrites: false,
    consumerMarkedDirty: (node) => {
      if (node.schedule !== null) {
        node.schedule(node.ref);
      }
    },
    hasRun: false,
    cleanupFn: NOOP_CLEANUP_FN
  });
})();
function setAlternateWeakRefImpl(impl) {
}

export {
  defaultEquals,
  SIGNAL,
  setActiveConsumer,
  getActiveConsumer,
  isInNotificationPhase,
  isReactive,
  REACTIVE_NODE,
  producerAccessed,
  producerIncrementEpoch,
  producerUpdateValueVersion,
  producerNotifyConsumers,
  producerUpdatesAllowed,
  consumerMarkDirty,
  consumerBeforeComputation,
  consumerAfterComputation,
  consumerPollProducersForChange,
  consumerDestroy,
  createComputed,
  setThrowInvalidWriteToSignalError,
  createSignal,
  setPostSignalSetFn,
  signalSetFn,
  signalUpdateFn,
  runPostSignalSetFn,
  SIGNAL_NODE,
  createWatch,
  setAlternateWeakRefImpl
};
/*! Bundled license information:

@angular/core/fesm2022/primitives/signals.mjs:
  (**
   * @license Angular v18.2.0
   * (c) 2010-2024 Google LLC. https://angular.io/
   * License: MIT
   *)
*/
//# sourceMappingURL=chunk-5NODSH2C.js.map



================================================
FILE: .angular/cache/18.2.20/angular-pivothead-example/vite/deps/chunk-HB2ZDJCU.js
================================================
import {
  ApplicationRef,
  Attribute,
  ChangeDetectorRef,
  DEFAULT_CURRENCY_CODE,
  Directive,
  ElementRef,
  EventEmitter,
  Host,
  IMAGE_CONFIG,
  IMAGE_CONFIG_DEFAULTS,
  Inject,
  Injectable,
  InjectionToken,
  Injector,
  Input,
  IterableDiffers,
  KeyValueDiffers,
  LOCALE_ID,
  LocaleDataIndex,
  NgModule,
  NgModuleRef$1,
  NgZone,
  Optional,
  PLATFORM_ID,
  Pipe,
  Renderer2,
  RendererStyleFlags2,
  RuntimeError,
  TemplateRef,
  Version,
  ViewContainerRef,
  booleanAttribute,
  createNgModule,
  findLocaleData,
  formatRuntimeError,
  getLocaleCurrencyCode,
  getLocalePluralCase,
  inject,
  isPromise,
  isSubscribable,
  numberAttribute,
  performanceMarkFeature,
  registerLocaleData,
  setClassMetadata,
  stringify,
  untracked,
  unwrapSafeValue,
  whenStable,
  ɵɵInputTransformsFeature,
  ɵɵNgOnChangesFeature,
  ɵɵdefineDirective,
  ɵɵdefineInjectable,
  ɵɵdefineInjector,
  ɵɵdefineNgModule,
  ɵɵdefinePipe,
  ɵɵdirectiveInject,
  ɵɵinject,
  ɵɵinjectAttribute,
  ɵɵstyleProp
} from "./chunk-2VVDJA4L.js";
import {
  __async,
  __spreadProps,
  __spreadValues
} from "./chunk-WDMUDEB6.js";

// node_modules/@angular/common/fesm2022/common.mjs
var _DOM = null;
function getDOM() {
  return _DOM;
}
function setRootDomAdapter(adapter) {
  _DOM ??= adapter;
}
var DomAdapter = class {
};
var PlatformNavigation = class _PlatformNavigation {
  static {
    this.ɵfac = function PlatformNavigation_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _PlatformNavigation)();
    };
  }
  static {
    this.ɵprov = ɵɵdefineInjectable({
      token: _PlatformNavigation,
      factory: () => (() => window.navigation)(),
      providedIn: "platform"
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PlatformNavigation, [{
    type: Injectable,
    args: [{
      providedIn: "platform",
      useFactory: () => window.navigation
    }]
  }], null, null);
})();
var DOCUMENT = new InjectionToken(ngDevMode ? "DocumentToken" : "");
var PlatformLocation = class _PlatformLocation {
  historyGo(relativePosition) {
    throw new Error(ngDevMode ? "Not implemented" : "");
  }
  static {
    this.ɵfac = function PlatformLocation_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _PlatformLocation)();
    };
  }
  static {
    this.ɵprov = ɵɵdefineInjectable({
      token: _PlatformLocation,
      factory: () => (() => inject(BrowserPlatformLocation))(),
      providedIn: "platform"
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PlatformLocation, [{
    type: Injectable,
    args: [{
      providedIn: "platform",
      useFactory: () => inject(BrowserPlatformLocation)
    }]
  }], null, null);
})();
var LOCATION_INITIALIZED = new InjectionToken(ngDevMode ? "Location Initialized" : "");
var BrowserPlatformLocation = class _BrowserPlatformLocation extends PlatformLocation {
  constructor() {
    super();
    this._doc = inject(DOCUMENT);
    this._location = window.location;
    this._history = window.history;
  }
  getBaseHrefFromDOM() {
    return getDOM().getBaseHref(this._doc);
  }
  onPopState(fn) {
    const window2 = getDOM().getGlobalEventTarget(this._doc, "window");
    window2.addEventListener("popstate", fn, false);
    return () => window2.removeEventListener("popstate", fn);
  }
  onHashChange(fn) {
    const window2 = getDOM().getGlobalEventTarget(this._doc, "window");
    window2.addEventListener("hashchange", fn, false);
    return () => window2.removeEventListener("hashchange", fn);
  }
  get href() {
    return this._location.href;
  }
  get protocol() {
    return this._location.protocol;
  }
  get hostname() {
    return this._location.hostname;
  }
  get port() {
    return this._location.port;
  }
  get pathname() {
    return this._location.pathname;
  }
  get search() {
    return this._location.search;
  }
  get hash() {
    return this._location.hash;
  }
  set pathname(newPath) {
    this._location.pathname = newPath;
  }
  pushState(state, title, url) {
    this._history.pushState(state, title, url);
  }
  replaceState(state, title, url) {
    this._history.replaceState(state, title, url);
  }
  forward() {
    this._history.forward();
  }
  back() {
    this._history.back();
  }
  historyGo(relativePosition = 0) {
    this._history.go(relativePosition);
  }
  getState() {
    return this._history.state;
  }
  static {
    this.ɵfac = function BrowserPlatformLocation_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _BrowserPlatformLocation)();
    };
  }
  static {
    this.ɵprov = ɵɵdefineInjectable({
      token: _BrowserPlatformLocation,
      factory: () => (() => new _BrowserPlatformLocation())(),
      providedIn: "platform"
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(BrowserPlatformLocation, [{
    type: Injectable,
    args: [{
      providedIn: "platform",
      useFactory: () => new BrowserPlatformLocation()
    }]
  }], () => [], null);
})();
function joinWithSlash(start, end) {
  if (start.length == 0) {
    return end;
  }
  if (end.length == 0) {
    return start;
  }
  let slashes = 0;
  if (start.endsWith("/")) {
    slashes++;
  }
  if (end.startsWith("/")) {
    slashes++;
  }
  if (slashes == 2) {
    return start + end.substring(1);
  }
  if (slashes == 1) {
    return start + end;
  }
  return start + "/" + end;
}
function stripTrailingSlash(url) {
  const match = url.match(/#|\?|$/);
  const pathEndIdx = match && match.index || url.length;
  const droppedSlashIdx = pathEndIdx - (url[pathEndIdx - 1] === "/" ? 1 : 0);
  return url.slice(0, droppedSlashIdx) + url.slice(pathEndIdx);
}
function normalizeQueryParams(params) {
  return params && params[0] !== "?" ? "?" + params : params;
}
var LocationStrategy = class _LocationStrategy {
  historyGo(relativePosition) {
    throw new Error(ngDevMode ? "Not implemented" : "");
  }
  static {
    this.ɵfac = function LocationStrategy_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _LocationStrategy)();
    };
  }
  static {
    this.ɵprov = ɵɵdefineInjectable({
      token: _LocationStrategy,
      factory: () => (() => inject(PathLocationStrategy))(),
      providedIn: "root"
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(LocationStrategy, [{
    type: Injectable,
    args: [{
      providedIn: "root",
      useFactory: () => inject(PathLocationStrategy)
    }]
  }], null, null);
})();
var APP_BASE_HREF = new InjectionToken(ngDevMode ? "appBaseHref" : "");
var PathLocationStrategy = class _PathLocationStrategy extends LocationStrategy {
  constructor(_platformLocation, href) {
    super();
    this._platformLocation = _platformLocation;
    this._removeListenerFns = [];
    this._baseHref = href ?? this._platformLocation.getBaseHrefFromDOM() ?? inject(DOCUMENT).location?.origin ?? "";
  }
  /** @nodoc */
  ngOnDestroy() {
    while (this._removeListenerFns.length) {
      this._removeListenerFns.pop()();
    }
  }
  onPopState(fn) {
    this._removeListenerFns.push(this._platformLocation.onPopState(fn), this._platformLocation.onHashChange(fn));
  }
  getBaseHref() {
    return this._baseHref;
  }
  prepareExternalUrl(internal) {
    return joinWithSlash(this._baseHref, internal);
  }
  path(includeHash = false) {
    const pathname = this._platformLocation.pathname + normalizeQueryParams(this._platformLocation.search);
    const hash = this._platformLocation.hash;
    return hash && includeHash ? `${pathname}${hash}` : pathname;
  }
  pushState(state, title, url, queryParams) {
    const externalUrl = this.prepareExternalUrl(url + normalizeQueryParams(queryParams));
    this._platformLocation.pushState(state, title, externalUrl);
  }
  replaceState(state, title, url, queryParams) {
    const externalUrl = this.prepareExternalUrl(url + normalizeQueryParams(queryParams));
    this._platformLocation.replaceState(state, title, externalUrl);
  }
  forward() {
    this._platformLocation.forward();
  }
  back() {
    this._platformLocation.back();
  }
  getState() {
    return this._platformLocation.getState();
  }
  historyGo(relativePosition = 0) {
    this._platformLocation.historyGo?.(relativePosition);
  }
  static {
    this.ɵfac = function PathLocationStrategy_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _PathLocationStrategy)(ɵɵinject(PlatformLocation), ɵɵinject(APP_BASE_HREF, 8));
    };
  }
  static {
    this.ɵprov = ɵɵdefineInjectable({
      token: _PathLocationStrategy,
      factory: _PathLocationStrategy.ɵfac,
      providedIn: "root"
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PathLocationStrategy, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], () => [{
    type: PlatformLocation
  }, {
    type: void 0,
    decorators: [{
      type: Optional
    }, {
      type: Inject,
      args: [APP_BASE_HREF]
    }]
  }], null);
})();
var HashLocationStrategy = class _HashLocationStrategy extends LocationStrategy {
  constructor(_platformLocation, _baseHref) {
    super();
    this._platformLocation = _platformLocation;
    this._baseHref = "";
    this._removeListenerFns = [];
    if (_baseHref != null) {
      this._baseHref = _baseHref;
    }
  }
  /** @nodoc */
  ngOnDestroy() {
    while (this._removeListenerFns.length) {
      this._removeListenerFns.pop()();
    }
  }
  onPopState(fn) {
    this._removeListenerFns.push(this._platformLocation.onPopState(fn), this._platformLocation.onHashChange(fn));
  }
  getBaseHref() {
    return this._baseHref;
  }
  path(includeHash = false) {
    const path = this._platformLocation.hash ?? "#";
    return path.length > 0 ? path.substring(1) : path;
  }
  prepareExternalUrl(internal) {
    const url = joinWithSlash(this._baseHref, internal);
    return url.length > 0 ? "#" + url : url;
  }
  pushState(state, title, path, queryParams) {
    let url = this.prepareExternalUrl(path + normalizeQueryParams(queryParams));
    if (url.length == 0) {
      url = this._platformLocation.pathname;
    }
    this._platformLocation.pushState(state, title, url);
  }
  replaceState(state, title, path, queryParams) {
    let url = this.prepareExternalUrl(path + normalizeQueryParams(queryParams));
    if (url.length == 0) {
      url = this._platformLocation.pathname;
    }
    this._platformLocation.replaceState(state, title, url);
  }
  forward() {
    this._platformLocation.forward();
  }
  back() {
    this._platformLocation.back();
  }
  getState() {
    return this._platformLocation.getState();
  }
  historyGo(relativePosition = 0) {
    this._platformLocation.historyGo?.(relativePosition);
  }
  static {
    this.ɵfac = function HashLocationStrategy_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _HashLocationStrategy)(ɵɵinject(PlatformLocation), ɵɵinject(APP_BASE_HREF, 8));
    };
  }
  static {
    this.ɵprov = ɵɵdefineInjectable({
      token: _HashLocationStrategy,
      factory: _HashLocationStrategy.ɵfac
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(HashLocationStrategy, [{
    type: Injectable
  }], () => [{
    type: PlatformLocation
  }, {
    type: void 0,
    decorators: [{
      type: Optional
    }, {
      type: Inject,
      args: [APP_BASE_HREF]
    }]
  }], null);
})();
var Location = class _Location {
  constructor(locationStrategy) {
    this._subject = new EventEmitter();
    this._urlChangeListeners = [];
    this._urlChangeSubscription = null;
    this._locationStrategy = locationStrategy;
    const baseHref = this._locationStrategy.getBaseHref();
    this._basePath = _stripOrigin(stripTrailingSlash(_stripIndexHtml(baseHref)));
    this._locationStrategy.onPopState((ev) => {
      this._subject.emit({
        "url": this.path(true),
        "pop": true,
        "state": ev.state,
        "type": ev.type
      });
    });
  }
  /** @nodoc */
  ngOnDestroy() {
    this._urlChangeSubscription?.unsubscribe();
    this._urlChangeListeners = [];
  }
  /**
   * Normalizes the URL path for this location.
   *
   * @param includeHash True to include an anchor fragment in the path.
   *
   * @returns The normalized URL path.
   */
  // TODO: vsavkin. Remove the boolean flag and always include hash once the deprecated router is
  // removed.
  path(includeHash = false) {
    return this.normalize(this._locationStrategy.path(includeHash));
  }
  /**
   * Reports the current state of the location history.
   * @returns The current value of the `history.state` object.
   */
  getState() {
    return this._locationStrategy.getState();
  }
  /**
   * Normalizes the given path and compares to the current normalized path.
   *
   * @param path The given URL path.
   * @param query Query parameters.
   *
   * @returns True if the given URL path is equal to the current normalized path, false
   * otherwise.
   */
  isCurrentPathEqualTo(path, query = "") {
    return this.path() == this.normalize(path + normalizeQueryParams(query));
  }
  /**
   * Normalizes a URL path by stripping any trailing slashes.
   *
   * @param url String representing a URL.
   *
   * @returns The normalized URL string.
   */
  normalize(url) {
    return _Location.stripTrailingSlash(_stripBasePath(this._basePath, _stripIndexHtml(url)));
  }
  /**
   * Normalizes an external URL path.
   * If the given URL doesn't begin with a leading slash (`'/'`), adds one
   * before normalizing. Adds a hash if `HashLocationStrategy` is
   * in use, or the `APP_BASE_HREF` if the `PathLocationStrategy` is in use.
   *
   * @param url String representing a URL.
   *
   * @returns  A normalized platform-specific URL.
   */
  prepareExternalUrl(url) {
    if (url && url[0] !== "/") {
      url = "/" + url;
    }
    return this._locationStrategy.prepareExternalUrl(url);
  }
  // TODO: rename this method to pushState
  /**
   * Changes the browser's URL to a normalized version of a given URL, and pushes a
   * new item onto the platform's history.
   *
   * @param path  URL path to normalize.
   * @param query Query parameters.
   * @param state Location history state.
   *
   */
  go(path, query = "", state = null) {
    this._locationStrategy.pushState(state, "", path, query);
    this._notifyUrlChangeListeners(this.prepareExternalUrl(path + normalizeQueryParams(query)), state);
  }
  /**
   * Changes the browser's URL to a normalized version of the given URL, and replaces
   * the top item on the platform's history stack.
   *
   * @param path  URL path to normalize.
   * @param query Query parameters.
   * @param state Location history state.
   */
  replaceState(path, query = "", state = null) {
    this._locationStrategy.replaceState(state, "", path, query);
    this._notifyUrlChangeListeners(this.prepareExternalUrl(path + normalizeQueryParams(query)), state);
  }
  /**
   * Navigates forward in the platform's history.
   */
  forward() {
    this._locationStrategy.forward();
  }
  /**
   * Navigates back in the platform's history.
   */
  back() {
    this._locationStrategy.back();
  }
  /**
   * Navigate to a specific page from session history, identified by its relative position to the
   * current page.
   *
   * @param relativePosition  Position of the target page in the history relative to the current
   *     page.
   * A negative value moves backwards, a positive value moves forwards, e.g. `location.historyGo(2)`
   * moves forward two pages and `location.historyGo(-2)` moves back two pages. When we try to go
   * beyond what's stored in the history session, we stay in the current page. Same behaviour occurs
   * when `relativePosition` equals 0.
   * @see https://developer.mozilla.org/en-US/docs/Web/API/History_API#Moving_to_a_specific_point_in_history
   */
  historyGo(relativePosition = 0) {
    this._locationStrategy.historyGo?.(relativePosition);
  }
  /**
   * Registers a URL change listener. Use to catch updates performed by the Angular
   * framework that are not detectible through "popstate" or "hashchange" events.
   *
   * @param fn The change handler function, which take a URL and a location history state.
   * @returns A function that, when executed, unregisters a URL change listener.
   */
  onUrlChange(fn) {
    this._urlChangeListeners.push(fn);
    this._urlChangeSubscription ??= this.subscribe((v) => {
      this._notifyUrlChangeListeners(v.url, v.state);
    });
    return () => {
      const fnIndex = this._urlChangeListeners.indexOf(fn);
      this._urlChangeListeners.splice(fnIndex, 1);
      if (this._urlChangeListeners.length === 0) {
        this._urlChangeSubscription?.unsubscribe();
        this._urlChangeSubscription = null;
      }
    };
  }
  /** @internal */
  _notifyUrlChangeListeners(url = "", state) {
    this._urlChangeListeners.forEach((fn) => fn(url, state));
  }
  /**
   * Subscribes to the platform's `popState` events.
   *
   * Note: `Location.go()` does not trigger the `popState` event in the browser. Use
   * `Location.onUrlChange()` to subscribe to URL changes instead.
   *
   * @param value Event that is triggered when the state history changes.
   * @param exception The exception to throw.
   *
   * @see [onpopstate](https://developer.mozilla.org/en-US/docs/Web/API/WindowEventHandlers/onpopstate)
   *
   * @returns Subscribed events.
   */
  subscribe(onNext, onThrow, onReturn) {
    return this._subject.subscribe({
      next: onNext,
      error: onThrow,
      complete: onReturn
    });
  }
  static {
    this.normalizeQueryParams = normalizeQueryParams;
  }
  static {
    this.joinWithSlash = joinWithSlash;
  }
  static {
    this.stripTrailingSlash = stripTrailingSlash;
  }
  static {
    this.ɵfac = function Location_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _Location)(ɵɵinject(LocationStrategy));
    };
  }
  static {
    this.ɵprov = ɵɵdefineInjectable({
      token: _Location,
      factory: () => createLocation(),
      providedIn: "root"
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(Location, [{
    type: Injectable,
    args: [{
      providedIn: "root",
      // See #23917
      useFactory: createLocation
    }]
  }], () => [{
    type: LocationStrategy
  }], null);
})();
function createLocation() {
  return new Location(ɵɵinject(LocationStrategy));
}
function _stripBasePath(basePath, url) {
  if (!basePath || !url.startsWith(basePath)) {
    return url;
  }
  const strippedUrl = url.substring(basePath.length);
  if (strippedUrl === "" || ["/", ";", "?", "#"].includes(strippedUrl[0])) {
    return strippedUrl;
  }
  return url;
}
function _stripIndexHtml(url) {
  return url.replace(/\/index.html$/, "");
}
function _stripOrigin(baseHref) {
  const isAbsoluteUrl2 = new RegExp("^(https?:)?//").test(baseHref);
  if (isAbsoluteUrl2) {
    const [, pathname] = baseHref.split(/\/\/[^\/]+/);
    return pathname;
  }
  return baseHref;
}
var CURRENCIES_EN = {
  "ADP": [void 0, void 0, 0],
  "AFN": [void 0, "؋", 0],
  "ALL": [void 0, void 0, 0],
  "AMD": [void 0, "֏", 2],
  "AOA": [void 0, "Kz"],
  "ARS": [void 0, "$"],
  "AUD": ["A$", "$"],
  "AZN": [void 0, "₼"],
  "BAM": [void 0, "KM"],
  "BBD": [void 0, "$"],
  "BDT": [void 0, "৳"],
  "BHD": [void 0, void 0, 3],
  "BIF": [void 0, void 0, 0],
  "BMD": [void 0, "$"],
  "BND": [void 0, "$"],
  "BOB": [void 0, "Bs"],
  "BRL": ["R$"],
  "BSD": [void 0, "$"],
  "BWP": [void 0, "P"],
  "BYN": [void 0, void 0, 2],
  "BYR": [void 0, void 0, 0],
  "BZD": [void 0, "$"],
  "CAD": ["CA$", "$", 2],
  "CHF": [void 0, void 0, 2],
  "CLF": [void 0, void 0, 4],
  "CLP": [void 0, "$", 0],
  "CNY": ["CN¥", "¥"],
  "COP": [void 0, "$", 2],
  "CRC": [void 0, "₡", 2],
  "CUC": [void 0, "$"],
  "CUP": [void 0, "$"],
  "CZK": [void 0, "Kč", 2],
  "DJF": [void 0, void 0, 0],
  "DKK": [void 0, "kr", 2],
  "DOP": [void 0, "$"],
  "EGP": [void 0, "E£"],
  "ESP": [void 0, "₧", 0],
  "EUR": ["€"],
  "FJD": [void 0, "$"],
  "FKP": [void 0, "£"],
  "GBP": ["£"],
  "GEL": [void 0, "₾"],
  "GHS": [void 0, "GH₵"],
  "GIP": [void 0, "£"],
  "GNF": [void 0, "FG", 0],
  "GTQ": [void 0, "Q"],
  "GYD": [void 0, "$", 2],
  "HKD": ["HK$", "$"],
  "HNL": [void 0, "L"],
  "HRK": [void 0, "kn"],
  "HUF": [void 0, "Ft", 2],
  "IDR": [void 0, "Rp", 2],
  "ILS": ["₪"],
  "INR": ["₹"],
  "IQD": [void 0, void 0, 0],
  "IRR": [void 0, void 0, 0],
  "ISK": [void 0, "kr", 0],
  "ITL": [void 0, void 0, 0],
  "JMD": [void 0, "$"],
  "JOD": [void 0, void 0, 3],
  "JPY": ["¥", void 0, 0],
  "KHR": [void 0, "៛"],
  "KMF": [void 0, "CF", 0],
  "KPW": [void 0, "₩", 0],
  "KRW": ["₩", void 0, 0],
  "KWD": [void 0, void 0, 3],
  "KYD": [void 0, "$"],
  "KZT": [void 0, "₸"],
  "LAK": [void 0, "₭", 0],
  "LBP": [void 0, "L£", 0],
  "LKR": [void 0, "Rs"],
  "LRD": [void 0, "$"],
  "LTL": [void 0, "Lt"],
  "LUF": [void 0, void 0, 0],
  "LVL": [void 0, "Ls"],
  "LYD": [void 0, void 0, 3],
  "MGA": [void 0, "Ar", 0],
  "MGF": [void 0, void 0, 0],
  "MMK": [void 0, "K", 0],
  "MNT": [void 0, "₮", 2],
  "MRO": [void 0, void 0, 0],
  "MUR": [void 0, "Rs", 2],
  "MXN": ["MX$", "$"],
  "MYR": [void 0, "RM"],
  "NAD": [void 0, "$"],
  "NGN": [void 0, "₦"],
  "NIO": [void 0, "C$"],
  "NOK": [void 0, "kr", 2],
  "NPR": [void 0, "Rs"],
  "NZD": ["NZ$", "$"],
  "OMR": [void 0, void 0, 3],
  "PHP": ["₱"],
  "PKR": [void 0, "Rs", 2],
  "PLN": [void 0, "zł"],
  "PYG": [void 0, "₲", 0],
  "RON": [void 0, "lei"],
  "RSD": [void 0, void 0, 0],
  "RUB": [void 0, "₽"],
  "RWF": [void 0, "RF", 0],
  "SBD": [void 0, "$"],
  "SEK": [void 0, "kr", 2],
  "SGD": [void 0, "$"],
  "SHP": [void 0, "£"],
  "SLE": [void 0, void 0, 2],
  "SLL": [void 0, void 0, 0],
  "SOS": [void 0, void 0, 0],
  "SRD": [void 0, "$"],
  "SSP": [void 0, "£"],
  "STD": [void 0, void 0, 0],
  "STN": [void 0, "Db"],
  "SYP": [void 0, "£", 0],
  "THB": [void 0, "฿"],
  "TMM": [void 0, void 0, 0],
  "TND": [void 0, void 0, 3],
  "TOP": [void 0, "T$"],
  "TRL": [void 0, void 0, 0],
  "TRY": [void 0, "₺"],
  "TTD": [void 0, "$"],
  "TWD": ["NT$", "$", 2],
  "TZS": [void 0, void 0, 2],
  "UAH": [void 0, "₴"],
  "UGX": [void 0, void 0, 0],
  "USD": ["$"],
  "UYI": [void 0, void 0, 0],
  "UYU": [void 0, "$"],
  "UYW": [void 0, void 0, 4],
  "UZS": [void 0, void 0, 2],
  "VEF": [void 0, "Bs", 2],
  "VND": ["₫", void 0, 0],
  "VUV": [void 0, void 0, 0],
  "XAF": ["FCFA", void 0, 0],
  "XCD": ["EC$", "$"],
  "XOF": ["F CFA", void 0, 0],
  "XPF": ["CFPF", void 0, 0],
  "XXX": ["¤"],
  "YER": [void 0, void 0, 0],
  "ZAR": [void 0, "R"],
  "ZMK": [void 0, void 0, 0],
  "ZMW": [void 0, "ZK"],
  "ZWD": [void 0, void 0, 0]
};
var NumberFormatStyle;
(function(NumberFormatStyle2) {
  NumberFormatStyle2[NumberFormatStyle2["Decimal"] = 0] = "Decimal";
  NumberFormatStyle2[NumberFormatStyle2["Percent"] = 1] = "Percent";
  NumberFormatStyle2[NumberFormatStyle2["Currency"] = 2] = "Currency";
  NumberFormatStyle2[NumberFormatStyle2["Scientific"] = 3] = "Scientific";
})(NumberFormatStyle || (NumberFormatStyle = {}));
var Plural;
(function(Plural2) {
  Plural2[Plural2["Zero"] = 0] = "Zero";
  Plural2[Plural2["One"] = 1] = "One";
  Plural2[Plural2["Two"] = 2] = "Two";
  Plural2[Plural2["Few"] = 3] = "Few";
  Plural2[Plural2["Many"] = 4] = "Many";
  Plural2[Plural2["Other"] = 5] = "Other";
})(Plural || (Plural = {}));
var FormStyle;
(function(FormStyle2) {
  FormStyle2[FormStyle2["Format"] = 0] = "Format";
  FormStyle2[FormStyle2["Standalone"] = 1] = "Standalone";
})(FormStyle || (FormStyle = {}));
var TranslationWidth;
(function(TranslationWidth2) {
  TranslationWidth2[TranslationWidth2["Narrow"] = 0] = "Narrow";
  TranslationWidth2[TranslationWidth2["Abbreviated"] = 1] = "Abbreviated";
  TranslationWidth2[TranslationWidth2["Wide"] = 2] = "Wide";
  TranslationWidth2[TranslationWidth2["Short"] = 3] = "Short";
})(TranslationWidth || (TranslationWidth = {}));
var FormatWidth;
(function(FormatWidth2) {
  FormatWidth2[FormatWidth2["Short"] = 0] = "Short";
  FormatWidth2[FormatWidth2["Medium"] = 1] = "Medium";
  FormatWidth2[FormatWidth2["Long"] = 2] = "Long";
  FormatWidth2[FormatWidth2["Full"] = 3] = "Full";
})(FormatWidth || (FormatWidth = {}));
var NumberSymbol = {
  /**
   * Decimal separator.
   * For `en-US`, the dot character.
   * Example: 2,345`.`67
   */
  Decimal: 0,
  /**
   * Grouping separator, typically for thousands.
   * For `en-US`, the comma character.
   * Example: 2`,`345.67
   */
  Group: 1,
  /**
   * List-item separator.
   * Example: "one, two, and three"
   */
  List: 2,
  /**
   * Sign for percentage (out of 100).
   * Example: 23.4%
   */
  PercentSign: 3,
  /**
   * Sign for positive numbers.
   * Example: +23
   */
  PlusSign: 4,
  /**
   * Sign for negative numbers.
   * Example: -23
   */
  MinusSign: 5,
  /**
   * Computer notation for exponential value (n times a power of 10).
   * Example: 1.2E3
   */
  Exponential: 6,
  /**
   * Human-readable format of exponential.
   * Example: 1.2x103
   */
  SuperscriptingExponent: 7,
  /**
   * Sign for permille (out of 1000).
   * Example: 23.4‰
   */
  PerMille: 8,
  /**
   * Infinity, can be used with plus and minus.
   * Example: ∞, +∞, -∞
   */
  Infinity: 9,
  /**
   * Not a number.
   * Example: NaN
   */
  NaN: 10,
  /**
   * Symbol used between time units.
   * Example: 10:52
   */
  TimeSeparator: 11,
  /**
   * Decimal separator for currency values (fallback to `Decimal`).
   * Example: $2,345.67
   */
  CurrencyDecimal: 12,
  /**
   * Group separator for currency values (fallback to `Group`).
   * Example: $2,345.67
   */
  CurrencyGroup: 13
};
var WeekDay;
(function(WeekDay2) {
  WeekDay2[WeekDay2["Sunday"] = 0] = "Sunday";
  WeekDay2[WeekDay2["Monday"] = 1] = "Monday";
  WeekDay2[WeekDay2["Tuesday"] = 2] = "Tuesday";
  WeekDay2[WeekDay2["Wednesday"] = 3] = "Wednesday";
  WeekDay2[WeekDay2["Thursday"] = 4] = "Thursday";
  WeekDay2[WeekDay2["Friday"] = 5] = "Friday";
  WeekDay2[WeekDay2["Saturday"] = 6] = "Saturday";
})(WeekDay || (WeekDay = {}));
function getLocaleId(locale) {
  return findLocaleData(locale)[LocaleDataIndex.LocaleId];
}
function getLocaleDayPeriods(locale, formStyle, width) {
  const data = findLocaleData(locale);
  const amPmData = [data[LocaleDataIndex.DayPeriodsFormat], data[LocaleDataIndex.DayPeriodsStandalone]];
  const amPm = getLastDefinedValue(amPmData, formStyle);
  return getLastDefinedValue(amPm, width);
}
function getLocaleDayNames(locale, formStyle, width) {
  const data = findLocaleData(locale);
  const daysData = [data[LocaleDataIndex.DaysFormat], data[LocaleDataIndex.DaysStandalone]];
  const days = getLastDefinedValue(daysData, formStyle);
  return getLastDefinedValue(days, width);
}
function getLocaleMonthNames(locale, formStyle, width) {
  const data = findLocaleData(locale);
  const monthsData = [data[LocaleDataIndex.MonthsFormat], data[LocaleDataIndex.MonthsStandalone]];
  const months = getLastDefinedValue(monthsData, formStyle);
  return getLastDefinedValue(months, width);
}
function getLocaleEraNames(locale, width) {
  const data = findLocaleData(locale);
  const erasData = data[LocaleDataIndex.Eras];
  return getLastDefinedValue(erasData, width);
}
function getLocaleFirstDayOfWeek(locale) {
  const data = findLocaleData(locale);
  return data[LocaleDataIndex.FirstDayOfWeek];
}
function getLocaleWeekEndRange(locale) {
  const data = findLocaleData(locale);
  return data[LocaleDataIndex.WeekendRange];
}
function getLocaleDateFormat(locale, width) {
  const data = findLocaleData(locale);
  return getLastDefinedValue(data[LocaleDataIndex.DateFormat], width);
}
function getLocaleTimeFormat(locale, width) {
  const data = findLocaleData(locale);
  return getLastDefinedValue(data[LocaleDataIndex.TimeFormat], width);
}
function getLocaleDateTimeFormat(locale, width) {
  const data = findLocaleData(locale);
  const dateTimeFormatData = data[LocaleDataIndex.DateTimeFormat];
  return getLastDefinedValue(dateTimeFormatData, width);
}
function getLocaleNumberSymbol(locale, symbol) {
  const data = findLocaleData(locale);
  const res = data[LocaleDataIndex.NumberSymbols][symbol];
  if (typeof res === "undefined") {
    if (symbol === NumberSymbol.CurrencyDecimal) {
      return data[LocaleDataIndex.NumberSymbols][NumberSymbol.Decimal];
    } else if (symbol === NumberSymbol.CurrencyGroup) {
      return data[LocaleDataIndex.NumberSymbols][NumberSymbol.Group];
    }
  }
  return res;
}
function getLocaleNumberFormat(locale, type) {
  const data = findLocaleData(locale);
  return data[LocaleDataIndex.NumberFormats][type];
}
function getLocaleCurrencySymbol(locale) {
  const data = findLocaleData(locale);
  return data[LocaleDataIndex.CurrencySymbol] || null;
}
function getLocaleCurrencyName(locale) {
  const data = findLocaleData(locale);
  return data[LocaleDataIndex.CurrencyName] || null;
}
function getLocaleCurrencyCode2(locale) {
  return getLocaleCurrencyCode(locale);
}
function getLocaleCurrencies(locale) {
  const data = findLocaleData(locale);
  return data[LocaleDataIndex.Currencies];
}
var getLocalePluralCase2 = getLocalePluralCase;
function checkFullData(data) {
  if (!data[LocaleDataIndex.ExtraData]) {
    throw new Error(`Missing extra locale data for the locale "${data[LocaleDataIndex.LocaleId]}". Use "registerLocaleData" to load new data. See the "I18n guide" on angular.io to know more.`);
  }
}
function getLocaleExtraDayPeriodRules(locale) {
  const data = findLocaleData(locale);
  checkFullData(data);
  const rules = data[LocaleDataIndex.ExtraData][
    2
    /* ɵExtraLocaleDataIndex.ExtraDayPeriodsRules */
  ] || [];
  return rules.map((rule) => {
    if (typeof rule === "string") {
      return extractTime(rule);
    }
    return [extractTime(rule[0]), extractTime(rule[1])];
  });
}
function getLocaleExtraDayPeriods(locale, formStyle, width) {
  const data = findLocaleData(locale);
  checkFullData(data);
  const dayPeriodsData = [data[LocaleDataIndex.ExtraData][
    0
    /* ɵExtraLocaleDataIndex.ExtraDayPeriodFormats */
  ], data[LocaleDataIndex.ExtraData][
    1
    /* ɵExtraLocaleDataIndex.ExtraDayPeriodStandalone */
  ]];
  const dayPeriods = getLastDefinedValue(dayPeriodsData, formStyle) || [];
  return getLastDefinedValue(dayPeriods, width) || [];
}
function getLocaleDirection(locale) {
  const data = findLocaleData(locale);
  return data[LocaleDataIndex.Directionality];
}
function getLastDefinedValue(data, index) {
  for (let i = index; i > -1; i--) {
    if (typeof data[i] !== "undefined") {
      return data[i];
    }
  }
  throw new Error("Locale data API: locale data undefined");
}
function extractTime(time) {
  const [h, m] = time.split(":");
  return {
    hours: +h,
    minutes: +m
  };
}
function getCurrencySymbol(code, format, locale = "en") {
  const currency = getLocaleCurrencies(locale)[code] || CURRENCIES_EN[code] || [];
  const symbolNarrow = currency[
    1
    /* ɵCurrencyIndex.SymbolNarrow */
  ];
  if (format === "narrow" && typeof symbolNarrow === "string") {
    return symbolNarrow;
  }
  return currency[
    0
    /* ɵCurrencyIndex.Symbol */
  ] || code;
}
var DEFAULT_NB_OF_CURRENCY_DIGITS = 2;
function getNumberOfCurrencyDigits(code) {
  let digits;
  const currency = CURRENCIES_EN[code];
  if (currency) {
    digits = currency[
      2
      /* ɵCurrencyIndex.NbOfDigits */
    ];
  }
  return typeof digits === "number" ? digits : DEFAULT_NB_OF_CURRENCY_DIGITS;
}
var ISO8601_DATE_REGEX = /^(\d{4,})-?(\d\d)-?(\d\d)(?:T(\d\d)(?::?(\d\d)(?::?(\d\d)(?:\.(\d+))?)?)?(Z|([+-])(\d\d):?(\d\d))?)?$/;
var NAMED_FORMATS = {};
var DATE_FORMATS_SPLIT = /((?:[^BEGHLMOSWYZabcdhmswyz']+)|(?:'(?:[^']|'')*')|(?:G{1,5}|y{1,4}|Y{1,4}|M{1,5}|L{1,5}|w{1,2}|W{1}|d{1,2}|E{1,6}|c{1,6}|a{1,5}|b{1,5}|B{1,5}|h{1,2}|H{1,2}|m{1,2}|s{1,2}|S{1,3}|z{1,4}|Z{1,5}|O{1,4}))([\s\S]*)/;
var ZoneWidth;
(function(ZoneWidth2) {
  ZoneWidth2[ZoneWidth2["Short"] = 0] = "Short";
  ZoneWidth2[ZoneWidth2["ShortGMT"] = 1] = "ShortGMT";
  ZoneWidth2[ZoneWidth2["Long"] = 2] = "Long";
  ZoneWidth2[ZoneWidth2["Extended"] = 3] = "Extended";
})(ZoneWidth || (ZoneWidth = {}));
var DateType;
(function(DateType2) {
  DateType2[DateType2["FullYear"] = 0] = "FullYear";
  DateType2[DateType2["Month"] = 1] = "Month";
  DateType2[DateType2["Date"] = 2] = "Date";
  DateType2[DateType2["Hours"] = 3] = "Hours";
  DateType2[DateType2["Minutes"] = 4] = "Minutes";
  DateType2[DateType2["Seconds"] = 5] = "Seconds";
  DateType2[DateType2["FractionalSeconds"] = 6] = "FractionalSeconds";
  DateType2[DateType2["Day"] = 7] = "Day";
})(DateType || (DateType = {}));
var TranslationType;
(function(TranslationType2) {
  TranslationType2[TranslationType2["DayPeriods"] = 0] = "DayPeriods";
  TranslationType2[TranslationType2["Days"] = 1] = "Days";
  TranslationType2[TranslationType2["Months"] = 2] = "Months";
  TranslationType2[TranslationType2["Eras"] = 3] = "Eras";
})(TranslationType || (TranslationType = {}));
function formatDate(value, format, locale, timezone) {
  let date = toDate(value);
  const namedFormat = getNamedFormat(locale, format);
  format = namedFormat || format;
  let parts = [];
  let match;
  while (format) {
    match = DATE_FORMATS_SPLIT.exec(format);
    if (match) {
      parts = parts.concat(match.slice(1));
      const part = parts.pop();
      if (!part) {
        break;
      }
      format = part;
    } else {
      parts.push(format);
      break;
    }
  }
  let dateTimezoneOffset = date.getTimezoneOffset();
  if (timezone) {
    dateTimezoneOffset = timezoneToOffset(timezone, dateTimezoneOffset);
    date = convertTimezoneToLocal(date, timezone, true);
  }
  let text = "";
  parts.forEach((value2) => {
    const dateFormatter = getDateFormatter(value2);
    text += dateFormatter ? dateFormatter(date, locale, dateTimezoneOffset) : value2 === "''" ? "'" : value2.replace(/(^'|'$)/g, "").replace(/''/g, "'");
  });
  return text;
}
function createDate(year, month, date) {
  const newDate = /* @__PURE__ */ new Date(0);
  newDate.setFullYear(year, month, date);
  newDate.setHours(0, 0, 0);
  return newDate;
}
function getNamedFormat(locale, format) {
  const localeId = getLocaleId(locale);
  NAMED_FORMATS[localeId] ??= {};
  if (NAMED_FORMATS[localeId][format]) {
    return NAMED_FORMATS[localeId][format];
  }
  let formatValue = "";
  switch (format) {
    case "shortDate":
      formatValue = getLocaleDateFormat(locale, FormatWidth.Short);
      break;
    case "mediumDate":
      formatValue = getLocaleDateFormat(locale, FormatWidth.Medium);
      break;
    case "longDate":
      formatValue = getLocaleDateFormat(locale, FormatWidth.Long);
      break;
    case "fullDate":
      formatValue = getLocaleDateFormat(locale, FormatWidth.Full);
      break;
    case "shortTime":
      formatValue = getLocaleTimeFormat(locale, FormatWidth.Short);
      break;
    case "mediumTime":
      formatValue = getLocaleTimeFormat(locale, FormatWidth.Medium);
      break;
    case "longTime":
      formatValue = getLocaleTimeFormat(locale, FormatWidth.Long);
      break;
    case "fullTime":
      formatValue = getLocaleTimeFormat(locale, FormatWidth.Full);
      break;
    case "short":
      const shortTime = getNamedFormat(locale, "shortTime");
      const shortDate = getNamedFormat(locale, "shortDate");
      formatValue = formatDateTime(getLocaleDateTimeFormat(locale, FormatWidth.Short), [shortTime, shortDate]);
      break;
    case "medium":
      const mediumTime = getNamedFormat(locale, "mediumTime");
      const mediumDate = getNamedFormat(locale, "mediumDate");
      formatValue = formatDateTime(getLocaleDateTimeFormat(locale, FormatWidth.Medium), [mediumTime, mediumDate]);
      break;
    case "long":
      const longTime = getNamedFormat(locale, "longTime");
      const longDate = getNamedFormat(locale, "longDate");
      formatValue = formatDateTime(getLocaleDateTimeFormat(locale, FormatWidth.Long), [longTime, longDate]);
      break;
    case "full":
      const fullTime = getNamedFormat(locale, "fullTime");
      const fullDate = getNamedFormat(locale, "fullDate");
      formatValue = formatDateTime(getLocaleDateTimeFormat(locale, FormatWidth.Full), [fullTime, fullDate]);
      break;
  }
  if (formatValue) {
    NAMED_FORMATS[localeId][format] = formatValue;
  }
  return formatValue;
}
function formatDateTime(str, opt_values) {
  if (opt_values) {
    str = str.replace(/\{([^}]+)}/g, function(match, key) {
      return opt_values != null && key in opt_values ? opt_values[key] : match;
    });
  }
  return str;
}
function padNumber(num, digits, minusSign = "-", trim, negWrap) {
  let neg = "";
  if (num < 0 || negWrap && num <= 0) {
    if (negWrap) {
      num = -num + 1;
    } else {
      num = -num;
      neg = minusSign;
    }
  }
  let strNum = String(num);
  while (strNum.length < digits) {
    strNum = "0" + strNum;
  }
  if (trim) {
    strNum = strNum.slice(strNum.length - digits);
  }
  return neg + strNum;
}
function formatFractionalSeconds(milliseconds, digits) {
  const strMs = padNumber(milliseconds, 3);
  return strMs.substring(0, digits);
}
function dateGetter(name, size, offset = 0, trim = false, negWrap = false) {
  return function(date, locale) {
    let part = getDatePart(name, date);
    if (offset > 0 || part > -offset) {
      part += offset;
    }
    if (name === DateType.Hours) {
      if (part === 0 && offset === -12) {
        part = 12;
      }
    } else if (name === DateType.FractionalSeconds) {
      return formatFractionalSeconds(part, size);
    }
    const localeMinus = getLocaleNumberSymbol(locale, NumberSymbol.MinusSign);
    return padNumber(part, size, localeMinus, trim, negWrap);
  };
}
function getDatePart(part, date) {
  switch (part) {
    case DateType.FullYear:
      return date.getFullYear();
    case DateType.Month:
      return date.getMonth();
    case DateType.Date:
      return date.getDate();
    case DateType.Hours:
      return date.getHours();
    case DateType.Minutes:
      return date.getMinutes();
    case DateType.Seconds:
      return date.getSeconds();
    case DateType.FractionalSeconds:
      return date.getMilliseconds();
    case DateType.Day:
      return date.getDay();
    default:
      throw new Error(`Unknown DateType value "${part}".`);
  }
}
function dateStrGetter(name, width, form = FormStyle.Format, extended = false) {
  return function(date, locale) {
    return getDateTranslation(date, locale, name, width, form, extended);
  };
}
function getDateTranslation(date, locale, name, width, form, extended) {
  switch (name) {
    case TranslationType.Months:
      return getLocaleMonthNames(locale, form, width)[date.getMonth()];
    case TranslationType.Days:
      return getLocaleDayNames(locale, form, width)[date.getDay()];
    case TranslationType.DayPeriods:
      const currentHours = date.getHours();
      const currentMinutes = date.getMinutes();
      if (extended) {
        const rules = getLocaleExtraDayPeriodRules(locale);
        const dayPeriods = getLocaleExtraDayPeriods(locale, form, width);
        const index = rules.findIndex((rule) => {
          if (Array.isArray(rule)) {
            const [from, to] = rule;
            const afterFrom = currentHours >= from.hours && currentMinutes >= from.minutes;
            const beforeTo = currentHours < to.hours || currentHours === to.hours && currentMinutes < to.minutes;
            if (from.hours < to.hours) {
              if (afterFrom && beforeTo) {
                return true;
              }
            } else if (afterFrom || beforeTo) {
              return true;
            }
          } else {
            if (rule.hours === currentHours && rule.minutes === currentMinutes) {
              return true;
            }
          }
          return false;
        });
        if (index !== -1) {
          return dayPeriods[index];
        }
      }
      return getLocaleDayPeriods(locale, form, width)[currentHours < 12 ? 0 : 1];
    case TranslationType.Eras:
      return getLocaleEraNames(locale, width)[date.getFullYear() <= 0 ? 0 : 1];
    default:
      const unexpected = name;
      throw new Error(`unexpected translation type ${unexpected}`);
  }
}
function timeZoneGetter(width) {
  return function(date, locale, offset) {
    const zone = -1 * offset;
    const minusSign = getLocaleNumberSymbol(locale, NumberSymbol.MinusSign);
    const hours = zone > 0 ? Math.floor(zone / 60) : Math.ceil(zone / 60);
    switch (width) {
      case ZoneWidth.Short:
        return (zone >= 0 ? "+" : "") + padNumber(hours, 2, minusSign) + padNumber(Math.abs(zone % 60), 2, minusSign);
      case ZoneWidth.ShortGMT:
        return "GMT" + (zone >= 0 ? "+" : "") + padNumber(hours, 1, minusSign);
      case ZoneWidth.Long:
        return "GMT" + (zone >= 0 ? "+" : "") + padNumber(hours, 2, minusSign) + ":" + padNumber(Math.abs(zone % 60), 2, minusSign);
      case ZoneWidth.Extended:
        if (offset === 0) {
          return "Z";
        } else {
          return (zone >= 0 ? "+" : "") + padNumber(hours, 2, minusSign) + ":" + padNumber(Math.abs(zone % 60), 2, minusSign);
        }
      default:
        throw new Error(`Unknown zone width "${width}"`);
    }
  };
}
var JANUARY = 0;
var THURSDAY = 4;
function getFirstThursdayOfYear(year) {
  const firstDayOfYear = createDate(year, JANUARY, 1).getDay();
  return createDate(year, 0, 1 + (firstDayOfYear <= THURSDAY ? THURSDAY : THURSDAY + 7) - firstDayOfYear);
}
function getThursdayThisIsoWeek(datetime) {
  const currentDay = datetime.getDay();
  const deltaToThursday = currentDay === 0 ? -3 : THURSDAY - currentDay;
  return createDate(datetime.getFullYear(), datetime.getMonth(), datetime.getDate() + deltaToThursday);
}
function weekGetter(size, monthBased = false) {
  return function(date, locale) {
    let result;
    if (monthBased) {
      const nbDaysBefore1stDayOfMonth = new Date(date.getFullYear(), date.getMonth(), 1).getDay() - 1;
      const today = date.getDate();
      result = 1 + Math.floor((today + nbDaysBefore1stDayOfMonth) / 7);
    } else {
      const thisThurs = getThursdayThisIsoWeek(date);
      const firstThurs = getFirstThursdayOfYear(thisThurs.getFullYear());
      const diff = thisThurs.getTime() - firstThurs.getTime();
      result = 1 + Math.round(diff / 6048e5);
    }
    return padNumber(result, size, getLocaleNumberSymbol(locale, NumberSymbol.MinusSign));
  };
}
function weekNumberingYearGetter(size, trim = false) {
  return function(date, locale) {
    const thisThurs = getThursdayThisIsoWeek(date);
    const weekNumberingYear = thisThurs.getFullYear();
    return padNumber(weekNumberingYear, size, getLocaleNumberSymbol(locale, NumberSymbol.MinusSign), trim);
  };
}
var DATE_FORMATS = {};
function getDateFormatter(format) {
  if (DATE_FORMATS[format]) {
    return DATE_FORMATS[format];
  }
  let formatter;
  switch (format) {
    case "G":
    case "GG":
    case "GGG":
      formatter = dateStrGetter(TranslationType.Eras, TranslationWidth.Abbreviated);
      break;
    case "GGGG":
      formatter = dateStrGetter(TranslationType.Eras, TranslationWidth.Wide);
      break;
    case "GGGGG":
      formatter = dateStrGetter(TranslationType.Eras, TranslationWidth.Narrow);
      break;
    case "y":
      formatter = dateGetter(DateType.FullYear, 1, 0, false, true);
      break;
    case "yy":
      formatter = dateGetter(DateType.FullYear, 2, 0, true, true);
      break;
    case "yyy":
      formatter = dateGetter(DateType.FullYear, 3, 0, false, true);
      break;
    case "yyyy":
      formatter = dateGetter(DateType.FullYear, 4, 0, false, true);
      break;
    case "Y":
      formatter = weekNumberingYearGetter(1);
      break;
    case "YY":
      formatter = weekNumberingYearGetter(2, true);
      break;
    case "YYY":
      formatter = weekNumberingYearGetter(3);
      break;
    case "YYYY":
      formatter = weekNumberingYearGetter(4);
      break;
    case "M":
    case "L":
      formatter = dateGetter(DateType.Month, 1, 1);
      break;
    case "MM":
    case "LL":
      formatter = dateGetter(DateType.Month, 2, 1);
      break;
    case "MMM":
      formatter = dateStrGetter(TranslationType.Months, TranslationWidth.Abbreviated);
      break;
    case "MMMM":
      formatter = dateStrGetter(TranslationType.Months, TranslationWidth.Wide);
      break;
    case "MMMMM":
      formatter = dateStrGetter(TranslationType.Months, TranslationWidth.Narrow);
      break;
    case "LLL":
      formatter = dateStrGetter(TranslationType.Months, TranslationWidth.Abbreviated, FormStyle.Standalone);
      break;
    case "LLLL":
      formatter = dateStrGetter(TranslationType.Months, TranslationWidth.Wide, FormStyle.Standalone);
      break;
    case "LLLLL":
      formatter = dateStrGetter(TranslationType.Months, TranslationWidth.Narrow, FormStyle.Standalone);
      break;
    case "w":
      formatter = weekGetter(1);
      break;
    case "ww":
      formatter = weekGetter(2);
      break;
    case "W":
      formatter = weekGetter(1, true);
      break;
    case "d":
      formatter = dateGetter(DateType.Date, 1);
      break;
    case "dd":
      formatter = dateGetter(DateType.Date, 2);
      break;
    case "c":
    case "cc":
      formatter = dateGetter(DateType.Day, 1);
      break;
    case "ccc":
      formatter = dateStrGetter(TranslationType.Days, TranslationWidth.Abbreviated, FormStyle.Standalone);
      break;
    case "cccc":
      formatter = dateStrGetter(TranslationType.Days, TranslationWidth.Wide, FormStyle.Standalone);
      break;
    case "ccccc":
      formatter = dateStrGetter(TranslationType.Days, TranslationWidth.Narrow, FormStyle.Standalone);
      break;
    case "cccccc":
      formatter = dateStrGetter(TranslationType.Days, TranslationWidth.Short, FormStyle.Standalone);
      break;
    case "E":
    case "EE":
    case "EEE":
      formatter = dateStrGetter(TranslationType.Days, TranslationWidth.Abbreviated);
      break;
    case "EEEE":
      formatter = dateStrGetter(TranslationType.Days, TranslationWidth.Wide);
      break;
    case "EEEEE":
      formatter = dateStrGetter(TranslationType.Days, TranslationWidth.Narrow);
      break;
    case "EEEEEE":
      formatter = dateStrGetter(TranslationType.Days, TranslationWidth.Short);
      break;
    case "a":
    case "aa":
    case "aaa":
      formatter = dateStrGetter(TranslationType.DayPeriods, TranslationWidth.Abbreviated);
      break;
    case "aaaa":
      formatter = dateStrGetter(TranslationType.DayPeriods, TranslationWidth.Wide);
      break;
    case "aaaaa":
      formatter = dateStrGetter(TranslationType.DayPeriods, TranslationWidth.Narrow);
      break;
    case "b":
    case "bb":
    case "bbb":
      formatter = dateStrGetter(TranslationType.DayPeriods, TranslationWidth.Abbreviated, FormStyle.Standalone, true);
      break;
    case "bbbb":
      formatter = dateStrGetter(TranslationType.DayPeriods, TranslationWidth.Wide, FormStyle.Standalone, true);
      break;
    case "bbbbb":
      formatter = dateStrGetter(TranslationType.DayPeriods, TranslationWidth.Narrow, FormStyle.Standalone, true);
      break;
    case "B":
    case "BB":
    case "BBB":
      formatter = dateStrGetter(TranslationType.DayPeriods, TranslationWidth.Abbreviated, FormStyle.Format, true);
      break;
    case "BBBB":
      formatter = dateStrGetter(TranslationType.DayPeriods, TranslationWidth.Wide, FormStyle.Format, true);
      break;
    case "BBBBB":
      formatter = dateStrGetter(TranslationType.DayPeriods, TranslationWidth.Narrow, FormStyle.Format, true);
      break;
    case "h":
      formatter = dateGetter(DateType.Hours, 1, -12);
      break;
    case "hh":
      formatter = dateGetter(DateType.Hours, 2, -12);
      break;
    case "H":
      formatter = dateGetter(DateType.Hours, 1);
      break;
    case "HH":
      formatter = dateGetter(DateType.Hours, 2);
      break;
    case "m":
      formatter = dateGetter(DateType.Minutes, 1);
      break;
    case "mm":
      formatter = dateGetter(DateType.Minutes, 2);
      break;
    case "s":
      formatter = dateGetter(DateType.Seconds, 1);
      break;
    case "ss":
      formatter = dateGetter(DateType.Seconds, 2);
      break;
    case "S":
      formatter = dateGetter(DateType.FractionalSeconds, 1);
      break;
    case "SS":
      formatter = dateGetter(DateType.FractionalSeconds, 2);
      break;
    case "SSS":
      formatter = dateGetter(DateType.FractionalSeconds, 3);
      break;
    case "Z":
    case "ZZ":
    case "ZZZ":
      formatter = timeZoneGetter(ZoneWidth.Short);
      break;
    case "ZZZZZ":
      formatter = timeZoneGetter(ZoneWidth.Extended);
      break;
    case "O":
    case "OO":
    case "OOO":
    case "z":
    case "zz":
    case "zzz":
      formatter = timeZoneGetter(ZoneWidth.ShortGMT);
      break;
    case "OOOO":
    case "ZZZZ":
    case "zzzz":
      formatter = timeZoneGetter(ZoneWidth.Long);
      break;
    default:
      return null;
  }
  DATE_FORMATS[format] = formatter;
  return formatter;
}
function timezoneToOffset(timezone, fallback) {
  timezone = timezone.replace(/:/g, "");
  const requestedTimezoneOffset = Date.parse("Jan 01, 1970 00:00:00 " + timezone) / 6e4;
  return isNaN(requestedTimezoneOffset) ? fallback : requestedTimezoneOffset;
}
function addDateMinutes(date, minutes) {
  date = new Date(date.getTime());
  date.setMinutes(date.getMinutes() + minutes);
  return date;
}
function convertTimezoneToLocal(date, timezone, reverse) {
  const reverseValue = reverse ? -1 : 1;
  const dateTimezoneOffset = date.getTimezoneOffset();
  const timezoneOffset = timezoneToOffset(timezone, dateTimezoneOffset);
  return addDateMinutes(date, reverseValue * (timezoneOffset - dateTimezoneOffset));
}
function toDate(value) {
  if (isDate(value)) {
    return value;
  }
  if (typeof value === "number" && !isNaN(value)) {
    return new Date(value);
  }
  if (typeof value === "string") {
    value = value.trim();
    if (/^(\d{4}(-\d{1,2}(-\d{1,2})?)?)$/.test(value)) {
      const [y, m = 1, d = 1] = value.split("-").map((val) => +val);
      return createDate(y, m - 1, d);
    }
    const parsedNb = parseFloat(value);
    if (!isNaN(value - parsedNb)) {
      return new Date(parsedNb);
    }
    let match;
    if (match = value.match(ISO8601_DATE_REGEX)) {
      return isoStringToDate(match);
    }
  }
  const date = new Date(value);
  if (!isDate(date)) {
    throw new Error(`Unable to convert "${value}" into a date`);
  }
  return date;
}
function isoStringToDate(match) {
  const date = /* @__PURE__ */ new Date(0);
  let tzHour = 0;
  let tzMin = 0;
  const dateSetter = match[8] ? date.setUTCFullYear : date.setFullYear;
  const timeSetter = match[8] ? date.setUTCHours : date.setHours;
  if (match[9]) {
    tzHour = Number(match[9] + match[10]);
    tzMin = Number(match[9] + match[11]);
  }
  dateSetter.call(date, Number(match[1]), Number(match[2]) - 1, Number(match[3]));
  const h = Number(match[4] || 0) - tzHour;
  const m = Number(match[5] || 0) - tzMin;
  const s = Number(match[6] || 0);
  const ms = Math.floor(parseFloat("0." + (match[7] || 0)) * 1e3);
  timeSetter.call(date, h, m, s, ms);
  return date;
}
function isDate(value) {
  return value instanceof Date && !isNaN(value.valueOf());
}
var NUMBER_FORMAT_REGEXP = /^(\d+)?\.((\d+)(-(\d+))?)?$/;
var MAX_DIGITS = 22;
var DECIMAL_SEP = ".";
var ZERO_CHAR = "0";
var PATTERN_SEP = ";";
var GROUP_SEP = ",";
var DIGIT_CHAR = "#";
var CURRENCY_CHAR = "¤";
var PERCENT_CHAR = "%";
function formatNumberToLocaleString(value, pattern, locale, groupSymbol, decimalSymbol, digitsInfo, isPercent = false) {
  let formattedText = "";
  let isZero = false;
  if (!isFinite(value)) {
    formattedText = getLocaleNumberSymbol(locale, NumberSymbol.Infinity);
  } else {
    let parsedNumber = parseNumber(value);
    if (isPercent) {
      parsedNumber = toPercent(parsedNumber);
    }
    let minInt = pattern.minInt;
    let minFraction = pattern.minFrac;
    let maxFraction = pattern.maxFrac;
    if (digitsInfo) {
      const parts = digitsInfo.match(NUMBER_FORMAT_REGEXP);
      if (parts === null) {
        throw new Error(`${digitsInfo} is not a valid digit info`);
      }
      const minIntPart = parts[1];
      const minFractionPart = parts[3];
      const maxFractionPart = parts[5];
      if (minIntPart != null) {
        minInt = parseIntAutoRadix(minIntPart);
      }
      if (minFractionPart != null) {
        minFraction = parseIntAutoRadix(minFractionPart);
      }
      if (maxFractionPart != null) {
        maxFraction = parseIntAutoRadix(maxFractionPart);
      } else if (minFractionPart != null && minFraction > maxFraction) {
        maxFraction = minFraction;
      }
    }
    roundNumber(parsedNumber, minFraction, maxFraction);
    let digits = parsedNumber.digits;
    let integerLen = parsedNumber.integerLen;
    const exponent = parsedNumber.exponent;
    let decimals = [];
    isZero = digits.every((d) => !d);
    for (; integerLen < minInt; integerLen++) {
      digits.unshift(0);
    }
    for (; integerLen < 0; integerLen++) {
      digits.unshift(0);
    }
    if (integerLen > 0) {
      decimals = digits.splice(integerLen, digits.length);
    } else {
      decimals = digits;
      digits = [0];
    }
    const groups = [];
    if (digits.length >= pattern.lgSize) {
      groups.unshift(digits.splice(-pattern.lgSize, digits.length).join(""));
    }
    while (digits.length > pattern.gSize) {
      groups.unshift(digits.splice(-pattern.gSize, digits.length).join(""));
    }
    if (digits.length) {
      groups.unshift(digits.join(""));
    }
    formattedText = groups.join(getLocaleNumberSymbol(locale, groupSymbol));
    if (decimals.length) {
      formattedText += getLocaleNumberSymbol(locale, decimalSymbol) + decimals.join("");
    }
    if (exponent) {
      formattedText += getLocaleNumberSymbol(locale, NumberSymbol.Exponential) + "+" + exponent;
    }
  }
  if (value < 0 && !isZero) {
    formattedText = pattern.negPre + formattedText + pattern.negSuf;
  } else {
    formattedText = pattern.posPre + formattedText + pattern.posSuf;
  }
  return formattedText;
}
function formatCurrency(value, locale, currency, currencyCode, digitsInfo) {
  const format = getLocaleNumberFormat(locale, NumberFormatStyle.Currency);
  const pattern = parseNumberFormat(format, getLocaleNumberSymbol(locale, NumberSymbol.MinusSign));
  pattern.minFrac = getNumberOfCurrencyDigits(currencyCode);
  pattern.maxFrac = pattern.minFrac;
  const res = formatNumberToLocaleString(value, pattern, locale, NumberSymbol.CurrencyGroup, NumberSymbol.CurrencyDecimal, digitsInfo);
  return res.replace(CURRENCY_CHAR, currency).replace(CURRENCY_CHAR, "").trim();
}
function formatPercent(value, locale, digitsInfo) {
  const format = getLocaleNumberFormat(locale, NumberFormatStyle.Percent);
  const pattern = parseNumberFormat(format, getLocaleNumberSymbol(locale, NumberSymbol.MinusSign));
  const res = formatNumberToLocaleString(value, pattern, locale, NumberSymbol.Group, NumberSymbol.Decimal, digitsInfo, true);
  return res.replace(new RegExp(PERCENT_CHAR, "g"), getLocaleNumberSymbol(locale, NumberSymbol.PercentSign));
}
function formatNumber(value, locale, digitsInfo) {
  const format = getLocaleNumberFormat(locale, NumberFormatStyle.Decimal);
  const pattern = parseNumberFormat(format, getLocaleNumberSymbol(locale, NumberSymbol.MinusSign));
  return formatNumberToLocaleString(value, pattern, locale, NumberSymbol.Group, NumberSymbol.Decimal, digitsInfo);
}
function parseNumberFormat(format, minusSign = "-") {
  const p = {
    minInt: 1,
    minFrac: 0,
    maxFrac: 0,
    posPre: "",
    posSuf: "",
    negPre: "",
    negSuf: "",
    gSize: 0,
    lgSize: 0
  };
  const patternParts = format.split(PATTERN_SEP);
  const positive = patternParts[0];
  const negative = patternParts[1];
  const positiveParts = positive.indexOf(DECIMAL_SEP) !== -1 ? positive.split(DECIMAL_SEP) : [positive.substring(0, positive.lastIndexOf(ZERO_CHAR) + 1), positive.substring(positive.lastIndexOf(ZERO_CHAR) + 1)], integer = positiveParts[0], fraction = positiveParts[1] || "";
  p.posPre = integer.substring(0, integer.indexOf(DIGIT_CHAR));
  for (let i = 0; i < fraction.length; i++) {
    const ch = fraction.charAt(i);
    if (ch === ZERO_CHAR) {
      p.minFrac = p.maxFrac = i + 1;
    } else if (ch === DIGIT_CHAR) {
      p.maxFrac = i + 1;
    } else {
      p.posSuf += ch;
    }
  }
  const groups = integer.split(GROUP_SEP);
  p.gSize = groups[1] ? groups[1].length : 0;
  p.lgSize = groups[2] || groups[1] ? (groups[2] || groups[1]).length : 0;
  if (negative) {
    const trunkLen = positive.length - p.posPre.length - p.posSuf.length, pos = negative.indexOf(DIGIT_CHAR);
    p.negPre = negative.substring(0, pos).replace(/'/g, "");
    p.negSuf = negative.slice(pos + trunkLen).replace(/'/g, "");
  } else {
    p.negPre = minusSign + p.posPre;
    p.negSuf = p.posSuf;
  }
  return p;
}
function toPercent(parsedNumber) {
  if (parsedNumber.digits[0] === 0) {
    return parsedNumber;
  }
  const fractionLen = parsedNumber.digits.length - parsedNumber.integerLen;
  if (parsedNumber.exponent) {
    parsedNumber.exponent += 2;
  } else {
    if (fractionLen === 0) {
      parsedNumber.digits.push(0, 0);
    } else if (fractionLen === 1) {
      parsedNumber.digits.push(0);
    }
    parsedNumber.integerLen += 2;
  }
  return parsedNumber;
}
function parseNumber(num) {
  let numStr = Math.abs(num) + "";
  let exponent = 0, digits, integerLen;
  let i, j, zeros;
  if ((integerLen = numStr.indexOf(DECIMAL_SEP)) > -1) {
    numStr = numStr.replace(DECIMAL_SEP, "");
  }
  if ((i = numStr.search(/e/i)) > 0) {
    if (integerLen < 0) integerLen = i;
    integerLen += +numStr.slice(i + 1);
    numStr = numStr.substring(0, i);
  } else if (integerLen < 0) {
    integerLen = numStr.length;
  }
  for (i = 0; numStr.charAt(i) === ZERO_CHAR; i++) {
  }
  if (i === (zeros = numStr.length)) {
    digits = [0];
    integerLen = 1;
  } else {
    zeros--;
    while (numStr.charAt(zeros) === ZERO_CHAR) zeros--;
    integerLen -= i;
    digits = [];
    for (j = 0; i <= zeros; i++, j++) {
      digits[j] = Number(numStr.charAt(i));
    }
  }
  if (integerLen > MAX_DIGITS) {
    digits = digits.splice(0, MAX_DIGITS - 1);
    exponent = integerLen - 1;
    integerLen = 1;
  }
  return {
    digits,
    exponent,
    integerLen
  };
}
function roundNumber(parsedNumber, minFrac, maxFrac) {
  if (minFrac > maxFrac) {
    throw new Error(`The minimum number of digits after fraction (${minFrac}) is higher than the maximum (${maxFrac}).`);
  }
  let digits = parsedNumber.digits;
  let fractionLen = digits.length - parsedNumber.integerLen;
  const fractionSize = Math.min(Math.max(minFrac, fractionLen), maxFrac);
  let roundAt = fractionSize + parsedNumber.integerLen;
  let digit = digits[roundAt];
  if (roundAt > 0) {
    digits.splice(Math.max(parsedNumber.integerLen, roundAt));
    for (let j = roundAt; j < digits.length; j++) {
      digits[j] = 0;
    }
  } else {
    fractionLen = Math.max(0, fractionLen);
    parsedNumber.integerLen = 1;
    digits.length = Math.max(1, roundAt = fractionSize + 1);
    digits[0] = 0;
    for (let i = 1; i < roundAt; i++) digits[i] = 0;
  }
  if (digit >= 5) {
    if (roundAt - 1 < 0) {
      for (let k = 0; k > roundAt; k--) {
        digits.unshift(0);
        parsedNumber.integerLen++;
      }
      digits.unshift(1);
      parsedNumber.integerLen++;
    } else {
      digits[roundAt - 1]++;
    }
  }
  for (; fractionLen < Math.max(0, fractionSize); fractionLen++) digits.push(0);
  let dropTrailingZeros = fractionSize !== 0;
  const minLen = minFrac + parsedNumber.integerLen;
  const carry = digits.reduceRight(function(carry2, d, i, digits2) {
    d = d + carry2;
    digits2[i] = d < 10 ? d : d - 10;
    if (dropTrailingZeros) {
      if (digits2[i] === 0 && i >= minLen) {
        digits2.pop();
      } else {
        dropTrailingZeros = false;
      }
    }
    return d >= 10 ? 1 : 0;
  }, 0);
  if (carry) {
    digits.unshift(carry);
    parsedNumber.integerLen++;
  }
}
function parseIntAutoRadix(text) {
  const result = parseInt(text);
  if (isNaN(result)) {
    throw new Error("Invalid integer literal when parsing " + text);
  }
  return result;
}
var NgLocalization = class _NgLocalization {
  static {
    this.ɵfac = function NgLocalization_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _NgLocalization)();
    };
  }
  static {
    this.ɵprov = ɵɵdefineInjectable({
      token: _NgLocalization,
      factory: function NgLocalization_Factory(__ngFactoryType__) {
        let __ngConditionalFactory__ = null;
        if (__ngFactoryType__) {
          __ngConditionalFactory__ = new __ngFactoryType__();
        } else {
          __ngConditionalFactory__ = ((locale) => new NgLocaleLocalization(locale))(ɵɵinject(LOCALE_ID));
        }
        return __ngConditionalFactory__;
      },
      providedIn: "root"
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NgLocalization, [{
    type: Injectable,
    args: [{
      providedIn: "root",
      useFactory: (locale) => new NgLocaleLocalization(locale),
      deps: [LOCALE_ID]
    }]
  }], null, null);
})();
function getPluralCategory(value, cases, ngLocalization, locale) {
  let key = `=${value}`;
  if (cases.indexOf(key) > -1) {
    return key;
  }
  key = ngLocalization.getPluralCategory(value, locale);
  if (cases.indexOf(key) > -1) {
    return key;
  }
  if (cases.indexOf("other") > -1) {
    return "other";
  }
  throw new Error(`No plural message found for value "${value}"`);
}
var NgLocaleLocalization = class _NgLocaleLocalization extends NgLocalization {
  constructor(locale) {
    super();
    this.locale = locale;
  }
  getPluralCategory(value, locale) {
    const plural = getLocalePluralCase2(locale || this.locale)(value);
    switch (plural) {
      case Plural.Zero:
        return "zero";
      case Plural.One:
        return "one";
      case Plural.Two:
        return "two";
      case Plural.Few:
        return "few";
      case Plural.Many:
        return "many";
      default:
        return "other";
    }
  }
  static {
    this.ɵfac = function NgLocaleLocalization_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _NgLocaleLocalization)(ɵɵinject(LOCALE_ID));
    };
  }
  static {
    this.ɵprov = ɵɵdefineInjectable({
      token: _NgLocaleLocalization,
      factory: _NgLocaleLocalization.ɵfac
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NgLocaleLocalization, [{
    type: Injectable
  }], () => [{
    type: void 0,
    decorators: [{
      type: Inject,
      args: [LOCALE_ID]
    }]
  }], null);
})();
function registerLocaleData2(data, localeId, extraData) {
  return registerLocaleData(data, localeId, extraData);
}
function parseCookieValue(cookieStr, name) {
  name = encodeURIComponent(name);
  for (const cookie of cookieStr.split(";")) {
    const eqIndex = cookie.indexOf("=");
    const [cookieName, cookieValue] = eqIndex == -1 ? [cookie, ""] : [cookie.slice(0, eqIndex), cookie.slice(eqIndex + 1)];
    if (cookieName.trim() === name) {
      return decodeURIComponent(cookieValue);
    }
  }
  return null;
}
var WS_REGEXP = /\s+/;
var EMPTY_ARRAY = [];
var NgClass = class _NgClass {
  constructor(_ngEl, _renderer) {
    this._ngEl = _ngEl;
    this._renderer = _renderer;
    this.initialClasses = EMPTY_ARRAY;
    this.stateMap = /* @__PURE__ */ new Map();
  }
  set klass(value) {
    this.initialClasses = value != null ? value.trim().split(WS_REGEXP) : EMPTY_ARRAY;
  }
  set ngClass(value) {
    this.rawClass = typeof value === "string" ? value.trim().split(WS_REGEXP) : value;
  }
  /*
  The NgClass directive uses the custom change detection algorithm for its inputs. The custom
  algorithm is necessary since inputs are represented as complex object or arrays that need to be
  deeply-compared.
     This algorithm is perf-sensitive since NgClass is used very frequently and its poor performance
  might negatively impact runtime performance of the entire change detection cycle. The design of
  this algorithm is making sure that:
  - there is no unnecessary DOM manipulation (CSS classes are added / removed from the DOM only when
  needed), even if references to bound objects change;
  - there is no memory allocation if nothing changes (even relatively modest memory allocation
  during the change detection cycle can result in GC pauses for some of the CD cycles).
     The algorithm works by iterating over the set of bound classes, staring with [class] binding and
  then going over [ngClass] binding. For each CSS class name:
  - check if it was seen before (this information is tracked in the state map) and if its value
  changed;
  - mark it as "touched" - names that are not marked are not present in the latest set of binding
  and we can remove such class name from the internal data structures;
     After iteration over all the CSS class names we've got data structure with all the information
  necessary to synchronize changes to the DOM - it is enough to iterate over the state map, flush
  changes to the DOM and reset internal data structures so those are ready for the next change
  detection cycle.
   */
  ngDoCheck() {
    for (const klass of this.initialClasses) {
      this._updateState(klass, true);
    }
    const rawClass = this.rawClass;
    if (Array.isArray(rawClass) || rawClass instanceof Set) {
      for (const klass of rawClass) {
        this._updateState(klass, true);
      }
    } else if (rawClass != null) {
      for (const klass of Object.keys(rawClass)) {
        this._updateState(klass, Boolean(rawClass[klass]));
      }
    }
    this._applyStateDiff();
  }
  _updateState(klass, nextEnabled) {
    const state = this.stateMap.get(klass);
    if (state !== void 0) {
      if (state.enabled !== nextEnabled) {
        state.changed = true;
        state.enabled = nextEnabled;
      }
      state.touched = true;
    } else {
      this.stateMap.set(klass, {
        enabled: nextEnabled,
        changed: true,
        touched: true
      });
    }
  }
  _applyStateDiff() {
    for (const stateEntry of this.stateMap) {
      const klass = stateEntry[0];
      const state = stateEntry[1];
      if (state.changed) {
        this._toggleClass(klass, state.enabled);
        state.changed = false;
      } else if (!state.touched) {
        if (state.enabled) {
          this._toggleClass(klass, false);
        }
        this.stateMap.delete(klass);
      }
      state.touched = false;
    }
  }
  _toggleClass(klass, enabled) {
    if (ngDevMode) {
      if (typeof klass !== "string") {
        throw new Error(`NgClass can only toggle CSS classes expressed as strings, got ${stringify(klass)}`);
      }
    }
    klass = klass.trim();
    if (klass.length > 0) {
      klass.split(WS_REGEXP).forEach((klass2) => {
        if (enabled) {
          this._renderer.addClass(this._ngEl.nativeElement, klass2);
        } else {
          this._renderer.removeClass(this._ngEl.nativeElement, klass2);
        }
      });
    }
  }
  static {
    this.ɵfac = function NgClass_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _NgClass)(ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(Renderer2));
    };
  }
  static {
    this.ɵdir = ɵɵdefineDirective({
      type: _NgClass,
      selectors: [["", "ngClass", ""]],
      inputs: {
        klass: [0, "class", "klass"],
        ngClass: "ngClass"
      },
      standalone: true
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NgClass, [{
    type: Directive,
    args: [{
      selector: "[ngClass]",
      standalone: true
    }]
  }], () => [{
    type: ElementRef
  }, {
    type: Renderer2
  }], {
    klass: [{
      type: Input,
      args: ["class"]
    }],
    ngClass: [{
      type: Input,
      args: ["ngClass"]
    }]
  });
})();
var NgComponentOutlet = class _NgComponentOutlet {
  constructor(_viewContainerRef) {
    this._viewContainerRef = _viewContainerRef;
    this.ngComponentOutlet = null;
    this._inputsUsed = /* @__PURE__ */ new Map();
  }
  _needToReCreateNgModuleInstance(changes) {
    return changes["ngComponentOutletNgModule"] !== void 0 || changes["ngComponentOutletNgModuleFactory"] !== void 0;
  }
  _needToReCreateComponentInstance(changes) {
    return changes["ngComponentOutlet"] !== void 0 || changes["ngComponentOutletContent"] !== void 0 || changes["ngComponentOutletInjector"] !== void 0 || this._needToReCreateNgModuleInstance(changes);
  }
  /** @nodoc */
  ngOnChanges(changes) {
    if (this._needToReCreateComponentInstance(changes)) {
      this._viewContainerRef.clear();
      this._inputsUsed.clear();
      this._componentRef = void 0;
      if (this.ngComponentOutlet) {
        const injector = this.ngComponentOutletInjector || this._viewContainerRef.parentInjector;
        if (this._needToReCreateNgModuleInstance(changes)) {
          this._moduleRef?.destroy();
          if (this.ngComponentOutletNgModule) {
            this._moduleRef = createNgModule(this.ngComponentOutletNgModule, getParentInjector(injector));
          } else if (this.ngComponentOutletNgModuleFactory) {
            this._moduleRef = this.ngComponentOutletNgModuleFactory.create(getParentInjector(injector));
          } else {
            this._moduleRef = void 0;
          }
        }
        this._componentRef = this._viewContainerRef.createComponent(this.ngComponentOutlet, {
          injector,
          ngModuleRef: this._moduleRef,
          projectableNodes: this.ngComponentOutletContent
        });
      }
    }
  }
  /** @nodoc */
  ngDoCheck() {
    if (this._componentRef) {
      if (this.ngComponentOutletInputs) {
        for (const inputName of Object.keys(this.ngComponentOutletInputs)) {
          this._inputsUsed.set(inputName, true);
        }
      }
      this._applyInputStateDiff(this._componentRef);
    }
  }
  /** @nodoc */
  ngOnDestroy() {
    this._moduleRef?.destroy();
  }
  _applyInputStateDiff(componentRef) {
    for (const [inputName, touched] of this._inputsUsed) {
      if (!touched) {
        componentRef.setInput(inputName, void 0);
        this._inputsUsed.delete(inputName);
      } else {
        componentRef.setInput(inputName, this.ngComponentOutletInputs[inputName]);
        this._inputsUsed.set(inputName, false);
      }
    }
  }
  static {
    this.ɵfac = function NgComponentOutlet_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _NgComponentOutlet)(ɵɵdirectiveInject(ViewContainerRef));
    };
  }
  static {
    this.ɵdir = ɵɵdefineDirective({
      type: _NgComponentOutlet,
      selectors: [["", "ngComponentOutlet", ""]],
      inputs: {
        ngComponentOutlet: "ngComponentOutlet",
        ngComponentOutletInputs: "ngComponentOutletInputs",
        ngComponentOutletInjector: "ngComponentOutletInjector",
        ngComponentOutletContent: "ngComponentOutletContent",
        ngComponentOutletNgModule: "ngComponentOutletNgModule",
        ngComponentOutletNgModuleFactory: "ngComponentOutletNgModuleFactory"
      },
      standalone: true,
      features: [ɵɵNgOnChangesFeature]
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NgComponentOutlet, [{
    type: Directive,
    args: [{
      selector: "[ngComponentOutlet]",
      standalone: true
    }]
  }], () => [{
    type: ViewContainerRef
  }], {
    ngComponentOutlet: [{
      type: Input
    }],
    ngComponentOutletInputs: [{
      type: Input
    }],
    ngComponentOutletInjector: [{
      type: Input
    }],
    ngComponentOutletContent: [{
      type: Input
    }],
    ngComponentOutletNgModule: [{
      type: Input
    }],
    ngComponentOutletNgModuleFactory: [{
      type: Input
    }]
  });
})();
function getParentInjector(injector) {
  const parentNgModule = injector.get(NgModuleRef$1);
  return parentNgModule.injector;
}
var NgForOfContext = class {
  constructor($implicit, ngForOf, index, count) {
    this.$implicit = $implicit;
    this.ngForOf = ngForOf;
    this.index = index;
    this.count = count;
  }
  get first() {
    return this.index === 0;
  }
  get last() {
    return this.index === this.count - 1;
  }
  get even() {
    return this.index % 2 === 0;
  }
  get odd() {
    return !this.even;
  }
};
var NgForOf = class _NgForOf {
  /**
   * The value of the iterable expression, which can be used as a
   * [template input variable](guide/directives/structural-directives#shorthand).
   */
  set ngForOf(ngForOf) {
    this._ngForOf = ngForOf;
    this._ngForOfDirty = true;
  }
  /**
   * Specifies a custom `TrackByFunction` to compute the identity of items in an iterable.
   *
   * If a custom `TrackByFunction` is not provided, `NgForOf` will use the item's [object
   * identity](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is)
   * as the key.
   *
   * `NgForOf` uses the computed key to associate items in an iterable with DOM elements
   * it produces for these items.
   *
   * A custom `TrackByFunction` is useful to provide good user experience in cases when items in an
   * iterable rendered using `NgForOf` have a natural identifier (for example, custom ID or a
   * primary key), and this iterable could be updated with new object instances that still
   * represent the same underlying entity (for example, when data is re-fetched from the server,
   * and the iterable is recreated and re-rendered, but most of the data is still the same).
   *
   * @see {@link TrackByFunction}
   */
  set ngForTrackBy(fn) {
    if ((typeof ngDevMode === "undefined" || ngDevMode) && fn != null && typeof fn !== "function") {
      console.warn(`trackBy must be a function, but received ${JSON.stringify(fn)}. See https://angular.io/api/common/NgForOf#change-propagation for more information.`);
    }
    this._trackByFn = fn;
  }
  get ngForTrackBy() {
    return this._trackByFn;
  }
  constructor(_viewContainer, _template, _differs) {
    this._viewContainer = _viewContainer;
    this._template = _template;
    this._differs = _differs;
    this._ngForOf = null;
    this._ngForOfDirty = true;
    this._differ = null;
  }
  /**
   * A reference to the template that is stamped out for each item in the iterable.
   * @see [template reference variable](guide/templates/reference-variables)
   */
  set ngForTemplate(value) {
    if (value) {
      this._template = value;
    }
  }
  /**
   * Applies the changes when needed.
   * @nodoc
   */
  ngDoCheck() {
    if (this._ngForOfDirty) {
      this._ngForOfDirty = false;
      const value = this._ngForOf;
      if (!this._differ && value) {
        if (typeof ngDevMode === "undefined" || ngDevMode) {
          try {
            this._differ = this._differs.find(value).create(this.ngForTrackBy);
          } catch {
            let errorMessage = `Cannot find a differ supporting object '${value}' of type '${getTypeName(value)}'. NgFor only supports binding to Iterables, such as Arrays.`;
            if (typeof value === "object") {
              errorMessage += " Did you mean to use the keyvalue pipe?";
            }
            throw new RuntimeError(-2200, errorMessage);
          }
        } else {
          this._differ = this._differs.find(value).create(this.ngForTrackBy);
        }
      }
    }
    if (this._differ) {
      const changes = this._differ.diff(this._ngForOf);
      if (changes) this._applyChanges(changes);
    }
  }
  _applyChanges(changes) {
    const viewContainer = this._viewContainer;
    changes.forEachOperation((item, adjustedPreviousIndex, currentIndex) => {
      if (item.previousIndex == null) {
        viewContainer.createEmbeddedView(this._template, new NgForOfContext(item.item, this._ngForOf, -1, -1), currentIndex === null ? void 0 : currentIndex);
      } else if (currentIndex == null) {
        viewContainer.remove(adjustedPreviousIndex === null ? void 0 : adjustedPreviousIndex);
      } else if (adjustedPreviousIndex !== null) {
        const view = viewContainer.get(adjustedPreviousIndex);
        viewContainer.move(view, currentIndex);
        applyViewChange(view, item);
      }
    });
    for (let i = 0, ilen = viewContainer.length; i < ilen; i++) {
      const viewRef = viewContainer.get(i);
      const context = viewRef.context;
      context.index = i;
      context.count = ilen;
      context.ngForOf = this._ngForOf;
    }
    changes.forEachIdentityChange((record) => {
      const viewRef = viewContainer.get(record.currentIndex);
      applyViewChange(viewRef, record);
    });
  }
  /**
   * Asserts the correct type of the context for the template that `NgForOf` will render.
   *
   * The presence of this method is a signal to the Ivy template type-check compiler that the
   * `NgForOf` structural directive renders its template with a specific context type.
   */
  static ngTemplateContextGuard(dir, ctx) {
    return true;
  }
  static {
    this.ɵfac = function NgForOf_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _NgForOf)(ɵɵdirectiveInject(ViewContainerRef), ɵɵdirectiveInject(TemplateRef), ɵɵdirectiveInject(IterableDiffers));
    };
  }
  static {
    this.ɵdir = ɵɵdefineDirective({
      type: _NgForOf,
      selectors: [["", "ngFor", "", "ngForOf", ""]],
      inputs: {
        ngForOf: "ngForOf",
        ngForTrackBy: "ngForTrackBy",
        ngForTemplate: "ngForTemplate"
      },
      standalone: true
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NgForOf, [{
    type: Directive,
    args: [{
      selector: "[ngFor][ngForOf]",
      standalone: true
    }]
  }], () => [{
    type: ViewContainerRef
  }, {
    type: TemplateRef
  }, {
    type: IterableDiffers
  }], {
    ngForOf: [{
      type: Input
    }],
    ngForTrackBy: [{
      type: Input
    }],
    ngForTemplate: [{
      type: Input
    }]
  });
})();
function applyViewChange(view, record) {
  view.context.$implicit = record.item;
}
function getTypeName(type) {
  return type["name"] || typeof type;
}
var NgIf = class _NgIf {
  constructor(_viewContainer, templateRef) {
    this._viewContainer = _viewContainer;
    this._context = new NgIfContext();
    this._thenTemplateRef = null;
    this._elseTemplateRef = null;
    this._thenViewRef = null;
    this._elseViewRef = null;
    this._thenTemplateRef = templateRef;
  }
  /**
   * The Boolean expression to evaluate as the condition for showing a template.
   */
  set ngIf(condition) {
    this._context.$implicit = this._context.ngIf = condition;
    this._updateView();
  }
  /**
   * A template to show if the condition expression evaluates to true.
   */
  set ngIfThen(templateRef) {
    assertTemplate("ngIfThen", templateRef);
    this._thenTemplateRef = templateRef;
    this._thenViewRef = null;
    this._updateView();
  }
  /**
   * A template to show if the condition expression evaluates to false.
   */
  set ngIfElse(templateRef) {
    assertTemplate("ngIfElse", templateRef);
    this._elseTemplateRef = templateRef;
    this._elseViewRef = null;
    this._updateView();
  }
  _updateView() {
    if (this._context.$implicit) {
      if (!this._thenViewRef) {
        this._viewContainer.clear();
        this._elseViewRef = null;
        if (this._thenTemplateRef) {
          this._thenViewRef = this._viewContainer.createEmbeddedView(this._thenTemplateRef, this._context);
        }
      }
    } else {
      if (!this._elseViewRef) {
        this._viewContainer.clear();
        this._thenViewRef = null;
        if (this._elseTemplateRef) {
          this._elseViewRef = this._viewContainer.createEmbeddedView(this._elseTemplateRef, this._context);
        }
      }
    }
  }
  /**
   * Asserts the correct type of the context for the template that `NgIf` will render.
   *
   * The presence of this method is a signal to the Ivy template type-check compiler that the
   * `NgIf` structural directive renders its template with a specific context type.
   */
  static ngTemplateContextGuard(dir, ctx) {
    return true;
  }
  static {
    this.ɵfac = function NgIf_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _NgIf)(ɵɵdirectiveInject(ViewContainerRef), ɵɵdirectiveInject(TemplateRef));
    };
  }
  static {
    this.ɵdir = ɵɵdefineDirective({
      type: _NgIf,
      selectors: [["", "ngIf", ""]],
      inputs: {
        ngIf: "ngIf",
        ngIfThen: "ngIfThen",
        ngIfElse: "ngIfElse"
      },
      standalone: true
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NgIf, [{
    type: Directive,
    args: [{
      selector: "[ngIf]",
      standalone: true
    }]
  }], () => [{
    type: ViewContainerRef
  }, {
    type: TemplateRef
  }], {
    ngIf: [{
      type: Input
    }],
    ngIfThen: [{
      type: Input
    }],
    ngIfElse: [{
      type: Input
    }]
  });
})();
var NgIfContext = class {
  constructor() {
    this.$implicit = null;
    this.ngIf = null;
  }
};
function assertTemplate(property, templateRef) {
  const isTemplateRefOrNull = !!(!templateRef || templateRef.createEmbeddedView);
  if (!isTemplateRefOrNull) {
    throw new Error(`${property} must be a TemplateRef, but received '${stringify(templateRef)}'.`);
  }
}
var SwitchView = class {
  constructor(_viewContainerRef, _templateRef) {
    this._viewContainerRef = _viewContainerRef;
    this._templateRef = _templateRef;
    this._created = false;
  }
  create() {
    this._created = true;
    this._viewContainerRef.createEmbeddedView(this._templateRef);
  }
  destroy() {
    this._created = false;
    this._viewContainerRef.clear();
  }
  enforceState(created) {
    if (created && !this._created) {
      this.create();
    } else if (!created && this._created) {
      this.destroy();
    }
  }
};
var NgSwitch = class _NgSwitch {
  constructor() {
    this._defaultViews = [];
    this._defaultUsed = false;
    this._caseCount = 0;
    this._lastCaseCheckIndex = 0;
    this._lastCasesMatched = false;
  }
  set ngSwitch(newValue) {
    this._ngSwitch = newValue;
    if (this._caseCount === 0) {
      this._updateDefaultCases(true);
    }
  }
  /** @internal */
  _addCase() {
    return this._caseCount++;
  }
  /** @internal */
  _addDefault(view) {
    this._defaultViews.push(view);
  }
  /** @internal */
  _matchCase(value) {
    const matched = value === this._ngSwitch;
    this._lastCasesMatched ||= matched;
    this._lastCaseCheckIndex++;
    if (this._lastCaseCheckIndex === this._caseCount) {
      this._updateDefaultCases(!this._lastCasesMatched);
      this._lastCaseCheckIndex = 0;
      this._lastCasesMatched = false;
    }
    return matched;
  }
  _updateDefaultCases(useDefault) {
    if (this._defaultViews.length > 0 && useDefault !== this._defaultUsed) {
      this._defaultUsed = useDefault;
      for (const defaultView of this._defaultViews) {
        defaultView.enforceState(useDefault);
      }
    }
  }
  static {
    this.ɵfac = function NgSwitch_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _NgSwitch)();
    };
  }
  static {
    this.ɵdir = ɵɵdefineDirective({
      type: _NgSwitch,
      selectors: [["", "ngSwitch", ""]],
      inputs: {
        ngSwitch: "ngSwitch"
      },
      standalone: true
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NgSwitch, [{
    type: Directive,
    args: [{
      selector: "[ngSwitch]",
      standalone: true
    }]
  }], null, {
    ngSwitch: [{
      type: Input
    }]
  });
})();
var NgSwitchCase = class _NgSwitchCase {
  constructor(viewContainer, templateRef, ngSwitch) {
    this.ngSwitch = ngSwitch;
    if ((typeof ngDevMode === "undefined" || ngDevMode) && !ngSwitch) {
      throwNgSwitchProviderNotFoundError("ngSwitchCase", "NgSwitchCase");
    }
    ngSwitch._addCase();
    this._view = new SwitchView(viewContainer, templateRef);
  }
  /**
   * Performs case matching. For internal use only.
   * @nodoc
   */
  ngDoCheck() {
    this._view.enforceState(this.ngSwitch._matchCase(this.ngSwitchCase));
  }
  static {
    this.ɵfac = function NgSwitchCase_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _NgSwitchCase)(ɵɵdirectiveInject(ViewContainerRef), ɵɵdirectiveInject(TemplateRef), ɵɵdirectiveInject(NgSwitch, 9));
    };
  }
  static {
    this.ɵdir = ɵɵdefineDirective({
      type: _NgSwitchCase,
      selectors: [["", "ngSwitchCase", ""]],
      inputs: {
        ngSwitchCase: "ngSwitchCase"
      },
      standalone: true
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NgSwitchCase, [{
    type: Directive,
    args: [{
      selector: "[ngSwitchCase]",
      standalone: true
    }]
  }], () => [{
    type: ViewContainerRef
  }, {
    type: TemplateRef
  }, {
    type: NgSwitch,
    decorators: [{
      type: Optional
    }, {
      type: Host
    }]
  }], {
    ngSwitchCase: [{
      type: Input
    }]
  });
})();
var NgSwitchDefault = class _NgSwitchDefault {
  constructor(viewContainer, templateRef, ngSwitch) {
    if ((typeof ngDevMode === "undefined" || ngDevMode) && !ngSwitch) {
      throwNgSwitchProviderNotFoundError("ngSwitchDefault", "NgSwitchDefault");
    }
    ngSwitch._addDefault(new SwitchView(viewContainer, templateRef));
  }
  static {
    this.ɵfac = function NgSwitchDefault_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _NgSwitchDefault)(ɵɵdirectiveInject(ViewContainerRef), ɵɵdirectiveInject(TemplateRef), ɵɵdirectiveInject(NgSwitch, 9));
    };
  }
  static {
    this.ɵdir = ɵɵdefineDirective({
      type: _NgSwitchDefault,
      selectors: [["", "ngSwitchDefault", ""]],
      standalone: true
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NgSwitchDefault, [{
    type: Directive,
    args: [{
      selector: "[ngSwitchDefault]",
      standalone: true
    }]
  }], () => [{
    type: ViewContainerRef
  }, {
    type: TemplateRef
  }, {
    type: NgSwitch,
    decorators: [{
      type: Optional
    }, {
      type: Host
    }]
  }], null);
})();
function throwNgSwitchProviderNotFoundError(attrName, directiveName) {
  throw new RuntimeError(2e3, `An element with the "${attrName}" attribute (matching the "${directiveName}" directive) must be located inside an element with the "ngSwitch" attribute (matching "NgSwitch" directive)`);
}
var NgPlural = class _NgPlural {
  constructor(_localization) {
    this._localization = _localization;
    this._caseViews = {};
  }
  set ngPlural(value) {
    this._updateView(value);
  }
  addCase(value, switchView) {
    this._caseViews[value] = switchView;
  }
  _updateView(switchValue) {
    this._clearViews();
    const cases = Object.keys(this._caseViews);
    const key = getPluralCategory(switchValue, cases, this._localization);
    this._activateView(this._caseViews[key]);
  }
  _clearViews() {
    if (this._activeView) this._activeView.destroy();
  }
  _activateView(view) {
    if (view) {
      this._activeView = view;
      this._activeView.create();
    }
  }
  static {
    this.ɵfac = function NgPlural_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _NgPlural)(ɵɵdirectiveInject(NgLocalization));
    };
  }
  static {
    this.ɵdir = ɵɵdefineDirective({
      type: _NgPlural,
      selectors: [["", "ngPlural", ""]],
      inputs: {
        ngPlural: "ngPlural"
      },
      standalone: true
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NgPlural, [{
    type: Directive,
    args: [{
      selector: "[ngPlural]",
      standalone: true
    }]
  }], () => [{
    type: NgLocalization
  }], {
    ngPlural: [{
      type: Input
    }]
  });
})();
var NgPluralCase = class _NgPluralCase {
  constructor(value, template, viewContainer, ngPlural) {
    this.value = value;
    const isANumber = !isNaN(Number(value));
    ngPlural.addCase(isANumber ? `=${value}` : value, new SwitchView(viewContainer, template));
  }
  static {
    this.ɵfac = function NgPluralCase_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _NgPluralCase)(ɵɵinjectAttribute("ngPluralCase"), ɵɵdirectiveInject(TemplateRef), ɵɵdirectiveInject(ViewContainerRef), ɵɵdirectiveInject(NgPlural, 1));
    };
  }
  static {
    this.ɵdir = ɵɵdefineDirective({
      type: _NgPluralCase,
      selectors: [["", "ngPluralCase", ""]],
      standalone: true
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NgPluralCase, [{
    type: Directive,
    args: [{
      selector: "[ngPluralCase]",
      standalone: true
    }]
  }], () => [{
    type: void 0,
    decorators: [{
      type: Attribute,
      args: ["ngPluralCase"]
    }]
  }, {
    type: TemplateRef
  }, {
    type: ViewContainerRef
  }, {
    type: NgPlural,
    decorators: [{
      type: Host
    }]
  }], null);
})();
var NgStyle = class _NgStyle {
  constructor(_ngEl, _differs, _renderer) {
    this._ngEl = _ngEl;
    this._differs = _differs;
    this._renderer = _renderer;
    this._ngStyle = null;
    this._differ = null;
  }
  set ngStyle(values) {
    this._ngStyle = values;
    if (!this._differ && values) {
      this._differ = this._differs.find(values).create();
    }
  }
  ngDoCheck() {
    if (this._differ) {
      const changes = this._differ.diff(this._ngStyle);
      if (changes) {
        this._applyChanges(changes);
      }
    }
  }
  _setStyle(nameAndUnit, value) {
    const [name, unit] = nameAndUnit.split(".");
    const flags = name.indexOf("-") === -1 ? void 0 : RendererStyleFlags2.DashCase;
    if (value != null) {
      this._renderer.setStyle(this._ngEl.nativeElement, name, unit ? `${value}${unit}` : value, flags);
    } else {
      this._renderer.removeStyle(this._ngEl.nativeElement, name, flags);
    }
  }
  _applyChanges(changes) {
    changes.forEachRemovedItem((record) => this._setStyle(record.key, null));
    changes.forEachAddedItem((record) => this._setStyle(record.key, record.currentValue));
    changes.forEachChangedItem((record) => this._setStyle(record.key, record.currentValue));
  }
  static {
    this.ɵfac = function NgStyle_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _NgStyle)(ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(KeyValueDiffers), ɵɵdirectiveInject(Renderer2));
    };
  }
  static {
    this.ɵdir = ɵɵdefineDirective({
      type: _NgStyle,
      selectors: [["", "ngStyle", ""]],
      inputs: {
        ngStyle: "ngStyle"
      },
      standalone: true
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NgStyle, [{
    type: Directive,
    args: [{
      selector: "[ngStyle]",
      standalone: true
    }]
  }], () => [{
    type: ElementRef
  }, {
    type: KeyValueDiffers
  }, {
    type: Renderer2
  }], {
    ngStyle: [{
      type: Input,
      args: ["ngStyle"]
    }]
  });
})();
var NgTemplateOutlet = class _NgTemplateOutlet {
  constructor(_viewContainerRef) {
    this._viewContainerRef = _viewContainerRef;
    this._viewRef = null;
    this.ngTemplateOutletContext = null;
    this.ngTemplateOutlet = null;
    this.ngTemplateOutletInjector = null;
  }
  ngOnChanges(changes) {
    if (this._shouldRecreateView(changes)) {
      const viewContainerRef = this._viewContainerRef;
      if (this._viewRef) {
        viewContainerRef.remove(viewContainerRef.indexOf(this._viewRef));
      }
      if (!this.ngTemplateOutlet) {
        this._viewRef = null;
        return;
      }
      const viewContext = this._createContextForwardProxy();
      this._viewRef = viewContainerRef.createEmbeddedView(this.ngTemplateOutlet, viewContext, {
        injector: this.ngTemplateOutletInjector ?? void 0
      });
    }
  }
  /**
   * We need to re-create existing embedded view if either is true:
   * - the outlet changed.
   * - the injector changed.
   */
  _shouldRecreateView(changes) {
    return !!changes["ngTemplateOutlet"] || !!changes["ngTemplateOutletInjector"];
  }
  /**
   * For a given outlet instance, we create a proxy object that delegates
   * to the user-specified context. This allows changing, or swapping out
   * the context object completely without having to destroy/re-create the view.
   */
  _createContextForwardProxy() {
    return new Proxy({}, {
      set: (_target, prop, newValue) => {
        if (!this.ngTemplateOutletContext) {
          return false;
        }
        return Reflect.set(this.ngTemplateOutletContext, prop, newValue);
      },
      get: (_target, prop, receiver) => {
        if (!this.ngTemplateOutletContext) {
          return void 0;
        }
        return Reflect.get(this.ngTemplateOutletContext, prop, receiver);
      }
    });
  }
  static {
    this.ɵfac = function NgTemplateOutlet_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _NgTemplateOutlet)(ɵɵdirectiveInject(ViewContainerRef));
    };
  }
  static {
    this.ɵdir = ɵɵdefineDirective({
      type: _NgTemplateOutlet,
      selectors: [["", "ngTemplateOutlet", ""]],
      inputs: {
        ngTemplateOutletContext: "ngTemplateOutletContext",
        ngTemplateOutlet: "ngTemplateOutlet",
        ngTemplateOutletInjector: "ngTemplateOutletInjector"
      },
      standalone: true,
      features: [ɵɵNgOnChangesFeature]
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NgTemplateOutlet, [{
    type: Directive,
    args: [{
      selector: "[ngTemplateOutlet]",
      standalone: true
    }]
  }], () => [{
    type: ViewContainerRef
  }], {
    ngTemplateOutletContext: [{
      type: Input
    }],
    ngTemplateOutlet: [{
      type: Input
    }],
    ngTemplateOutletInjector: [{
      type: Input
    }]
  });
})();
var COMMON_DIRECTIVES = [NgClass, NgComponentOutlet, NgForOf, NgIf, NgTemplateOutlet, NgStyle, NgSwitch, NgSwitchCase, NgSwitchDefault, NgPlural, NgPluralCase];
function invalidPipeArgumentError(type, value) {
  return new RuntimeError(2100, ngDevMode && `InvalidPipeArgument: '${value}' for pipe '${stringify(type)}'`);
}
var SubscribableStrategy = class {
  createSubscription(async, updateLatestValue) {
    return untracked(() => async.subscribe({
      next: updateLatestValue,
      error: (e) => {
        throw e;
      }
    }));
  }
  dispose(subscription) {
    untracked(() => subscription.unsubscribe());
  }
};
var PromiseStrategy = class {
  createSubscription(async, updateLatestValue) {
    return async.then(updateLatestValue, (e) => {
      throw e;
    });
  }
  dispose(subscription) {
  }
};
var _promiseStrategy = new PromiseStrategy();
var _subscribableStrategy = new SubscribableStrategy();
var AsyncPipe = class _AsyncPipe {
  constructor(ref) {
    this._latestValue = null;
    this.markForCheckOnValueUpdate = true;
    this._subscription = null;
    this._obj = null;
    this._strategy = null;
    this._ref = ref;
  }
  ngOnDestroy() {
    if (this._subscription) {
      this._dispose();
    }
    this._ref = null;
  }
  transform(obj) {
    if (!this._obj) {
      if (obj) {
        try {
          this.markForCheckOnValueUpdate = false;
          this._subscribe(obj);
        } finally {
          this.markForCheckOnValueUpdate = true;
        }
      }
      return this._latestValue;
    }
    if (obj !== this._obj) {
      this._dispose();
      return this.transform(obj);
    }
    return this._latestValue;
  }
  _subscribe(obj) {
    this._obj = obj;
    this._strategy = this._selectStrategy(obj);
    this._subscription = this._strategy.createSubscription(obj, (value) => this._updateLatestValue(obj, value));
  }
  _selectStrategy(obj) {
    if (isPromise(obj)) {
      return _promiseStrategy;
    }
    if (isSubscribable(obj)) {
      return _subscribableStrategy;
    }
    throw invalidPipeArgumentError(_AsyncPipe, obj);
  }
  _dispose() {
    this._strategy.dispose(this._subscription);
    this._latestValue = null;
    this._subscription = null;
    this._obj = null;
  }
  _updateLatestValue(async, value) {
    if (async === this._obj) {
      this._latestValue = value;
      if (this.markForCheckOnValueUpdate) {
        this._ref?.markForCheck();
      }
    }
  }
  static {
    this.ɵfac = function AsyncPipe_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _AsyncPipe)(ɵɵdirectiveInject(ChangeDetectorRef, 16));
    };
  }
  static {
    this.ɵpipe = ɵɵdefinePipe({
      name: "async",
      type: _AsyncPipe,
      pure: false,
      standalone: true
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(AsyncPipe, [{
    type: Pipe,
    args: [{
      name: "async",
      pure: false,
      standalone: true
    }]
  }], () => [{
    type: ChangeDetectorRef
  }], null);
})();
var LowerCasePipe = class _LowerCasePipe {
  transform(value) {
    if (value == null) return null;
    if (typeof value !== "string") {
      throw invalidPipeArgumentError(_LowerCasePipe, value);
    }
    return value.toLowerCase();
  }
  static {
    this.ɵfac = function LowerCasePipe_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _LowerCasePipe)();
    };
  }
  static {
    this.ɵpipe = ɵɵdefinePipe({
      name: "lowercase",
      type: _LowerCasePipe,
      pure: true,
      standalone: true
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(LowerCasePipe, [{
    type: Pipe,
    args: [{
      name: "lowercase",
      standalone: true
    }]
  }], null, null);
})();
var unicodeWordMatch = /(?:[0-9A-Za-z\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0560-\u0588\u05D0-\u05EA\u05EF-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u0860-\u086A\u0870-\u0887\u0889-\u088E\u08A0-\u08C9\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u09FC\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C5D\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D04-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E86-\u0E8A\u0E8C-\u0EA3\u0EA5\u0EA7-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16F1-\u16F8\u1700-\u1711\u171F-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1878\u1880-\u1884\u1887-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4C\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1C90-\u1CBA\u1CBD-\u1CBF\u1CE9-\u1CEC\u1CEE-\u1CF3\u1CF5\u1CF6\u1CFA\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2183\u2184\u2C00-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005\u3006\u3031-\u3035\u303B\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312F\u3131-\u318E\u31A0-\u31BF\u31F0-\u31FF\u3400-\u4DBF\u4E00-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6E5\uA717-\uA71F\uA722-\uA788\uA78B-\uA7CA\uA7D0\uA7D1\uA7D3\uA7D5-\uA7D9\uA7F2-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA8FE\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB69\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF2D-\uDF40\uDF42-\uDF49\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF]|\uD801[\uDC00-\uDC9D\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDD70-\uDD7A\uDD7C-\uDD8A\uDD8C-\uDD92\uDD94\uDD95\uDD97-\uDDA1\uDDA3-\uDDB1\uDDB3-\uDDB9\uDDBB\uDDBC\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67\uDF80-\uDF85\uDF87-\uDFB0\uDFB2-\uDFBA]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE35\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2\uDD00-\uDD23\uDE80-\uDEA9\uDEB0\uDEB1\uDF00-\uDF1C\uDF27\uDF30-\uDF45\uDF70-\uDF81\uDFB0-\uDFC4\uDFE0-\uDFF6]|\uD804[\uDC03-\uDC37\uDC71\uDC72\uDC75\uDC83-\uDCAF\uDCD0-\uDCE8\uDD03-\uDD26\uDD44\uDD47\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE2B\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEDE\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF50\uDF5D-\uDF61]|\uD805[\uDC00-\uDC34\uDC47-\uDC4A\uDC5F-\uDC61\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDD80-\uDDAE\uDDD8-\uDDDB\uDE00-\uDE2F\uDE44\uDE80-\uDEAA\uDEB8\uDF00-\uDF1A\uDF40-\uDF46]|\uD806[\uDC00-\uDC2B\uDCA0-\uDCDF\uDCFF-\uDD06\uDD09\uDD0C-\uDD13\uDD15\uDD16\uDD18-\uDD2F\uDD3F\uDD41\uDDA0-\uDDA7\uDDAA-\uDDD0\uDDE1\uDDE3\uDE00\uDE0B-\uDE32\uDE3A\uDE50\uDE5C-\uDE89\uDE9D\uDEB0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC2E\uDC40\uDC72-\uDC8F\uDD00-\uDD06\uDD08\uDD09\uDD0B-\uDD30\uDD46\uDD60-\uDD65\uDD67\uDD68\uDD6A-\uDD89\uDD98\uDEE0-\uDEF2\uDFB0]|\uD808[\uDC00-\uDF99]|\uD809[\uDC80-\uDD43]|\uD80B[\uDF90-\uDFF0]|[\uD80C\uD81C-\uD820\uD822\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872\uD874-\uD879\uD880-\uD883][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDE70-\uDEBE\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDE40-\uDE7F\uDF00-\uDF4A\uDF50\uDF93-\uDF9F\uDFE0\uDFE1\uDFE3]|\uD821[\uDC00-\uDFF7]|\uD823[\uDC00-\uDCD5\uDD00-\uDD08]|\uD82B[\uDFF0-\uDFF3\uDFF5-\uDFFB\uDFFD\uDFFE]|\uD82C[\uDC00-\uDD22\uDD50-\uDD52\uDD64-\uDD67\uDD70-\uDEFB]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB]|\uD837[\uDF00-\uDF1E]|\uD838[\uDD00-\uDD2C\uDD37-\uDD3D\uDD4E\uDE90-\uDEAD\uDEC0-\uDEEB]|\uD839[\uDFE0-\uDFE6\uDFE8-\uDFEB\uDFED\uDFEE\uDFF0-\uDFFE]|\uD83A[\uDC00-\uDCC4\uDD00-\uDD43\uDD4B]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDEDF\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF38\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1\uDEB0-\uDFFF]|\uD87A[\uDC00-\uDFE0]|\uD87E[\uDC00-\uDE1D]|\uD884[\uDC00-\uDF4A])\S*/g;
var TitleCasePipe = class _TitleCasePipe {
  transform(value) {
    if (value == null) return null;
    if (typeof value !== "string") {
      throw invalidPipeArgumentError(_TitleCasePipe, value);
    }
    return value.replace(unicodeWordMatch, (txt) => txt[0].toUpperCase() + txt.slice(1).toLowerCase());
  }
  static {
    this.ɵfac = function TitleCasePipe_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _TitleCasePipe)();
    };
  }
  static {
    this.ɵpipe = ɵɵdefinePipe({
      name: "titlecase",
      type: _TitleCasePipe,
      pure: true,
      standalone: true
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(TitleCasePipe, [{
    type: Pipe,
    args: [{
      name: "titlecase",
      standalone: true
    }]
  }], null, null);
})();
var UpperCasePipe = class _UpperCasePipe {
  transform(value) {
    if (value == null) return null;
    if (typeof value !== "string") {
      throw invalidPipeArgumentError(_UpperCasePipe, value);
    }
    return value.toUpperCase();
  }
  static {
    this.ɵfac = function UpperCasePipe_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _UpperCasePipe)();
    };
  }
  static {
    this.ɵpipe = ɵɵdefinePipe({
      name: "uppercase",
      type: _UpperCasePipe,
      pure: true,
      standalone: true
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(UpperCasePipe, [{
    type: Pipe,
    args: [{
      name: "uppercase",
      standalone: true
    }]
  }], null, null);
})();
var DEFAULT_DATE_FORMAT = "mediumDate";
var DATE_PIPE_DEFAULT_TIMEZONE = new InjectionToken(ngDevMode ? "DATE_PIPE_DEFAULT_TIMEZONE" : "");
var DATE_PIPE_DEFAULT_OPTIONS = new InjectionToken(ngDevMode ? "DATE_PIPE_DEFAULT_OPTIONS" : "");
var DatePipe = class _DatePipe {
  constructor(locale, defaultTimezone, defaultOptions) {
    this.locale = locale;
    this.defaultTimezone = defaultTimezone;
    this.defaultOptions = defaultOptions;
  }
  transform(value, format, timezone, locale) {
    if (value == null || value === "" || value !== value) return null;
    try {
      const _format = format ?? this.defaultOptions?.dateFormat ?? DEFAULT_DATE_FORMAT;
      const _timezone = timezone ?? this.defaultOptions?.timezone ?? this.defaultTimezone ?? void 0;
      return formatDate(value, _format, locale || this.locale, _timezone);
    } catch (error) {
      throw invalidPipeArgumentError(_DatePipe, error.message);
    }
  }
  static {
    this.ɵfac = function DatePipe_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _DatePipe)(ɵɵdirectiveInject(LOCALE_ID, 16), ɵɵdirectiveInject(DATE_PIPE_DEFAULT_TIMEZONE, 24), ɵɵdirectiveInject(DATE_PIPE_DEFAULT_OPTIONS, 24));
    };
  }
  static {
    this.ɵpipe = ɵɵdefinePipe({
      name: "date",
      type: _DatePipe,
      pure: true,
      standalone: true
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DatePipe, [{
    type: Pipe,
    args: [{
      name: "date",
      standalone: true
    }]
  }], () => [{
    type: void 0,
    decorators: [{
      type: Inject,
      args: [LOCALE_ID]
    }]
  }, {
    type: void 0,
    decorators: [{
      type: Inject,
      args: [DATE_PIPE_DEFAULT_TIMEZONE]
    }, {
      type: Optional
    }]
  }, {
    type: void 0,
    decorators: [{
      type: Inject,
      args: [DATE_PIPE_DEFAULT_OPTIONS]
    }, {
      type: Optional
    }]
  }], null);
})();
var _INTERPOLATION_REGEXP = /#/g;
var I18nPluralPipe = class _I18nPluralPipe {
  constructor(_localization) {
    this._localization = _localization;
  }
  /**
   * @param value the number to be formatted
   * @param pluralMap an object that mimics the ICU format, see
   * https://unicode-org.github.io/icu/userguide/format_parse/messages/.
   * @param locale a `string` defining the locale to use (uses the current {@link LOCALE_ID} by
   * default).
   */
  transform(value, pluralMap, locale) {
    if (value == null) return "";
    if (typeof pluralMap !== "object" || pluralMap === null) {
      throw invalidPipeArgumentError(_I18nPluralPipe, pluralMap);
    }
    const key = getPluralCategory(value, Object.keys(pluralMap), this._localization, locale);
    return pluralMap[key].replace(_INTERPOLATION_REGEXP, value.toString());
  }
  static {
    this.ɵfac = function I18nPluralPipe_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _I18nPluralPipe)(ɵɵdirectiveInject(NgLocalization, 16));
    };
  }
  static {
    this.ɵpipe = ɵɵdefinePipe({
      name: "i18nPlural",
      type: _I18nPluralPipe,
      pure: true,
      standalone: true
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(I18nPluralPipe, [{
    type: Pipe,
    args: [{
      name: "i18nPlural",
      standalone: true
    }]
  }], () => [{
    type: NgLocalization
  }], null);
})();
var I18nSelectPipe = class _I18nSelectPipe {
  /**
   * @param value a string to be internationalized.
   * @param mapping an object that indicates the text that should be displayed
   * for different values of the provided `value`.
   */
  transform(value, mapping) {
    if (value == null) return "";
    if (typeof mapping !== "object" || typeof value !== "string") {
      throw invalidPipeArgumentError(_I18nSelectPipe, mapping);
    }
    if (mapping.hasOwnProperty(value)) {
      return mapping[value];
    }
    if (mapping.hasOwnProperty("other")) {
      return mapping["other"];
    }
    return "";
  }
  static {
    this.ɵfac = function I18nSelectPipe_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _I18nSelectPipe)();
    };
  }
  static {
    this.ɵpipe = ɵɵdefinePipe({
      name: "i18nSelect",
      type: _I18nSelectPipe,
      pure: true,
      standalone: true
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(I18nSelectPipe, [{
    type: Pipe,
    args: [{
      name: "i18nSelect",
      standalone: true
    }]
  }], null, null);
})();
var JsonPipe = class _JsonPipe {
  /**
   * @param value A value of any type to convert into a JSON-format string.
   */
  transform(value) {
    return JSON.stringify(value, null, 2);
  }
  static {
    this.ɵfac = function JsonPipe_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _JsonPipe)();
    };
  }
  static {
    this.ɵpipe = ɵɵdefinePipe({
      name: "json",
      type: _JsonPipe,
      pure: false,
      standalone: true
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(JsonPipe, [{
    type: Pipe,
    args: [{
      name: "json",
      pure: false,
      standalone: true
    }]
  }], null, null);
})();
function makeKeyValuePair(key, value) {
  return {
    key,
    value
  };
}
var KeyValuePipe = class _KeyValuePipe {
  constructor(differs) {
    this.differs = differs;
    this.keyValues = [];
    this.compareFn = defaultComparator;
  }
  transform(input, compareFn = defaultComparator) {
    if (!input || !(input instanceof Map) && typeof input !== "object") {
      return null;
    }
    this.differ ??= this.differs.find(input).create();
    const differChanges = this.differ.diff(input);
    const compareFnChanged = compareFn !== this.compareFn;
    if (differChanges) {
      this.keyValues = [];
      differChanges.forEachItem((r) => {
        this.keyValues.push(makeKeyValuePair(r.key, r.currentValue));
      });
    }
    if (differChanges || compareFnChanged) {
      this.keyValues.sort(compareFn);
      this.compareFn = compareFn;
    }
    return this.keyValues;
  }
  static {
    this.ɵfac = function KeyValuePipe_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _KeyValuePipe)(ɵɵdirectiveInject(KeyValueDiffers, 16));
    };
  }
  static {
    this.ɵpipe = ɵɵdefinePipe({
      name: "keyvalue",
      type: _KeyValuePipe,
      pure: false,
      standalone: true
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(KeyValuePipe, [{
    type: Pipe,
    args: [{
      name: "keyvalue",
      pure: false,
      standalone: true
    }]
  }], () => [{
    type: KeyValueDiffers
  }], null);
})();
function defaultComparator(keyValueA, keyValueB) {
  const a = keyValueA.key;
  const b = keyValueB.key;
  if (a === b) return 0;
  if (a === void 0) return 1;
  if (b === void 0) return -1;
  if (a === null) return 1;
  if (b === null) return -1;
  if (typeof a == "string" && typeof b == "string") {
    return a < b ? -1 : 1;
  }
  if (typeof a == "number" && typeof b == "number") {
    return a - b;
  }
  if (typeof a == "boolean" && typeof b == "boolean") {
    return a < b ? -1 : 1;
  }
  const aString = String(a);
  const bString = String(b);
  return aString == bString ? 0 : aString < bString ? -1 : 1;
}
var DecimalPipe = class _DecimalPipe {
  constructor(_locale) {
    this._locale = _locale;
  }
  /**
   * @param value The value to be formatted.
   * @param digitsInfo Sets digit and decimal representation.
   * [See more](#digitsinfo).
   * @param locale Specifies what locale format rules to use.
   * [See more](#locale).
   */
  transform(value, digitsInfo, locale) {
    if (!isValue(value)) return null;
    locale ||= this._locale;
    try {
      const num = strToNumber(value);
      return formatNumber(num, locale, digitsInfo);
    } catch (error) {
      throw invalidPipeArgumentError(_DecimalPipe, error.message);
    }
  }
  static {
    this.ɵfac = function DecimalPipe_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _DecimalPipe)(ɵɵdirectiveInject(LOCALE_ID, 16));
    };
  }
  static {
    this.ɵpipe = ɵɵdefinePipe({
      name: "number",
      type: _DecimalPipe,
      pure: true,
      standalone: true
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DecimalPipe, [{
    type: Pipe,
    args: [{
      name: "number",
      standalone: true
    }]
  }], () => [{
    type: void 0,
    decorators: [{
      type: Inject,
      args: [LOCALE_ID]
    }]
  }], null);
})();
var PercentPipe = class _PercentPipe {
  constructor(_locale) {
    this._locale = _locale;
  }
  /**
   *
   * @param value The number to be formatted as a percentage.
   * @param digitsInfo Decimal representation options, specified by a string
   * in the following format:<br>
   * <code>{minIntegerDigits}.{minFractionDigits}-{maxFractionDigits}</code>.
   *   - `minIntegerDigits`: The minimum number of integer digits before the decimal point.
   * Default is `1`.
   *   - `minFractionDigits`: The minimum number of digits after the decimal point.
   * Default is `0`.
   *   - `maxFractionDigits`: The maximum number of digits after the decimal point.
   * Default is `0`.
   * @param locale A locale code for the locale format rules to use.
   * When not supplied, uses the value of `LOCALE_ID`, which is `en-US` by default.
   * See [Setting your app locale](guide/i18n/locale-id).
   */
  transform(value, digitsInfo, locale) {
    if (!isValue(value)) return null;
    locale ||= this._locale;
    try {
      const num = strToNumber(value);
      return formatPercent(num, locale, digitsInfo);
    } catch (error) {
      throw invalidPipeArgumentError(_PercentPipe, error.message);
    }
  }
  static {
    this.ɵfac = function PercentPipe_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _PercentPipe)(ɵɵdirectiveInject(LOCALE_ID, 16));
    };
  }
  static {
    this.ɵpipe = ɵɵdefinePipe({
      name: "percent",
      type: _PercentPipe,
      pure: true,
      standalone: true
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PercentPipe, [{
    type: Pipe,
    args: [{
      name: "percent",
      standalone: true
    }]
  }], () => [{
    type: void 0,
    decorators: [{
      type: Inject,
      args: [LOCALE_ID]
    }]
  }], null);
})();
var CurrencyPipe = class _CurrencyPipe {
  constructor(_locale, _defaultCurrencyCode = "USD") {
    this._locale = _locale;
    this._defaultCurrencyCode = _defaultCurrencyCode;
  }
  /**
   *
   * @param value The number to be formatted as currency.
   * @param currencyCode The [ISO 4217](https://en.wikipedia.org/wiki/ISO_4217) currency code,
   * such as `USD` for the US dollar and `EUR` for the euro. The default currency code can be
   * configured using the `DEFAULT_CURRENCY_CODE` injection token.
   * @param display The format for the currency indicator. One of the following:
   *   - `code`: Show the code (such as `USD`).
   *   - `symbol`(default): Show the symbol (such as `$`).
   *   - `symbol-narrow`: Use the narrow symbol for locales that have two symbols for their
   * currency.
   * For example, the Canadian dollar CAD has the symbol `CA$` and the symbol-narrow `$`. If the
   * locale has no narrow symbol, uses the standard symbol for the locale.
   *   - String: Use the given string value instead of a code or a symbol.
   * For example, an empty string will suppress the currency & symbol.
   *   - Boolean (marked deprecated in v5): `true` for symbol and false for `code`.
   *
   * @param digitsInfo Decimal representation options, specified by a string
   * in the following format:<br>
   * <code>{minIntegerDigits}.{minFractionDigits}-{maxFractionDigits}</code>.
   *   - `minIntegerDigits`: The minimum number of integer digits before the decimal point.
   * Default is `1`.
   *   - `minFractionDigits`: The minimum number of digits after the decimal point.
   * Default is `2`.
   *   - `maxFractionDigits`: The maximum number of digits after the decimal point.
   * Default is `2`.
   * If not provided, the number will be formatted with the proper amount of digits,
   * depending on what the [ISO 4217](https://en.wikipedia.org/wiki/ISO_4217) specifies.
   * For example, the Canadian dollar has 2 digits, whereas the Chilean peso has none.
   * @param locale A locale code for the locale format rules to use.
   * When not supplied, uses the value of `LOCALE_ID`, which is `en-US` by default.
   * See [Setting your app locale](guide/i18n/locale-id).
   */
  transform(value, currencyCode = this._defaultCurrencyCode, display = "symbol", digitsInfo, locale) {
    if (!isValue(value)) return null;
    locale ||= this._locale;
    if (typeof display === "boolean") {
      if ((typeof ngDevMode === "undefined" || ngDevMode) && console && console.warn) {
        console.warn(`Warning: the currency pipe has been changed in Angular v5. The symbolDisplay option (third parameter) is now a string instead of a boolean. The accepted values are "code", "symbol" or "symbol-narrow".`);
      }
      display = display ? "symbol" : "code";
    }
    let currency = currencyCode || this._defaultCurrencyCode;
    if (display !== "code") {
      if (display === "symbol" || display === "symbol-narrow") {
        currency = getCurrencySymbol(currency, display === "symbol" ? "wide" : "narrow", locale);
      } else {
        currency = display;
      }
    }
    try {
      const num = strToNumber(value);
      return formatCurrency(num, locale, currency, currencyCode, digitsInfo);
    } catch (error) {
      throw invalidPipeArgumentError(_CurrencyPipe, error.message);
    }
  }
  static {
    this.ɵfac = function CurrencyPipe_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _CurrencyPipe)(ɵɵdirectiveInject(LOCALE_ID, 16), ɵɵdirectiveInject(DEFAULT_CURRENCY_CODE, 16));
    };
  }
  static {
    this.ɵpipe = ɵɵdefinePipe({
      name: "currency",
      type: _CurrencyPipe,
      pure: true,
      standalone: true
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CurrencyPipe, [{
    type: Pipe,
    args: [{
      name: "currency",
      standalone: true
    }]
  }], () => [{
    type: void 0,
    decorators: [{
      type: Inject,
      args: [LOCALE_ID]
    }]
  }, {
    type: void 0,
    decorators: [{
      type: Inject,
      args: [DEFAULT_CURRENCY_CODE]
    }]
  }], null);
})();
function isValue(value) {
  return !(value == null || value === "" || value !== value);
}
function strToNumber(value) {
  if (typeof value === "string" && !isNaN(Number(value) - parseFloat(value))) {
    return Number(value);
  }
  if (typeof value !== "number") {
    throw new Error(`${value} is not a number`);
  }
  return value;
}
var SlicePipe = class _SlicePipe {
  transform(value, start, end) {
    if (value == null) return null;
    if (!this.supports(value)) {
      throw invalidPipeArgumentError(_SlicePipe, value);
    }
    return value.slice(start, end);
  }
  supports(obj) {
    return typeof obj === "string" || Array.isArray(obj);
  }
  static {
    this.ɵfac = function SlicePipe_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _SlicePipe)();
    };
  }
  static {
    this.ɵpipe = ɵɵdefinePipe({
      name: "slice",
      type: _SlicePipe,
      pure: false,
      standalone: true
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(SlicePipe, [{
    type: Pipe,
    args: [{
      name: "slice",
      pure: false,
      standalone: true
    }]
  }], null, null);
})();
var COMMON_PIPES = [AsyncPipe, UpperCasePipe, LowerCasePipe, JsonPipe, SlicePipe, DecimalPipe, PercentPipe, TitleCasePipe, CurrencyPipe, DatePipe, I18nPluralPipe, I18nSelectPipe, KeyValuePipe];
var CommonModule = class _CommonModule {
  static {
    this.ɵfac = function CommonModule_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _CommonModule)();
    };
  }
  static {
    this.ɵmod = ɵɵdefineNgModule({
      type: _CommonModule,
      imports: [NgClass, NgComponentOutlet, NgForOf, NgIf, NgTemplateOutlet, NgStyle, NgSwitch, NgSwitchCase, NgSwitchDefault, NgPlural, NgPluralCase, AsyncPipe, UpperCasePipe, LowerCasePipe, JsonPipe, SlicePipe, DecimalPipe, PercentPipe, TitleCasePipe, CurrencyPipe, DatePipe, I18nPluralPipe, I18nSelectPipe, KeyValuePipe],
      exports: [NgClass, NgComponentOutlet, NgForOf, NgIf, NgTemplateOutlet, NgStyle, NgSwitch, NgSwitchCase, NgSwitchDefault, NgPlural, NgPluralCase, AsyncPipe, UpperCasePipe, LowerCasePipe, JsonPipe, SlicePipe, DecimalPipe, PercentPipe, TitleCasePipe, CurrencyPipe, DatePipe, I18nPluralPipe, I18nSelectPipe, KeyValuePipe]
    });
  }
  static {
    this.ɵinj = ɵɵdefineInjector({});
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CommonModule, [{
    type: NgModule,
    args: [{
      imports: [COMMON_DIRECTIVES, COMMON_PIPES],
      exports: [COMMON_DIRECTIVES, COMMON_PIPES]
    }]
  }], null, null);
})();
var PLATFORM_BROWSER_ID = "browser";
var PLATFORM_SERVER_ID = "server";
function isPlatformBrowser(platformId) {
  return platformId === PLATFORM_BROWSER_ID;
}
function isPlatformServer(platformId) {
  return platformId === PLATFORM_SERVER_ID;
}
var VERSION = new Version("18.2.0");
var ViewportScroller = class _ViewportScroller {
  static {
    this.ɵprov = ɵɵdefineInjectable({
      token: _ViewportScroller,
      providedIn: "root",
      factory: () => isPlatformBrowser(inject(PLATFORM_ID)) ? new BrowserViewportScroller(inject(DOCUMENT), window) : new NullViewportScroller()
    });
  }
};
var BrowserViewportScroller = class {
  constructor(document, window2) {
    this.document = document;
    this.window = window2;
    this.offset = () => [0, 0];
  }
  /**
   * Configures the top offset used when scrolling to an anchor.
   * @param offset A position in screen coordinates (a tuple with x and y values)
   * or a function that returns the top offset position.
   *
   */
  setOffset(offset) {
    if (Array.isArray(offset)) {
      this.offset = () => offset;
    } else {
      this.offset = offset;
    }
  }
  /**
   * Retrieves the current scroll position.
   * @returns The position in screen coordinates.
   */
  getScrollPosition() {
    return [this.window.scrollX, this.window.scrollY];
  }
  /**
   * Sets the scroll position.
   * @param position The new position in screen coordinates.
   */
  scrollToPosition(position) {
    this.window.scrollTo(position[0], position[1]);
  }
  /**
   * Scrolls to an element and attempts to focus the element.
   *
   * Note that the function name here is misleading in that the target string may be an ID for a
   * non-anchor element.
   *
   * @param target The ID of an element or name of the anchor.
   *
   * @see https://html.spec.whatwg.org/#the-indicated-part-of-the-document
   * @see https://html.spec.whatwg.org/#scroll-to-fragid
   */
  scrollToAnchor(target) {
    const elSelected = findAnchorFromDocument(this.document, target);
    if (elSelected) {
      this.scrollToElement(elSelected);
      elSelected.focus();
    }
  }
  /**
   * Disables automatic scroll restoration provided by the browser.
   */
  setHistoryScrollRestoration(scrollRestoration) {
    this.window.history.scrollRestoration = scrollRestoration;
  }
  /**
   * Scrolls to an element using the native offset and the specified offset set on this scroller.
   *
   * The offset can be used when we know that there is a floating header and scrolling naively to an
   * element (ex: `scrollIntoView`) leaves the element hidden behind the floating header.
   */
  scrollToElement(el) {
    const rect = el.getBoundingClientRect();
    const left = rect.left + this.window.pageXOffset;
    const top = rect.top + this.window.pageYOffset;
    const offset = this.offset();
    this.window.scrollTo(left - offset[0], top - offset[1]);
  }
};
function findAnchorFromDocument(document, target) {
  const documentResult = document.getElementById(target) || document.getElementsByName(target)[0];
  if (documentResult) {
    return documentResult;
  }
  if (typeof document.createTreeWalker === "function" && document.body && typeof document.body.attachShadow === "function") {
    const treeWalker = document.createTreeWalker(document.body, NodeFilter.SHOW_ELEMENT);
    let currentNode = treeWalker.currentNode;
    while (currentNode) {
      const shadowRoot = currentNode.shadowRoot;
      if (shadowRoot) {
        const result = shadowRoot.getElementById(target) || shadowRoot.querySelector(`[name="${target}"]`);
        if (result) {
          return result;
        }
      }
      currentNode = treeWalker.nextNode();
    }
  }
  return null;
}
var NullViewportScroller = class {
  /**
   * Empty implementation
   */
  setOffset(offset) {
  }
  /**
   * Empty implementation
   */
  getScrollPosition() {
    return [0, 0];
  }
  /**
   * Empty implementation
   */
  scrollToPosition(position) {
  }
  /**
   * Empty implementation
   */
  scrollToAnchor(anchor) {
  }
  /**
   * Empty implementation
   */
  setHistoryScrollRestoration(scrollRestoration) {
  }
};
var XhrFactory = class {
};
var PLACEHOLDER_QUALITY = "20";
function getUrl(src, win) {
  return isAbsoluteUrl(src) ? new URL(src) : new URL(src, win.location.href);
}
function isAbsoluteUrl(src) {
  return /^https?:\/\//.test(src);
}
function extractHostname(url) {
  return isAbsoluteUrl(url) ? new URL(url).hostname : url;
}
function isValidPath(path) {
  const isString = typeof path === "string";
  if (!isString || path.trim() === "") {
    return false;
  }
  try {
    const url = new URL(path);
    return true;
  } catch {
    return false;
  }
}
function normalizePath(path) {
  return path.endsWith("/") ? path.slice(0, -1) : path;
}
function normalizeSrc(src) {
  return src.startsWith("/") ? src.slice(1) : src;
}
var noopImageLoader = (config) => config.src;
var IMAGE_LOADER = new InjectionToken(ngDevMode ? "ImageLoader" : "", {
  providedIn: "root",
  factory: () => noopImageLoader
});
function createImageLoader(buildUrlFn, exampleUrls) {
  return function provideImageLoader(path) {
    if (!isValidPath(path)) {
      throwInvalidPathError(path, exampleUrls || []);
    }
    path = normalizePath(path);
    const loaderFn = (config) => {
      if (isAbsoluteUrl(config.src)) {
        throwUnexpectedAbsoluteUrlError(path, config.src);
      }
      return buildUrlFn(path, __spreadProps(__spreadValues({}, config), {
        src: normalizeSrc(config.src)
      }));
    };
    const providers = [{
      provide: IMAGE_LOADER,
      useValue: loaderFn
    }];
    return providers;
  };
}
function throwInvalidPathError(path, exampleUrls) {
  throw new RuntimeError(2959, ngDevMode && `Image loader has detected an invalid path (\`${path}\`). To fix this, supply a path using one of the following formats: ${exampleUrls.join(" or ")}`);
}
function throwUnexpectedAbsoluteUrlError(path, url) {
  throw new RuntimeError(2959, ngDevMode && `Image loader has detected a \`<img>\` tag with an invalid \`ngSrc\` attribute: ${url}. This image loader expects \`ngSrc\` to be a relative URL - however the provided value is an absolute URL. To fix this, provide \`ngSrc\` as a path relative to the base URL configured for this loader (\`${path}\`).`);
}
var provideCloudflareLoader = createImageLoader(createCloudflareUrl, ngDevMode ? ["https://<ZONE>/cdn-cgi/image/<OPTIONS>/<SOURCE-IMAGE>"] : void 0);
function createCloudflareUrl(path, config) {
  let params = `format=auto`;
  if (config.width) {
    params += `,width=${config.width}`;
  }
  if (config.isPlaceholder) {
    params += `,quality=${PLACEHOLDER_QUALITY}`;
  }
  return `${path}/cdn-cgi/image/${params}/${config.src}`;
}
var cloudinaryLoaderInfo = {
  name: "Cloudinary",
  testUrl: isCloudinaryUrl
};
var CLOUDINARY_LOADER_REGEX = /https?\:\/\/[^\/]+\.cloudinary\.com\/.+/;
function isCloudinaryUrl(url) {
  return CLOUDINARY_LOADER_REGEX.test(url);
}
var provideCloudinaryLoader = createImageLoader(createCloudinaryUrl, ngDevMode ? ["https://res.cloudinary.com/mysite", "https://mysite.cloudinary.com", "https://subdomain.mysite.com"] : void 0);
function createCloudinaryUrl(path, config) {
  const quality = config.isPlaceholder ? "q_auto:low" : "q_auto";
  let params = `f_auto,${quality}`;
  if (config.width) {
    params += `,w_${config.width}`;
  }
  return `${path}/image/upload/${params}/${config.src}`;
}
var imageKitLoaderInfo = {
  name: "ImageKit",
  testUrl: isImageKitUrl
};
var IMAGE_KIT_LOADER_REGEX = /https?\:\/\/[^\/]+\.imagekit\.io\/.+/;
function isImageKitUrl(url) {
  return IMAGE_KIT_LOADER_REGEX.test(url);
}
var provideImageKitLoader = createImageLoader(createImagekitUrl, ngDevMode ? ["https://ik.imagekit.io/mysite", "https://subdomain.mysite.com"] : void 0);
function createImagekitUrl(path, config) {
  const {
    src,
    width
  } = config;
  const params = [];
  if (width) {
    params.push(`w-${width}`);
  }
  if (config.isPlaceholder) {
    params.push(`q-${PLACEHOLDER_QUALITY}`);
  }
  const urlSegments = params.length ? [path, `tr:${params.join(",")}`, src] : [path, src];
  const url = new URL(urlSegments.join("/"));
  return url.href;
}
var imgixLoaderInfo = {
  name: "Imgix",
  testUrl: isImgixUrl
};
var IMGIX_LOADER_REGEX = /https?\:\/\/[^\/]+\.imgix\.net\/.+/;
function isImgixUrl(url) {
  return IMGIX_LOADER_REGEX.test(url);
}
var provideImgixLoader = createImageLoader(createImgixUrl, ngDevMode ? ["https://somepath.imgix.net/"] : void 0);
function createImgixUrl(path, config) {
  const url = new URL(`${path}/${config.src}`);
  url.searchParams.set("auto", "format");
  if (config.width) {
    url.searchParams.set("w", config.width.toString());
  }
  if (config.isPlaceholder) {
    url.searchParams.set("q", PLACEHOLDER_QUALITY);
  }
  return url.href;
}
var netlifyLoaderInfo = {
  name: "Netlify",
  testUrl: isNetlifyUrl
};
var NETLIFY_LOADER_REGEX = /https?\:\/\/[^\/]+\.netlify\.app\/.+/;
function isNetlifyUrl(url) {
  return NETLIFY_LOADER_REGEX.test(url);
}
function provideNetlifyLoader(path) {
  if (path && !isValidPath(path)) {
    throw new RuntimeError(2959, ngDevMode && `Image loader has detected an invalid path (\`${path}\`). To fix this, supply either the full URL to the Netlify site, or leave it empty to use the current site.`);
  }
  if (path) {
    const url = new URL(path);
    path = url.origin;
  }
  const loaderFn = (config) => {
    return createNetlifyUrl(config, path);
  };
  const providers = [{
    provide: IMAGE_LOADER,
    useValue: loaderFn
  }];
  return providers;
}
var validParams = /* @__PURE__ */ new Map([["height", "h"], ["fit", "fit"], ["quality", "q"], ["q", "q"], ["position", "position"]]);
function createNetlifyUrl(config, path) {
  const url = new URL(path ?? "https://a/");
  url.pathname = "/.netlify/images";
  if (!isAbsoluteUrl(config.src) && !config.src.startsWith("/")) {
    config.src = "/" + config.src;
  }
  url.searchParams.set("url", config.src);
  if (config.width) {
    url.searchParams.set("w", config.width.toString());
  }
  const configQuality = config.loaderParams?.["quality"] ?? config.loaderParams?.["q"];
  if (config.isPlaceholder && !configQuality) {
    url.searchParams.set("q", PLACEHOLDER_QUALITY);
  }
  for (const [param, value] of Object.entries(config.loaderParams ?? {})) {
    if (validParams.has(param)) {
      url.searchParams.set(validParams.get(param), value.toString());
    } else {
      if (ngDevMode) {
        console.warn(formatRuntimeError(2959, `The Netlify image loader has detected an \`<img>\` tag with the unsupported attribute "\`${param}\`".`));
      }
    }
  }
  return url.hostname === "a" ? url.href.replace(url.origin, "") : url.href;
}
function imgDirectiveDetails(ngSrc, includeNgSrc = true) {
  const ngSrcInfo = includeNgSrc ? `(activated on an <img> element with the \`ngSrc="${ngSrc}"\`) ` : "";
  return `The NgOptimizedImage directive ${ngSrcInfo}has detected that`;
}
function assertDevMode(checkName) {
  if (!ngDevMode) {
    throw new RuntimeError(2958, `Unexpected invocation of the ${checkName} in the prod mode. Please make sure that the prod mode is enabled for production builds.`);
  }
}
var LCPImageObserver = class _LCPImageObserver {
  constructor() {
    this.images = /* @__PURE__ */ new Map();
    this.window = null;
    this.observer = null;
    const isBrowser = isPlatformBrowser(inject(PLATFORM_ID));
    assertDevMode("LCP checker");
    const win = inject(DOCUMENT).defaultView;
    if (isBrowser && typeof PerformanceObserver !== "undefined") {
      this.window = win;
      this.observer = this.initPerformanceObserver();
    }
  }
  /**
   * Inits PerformanceObserver and subscribes to LCP events.
   * Based on https://web.dev/lcp/#measure-lcp-in-javascript
   */
  initPerformanceObserver() {
    const observer = new PerformanceObserver((entryList) => {
      const entries = entryList.getEntries();
      if (entries.length === 0) return;
      const lcpElement = entries[entries.length - 1];
      const imgSrc = lcpElement.element?.src ?? "";
      if (imgSrc.startsWith("data:") || imgSrc.startsWith("blob:")) return;
      const img = this.images.get(imgSrc);
      if (!img) return;
      if (!img.priority && !img.alreadyWarnedPriority) {
        img.alreadyWarnedPriority = true;
        logMissingPriorityError(imgSrc);
      }
      if (img.modified && !img.alreadyWarnedModified) {
        img.alreadyWarnedModified = true;
        logModifiedWarning(imgSrc);
      }
    });
    observer.observe({
      type: "largest-contentful-paint",
      buffered: true
    });
    return observer;
  }
  registerImage(rewrittenSrc, originalNgSrc, isPriority) {
    if (!this.observer) return;
    const newObservedImageState = {
      priority: isPriority,
      modified: false,
      alreadyWarnedModified: false,
      alreadyWarnedPriority: false
    };
    this.images.set(getUrl(rewrittenSrc, this.window).href, newObservedImageState);
  }
  unregisterImage(rewrittenSrc) {
    if (!this.observer) return;
    this.images.delete(getUrl(rewrittenSrc, this.window).href);
  }
  updateImage(originalSrc, newSrc) {
    if (!this.observer) return;
    const originalUrl = getUrl(originalSrc, this.window).href;
    const img = this.images.get(originalUrl);
    if (img) {
      img.modified = true;
      this.images.set(getUrl(newSrc, this.window).href, img);
      this.images.delete(originalUrl);
    }
  }
  ngOnDestroy() {
    if (!this.observer) return;
    this.observer.disconnect();
    this.images.clear();
  }
  static {
    this.ɵfac = function LCPImageObserver_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _LCPImageObserver)();
    };
  }
  static {
    this.ɵprov = ɵɵdefineInjectable({
      token: _LCPImageObserver,
      factory: _LCPImageObserver.ɵfac,
      providedIn: "root"
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(LCPImageObserver, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], () => [], null);
})();
function logMissingPriorityError(ngSrc) {
  const directiveDetails = imgDirectiveDetails(ngSrc);
  console.error(formatRuntimeError(2955, `${directiveDetails} this image is the Largest Contentful Paint (LCP) element but was not marked "priority". This image should be marked "priority" in order to prioritize its loading. To fix this, add the "priority" attribute.`));
}
function logModifiedWarning(ngSrc) {
  const directiveDetails = imgDirectiveDetails(ngSrc);
  console.warn(formatRuntimeError(2964, `${directiveDetails} this image is the Largest Contentful Paint (LCP) element and has had its "ngSrc" attribute modified. This can cause slower loading performance. It is recommended not to modify the "ngSrc" property on any image which could be the LCP element.`));
}
var INTERNAL_PRECONNECT_CHECK_BLOCKLIST = /* @__PURE__ */ new Set(["localhost", "127.0.0.1", "0.0.0.0"]);
var PRECONNECT_CHECK_BLOCKLIST = new InjectionToken(ngDevMode ? "PRECONNECT_CHECK_BLOCKLIST" : "");
var PreconnectLinkChecker = class _PreconnectLinkChecker {
  constructor() {
    this.document = inject(DOCUMENT);
    this.isServer = isPlatformServer(inject(PLATFORM_ID));
    this.preconnectLinks = null;
    this.alreadySeen = /* @__PURE__ */ new Set();
    this.window = null;
    this.blocklist = new Set(INTERNAL_PRECONNECT_CHECK_BLOCKLIST);
    assertDevMode("preconnect link checker");
    const win = this.document.defaultView;
    if (typeof win !== "undefined") {
      this.window = win;
    }
    const blocklist = inject(PRECONNECT_CHECK_BLOCKLIST, {
      optional: true
    });
    if (blocklist) {
      this.populateBlocklist(blocklist);
    }
  }
  populateBlocklist(origins) {
    if (Array.isArray(origins)) {
      deepForEach(origins, (origin) => {
        this.blocklist.add(extractHostname(origin));
      });
    } else {
      this.blocklist.add(extractHostname(origins));
    }
  }
  /**
   * Checks that a preconnect resource hint exists in the head for the
   * given src.
   *
   * @param rewrittenSrc src formatted with loader
   * @param originalNgSrc ngSrc value
   */
  assertPreconnect(rewrittenSrc, originalNgSrc) {
    if (this.isServer) return;
    const imgUrl = getUrl(rewrittenSrc, this.window);
    if (this.blocklist.has(imgUrl.hostname) || this.alreadySeen.has(imgUrl.origin)) return;
    this.alreadySeen.add(imgUrl.origin);
    this.preconnectLinks ??= this.queryPreconnectLinks();
    if (!this.preconnectLinks.has(imgUrl.origin)) {
      console.warn(formatRuntimeError(2956, `${imgDirectiveDetails(originalNgSrc)} there is no preconnect tag present for this image. Preconnecting to the origin(s) that serve priority images ensures that these images are delivered as soon as possible. To fix this, please add the following element into the <head> of the document:
  <link rel="preconnect" href="${imgUrl.origin}">`));
    }
  }
  queryPreconnectLinks() {
    const preconnectUrls = /* @__PURE__ */ new Set();
    const selector = "link[rel=preconnect]";
    const links = Array.from(this.document.querySelectorAll(selector));
    for (let link of links) {
      const url = getUrl(link.href, this.window);
      preconnectUrls.add(url.origin);
    }
    return preconnectUrls;
  }
  ngOnDestroy() {
    this.preconnectLinks?.clear();
    this.alreadySeen.clear();
  }
  static {
    this.ɵfac = function PreconnectLinkChecker_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _PreconnectLinkChecker)();
    };
  }
  static {
    this.ɵprov = ɵɵdefineInjectable({
      token: _PreconnectLinkChecker,
      factory: _PreconnectLinkChecker.ɵfac,
      providedIn: "root"
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PreconnectLinkChecker, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], () => [], null);
})();
function deepForEach(input, fn) {
  for (let value of input) {
    Array.isArray(value) ? deepForEach(value, fn) : fn(value);
  }
}
var DEFAULT_PRELOADED_IMAGES_LIMIT = 5;
var PRELOADED_IMAGES = new InjectionToken("NG_OPTIMIZED_PRELOADED_IMAGES", {
  providedIn: "root",
  factory: () => /* @__PURE__ */ new Set()
});
var PreloadLinkCreator = class _PreloadLinkCreator {
  constructor() {
    this.preloadedImages = inject(PRELOADED_IMAGES);
    this.document = inject(DOCUMENT);
  }
  /**
   * @description Add a preload `<link>` to the `<head>` of the `index.html` that is served from the
   * server while using Angular Universal and SSR to kick off image loads for high priority images.
   *
   * The `sizes` (passed in from the user) and `srcset` (parsed and formatted from `ngSrcset`)
   * properties used to set the corresponding attributes, `imagesizes` and `imagesrcset`
   * respectively, on the preload `<link>` tag so that the correctly sized image is preloaded from
   * the CDN.
   *
   * {@link https://web.dev/preload-responsive-images/#imagesrcset-and-imagesizes}
   *
   * @param renderer The `Renderer2` passed in from the directive
   * @param src The original src of the image that is set on the `ngSrc` input.
   * @param srcset The parsed and formatted srcset created from the `ngSrcset` input
   * @param sizes The value of the `sizes` attribute passed in to the `<img>` tag
   */
  createPreloadLinkTag(renderer, src, srcset, sizes) {
    if (ngDevMode) {
      if (this.preloadedImages.size >= DEFAULT_PRELOADED_IMAGES_LIMIT) {
        throw new RuntimeError(2961, ngDevMode && `The \`NgOptimizedImage\` directive has detected that more than ${DEFAULT_PRELOADED_IMAGES_LIMIT} images were marked as priority. This might negatively affect an overall performance of the page. To fix this, remove the "priority" attribute from images with less priority.`);
      }
    }
    if (this.preloadedImages.has(src)) {
      return;
    }
    this.preloadedImages.add(src);
    const preload = renderer.createElement("link");
    renderer.setAttribute(preload, "as", "image");
    renderer.setAttribute(preload, "href", src);
    renderer.setAttribute(preload, "rel", "preload");
    renderer.setAttribute(preload, "fetchpriority", "high");
    if (sizes) {
      renderer.setAttribute(preload, "imageSizes", sizes);
    }
    if (srcset) {
      renderer.setAttribute(preload, "imageSrcset", srcset);
    }
    renderer.appendChild(this.document.head, preload);
  }
  static {
    this.ɵfac = function PreloadLinkCreator_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _PreloadLinkCreator)();
    };
  }
  static {
    this.ɵprov = ɵɵdefineInjectable({
      token: _PreloadLinkCreator,
      factory: _PreloadLinkCreator.ɵfac,
      providedIn: "root"
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PreloadLinkCreator, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], null, null);
})();
var BASE64_IMG_MAX_LENGTH_IN_ERROR = 50;
var VALID_WIDTH_DESCRIPTOR_SRCSET = /^((\s*\d+w\s*(,|$)){1,})$/;
var VALID_DENSITY_DESCRIPTOR_SRCSET = /^((\s*\d+(\.\d+)?x\s*(,|$)){1,})$/;
var ABSOLUTE_SRCSET_DENSITY_CAP = 3;
var RECOMMENDED_SRCSET_DENSITY_CAP = 2;
var DENSITY_SRCSET_MULTIPLIERS = [1, 2];
var VIEWPORT_BREAKPOINT_CUTOFF = 640;
var ASPECT_RATIO_TOLERANCE = 0.1;
var OVERSIZED_IMAGE_TOLERANCE = 1e3;
var FIXED_SRCSET_WIDTH_LIMIT = 1920;
var FIXED_SRCSET_HEIGHT_LIMIT = 1080;
var PLACEHOLDER_BLUR_AMOUNT = 15;
var PLACEHOLDER_DIMENSION_LIMIT = 1e3;
var DATA_URL_WARN_LIMIT = 4e3;
var DATA_URL_ERROR_LIMIT = 1e4;
var BUILT_IN_LOADERS = [imgixLoaderInfo, imageKitLoaderInfo, cloudinaryLoaderInfo, netlifyLoaderInfo];
var PRIORITY_COUNT_THRESHOLD = 10;
var IMGS_WITH_PRIORITY_ATTR_COUNT = 0;
var NgOptimizedImage = class _NgOptimizedImage {
  constructor() {
    this.imageLoader = inject(IMAGE_LOADER);
    this.config = processConfig(inject(IMAGE_CONFIG));
    this.renderer = inject(Renderer2);
    this.imgElement = inject(ElementRef).nativeElement;
    this.injector = inject(Injector);
    this.isServer = isPlatformServer(inject(PLATFORM_ID));
    this.preloadLinkCreator = inject(PreloadLinkCreator);
    this.lcpObserver = ngDevMode ? this.injector.get(LCPImageObserver) : null;
    this._renderedSrc = null;
    this.priority = false;
    this.disableOptimizedSrcset = false;
    this.fill = false;
  }
  /** @nodoc */
  ngOnInit() {
    performanceMarkFeature("NgOptimizedImage");
    if (ngDevMode) {
      const ngZone = this.injector.get(NgZone);
      assertNonEmptyInput(this, "ngSrc", this.ngSrc);
      assertValidNgSrcset(this, this.ngSrcset);
      assertNoConflictingSrc(this);
      if (this.ngSrcset) {
        assertNoConflictingSrcset(this);
      }
      assertNotBase64Image(this);
      assertNotBlobUrl(this);
      if (this.fill) {
        assertEmptyWidthAndHeight(this);
        ngZone.runOutsideAngular(() => assertNonZeroRenderedHeight(this, this.imgElement, this.renderer));
      } else {
        assertNonEmptyWidthAndHeight(this);
        if (this.height !== void 0) {
          assertGreaterThanZero(this, this.height, "height");
        }
        if (this.width !== void 0) {
          assertGreaterThanZero(this, this.width, "width");
        }
        ngZone.runOutsideAngular(() => assertNoImageDistortion(this, this.imgElement, this.renderer));
      }
      assertValidLoadingInput(this);
      if (!this.ngSrcset) {
        assertNoComplexSizes(this);
      }
      assertValidPlaceholder(this, this.imageLoader);
      assertNotMissingBuiltInLoader(this.ngSrc, this.imageLoader);
      assertNoNgSrcsetWithoutLoader(this, this.imageLoader);
      assertNoLoaderParamsWithoutLoader(this, this.imageLoader);
      if (this.lcpObserver !== null) {
        const ngZone2 = this.injector.get(NgZone);
        ngZone2.runOutsideAngular(() => {
          this.lcpObserver.registerImage(this.getRewrittenSrc(), this.ngSrc, this.priority);
        });
      }
      if (this.priority) {
        const checker = this.injector.get(PreconnectLinkChecker);
        checker.assertPreconnect(this.getRewrittenSrc(), this.ngSrc);
        if (!this.isServer) {
          const applicationRef = this.injector.get(ApplicationRef);
          assetPriorityCountBelowThreshold(applicationRef);
        }
      }
    }
    if (this.placeholder) {
      this.removePlaceholderOnLoad(this.imgElement);
    }
    this.setHostAttributes();
  }
  setHostAttributes() {
    if (this.fill) {
      this.sizes ||= "100vw";
    } else {
      this.setHostAttribute("width", this.width.toString());
      this.setHostAttribute("height", this.height.toString());
    }
    this.setHostAttribute("loading", this.getLoadingBehavior());
    this.setHostAttribute("fetchpriority", this.getFetchPriority());
    this.setHostAttribute("ng-img", "true");
    const rewrittenSrcset = this.updateSrcAndSrcset();
    if (this.sizes) {
      this.setHostAttribute("sizes", this.sizes);
    }
    if (this.isServer && this.priority) {
      this.preloadLinkCreator.createPreloadLinkTag(this.renderer, this.getRewrittenSrc(), rewrittenSrcset, this.sizes);
    }
  }
  /** @nodoc */
  ngOnChanges(changes) {
    if (ngDevMode) {
      assertNoPostInitInputChange(this, changes, ["ngSrcset", "width", "height", "priority", "fill", "loading", "sizes", "loaderParams", "disableOptimizedSrcset"]);
    }
    if (changes["ngSrc"] && !changes["ngSrc"].isFirstChange()) {
      const oldSrc = this._renderedSrc;
      this.updateSrcAndSrcset(true);
      const newSrc = this._renderedSrc;
      if (this.lcpObserver !== null && oldSrc && newSrc && oldSrc !== newSrc) {
        const ngZone = this.injector.get(NgZone);
        ngZone.runOutsideAngular(() => {
          this.lcpObserver?.updateImage(oldSrc, newSrc);
        });
      }
    }
    if (ngDevMode && changes["placeholder"]?.currentValue && !this.isServer) {
      assertPlaceholderDimensions(this, this.imgElement);
    }
  }
  callImageLoader(configWithoutCustomParams) {
    let augmentedConfig = configWithoutCustomParams;
    if (this.loaderParams) {
      augmentedConfig.loaderParams = this.loaderParams;
    }
    return this.imageLoader(augmentedConfig);
  }
  getLoadingBehavior() {
    if (!this.priority && this.loading !== void 0) {
      return this.loading;
    }
    return this.priority ? "eager" : "lazy";
  }
  getFetchPriority() {
    return this.priority ? "high" : "auto";
  }
  getRewrittenSrc() {
    if (!this._renderedSrc) {
      const imgConfig = {
        src: this.ngSrc
      };
      this._renderedSrc = this.callImageLoader(imgConfig);
    }
    return this._renderedSrc;
  }
  getRewrittenSrcset() {
    const widthSrcSet = VALID_WIDTH_DESCRIPTOR_SRCSET.test(this.ngSrcset);
    const finalSrcs = this.ngSrcset.split(",").filter((src) => src !== "").map((srcStr) => {
      srcStr = srcStr.trim();
      const width = widthSrcSet ? parseFloat(srcStr) : parseFloat(srcStr) * this.width;
      return `${this.callImageLoader({
        src: this.ngSrc,
        width
      })} ${srcStr}`;
    });
    return finalSrcs.join(", ");
  }
  getAutomaticSrcset() {
    if (this.sizes) {
      return this.getResponsiveSrcset();
    } else {
      return this.getFixedSrcset();
    }
  }
  getResponsiveSrcset() {
    const {
      breakpoints
    } = this.config;
    let filteredBreakpoints = breakpoints;
    if (this.sizes?.trim() === "100vw") {
      filteredBreakpoints = breakpoints.filter((bp) => bp >= VIEWPORT_BREAKPOINT_CUTOFF);
    }
    const finalSrcs = filteredBreakpoints.map((bp) => `${this.callImageLoader({
      src: this.ngSrc,
      width: bp
    })} ${bp}w`);
    return finalSrcs.join(", ");
  }
  updateSrcAndSrcset(forceSrcRecalc = false) {
    if (forceSrcRecalc) {
      this._renderedSrc = null;
    }
    const rewrittenSrc = this.getRewrittenSrc();
    this.setHostAttribute("src", rewrittenSrc);
    let rewrittenSrcset = void 0;
    if (this.ngSrcset) {
      rewrittenSrcset = this.getRewrittenSrcset();
    } else if (this.shouldGenerateAutomaticSrcset()) {
      rewrittenSrcset = this.getAutomaticSrcset();
    }
    if (rewrittenSrcset) {
      this.setHostAttribute("srcset", rewrittenSrcset);
    }
    return rewrittenSrcset;
  }
  getFixedSrcset() {
    const finalSrcs = DENSITY_SRCSET_MULTIPLIERS.map((multiplier) => `${this.callImageLoader({
      src: this.ngSrc,
      width: this.width * multiplier
    })} ${multiplier}x`);
    return finalSrcs.join(", ");
  }
  shouldGenerateAutomaticSrcset() {
    let oversizedImage = false;
    if (!this.sizes) {
      oversizedImage = this.width > FIXED_SRCSET_WIDTH_LIMIT || this.height > FIXED_SRCSET_HEIGHT_LIMIT;
    }
    return !this.disableOptimizedSrcset && !this.srcset && this.imageLoader !== noopImageLoader && !oversizedImage;
  }
  /**
   * Returns an image url formatted for use with the CSS background-image property. Expects one of:
   * * A base64 encoded image, which is wrapped and passed through.
   * * A boolean. If true, calls the image loader to generate a small placeholder url.
   */
  generatePlaceholder(placeholderInput) {
    const {
      placeholderResolution
    } = this.config;
    if (placeholderInput === true) {
      return `url(${this.callImageLoader({
        src: this.ngSrc,
        width: placeholderResolution,
        isPlaceholder: true
      })})`;
    } else if (typeof placeholderInput === "string") {
      return `url(${placeholderInput})`;
    }
    return null;
  }
  /**
   * Determines if blur should be applied, based on an optional boolean
   * property `blur` within the optional configuration object `placeholderConfig`.
   */
  shouldBlurPlaceholder(placeholderConfig) {
    if (!placeholderConfig || !placeholderConfig.hasOwnProperty("blur")) {
      return true;
    }
    return Boolean(placeholderConfig.blur);
  }
  removePlaceholderOnLoad(img) {
    const callback = () => {
      const changeDetectorRef = this.injector.get(ChangeDetectorRef);
      removeLoadListenerFn();
      removeErrorListenerFn();
      this.placeholder = false;
      changeDetectorRef.markForCheck();
    };
    const removeLoadListenerFn = this.renderer.listen(img, "load", callback);
    const removeErrorListenerFn = this.renderer.listen(img, "error", callback);
  }
  /** @nodoc */
  ngOnDestroy() {
    if (ngDevMode) {
      if (!this.priority && this._renderedSrc !== null && this.lcpObserver !== null) {
        this.lcpObserver.unregisterImage(this._renderedSrc);
      }
    }
  }
  setHostAttribute(name, value) {
    this.renderer.setAttribute(this.imgElement, name, value);
  }
  static {
    this.ɵfac = function NgOptimizedImage_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _NgOptimizedImage)();
    };
  }
  static {
    this.ɵdir = ɵɵdefineDirective({
      type: _NgOptimizedImage,
      selectors: [["img", "ngSrc", ""]],
      hostVars: 18,
      hostBindings: function NgOptimizedImage_HostBindings(rf, ctx) {
        if (rf & 2) {
          ɵɵstyleProp("position", ctx.fill ? "absolute" : null)("width", ctx.fill ? "100%" : null)("height", ctx.fill ? "100%" : null)("inset", ctx.fill ? "0" : null)("background-size", ctx.placeholder ? "cover" : null)("background-position", ctx.placeholder ? "50% 50%" : null)("background-repeat", ctx.placeholder ? "no-repeat" : null)("background-image", ctx.placeholder ? ctx.generatePlaceholder(ctx.placeholder) : null)("filter", ctx.placeholder && ctx.shouldBlurPlaceholder(ctx.placeholderConfig) ? "blur(15px)" : null);
        }
      },
      inputs: {
        ngSrc: [2, "ngSrc", "ngSrc", unwrapSafeUrl],
        ngSrcset: "ngSrcset",
        sizes: "sizes",
        width: [2, "width", "width", numberAttribute],
        height: [2, "height", "height", numberAttribute],
        loading: "loading",
        priority: [2, "priority", "priority", booleanAttribute],
        loaderParams: "loaderParams",
        disableOptimizedSrcset: [2, "disableOptimizedSrcset", "disableOptimizedSrcset", booleanAttribute],
        fill: [2, "fill", "fill", booleanAttribute],
        placeholder: [2, "placeholder", "placeholder", booleanOrUrlAttribute],
        placeholderConfig: "placeholderConfig",
        src: "src",
        srcset: "srcset"
      },
      standalone: true,
      features: [ɵɵInputTransformsFeature, ɵɵNgOnChangesFeature]
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NgOptimizedImage, [{
    type: Directive,
    args: [{
      standalone: true,
      selector: "img[ngSrc]",
      host: {
        "[style.position]": 'fill ? "absolute" : null',
        "[style.width]": 'fill ? "100%" : null',
        "[style.height]": 'fill ? "100%" : null',
        "[style.inset]": 'fill ? "0" : null',
        "[style.background-size]": 'placeholder ? "cover" : null',
        "[style.background-position]": 'placeholder ? "50% 50%" : null',
        "[style.background-repeat]": 'placeholder ? "no-repeat" : null',
        "[style.background-image]": "placeholder ? generatePlaceholder(placeholder) : null",
        "[style.filter]": `placeholder && shouldBlurPlaceholder(placeholderConfig) ? "blur(${PLACEHOLDER_BLUR_AMOUNT}px)" : null`
      }
    }]
  }], null, {
    ngSrc: [{
      type: Input,
      args: [{
        required: true,
        transform: unwrapSafeUrl
      }]
    }],
    ngSrcset: [{
      type: Input
    }],
    sizes: [{
      type: Input
    }],
    width: [{
      type: Input,
      args: [{
        transform: numberAttribute
      }]
    }],
    height: [{
      type: Input,
      args: [{
        transform: numberAttribute
      }]
    }],
    loading: [{
      type: Input
    }],
    priority: [{
      type: Input,
      args: [{
        transform: booleanAttribute
      }]
    }],
    loaderParams: [{
      type: Input
    }],
    disableOptimizedSrcset: [{
      type: Input,
      args: [{
        transform: booleanAttribute
      }]
    }],
    fill: [{
      type: Input,
      args: [{
        transform: booleanAttribute
      }]
    }],
    placeholder: [{
      type: Input,
      args: [{
        transform: booleanOrUrlAttribute
      }]
    }],
    placeholderConfig: [{
      type: Input
    }],
    src: [{
      type: Input
    }],
    srcset: [{
      type: Input
    }]
  });
})();
function processConfig(config) {
  let sortedBreakpoints = {};
  if (config.breakpoints) {
    sortedBreakpoints.breakpoints = config.breakpoints.sort((a, b) => a - b);
  }
  return Object.assign({}, IMAGE_CONFIG_DEFAULTS, config, sortedBreakpoints);
}
function assertNoConflictingSrc(dir) {
  if (dir.src) {
    throw new RuntimeError(2950, `${imgDirectiveDetails(dir.ngSrc)} both \`src\` and \`ngSrc\` have been set. Supplying both of these attributes breaks lazy loading. The NgOptimizedImage directive sets \`src\` itself based on the value of \`ngSrc\`. To fix this, please remove the \`src\` attribute.`);
  }
}
function assertNoConflictingSrcset(dir) {
  if (dir.srcset) {
    throw new RuntimeError(2951, `${imgDirectiveDetails(dir.ngSrc)} both \`srcset\` and \`ngSrcset\` have been set. Supplying both of these attributes breaks lazy loading. The NgOptimizedImage directive sets \`srcset\` itself based on the value of \`ngSrcset\`. To fix this, please remove the \`srcset\` attribute.`);
  }
}
function assertNotBase64Image(dir) {
  let ngSrc = dir.ngSrc.trim();
  if (ngSrc.startsWith("data:")) {
    if (ngSrc.length > BASE64_IMG_MAX_LENGTH_IN_ERROR) {
      ngSrc = ngSrc.substring(0, BASE64_IMG_MAX_LENGTH_IN_ERROR) + "...";
    }
    throw new RuntimeError(2952, `${imgDirectiveDetails(dir.ngSrc, false)} \`ngSrc\` is a Base64-encoded string (${ngSrc}). NgOptimizedImage does not support Base64-encoded strings. To fix this, disable the NgOptimizedImage directive for this element by removing \`ngSrc\` and using a standard \`src\` attribute instead.`);
  }
}
function assertNoComplexSizes(dir) {
  let sizes = dir.sizes;
  if (sizes?.match(/((\)|,)\s|^)\d+px/)) {
    throw new RuntimeError(2952, `${imgDirectiveDetails(dir.ngSrc, false)} \`sizes\` was set to a string including pixel values. For automatic \`srcset\` generation, \`sizes\` must only include responsive values, such as \`sizes="50vw"\` or \`sizes="(min-width: 768px) 50vw, 100vw"\`. To fix this, modify the \`sizes\` attribute, or provide your own \`ngSrcset\` value directly.`);
  }
}
function assertValidPlaceholder(dir, imageLoader) {
  assertNoPlaceholderConfigWithoutPlaceholder(dir);
  assertNoRelativePlaceholderWithoutLoader(dir, imageLoader);
  assertNoOversizedDataUrl(dir);
}
function assertNoPlaceholderConfigWithoutPlaceholder(dir) {
  if (dir.placeholderConfig && !dir.placeholder) {
    throw new RuntimeError(2952, `${imgDirectiveDetails(dir.ngSrc, false)} \`placeholderConfig\` options were provided for an image that does not use the \`placeholder\` attribute, and will have no effect.`);
  }
}
function assertNoRelativePlaceholderWithoutLoader(dir, imageLoader) {
  if (dir.placeholder === true && imageLoader === noopImageLoader) {
    throw new RuntimeError(2963, `${imgDirectiveDetails(dir.ngSrc)} the \`placeholder\` attribute is set to true but no image loader is configured (i.e. the default one is being used), which would result in the same image being used for the primary image and its placeholder. To fix this, provide a loader or remove the \`placeholder\` attribute from the image.`);
  }
}
function assertNoOversizedDataUrl(dir) {
  if (dir.placeholder && typeof dir.placeholder === "string" && dir.placeholder.startsWith("data:")) {
    if (dir.placeholder.length > DATA_URL_ERROR_LIMIT) {
      throw new RuntimeError(2965, `${imgDirectiveDetails(dir.ngSrc)} the \`placeholder\` attribute is set to a data URL which is longer than ${DATA_URL_ERROR_LIMIT} characters. This is strongly discouraged, as large inline placeholders directly increase the bundle size of Angular and hurt page load performance. To fix this, generate a smaller data URL placeholder.`);
    }
    if (dir.placeholder.length > DATA_URL_WARN_LIMIT) {
      console.warn(formatRuntimeError(2965, `${imgDirectiveDetails(dir.ngSrc)} the \`placeholder\` attribute is set to a data URL which is longer than ${DATA_URL_WARN_LIMIT} characters. This is discouraged, as large inline placeholders directly increase the bundle size of Angular and hurt page load performance. For better loading performance, generate a smaller data URL placeholder.`));
    }
  }
}
function assertNotBlobUrl(dir) {
  const ngSrc = dir.ngSrc.trim();
  if (ngSrc.startsWith("blob:")) {
    throw new RuntimeError(2952, `${imgDirectiveDetails(dir.ngSrc)} \`ngSrc\` was set to a blob URL (${ngSrc}). Blob URLs are not supported by the NgOptimizedImage directive. To fix this, disable the NgOptimizedImage directive for this element by removing \`ngSrc\` and using a regular \`src\` attribute instead.`);
  }
}
function assertNonEmptyInput(dir, name, value) {
  const isString = typeof value === "string";
  const isEmptyString = isString && value.trim() === "";
  if (!isString || isEmptyString) {
    throw new RuntimeError(2952, `${imgDirectiveDetails(dir.ngSrc)} \`${name}\` has an invalid value (\`${value}\`). To fix this, change the value to a non-empty string.`);
  }
}
function assertValidNgSrcset(dir, value) {
  if (value == null) return;
  assertNonEmptyInput(dir, "ngSrcset", value);
  const stringVal = value;
  const isValidWidthDescriptor = VALID_WIDTH_DESCRIPTOR_SRCSET.test(stringVal);
  const isValidDensityDescriptor = VALID_DENSITY_DESCRIPTOR_SRCSET.test(stringVal);
  if (isValidDensityDescriptor) {
    assertUnderDensityCap(dir, stringVal);
  }
  const isValidSrcset = isValidWidthDescriptor || isValidDensityDescriptor;
  if (!isValidSrcset) {
    throw new RuntimeError(2952, `${imgDirectiveDetails(dir.ngSrc)} \`ngSrcset\` has an invalid value (\`${value}\`). To fix this, supply \`ngSrcset\` using a comma-separated list of one or more width descriptors (e.g. "100w, 200w") or density descriptors (e.g. "1x, 2x").`);
  }
}
function assertUnderDensityCap(dir, value) {
  const underDensityCap = value.split(",").every((num) => num === "" || parseFloat(num) <= ABSOLUTE_SRCSET_DENSITY_CAP);
  if (!underDensityCap) {
    throw new RuntimeError(2952, `${imgDirectiveDetails(dir.ngSrc)} the \`ngSrcset\` contains an unsupported image density:\`${value}\`. NgOptimizedImage generally recommends a max image density of ${RECOMMENDED_SRCSET_DENSITY_CAP}x but supports image densities up to ${ABSOLUTE_SRCSET_DENSITY_CAP}x. The human eye cannot distinguish between image densities greater than ${RECOMMENDED_SRCSET_DENSITY_CAP}x - which makes them unnecessary for most use cases. Images that will be pinch-zoomed are typically the primary use case for ${ABSOLUTE_SRCSET_DENSITY_CAP}x images. Please remove the high density descriptor and try again.`);
  }
}
function postInitInputChangeError(dir, inputName) {
  let reason;
  if (inputName === "width" || inputName === "height") {
    reason = `Changing \`${inputName}\` may result in different attribute value applied to the underlying image element and cause layout shifts on a page.`;
  } else {
    reason = `Changing the \`${inputName}\` would have no effect on the underlying image element, because the resource loading has already occurred.`;
  }
  return new RuntimeError(2953, `${imgDirectiveDetails(dir.ngSrc)} \`${inputName}\` was updated after initialization. The NgOptimizedImage directive will not react to this input change. ${reason} To fix this, either switch \`${inputName}\` to a static value or wrap the image element in an *ngIf that is gated on the necessary value.`);
}
function assertNoPostInitInputChange(dir, changes, inputs) {
  inputs.forEach((input) => {
    const isUpdated = changes.hasOwnProperty(input);
    if (isUpdated && !changes[input].isFirstChange()) {
      if (input === "ngSrc") {
        dir = {
          ngSrc: changes[input].previousValue
        };
      }
      throw postInitInputChangeError(dir, input);
    }
  });
}
function assertGreaterThanZero(dir, inputValue, inputName) {
  const validNumber = typeof inputValue === "number" && inputValue > 0;
  const validString = typeof inputValue === "string" && /^\d+$/.test(inputValue.trim()) && parseInt(inputValue) > 0;
  if (!validNumber && !validString) {
    throw new RuntimeError(2952, `${imgDirectiveDetails(dir.ngSrc)} \`${inputName}\` has an invalid value. To fix this, provide \`${inputName}\` as a number greater than 0.`);
  }
}
function assertNoImageDistortion(dir, img, renderer) {
  const removeLoadListenerFn = renderer.listen(img, "load", () => {
    removeLoadListenerFn();
    removeErrorListenerFn();
    const computedStyle = window.getComputedStyle(img);
    let renderedWidth = parseFloat(computedStyle.getPropertyValue("width"));
    let renderedHeight = parseFloat(computedStyle.getPropertyValue("height"));
    const boxSizing = computedStyle.getPropertyValue("box-sizing");
    if (boxSizing === "border-box") {
      const paddingTop = computedStyle.getPropertyValue("padding-top");
      const paddingRight = computedStyle.getPropertyValue("padding-right");
      const paddingBottom = computedStyle.getPropertyValue("padding-bottom");
      const paddingLeft = computedStyle.getPropertyValue("padding-left");
      renderedWidth -= parseFloat(paddingRight) + parseFloat(paddingLeft);
      renderedHeight -= parseFloat(paddingTop) + parseFloat(paddingBottom);
    }
    const renderedAspectRatio = renderedWidth / renderedHeight;
    const nonZeroRenderedDimensions = renderedWidth !== 0 && renderedHeight !== 0;
    const intrinsicWidth = img.naturalWidth;
    const intrinsicHeight = img.naturalHeight;
    const intrinsicAspectRatio = intrinsicWidth / intrinsicHeight;
    const suppliedWidth = dir.width;
    const suppliedHeight = dir.height;
    const suppliedAspectRatio = suppliedWidth / suppliedHeight;
    const inaccurateDimensions = Math.abs(suppliedAspectRatio - intrinsicAspectRatio) > ASPECT_RATIO_TOLERANCE;
    const stylingDistortion = nonZeroRenderedDimensions && Math.abs(intrinsicAspectRatio - renderedAspectRatio) > ASPECT_RATIO_TOLERANCE;
    if (inaccurateDimensions) {
      console.warn(formatRuntimeError(2952, `${imgDirectiveDetails(dir.ngSrc)} the aspect ratio of the image does not match the aspect ratio indicated by the width and height attributes. 
Intrinsic image size: ${intrinsicWidth}w x ${intrinsicHeight}h (aspect-ratio: ${round(intrinsicAspectRatio)}). 
Supplied width and height attributes: ${suppliedWidth}w x ${suppliedHeight}h (aspect-ratio: ${round(suppliedAspectRatio)}). 
To fix this, update the width and height attributes.`));
    } else if (stylingDistortion) {
      console.warn(formatRuntimeError(2952, `${imgDirectiveDetails(dir.ngSrc)} the aspect ratio of the rendered image does not match the image's intrinsic aspect ratio. 
Intrinsic image size: ${intrinsicWidth}w x ${intrinsicHeight}h (aspect-ratio: ${round(intrinsicAspectRatio)}). 
Rendered image size: ${renderedWidth}w x ${renderedHeight}h (aspect-ratio: ${round(renderedAspectRatio)}). 
This issue can occur if "width" and "height" attributes are added to an image without updating the corresponding image styling. To fix this, adjust image styling. In most cases, adding "height: auto" or "width: auto" to the image styling will fix this issue.`));
    } else if (!dir.ngSrcset && nonZeroRenderedDimensions) {
      const recommendedWidth = RECOMMENDED_SRCSET_DENSITY_CAP * renderedWidth;
      const recommendedHeight = RECOMMENDED_SRCSET_DENSITY_CAP * renderedHeight;
      const oversizedWidth = intrinsicWidth - recommendedWidth >= OVERSIZED_IMAGE_TOLERANCE;
      const oversizedHeight = intrinsicHeight - recommendedHeight >= OVERSIZED_IMAGE_TOLERANCE;
      if (oversizedWidth || oversizedHeight) {
        console.warn(formatRuntimeError(2960, `${imgDirectiveDetails(dir.ngSrc)} the intrinsic image is significantly larger than necessary. 
Rendered image size: ${renderedWidth}w x ${renderedHeight}h. 
Intrinsic image size: ${intrinsicWidth}w x ${intrinsicHeight}h. 
Recommended intrinsic image size: ${recommendedWidth}w x ${recommendedHeight}h. 
Note: Recommended intrinsic image size is calculated assuming a maximum DPR of ${RECOMMENDED_SRCSET_DENSITY_CAP}. To improve loading time, resize the image or consider using the "ngSrcset" and "sizes" attributes.`));
      }
    }
  });
  const removeErrorListenerFn = renderer.listen(img, "error", () => {
    removeLoadListenerFn();
    removeErrorListenerFn();
  });
}
function assertNonEmptyWidthAndHeight(dir) {
  let missingAttributes = [];
  if (dir.width === void 0) missingAttributes.push("width");
  if (dir.height === void 0) missingAttributes.push("height");
  if (missingAttributes.length > 0) {
    throw new RuntimeError(2954, `${imgDirectiveDetails(dir.ngSrc)} these required attributes are missing: ${missingAttributes.map((attr) => `"${attr}"`).join(", ")}. Including "width" and "height" attributes will prevent image-related layout shifts. To fix this, include "width" and "height" attributes on the image tag or turn on "fill" mode with the \`fill\` attribute.`);
  }
}
function assertEmptyWidthAndHeight(dir) {
  if (dir.width || dir.height) {
    throw new RuntimeError(2952, `${imgDirectiveDetails(dir.ngSrc)} the attributes \`height\` and/or \`width\` are present along with the \`fill\` attribute. Because \`fill\` mode causes an image to fill its containing element, the size attributes have no effect and should be removed.`);
  }
}
function assertNonZeroRenderedHeight(dir, img, renderer) {
  const removeLoadListenerFn = renderer.listen(img, "load", () => {
    removeLoadListenerFn();
    removeErrorListenerFn();
    const renderedHeight = img.clientHeight;
    if (dir.fill && renderedHeight === 0) {
      console.warn(formatRuntimeError(2952, `${imgDirectiveDetails(dir.ngSrc)} the height of the fill-mode image is zero. This is likely because the containing element does not have the CSS 'position' property set to one of the following: "relative", "fixed", or "absolute". To fix this problem, make sure the container element has the CSS 'position' property defined and the height of the element is not zero.`));
    }
  });
  const removeErrorListenerFn = renderer.listen(img, "error", () => {
    removeLoadListenerFn();
    removeErrorListenerFn();
  });
}
function assertValidLoadingInput(dir) {
  if (dir.loading && dir.priority) {
    throw new RuntimeError(2952, `${imgDirectiveDetails(dir.ngSrc)} the \`loading\` attribute was used on an image that was marked "priority". Setting \`loading\` on priority images is not allowed because these images will always be eagerly loaded. To fix this, remove the “loading” attribute from the priority image.`);
  }
  const validInputs = ["auto", "eager", "lazy"];
  if (typeof dir.loading === "string" && !validInputs.includes(dir.loading)) {
    throw new RuntimeError(2952, `${imgDirectiveDetails(dir.ngSrc)} the \`loading\` attribute has an invalid value (\`${dir.loading}\`). To fix this, provide a valid value ("lazy", "eager", or "auto").`);
  }
}
function assertNotMissingBuiltInLoader(ngSrc, imageLoader) {
  if (imageLoader === noopImageLoader) {
    let builtInLoaderName = "";
    for (const loader of BUILT_IN_LOADERS) {
      if (loader.testUrl(ngSrc)) {
        builtInLoaderName = loader.name;
        break;
      }
    }
    if (builtInLoaderName) {
      console.warn(formatRuntimeError(2962, `NgOptimizedImage: It looks like your images may be hosted on the ${builtInLoaderName} CDN, but your app is not using Angular's built-in loader for that CDN. We recommend switching to use the built-in by calling \`provide${builtInLoaderName}Loader()\` in your \`providers\` and passing it your instance's base URL. If you don't want to use the built-in loader, define a custom loader function using IMAGE_LOADER to silence this warning.`));
    }
  }
}
function assertNoNgSrcsetWithoutLoader(dir, imageLoader) {
  if (dir.ngSrcset && imageLoader === noopImageLoader) {
    console.warn(formatRuntimeError(2963, `${imgDirectiveDetails(dir.ngSrc)} the \`ngSrcset\` attribute is present but no image loader is configured (i.e. the default one is being used), which would result in the same image being used for all configured sizes. To fix this, provide a loader or remove the \`ngSrcset\` attribute from the image.`));
  }
}
function assertNoLoaderParamsWithoutLoader(dir, imageLoader) {
  if (dir.loaderParams && imageLoader === noopImageLoader) {
    console.warn(formatRuntimeError(2963, `${imgDirectiveDetails(dir.ngSrc)} the \`loaderParams\` attribute is present but no image loader is configured (i.e. the default one is being used), which means that the loaderParams data will not be consumed and will not affect the URL. To fix this, provide a custom loader or remove the \`loaderParams\` attribute from the image.`));
  }
}
function assetPriorityCountBelowThreshold(appRef) {
  return __async(this, null, function* () {
    if (IMGS_WITH_PRIORITY_ATTR_COUNT === 0) {
      IMGS_WITH_PRIORITY_ATTR_COUNT++;
      yield whenStable(appRef);
      if (IMGS_WITH_PRIORITY_ATTR_COUNT > PRIORITY_COUNT_THRESHOLD) {
        console.warn(formatRuntimeError(2966, `NgOptimizedImage: The "priority" attribute is set to true more than ${PRIORITY_COUNT_THRESHOLD} times (${IMGS_WITH_PRIORITY_ATTR_COUNT} times). Marking too many images as "high" priority can hurt your application's LCP (https://web.dev/lcp). "Priority" should only be set on the image expected to be the page's LCP element.`));
      }
    } else {
      IMGS_WITH_PRIORITY_ATTR_COUNT++;
    }
  });
}
function assertPlaceholderDimensions(dir, imgElement) {
  const computedStyle = window.getComputedStyle(imgElement);
  let renderedWidth = parseFloat(computedStyle.getPropertyValue("width"));
  let renderedHeight = parseFloat(computedStyle.getPropertyValue("height"));
  if (renderedWidth > PLACEHOLDER_DIMENSION_LIMIT || renderedHeight > PLACEHOLDER_DIMENSION_LIMIT) {
    console.warn(formatRuntimeError(2967, `${imgDirectiveDetails(dir.ngSrc)} it uses a placeholder image, but at least one of the dimensions attribute (height or width) exceeds the limit of ${PLACEHOLDER_DIMENSION_LIMIT}px. To fix this, use a smaller image as a placeholder.`));
  }
}
function round(input) {
  return Number.isInteger(input) ? input : input.toFixed(2);
}
function unwrapSafeUrl(value) {
  if (typeof value === "string") {
    return value;
  }
  return unwrapSafeValue(value);
}
function booleanOrUrlAttribute(value) {
  if (typeof value === "string" && value !== "true" && value !== "false" && value !== "") {
    return value;
  }
  return booleanAttribute(value);
}

export {
  getDOM,
  setRootDomAdapter,
  DomAdapter,
  PlatformNavigation,
  DOCUMENT,
  PlatformLocation,
  LOCATION_INITIALIZED,
  BrowserPlatformLocation,
  normalizeQueryParams,
  LocationStrategy,
  APP_BASE_HREF,
  PathLocationStrategy,
  HashLocationStrategy,
  Location,
  NumberFormatStyle,
  Plural,
  FormStyle,
  TranslationWidth,
  FormatWidth,
  NumberSymbol,
  WeekDay,
  getLocaleId,
  getLocaleDayPeriods,
  getLocaleDayNames,
  getLocaleMonthNames,
  getLocaleEraNames,
  getLocaleFirstDayOfWeek,
  getLocaleWeekEndRange,
  getLocaleDateFormat,
  getLocaleTimeFormat,
  getLocaleDateTimeFormat,
  getLocaleNumberSymbol,
  getLocaleNumberFormat,
  getLocaleCurrencySymbol,
  getLocaleCurrencyName,
  getLocaleCurrencyCode2 as getLocaleCurrencyCode,
  getLocalePluralCase2 as getLocalePluralCase,
  getLocaleExtraDayPeriodRules,
  getLocaleExtraDayPeriods,
  getLocaleDirection,
  getCurrencySymbol,
  getNumberOfCurrencyDigits,
  formatDate,
  formatCurrency,
  formatPercent,
  formatNumber,
  NgLocalization,
  NgLocaleLocalization,
  registerLocaleData2 as registerLocaleData,
  parseCookieValue,
  NgClass,
  NgComponentOutlet,
  NgForOfContext,
  NgForOf,
  NgIf,
  NgIfContext,
  NgSwitch,
  NgSwitchCase,
  NgSwitchDefault,
  NgPlural,
  NgPluralCase,
  NgStyle,
  NgTemplateOutlet,
  AsyncPipe,
  LowerCasePipe,
  TitleCasePipe,
  UpperCasePipe,
  DATE_PIPE_DEFAULT_TIMEZONE,
  DATE_PIPE_DEFAULT_OPTIONS,
  DatePipe,
  I18nPluralPipe,
  I18nSelectPipe,
  JsonPipe,
  KeyValuePipe,
  DecimalPipe,
  PercentPipe,
  CurrencyPipe,
  SlicePipe,
  CommonModule,
  PLATFORM_BROWSER_ID,
  PLATFORM_SERVER_ID,
  isPlatformBrowser,
  isPlatformServer,
  VERSION,
  ViewportScroller,
  NullViewportScroller,
  XhrFactory,
  IMAGE_LOADER,
  provideCloudflareLoader,
  provideCloudinaryLoader,
  provideImageKitLoader,
  provideImgixLoader,
  provideNetlifyLoader,
  PRECONNECT_CHECK_BLOCKLIST,
  NgOptimizedImage
};
/*! Bundled license information:

@angular/common/fesm2022/common.mjs:
  (**
   * @license Angular v18.2.0
   * (c) 2010-2024 Google LLC. https://angular.io/
   * License: MIT
   *)
*/
//# sourceMappingURL=chunk-HB2ZDJCU.js.map



================================================
FILE: .angular/cache/18.2.20/angular-pivothead-example/vite/deps/chunk-HHOT2EEL.js
================================================
import {
  AsyncAction,
  AsyncScheduler,
  AsyncSubject,
  EMPTY,
  EmptyError,
  Observable,
  SafeSubscriber,
  Subject,
  Subscription,
  __extends,
  __generator,
  __read,
  __spreadArray,
  argsArgArrayOrObject,
  createObject,
  createOperatorSubscriber,
  filter,
  from,
  identity,
  innerFrom,
  isArrayLike,
  isFunction,
  isScheduler,
  mapOneOrManyArgs,
  mergeAll,
  mergeMap,
  noop,
  not,
  observeOn,
  popNumber,
  popResultSelector,
  popScheduler,
  scheduleIterable,
  subscribeOn
} from "./chunk-OVFEQSRS.js";

// node_modules/rxjs/dist/esm5/internal/scheduler/performanceTimestampProvider.js
var performanceTimestampProvider = {
  now: function() {
    return (performanceTimestampProvider.delegate || performance).now();
  },
  delegate: void 0
};

// node_modules/rxjs/dist/esm5/internal/scheduler/animationFrameProvider.js
var animationFrameProvider = {
  schedule: function(callback) {
    var request = requestAnimationFrame;
    var cancel = cancelAnimationFrame;
    var delegate = animationFrameProvider.delegate;
    if (delegate) {
      request = delegate.requestAnimationFrame;
      cancel = delegate.cancelAnimationFrame;
    }
    var handle = request(function(timestamp2) {
      cancel = void 0;
      callback(timestamp2);
    });
    return new Subscription(function() {
      return cancel === null || cancel === void 0 ? void 0 : cancel(handle);
    });
  },
  requestAnimationFrame: function() {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      args[_i] = arguments[_i];
    }
    var delegate = animationFrameProvider.delegate;
    return ((delegate === null || delegate === void 0 ? void 0 : delegate.requestAnimationFrame) || requestAnimationFrame).apply(void 0, __spreadArray([], __read(args)));
  },
  cancelAnimationFrame: function() {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      args[_i] = arguments[_i];
    }
    var delegate = animationFrameProvider.delegate;
    return ((delegate === null || delegate === void 0 ? void 0 : delegate.cancelAnimationFrame) || cancelAnimationFrame).apply(void 0, __spreadArray([], __read(args)));
  },
  delegate: void 0
};

// node_modules/rxjs/dist/esm5/internal/observable/dom/animationFrames.js
function animationFrames(timestampProvider) {
  return timestampProvider ? animationFramesFactory(timestampProvider) : DEFAULT_ANIMATION_FRAMES;
}
function animationFramesFactory(timestampProvider) {
  return new Observable(function(subscriber) {
    var provider = timestampProvider || performanceTimestampProvider;
    var start = provider.now();
    var id = 0;
    var run = function() {
      if (!subscriber.closed) {
        id = animationFrameProvider.requestAnimationFrame(function(timestamp2) {
          id = 0;
          var now = provider.now();
          subscriber.next({
            timestamp: timestampProvider ? now : timestamp2,
            elapsed: now - start
          });
          run();
        });
      }
    };
    run();
    return function() {
      if (id) {
        animationFrameProvider.cancelAnimationFrame(id);
      }
    };
  });
}
var DEFAULT_ANIMATION_FRAMES = animationFramesFactory();

// node_modules/rxjs/dist/esm5/internal/util/Immediate.js
var nextHandle = 1;
var resolved;
var activeHandles = {};
function findAndClearHandle(handle) {
  if (handle in activeHandles) {
    delete activeHandles[handle];
    return true;
  }
  return false;
}
var Immediate = {
  setImmediate: function(cb) {
    var handle = nextHandle++;
    activeHandles[handle] = true;
    if (!resolved) {
      resolved = Promise.resolve();
    }
    resolved.then(function() {
      return findAndClearHandle(handle) && cb();
    });
    return handle;
  },
  clearImmediate: function(handle) {
    findAndClearHandle(handle);
  }
};

// node_modules/rxjs/dist/esm5/internal/scheduler/immediateProvider.js
var setImmediate = Immediate.setImmediate;
var clearImmediate = Immediate.clearImmediate;
var immediateProvider = {
  setImmediate: function() {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      args[_i] = arguments[_i];
    }
    var delegate = immediateProvider.delegate;
    return ((delegate === null || delegate === void 0 ? void 0 : delegate.setImmediate) || setImmediate).apply(void 0, __spreadArray([], __read(args)));
  },
  clearImmediate: function(handle) {
    var delegate = immediateProvider.delegate;
    return ((delegate === null || delegate === void 0 ? void 0 : delegate.clearImmediate) || clearImmediate)(handle);
  },
  delegate: void 0
};

// node_modules/rxjs/dist/esm5/internal/scheduler/AsapAction.js
var AsapAction = function(_super) {
  __extends(AsapAction2, _super);
  function AsapAction2(scheduler, work) {
    var _this = _super.call(this, scheduler, work) || this;
    _this.scheduler = scheduler;
    _this.work = work;
    return _this;
  }
  AsapAction2.prototype.requestAsyncId = function(scheduler, id, delay2) {
    if (delay2 === void 0) {
      delay2 = 0;
    }
    if (delay2 !== null && delay2 > 0) {
      return _super.prototype.requestAsyncId.call(this, scheduler, id, delay2);
    }
    scheduler.actions.push(this);
    return scheduler._scheduled || (scheduler._scheduled = immediateProvider.setImmediate(scheduler.flush.bind(scheduler, void 0)));
  };
  AsapAction2.prototype.recycleAsyncId = function(scheduler, id, delay2) {
    var _a;
    if (delay2 === void 0) {
      delay2 = 0;
    }
    if (delay2 != null ? delay2 > 0 : this.delay > 0) {
      return _super.prototype.recycleAsyncId.call(this, scheduler, id, delay2);
    }
    var actions = scheduler.actions;
    if (id != null && ((_a = actions[actions.length - 1]) === null || _a === void 0 ? void 0 : _a.id) !== id) {
      immediateProvider.clearImmediate(id);
      scheduler._scheduled = void 0;
    }
    return void 0;
  };
  return AsapAction2;
}(AsyncAction);

// node_modules/rxjs/dist/esm5/internal/scheduler/AsapScheduler.js
var AsapScheduler = function(_super) {
  __extends(AsapScheduler2, _super);
  function AsapScheduler2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  AsapScheduler2.prototype.flush = function(action) {
    this._active = true;
    var flushId = this._scheduled;
    this._scheduled = void 0;
    var actions = this.actions;
    var error;
    action = action || actions.shift();
    do {
      if (error = action.execute(action.state, action.delay)) {
        break;
      }
    } while ((action = actions[0]) && action.id === flushId && actions.shift());
    this._active = false;
    if (error) {
      while ((action = actions[0]) && action.id === flushId && actions.shift()) {
        action.unsubscribe();
      }
      throw error;
    }
  };
  return AsapScheduler2;
}(AsyncScheduler);

// node_modules/rxjs/dist/esm5/internal/scheduler/asap.js
var asapScheduler = new AsapScheduler(AsapAction);
var asap = asapScheduler;

// node_modules/rxjs/dist/esm5/internal/scheduler/QueueAction.js
var QueueAction = function(_super) {
  __extends(QueueAction2, _super);
  function QueueAction2(scheduler, work) {
    var _this = _super.call(this, scheduler, work) || this;
    _this.scheduler = scheduler;
    _this.work = work;
    return _this;
  }
  QueueAction2.prototype.schedule = function(state, delay2) {
    if (delay2 === void 0) {
      delay2 = 0;
    }
    if (delay2 > 0) {
      return _super.prototype.schedule.call(this, state, delay2);
    }
    this.delay = delay2;
    this.state = state;
    this.scheduler.flush(this);
    return this;
  };
  QueueAction2.prototype.execute = function(state, delay2) {
    return delay2 > 0 || this.closed ? _super.prototype.execute.call(this, state, delay2) : this._execute(state, delay2);
  };
  QueueAction2.prototype.requestAsyncId = function(scheduler, id, delay2) {
    if (delay2 === void 0) {
      delay2 = 0;
    }
    if (delay2 != null && delay2 > 0 || delay2 == null && this.delay > 0) {
      return _super.prototype.requestAsyncId.call(this, scheduler, id, delay2);
    }
    scheduler.flush(this);
    return 0;
  };
  return QueueAction2;
}(AsyncAction);

// node_modules/rxjs/dist/esm5/internal/scheduler/QueueScheduler.js
var QueueScheduler = function(_super) {
  __extends(QueueScheduler2, _super);
  function QueueScheduler2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  return QueueScheduler2;
}(AsyncScheduler);

// node_modules/rxjs/dist/esm5/internal/scheduler/queue.js
var queueScheduler = new QueueScheduler(QueueAction);
var queue = queueScheduler;

// node_modules/rxjs/dist/esm5/internal/scheduler/AnimationFrameAction.js
var AnimationFrameAction = function(_super) {
  __extends(AnimationFrameAction2, _super);
  function AnimationFrameAction2(scheduler, work) {
    var _this = _super.call(this, scheduler, work) || this;
    _this.scheduler = scheduler;
    _this.work = work;
    return _this;
  }
  AnimationFrameAction2.prototype.requestAsyncId = function(scheduler, id, delay2) {
    if (delay2 === void 0) {
      delay2 = 0;
    }
    if (delay2 !== null && delay2 > 0) {
      return _super.prototype.requestAsyncId.call(this, scheduler, id, delay2);
    }
    scheduler.actions.push(this);
    return scheduler._scheduled || (scheduler._scheduled = animationFrameProvider.requestAnimationFrame(function() {
      return scheduler.flush(void 0);
    }));
  };
  AnimationFrameAction2.prototype.recycleAsyncId = function(scheduler, id, delay2) {
    var _a;
    if (delay2 === void 0) {
      delay2 = 0;
    }
    if (delay2 != null ? delay2 > 0 : this.delay > 0) {
      return _super.prototype.recycleAsyncId.call(this, scheduler, id, delay2);
    }
    var actions = scheduler.actions;
    if (id != null && ((_a = actions[actions.length - 1]) === null || _a === void 0 ? void 0 : _a.id) !== id) {
      animationFrameProvider.cancelAnimationFrame(id);
      scheduler._scheduled = void 0;
    }
    return void 0;
  };
  return AnimationFrameAction2;
}(AsyncAction);

// node_modules/rxjs/dist/esm5/internal/scheduler/AnimationFrameScheduler.js
var AnimationFrameScheduler = function(_super) {
  __extends(AnimationFrameScheduler2, _super);
  function AnimationFrameScheduler2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  AnimationFrameScheduler2.prototype.flush = function(action) {
    this._active = true;
    var flushId = this._scheduled;
    this._scheduled = void 0;
    var actions = this.actions;
    var error;
    action = action || actions.shift();
    do {
      if (error = action.execute(action.state, action.delay)) {
        break;
      }
    } while ((action = actions[0]) && action.id === flushId && actions.shift());
    this._active = false;
    if (error) {
      while ((action = actions[0]) && action.id === flushId && actions.shift()) {
        action.unsubscribe();
      }
      throw error;
    }
  };
  return AnimationFrameScheduler2;
}(AsyncScheduler);

// node_modules/rxjs/dist/esm5/internal/scheduler/animationFrame.js
var animationFrameScheduler = new AnimationFrameScheduler(AnimationFrameAction);
var animationFrame = animationFrameScheduler;

// node_modules/rxjs/dist/esm5/internal/scheduler/VirtualTimeScheduler.js
var VirtualTimeScheduler = function(_super) {
  __extends(VirtualTimeScheduler2, _super);
  function VirtualTimeScheduler2(schedulerActionCtor, maxFrames) {
    if (schedulerActionCtor === void 0) {
      schedulerActionCtor = VirtualAction;
    }
    if (maxFrames === void 0) {
      maxFrames = Infinity;
    }
    var _this = _super.call(this, schedulerActionCtor, function() {
      return _this.frame;
    }) || this;
    _this.maxFrames = maxFrames;
    _this.frame = 0;
    _this.index = -1;
    return _this;
  }
  VirtualTimeScheduler2.prototype.flush = function() {
    var _a = this, actions = _a.actions, maxFrames = _a.maxFrames;
    var error;
    var action;
    while ((action = actions[0]) && action.delay <= maxFrames) {
      actions.shift();
      this.frame = action.delay;
      if (error = action.execute(action.state, action.delay)) {
        break;
      }
    }
    if (error) {
      while (action = actions.shift()) {
        action.unsubscribe();
      }
      throw error;
    }
  };
  VirtualTimeScheduler2.frameTimeFactor = 10;
  return VirtualTimeScheduler2;
}(AsyncScheduler);
var VirtualAction = function(_super) {
  __extends(VirtualAction2, _super);
  function VirtualAction2(scheduler, work, index) {
    if (index === void 0) {
      index = scheduler.index += 1;
    }
    var _this = _super.call(this, scheduler, work) || this;
    _this.scheduler = scheduler;
    _this.work = work;
    _this.index = index;
    _this.active = true;
    _this.index = scheduler.index = index;
    return _this;
  }
  VirtualAction2.prototype.schedule = function(state, delay2) {
    if (delay2 === void 0) {
      delay2 = 0;
    }
    if (Number.isFinite(delay2)) {
      if (!this.id) {
        return _super.prototype.schedule.call(this, state, delay2);
      }
      this.active = false;
      var action = new VirtualAction2(this.scheduler, this.work);
      this.add(action);
      return action.schedule(state, delay2);
    } else {
      return Subscription.EMPTY;
    }
  };
  VirtualAction2.prototype.requestAsyncId = function(scheduler, id, delay2) {
    if (delay2 === void 0) {
      delay2 = 0;
    }
    this.delay = scheduler.frame + delay2;
    var actions = scheduler.actions;
    actions.push(this);
    actions.sort(VirtualAction2.sortActions);
    return 1;
  };
  VirtualAction2.prototype.recycleAsyncId = function(scheduler, id, delay2) {
    if (delay2 === void 0) {
      delay2 = 0;
    }
    return void 0;
  };
  VirtualAction2.prototype._execute = function(state, delay2) {
    if (this.active === true) {
      return _super.prototype._execute.call(this, state, delay2);
    }
  };
  VirtualAction2.sortActions = function(a, b) {
    if (a.delay === b.delay) {
      if (a.index === b.index) {
        return 0;
      } else if (a.index > b.index) {
        return 1;
      } else {
        return -1;
      }
    } else if (a.delay > b.delay) {
      return 1;
    } else {
      return -1;
    }
  };
  return VirtualAction2;
}(AsyncAction);

// node_modules/rxjs/dist/esm5/internal/util/isObservable.js
function isObservable(obj) {
  return !!obj && (obj instanceof Observable || isFunction(obj.lift) && isFunction(obj.subscribe));
}

// node_modules/rxjs/dist/esm5/internal/lastValueFrom.js
function lastValueFrom(source, config2) {
  var hasConfig = typeof config2 === "object";
  return new Promise(function(resolve, reject) {
    var _hasValue = false;
    var _value;
    source.subscribe({
      next: function(value) {
        _value = value;
        _hasValue = true;
      },
      error: reject,
      complete: function() {
        if (_hasValue) {
          resolve(_value);
        } else if (hasConfig) {
          resolve(config2.defaultValue);
        } else {
          reject(new EmptyError());
        }
      }
    });
  });
}

// node_modules/rxjs/dist/esm5/internal/firstValueFrom.js
function firstValueFrom(source, config2) {
  var hasConfig = typeof config2 === "object";
  return new Promise(function(resolve, reject) {
    var subscriber = new SafeSubscriber({
      next: function(value) {
        resolve(value);
        subscriber.unsubscribe();
      },
      error: reject,
      complete: function() {
        if (hasConfig) {
          resolve(config2.defaultValue);
        } else {
          reject(new EmptyError());
        }
      }
    });
    source.subscribe(subscriber);
  });
}

// node_modules/rxjs/dist/esm5/internal/observable/bindCallbackInternals.js
function bindCallbackInternals(isNodeStyle, callbackFunc, resultSelector, scheduler) {
  if (resultSelector) {
    if (isScheduler(resultSelector)) {
      scheduler = resultSelector;
    } else {
      return function() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }
        return bindCallbackInternals(isNodeStyle, callbackFunc, scheduler).apply(this, args).pipe(mapOneOrManyArgs(resultSelector));
      };
    }
  }
  if (scheduler) {
    return function() {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      return bindCallbackInternals(isNodeStyle, callbackFunc).apply(this, args).pipe(subscribeOn(scheduler), observeOn(scheduler));
    };
  }
  return function() {
    var _this = this;
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      args[_i] = arguments[_i];
    }
    var subject = new AsyncSubject();
    var uninitialized = true;
    return new Observable(function(subscriber) {
      var subs = subject.subscribe(subscriber);
      if (uninitialized) {
        uninitialized = false;
        var isAsync_1 = false;
        var isComplete_1 = false;
        callbackFunc.apply(_this, __spreadArray(__spreadArray([], __read(args)), [function() {
          var results = [];
          for (var _i2 = 0; _i2 < arguments.length; _i2++) {
            results[_i2] = arguments[_i2];
          }
          if (isNodeStyle) {
            var err = results.shift();
            if (err != null) {
              subject.error(err);
              return;
            }
          }
          subject.next(1 < results.length ? results : results[0]);
          isComplete_1 = true;
          if (isAsync_1) {
            subject.complete();
          }
        }]));
        if (isComplete_1) {
          subject.complete();
        }
        isAsync_1 = true;
      }
      return subs;
    });
  };
}

// node_modules/rxjs/dist/esm5/internal/observable/bindCallback.js
function bindCallback(callbackFunc, resultSelector, scheduler) {
  return bindCallbackInternals(false, callbackFunc, resultSelector, scheduler);
}

// node_modules/rxjs/dist/esm5/internal/observable/bindNodeCallback.js
function bindNodeCallback(callbackFunc, resultSelector, scheduler) {
  return bindCallbackInternals(true, callbackFunc, resultSelector, scheduler);
}

// node_modules/rxjs/dist/esm5/internal/observable/defer.js
function defer(observableFactory) {
  return new Observable(function(subscriber) {
    innerFrom(observableFactory()).subscribe(subscriber);
  });
}

// node_modules/rxjs/dist/esm5/internal/observable/connectable.js
var DEFAULT_CONFIG = {
  connector: function() {
    return new Subject();
  },
  resetOnDisconnect: true
};
function connectable(source, config2) {
  if (config2 === void 0) {
    config2 = DEFAULT_CONFIG;
  }
  var connection = null;
  var connector = config2.connector, _a = config2.resetOnDisconnect, resetOnDisconnect = _a === void 0 ? true : _a;
  var subject = connector();
  var result = new Observable(function(subscriber) {
    return subject.subscribe(subscriber);
  });
  result.connect = function() {
    if (!connection || connection.closed) {
      connection = defer(function() {
        return source;
      }).subscribe(subject);
      if (resetOnDisconnect) {
        connection.add(function() {
          return subject = connector();
        });
      }
    }
    return connection;
  };
  return result;
}

// node_modules/rxjs/dist/esm5/internal/observable/forkJoin.js
function forkJoin() {
  var args = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    args[_i] = arguments[_i];
  }
  var resultSelector = popResultSelector(args);
  var _a = argsArgArrayOrObject(args), sources = _a.args, keys = _a.keys;
  var result = new Observable(function(subscriber) {
    var length = sources.length;
    if (!length) {
      subscriber.complete();
      return;
    }
    var values = new Array(length);
    var remainingCompletions = length;
    var remainingEmissions = length;
    var _loop_1 = function(sourceIndex2) {
      var hasValue = false;
      innerFrom(sources[sourceIndex2]).subscribe(createOperatorSubscriber(subscriber, function(value) {
        if (!hasValue) {
          hasValue = true;
          remainingEmissions--;
        }
        values[sourceIndex2] = value;
      }, function() {
        return remainingCompletions--;
      }, void 0, function() {
        if (!remainingCompletions || !hasValue) {
          if (!remainingEmissions) {
            subscriber.next(keys ? createObject(keys, values) : values);
          }
          subscriber.complete();
        }
      }));
    };
    for (var sourceIndex = 0; sourceIndex < length; sourceIndex++) {
      _loop_1(sourceIndex);
    }
  });
  return resultSelector ? result.pipe(mapOneOrManyArgs(resultSelector)) : result;
}

// node_modules/rxjs/dist/esm5/internal/observable/fromEvent.js
var nodeEventEmitterMethods = ["addListener", "removeListener"];
var eventTargetMethods = ["addEventListener", "removeEventListener"];
var jqueryMethods = ["on", "off"];
function fromEvent(target, eventName, options, resultSelector) {
  if (isFunction(options)) {
    resultSelector = options;
    options = void 0;
  }
  if (resultSelector) {
    return fromEvent(target, eventName, options).pipe(mapOneOrManyArgs(resultSelector));
  }
  var _a = __read(isEventTarget(target) ? eventTargetMethods.map(function(methodName) {
    return function(handler) {
      return target[methodName](eventName, handler, options);
    };
  }) : isNodeStyleEventEmitter(target) ? nodeEventEmitterMethods.map(toCommonHandlerRegistry(target, eventName)) : isJQueryStyleEventEmitter(target) ? jqueryMethods.map(toCommonHandlerRegistry(target, eventName)) : [], 2), add = _a[0], remove = _a[1];
  if (!add) {
    if (isArrayLike(target)) {
      return mergeMap(function(subTarget) {
        return fromEvent(subTarget, eventName, options);
      })(innerFrom(target));
    }
  }
  if (!add) {
    throw new TypeError("Invalid event target");
  }
  return new Observable(function(subscriber) {
    var handler = function() {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      return subscriber.next(1 < args.length ? args : args[0]);
    };
    add(handler);
    return function() {
      return remove(handler);
    };
  });
}
function toCommonHandlerRegistry(target, eventName) {
  return function(methodName) {
    return function(handler) {
      return target[methodName](eventName, handler);
    };
  };
}
function isNodeStyleEventEmitter(target) {
  return isFunction(target.addListener) && isFunction(target.removeListener);
}
function isJQueryStyleEventEmitter(target) {
  return isFunction(target.on) && isFunction(target.off);
}
function isEventTarget(target) {
  return isFunction(target.addEventListener) && isFunction(target.removeEventListener);
}

// node_modules/rxjs/dist/esm5/internal/observable/fromEventPattern.js
function fromEventPattern(addHandler, removeHandler, resultSelector) {
  if (resultSelector) {
    return fromEventPattern(addHandler, removeHandler).pipe(mapOneOrManyArgs(resultSelector));
  }
  return new Observable(function(subscriber) {
    var handler = function() {
      var e = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        e[_i] = arguments[_i];
      }
      return subscriber.next(e.length === 1 ? e[0] : e);
    };
    var retValue = addHandler(handler);
    return isFunction(removeHandler) ? function() {
      return removeHandler(handler, retValue);
    } : void 0;
  });
}

// node_modules/rxjs/dist/esm5/internal/observable/generate.js
function generate(initialStateOrOptions, condition, iterate, resultSelectorOrScheduler, scheduler) {
  var _a, _b;
  var resultSelector;
  var initialState;
  if (arguments.length === 1) {
    _a = initialStateOrOptions, initialState = _a.initialState, condition = _a.condition, iterate = _a.iterate, _b = _a.resultSelector, resultSelector = _b === void 0 ? identity : _b, scheduler = _a.scheduler;
  } else {
    initialState = initialStateOrOptions;
    if (!resultSelectorOrScheduler || isScheduler(resultSelectorOrScheduler)) {
      resultSelector = identity;
      scheduler = resultSelectorOrScheduler;
    } else {
      resultSelector = resultSelectorOrScheduler;
    }
  }
  function gen() {
    var state;
    return __generator(this, function(_a2) {
      switch (_a2.label) {
        case 0:
          state = initialState;
          _a2.label = 1;
        case 1:
          if (!(!condition || condition(state))) return [3, 4];
          return [4, resultSelector(state)];
        case 2:
          _a2.sent();
          _a2.label = 3;
        case 3:
          state = iterate(state);
          return [3, 1];
        case 4:
          return [2];
      }
    });
  }
  return defer(scheduler ? function() {
    return scheduleIterable(gen(), scheduler);
  } : gen);
}

// node_modules/rxjs/dist/esm5/internal/observable/iif.js
function iif(condition, trueResult, falseResult) {
  return defer(function() {
    return condition() ? trueResult : falseResult;
  });
}

// node_modules/rxjs/dist/esm5/internal/observable/merge.js
function merge() {
  var args = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    args[_i] = arguments[_i];
  }
  var scheduler = popScheduler(args);
  var concurrent = popNumber(args, Infinity);
  var sources = args;
  return !sources.length ? EMPTY : sources.length === 1 ? innerFrom(sources[0]) : mergeAll(concurrent)(from(sources, scheduler));
}

// node_modules/rxjs/dist/esm5/internal/observable/never.js
var NEVER = new Observable(noop);
function never() {
  return NEVER;
}

// node_modules/rxjs/dist/esm5/internal/observable/pairs.js
function pairs(obj, scheduler) {
  return from(Object.entries(obj), scheduler);
}

// node_modules/rxjs/dist/esm5/internal/observable/partition.js
function partition(source, predicate, thisArg) {
  return [filter(predicate, thisArg)(innerFrom(source)), filter(not(predicate, thisArg))(innerFrom(source))];
}

// node_modules/rxjs/dist/esm5/internal/observable/range.js
function range(start, count2, scheduler) {
  if (count2 == null) {
    count2 = start;
    start = 0;
  }
  if (count2 <= 0) {
    return EMPTY;
  }
  var end = count2 + start;
  return new Observable(scheduler ? function(subscriber) {
    var n = start;
    return scheduler.schedule(function() {
      if (n < end) {
        subscriber.next(n++);
        this.schedule();
      } else {
        subscriber.complete();
      }
    });
  } : function(subscriber) {
    var n = start;
    while (n < end && !subscriber.closed) {
      subscriber.next(n++);
    }
    subscriber.complete();
  });
}

// node_modules/rxjs/dist/esm5/internal/observable/using.js
function using(resourceFactory, observableFactory) {
  return new Observable(function(subscriber) {
    var resource = resourceFactory();
    var result = observableFactory(resource);
    var source = result ? innerFrom(result) : EMPTY;
    source.subscribe(subscriber);
    return function() {
      if (resource) {
        resource.unsubscribe();
      }
    };
  });
}

export {
  animationFrames,
  asapScheduler,
  asap,
  queueScheduler,
  queue,
  animationFrameScheduler,
  animationFrame,
  VirtualTimeScheduler,
  VirtualAction,
  isObservable,
  lastValueFrom,
  firstValueFrom,
  bindCallback,
  bindNodeCallback,
  defer,
  connectable,
  forkJoin,
  fromEvent,
  fromEventPattern,
  generate,
  iif,
  merge,
  NEVER,
  never,
  pairs,
  partition,
  range,
  using
};
//# sourceMappingURL=chunk-HHOT2EEL.js.map



================================================
FILE: .angular/cache/18.2.20/angular-pivothead-example/vite/deps/chunk-JBLJVEST.js
================================================
import {
  __async,
  __spreadProps,
  __spreadValues
} from "./chunk-WDMUDEB6.js";

// node_modules/@mindfiredigital/pivothead-angular/node_modules/@mindfiredigital/pivothead-web-component/node_modules/@mindfiredigital/pivothead/dist/index-da0a407c.mjs
function Dh(r6, e, t) {
  if (!r6 || r6.length === 0) return 0;
  const n = r6.map((i) => Number(i[e]) || 0);
  switch (t) {
    case "sum":
      return n.reduce((i, a) => i + a, 0);
    case "avg":
      return n.reduce((i, a) => i + a, 0) / n.length;
    case "min":
      return Math.min(...n);
    case "max":
      return Math.max(...n);
    case "count":
      return n.length;
    default:
      return 0;
  }
}
function Y2(r6, e, t) {
  return !e || e.length === 0 ? r6 : [...r6].sort((n, i) => {
    for (const a of e) {
      const {
        field: s,
        direction: o,
        type: f,
        aggregation: h
      } = a;
      if (f === "measure") {
        const c = Oh(n, s), p = Oh(i, s);
        if (c !== p) return o === "asc" ? c - p : p - c;
      } else {
        const c = n[s], p = i[s];
        if (c !== p) return o === "asc" ? c < p ? -1 : 1 : c > p ? -1 : 1;
      }
    }
    return 0;
  });
}
function Oh(r6, e, t) {
  return Number(r6[e]) || 0;
}
function $2(r6, e = null, t = null) {
  let n = [...r6.data || []];
  e && (n = Y2(n, [e]));
  let i = [];
  if (t) {
    const {
      rowFields: a,
      columnFields: s,
      grouper: o
    } = t, f = [...a, ...s];
    i = Yc(n, f, o);
  }
  return {
    rawData: n,
    groups: i
  };
}
function Yc(r6, e, t) {
  if (!e || e.length === 0) return [{
    key: "All",
    items: r6,
    subgroups: [],
    aggregates: {}
  }];
  const n = {};
  return r6.forEach((i) => {
    const a = t(i, e);
    n[a] || (n[a] = {
      key: a,
      items: [],
      subgroups: [],
      aggregates: {}
    }), n[a].items.push(i);
  }), e.length > 1 && Object.values(n).forEach((i) => {
    i.subgroups = Yc(i.items, e.slice(1), t);
  }), Object.values(n);
}
var M0 = {};
M0.version = "0.18.5";
var $c = 1252;
var K2 = [874, 932, 936, 949, 950, 1250, 1251, 1252, 1253, 1254, 1255, 1256, 1257, 1258, 1e4];
var Kc = function(r6) {
  K2.indexOf(r6) != -1 && ($c = r6);
};
function J2() {
  Kc(1252);
}
var _o = function(r6) {
  Kc(r6);
};
function Z2() {
  _o(1200), J2();
}
function Q2(r6) {
  for (var e = [], t = 0; t < r6.length >> 1; ++t) e[t] = String.fromCharCode(r6.charCodeAt(2 * t + 1) + (r6.charCodeAt(2 * t) << 8));
  return e.join("");
}
var _0 = function(e) {
  return String.fromCharCode(e);
};
var Ih = function(e) {
  return String.fromCharCode(e);
};
var Ea;
var sa = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
function So(r6) {
  for (var e = "", t = 0, n = 0, i = 0, a = 0, s = 0, o = 0, f = 0, h = 0; h < r6.length; ) t = r6.charCodeAt(h++), a = t >> 2, n = r6.charCodeAt(h++), s = (t & 3) << 4 | n >> 4, i = r6.charCodeAt(h++), o = (n & 15) << 2 | i >> 6, f = i & 63, isNaN(n) ? o = f = 64 : isNaN(i) && (f = 64), e += sa.charAt(a) + sa.charAt(s) + sa.charAt(o) + sa.charAt(f);
  return e;
}
function ji(r6) {
  var e = "", t = 0, n = 0, i = 0, a = 0, s = 0, o = 0, f = 0;
  r6 = r6.replace(/[^\w\+\/\=]/g, "");
  for (var h = 0; h < r6.length; ) a = sa.indexOf(r6.charAt(h++)), s = sa.indexOf(r6.charAt(h++)), t = a << 2 | s >> 4, e += String.fromCharCode(t), o = sa.indexOf(r6.charAt(h++)), n = (s & 15) << 4 | o >> 2, o !== 64 && (e += String.fromCharCode(n)), f = sa.indexOf(r6.charAt(h++)), i = (o & 3) << 6 | f, f !== 64 && (e += String.fromCharCode(i));
  return e;
}
var It = function() {
  return typeof Buffer < "u" && typeof process < "u" && typeof process.versions < "u" && !!process.versions.node;
}();
var Hi = function() {
  if (typeof Buffer < "u") {
    var r6 = !Buffer.from;
    if (!r6) try {
      Buffer.from("foo", "utf8");
    } catch {
      r6 = true;
    }
    return r6 ? function(e, t) {
      return t ? new Buffer(e, t) : new Buffer(e);
    } : Buffer.from.bind(Buffer);
  }
  return function() {
  };
}();
function Pa(r6) {
  return It ? Buffer.alloc ? Buffer.alloc(r6) : new Buffer(r6) : typeof Uint8Array < "u" ? new Uint8Array(r6) : new Array(r6);
}
function Rh(r6) {
  return It ? Buffer.allocUnsafe ? Buffer.allocUnsafe(r6) : new Buffer(r6) : typeof Uint8Array < "u" ? new Uint8Array(r6) : new Array(r6);
}
var ri = function(e) {
  return It ? Hi(e, "binary") : e.split("").map(function(t) {
    return t.charCodeAt(0) & 255;
  });
};
function tf(r6) {
  if (typeof ArrayBuffer > "u") return ri(r6);
  for (var e = new ArrayBuffer(r6.length), t = new Uint8Array(e), n = 0; n != r6.length; ++n) t[n] = r6.charCodeAt(n) & 255;
  return e;
}
function Fo(r6) {
  if (Array.isArray(r6)) return r6.map(function(n) {
    return String.fromCharCode(n);
  }).join("");
  for (var e = [], t = 0; t < r6.length; ++t) e[t] = String.fromCharCode(r6[t]);
  return e.join("");
}
function ed(r6) {
  if (typeof Uint8Array > "u") throw new Error("Unsupported");
  return new Uint8Array(r6);
}
var jr = It ? function(r6) {
  return Buffer.concat(r6.map(function(e) {
    return Buffer.isBuffer(e) ? e : Hi(e);
  }));
} : function(r6) {
  if (typeof Uint8Array < "u") {
    var e = 0, t = 0;
    for (e = 0; e < r6.length; ++e) t += r6[e].length;
    var n = new Uint8Array(t), i = 0;
    for (e = 0, t = 0; e < r6.length; t += i, ++e) if (i = r6[e].length, r6[e] instanceof Uint8Array) n.set(r6[e], t);
    else {
      if (typeof r6[e] == "string") throw "wtf";
      n.set(new Uint8Array(r6[e]), t);
    }
    return n;
  }
  return [].concat.apply([], r6.map(function(a) {
    return Array.isArray(a) ? a : [].slice.call(a);
  }));
};
function td(r6) {
  for (var e = [], t = 0, n = r6.length + 250, i = Pa(r6.length + 255), a = 0; a < r6.length; ++a) {
    var s = r6.charCodeAt(a);
    if (s < 128) i[t++] = s;
    else if (s < 2048) i[t++] = 192 | s >> 6 & 31, i[t++] = 128 | s & 63;
    else if (s >= 55296 && s < 57344) {
      s = (s & 1023) + 64;
      var o = r6.charCodeAt(++a) & 1023;
      i[t++] = 240 | s >> 8 & 7, i[t++] = 128 | s >> 2 & 63, i[t++] = 128 | o >> 6 & 15 | (s & 3) << 4, i[t++] = 128 | o & 63;
    } else i[t++] = 224 | s >> 12 & 15, i[t++] = 128 | s >> 6 & 63, i[t++] = 128 | s & 63;
    t > n && (e.push(i.slice(0, t)), t = 0, i = Pa(65535), n = 65530);
  }
  return e.push(i.slice(0, t)), jr(e);
}
var uo = /\u0000/g;
var S0 = /[\u0001-\u0006]/g;
function xs(r6) {
  for (var e = "", t = r6.length - 1; t >= 0; ) e += r6.charAt(t--);
  return e;
}
function ni(r6, e) {
  var t = "" + r6;
  return t.length >= e ? t : fr("0", e - t.length) + t;
}
function Il(r6, e) {
  var t = "" + r6;
  return t.length >= e ? t : fr(" ", e - t.length) + t;
}
function B0(r6, e) {
  var t = "" + r6;
  return t.length >= e ? t : t + fr(" ", e - t.length);
}
function rd(r6, e) {
  var t = "" + Math.round(r6);
  return t.length >= e ? t : fr("0", e - t.length) + t;
}
function nd(r6, e) {
  var t = "" + r6;
  return t.length >= e ? t : fr("0", e - t.length) + t;
}
var Mh = Math.pow(2, 32);
function fs(r6, e) {
  if (r6 > Mh || r6 < -Mh) return rd(r6, e);
  var t = Math.round(r6);
  return nd(t, e);
}
function j0(r6, e) {
  return e = e || 0, r6.length >= 7 + e && (r6.charCodeAt(e) | 32) === 103 && (r6.charCodeAt(e + 1) | 32) === 101 && (r6.charCodeAt(e + 2) | 32) === 110 && (r6.charCodeAt(e + 3) | 32) === 101 && (r6.charCodeAt(e + 4) | 32) === 114 && (r6.charCodeAt(e + 5) | 32) === 97 && (r6.charCodeAt(e + 6) | 32) === 108;
}
var Bh = [["Sun", "Sunday"], ["Mon", "Monday"], ["Tue", "Tuesday"], ["Wed", "Wednesday"], ["Thu", "Thursday"], ["Fri", "Friday"], ["Sat", "Saturday"]];
var Kf = [["J", "Jan", "January"], ["F", "Feb", "February"], ["M", "Mar", "March"], ["A", "Apr", "April"], ["M", "May", "May"], ["J", "Jun", "June"], ["J", "Jul", "July"], ["A", "Aug", "August"], ["S", "Sep", "September"], ["O", "Oct", "October"], ["N", "Nov", "November"], ["D", "Dec", "December"]];
function id(r6) {
  return r6 || (r6 = {}), r6[0] = "General", r6[1] = "0", r6[2] = "0.00", r6[3] = "#,##0", r6[4] = "#,##0.00", r6[9] = "0%", r6[10] = "0.00%", r6[11] = "0.00E+00", r6[12] = "# ?/?", r6[13] = "# ??/??", r6[14] = "m/d/yy", r6[15] = "d-mmm-yy", r6[16] = "d-mmm", r6[17] = "mmm-yy", r6[18] = "h:mm AM/PM", r6[19] = "h:mm:ss AM/PM", r6[20] = "h:mm", r6[21] = "h:mm:ss", r6[22] = "m/d/yy h:mm", r6[37] = "#,##0 ;(#,##0)", r6[38] = "#,##0 ;[Red](#,##0)", r6[39] = "#,##0.00;(#,##0.00)", r6[40] = "#,##0.00;[Red](#,##0.00)", r6[45] = "mm:ss", r6[46] = "[h]:mm:ss", r6[47] = "mmss.0", r6[48] = "##0.0E+0", r6[49] = "@", r6[56] = '"上午/下午 "hh"時"mm"分"ss"秒 "', r6;
}
var lr = {
  0: "General",
  1: "0",
  2: "0.00",
  3: "#,##0",
  4: "#,##0.00",
  9: "0%",
  10: "0.00%",
  11: "0.00E+00",
  12: "# ?/?",
  13: "# ??/??",
  14: "m/d/yy",
  15: "d-mmm-yy",
  16: "d-mmm",
  17: "mmm-yy",
  18: "h:mm AM/PM",
  19: "h:mm:ss AM/PM",
  20: "h:mm",
  21: "h:mm:ss",
  22: "m/d/yy h:mm",
  37: "#,##0 ;(#,##0)",
  38: "#,##0 ;[Red](#,##0)",
  39: "#,##0.00;(#,##0.00)",
  40: "#,##0.00;[Red](#,##0.00)",
  45: "mm:ss",
  46: "[h]:mm:ss",
  47: "mmss.0",
  48: "##0.0E+0",
  49: "@",
  56: '"上午/下午 "hh"時"mm"分"ss"秒 "'
};
var jh = {
  5: 37,
  6: 38,
  7: 39,
  8: 40,
  //  5 -> 37 ...  8 -> 40
  23: 0,
  24: 0,
  25: 0,
  26: 0,
  // 23 ->  0 ... 26 ->  0
  27: 14,
  28: 14,
  29: 14,
  30: 14,
  31: 14,
  // 27 -> 14 ... 31 -> 14
  50: 14,
  51: 14,
  52: 14,
  53: 14,
  54: 14,
  // 50 -> 14 ... 58 -> 14
  55: 14,
  56: 14,
  57: 14,
  58: 14,
  59: 1,
  60: 2,
  61: 3,
  62: 4,
  // 59 ->  1 ... 62 ->  4
  67: 9,
  68: 10,
  // 67 ->  9 ... 68 -> 10
  69: 12,
  70: 13,
  71: 14,
  // 69 -> 12 ... 71 -> 14
  72: 14,
  73: 15,
  74: 16,
  75: 17,
  // 72 -> 14 ... 75 -> 17
  76: 20,
  77: 21,
  78: 22,
  // 76 -> 20 ... 78 -> 22
  79: 45,
  80: 46,
  81: 47,
  // 79 -> 45 ... 81 -> 47
  82: 0
  // 82 ->  0 ... 65536 -> 0 (omitted)
};
var ad = {
  //  5 -- Currency,   0 decimal, black negative
  5: '"$"#,##0_);\\("$"#,##0\\)',
  63: '"$"#,##0_);\\("$"#,##0\\)',
  //  6 -- Currency,   0 decimal, red   negative
  6: '"$"#,##0_);[Red]\\("$"#,##0\\)',
  64: '"$"#,##0_);[Red]\\("$"#,##0\\)',
  //  7 -- Currency,   2 decimal, black negative
  7: '"$"#,##0.00_);\\("$"#,##0.00\\)',
  65: '"$"#,##0.00_);\\("$"#,##0.00\\)',
  //  8 -- Currency,   2 decimal, red   negative
  8: '"$"#,##0.00_);[Red]\\("$"#,##0.00\\)',
  66: '"$"#,##0.00_);[Red]\\("$"#,##0.00\\)',
  // 41 -- Accounting, 0 decimal, No Symbol
  41: '_(* #,##0_);_(* \\(#,##0\\);_(* "-"_);_(@_)',
  // 42 -- Accounting, 0 decimal, $  Symbol
  42: '_("$"* #,##0_);_("$"* \\(#,##0\\);_("$"* "-"_);_(@_)',
  // 43 -- Accounting, 2 decimal, No Symbol
  43: '_(* #,##0.00_);_(* \\(#,##0.00\\);_(* "-"??_);_(@_)',
  // 44 -- Accounting, 2 decimal, $  Symbol
  44: '_("$"* #,##0.00_);_("$"* \\(#,##0.00\\);_("$"* "-"??_);_(@_)'
};
function U0(r6, e, t) {
  for (var n = r6 < 0 ? -1 : 1, i = r6 * n, a = 0, s = 1, o = 0, f = 1, h = 0, c = 0, p = Math.floor(i); h < e && (p = Math.floor(i), o = p * s + a, c = p * h + f, !(i - p < 5e-8)); ) i = 1 / (i - p), a = s, s = o, f = h, h = c;
  if (c > e && (h > e ? (c = f, o = a) : (c = h, o = s)), !t) return [0, n * o, c];
  var v = Math.floor(n * o / c);
  return [v, n * o - v * c, c];
}
function A0(r6, e, t) {
  if (r6 > 2958465 || r6 < 0) return null;
  var n = r6 | 0, i = Math.floor(86400 * (r6 - n)), a = 0, s = [], o = {
    D: n,
    T: i,
    u: 86400 * (r6 - n) - i,
    y: 0,
    m: 0,
    d: 0,
    H: 0,
    M: 0,
    S: 0,
    q: 0
  };
  if (Math.abs(o.u) < 1e-6 && (o.u = 0), e && e.date1904 && (n += 1462), o.u > 0.9999 && (o.u = 0, ++i == 86400 && (o.T = i = 0, ++n, ++o.D)), n === 60) s = t ? [1317, 10, 29] : [1900, 2, 29], a = 3;
  else if (n === 0) s = t ? [1317, 8, 29] : [1900, 1, 0], a = 6;
  else {
    n > 60 && --n;
    var f = new Date(1900, 0, 1);
    f.setDate(f.getDate() + n - 1), s = [f.getFullYear(), f.getMonth() + 1, f.getDate()], a = f.getDay(), n < 60 && (a = (a + 6) % 7), t && (a = ud(f, s));
  }
  return o.y = s[0], o.m = s[1], o.d = s[2], o.S = i % 60, i = Math.floor(i / 60), o.M = i % 60, i = Math.floor(i / 60), o.H = i, o.q = a, o;
}
var Jc = new Date(1899, 11, 31, 0, 0, 0);
var sd = Jc.getTime();
var od = new Date(1900, 2, 1, 0, 0, 0);
function Zc(r6, e) {
  var t = r6.getTime();
  return e ? t -= 1461 * 24 * 60 * 60 * 1e3 : r6 >= od && (t += 24 * 60 * 60 * 1e3), (t - (sd + (r6.getTimezoneOffset() - Jc.getTimezoneOffset()) * 6e4)) / (24 * 60 * 60 * 1e3);
}
function Rl(r6) {
  return r6.indexOf(".") == -1 ? r6 : r6.replace(/(?:\.0*|(\.\d*[1-9])0+)$/, "$1");
}
function fd(r6) {
  return r6.indexOf("E") == -1 ? r6 : r6.replace(/(?:\.0*|(\.\d*[1-9])0+)[Ee]/, "$1E").replace(/(E[+-])(\d)$/, "$10$2");
}
function ld(r6) {
  var e = r6 < 0 ? 12 : 11, t = Rl(r6.toFixed(12));
  return t.length <= e || (t = r6.toPrecision(10), t.length <= e) ? t : r6.toExponential(5);
}
function hd(r6) {
  var e = Rl(r6.toFixed(11));
  return e.length > (r6 < 0 ? 12 : 11) || e === "0" || e === "-0" ? r6.toPrecision(6) : e;
}
function cd(r6) {
  var e = Math.floor(Math.log(Math.abs(r6)) * Math.LOG10E), t;
  return e >= -4 && e <= -1 ? t = r6.toPrecision(10 + e) : Math.abs(e) <= 9 ? t = ld(r6) : e === 10 ? t = r6.toFixed(10).substr(0, 12) : t = hd(r6), Rl(fd(t.toUpperCase()));
}
function ml(r6, e) {
  switch (typeof r6) {
    case "string":
      return r6;
    case "boolean":
      return r6 ? "TRUE" : "FALSE";
    case "number":
      return (r6 | 0) === r6 ? r6.toString(10) : cd(r6);
    case "undefined":
      return "";
    case "object":
      if (r6 == null) return "";
      if (r6 instanceof Date) return la(14, Zc(r6, e && e.date1904), e);
  }
  throw new Error("unsupported value in General format: " + r6);
}
function ud(r6, e) {
  e[0] -= 581;
  var t = r6.getDay();
  return r6 < 60 && (t = (t + 6) % 7), t;
}
function dd(r6, e, t, n) {
  var i = "", a = 0, s = 0, o = t.y, f, h = 0;
  switch (r6) {
    case 98:
      o = t.y + 543;
    case 121:
      switch (e.length) {
        case 1:
        case 2:
          f = o % 100, h = 2;
          break;
        default:
          f = o % 1e4, h = 4;
          break;
      }
      break;
    case 109:
      switch (e.length) {
        case 1:
        case 2:
          f = t.m, h = e.length;
          break;
        case 3:
          return Kf[t.m - 1][1];
        case 5:
          return Kf[t.m - 1][0];
        default:
          return Kf[t.m - 1][2];
      }
      break;
    case 100:
      switch (e.length) {
        case 1:
        case 2:
          f = t.d, h = e.length;
          break;
        case 3:
          return Bh[t.q][0];
        default:
          return Bh[t.q][1];
      }
      break;
    case 104:
      switch (e.length) {
        case 1:
        case 2:
          f = 1 + (t.H + 11) % 12, h = e.length;
          break;
        default:
          throw "bad hour format: " + e;
      }
      break;
    case 72:
      switch (e.length) {
        case 1:
        case 2:
          f = t.H, h = e.length;
          break;
        default:
          throw "bad hour format: " + e;
      }
      break;
    case 77:
      switch (e.length) {
        case 1:
        case 2:
          f = t.M, h = e.length;
          break;
        default:
          throw "bad minute format: " + e;
      }
      break;
    case 115:
      if (e != "s" && e != "ss" && e != ".0" && e != ".00" && e != ".000") throw "bad second format: " + e;
      return t.u === 0 && (e == "s" || e == "ss") ? ni(t.S, e.length) : (n >= 2 ? s = n === 3 ? 1e3 : 100 : s = n === 1 ? 10 : 1, a = Math.round(s * (t.S + t.u)), a >= 60 * s && (a = 0), e === "s" ? a === 0 ? "0" : "" + a / s : (i = ni(a, 2 + n), e === "ss" ? i.substr(0, 2) : "." + i.substr(2, e.length - 1)));
    case 90:
      switch (e) {
        case "[h]":
        case "[hh]":
          f = t.D * 24 + t.H;
          break;
        case "[m]":
        case "[mm]":
          f = (t.D * 24 + t.H) * 60 + t.M;
          break;
        case "[s]":
        case "[ss]":
          f = ((t.D * 24 + t.H) * 60 + t.M) * 60 + Math.round(t.S + t.u);
          break;
        default:
          throw "bad abstime format: " + e;
      }
      h = e.length === 3 ? 1 : 2;
      break;
    case 101:
      f = o, h = 1;
      break;
  }
  var c = h > 0 ? ni(f, h) : "";
  return c;
}
function oa(r6) {
  var e = 3;
  if (r6.length <= e) return r6;
  for (var t = r6.length % e, n = r6.substr(0, t); t != r6.length; t += e) n += (n.length > 0 ? "," : "") + r6.substr(t, e);
  return n;
}
var Qc = /%/g;
function pd(r6, e, t) {
  var n = e.replace(Qc, ""), i = e.length - n.length;
  return Ri(r6, n, t * Math.pow(10, 2 * i)) + fr("%", i);
}
function gd(r6, e, t) {
  for (var n = e.length - 1; e.charCodeAt(n - 1) === 44; ) --n;
  return Ri(r6, e.substr(0, n), t / Math.pow(10, 3 * (e.length - n)));
}
function eu(r6, e) {
  var t, n = r6.indexOf("E") - r6.indexOf(".") - 1;
  if (r6.match(/^#+0.0E\+0$/)) {
    if (e == 0) return "0.0E+0";
    if (e < 0) return "-" + eu(r6, -e);
    var i = r6.indexOf(".");
    i === -1 && (i = r6.indexOf("E"));
    var a = Math.floor(Math.log(e) * Math.LOG10E) % i;
    if (a < 0 && (a += i), t = (e / Math.pow(10, a)).toPrecision(n + 1 + (i + a) % i), t.indexOf("e") === -1) {
      var s = Math.floor(Math.log(e) * Math.LOG10E);
      for (t.indexOf(".") === -1 ? t = t.charAt(0) + "." + t.substr(1) + "E+" + (s - t.length + a) : t += "E+" + (s - a); t.substr(0, 2) === "0."; ) t = t.charAt(0) + t.substr(2, i) + "." + t.substr(2 + i), t = t.replace(/^0+([1-9])/, "$1").replace(/^0+\./, "0.");
      t = t.replace(/\+-/, "-");
    }
    t = t.replace(/^([+-]?)(\d*)\.(\d*)[Ee]/, function(o, f, h, c) {
      return f + h + c.substr(0, (i + a) % i) + "." + c.substr(a) + "E";
    });
  } else t = e.toExponential(n);
  return r6.match(/E\+00$/) && t.match(/e[+-]\d$/) && (t = t.substr(0, t.length - 1) + "0" + t.charAt(t.length - 1)), r6.match(/E\-/) && t.match(/e\+/) && (t = t.replace(/e\+/, "e")), t.replace("e", "E");
}
var tu = /# (\?+)( ?)\/( ?)(\d+)/;
function vd(r6, e, t) {
  var n = parseInt(r6[4], 10), i = Math.round(e * n), a = Math.floor(i / n), s = i - a * n, o = n;
  return t + (a === 0 ? "" : "" + a) + " " + (s === 0 ? fr(" ", r6[1].length + 1 + r6[4].length) : Il(s, r6[1].length) + r6[2] + "/" + r6[3] + ni(o, r6[4].length));
}
function md(r6, e, t) {
  return t + (e === 0 ? "" : "" + e) + fr(" ", r6[1].length + 2 + r6[4].length);
}
var ru = /^#*0*\.([0#]+)/;
var nu = /\).*[0#]/;
var iu = /\(###\) ###\\?-####/;
function rn(r6) {
  for (var e = "", t, n = 0; n != r6.length; ++n) switch (t = r6.charCodeAt(n)) {
    case 35:
      break;
    case 63:
      e += " ";
      break;
    case 48:
      e += "0";
      break;
    default:
      e += String.fromCharCode(t);
  }
  return e;
}
function Uh(r6, e) {
  var t = Math.pow(10, e);
  return "" + Math.round(r6 * t) / t;
}
function qh(r6, e) {
  var t = r6 - Math.floor(r6), n = Math.pow(10, e);
  return e < ("" + Math.round(t * n)).length ? 0 : Math.round(t * n);
}
function xd(r6, e) {
  return e < ("" + Math.round((r6 - Math.floor(r6)) * Math.pow(10, e))).length ? 1 : 0;
}
function wd(r6) {
  return r6 < 2147483647 && r6 > -2147483648 ? "" + (r6 >= 0 ? r6 | 0 : r6 - 1 | 0) : "" + Math.floor(r6);
}
function Un(r6, e, t) {
  if (r6.charCodeAt(0) === 40 && !e.match(nu)) {
    var n = e.replace(/\( */, "").replace(/ \)/, "").replace(/\)/, "");
    return t >= 0 ? Un("n", n, t) : "(" + Un("n", n, -t) + ")";
  }
  if (e.charCodeAt(e.length - 1) === 44) return gd(r6, e, t);
  if (e.indexOf("%") !== -1) return pd(r6, e, t);
  if (e.indexOf("E") !== -1) return eu(e, t);
  if (e.charCodeAt(0) === 36) return "$" + Un(r6, e.substr(e.charAt(1) == " " ? 2 : 1), t);
  var i, a, s, o, f = Math.abs(t), h = t < 0 ? "-" : "";
  if (e.match(/^00+$/)) return h + fs(f, e.length);
  if (e.match(/^[#?]+$/)) return i = fs(t, 0), i === "0" && (i = ""), i.length > e.length ? i : rn(e.substr(0, e.length - i.length)) + i;
  if (a = e.match(tu)) return vd(a, f, h);
  if (e.match(/^#+0+$/)) return h + fs(f, e.length - e.indexOf("0"));
  if (a = e.match(ru)) return i = Uh(t, a[1].length).replace(/^([^\.]+)$/, "$1." + rn(a[1])).replace(/\.$/, "." + rn(a[1])).replace(/\.(\d*)$/, function(w, x) {
    return "." + x + fr("0", rn(
      /*::(*/
      a[1]
    ).length - x.length);
  }), e.indexOf("0.") !== -1 ? i : i.replace(/^0\./, ".");
  if (e = e.replace(/^#+([0.])/, "$1"), a = e.match(/^(0*)\.(#*)$/)) return h + Uh(f, a[2].length).replace(/\.(\d*[1-9])0*$/, ".$1").replace(/^(-?\d*)$/, "$1.").replace(/^0\./, a[1].length ? "0." : ".");
  if (a = e.match(/^#{1,3},##0(\.?)$/)) return h + oa(fs(f, 0));
  if (a = e.match(/^#,##0\.([#0]*0)$/)) return t < 0 ? "-" + Un(r6, e, -t) : oa("" + (Math.floor(t) + xd(t, a[1].length))) + "." + ni(qh(t, a[1].length), a[1].length);
  if (a = e.match(/^#,#*,#0/)) return Un(r6, e.replace(/^#,#*,/, ""), t);
  if (a = e.match(/^([0#]+)(\\?-([0#]+))+$/)) return i = xs(Un(r6, e.replace(/[\\-]/g, ""), t)), s = 0, xs(xs(e.replace(/\\/g, "")).replace(/[0#]/g, function(w) {
    return s < i.length ? i.charAt(s++) : w === "0" ? "0" : "";
  }));
  if (e.match(iu)) return i = Un(r6, "##########", t), "(" + i.substr(0, 3) + ") " + i.substr(3, 3) + "-" + i.substr(6);
  var c = "";
  if (a = e.match(/^([#0?]+)( ?)\/( ?)([#0?]+)/)) return s = Math.min(
    /*::String(*/
    a[4].length,
    7
  ), o = U0(f, Math.pow(10, s) - 1, false), i = "" + h, c = Ri(
    "n",
    /*::String(*/
    a[1],
    o[1]
  ), c.charAt(c.length - 1) == " " && (c = c.substr(0, c.length - 1) + "0"), i += c + /*::String(*/
  a[2] + "/" + /*::String(*/
  a[3], c = B0(o[2], s), c.length < a[4].length && (c = rn(a[4].substr(a[4].length - c.length)) + c), i += c, i;
  if (a = e.match(/^# ([#0?]+)( ?)\/( ?)([#0?]+)/)) return s = Math.min(Math.max(a[1].length, a[4].length), 7), o = U0(f, Math.pow(10, s) - 1, true), h + (o[0] || (o[1] ? "" : "0")) + " " + (o[1] ? Il(o[1], s) + a[2] + "/" + a[3] + B0(o[2], s) : fr(" ", 2 * s + 1 + a[2].length + a[3].length));
  if (a = e.match(/^[#0?]+$/)) return i = fs(t, 0), e.length <= i.length ? i : rn(e.substr(0, e.length - i.length)) + i;
  if (a = e.match(/^([#0?]+)\.([#0]+)$/)) {
    i = "" + t.toFixed(Math.min(a[2].length, 10)).replace(/([^0])0+$/, "$1"), s = i.indexOf(".");
    var p = e.indexOf(".") - s, v = e.length - i.length - p;
    return rn(e.substr(0, p) + i + e.substr(e.length - v));
  }
  if (a = e.match(/^00,000\.([#0]*0)$/)) return s = qh(t, a[1].length), t < 0 ? "-" + Un(r6, e, -t) : oa(wd(t)).replace(/^\d,\d{3}$/, "0$&").replace(/^\d*$/, function(w) {
    return "00," + (w.length < 3 ? ni(0, 3 - w.length) : "") + w;
  }) + "." + ni(s, a[1].length);
  switch (e) {
    case "###,##0.00":
      return Un(r6, "#,##0.00", t);
    case "###,###":
    case "##,###":
    case "#,###":
      var d = oa(fs(f, 0));
      return d !== "0" ? h + d : "";
    case "###,###.00":
      return Un(r6, "###,##0.00", t).replace(/^0\./, ".");
    case "#,###.00":
      return Un(r6, "#,##0.00", t).replace(/^0\./, ".");
  }
  throw new Error("unsupported format |" + e + "|");
}
function yd(r6, e, t) {
  for (var n = e.length - 1; e.charCodeAt(n - 1) === 44; ) --n;
  return Ri(r6, e.substr(0, n), t / Math.pow(10, 3 * (e.length - n)));
}
function _d(r6, e, t) {
  var n = e.replace(Qc, ""), i = e.length - n.length;
  return Ri(r6, n, t * Math.pow(10, 2 * i)) + fr("%", i);
}
function au(r6, e) {
  var t, n = r6.indexOf("E") - r6.indexOf(".") - 1;
  if (r6.match(/^#+0.0E\+0$/)) {
    if (e == 0) return "0.0E+0";
    if (e < 0) return "-" + au(r6, -e);
    var i = r6.indexOf(".");
    i === -1 && (i = r6.indexOf("E"));
    var a = Math.floor(Math.log(e) * Math.LOG10E) % i;
    if (a < 0 && (a += i), t = (e / Math.pow(10, a)).toPrecision(n + 1 + (i + a) % i), !t.match(/[Ee]/)) {
      var s = Math.floor(Math.log(e) * Math.LOG10E);
      t.indexOf(".") === -1 ? t = t.charAt(0) + "." + t.substr(1) + "E+" + (s - t.length + a) : t += "E+" + (s - a), t = t.replace(/\+-/, "-");
    }
    t = t.replace(/^([+-]?)(\d*)\.(\d*)[Ee]/, function(o, f, h, c) {
      return f + h + c.substr(0, (i + a) % i) + "." + c.substr(a) + "E";
    });
  } else t = e.toExponential(n);
  return r6.match(/E\+00$/) && t.match(/e[+-]\d$/) && (t = t.substr(0, t.length - 1) + "0" + t.charAt(t.length - 1)), r6.match(/E\-/) && t.match(/e\+/) && (t = t.replace(/e\+/, "e")), t.replace("e", "E");
}
function pi(r6, e, t) {
  if (r6.charCodeAt(0) === 40 && !e.match(nu)) {
    var n = e.replace(/\( */, "").replace(/ \)/, "").replace(/\)/, "");
    return t >= 0 ? pi("n", n, t) : "(" + pi("n", n, -t) + ")";
  }
  if (e.charCodeAt(e.length - 1) === 44) return yd(r6, e, t);
  if (e.indexOf("%") !== -1) return _d(r6, e, t);
  if (e.indexOf("E") !== -1) return au(e, t);
  if (e.charCodeAt(0) === 36) return "$" + pi(r6, e.substr(e.charAt(1) == " " ? 2 : 1), t);
  var i, a, s, o, f = Math.abs(t), h = t < 0 ? "-" : "";
  if (e.match(/^00+$/)) return h + ni(f, e.length);
  if (e.match(/^[#?]+$/)) return i = "" + t, t === 0 && (i = ""), i.length > e.length ? i : rn(e.substr(0, e.length - i.length)) + i;
  if (a = e.match(tu)) return md(a, f, h);
  if (e.match(/^#+0+$/)) return h + ni(f, e.length - e.indexOf("0"));
  if (a = e.match(ru)) return i = ("" + t).replace(/^([^\.]+)$/, "$1." + rn(a[1])).replace(/\.$/, "." + rn(a[1])), i = i.replace(/\.(\d*)$/, function(w, x) {
    return "." + x + fr("0", rn(a[1]).length - x.length);
  }), e.indexOf("0.") !== -1 ? i : i.replace(/^0\./, ".");
  if (e = e.replace(/^#+([0.])/, "$1"), a = e.match(/^(0*)\.(#*)$/)) return h + ("" + f).replace(/\.(\d*[1-9])0*$/, ".$1").replace(/^(-?\d*)$/, "$1.").replace(/^0\./, a[1].length ? "0." : ".");
  if (a = e.match(/^#{1,3},##0(\.?)$/)) return h + oa("" + f);
  if (a = e.match(/^#,##0\.([#0]*0)$/)) return t < 0 ? "-" + pi(r6, e, -t) : oa("" + t) + "." + fr("0", a[1].length);
  if (a = e.match(/^#,#*,#0/)) return pi(r6, e.replace(/^#,#*,/, ""), t);
  if (a = e.match(/^([0#]+)(\\?-([0#]+))+$/)) return i = xs(pi(r6, e.replace(/[\\-]/g, ""), t)), s = 0, xs(xs(e.replace(/\\/g, "")).replace(/[0#]/g, function(w) {
    return s < i.length ? i.charAt(s++) : w === "0" ? "0" : "";
  }));
  if (e.match(iu)) return i = pi(r6, "##########", t), "(" + i.substr(0, 3) + ") " + i.substr(3, 3) + "-" + i.substr(6);
  var c = "";
  if (a = e.match(/^([#0?]+)( ?)\/( ?)([#0?]+)/)) return s = Math.min(
    /*::String(*/
    a[4].length,
    7
  ), o = U0(f, Math.pow(10, s) - 1, false), i = "" + h, c = Ri(
    "n",
    /*::String(*/
    a[1],
    o[1]
  ), c.charAt(c.length - 1) == " " && (c = c.substr(0, c.length - 1) + "0"), i += c + /*::String(*/
  a[2] + "/" + /*::String(*/
  a[3], c = B0(o[2], s), c.length < a[4].length && (c = rn(a[4].substr(a[4].length - c.length)) + c), i += c, i;
  if (a = e.match(/^# ([#0?]+)( ?)\/( ?)([#0?]+)/)) return s = Math.min(Math.max(a[1].length, a[4].length), 7), o = U0(f, Math.pow(10, s) - 1, true), h + (o[0] || (o[1] ? "" : "0")) + " " + (o[1] ? Il(o[1], s) + a[2] + "/" + a[3] + B0(o[2], s) : fr(" ", 2 * s + 1 + a[2].length + a[3].length));
  if (a = e.match(/^[#0?]+$/)) return i = "" + t, e.length <= i.length ? i : rn(e.substr(0, e.length - i.length)) + i;
  if (a = e.match(/^([#0]+)\.([#0]+)$/)) {
    i = "" + t.toFixed(Math.min(a[2].length, 10)).replace(/([^0])0+$/, "$1"), s = i.indexOf(".");
    var p = e.indexOf(".") - s, v = e.length - i.length - p;
    return rn(e.substr(0, p) + i + e.substr(e.length - v));
  }
  if (a = e.match(/^00,000\.([#0]*0)$/)) return t < 0 ? "-" + pi(r6, e, -t) : oa("" + t).replace(/^\d,\d{3}$/, "0$&").replace(/^\d*$/, function(w) {
    return "00," + (w.length < 3 ? ni(0, 3 - w.length) : "") + w;
  }) + "." + ni(0, a[1].length);
  switch (e) {
    case "###,###":
    case "##,###":
    case "#,###":
      var d = oa("" + f);
      return d !== "0" ? h + d : "";
    default:
      if (e.match(/\.[0#?]*$/)) return pi(r6, e.slice(0, e.lastIndexOf(".")), t) + rn(e.slice(e.lastIndexOf(".")));
  }
  throw new Error("unsupported format |" + e + "|");
}
function Ri(r6, e, t) {
  return (t | 0) === t ? pi(r6, e, t) : Un(r6, e, t);
}
function Sd(r6) {
  for (var e = [], t = false, n = 0, i = 0; n < r6.length; ++n) switch (
    /*cc=*/
    r6.charCodeAt(n)
  ) {
    case 34:
      t = !t;
      break;
    case 95:
    case 42:
    case 92:
      ++n;
      break;
    case 59:
      e[e.length] = r6.substr(i, n - i), i = n + 1;
  }
  if (e[e.length] = r6.substr(i), t === true) throw new Error("Format |" + r6 + "| unterminated string ");
  return e;
}
var su = /\[[HhMmSs\u0E0A\u0E19\u0E17]*\]/;
function ou(r6) {
  for (var e = 0, t = "", n = ""; e < r6.length; ) switch (t = r6.charAt(e)) {
    case "G":
      j0(r6, e) && (e += 6), e++;
      break;
    case '"':
      for (
        ;
        /*cc=*/
        r6.charCodeAt(++e) !== 34 && e < r6.length;
      ) ;
      ++e;
      break;
    case "\\":
      e += 2;
      break;
    case "_":
      e += 2;
      break;
    case "@":
      ++e;
      break;
    case "B":
    case "b":
      if (r6.charAt(e + 1) === "1" || r6.charAt(e + 1) === "2") return true;
    case "M":
    case "D":
    case "Y":
    case "H":
    case "S":
    case "E":
    case "m":
    case "d":
    case "y":
    case "h":
    case "s":
    case "e":
    case "g":
      return true;
    case "A":
    case "a":
    case "上":
      if (r6.substr(e, 3).toUpperCase() === "A/P" || r6.substr(e, 5).toUpperCase() === "AM/PM" || r6.substr(e, 5).toUpperCase() === "上午/下午") return true;
      ++e;
      break;
    case "[":
      for (n = t; r6.charAt(e++) !== "]" && e < r6.length; ) n += r6.charAt(e);
      if (n.match(su)) return true;
      break;
    case ".":
    case "0":
    case "#":
      for (; e < r6.length && ("0#?.,E+-%".indexOf(t = r6.charAt(++e)) > -1 || t == "\\" && r6.charAt(e + 1) == "-" && "0#".indexOf(r6.charAt(e + 2)) > -1); ) ;
      break;
    case "?":
      for (; r6.charAt(++e) === t; ) ;
      break;
    case "*":
      ++e, (r6.charAt(e) == " " || r6.charAt(e) == "*") && ++e;
      break;
    case "(":
    case ")":
      ++e;
      break;
    case "1":
    case "2":
    case "3":
    case "4":
    case "5":
    case "6":
    case "7":
    case "8":
    case "9":
      for (; e < r6.length && "0123456789".indexOf(r6.charAt(++e)) > -1; ) ;
      break;
    case " ":
      ++e;
      break;
    default:
      ++e;
      break;
  }
  return false;
}
function Ad(r6, e, t, n) {
  for (var i = [], a = "", s = 0, o = "", f = "t", h, c, p, v = "H"; s < r6.length; ) switch (o = r6.charAt(s)) {
    case "G":
      if (!j0(r6, s)) throw new Error("unrecognized character " + o + " in " + r6);
      i[i.length] = {
        t: "G",
        v: "General"
      }, s += 7;
      break;
    case '"':
      for (a = ""; (p = r6.charCodeAt(++s)) !== 34 && s < r6.length; ) a += String.fromCharCode(p);
      i[i.length] = {
        t: "t",
        v: a
      }, ++s;
      break;
    case "\\":
      var d = r6.charAt(++s), w = d === "(" || d === ")" ? d : "t";
      i[i.length] = {
        t: w,
        v: d
      }, ++s;
      break;
    case "_":
      i[i.length] = {
        t: "t",
        v: " "
      }, s += 2;
      break;
    case "@":
      i[i.length] = {
        t: "T",
        v: e
      }, ++s;
      break;
    case "B":
    case "b":
      if (r6.charAt(s + 1) === "1" || r6.charAt(s + 1) === "2") {
        if (h == null && (h = A0(e, t, r6.charAt(s + 1) === "2"), h == null)) return "";
        i[i.length] = {
          t: "X",
          v: r6.substr(s, 2)
        }, f = o, s += 2;
        break;
      }
    case "M":
    case "D":
    case "Y":
    case "H":
    case "S":
    case "E":
      o = o.toLowerCase();
    case "m":
    case "d":
    case "y":
    case "h":
    case "s":
    case "e":
    case "g":
      if (e < 0 || h == null && (h = A0(e, t), h == null)) return "";
      for (a = o; ++s < r6.length && r6.charAt(s).toLowerCase() === o; ) a += o;
      o === "m" && f.toLowerCase() === "h" && (o = "M"), o === "h" && (o = v), i[i.length] = {
        t: o,
        v: a
      }, f = o;
      break;
    case "A":
    case "a":
    case "上":
      var x = {
        t: o,
        v: o
      };
      if (h == null && (h = A0(e, t)), r6.substr(s, 3).toUpperCase() === "A/P" ? (h != null && (x.v = h.H >= 12 ? "P" : "A"), x.t = "T", v = "h", s += 3) : r6.substr(s, 5).toUpperCase() === "AM/PM" ? (h != null && (x.v = h.H >= 12 ? "PM" : "AM"), x.t = "T", s += 5, v = "h") : r6.substr(s, 5).toUpperCase() === "上午/下午" ? (h != null && (x.v = h.H >= 12 ? "下午" : "上午"), x.t = "T", s += 5, v = "h") : (x.t = "t", ++s), h == null && x.t === "T") return "";
      i[i.length] = x, f = o;
      break;
    case "[":
      for (a = o; r6.charAt(s++) !== "]" && s < r6.length; ) a += r6.charAt(s);
      if (a.slice(-1) !== "]") throw 'unterminated "[" block: |' + a + "|";
      if (a.match(su)) {
        if (h == null && (h = A0(e, t), h == null)) return "";
        i[i.length] = {
          t: "Z",
          v: a.toLowerCase()
        }, f = a.charAt(1);
      } else a.indexOf("$") > -1 && (a = (a.match(/\$([^-\[\]]*)/) || [])[1] || "$", ou(r6) || (i[i.length] = {
        t: "t",
        v: a
      }));
      break;
    case ".":
      if (h != null) {
        for (a = o; ++s < r6.length && (o = r6.charAt(s)) === "0"; ) a += o;
        i[i.length] = {
          t: "s",
          v: a
        };
        break;
      }
    case "0":
    case "#":
      for (a = o; ++s < r6.length && "0#?.,E+-%".indexOf(o = r6.charAt(s)) > -1; ) a += o;
      i[i.length] = {
        t: "n",
        v: a
      };
      break;
    case "?":
      for (a = o; r6.charAt(++s) === o; ) a += o;
      i[i.length] = {
        t: o,
        v: a
      }, f = o;
      break;
    case "*":
      ++s, (r6.charAt(s) == " " || r6.charAt(s) == "*") && ++s;
      break;
    case "(":
    case ")":
      i[i.length] = {
        t: n === 1 ? "t" : o,
        v: o
      }, ++s;
      break;
    case "1":
    case "2":
    case "3":
    case "4":
    case "5":
    case "6":
    case "7":
    case "8":
    case "9":
      for (a = o; s < r6.length && "0123456789".indexOf(r6.charAt(++s)) > -1; ) a += r6.charAt(s);
      i[i.length] = {
        t: "D",
        v: a
      };
      break;
    case " ":
      i[i.length] = {
        t: o,
        v: o
      }, ++s;
      break;
    case "$":
      i[i.length] = {
        t: "t",
        v: "$"
      }, ++s;
      break;
    default:
      if (",$-+/():!^&'~{}<>=€acfijklopqrtuvwxzP".indexOf(o) === -1) throw new Error("unrecognized character " + o + " in " + r6);
      i[i.length] = {
        t: "t",
        v: o
      }, ++s;
      break;
  }
  var S = 0, A = 0, b;
  for (s = i.length - 1, f = "t"; s >= 0; --s) switch (i[s].t) {
    case "h":
    case "H":
      i[s].t = v, f = "h", S < 1 && (S = 1);
      break;
    case "s":
      (b = i[s].v.match(/\.0+$/)) && (A = Math.max(A, b[0].length - 1)), S < 3 && (S = 3);
    case "d":
    case "y":
    case "M":
    case "e":
      f = i[s].t;
      break;
    case "m":
      f === "s" && (i[s].t = "M", S < 2 && (S = 2));
      break;
    case "X":
      break;
    case "Z":
      S < 1 && i[s].v.match(/[Hh]/) && (S = 1), S < 2 && i[s].v.match(/[Mm]/) && (S = 2), S < 3 && i[s].v.match(/[Ss]/) && (S = 3);
  }
  switch (S) {
    case 0:
      break;
    case 1:
      h.u >= 0.5 && (h.u = 0, ++h.S), h.S >= 60 && (h.S = 0, ++h.M), h.M >= 60 && (h.M = 0, ++h.H);
      break;
    case 2:
      h.u >= 0.5 && (h.u = 0, ++h.S), h.S >= 60 && (h.S = 0, ++h.M);
      break;
  }
  var O = "", q;
  for (s = 0; s < i.length; ++s) switch (i[s].t) {
    case "t":
    case "T":
    case " ":
    case "D":
      break;
    case "X":
      i[s].v = "", i[s].t = ";";
      break;
    case "d":
    case "m":
    case "y":
    case "h":
    case "H":
    case "M":
    case "s":
    case "e":
    case "b":
    case "Z":
      i[s].v = dd(i[s].t.charCodeAt(0), i[s].v, h, A), i[s].t = "t";
      break;
    case "n":
    case "?":
      for (q = s + 1; i[q] != null && ((o = i[q].t) === "?" || o === "D" || (o === " " || o === "t") && i[q + 1] != null && (i[q + 1].t === "?" || i[q + 1].t === "t" && i[q + 1].v === "/") || i[s].t === "(" && (o === " " || o === "n" || o === ")") || o === "t" && (i[q].v === "/" || i[q].v === " " && i[q + 1] != null && i[q + 1].t == "?")); ) i[s].v += i[q].v, i[q] = {
        v: "",
        t: ";"
      }, ++q;
      O += i[s].v, s = q - 1;
      break;
    case "G":
      i[s].t = "t", i[s].v = ml(e, t);
      break;
  }
  var te = "", le, j;
  if (O.length > 0) {
    O.charCodeAt(0) == 40 ? (le = e < 0 && O.charCodeAt(0) === 45 ? -e : e, j = Ri("n", O, le)) : (le = e < 0 && n > 1 ? -e : e, j = Ri("n", O, le), le < 0 && i[0] && i[0].t == "t" && (j = j.substr(1), i[0].v = "-" + i[0].v)), q = j.length - 1;
    var M = i.length;
    for (s = 0; s < i.length; ++s) if (i[s] != null && i[s].t != "t" && i[s].v.indexOf(".") > -1) {
      M = s;
      break;
    }
    var H = i.length;
    if (M === i.length && j.indexOf("E") === -1) {
      for (s = i.length - 1; s >= 0; --s) i[s] == null || "n?".indexOf(i[s].t) === -1 || (q >= i[s].v.length - 1 ? (q -= i[s].v.length, i[s].v = j.substr(q + 1, i[s].v.length)) : q < 0 ? i[s].v = "" : (i[s].v = j.substr(0, q + 1), q = -1), i[s].t = "t", H = s);
      q >= 0 && H < i.length && (i[H].v = j.substr(0, q + 1) + i[H].v);
    } else if (M !== i.length && j.indexOf("E") === -1) {
      for (q = j.indexOf(".") - 1, s = M; s >= 0; --s) if (!(i[s] == null || "n?".indexOf(i[s].t) === -1)) {
        for (c = i[s].v.indexOf(".") > -1 && s === M ? i[s].v.indexOf(".") - 1 : i[s].v.length - 1, te = i[s].v.substr(c + 1); c >= 0; --c) q >= 0 && (i[s].v.charAt(c) === "0" || i[s].v.charAt(c) === "#") && (te = j.charAt(q--) + te);
        i[s].v = te, i[s].t = "t", H = s;
      }
      for (q >= 0 && H < i.length && (i[H].v = j.substr(0, q + 1) + i[H].v), q = j.indexOf(".") + 1, s = M; s < i.length; ++s) if (!(i[s] == null || "n?(".indexOf(i[s].t) === -1 && s !== M)) {
        for (c = i[s].v.indexOf(".") > -1 && s === M ? i[s].v.indexOf(".") + 1 : 0, te = i[s].v.substr(0, c); c < i[s].v.length; ++c) q < j.length && (te += j.charAt(q++));
        i[s].v = te, i[s].t = "t", H = s;
      }
    }
  }
  for (s = 0; s < i.length; ++s) i[s] != null && "n?".indexOf(i[s].t) > -1 && (le = n > 1 && e < 0 && s > 0 && i[s - 1].v === "-" ? -e : e, i[s].v = Ri(i[s].t, i[s].v, le), i[s].t = "t");
  var ee = "";
  for (s = 0; s !== i.length; ++s) i[s] != null && (ee += i[s].v);
  return ee;
}
var Hh = /\[(=|>[=]?|<[>=]?)(-?\d+(?:\.\d*)?)\]/;
function Wh(r6, e) {
  if (e == null) return false;
  var t = parseFloat(e[2]);
  switch (e[1]) {
    case "=":
      if (r6 == t) return true;
      break;
    case ">":
      if (r6 > t) return true;
      break;
    case "<":
      if (r6 < t) return true;
      break;
    case "<>":
      if (r6 != t) return true;
      break;
    case ">=":
      if (r6 >= t) return true;
      break;
    case "<=":
      if (r6 <= t) return true;
      break;
  }
  return false;
}
function bd(r6, e) {
  var t = Sd(r6), n = t.length, i = t[n - 1].indexOf("@");
  if (n < 4 && i > -1 && --n, t.length > 4) throw new Error("cannot find right format for |" + t.join("|") + "|");
  if (typeof e != "number") return [4, t.length === 4 || i > -1 ? t[t.length - 1] : "@"];
  switch (t.length) {
    case 1:
      t = i > -1 ? ["General", "General", "General", t[0]] : [t[0], t[0], t[0], "@"];
      break;
    case 2:
      t = i > -1 ? [t[0], t[0], t[0], t[1]] : [t[0], t[1], t[0], "@"];
      break;
    case 3:
      t = i > -1 ? [t[0], t[1], t[0], t[2]] : [t[0], t[1], t[2], "@"];
      break;
  }
  var a = e > 0 ? t[0] : e < 0 ? t[1] : t[2];
  if (t[0].indexOf("[") === -1 && t[1].indexOf("[") === -1) return [n, a];
  if (t[0].match(/\[[=<>]/) != null || t[1].match(/\[[=<>]/) != null) {
    var s = t[0].match(Hh), o = t[1].match(Hh);
    return Wh(e, s) ? [n, t[0]] : Wh(e, o) ? [n, t[1]] : [n, t[s != null && o != null ? 2 : 1]];
  }
  return [n, a];
}
function la(r6, e, t) {
  t == null && (t = {});
  var n = "";
  switch (typeof r6) {
    case "string":
      r6 == "m/d/yy" && t.dateNF ? n = t.dateNF : n = r6;
      break;
    case "number":
      r6 == 14 && t.dateNF ? n = t.dateNF : n = (t.table != null ? t.table : lr)[r6], n == null && (n = t.table && t.table[jh[r6]] || lr[jh[r6]]), n == null && (n = ad[r6] || "General");
      break;
  }
  if (j0(n, 0)) return ml(e, t);
  e instanceof Date && (e = Zc(e, t.date1904));
  var i = bd(n, e);
  if (j0(i[1])) return ml(e, t);
  if (e === true) e = "TRUE";
  else if (e === false) e = "FALSE";
  else if (e === "" || e == null) return "";
  return Ad(i[1], e, t, i[0]);
}
function fu(r6, e) {
  if (typeof e != "number") {
    e = +e || -1;
    for (var t = 0; t < 392; ++t) {
      if (lr[t] == null) {
        e < 0 && (e = t);
        continue;
      }
      if (lr[t] == r6) {
        e = t;
        break;
      }
    }
    e < 0 && (e = 391);
  }
  return lr[e] = r6, e;
}
function rf(r6) {
  for (var e = 0; e != 392; ++e) r6[e] !== void 0 && fu(r6[e], e);
}
function nf() {
  lr = id();
}
var lu = /[dD]+|[mM]+|[yYeE]+|[Hh]+|[Ss]+/g;
function Td(r6) {
  var e = typeof r6 == "number" ? lr[r6] : r6;
  return e = e.replace(lu, "(\\d+)"), new RegExp("^" + e + "$");
}
function Ed(r6, e, t) {
  var n = -1, i = -1, a = -1, s = -1, o = -1, f = -1;
  (e.match(lu) || []).forEach(function(p, v) {
    var d = parseInt(t[v + 1], 10);
    switch (p.toLowerCase().charAt(0)) {
      case "y":
        n = d;
        break;
      case "d":
        a = d;
        break;
      case "h":
        s = d;
        break;
      case "s":
        f = d;
        break;
      case "m":
        s >= 0 ? o = d : i = d;
        break;
    }
  }), f >= 0 && o == -1 && i >= 0 && (o = i, i = -1);
  var h = ("" + (n >= 0 ? n : (/* @__PURE__ */ new Date()).getFullYear())).slice(-4) + "-" + ("00" + (i >= 1 ? i : 1)).slice(-2) + "-" + ("00" + (a >= 1 ? a : 1)).slice(-2);
  h.length == 7 && (h = "0" + h), h.length == 8 && (h = "20" + h);
  var c = ("00" + (s >= 0 ? s : 0)).slice(-2) + ":" + ("00" + (o >= 0 ? o : 0)).slice(-2) + ":" + ("00" + (f >= 0 ? f : 0)).slice(-2);
  return s == -1 && o == -1 && f == -1 ? h : n == -1 && i == -1 && a == -1 ? c : h + "T" + c;
}
var Nd = function() {
  var r6 = {};
  r6.version = "1.2.0";
  function e() {
    for (var j = 0, M = new Array(256), H = 0; H != 256; ++H) j = H, j = j & 1 ? -306674912 ^ j >>> 1 : j >>> 1, j = j & 1 ? -306674912 ^ j >>> 1 : j >>> 1, j = j & 1 ? -306674912 ^ j >>> 1 : j >>> 1, j = j & 1 ? -306674912 ^ j >>> 1 : j >>> 1, j = j & 1 ? -306674912 ^ j >>> 1 : j >>> 1, j = j & 1 ? -306674912 ^ j >>> 1 : j >>> 1, j = j & 1 ? -306674912 ^ j >>> 1 : j >>> 1, j = j & 1 ? -306674912 ^ j >>> 1 : j >>> 1, M[H] = j;
    return typeof Int32Array < "u" ? new Int32Array(M) : M;
  }
  var t = e();
  function n(j) {
    var M = 0, H = 0, ee = 0, F = typeof Int32Array < "u" ? new Int32Array(4096) : new Array(4096);
    for (ee = 0; ee != 256; ++ee) F[ee] = j[ee];
    for (ee = 0; ee != 256; ++ee) for (H = j[ee], M = 256 + ee; M < 4096; M += 256) H = F[M] = H >>> 8 ^ j[H & 255];
    var P = [];
    for (ee = 1; ee != 16; ++ee) P[ee - 1] = typeof Int32Array < "u" ? F.subarray(ee * 256, ee * 256 + 256) : F.slice(ee * 256, ee * 256 + 256);
    return P;
  }
  var i = n(t), a = i[0], s = i[1], o = i[2], f = i[3], h = i[4], c = i[5], p = i[6], v = i[7], d = i[8], w = i[9], x = i[10], S = i[11], A = i[12], b = i[13], O = i[14];
  function q(j, M) {
    for (var H = M ^ -1, ee = 0, F = j.length; ee < F; ) H = H >>> 8 ^ t[(H ^ j.charCodeAt(ee++)) & 255];
    return ~H;
  }
  function te(j, M) {
    for (var H = M ^ -1, ee = j.length - 15, F = 0; F < ee; ) H = O[j[F++] ^ H & 255] ^ b[j[F++] ^ H >> 8 & 255] ^ A[j[F++] ^ H >> 16 & 255] ^ S[j[F++] ^ H >>> 24] ^ x[j[F++]] ^ w[j[F++]] ^ d[j[F++]] ^ v[j[F++]] ^ p[j[F++]] ^ c[j[F++]] ^ h[j[F++]] ^ f[j[F++]] ^ o[j[F++]] ^ s[j[F++]] ^ a[j[F++]] ^ t[j[F++]];
    for (ee += 15; F < ee; ) H = H >>> 8 ^ t[(H ^ j[F++]) & 255];
    return ~H;
  }
  function le(j, M) {
    for (var H = M ^ -1, ee = 0, F = j.length, P = 0, Y = 0; ee < F; ) P = j.charCodeAt(ee++), P < 128 ? H = H >>> 8 ^ t[(H ^ P) & 255] : P < 2048 ? (H = H >>> 8 ^ t[(H ^ (192 | P >> 6 & 31)) & 255], H = H >>> 8 ^ t[(H ^ (128 | P & 63)) & 255]) : P >= 55296 && P < 57344 ? (P = (P & 1023) + 64, Y = j.charCodeAt(ee++) & 1023, H = H >>> 8 ^ t[(H ^ (240 | P >> 8 & 7)) & 255], H = H >>> 8 ^ t[(H ^ (128 | P >> 2 & 63)) & 255], H = H >>> 8 ^ t[(H ^ (128 | Y >> 6 & 15 | (P & 3) << 4)) & 255], H = H >>> 8 ^ t[(H ^ (128 | Y & 63)) & 255]) : (H = H >>> 8 ^ t[(H ^ (224 | P >> 12 & 15)) & 255], H = H >>> 8 ^ t[(H ^ (128 | P >> 6 & 63)) & 255], H = H >>> 8 ^ t[(H ^ (128 | P & 63)) & 255]);
    return ~H;
  }
  return r6.table = t, r6.bstr = q, r6.buf = te, r6.str = le, r6;
}();
var Xt = function() {
  var e = {};
  e.version = "1.2.1";
  function t(D, X) {
    for (var U = D.split("/"), W = X.split("/"), G = 0, K = 0, ge = Math.min(U.length, W.length); G < ge; ++G) {
      if (K = U[G].length - W[G].length) return K;
      if (U[G] != W[G]) return U[G] < W[G] ? -1 : 1;
    }
    return U.length - W.length;
  }
  function n(D) {
    if (D.charAt(D.length - 1) == "/") return D.slice(0, -1).indexOf("/") === -1 ? D : n(D.slice(0, -1));
    var X = D.lastIndexOf("/");
    return X === -1 ? D : D.slice(0, X + 1);
  }
  function i(D) {
    if (D.charAt(D.length - 1) == "/") return i(D.slice(0, -1));
    var X = D.lastIndexOf("/");
    return X === -1 ? D : D.slice(X + 1);
  }
  function a(D, X) {
    typeof X == "string" && (X = new Date(X));
    var U = X.getHours();
    U = U << 6 | X.getMinutes(), U = U << 5 | X.getSeconds() >>> 1, D.write_shift(2, U);
    var W = X.getFullYear() - 1980;
    W = W << 4 | X.getMonth() + 1, W = W << 5 | X.getDate(), D.write_shift(2, W);
  }
  function s(D) {
    var X = D.read_shift(2) & 65535, U = D.read_shift(2) & 65535, W = /* @__PURE__ */ new Date(), G = U & 31;
    U >>>= 5;
    var K = U & 15;
    U >>>= 4, W.setMilliseconds(0), W.setFullYear(U + 1980), W.setMonth(K - 1), W.setDate(G);
    var ge = X & 31;
    X >>>= 5;
    var Ee = X & 63;
    return X >>>= 6, W.setHours(X), W.setMinutes(Ee), W.setSeconds(ge << 1), W;
  }
  function o(D) {
    Tn(D, 0);
    for (var X = (
      /*::(*/
      {}
    ), U = 0; D.l <= D.length - 4; ) {
      var W = D.read_shift(2), G = D.read_shift(2), K = D.l + G, ge = {};
      switch (W) {
        case 21589:
          U = D.read_shift(1), U & 1 && (ge.mtime = D.read_shift(4)), G > 5 && (U & 2 && (ge.atime = D.read_shift(4)), U & 4 && (ge.ctime = D.read_shift(4))), ge.mtime && (ge.mt = new Date(ge.mtime * 1e3));
          break;
      }
      D.l = K, X[W] = ge;
    }
    return X;
  }
  var f;
  function h() {
    return f || (f = {});
  }
  function c(D, X) {
    if (D[0] == 80 && D[1] == 75) return er(D, X);
    if ((D[0] | 32) == 109 && (D[1] | 32) == 105) return kn(D, X);
    if (D.length < 512) throw new Error("CFB file size " + D.length + " < 512");
    var U = 3, W = 512, G = 0, K = 0, ge = 0, Ee = 0, pe = 0, ye = [], _e = (
      /*::(*/
      D.slice(0, 512)
    );
    Tn(_e, 0);
    var Ue = p(_e);
    switch (U = Ue[0], U) {
      case 3:
        W = 512;
        break;
      case 4:
        W = 4096;
        break;
      case 0:
        if (Ue[1] == 0) return er(D, X);
      default:
        throw new Error("Major Version: Expected 3 or 4 saw " + U);
    }
    W !== 512 && (_e = /*::(*/
    D.slice(0, W), Tn(
      _e,
      28
      /* blob.l */
    ));
    var Ve = D.slice(0, W);
    v(_e, U);
    var tt = _e.read_shift(4, "i");
    if (U === 3 && tt !== 0) throw new Error("# Directory Sectors: Expected 0 saw " + tt);
    _e.l += 4, ge = _e.read_shift(4, "i"), _e.l += 4, _e.chk("00100000", "Mini Stream Cutoff Size: "), Ee = _e.read_shift(4, "i"), G = _e.read_shift(4, "i"), pe = _e.read_shift(4, "i"), K = _e.read_shift(4, "i");
    for (var He = -1, et = 0; et < 109 && (He = _e.read_shift(4, "i"), !(He < 0)); ++et) ye[et] = He;
    var pt = d(D, W);
    S(pe, K, pt, W, ye);
    var Mt = b(pt, ge, ye, W);
    Mt[ge].name = "!Directory", G > 0 && Ee !== Y && (Mt[Ee].name = "!MiniFAT"), Mt[ye[0]].name = "!FAT", Mt.fat_addrs = ye, Mt.ssz = W;
    var Vt = {}, mr = [], zn = [], Si = [];
    O(ge, Mt, pt, mr, G, Vt, zn, Ee), w(zn, Si, mr), mr.shift();
    var fi = {
      FileIndex: zn,
      FullPaths: Si
    };
    return X && X.raw && (fi.raw = {
      header: Ve,
      sectors: pt
    }), fi;
  }
  function p(D) {
    if (D[D.l] == 80 && D[D.l + 1] == 75) return [0, 0];
    D.chk(Q, "Header Signature: "), D.l += 16;
    var X = D.read_shift(2, "u");
    return [D.read_shift(2, "u"), X];
  }
  function v(D, X) {
    var U = 9;
    switch (D.l += 2, U = D.read_shift(2)) {
      case 9:
        if (X != 3) throw new Error("Sector Shift: Expected 9 saw " + U);
        break;
      case 12:
        if (X != 4) throw new Error("Sector Shift: Expected 12 saw " + U);
        break;
      default:
        throw new Error("Sector Shift: Expected 9 or 12 saw " + U);
    }
    D.chk("0600", "Mini Sector Shift: "), D.chk("000000000000", "Reserved: ");
  }
  function d(D, X) {
    for (var U = Math.ceil(D.length / X) - 1, W = [], G = 1; G < U; ++G) W[G - 1] = D.slice(G * X, (G + 1) * X);
    return W[U - 1] = D.slice(U * X), W;
  }
  function w(D, X, U) {
    for (var W = 0, G = 0, K = 0, ge = 0, Ee = 0, pe = U.length, ye = [], _e = []; W < pe; ++W) ye[W] = _e[W] = W, X[W] = U[W];
    for (; Ee < _e.length; ++Ee) W = _e[Ee], G = D[W].L, K = D[W].R, ge = D[W].C, ye[W] === W && (G !== -1 && ye[G] !== G && (ye[W] = ye[G]), K !== -1 && ye[K] !== K && (ye[W] = ye[K])), ge !== -1 && (ye[ge] = W), G !== -1 && W != ye[W] && (ye[G] = ye[W], _e.lastIndexOf(G) < Ee && _e.push(G)), K !== -1 && W != ye[W] && (ye[K] = ye[W], _e.lastIndexOf(K) < Ee && _e.push(K));
    for (W = 1; W < pe; ++W) ye[W] === W && (K !== -1 && ye[K] !== K ? ye[W] = ye[K] : G !== -1 && ye[G] !== G && (ye[W] = ye[G]));
    for (W = 1; W < pe; ++W) if (D[W].type !== 0) {
      if (Ee = W, Ee != ye[Ee]) do
        Ee = ye[Ee], X[W] = X[Ee] + "/" + X[W];
      while (Ee !== 0 && ye[Ee] !== -1 && Ee != ye[Ee]);
      ye[W] = -1;
    }
    for (X[0] += "/", W = 1; W < pe; ++W) D[W].type !== 2 && (X[W] += "/");
  }
  function x(D, X, U) {
    for (var W = D.start, G = D.size, K = [], ge = W; U && G > 0 && ge >= 0; ) K.push(X.slice(ge * P, ge * P + P)), G -= P, ge = Na(U, ge * 4);
    return K.length === 0 ? Le(0) : jr(K).slice(0, D.size);
  }
  function S(D, X, U, W, G) {
    var K = Y;
    if (D === Y) {
      if (X !== 0) throw new Error("DIFAT chain shorter than expected");
    } else if (D !== -1) {
      var ge = U[D], Ee = (W >>> 2) - 1;
      if (!ge) return;
      for (var pe = 0; pe < Ee && (K = Na(ge, pe * 4)) !== Y; ++pe) G.push(K);
      S(Na(ge, W - 4), X - 1, U, W, G);
    }
  }
  function A(D, X, U, W, G) {
    var K = [], ge = [];
    G || (G = []);
    var Ee = W - 1, pe = 0, ye = 0;
    for (pe = X; pe >= 0; ) {
      G[pe] = true, K[K.length] = pe, ge.push(D[pe]);
      var _e = U[Math.floor(pe * 4 / W)];
      if (ye = pe * 4 & Ee, W < 4 + ye) throw new Error("FAT boundary crossed: " + pe + " 4 " + W);
      if (!D[_e]) break;
      pe = Na(D[_e], ye);
    }
    return {
      nodes: K,
      data: Jh([ge])
    };
  }
  function b(D, X, U, W) {
    var G = D.length, K = [], ge = [], Ee = [], pe = [], ye = W - 1, _e = 0, Ue = 0, Ve = 0, tt = 0;
    for (_e = 0; _e < G; ++_e) if (Ee = [], Ve = _e + X, Ve >= G && (Ve -= G), !ge[Ve]) {
      pe = [];
      var He = [];
      for (Ue = Ve; Ue >= 0; ) {
        He[Ue] = true, ge[Ue] = true, Ee[Ee.length] = Ue, pe.push(D[Ue]);
        var et = U[Math.floor(Ue * 4 / W)];
        if (tt = Ue * 4 & ye, W < 4 + tt) throw new Error("FAT boundary crossed: " + Ue + " 4 " + W);
        if (!D[et] || (Ue = Na(D[et], tt), He[Ue])) break;
      }
      K[Ve] = {
        nodes: Ee,
        data: Jh([pe])
      };
    }
    return K;
  }
  function O(D, X, U, W, G, K, ge, Ee) {
    for (var pe = 0, ye = W.length ? 2 : 0, _e = X[D].data, Ue = 0, Ve = 0, tt; Ue < _e.length; Ue += 128) {
      var He = (
        /*::(*/
        _e.slice(Ue, Ue + 128)
      );
      Tn(He, 64), Ve = He.read_shift(2), tt = ql(He, 0, Ve - ye), W.push(tt);
      var et = {
        name: tt,
        type: He.read_shift(1),
        color: He.read_shift(1),
        L: He.read_shift(4, "i"),
        R: He.read_shift(4, "i"),
        C: He.read_shift(4, "i"),
        clsid: He.read_shift(16),
        state: He.read_shift(4, "i"),
        start: 0,
        size: 0
      }, pt = He.read_shift(2) + He.read_shift(2) + He.read_shift(2) + He.read_shift(2);
      pt !== 0 && (et.ct = q(He, He.l - 8));
      var Mt = He.read_shift(2) + He.read_shift(2) + He.read_shift(2) + He.read_shift(2);
      Mt !== 0 && (et.mt = q(He, He.l - 8)), et.start = He.read_shift(4, "i"), et.size = He.read_shift(4, "i"), et.size < 0 && et.start < 0 && (et.size = et.type = 0, et.start = Y, et.name = ""), et.type === 5 ? (pe = et.start, G > 0 && pe !== Y && (X[pe].name = "!StreamData")) : et.size >= 4096 ? (et.storage = "fat", X[et.start] === void 0 && (X[et.start] = A(U, et.start, X.fat_addrs, X.ssz)), X[et.start].name = et.name, et.content = X[et.start].data.slice(0, et.size)) : (et.storage = "minifat", et.size < 0 ? et.size = 0 : pe !== Y && et.start !== Y && X[pe] && (et.content = x(et, X[pe].data, (X[Ee] || {}).data))), et.content && Tn(et.content, 0), K[tt] = et, ge.push(et);
    }
  }
  function q(D, X) {
    return new Date((Nn(D, X + 4) / 1e7 * Math.pow(2, 32) + Nn(D, X) / 1e7 - 11644473600) * 1e3);
  }
  function te(D, X) {
    return h(), c(f.readFileSync(D), X);
  }
  function le(D, X) {
    var U = X && X.type;
    switch (U || It && Buffer.isBuffer(D) && (U = "buffer"), U || "base64") {
      case "file":
        return te(D, X);
      case "base64":
        return c(ri(ji(D)), X);
      case "binary":
        return c(ri(D), X);
    }
    return c(
      /*::typeof blob == 'string' ? new Buffer(blob, 'utf-8') : */
      D,
      X
    );
  }
  function j(D, X) {
    var U = X || {}, W = U.root || "Root Entry";
    if (D.FullPaths || (D.FullPaths = []), D.FileIndex || (D.FileIndex = []), D.FullPaths.length !== D.FileIndex.length) throw new Error("inconsistent CFB structure");
    D.FullPaths.length === 0 && (D.FullPaths[0] = W + "/", D.FileIndex[0] = {
      name: W,
      type: 5
    }), U.CLSID && (D.FileIndex[0].clsid = U.CLSID), M(D);
  }
  function M(D) {
    var X = "Sh33tJ5";
    if (!Xt.find(D, "/" + X)) {
      var U = Le(4);
      U[0] = 55, U[1] = U[3] = 50, U[2] = 54, D.FileIndex.push({
        name: X,
        type: 2,
        content: U,
        size: 4,
        L: 69,
        R: 69,
        C: 69
      }), D.FullPaths.push(D.FullPaths[0] + X), H(D);
    }
  }
  function H(D, X) {
    j(D);
    for (var U = false, W = false, G = D.FullPaths.length - 1; G >= 0; --G) {
      var K = D.FileIndex[G];
      switch (K.type) {
        case 0:
          W ? U = true : (D.FileIndex.pop(), D.FullPaths.pop());
          break;
        case 1:
        case 2:
        case 5:
          W = true, isNaN(K.R * K.L * K.C) && (U = true), K.R > -1 && K.L > -1 && K.R == K.L && (U = true);
          break;
        default:
          U = true;
          break;
      }
    }
    if (!(!U && !X)) {
      var ge = new Date(1987, 1, 19), Ee = 0, pe = Object.create ? /* @__PURE__ */ Object.create(null) : {}, ye = [];
      for (G = 0; G < D.FullPaths.length; ++G) pe[D.FullPaths[G]] = true, D.FileIndex[G].type !== 0 && ye.push([D.FullPaths[G], D.FileIndex[G]]);
      for (G = 0; G < ye.length; ++G) {
        var _e = n(ye[G][0]);
        W = pe[_e], W || (ye.push([_e, {
          name: i(_e).replace("/", ""),
          type: 1,
          clsid: we,
          ct: ge,
          mt: ge,
          content: null
        }]), pe[_e] = true);
      }
      for (ye.sort(function(tt, He) {
        return t(tt[0], He[0]);
      }), D.FullPaths = [], D.FileIndex = [], G = 0; G < ye.length; ++G) D.FullPaths[G] = ye[G][0], D.FileIndex[G] = ye[G][1];
      for (G = 0; G < ye.length; ++G) {
        var Ue = D.FileIndex[G], Ve = D.FullPaths[G];
        if (Ue.name = i(Ve).replace("/", ""), Ue.L = Ue.R = Ue.C = -(Ue.color = 1), Ue.size = Ue.content ? Ue.content.length : 0, Ue.start = 0, Ue.clsid = Ue.clsid || we, G === 0) Ue.C = ye.length > 1 ? 1 : -1, Ue.size = 0, Ue.type = 5;
        else if (Ve.slice(-1) == "/") {
          for (Ee = G + 1; Ee < ye.length && n(D.FullPaths[Ee]) != Ve; ++Ee) ;
          for (Ue.C = Ee >= ye.length ? -1 : Ee, Ee = G + 1; Ee < ye.length && n(D.FullPaths[Ee]) != n(Ve); ++Ee) ;
          Ue.R = Ee >= ye.length ? -1 : Ee, Ue.type = 1;
        } else n(D.FullPaths[G + 1] || "") == n(Ve) && (Ue.R = G + 1), Ue.type = 2;
      }
    }
  }
  function ee(D, X) {
    var U = X || {};
    if (U.fileType == "mad") return lt(D, U);
    switch (H(D), U.fileType) {
      case "zip":
        return Wn(D, U);
    }
    var W = function(tt) {
      for (var He = 0, et = 0, pt = 0; pt < tt.FileIndex.length; ++pt) {
        var Mt = tt.FileIndex[pt];
        if (Mt.content) {
          var Vt = Mt.content.length;
          Vt > 0 && (Vt < 4096 ? He += Vt + 63 >> 6 : et += Vt + 511 >> 9);
        }
      }
      for (var mr = tt.FullPaths.length + 3 >> 2, zn = He + 7 >> 3, Si = He + 127 >> 7, fi = zn + et + mr + Si, Vn = fi + 127 >> 7, li = Vn <= 109 ? 0 : Math.ceil((Vn - 109) / 127); fi + Vn + li + 127 >> 7 > Vn; ) li = ++Vn <= 109 ? 0 : Math.ceil((Vn - 109) / 127);
      var wn = [1, li, Vn, Si, mr, et, He, 0];
      return tt.FileIndex[0].size = He << 6, wn[7] = (tt.FileIndex[0].start = wn[0] + wn[1] + wn[2] + wn[3] + wn[4] + wn[5]) + (wn[6] + 7 >> 3), wn;
    }(D), G = Le(W[7] << 9), K = 0, ge = 0;
    {
      for (K = 0; K < 8; ++K) G.write_shift(1, ce[K]);
      for (K = 0; K < 8; ++K) G.write_shift(2, 0);
      for (G.write_shift(2, 62), G.write_shift(2, 3), G.write_shift(2, 65534), G.write_shift(2, 9), G.write_shift(2, 6), K = 0; K < 3; ++K) G.write_shift(2, 0);
      for (G.write_shift(4, 0), G.write_shift(4, W[2]), G.write_shift(4, W[0] + W[1] + W[2] + W[3] - 1), G.write_shift(4, 0), G.write_shift(4, 4096), G.write_shift(4, W[3] ? W[0] + W[1] + W[2] - 1 : Y), G.write_shift(4, W[3]), G.write_shift(-4, W[1] ? W[0] - 1 : Y), G.write_shift(4, W[1]), K = 0; K < 109; ++K) G.write_shift(-4, K < W[2] ? W[1] + K : -1);
    }
    if (W[1]) for (ge = 0; ge < W[1]; ++ge) {
      for (; K < 236 + ge * 127; ++K) G.write_shift(-4, K < W[2] ? W[1] + K : -1);
      G.write_shift(-4, ge === W[1] - 1 ? Y : ge + 1);
    }
    var Ee = function(tt) {
      for (ge += tt; K < ge - 1; ++K) G.write_shift(-4, K + 1);
      tt && (++K, G.write_shift(-4, Y));
    };
    for (ge = K = 0, ge += W[1]; K < ge; ++K) G.write_shift(-4, Se.DIFSECT);
    for (ge += W[2]; K < ge; ++K) G.write_shift(-4, Se.FATSECT);
    Ee(W[3]), Ee(W[4]);
    for (var pe = 0, ye = 0, _e = D.FileIndex[0]; pe < D.FileIndex.length; ++pe) _e = D.FileIndex[pe], _e.content && (ye = _e.content.length, !(ye < 4096) && (_e.start = ge, Ee(ye + 511 >> 9)));
    for (Ee(W[6] + 7 >> 3); G.l & 511; ) G.write_shift(-4, Se.ENDOFCHAIN);
    for (ge = K = 0, pe = 0; pe < D.FileIndex.length; ++pe) _e = D.FileIndex[pe], _e.content && (ye = _e.content.length, !(!ye || ye >= 4096) && (_e.start = ge, Ee(ye + 63 >> 6)));
    for (; G.l & 511; ) G.write_shift(-4, Se.ENDOFCHAIN);
    for (K = 0; K < W[4] << 2; ++K) {
      var Ue = D.FullPaths[K];
      if (!Ue || Ue.length === 0) {
        for (pe = 0; pe < 17; ++pe) G.write_shift(4, 0);
        for (pe = 0; pe < 3; ++pe) G.write_shift(4, -1);
        for (pe = 0; pe < 12; ++pe) G.write_shift(4, 0);
        continue;
      }
      _e = D.FileIndex[K], K === 0 && (_e.start = _e.size ? _e.start - 1 : Y);
      var Ve = K === 0 && U.root || _e.name;
      if (ye = 2 * (Ve.length + 1), G.write_shift(64, Ve, "utf16le"), G.write_shift(2, ye), G.write_shift(1, _e.type), G.write_shift(1, _e.color), G.write_shift(-4, _e.L), G.write_shift(-4, _e.R), G.write_shift(-4, _e.C), _e.clsid) G.write_shift(16, _e.clsid, "hex");
      else for (pe = 0; pe < 4; ++pe) G.write_shift(4, 0);
      G.write_shift(4, _e.state || 0), G.write_shift(4, 0), G.write_shift(4, 0), G.write_shift(4, 0), G.write_shift(4, 0), G.write_shift(4, _e.start), G.write_shift(4, _e.size), G.write_shift(4, 0);
    }
    for (K = 1; K < D.FileIndex.length; ++K) if (_e = D.FileIndex[K], _e.size >= 4096) if (G.l = _e.start + 1 << 9, It && Buffer.isBuffer(_e.content)) _e.content.copy(G, G.l, 0, _e.size), G.l += _e.size + 511 & -512;
    else {
      for (pe = 0; pe < _e.size; ++pe) G.write_shift(1, _e.content[pe]);
      for (; pe & 511; ++pe) G.write_shift(1, 0);
    }
    for (K = 1; K < D.FileIndex.length; ++K) if (_e = D.FileIndex[K], _e.size > 0 && _e.size < 4096) if (It && Buffer.isBuffer(_e.content)) _e.content.copy(G, G.l, 0, _e.size), G.l += _e.size + 63 & -64;
    else {
      for (pe = 0; pe < _e.size; ++pe) G.write_shift(1, _e.content[pe]);
      for (; pe & 63; ++pe) G.write_shift(1, 0);
    }
    if (It) G.l = G.length;
    else for (; G.l < G.length; ) G.write_shift(1, 0);
    return G;
  }
  function F(D, X) {
    var U = D.FullPaths.map(function(pe) {
      return pe.toUpperCase();
    }), W = U.map(function(pe) {
      var ye = pe.split("/");
      return ye[ye.length - (pe.slice(-1) == "/" ? 2 : 1)];
    }), G = false;
    X.charCodeAt(0) === 47 ? (G = true, X = U[0].slice(0, -1) + X) : G = X.indexOf("/") !== -1;
    var K = X.toUpperCase(), ge = G === true ? U.indexOf(K) : W.indexOf(K);
    if (ge !== -1) return D.FileIndex[ge];
    var Ee = !K.match(S0);
    for (K = K.replace(uo, ""), Ee && (K = K.replace(S0, "!")), ge = 0; ge < U.length; ++ge) if ((Ee ? U[ge].replace(S0, "!") : U[ge]).replace(uo, "") == K || (Ee ? W[ge].replace(S0, "!") : W[ge]).replace(uo, "") == K) return D.FileIndex[ge];
    return null;
  }
  var P = 64, Y = -2, Q = "d0cf11e0a1b11ae1", ce = [208, 207, 17, 224, 161, 177, 26, 225], we = "00000000000000000000000000000000", Se = {
    /* 2.1 Compund File Sector Numbers and Types */
    MAXREGSECT: -6,
    DIFSECT: -4,
    FATSECT: -3,
    ENDOFCHAIN: Y,
    FREESECT: -1,
    /* 2.2 Compound File Header */
    HEADER_SIGNATURE: Q,
    HEADER_MINOR_VERSION: "3e00",
    MAXREGSID: -6,
    NOSTREAM: -1,
    HEADER_CLSID: we,
    /* 2.6.1 Compound File Directory Entry */
    EntryTypes: ["unknown", "storage", "stream", "lockbytes", "property", "root"]
  };
  function de(D, X, U) {
    h();
    var W = ee(D, U);
    f.writeFileSync(X, W);
  }
  function Ae(D) {
    for (var X = new Array(D.length), U = 0; U < D.length; ++U) X[U] = String.fromCharCode(D[U]);
    return X.join("");
  }
  function be(D, X) {
    var U = ee(D, X);
    switch (X && X.type || "buffer") {
      case "file":
        return h(), f.writeFileSync(X.filename, U), U;
      case "binary":
        return typeof U == "string" ? U : Ae(U);
      case "base64":
        return So(typeof U == "string" ? U : Ae(U));
      case "buffer":
        if (It) return Buffer.isBuffer(U) ? U : Hi(U);
      case "array":
        return typeof U == "string" ? ri(U) : U;
    }
    return U;
  }
  var ze;
  function y(D) {
    try {
      var X = D.InflateRaw, U = new X();
      if (U._processChunk(new Uint8Array([3, 0]), U._finishFlushFlag), U.bytesRead) ze = D;
      else throw new Error("zlib does not expose bytesRead");
    } catch (W) {
      console.error("cannot use native zlib: " + (W.message || W));
    }
  }
  function L(D, X) {
    if (!ze) return Ct(D, X);
    var U = ze.InflateRaw, W = new U(), G = W._processChunk(D.slice(D.l), W._finishFlushFlag);
    return D.l += W.bytesRead, G;
  }
  function N(D) {
    return ze ? ze.deflateRawSync(D) : At(D);
  }
  var C = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15], z = [3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258], re = [1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577];
  function se(D) {
    var X = (D << 1 | D << 11) & 139536 | (D << 5 | D << 15) & 558144;
    return (X >> 16 | X >> 8 | X) & 255;
  }
  for (var ie = typeof Uint8Array < "u", ve = ie ? new Uint8Array(256) : [], Ce = 0; Ce < 256; ++Ce) ve[Ce] = se(Ce);
  function Oe(D, X) {
    var U = ve[D & 255];
    return X <= 8 ? U >>> 8 - X : (U = U << 8 | ve[D >> 8 & 255], X <= 16 ? U >>> 16 - X : (U = U << 8 | ve[D >> 16 & 255], U >>> 24 - X));
  }
  function qe(D, X) {
    var U = X & 7, W = X >>> 3;
    return (D[W] | (U <= 6 ? 0 : D[W + 1] << 8)) >>> U & 3;
  }
  function Ye(D, X) {
    var U = X & 7, W = X >>> 3;
    return (D[W] | (U <= 5 ? 0 : D[W + 1] << 8)) >>> U & 7;
  }
  function Te(D, X) {
    var U = X & 7, W = X >>> 3;
    return (D[W] | (U <= 4 ? 0 : D[W + 1] << 8)) >>> U & 15;
  }
  function Z(D, X) {
    var U = X & 7, W = X >>> 3;
    return (D[W] | (U <= 3 ? 0 : D[W + 1] << 8)) >>> U & 31;
  }
  function Ie(D, X) {
    var U = X & 7, W = X >>> 3;
    return (D[W] | (U <= 1 ? 0 : D[W + 1] << 8)) >>> U & 127;
  }
  function rt(D, X, U) {
    var W = X & 7, G = X >>> 3, K = (1 << U) - 1, ge = D[G] >>> W;
    return U < 8 - W || (ge |= D[G + 1] << 8 - W, U < 16 - W) || (ge |= D[G + 2] << 16 - W, U < 24 - W) || (ge |= D[G + 3] << 24 - W), ge & K;
  }
  function Be(D, X, U) {
    var W = X & 7, G = X >>> 3;
    return W <= 5 ? D[G] |= (U & 7) << W : (D[G] |= U << W & 255, D[G + 1] = (U & 7) >> 8 - W), X + 3;
  }
  function We(D, X, U) {
    var W = X & 7, G = X >>> 3;
    return U = (U & 1) << W, D[G] |= U, X + 1;
  }
  function $e(D, X, U) {
    var W = X & 7, G = X >>> 3;
    return U <<= W, D[G] |= U & 255, U >>>= 8, D[G + 1] = U, X + 8;
  }
  function Je(D, X, U) {
    var W = X & 7, G = X >>> 3;
    return U <<= W, D[G] |= U & 255, U >>>= 8, D[G + 1] = U & 255, D[G + 2] = U >>> 8, X + 16;
  }
  function st(D, X) {
    var U = D.length, W = 2 * U > X ? 2 * U : X + 5, G = 0;
    if (U >= X) return D;
    if (It) {
      var K = Rh(W);
      if (D.copy) D.copy(K);
      else for (; G < D.length; ++G) K[G] = D[G];
      return K;
    } else if (ie) {
      var ge = new Uint8Array(W);
      if (ge.set) ge.set(D);
      else for (; G < U; ++G) ge[G] = D[G];
      return ge;
    }
    return D.length = W, D;
  }
  function ot(D) {
    for (var X = new Array(D), U = 0; U < D; ++U) X[U] = 0;
    return X;
  }
  function gt(D, X, U) {
    var W = 1, G = 0, K = 0, ge = 0, Ee = 0, pe = D.length, ye = ie ? new Uint16Array(32) : ot(32);
    for (K = 0; K < 32; ++K) ye[K] = 0;
    for (K = pe; K < U; ++K) D[K] = 0;
    pe = D.length;
    var _e = ie ? new Uint16Array(pe) : ot(pe);
    for (K = 0; K < pe; ++K) ye[G = D[K]]++, W < G && (W = G), _e[K] = 0;
    for (ye[0] = 0, K = 1; K <= W; ++K) ye[K + 16] = Ee = Ee + ye[K - 1] << 1;
    for (K = 0; K < pe; ++K) Ee = D[K], Ee != 0 && (_e[K] = ye[Ee + 16]++);
    var Ue = 0;
    for (K = 0; K < pe; ++K) if (Ue = D[K], Ue != 0) for (Ee = Oe(_e[K], W) >> W - Ue, ge = (1 << W + 4 - Ue) - 1; ge >= 0; --ge) X[Ee | ge << Ue] = Ue & 15 | K << 4;
    return W;
  }
  var _t = ie ? new Uint16Array(512) : ot(512), Tt = ie ? new Uint16Array(32) : ot(32);
  if (!ie) {
    for (var Et = 0; Et < 512; ++Et) _t[Et] = 0;
    for (Et = 0; Et < 32; ++Et) Tt[Et] = 0;
  }
  (function() {
    for (var D = [], X = 0; X < 32; X++) D.push(5);
    gt(D, Tt, 32);
    var U = [];
    for (X = 0; X <= 143; X++) U.push(8);
    for (; X <= 255; X++) U.push(9);
    for (; X <= 279; X++) U.push(7);
    for (; X <= 287; X++) U.push(8);
    gt(U, _t, 288);
  })();
  var ct = function() {
    for (var X = ie ? new Uint8Array(32768) : [], U = 0, W = 0; U < re.length - 1; ++U) for (; W < re[U + 1]; ++W) X[W] = U;
    for (; W < 32768; ++W) X[W] = 29;
    var G = ie ? new Uint8Array(259) : [];
    for (U = 0, W = 0; U < z.length - 1; ++U) for (; W < z[U + 1]; ++W) G[W] = U;
    function K(Ee, pe) {
      for (var ye = 0; ye < Ee.length; ) {
        var _e = Math.min(65535, Ee.length - ye), Ue = ye + _e == Ee.length;
        for (pe.write_shift(1, +Ue), pe.write_shift(2, _e), pe.write_shift(2, ~_e & 65535); _e-- > 0; ) pe[pe.l++] = Ee[ye++];
      }
      return pe.l;
    }
    function ge(Ee, pe) {
      for (var ye = 0, _e = 0, Ue = ie ? new Uint16Array(32768) : []; _e < Ee.length; ) {
        var Ve = (
          /* data.length - boff; */
          Math.min(65535, Ee.length - _e)
        );
        if (Ve < 10) {
          for (ye = Be(pe, ye, +(_e + Ve == Ee.length)), ye & 7 && (ye += 8 - (ye & 7)), pe.l = ye / 8 | 0, pe.write_shift(2, Ve), pe.write_shift(2, ~Ve & 65535); Ve-- > 0; ) pe[pe.l++] = Ee[_e++];
          ye = pe.l * 8;
          continue;
        }
        ye = Be(pe, ye, +(_e + Ve == Ee.length) + 2);
        for (var tt = 0; Ve-- > 0; ) {
          var He = Ee[_e];
          tt = (tt << 5 ^ He) & 32767;
          var et = -1, pt = 0;
          if ((et = Ue[tt]) && (et |= _e & -32768, et > _e && (et -= 32768), et < _e)) for (; Ee[et + pt] == Ee[_e + pt] && pt < 250; ) ++pt;
          if (pt > 2) {
            He = G[pt], He <= 22 ? ye = $e(pe, ye, ve[He + 1] >> 1) - 1 : ($e(pe, ye, 3), ye += 5, $e(pe, ye, ve[He - 23] >> 5), ye += 3);
            var Mt = He < 8 ? 0 : He - 4 >> 2;
            Mt > 0 && (Je(pe, ye, pt - z[He]), ye += Mt), He = X[_e - et], ye = $e(pe, ye, ve[He] >> 3), ye -= 3;
            var Vt = He < 4 ? 0 : He - 2 >> 1;
            Vt > 0 && (Je(pe, ye, _e - et - re[He]), ye += Vt);
            for (var mr = 0; mr < pt; ++mr) Ue[tt] = _e & 32767, tt = (tt << 5 ^ Ee[_e]) & 32767, ++_e;
            Ve -= pt - 1;
          } else He <= 143 ? He = He + 48 : ye = We(pe, ye, 1), ye = $e(pe, ye, ve[He]), Ue[tt] = _e & 32767, ++_e;
        }
        ye = $e(pe, ye, 0) - 1;
      }
      return pe.l = (ye + 7) / 8 | 0, pe.l;
    }
    return function(pe, ye) {
      return pe.length < 8 ? K(pe, ye) : ge(pe, ye);
    };
  }();
  function At(D) {
    var X = Le(50 + Math.floor(D.length * 1.1)), U = ct(D, X);
    return X.slice(0, U);
  }
  var Qe = ie ? new Uint16Array(32768) : ot(32768), br = ie ? new Uint16Array(32768) : ot(32768), Ft = ie ? new Uint16Array(128) : ot(128), sn = 1, Rt = 1;
  function Jt(D, X) {
    var U = Z(D, X) + 257;
    X += 5;
    var W = Z(D, X) + 1;
    X += 5;
    var G = Te(D, X) + 4;
    X += 4;
    for (var K = 0, ge = ie ? new Uint8Array(19) : ot(19), Ee = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], pe = 1, ye = ie ? new Uint8Array(8) : ot(8), _e = ie ? new Uint8Array(8) : ot(8), Ue = ge.length, Ve = 0; Ve < G; ++Ve) ge[C[Ve]] = K = Ye(D, X), pe < K && (pe = K), ye[K]++, X += 3;
    var tt = 0;
    for (ye[0] = 0, Ve = 1; Ve <= pe; ++Ve) _e[Ve] = tt = tt + ye[Ve - 1] << 1;
    for (Ve = 0; Ve < Ue; ++Ve) (tt = ge[Ve]) != 0 && (Ee[Ve] = _e[tt]++);
    var He = 0;
    for (Ve = 0; Ve < Ue; ++Ve) if (He = ge[Ve], He != 0) {
      tt = ve[Ee[Ve]] >> 8 - He;
      for (var et = (1 << 7 - He) - 1; et >= 0; --et) Ft[tt | et << He] = He & 7 | Ve << 3;
    }
    var pt = [];
    for (pe = 1; pt.length < U + W; ) switch (tt = Ft[Ie(D, X)], X += tt & 7, tt >>>= 3) {
      case 16:
        for (K = 3 + qe(D, X), X += 2, tt = pt[pt.length - 1]; K-- > 0; ) pt.push(tt);
        break;
      case 17:
        for (K = 3 + Ye(D, X), X += 3; K-- > 0; ) pt.push(0);
        break;
      case 18:
        for (K = 11 + Ie(D, X), X += 7; K-- > 0; ) pt.push(0);
        break;
      default:
        pt.push(tt), pe < tt && (pe = tt);
        break;
    }
    var Mt = pt.slice(0, U), Vt = pt.slice(U);
    for (Ve = U; Ve < 286; ++Ve) Mt[Ve] = 0;
    for (Ve = W; Ve < 30; ++Ve) Vt[Ve] = 0;
    return sn = gt(Mt, Qe, 286), Rt = gt(Vt, br, 30), X;
  }
  function Cn(D, X) {
    if (D[0] == 3 && !(D[1] & 3)) return [Pa(X), 2];
    for (var U = 0, W = 0, G = Rh(X || 1 << 18), K = 0, ge = G.length >>> 0, Ee = 0, pe = 0; !(W & 1); ) {
      if (W = Ye(D, U), U += 3, W >>> 1) W >> 1 == 1 ? (Ee = 9, pe = 5) : (U = Jt(D, U), Ee = sn, pe = Rt);
      else {
        U & 7 && (U += 8 - (U & 7));
        var ye = D[U >>> 3] | D[(U >>> 3) + 1] << 8;
        if (U += 32, ye > 0) for (!X && ge < K + ye && (G = st(G, K + ye), ge = G.length); ye-- > 0; ) G[K++] = D[U >>> 3], U += 8;
        continue;
      }
      for (; ; ) {
        !X && ge < K + 32767 && (G = st(G, K + 32767), ge = G.length);
        var _e = rt(D, U, Ee), Ue = W >>> 1 == 1 ? _t[_e] : Qe[_e];
        if (U += Ue & 15, Ue >>>= 4, !(Ue >>> 8 & 255)) G[K++] = Ue;
        else {
          if (Ue == 256) break;
          Ue -= 257;
          var Ve = Ue < 8 ? 0 : Ue - 4 >> 2;
          Ve > 5 && (Ve = 0);
          var tt = K + z[Ue];
          Ve > 0 && (tt += rt(D, U, Ve), U += Ve), _e = rt(D, U, pe), Ue = W >>> 1 == 1 ? Tt[_e] : br[_e], U += Ue & 15, Ue >>>= 4;
          var He = Ue < 4 ? 0 : Ue - 2 >> 1, et = re[Ue];
          for (He > 0 && (et += rt(D, U, He), U += He), !X && ge < tt && (G = st(G, tt + 100), ge = G.length); K < tt; ) G[K] = G[K - et], ++K;
        }
      }
    }
    return X ? [G, U + 7 >>> 3] : [G.slice(0, K), U + 7 >>> 3];
  }
  function Ct(D, X) {
    var U = D.slice(D.l || 0), W = Cn(U, X);
    return D.l += W[1], W[0];
  }
  function oi(D, X) {
    if (D) typeof console < "u" && console.error(X);
    else throw new Error(X);
  }
  function er(D, X) {
    var U = (
      /*::(*/
      D
    );
    Tn(U, 0);
    var W = [], G = [], K = {
      FileIndex: W,
      FullPaths: G
    };
    j(K, {
      root: X.root
    });
    for (var ge = U.length - 4; (U[ge] != 80 || U[ge + 1] != 75 || U[ge + 2] != 5 || U[ge + 3] != 6) && ge >= 0; ) --ge;
    U.l = ge + 4, U.l += 4;
    var Ee = U.read_shift(2);
    U.l += 6;
    var pe = U.read_shift(4);
    for (U.l = pe, ge = 0; ge < Ee; ++ge) {
      U.l += 20;
      var ye = U.read_shift(4), _e = U.read_shift(4), Ue = U.read_shift(2), Ve = U.read_shift(2), tt = U.read_shift(2);
      U.l += 8;
      var He = U.read_shift(4), et = o(
        /*::(*/
        U.slice(U.l + Ue, U.l + Ue + Ve)
        /*:: :any)*/
      );
      U.l += Ue + Ve + tt;
      var pt = U.l;
      U.l = He + 4, mn(U, ye, _e, K, et), U.l = pt;
    }
    return K;
  }
  function mn(D, X, U, W, G) {
    D.l += 2;
    var K = D.read_shift(2), ge = D.read_shift(2), Ee = s(D);
    if (K & 8257) throw new Error("Unsupported ZIP encryption");
    for (var pe = D.read_shift(4), ye = D.read_shift(4), _e = D.read_shift(4), Ue = D.read_shift(2), Ve = D.read_shift(2), tt = "", He = 0; He < Ue; ++He) tt += String.fromCharCode(D[D.l++]);
    if (Ve) {
      var et = o(
        /*::(*/
        D.slice(D.l, D.l + Ve)
        /*:: :any)*/
      );
      (et[21589] || {}).mt && (Ee = et[21589].mt), ((G || {})[21589] || {}).mt && (Ee = G[21589].mt);
    }
    D.l += Ve;
    var pt = D.slice(D.l, D.l + ye);
    switch (ge) {
      case 8:
        pt = L(D, _e);
        break;
      case 0:
        break;
      default:
        throw new Error("Unsupported ZIP Compression method " + ge);
    }
    var Mt = false;
    K & 8 && (pe = D.read_shift(4), pe == 134695760 && (pe = D.read_shift(4), Mt = true), ye = D.read_shift(4), _e = D.read_shift(4)), ye != X && oi(Mt, "Bad compressed size: " + X + " != " + ye), _e != U && oi(Mt, "Bad uncompressed size: " + U + " != " + _e), on(W, tt, pt, {
      unsafe: true,
      mt: Ee
    });
  }
  function Wn(D, X) {
    var U = X || {}, W = [], G = [], K = Le(1), ge = U.compression ? 8 : 0, Ee = 0, pe = 0, ye = 0, _e = 0, Ue = 0, Ve = D.FullPaths[0], tt = Ve, He = D.FileIndex[0], et = [], pt = 0;
    for (pe = 1; pe < D.FullPaths.length; ++pe) if (tt = D.FullPaths[pe].slice(Ve.length), He = D.FileIndex[pe], !(!He.size || !He.content || tt == "Sh33tJ5")) {
      var Mt = _e, Vt = Le(tt.length);
      for (ye = 0; ye < tt.length; ++ye) Vt.write_shift(1, tt.charCodeAt(ye) & 127);
      Vt = Vt.slice(0, Vt.l), et[Ue] = Nd.buf(
        /*::((*/
        He.content,
        0
      );
      var mr = He.content;
      ge == 8 && (mr = N(mr)), K = Le(30), K.write_shift(4, 67324752), K.write_shift(2, 20), K.write_shift(2, Ee), K.write_shift(2, ge), He.mt ? a(K, He.mt) : K.write_shift(4, 0), K.write_shift(-4, et[Ue]), K.write_shift(4, mr.length), K.write_shift(
        4,
        /*::(*/
        He.content.length
      ), K.write_shift(2, Vt.length), K.write_shift(2, 0), _e += K.length, W.push(K), _e += Vt.length, W.push(Vt), _e += mr.length, W.push(mr), K = Le(46), K.write_shift(4, 33639248), K.write_shift(2, 0), K.write_shift(2, 20), K.write_shift(2, Ee), K.write_shift(2, ge), K.write_shift(4, 0), K.write_shift(-4, et[Ue]), K.write_shift(4, mr.length), K.write_shift(
        4,
        /*::(*/
        He.content.length
      ), K.write_shift(2, Vt.length), K.write_shift(2, 0), K.write_shift(2, 0), K.write_shift(2, 0), K.write_shift(2, 0), K.write_shift(4, 0), K.write_shift(4, Mt), pt += K.l, G.push(K), pt += Vt.length, G.push(Vt), ++Ue;
    }
    return K = Le(22), K.write_shift(4, 101010256), K.write_shift(2, 0), K.write_shift(2, 0), K.write_shift(2, Ue), K.write_shift(2, Ue), K.write_shift(4, pt), K.write_shift(4, _e), K.write_shift(2, 0), jr([jr(W), jr(G), K]);
  }
  var Yt = {
    htm: "text/html",
    xml: "text/xml",
    gif: "image/gif",
    jpg: "image/jpeg",
    png: "image/png",
    mso: "application/x-mso",
    thmx: "application/vnd.ms-officetheme",
    sh33tj5: "application/octet-stream"
  };
  function vt(D, X) {
    if (D.ctype) return D.ctype;
    var U = D.name || "", W = U.match(/\.([^\.]+)$/);
    return W && Yt[W[1]] || X && (W = (U = X).match(/[\.\\]([^\.\\])+$/), W && Yt[W[1]]) ? Yt[W[1]] : "application/octet-stream";
  }
  function kt(D) {
    for (var X = So(D), U = [], W = 0; W < X.length; W += 76) U.push(X.slice(W, W + 76));
    return U.join(`\r
`) + `\r
`;
  }
  function _i(D) {
    var X = D.replace(/[\x00-\x08\x0B\x0C\x0E-\x1F\x7E-\xFF=]/g, function(ye) {
      var _e = ye.charCodeAt(0).toString(16).toUpperCase();
      return "=" + (_e.length == 1 ? "0" + _e : _e);
    });
    X = X.replace(/ $/mg, "=20").replace(/\t$/mg, "=09"), X.charAt(0) == `
` && (X = "=0D" + X.slice(1)), X = X.replace(/\r(?!\n)/mg, "=0D").replace(/\n\n/mg, `
=0A`).replace(/([^\r\n])\n/mg, "$1=0A");
    for (var U = [], W = X.split(`\r
`), G = 0; G < W.length; ++G) {
      var K = W[G];
      if (K.length == 0) {
        U.push("");
        continue;
      }
      for (var ge = 0; ge < K.length; ) {
        var Ee = 76, pe = K.slice(ge, ge + Ee);
        pe.charAt(Ee - 1) == "=" ? Ee-- : pe.charAt(Ee - 2) == "=" ? Ee -= 2 : pe.charAt(Ee - 3) == "=" && (Ee -= 3), pe = K.slice(ge, ge + Ee), ge += Ee, ge < K.length && (pe += "="), U.push(pe);
      }
    }
    return U.join(`\r
`);
  }
  function Tr(D) {
    for (var X = [], U = 0; U < D.length; ++U) {
      for (var W = D[U]; U <= D.length && W.charAt(W.length - 1) == "="; ) W = W.slice(0, W.length - 1) + D[++U];
      X.push(W);
    }
    for (var G = 0; G < X.length; ++G) X[G] = X[G].replace(/[=][0-9A-Fa-f]{2}/g, function(K) {
      return String.fromCharCode(parseInt(K.slice(1), 16));
    });
    return ri(X.join(`\r
`));
  }
  function Pn(D, X, U) {
    for (var W = "", G = "", K = "", ge, Ee = 0; Ee < 10; ++Ee) {
      var pe = X[Ee];
      if (!pe || pe.match(/^\s*$/)) break;
      var ye = pe.match(/^(.*?):\s*([^\s].*)$/);
      if (ye) switch (ye[1].toLowerCase()) {
        case "content-location":
          W = ye[2].trim();
          break;
        case "content-type":
          K = ye[2].trim();
          break;
        case "content-transfer-encoding":
          G = ye[2].trim();
          break;
      }
    }
    switch (++Ee, G.toLowerCase()) {
      case "base64":
        ge = ri(ji(X.slice(Ee).join("")));
        break;
      case "quoted-printable":
        ge = Tr(X.slice(Ee));
        break;
      default:
        throw new Error("Unsupported Content-Transfer-Encoding " + G);
    }
    var _e = on(D, W.slice(U.length), ge, {
      unsafe: true
    });
    K && (_e.ctype = K);
  }
  function kn(D, X) {
    if (Ae(D.slice(0, 13)).toLowerCase() != "mime-version:") throw new Error("Unsupported MAD header");
    var U = X && X.root || "", W = (It && Buffer.isBuffer(D) ? D.toString("binary") : Ae(D)).split(`\r
`), G = 0, K = "";
    for (G = 0; G < W.length; ++G) if (K = W[G], !!/^Content-Location:/i.test(K) && (K = K.slice(K.indexOf("file")), U || (U = K.slice(0, K.lastIndexOf("/") + 1)), K.slice(0, U.length) != U)) for (; U.length > 0 && (U = U.slice(0, U.length - 1), U = U.slice(0, U.lastIndexOf("/") + 1), K.slice(0, U.length) != U); ) ;
    var ge = (W[1] || "").match(/boundary="(.*?)"/);
    if (!ge) throw new Error("MAD cannot find boundary");
    var Ee = "--" + (ge[1] || ""), pe = [], ye = [], _e = {
      FileIndex: pe,
      FullPaths: ye
    };
    j(_e);
    var Ue, Ve = 0;
    for (G = 0; G < W.length; ++G) {
      var tt = W[G];
      tt !== Ee && tt !== Ee + "--" || (Ve++ && Pn(_e, W.slice(Ue, G), U), Ue = G);
    }
    return _e;
  }
  function lt(D, X) {
    var U = X || {}, W = U.boundary || "SheetJS";
    W = "------=" + W;
    for (var G = ["MIME-Version: 1.0", 'Content-Type: multipart/related; boundary="' + W.slice(2) + '"', "", "", ""], K = D.FullPaths[0], ge = K, Ee = D.FileIndex[0], pe = 1; pe < D.FullPaths.length; ++pe) if (ge = D.FullPaths[pe].slice(K.length), Ee = D.FileIndex[pe], !(!Ee.size || !Ee.content || ge == "Sh33tJ5")) {
      ge = ge.replace(/[\x00-\x08\x0B\x0C\x0E-\x1F\x7E-\xFF]/g, function(pt) {
        return "_x" + pt.charCodeAt(0).toString(16) + "_";
      }).replace(/[\u0080-\uFFFF]/g, function(pt) {
        return "_u" + pt.charCodeAt(0).toString(16) + "_";
      });
      for (var ye = Ee.content, _e = It && Buffer.isBuffer(ye) ? ye.toString("binary") : Ae(ye), Ue = 0, Ve = Math.min(1024, _e.length), tt = 0, He = 0; He <= Ve; ++He) (tt = _e.charCodeAt(He)) >= 32 && tt < 128 && ++Ue;
      var et = Ue >= Ve * 4 / 5;
      G.push(W), G.push("Content-Location: " + (U.root || "file:///C:/SheetJS/") + ge), G.push("Content-Transfer-Encoding: " + (et ? "quoted-printable" : "base64")), G.push("Content-Type: " + vt(Ee, ge)), G.push(""), G.push(et ? _i(_e) : kt(_e));
    }
    return G.push(W + `--\r
`), G.join(`\r
`);
  }
  function xn(D) {
    var X = {};
    return j(X, D), X;
  }
  function on(D, X, U, W) {
    var G = W && W.unsafe;
    G || j(D);
    var K = !G && Xt.find(D, X);
    if (!K) {
      var ge = D.FullPaths[0];
      X.slice(0, ge.length) == ge ? ge = X : (ge.slice(-1) != "/" && (ge += "/"), ge = (ge + X).replace("//", "/")), K = {
        name: i(X),
        type: 2
      }, D.FileIndex.push(K), D.FullPaths.push(ge), G || Xt.utils.cfb_gc(D);
    }
    return K.content = U, K.size = U ? U.length : 0, W && (W.CLSID && (K.clsid = W.CLSID), W.mt && (K.mt = W.mt), W.ct && (K.ct = W.ct)), K;
  }
  function Wr(D, X) {
    j(D);
    var U = Xt.find(D, X);
    if (U) {
      for (var W = 0; W < D.FileIndex.length; ++W) if (D.FileIndex[W] == U) return D.FileIndex.splice(W, 1), D.FullPaths.splice(W, 1), true;
    }
    return false;
  }
  function hr(D, X, U) {
    j(D);
    var W = Xt.find(D, X);
    if (W) {
      for (var G = 0; G < D.FileIndex.length; ++G) if (D.FileIndex[G] == W) return D.FileIndex[G].name = i(U), D.FullPaths[G] = U, true;
    }
    return false;
  }
  function ir(D) {
    H(D, true);
  }
  return e.find = F, e.read = le, e.parse = c, e.write = be, e.writeFile = de, e.utils = {
    cfb_new: xn,
    cfb_add: on,
    cfb_del: Wr,
    cfb_mov: hr,
    cfb_gc: ir,
    ReadShift: go,
    CheckField: Nu,
    prep_blob: Tn,
    bconcat: jr,
    use_zlib: y,
    _deflateRaw: At,
    _inflateRaw: Ct,
    consts: Se
  }, e;
}();
function Fd(r6) {
  return typeof r6 == "string" ? tf(r6) : Array.isArray(r6) ? ed(r6) : r6;
}
function Lo(r6, e, t) {
  if (typeof Deno < "u") {
    if (t && typeof e == "string") switch (t) {
      case "utf8":
        e = new TextEncoder(t).encode(e);
        break;
      case "binary":
        e = tf(e);
        break;
      default:
        throw new Error("Unsupported encoding " + t);
    }
    return Deno.writeFileSync(r6, e);
  }
  var n = t == "utf8" ? Di(e) : e;
  if (typeof IE_SaveFile < "u") return IE_SaveFile(n, r6);
  if (typeof Blob < "u") {
    var i = new Blob([Fd(n)], {
      type: "application/octet-stream"
    });
    if (typeof navigator < "u" && navigator.msSaveBlob) return navigator.msSaveBlob(i, r6);
    if (typeof saveAs < "u") return saveAs(i, r6);
    if (typeof URL < "u" && typeof document < "u" && document.createElement && URL.createObjectURL) {
      var a = URL.createObjectURL(i);
      if (typeof chrome == "object" && typeof (chrome.downloads || {}).download == "function") return URL.revokeObjectURL && typeof setTimeout < "u" && setTimeout(function() {
        URL.revokeObjectURL(a);
      }, 6e4), chrome.downloads.download({
        url: a,
        filename: r6,
        saveAs: true
      });
      var s = document.createElement("a");
      if (s.download != null) return s.download = r6, s.href = a, document.body.appendChild(s), s.click(), document.body.removeChild(s), URL.revokeObjectURL && typeof setTimeout < "u" && setTimeout(function() {
        URL.revokeObjectURL(a);
      }, 6e4), a;
    }
  }
  if (typeof $ < "u" && typeof File < "u" && typeof Folder < "u") try {
    var o = File(r6);
    return o.open("w"), o.encoding = "binary", Array.isArray(e) && (e = Fo(e)), o.write(e), o.close(), e;
  } catch (f) {
    if (!f.message || !f.message.match(/onstruct/)) throw f;
  }
  throw new Error("cannot save file " + r6);
}
function Hr(r6) {
  for (var e = Object.keys(r6), t = [], n = 0; n < e.length; ++n) Object.prototype.hasOwnProperty.call(r6, e[n]) && t.push(e[n]);
  return t;
}
function zh(r6, e) {
  for (var t = [], n = Hr(r6), i = 0; i !== n.length; ++i) t[r6[n[i]][e]] == null && (t[r6[n[i]][e]] = n[i]);
  return t;
}
function Ml(r6) {
  for (var e = [], t = Hr(r6), n = 0; n !== t.length; ++n) e[r6[t[n]]] = t[n];
  return e;
}
function af(r6) {
  for (var e = [], t = Hr(r6), n = 0; n !== t.length; ++n) e[r6[t[n]]] = parseInt(t[n], 10);
  return e;
}
function Ld(r6) {
  for (var e = [], t = Hr(r6), n = 0; n !== t.length; ++n) e[r6[t[n]]] == null && (e[r6[t[n]]] = []), e[r6[t[n]]].push(t[n]);
  return e;
}
var q0 = new Date(1899, 11, 30, 0, 0, 0);
function pn(r6, e) {
  var t = r6.getTime();
  e && (t -= 1462 * 24 * 60 * 60 * 1e3);
  var n = q0.getTime() + (r6.getTimezoneOffset() - q0.getTimezoneOffset()) * 6e4;
  return (t - n) / (24 * 60 * 60 * 1e3);
}
var hu = /* @__PURE__ */ new Date();
var Cd = q0.getTime() + (hu.getTimezoneOffset() - q0.getTimezoneOffset()) * 6e4;
var Vh = hu.getTimezoneOffset();
function cu(r6) {
  var e = /* @__PURE__ */ new Date();
  return e.setTime(r6 * 24 * 60 * 60 * 1e3 + Cd), e.getTimezoneOffset() !== Vh && e.setTime(e.getTime() + (e.getTimezoneOffset() - Vh) * 6e4), e;
}
var Gh = /* @__PURE__ */ new Date("2017-02-19T19:06:09.000Z");
var uu = isNaN(Gh.getFullYear()) ? /* @__PURE__ */ new Date("2/19/17") : Gh;
var Pd = uu.getFullYear() == 2017;
function an(r6, e) {
  var t = new Date(r6);
  if (Pd) return e > 0 ? t.setTime(t.getTime() + t.getTimezoneOffset() * 60 * 1e3) : e < 0 && t.setTime(t.getTime() - t.getTimezoneOffset() * 60 * 1e3), t;
  if (r6 instanceof Date) return r6;
  if (uu.getFullYear() == 1917 && !isNaN(t.getFullYear())) {
    var n = t.getFullYear();
    return r6.indexOf("" + n) > -1 || t.setFullYear(t.getFullYear() + 100), t;
  }
  var i = r6.match(/\d+/g) || ["2017", "2", "19", "0", "0", "0"], a = new Date(+i[0], +i[1] - 1, +i[2], +i[3] || 0, +i[4] || 0, +i[5] || 0);
  return r6.indexOf("Z") > -1 && (a = new Date(a.getTime() - a.getTimezoneOffset() * 60 * 1e3)), a;
}
function sf(r6, e) {
  if (It && Buffer.isBuffer(r6)) {
    if (e) {
      if (r6[0] == 255 && r6[1] == 254) return Di(r6.slice(2).toString("utf16le"));
      if (r6[1] == 254 && r6[2] == 255) return Di(Q2(r6.slice(2).toString("binary")));
    }
    return r6.toString("binary");
  }
  if (typeof TextDecoder < "u") try {
    if (e) {
      if (r6[0] == 255 && r6[1] == 254) return Di(new TextDecoder("utf-16le").decode(r6.slice(2)));
      if (r6[0] == 254 && r6[1] == 255) return Di(new TextDecoder("utf-16be").decode(r6.slice(2)));
    }
    var t = {
      "€": "",
      "‚": "",
      ƒ: "",
      "„": "",
      "…": "",
      "†": "",
      "‡": "",
      "ˆ": "",
      "‰": "",
      Š: "",
      "‹": "",
      Œ: "",
      Ž: "",
      "‘": "",
      "’": "",
      "“": "",
      "”": "",
      "•": "",
      "–": "",
      "—": "",
      "˜": "",
      "™": "",
      š: "",
      "›": "",
      œ: "",
      ž: "",
      Ÿ: ""
    };
    return Array.isArray(r6) && (r6 = new Uint8Array(r6)), new TextDecoder("latin1").decode(r6).replace(/[€‚ƒ„…†‡ˆ‰Š‹ŒŽ‘’“”•–—˜™š›œžŸ]/g, function(a) {
      return t[a] || a;
    });
  } catch {
  }
  for (var n = [], i = 0; i != r6.length; ++i) n.push(String.fromCharCode(r6[i]));
  return n.join("");
}
function gn(r6) {
  if (typeof JSON < "u" && !Array.isArray(r6)) return JSON.parse(JSON.stringify(r6));
  if (typeof r6 != "object" || r6 == null) return r6;
  if (r6 instanceof Date) return new Date(r6.getTime());
  var e = {};
  for (var t in r6) Object.prototype.hasOwnProperty.call(r6, t) && (e[t] = gn(r6[t]));
  return e;
}
function fr(r6, e) {
  for (var t = ""; t.length < e; ) t += r6;
  return t;
}
function Mi(r6) {
  var e = Number(r6);
  if (!isNaN(e)) return isFinite(e) ? e : NaN;
  if (!/\d/.test(r6)) return e;
  var t = 1, n = r6.replace(/([\d]),([\d])/g, "$1$2").replace(/[$]/g, "").replace(/[%]/g, function() {
    return t *= 100, "";
  });
  return !isNaN(e = Number(n)) || (n = n.replace(/[(](.*)[)]/, function(i, a) {
    return t = -t, a;
  }), !isNaN(e = Number(n))) ? e / t : e;
}
var kd = ["january", "february", "march", "april", "may", "june", "july", "august", "september", "october", "november", "december"];
function Ao(r6) {
  var e = new Date(r6), t = /* @__PURE__ */ new Date(NaN), n = e.getYear(), i = e.getMonth(), a = e.getDate();
  if (isNaN(a)) return t;
  var s = r6.toLowerCase();
  if (s.match(/jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec/)) {
    if (s = s.replace(/[^a-z]/g, "").replace(/([^a-z]|^)[ap]m?([^a-z]|$)/, ""), s.length > 3 && kd.indexOf(s) == -1) return t;
  } else if (s.match(/[a-z]/)) return t;
  return n < 0 || n > 8099 ? t : (i > 0 || a > 1) && n != 101 ? e : r6.match(/[^-0-9:,\/\\]/) ? t : e;
}
function bt(r6, e, t) {
  if (r6.FullPaths) {
    if (typeof t == "string") {
      var n;
      return It ? n = Hi(t) : n = td(t), Xt.utils.cfb_add(r6, e, n);
    }
    Xt.utils.cfb_add(r6, e, t);
  } else r6.file(e, t);
}
function Bl() {
  return Xt.utils.cfb_new();
}
var Ar = `<?xml version="1.0" encoding="UTF-8" standalone="yes"?>\r
`;
var Dd = {
  "&quot;": '"',
  "&apos;": "'",
  "&gt;": ">",
  "&lt;": "<",
  "&amp;": "&"
};
var jl = Ml(Dd);
var Ul = /[&<>'"]/g;
var Od = /[\u0000-\u0008\u000b-\u001f]/g;
function Ht(r6) {
  var e = r6 + "";
  return e.replace(Ul, function(t) {
    return jl[t];
  }).replace(Od, function(t) {
    return "_x" + ("000" + t.charCodeAt(0).toString(16)).slice(-4) + "_";
  });
}
function Xh(r6) {
  return Ht(r6).replace(/ /g, "_x0020_");
}
var du = /[\u0000-\u001f]/g;
function Id(r6) {
  var e = r6 + "";
  return e.replace(Ul, function(t) {
    return jl[t];
  }).replace(/\n/g, "<br/>").replace(du, function(t) {
    return "&#x" + ("000" + t.charCodeAt(0).toString(16)).slice(-4) + ";";
  });
}
function Rd(r6) {
  var e = r6 + "";
  return e.replace(Ul, function(t) {
    return jl[t];
  }).replace(du, function(t) {
    return "&#x" + t.charCodeAt(0).toString(16).toUpperCase() + ";";
  });
}
function Md(r6) {
  return r6.replace(/(\r\n|[\r\n])/g, "&#10;");
}
function Bd(r6) {
  switch (r6) {
    case 1:
    case true:
    case "1":
    case "true":
    case "TRUE":
      return true;
    default:
      return false;
  }
}
function Jf(r6) {
  for (var e = "", t = 0, n = 0, i = 0, a = 0, s = 0, o = 0; t < r6.length; ) {
    if (n = r6.charCodeAt(t++), n < 128) {
      e += String.fromCharCode(n);
      continue;
    }
    if (i = r6.charCodeAt(t++), n > 191 && n < 224) {
      s = (n & 31) << 6, s |= i & 63, e += String.fromCharCode(s);
      continue;
    }
    if (a = r6.charCodeAt(t++), n < 240) {
      e += String.fromCharCode((n & 15) << 12 | (i & 63) << 6 | a & 63);
      continue;
    }
    s = r6.charCodeAt(t++), o = ((n & 7) << 18 | (i & 63) << 12 | (a & 63) << 6 | s & 63) - 65536, e += String.fromCharCode(55296 + (o >>> 10 & 1023)), e += String.fromCharCode(56320 + (o & 1023));
  }
  return e;
}
function Yh(r6) {
  var e = Pa(2 * r6.length), t, n, i = 1, a = 0, s = 0, o;
  for (n = 0; n < r6.length; n += i) i = 1, (o = r6.charCodeAt(n)) < 128 ? t = o : o < 224 ? (t = (o & 31) * 64 + (r6.charCodeAt(n + 1) & 63), i = 2) : o < 240 ? (t = (o & 15) * 4096 + (r6.charCodeAt(n + 1) & 63) * 64 + (r6.charCodeAt(n + 2) & 63), i = 3) : (i = 4, t = (o & 7) * 262144 + (r6.charCodeAt(n + 1) & 63) * 4096 + (r6.charCodeAt(n + 2) & 63) * 64 + (r6.charCodeAt(n + 3) & 63), t -= 65536, s = 55296 + (t >>> 10 & 1023), t = 56320 + (t & 1023)), s !== 0 && (e[a++] = s & 255, e[a++] = s >>> 8, s = 0), e[a++] = t % 256, e[a++] = t >>> 8;
  return e.slice(0, a).toString("ucs2");
}
function $h(r6) {
  return Hi(r6, "binary").toString("utf8");
}
var b0 = "foo bar bazâð£";
var po = It && ($h(b0) == Jf(b0) && $h || Yh(b0) == Jf(b0) && Yh) || Jf;
var Di = It ? function(r6) {
  return Hi(r6, "utf8").toString("binary");
} : function(r6) {
  for (var e = [], t = 0, n = 0, i = 0; t < r6.length; ) switch (n = r6.charCodeAt(t++), true) {
    case n < 128:
      e.push(String.fromCharCode(n));
      break;
    case n < 2048:
      e.push(String.fromCharCode(192 + (n >> 6))), e.push(String.fromCharCode(128 + (n & 63)));
      break;
    case (n >= 55296 && n < 57344):
      n -= 55296, i = r6.charCodeAt(t++) - 56320 + (n << 10), e.push(String.fromCharCode(240 + (i >> 18 & 7))), e.push(String.fromCharCode(144 + (i >> 12 & 63))), e.push(String.fromCharCode(128 + (i >> 6 & 63))), e.push(String.fromCharCode(128 + (i & 63)));
      break;
    default:
      e.push(String.fromCharCode(224 + (n >> 12))), e.push(String.fromCharCode(128 + (n >> 6 & 63))), e.push(String.fromCharCode(128 + (n & 63)));
  }
  return e.join("");
};
var jd = function() {
  var r6 = [["nbsp", " "], ["middot", "·"], ["quot", '"'], ["apos", "'"], ["gt", ">"], ["lt", "<"], ["amp", "&"]].map(function(e) {
    return [new RegExp("&" + e[0] + ";", "ig"), e[1]];
  });
  return function(t) {
    for (var n = t.replace(/^[\t\n\r ]+/, "").replace(/[\t\n\r ]+$/, "").replace(/>\s+/g, ">").replace(/\s+</g, "<").replace(/[\t\n\r ]+/g, " ").replace(/<\s*[bB][rR]\s*\/?>/g, `
`).replace(/<[^>]*>/g, ""), i = 0; i < r6.length; ++i) n = n.replace(r6[i][0], r6[i][1]);
    return n;
  };
}();
var pu = /(^\s|\s$|\n)/;
function Ur(r6, e) {
  return "<" + r6 + (e.match(pu) ? ' xml:space="preserve"' : "") + ">" + e + "</" + r6 + ">";
}
function bo(r6) {
  return Hr(r6).map(function(e) {
    return " " + e + '="' + r6[e] + '"';
  }).join("");
}
function Ge(r6, e, t) {
  return "<" + r6 + (t != null ? bo(t) : "") + (e != null ? (e.match(pu) ? ' xml:space="preserve"' : "") + ">" + e + "</" + r6 : "/") + ">";
}
function xl(r6, e) {
  try {
    return r6.toISOString().replace(/\.\d*/, "");
  } catch (t) {
    if (e) throw t;
  }
  return "";
}
function Ud(r6, e) {
  switch (typeof r6) {
    case "string":
      var t = Ge("vt:lpwstr", Ht(r6));
      return e && (t = t.replace(/&quot;/g, "_x0022_")), t;
    case "number":
      return Ge((r6 | 0) == r6 ? "vt:i4" : "vt:r8", Ht(String(r6)));
    case "boolean":
      return Ge("vt:bool", r6 ? "true" : "false");
  }
  if (r6 instanceof Date) return Ge("vt:filetime", xl(r6));
  throw new Error("Unable to serialize " + r6);
}
var kr = {
  CORE_PROPS: "http://schemas.openxmlformats.org/package/2006/metadata/core-properties",
  CUST_PROPS: "http://schemas.openxmlformats.org/officeDocument/2006/custom-properties",
  EXT_PROPS: "http://schemas.openxmlformats.org/officeDocument/2006/extended-properties",
  CT: "http://schemas.openxmlformats.org/package/2006/content-types",
  RELS: "http://schemas.openxmlformats.org/package/2006/relationships",
  TCMNT: "http://schemas.microsoft.com/office/spreadsheetml/2018/threadedcomments",
  dc: "http://purl.org/dc/elements/1.1/",
  dcterms: "http://purl.org/dc/terms/",
  dcmitype: "http://purl.org/dc/dcmitype/",
  mx: "http://schemas.microsoft.com/office/mac/excel/2008/main",
  r: "http://schemas.openxmlformats.org/officeDocument/2006/relationships",
  sjs: "http://schemas.openxmlformats.org/package/2006/sheetjs/core-properties",
  vt: "http://schemas.openxmlformats.org/officeDocument/2006/docPropsVTypes",
  xsi: "http://www.w3.org/2001/XMLSchema-instance",
  xsd: "http://www.w3.org/2001/XMLSchema"
};
var Fs = ["http://schemas.openxmlformats.org/spreadsheetml/2006/main", "http://purl.oclc.org/ooxml/spreadsheetml/main", "http://schemas.microsoft.com/office/excel/2006/main", "http://schemas.microsoft.com/office/excel/2006/2"];
var En = {
  o: "urn:schemas-microsoft-com:office:office",
  x: "urn:schemas-microsoft-com:office:excel",
  ss: "urn:schemas-microsoft-com:office:spreadsheet",
  dt: "uuid:C2F41010-65B3-11d1-A29F-00AA00C14882",
  mv: "http://macVmlSchemaUri",
  v: "urn:schemas-microsoft-com:vml",
  html: "http://www.w3.org/TR/REC-html40"
};
function qd(r6, e) {
  for (var t = 1 - 2 * (r6[e + 7] >>> 7), n = ((r6[e + 7] & 127) << 4) + (r6[e + 6] >>> 4 & 15), i = r6[e + 6] & 15, a = 5; a >= 0; --a) i = i * 256 + r6[e + a];
  return n == 2047 ? i == 0 ? t * (1 / 0) : NaN : (n == 0 ? n = -1022 : (n -= 1023, i += Math.pow(2, 52)), t * Math.pow(2, n - 52) * i);
}
function Hd(r6, e, t) {
  var n = (e < 0 || 1 / e == -1 / 0 ? 1 : 0) << 7, i = 0, a = 0, s = n ? -e : e;
  isFinite(s) ? s == 0 ? i = a = 0 : (i = Math.floor(Math.log(s) / Math.LN2), a = s * Math.pow(2, 52 - i), i <= -1023 && (!isFinite(a) || a < Math.pow(2, 52)) ? i = -1022 : (a -= Math.pow(2, 52), i += 1023)) : (i = 2047, a = isNaN(e) ? 26985 : 0);
  for (var o = 0; o <= 5; ++o, a /= 256) r6[t + o] = a & 255;
  r6[t + 6] = (i & 15) << 4 | a & 15, r6[t + 7] = i >> 4 | n;
}
var Kh = function(r6) {
  for (var e = [], t = 10240, n = 0; n < r6[0].length; ++n) if (r6[0][n]) for (var i = 0, a = r6[0][n].length; i < a; i += t) e.push.apply(e, r6[0][n].slice(i, i + t));
  return e;
};
var Jh = It ? function(r6) {
  return r6[0].length > 0 && Buffer.isBuffer(r6[0][0]) ? Buffer.concat(r6[0].map(function(e) {
    return Buffer.isBuffer(e) ? e : Hi(e);
  })) : Kh(r6);
} : Kh;
var Zh = function(r6, e, t) {
  for (var n = [], i = e; i < t; i += 2) n.push(String.fromCharCode(co(r6, i)));
  return n.join("").replace(uo, "");
};
var ql = It ? function(r6, e, t) {
  return Buffer.isBuffer(r6) ? r6.toString("utf16le", e, t).replace(uo, "") : Zh(r6, e, t);
} : Zh;
var Qh = function(r6, e, t) {
  for (var n = [], i = e; i < e + t; ++i) n.push(("0" + r6[i].toString(16)).slice(-2));
  return n.join("");
};
var gu = It ? function(r6, e, t) {
  return Buffer.isBuffer(r6) ? r6.toString("hex", e, e + t) : Qh(r6, e, t);
} : Qh;
var ec = function(r6, e, t) {
  for (var n = [], i = e; i < t; i++) n.push(String.fromCharCode(ds(r6, i)));
  return n.join("");
};
var Co = It ? function(e, t, n) {
  return Buffer.isBuffer(e) ? e.toString("utf8", t, n) : ec(e, t, n);
} : ec;
var vu = function(r6, e) {
  var t = Nn(r6, e);
  return t > 0 ? Co(r6, e + 4, e + 4 + t - 1) : "";
};
var mu = vu;
var xu = function(r6, e) {
  var t = Nn(r6, e);
  return t > 0 ? Co(r6, e + 4, e + 4 + t - 1) : "";
};
var wu = xu;
var yu = function(r6, e) {
  var t = 2 * Nn(r6, e);
  return t > 0 ? Co(r6, e + 4, e + 4 + t - 1) : "";
};
var _u = yu;
var Su = function(e, t) {
  var n = Nn(e, t);
  return n > 0 ? ql(e, t + 4, t + 4 + n) : "";
};
var Au = Su;
var bu = function(r6, e) {
  var t = Nn(r6, e);
  return t > 0 ? Co(r6, e + 4, e + 4 + t) : "";
};
var Tu = bu;
var Eu = function(r6, e) {
  return qd(r6, e);
};
var H0 = Eu;
var Hl = function(e) {
  return Array.isArray(e) || typeof Uint8Array < "u" && e instanceof Uint8Array;
};
It && (mu = function(e, t) {
  if (!Buffer.isBuffer(e)) return vu(e, t);
  var n = e.readUInt32LE(t);
  return n > 0 ? e.toString("utf8", t + 4, t + 4 + n - 1) : "";
}, wu = function(e, t) {
  if (!Buffer.isBuffer(e)) return xu(e, t);
  var n = e.readUInt32LE(t);
  return n > 0 ? e.toString("utf8", t + 4, t + 4 + n - 1) : "";
}, _u = function(e, t) {
  if (!Buffer.isBuffer(e)) return yu(e, t);
  var n = 2 * e.readUInt32LE(t);
  return e.toString("utf16le", t + 4, t + 4 + n - 1);
}, Au = function(e, t) {
  if (!Buffer.isBuffer(e)) return Su(e, t);
  var n = e.readUInt32LE(t);
  return e.toString("utf16le", t + 4, t + 4 + n);
}, Tu = function(e, t) {
  if (!Buffer.isBuffer(e)) return bu(e, t);
  var n = e.readUInt32LE(t);
  return e.toString("utf8", t + 4, t + 4 + n);
}, H0 = function(e, t) {
  return Buffer.isBuffer(e) ? e.readDoubleLE(t) : Eu(e, t);
}, Hl = function(e) {
  return Buffer.isBuffer(e) || Array.isArray(e) || typeof Uint8Array < "u" && e instanceof Uint8Array;
});
var ds = function(r6, e) {
  return r6[e];
};
var co = function(r6, e) {
  return r6[e + 1] * 256 + r6[e];
};
var Wd = function(r6, e) {
  var t = r6[e + 1] * 256 + r6[e];
  return t < 32768 ? t : (65535 - t + 1) * -1;
};
var Nn = function(r6, e) {
  return r6[e + 3] * (1 << 24) + (r6[e + 2] << 16) + (r6[e + 1] << 8) + r6[e];
};
var Na = function(r6, e) {
  return r6[e + 3] << 24 | r6[e + 2] << 16 | r6[e + 1] << 8 | r6[e];
};
var zd = function(r6, e) {
  return r6[e] << 24 | r6[e + 1] << 16 | r6[e + 2] << 8 | r6[e + 3];
};
function go(r6, e) {
  var t = "", n, i, a = [], s, o, f, h;
  switch (e) {
    case "dbcs":
      if (h = this.l, It && Buffer.isBuffer(this)) t = this.slice(this.l, this.l + 2 * r6).toString("utf16le");
      else for (f = 0; f < r6; ++f) t += String.fromCharCode(co(this, h)), h += 2;
      r6 *= 2;
      break;
    case "utf8":
      t = Co(this, this.l, this.l + r6);
      break;
    case "utf16le":
      r6 *= 2, t = ql(this, this.l, this.l + r6);
      break;
    case "wstr":
      return go.call(this, r6, "dbcs");
    case "lpstr-ansi":
      t = mu(this, this.l), r6 = 4 + Nn(this, this.l);
      break;
    case "lpstr-cp":
      t = wu(this, this.l), r6 = 4 + Nn(this, this.l);
      break;
    case "lpwstr":
      t = _u(this, this.l), r6 = 4 + 2 * Nn(this, this.l);
      break;
    case "lpp4":
      r6 = 4 + Nn(this, this.l), t = Au(this, this.l), r6 & 2 && (r6 += 2);
      break;
    case "8lpp4":
      r6 = 4 + Nn(this, this.l), t = Tu(this, this.l), r6 & 3 && (r6 += 4 - (r6 & 3));
      break;
    case "cstr":
      for (r6 = 0, t = ""; (s = ds(this, this.l + r6++)) !== 0; ) a.push(_0(s));
      t = a.join("");
      break;
    case "_wstr":
      for (r6 = 0, t = ""; (s = co(this, this.l + r6)) !== 0; ) a.push(_0(s)), r6 += 2;
      r6 += 2, t = a.join("");
      break;
    case "dbcs-cont":
      for (t = "", h = this.l, f = 0; f < r6; ++f) {
        if (this.lens && this.lens.indexOf(h) !== -1) return s = ds(this, h), this.l = h + 1, o = go.call(this, r6 - f, s ? "dbcs-cont" : "sbcs-cont"), a.join("") + o;
        a.push(_0(co(this, h))), h += 2;
      }
      t = a.join(""), r6 *= 2;
      break;
    case "cpstr":
    case "sbcs-cont":
      for (t = "", h = this.l, f = 0; f != r6; ++f) {
        if (this.lens && this.lens.indexOf(h) !== -1) return s = ds(this, h), this.l = h + 1, o = go.call(this, r6 - f, s ? "dbcs-cont" : "sbcs-cont"), a.join("") + o;
        a.push(_0(ds(this, h))), h += 1;
      }
      t = a.join("");
      break;
    default:
      switch (r6) {
        case 1:
          return n = ds(this, this.l), this.l++, n;
        case 2:
          return n = (e === "i" ? Wd : co)(this, this.l), this.l += 2, n;
        case 4:
        case -4:
          return e === "i" || !(this[this.l + 3] & 128) ? (n = (r6 > 0 ? Na : zd)(this, this.l), this.l += 4, n) : (i = Nn(this, this.l), this.l += 4, i);
        case 8:
        case -8:
          if (e === "f") return r6 == 8 ? i = H0(this, this.l) : i = H0([this[this.l + 7], this[this.l + 6], this[this.l + 5], this[this.l + 4], this[this.l + 3], this[this.l + 2], this[this.l + 1], this[this.l + 0]], 0), this.l += 8, i;
          r6 = 8;
        case 16:
          t = gu(this, this.l, r6);
          break;
      }
  }
  return this.l += r6, t;
}
var Vd = function(r6, e, t) {
  r6[t] = e & 255, r6[t + 1] = e >>> 8 & 255, r6[t + 2] = e >>> 16 & 255, r6[t + 3] = e >>> 24 & 255;
};
var Gd = function(r6, e, t) {
  r6[t] = e & 255, r6[t + 1] = e >> 8 & 255, r6[t + 2] = e >> 16 & 255, r6[t + 3] = e >> 24 & 255;
};
var Xd = function(r6, e, t) {
  r6[t] = e & 255, r6[t + 1] = e >>> 8 & 255;
};
function Yd(r6, e, t) {
  var n = 0, i = 0;
  if (t === "dbcs") {
    for (i = 0; i != e.length; ++i) Xd(this, e.charCodeAt(i), this.l + 2 * i);
    n = 2 * e.length;
  } else if (t === "sbcs") {
    for (e = e.replace(/[^\x00-\x7F]/g, "_"), i = 0; i != e.length; ++i) this[this.l + i] = e.charCodeAt(i) & 255;
    n = e.length;
  } else if (t === "hex") {
    for (; i < r6; ++i) this[this.l++] = parseInt(e.slice(2 * i, 2 * i + 2), 16) || 0;
    return this;
  } else if (t === "utf16le") {
    var a = Math.min(this.l + r6, this.length);
    for (i = 0; i < Math.min(e.length, r6); ++i) {
      var s = e.charCodeAt(i);
      this[this.l++] = s & 255, this[this.l++] = s >> 8;
    }
    for (; this.l < a; ) this[this.l++] = 0;
    return this;
  } else switch (r6) {
    case 1:
      n = 1, this[this.l] = e & 255;
      break;
    case 2:
      n = 2, this[this.l] = e & 255, e >>>= 8, this[this.l + 1] = e & 255;
      break;
    case 3:
      n = 3, this[this.l] = e & 255, e >>>= 8, this[this.l + 1] = e & 255, e >>>= 8, this[this.l + 2] = e & 255;
      break;
    case 4:
      n = 4, Vd(this, e, this.l);
      break;
    case 8:
      if (n = 8, t === "f") {
        Hd(this, e, this.l);
        break;
      }
    case 16:
      break;
    case -4:
      n = 4, Gd(this, e, this.l);
      break;
  }
  return this.l += n, this;
}
function Nu(r6, e) {
  var t = gu(this, this.l, r6.length >> 1);
  if (t !== r6) throw new Error(e + "Expected " + r6 + " saw " + t);
  this.l += r6.length >> 1;
}
function Tn(r6, e) {
  r6.l = e, r6.read_shift = /*::(*/
  go, r6.chk = Nu, r6.write_shift = Yd;
}
function wi(r6, e) {
  r6.l += e;
}
function Le(r6) {
  var e = Pa(r6);
  return Tn(e, 0), e;
}
function dn() {
  var r6 = [], e = It ? 256 : 2048, t = function(h) {
    var c = Le(h);
    return Tn(c, 0), c;
  }, n = t(e), i = function() {
    n && (n.length > n.l && (n = n.slice(0, n.l), n.l = n.length), n.length > 0 && r6.push(n), n = null);
  }, a = function(h) {
    return n && h < n.length - n.l ? n : (i(), n = t(Math.max(h + 1, e)));
  }, s = function() {
    return i(), jr(r6);
  }, o = function(h) {
    i(), n = h, n.l == null && (n.l = n.length), a(e);
  };
  return {
    next: a,
    push: o,
    end: s,
    _bufs: r6
  };
}
function Re(r6, e, t, n) {
  var i = +e, a;
  if (!isNaN(i)) {
    n || (n = qx[i].p || (t || []).length || 0), a = 1 + (i >= 128 ? 1 : 0) + 1, n >= 128 && ++a, n >= 16384 && ++a, n >= 2097152 && ++a;
    var s = r6.next(a);
    i <= 127 ? s.write_shift(1, i) : (s.write_shift(1, (i & 127) + 128), s.write_shift(1, i >> 7));
    for (var o = 0; o != 4; ++o) if (n >= 128) s.write_shift(1, (n & 127) + 128), n >>= 7;
    else {
      s.write_shift(1, n);
      break;
    }
    n > 0 && Hl(t) && r6.push(t);
  }
}
function vo(r6, e, t) {
  var n = gn(r6);
  if (e.s ? (n.cRel && (n.c += e.s.c), n.rRel && (n.r += e.s.r)) : (n.cRel && (n.c += e.c), n.rRel && (n.r += e.r)), !t || t.biff < 12) {
    for (; n.c >= 256; ) n.c -= 256;
    for (; n.r >= 65536; ) n.r -= 65536;
  }
  return n;
}
function tc(r6, e, t) {
  var n = gn(r6);
  return n.s = vo(n.s, e.s, t), n.e = vo(n.e, e.s, t), n;
}
function mo(r6, e) {
  if (r6.cRel && r6.c < 0) for (r6 = gn(r6); r6.c < 0; ) r6.c += e > 8 ? 16384 : 256;
  if (r6.rRel && r6.r < 0) for (r6 = gn(r6); r6.r < 0; ) r6.r += e > 8 ? 1048576 : e > 5 ? 65536 : 16384;
  var t = zt(r6);
  return !r6.cRel && r6.cRel != null && (t = Jd(t)), !r6.rRel && r6.rRel != null && (t = $d(t)), t;
}
function Zf(r6, e) {
  return r6.s.r == 0 && !r6.s.rRel && r6.e.r == (e.biff >= 12 ? 1048575 : e.biff >= 8 ? 65536 : 16384) && !r6.e.rRel ? (r6.s.cRel ? "" : "$") + Jr(r6.s.c) + ":" + (r6.e.cRel ? "" : "$") + Jr(r6.e.c) : r6.s.c == 0 && !r6.s.cRel && r6.e.c == (e.biff >= 12 ? 16383 : 255) && !r6.e.cRel ? (r6.s.rRel ? "" : "$") + qr(r6.s.r) + ":" + (r6.e.rRel ? "" : "$") + qr(r6.e.r) : mo(r6.s, e.biff) + ":" + mo(r6.e, e.biff);
}
function Wl(r6) {
  return parseInt(Kd(r6), 10) - 1;
}
function qr(r6) {
  return "" + (r6 + 1);
}
function $d(r6) {
  return r6.replace(/([A-Z]|^)(\d+)$/, "$1$$$2");
}
function Kd(r6) {
  return r6.replace(/\$(\d+)$/, "$1");
}
function zl(r6) {
  for (var e = Zd(r6), t = 0, n = 0; n !== e.length; ++n) t = 26 * t + e.charCodeAt(n) - 64;
  return t - 1;
}
function Jr(r6) {
  if (r6 < 0) throw new Error("invalid column " + r6);
  var e = "";
  for (++r6; r6; r6 = Math.floor((r6 - 1) / 26)) e = String.fromCharCode((r6 - 1) % 26 + 65) + e;
  return e;
}
function Jd(r6) {
  return r6.replace(/^([A-Z])/, "$$$1");
}
function Zd(r6) {
  return r6.replace(/^\$([A-Z])/, "$1");
}
function Qd(r6) {
  return r6.replace(/(\$?[A-Z]*)(\$?\d*)/, "$1,$2").split(",");
}
function Dr(r6) {
  for (var e = 0, t = 0, n = 0; n < r6.length; ++n) {
    var i = r6.charCodeAt(n);
    i >= 48 && i <= 57 ? e = 10 * e + (i - 48) : i >= 65 && i <= 90 && (t = 26 * t + (i - 64));
  }
  return {
    c: t - 1,
    r: e - 1
  };
}
function zt(r6) {
  for (var e = r6.c + 1, t = ""; e; e = (e - 1) / 26 | 0) t = String.fromCharCode((e - 1) % 26 + 65) + t;
  return t + (r6.r + 1);
}
function Ln(r6) {
  var e = r6.indexOf(":");
  return e == -1 ? {
    s: Dr(r6),
    e: Dr(r6)
  } : {
    s: Dr(r6.slice(0, e)),
    e: Dr(r6.slice(e + 1))
  };
}
function Sr(r6, e) {
  return typeof e > "u" || typeof e == "number" ? Sr(r6.s, r6.e) : (typeof r6 != "string" && (r6 = zt(r6)), typeof e != "string" && (e = zt(e)), r6 == e ? r6 : r6 + ":" + e);
}
function rr(r6) {
  var e = {
    s: {
      c: 0,
      r: 0
    },
    e: {
      c: 0,
      r: 0
    }
  }, t = 0, n = 0, i = 0, a = r6.length;
  for (t = 0; n < a && !((i = r6.charCodeAt(n) - 64) < 1 || i > 26); ++n) t = 26 * t + i;
  for (e.s.c = --t, t = 0; n < a && !((i = r6.charCodeAt(n) - 48) < 0 || i > 9); ++n) t = 10 * t + i;
  if (e.s.r = --t, n === a || i != 10) return e.e.c = e.s.c, e.e.r = e.s.r, e;
  for (++n, t = 0; n != a && !((i = r6.charCodeAt(n) - 64) < 1 || i > 26); ++n) t = 26 * t + i;
  for (e.e.c = --t, t = 0; n != a && !((i = r6.charCodeAt(n) - 48) < 0 || i > 9); ++n) t = 10 * t + i;
  return e.e.r = --t, e;
}
function rc(r6, e) {
  var t = r6.t == "d" && e instanceof Date;
  if (r6.z != null) try {
    return r6.w = la(r6.z, t ? pn(e) : e);
  } catch {
  }
  try {
    return r6.w = la((r6.XF || {}).numFmtId || (t ? 14 : 0), t ? pn(e) : e);
  } catch {
    return "" + e;
  }
}
function Ui(r6, e, t) {
  return r6 == null || r6.t == null || r6.t == "z" ? "" : r6.w !== void 0 ? r6.w : (r6.t == "d" && !r6.z && t && t.dateNF && (r6.z = t.dateNF), r6.t == "e" ? Po[r6.v] || r6.v : e == null ? rc(r6, r6.v) : rc(r6, e));
}
function Oa(r6, e) {
  var t = e && e.sheet ? e.sheet : "Sheet1", n = {};
  return n[t] = r6, {
    SheetNames: [t],
    Sheets: n
  };
}
function Fu(r6, e, t) {
  var n = t || {}, i = r6 ? Array.isArray(r6) : n.dense, a = r6 || (i ? [] : {}), s = 0, o = 0;
  if (a && n.origin != null) {
    if (typeof n.origin == "number") s = n.origin;
    else {
      var f = typeof n.origin == "string" ? Dr(n.origin) : n.origin;
      s = f.r, o = f.c;
    }
    a["!ref"] || (a["!ref"] = "A1:A1");
  }
  var h = {
    s: {
      c: 1e7,
      r: 1e7
    },
    e: {
      c: 0,
      r: 0
    }
  };
  if (a["!ref"]) {
    var c = rr(a["!ref"]);
    h.s.c = c.s.c, h.s.r = c.s.r, h.e.c = Math.max(h.e.c, c.e.c), h.e.r = Math.max(h.e.r, c.e.r), s == -1 && (h.e.r = s = c.e.r + 1);
  }
  for (var p = 0; p != e.length; ++p) if (e[p]) {
    if (!Array.isArray(e[p])) throw new Error("aoa_to_sheet expects an array of arrays");
    for (var v = 0; v != e[p].length; ++v) if (!(typeof e[p][v] > "u")) {
      var d = {
        v: e[p][v]
      }, w = s + p, x = o + v;
      if (h.s.r > w && (h.s.r = w), h.s.c > x && (h.s.c = x), h.e.r < w && (h.e.r = w), h.e.c < x && (h.e.c = x), e[p][v] && typeof e[p][v] == "object" && !Array.isArray(e[p][v]) && !(e[p][v] instanceof Date)) d = e[p][v];
      else if (Array.isArray(d.v) && (d.f = e[p][v][1], d.v = d.v[0]), d.v === null) {
        if (d.f) d.t = "n";
        else if (n.nullError) d.t = "e", d.v = 0;
        else if (n.sheetStubs) d.t = "z";
        else continue;
      } else typeof d.v == "number" ? d.t = "n" : typeof d.v == "boolean" ? d.t = "b" : d.v instanceof Date ? (d.z = n.dateNF || lr[14], n.cellDates ? (d.t = "d", d.w = la(d.z, pn(d.v))) : (d.t = "n", d.v = pn(d.v), d.w = la(d.z, d.v))) : d.t = "s";
      if (i) a[w] || (a[w] = []), a[w][x] && a[w][x].z && (d.z = a[w][x].z), a[w][x] = d;
      else {
        var S = zt({
          c: x,
          r: w
        });
        a[S] && a[S].z && (d.z = a[S].z), a[S] = d;
      }
    }
  }
  return h.s.c < 1e7 && (a["!ref"] = Sr(h)), a;
}
function Ls(r6, e) {
  return Fu(null, r6, e);
}
function ep(r6) {
  return r6.read_shift(4, "i");
}
function ii(r6, e) {
  return e || (e = Le(4)), e.write_shift(4, r6), e;
}
function Zr(r6) {
  var e = r6.read_shift(4);
  return e === 0 ? "" : r6.read_shift(e, "dbcs");
}
function Or(r6, e) {
  var t = false;
  return e == null && (t = true, e = Le(4 + 2 * r6.length)), e.write_shift(4, r6.length), r6.length > 0 && e.write_shift(0, r6, "dbcs"), t ? e.slice(0, e.l) : e;
}
function tp(r6) {
  return {
    ich: r6.read_shift(2),
    ifnt: r6.read_shift(2)
  };
}
function rp(r6, e) {
  return e || (e = Le(4)), e.write_shift(2, r6.ich || 0), e.write_shift(2, r6.ifnt || 0), e;
}
function Vl(r6, e) {
  var t = r6.l, n = r6.read_shift(1), i = Zr(r6), a = [], s = {
    t: i,
    h: i
  };
  if (n & 1) {
    for (var o = r6.read_shift(4), f = 0; f != o; ++f) a.push(tp(r6));
    s.r = a;
  } else s.r = [{
    ich: 0,
    ifnt: 0
  }];
  return r6.l = t + e, s;
}
function np(r6, e) {
  var t = false;
  return e == null && (t = true, e = Le(15 + 4 * r6.t.length)), e.write_shift(1, 0), Or(r6.t, e), t ? e.slice(0, e.l) : e;
}
var ip = Vl;
function ap(r6, e) {
  var t = false;
  return e == null && (t = true, e = Le(23 + 4 * r6.t.length)), e.write_shift(1, 1), Or(r6.t, e), e.write_shift(4, 1), rp({
    ich: 0,
    ifnt: 0
  }, e), t ? e.slice(0, e.l) : e;
}
function Hn(r6) {
  var e = r6.read_shift(4), t = r6.read_shift(2);
  return t += r6.read_shift(1) << 16, r6.l++, {
    c: e,
    iStyleRef: t
  };
}
function Ia(r6, e) {
  return e == null && (e = Le(8)), e.write_shift(-4, r6.c), e.write_shift(3, r6.iStyleRef || r6.s), e.write_shift(1, 0), e;
}
function Ra(r6) {
  var e = r6.read_shift(2);
  return e += r6.read_shift(1) << 16, r6.l++, {
    c: -1,
    iStyleRef: e
  };
}
function Ma(r6, e) {
  return e == null && (e = Le(4)), e.write_shift(3, r6.iStyleRef || r6.s), e.write_shift(1, 0), e;
}
var sp = Zr;
var Lu = Or;
function Gl(r6) {
  var e = r6.read_shift(4);
  return e === 0 || e === 4294967295 ? "" : r6.read_shift(e, "dbcs");
}
function W0(r6, e) {
  var t = false;
  return e == null && (t = true, e = Le(127)), e.write_shift(4, r6.length > 0 ? r6.length : 4294967295), r6.length > 0 && e.write_shift(0, r6, "dbcs"), t ? e.slice(0, e.l) : e;
}
var op = Zr;
var wl = Gl;
var Xl = W0;
function Cu(r6) {
  var e = r6.slice(r6.l, r6.l + 4), t = e[0] & 1, n = e[0] & 2;
  r6.l += 4;
  var i = n === 0 ? H0([0, 0, 0, 0, e[0] & 252, e[1], e[2], e[3]], 0) : Na(e, 0) >> 2;
  return t ? i / 100 : i;
}
function Pu(r6, e) {
  e == null && (e = Le(4));
  var t = 0, n = 0, i = r6 * 100;
  if (r6 == (r6 | 0) && r6 >= -(1 << 29) && r6 < 1 << 29 ? n = 1 : i == (i | 0) && i >= -(1 << 29) && i < 1 << 29 && (n = 1, t = 1), n) e.write_shift(-4, ((t ? i : r6) << 2) + (t + 2));
  else throw new Error("unsupported RkNumber " + r6);
}
function ku(r6) {
  var e = {
    s: {},
    e: {}
  };
  return e.s.r = r6.read_shift(4), e.e.r = r6.read_shift(4), e.s.c = r6.read_shift(4), e.e.c = r6.read_shift(4), e;
}
function fp(r6, e) {
  return e || (e = Le(16)), e.write_shift(4, r6.s.r), e.write_shift(4, r6.e.r), e.write_shift(4, r6.s.c), e.write_shift(4, r6.e.c), e;
}
var Ba = ku;
var Cs = fp;
function Ps(r6) {
  if (r6.length - r6.l < 8) throw "XLS Xnum Buffer underflow";
  return r6.read_shift(8, "f");
}
function ka(r6, e) {
  return (e || Le(8)).write_shift(8, r6, "f");
}
function lp(r6) {
  var e = {}, t = r6.read_shift(1), n = t >>> 1, i = r6.read_shift(1), a = r6.read_shift(2, "i"), s = r6.read_shift(1), o = r6.read_shift(1), f = r6.read_shift(1);
  switch (r6.l++, n) {
    case 0:
      e.auto = 1;
      break;
    case 1:
      e.index = i;
      var h = xp[i];
      h && (e.rgb = dc(h));
      break;
    case 2:
      e.rgb = dc([s, o, f]);
      break;
    case 3:
      e.theme = i;
      break;
  }
  return a != 0 && (e.tint = a > 0 ? a / 32767 : a / 32768), e;
}
function z0(r6, e) {
  if (e || (e = Le(8)), !r6 || r6.auto) return e.write_shift(4, 0), e.write_shift(4, 0), e;
  r6.index != null ? (e.write_shift(1, 2), e.write_shift(1, r6.index)) : r6.theme != null ? (e.write_shift(1, 6), e.write_shift(1, r6.theme)) : (e.write_shift(1, 5), e.write_shift(1, 0));
  var t = r6.tint || 0;
  if (t > 0 ? t *= 32767 : t < 0 && (t *= 32768), e.write_shift(2, t), !r6.rgb || r6.theme != null) e.write_shift(2, 0), e.write_shift(1, 0), e.write_shift(1, 0);
  else {
    var n = r6.rgb || "FFFFFF";
    typeof n == "number" && (n = ("000000" + n.toString(16)).slice(-6)), e.write_shift(1, parseInt(n.slice(0, 2), 16)), e.write_shift(1, parseInt(n.slice(2, 4), 16)), e.write_shift(1, parseInt(n.slice(4, 6), 16)), e.write_shift(1, 255);
  }
  return e;
}
function hp(r6) {
  var e = r6.read_shift(1);
  r6.l++;
  var t = {
    fBold: e & 1,
    fItalic: e & 2,
    fUnderline: e & 4,
    fStrikeout: e & 8,
    fOutline: e & 16,
    fShadow: e & 32,
    fCondense: e & 64,
    fExtend: e & 128
  };
  return t;
}
function cp(r6, e) {
  e || (e = Le(2));
  var t = (r6.italic ? 2 : 0) | (r6.strike ? 8 : 0) | (r6.outline ? 16 : 0) | (r6.shadow ? 32 : 0) | (r6.condense ? 64 : 0) | (r6.extend ? 128 : 0);
  return e.write_shift(1, t), e.write_shift(1, 0), e;
}
var Du = 2;
var bn = 3;
var T0 = 11;
var V0 = 19;
var E0 = 64;
var up = 65;
var dp = 71;
var pp = 4108;
var gp = 4126;
var Br = 80;
var nc = {
  /*::[*/
  1: {
    n: "CodePage",
    t: Du
  },
  /*::[*/
  2: {
    n: "Category",
    t: Br
  },
  /*::[*/
  3: {
    n: "PresentationFormat",
    t: Br
  },
  /*::[*/
  4: {
    n: "ByteCount",
    t: bn
  },
  /*::[*/
  5: {
    n: "LineCount",
    t: bn
  },
  /*::[*/
  6: {
    n: "ParagraphCount",
    t: bn
  },
  /*::[*/
  7: {
    n: "SlideCount",
    t: bn
  },
  /*::[*/
  8: {
    n: "NoteCount",
    t: bn
  },
  /*::[*/
  9: {
    n: "HiddenCount",
    t: bn
  },
  /*::[*/
  10: {
    n: "MultimediaClipCount",
    t: bn
  },
  /*::[*/
  11: {
    n: "ScaleCrop",
    t: T0
  },
  /*::[*/
  12: {
    n: "HeadingPairs",
    t: pp
    /* VT_VECTOR | VT_VARIANT */
  },
  /*::[*/
  13: {
    n: "TitlesOfParts",
    t: gp
    /* VT_VECTOR | VT_LPSTR */
  },
  /*::[*/
  14: {
    n: "Manager",
    t: Br
  },
  /*::[*/
  15: {
    n: "Company",
    t: Br
  },
  /*::[*/
  16: {
    n: "LinksUpToDate",
    t: T0
  },
  /*::[*/
  17: {
    n: "CharacterCount",
    t: bn
  },
  /*::[*/
  19: {
    n: "SharedDoc",
    t: T0
  },
  /*::[*/
  22: {
    n: "HyperlinksChanged",
    t: T0
  },
  /*::[*/
  23: {
    n: "AppVersion",
    t: bn,
    p: "version"
  },
  /*::[*/
  24: {
    n: "DigSig",
    t: up
  },
  /*::[*/
  26: {
    n: "ContentType",
    t: Br
  },
  /*::[*/
  27: {
    n: "ContentStatus",
    t: Br
  },
  /*::[*/
  28: {
    n: "Language",
    t: Br
  },
  /*::[*/
  29: {
    n: "Version",
    t: Br
  },
  /*::[*/
  255: {},
  /* [MS-OLEPS] 2.18 */
  /*::[*/
  2147483648: {
    n: "Locale",
    t: V0
  },
  /*::[*/
  2147483651: {
    n: "Behavior",
    t: V0
  },
  /*::[*/
  1919054434: {}
};
var ic = {
  /*::[*/
  1: {
    n: "CodePage",
    t: Du
  },
  /*::[*/
  2: {
    n: "Title",
    t: Br
  },
  /*::[*/
  3: {
    n: "Subject",
    t: Br
  },
  /*::[*/
  4: {
    n: "Author",
    t: Br
  },
  /*::[*/
  5: {
    n: "Keywords",
    t: Br
  },
  /*::[*/
  6: {
    n: "Comments",
    t: Br
  },
  /*::[*/
  7: {
    n: "Template",
    t: Br
  },
  /*::[*/
  8: {
    n: "LastAuthor",
    t: Br
  },
  /*::[*/
  9: {
    n: "RevNumber",
    t: Br
  },
  /*::[*/
  10: {
    n: "EditTime",
    t: E0
  },
  /*::[*/
  11: {
    n: "LastPrinted",
    t: E0
  },
  /*::[*/
  12: {
    n: "CreatedDate",
    t: E0
  },
  /*::[*/
  13: {
    n: "ModifiedDate",
    t: E0
  },
  /*::[*/
  14: {
    n: "PageCount",
    t: bn
  },
  /*::[*/
  15: {
    n: "WordCount",
    t: bn
  },
  /*::[*/
  16: {
    n: "CharCount",
    t: bn
  },
  /*::[*/
  17: {
    n: "Thumbnail",
    t: dp
  },
  /*::[*/
  18: {
    n: "Application",
    t: Br
  },
  /*::[*/
  19: {
    n: "DocSecurity",
    t: bn
  },
  /*::[*/
  255: {},
  /* [MS-OLEPS] 2.18 */
  /*::[*/
  2147483648: {
    n: "Locale",
    t: V0
  },
  /*::[*/
  2147483651: {
    n: "Behavior",
    t: V0
  },
  /*::[*/
  1919054434: {}
};
function vp(r6) {
  return r6.map(function(e) {
    return [e >> 16 & 255, e >> 8 & 255, e & 255];
  });
}
var mp = vp([
  /* Color Constants */
  0,
  16777215,
  16711680,
  65280,
  255,
  16776960,
  16711935,
  65535,
  /* Overridable Defaults */
  0,
  16777215,
  16711680,
  65280,
  255,
  16776960,
  16711935,
  65535,
  8388608,
  32768,
  128,
  8421376,
  8388736,
  32896,
  12632256,
  8421504,
  10066431,
  10040166,
  16777164,
  13434879,
  6684774,
  16744576,
  26316,
  13421823,
  128,
  16711935,
  16776960,
  65535,
  8388736,
  8388608,
  32896,
  255,
  52479,
  13434879,
  13434828,
  16777113,
  10079487,
  16751052,
  13408767,
  16764057,
  3368703,
  3394764,
  10079232,
  16763904,
  16750848,
  16737792,
  6710937,
  9868950,
  13158,
  3381606,
  13056,
  3355392,
  10040064,
  10040166,
  3355545,
  3355443,
  /* Other entries to appease BIFF8/12 */
  16777215,
  /* 0x40 icvForeground ?? */
  0,
  /* 0x41 icvBackground ?? */
  0,
  /* 0x42 icvFrame ?? */
  0,
  /* 0x43 icv3D ?? */
  0,
  /* 0x44 icv3DText ?? */
  0,
  /* 0x45 icv3DHilite ?? */
  0,
  /* 0x46 icv3DShadow ?? */
  0,
  /* 0x47 icvHilite ?? */
  0,
  /* 0x48 icvCtlText ?? */
  0,
  /* 0x49 icvCtlScrl ?? */
  0,
  /* 0x4A icvCtlInv ?? */
  0,
  /* 0x4B icvCtlBody ?? */
  0,
  /* 0x4C icvCtlFrame ?? */
  0,
  /* 0x4D icvCtlFore ?? */
  0,
  /* 0x4E icvCtlBack ?? */
  0,
  /* 0x4F icvCtlNeutral */
  0,
  /* 0x50 icvInfoBk ?? */
  0
  /* 0x51 icvInfoText ?? */
]);
var xp = gn(mp);
var Po = {
  /*::[*/
  0: "#NULL!",
  /*::[*/
  7: "#DIV/0!",
  /*::[*/
  15: "#VALUE!",
  /*::[*/
  23: "#REF!",
  /*::[*/
  29: "#NAME?",
  /*::[*/
  36: "#NUM!",
  /*::[*/
  42: "#N/A",
  /*::[*/
  43: "#GETTING_DATA",
  /*::[*/
  255: "#WTF?"
};
var wp = {
  /* Workbook */
  "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet.main+xml": "workbooks",
  "application/vnd.ms-excel.sheet.macroEnabled.main+xml": "workbooks",
  "application/vnd.ms-excel.sheet.binary.macroEnabled.main": "workbooks",
  "application/vnd.ms-excel.addin.macroEnabled.main+xml": "workbooks",
  "application/vnd.openxmlformats-officedocument.spreadsheetml.template.main+xml": "workbooks",
  /* Worksheet */
  "application/vnd.openxmlformats-officedocument.spreadsheetml.worksheet+xml": "sheets",
  "application/vnd.ms-excel.worksheet": "sheets",
  "application/vnd.ms-excel.binIndexWs": "TODO",
  /* Binary Index */
  /* Chartsheet */
  "application/vnd.openxmlformats-officedocument.spreadsheetml.chartsheet+xml": "charts",
  "application/vnd.ms-excel.chartsheet": "charts",
  /* Macrosheet */
  "application/vnd.ms-excel.macrosheet+xml": "macros",
  "application/vnd.ms-excel.macrosheet": "macros",
  "application/vnd.ms-excel.intlmacrosheet": "TODO",
  "application/vnd.ms-excel.binIndexMs": "TODO",
  /* Binary Index */
  /* Dialogsheet */
  "application/vnd.openxmlformats-officedocument.spreadsheetml.dialogsheet+xml": "dialogs",
  "application/vnd.ms-excel.dialogsheet": "dialogs",
  /* Shared Strings */
  "application/vnd.openxmlformats-officedocument.spreadsheetml.sharedStrings+xml": "strs",
  "application/vnd.ms-excel.sharedStrings": "strs",
  /* Styles */
  "application/vnd.openxmlformats-officedocument.spreadsheetml.styles+xml": "styles",
  "application/vnd.ms-excel.styles": "styles",
  /* File Properties */
  "application/vnd.openxmlformats-package.core-properties+xml": "coreprops",
  "application/vnd.openxmlformats-officedocument.custom-properties+xml": "custprops",
  "application/vnd.openxmlformats-officedocument.extended-properties+xml": "extprops",
  /* Custom Data Properties */
  "application/vnd.openxmlformats-officedocument.customXmlProperties+xml": "TODO",
  "application/vnd.openxmlformats-officedocument.spreadsheetml.customProperty": "TODO",
  /* Comments */
  "application/vnd.openxmlformats-officedocument.spreadsheetml.comments+xml": "comments",
  "application/vnd.ms-excel.comments": "comments",
  "application/vnd.ms-excel.threadedcomments+xml": "threadedcomments",
  "application/vnd.ms-excel.person+xml": "people",
  /* Metadata (Stock/Geography and Dynamic Array) */
  "application/vnd.openxmlformats-officedocument.spreadsheetml.sheetMetadata+xml": "metadata",
  "application/vnd.ms-excel.sheetMetadata": "metadata",
  /* PivotTable */
  "application/vnd.ms-excel.pivotTable": "TODO",
  "application/vnd.openxmlformats-officedocument.spreadsheetml.pivotTable+xml": "TODO",
  /* Chart Objects */
  "application/vnd.openxmlformats-officedocument.drawingml.chart+xml": "TODO",
  /* Chart Colors */
  "application/vnd.ms-office.chartcolorstyle+xml": "TODO",
  /* Chart Style */
  "application/vnd.ms-office.chartstyle+xml": "TODO",
  /* Chart Advanced */
  "application/vnd.ms-office.chartex+xml": "TODO",
  /* Calculation Chain */
  "application/vnd.ms-excel.calcChain": "calcchains",
  "application/vnd.openxmlformats-officedocument.spreadsheetml.calcChain+xml": "calcchains",
  /* Printer Settings */
  "application/vnd.openxmlformats-officedocument.spreadsheetml.printerSettings": "TODO",
  /* ActiveX */
  "application/vnd.ms-office.activeX": "TODO",
  "application/vnd.ms-office.activeX+xml": "TODO",
  /* Custom Toolbars */
  "application/vnd.ms-excel.attachedToolbars": "TODO",
  /* External Data Connections */
  "application/vnd.ms-excel.connections": "TODO",
  "application/vnd.openxmlformats-officedocument.spreadsheetml.connections+xml": "TODO",
  /* External Links */
  "application/vnd.ms-excel.externalLink": "links",
  "application/vnd.openxmlformats-officedocument.spreadsheetml.externalLink+xml": "links",
  /* PivotCache */
  "application/vnd.ms-excel.pivotCacheDefinition": "TODO",
  "application/vnd.ms-excel.pivotCacheRecords": "TODO",
  "application/vnd.openxmlformats-officedocument.spreadsheetml.pivotCacheDefinition+xml": "TODO",
  "application/vnd.openxmlformats-officedocument.spreadsheetml.pivotCacheRecords+xml": "TODO",
  /* Query Table */
  "application/vnd.ms-excel.queryTable": "TODO",
  "application/vnd.openxmlformats-officedocument.spreadsheetml.queryTable+xml": "TODO",
  /* Shared Workbook */
  "application/vnd.ms-excel.userNames": "TODO",
  "application/vnd.ms-excel.revisionHeaders": "TODO",
  "application/vnd.ms-excel.revisionLog": "TODO",
  "application/vnd.openxmlformats-officedocument.spreadsheetml.revisionHeaders+xml": "TODO",
  "application/vnd.openxmlformats-officedocument.spreadsheetml.revisionLog+xml": "TODO",
  "application/vnd.openxmlformats-officedocument.spreadsheetml.userNames+xml": "TODO",
  /* Single Cell Table */
  "application/vnd.ms-excel.tableSingleCells": "TODO",
  "application/vnd.openxmlformats-officedocument.spreadsheetml.tableSingleCells+xml": "TODO",
  /* Slicer */
  "application/vnd.ms-excel.slicer": "TODO",
  "application/vnd.ms-excel.slicerCache": "TODO",
  "application/vnd.ms-excel.slicer+xml": "TODO",
  "application/vnd.ms-excel.slicerCache+xml": "TODO",
  /* Sort Map */
  "application/vnd.ms-excel.wsSortMap": "TODO",
  /* Table */
  "application/vnd.ms-excel.table": "TODO",
  "application/vnd.openxmlformats-officedocument.spreadsheetml.table+xml": "TODO",
  /* Themes */
  "application/vnd.openxmlformats-officedocument.theme+xml": "themes",
  /* Theme Override */
  "application/vnd.openxmlformats-officedocument.themeOverride+xml": "TODO",
  /* Timeline */
  "application/vnd.ms-excel.Timeline+xml": "TODO",
  /* verify */
  "application/vnd.ms-excel.TimelineCache+xml": "TODO",
  /* verify */
  /* VBA */
  "application/vnd.ms-office.vbaProject": "vba",
  "application/vnd.ms-office.vbaProjectSignature": "TODO",
  /* Volatile Dependencies */
  "application/vnd.ms-office.volatileDependencies": "TODO",
  "application/vnd.openxmlformats-officedocument.spreadsheetml.volatileDependencies+xml": "TODO",
  /* Control Properties */
  "application/vnd.ms-excel.controlproperties+xml": "TODO",
  /* Data Model */
  "application/vnd.openxmlformats-officedocument.model+data": "TODO",
  /* Survey */
  "application/vnd.ms-excel.Survey+xml": "TODO",
  /* Drawing */
  "application/vnd.openxmlformats-officedocument.drawing+xml": "drawings",
  "application/vnd.openxmlformats-officedocument.drawingml.chartshapes+xml": "TODO",
  "application/vnd.openxmlformats-officedocument.drawingml.diagramColors+xml": "TODO",
  "application/vnd.openxmlformats-officedocument.drawingml.diagramData+xml": "TODO",
  "application/vnd.openxmlformats-officedocument.drawingml.diagramLayout+xml": "TODO",
  "application/vnd.openxmlformats-officedocument.drawingml.diagramStyle+xml": "TODO",
  /* VML */
  "application/vnd.openxmlformats-officedocument.vmlDrawing": "TODO",
  "application/vnd.openxmlformats-package.relationships+xml": "rels",
  "application/vnd.openxmlformats-officedocument.oleObject": "TODO",
  /* Image */
  "image/png": "TODO",
  sheet: "js"
};
var N0 = {
  workbooks: {
    xlsx: "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet.main+xml",
    xlsm: "application/vnd.ms-excel.sheet.macroEnabled.main+xml",
    xlsb: "application/vnd.ms-excel.sheet.binary.macroEnabled.main",
    xlam: "application/vnd.ms-excel.addin.macroEnabled.main+xml",
    xltx: "application/vnd.openxmlformats-officedocument.spreadsheetml.template.main+xml"
  },
  strs: {
    /* Shared Strings */
    xlsx: "application/vnd.openxmlformats-officedocument.spreadsheetml.sharedStrings+xml",
    xlsb: "application/vnd.ms-excel.sharedStrings"
  },
  comments: {
    /* Comments */
    xlsx: "application/vnd.openxmlformats-officedocument.spreadsheetml.comments+xml",
    xlsb: "application/vnd.ms-excel.comments"
  },
  sheets: {
    /* Worksheet */
    xlsx: "application/vnd.openxmlformats-officedocument.spreadsheetml.worksheet+xml",
    xlsb: "application/vnd.ms-excel.worksheet"
  },
  charts: {
    /* Chartsheet */
    xlsx: "application/vnd.openxmlformats-officedocument.spreadsheetml.chartsheet+xml",
    xlsb: "application/vnd.ms-excel.chartsheet"
  },
  dialogs: {
    /* Dialogsheet */
    xlsx: "application/vnd.openxmlformats-officedocument.spreadsheetml.dialogsheet+xml",
    xlsb: "application/vnd.ms-excel.dialogsheet"
  },
  macros: {
    /* Macrosheet (Excel 4.0 Macros) */
    xlsx: "application/vnd.ms-excel.macrosheet+xml",
    xlsb: "application/vnd.ms-excel.macrosheet"
  },
  metadata: {
    /* Metadata (Stock/Geography and Dynamic Array) */
    xlsx: "application/vnd.openxmlformats-officedocument.spreadsheetml.sheetMetadata+xml",
    xlsb: "application/vnd.ms-excel.sheetMetadata"
  },
  styles: {
    /* Styles */
    xlsx: "application/vnd.openxmlformats-officedocument.spreadsheetml.styles+xml",
    xlsb: "application/vnd.ms-excel.styles"
  }
};
function Ou() {
  return {
    workbooks: [],
    sheets: [],
    charts: [],
    dialogs: [],
    macros: [],
    rels: [],
    strs: [],
    comments: [],
    threadedcomments: [],
    links: [],
    coreprops: [],
    extprops: [],
    custprops: [],
    themes: [],
    styles: [],
    calcchains: [],
    vba: [],
    drawings: [],
    metadata: [],
    people: [],
    TODO: [],
    xmlns: ""
  };
}
function Iu(r6, e) {
  var t = Ld(wp), n = [], i;
  n[n.length] = Ar, n[n.length] = Ge("Types", null, {
    xmlns: kr.CT,
    "xmlns:xsd": kr.xsd,
    "xmlns:xsi": kr.xsi
  }), n = n.concat([
    ["xml", "application/xml"],
    ["bin", "application/vnd.ms-excel.sheet.binary.macroEnabled.main"],
    ["vml", "application/vnd.openxmlformats-officedocument.vmlDrawing"],
    ["data", "application/vnd.openxmlformats-officedocument.model+data"],
    /* from test files */
    ["bmp", "image/bmp"],
    ["png", "image/png"],
    ["gif", "image/gif"],
    ["emf", "image/x-emf"],
    ["wmf", "image/x-wmf"],
    ["jpg", "image/jpeg"],
    ["jpeg", "image/jpeg"],
    ["tif", "image/tiff"],
    ["tiff", "image/tiff"],
    ["pdf", "application/pdf"],
    ["rels", "application/vnd.openxmlformats-package.relationships+xml"]
  ].map(function(f) {
    return Ge("Default", null, {
      Extension: f[0],
      ContentType: f[1]
    });
  }));
  var a = function(f) {
    r6[f] && r6[f].length > 0 && (i = r6[f][0], n[n.length] = Ge("Override", null, {
      PartName: (i[0] == "/" ? "" : "/") + i,
      ContentType: N0[f][e.bookType] || N0[f].xlsx
    }));
  }, s = function(f) {
    (r6[f] || []).forEach(function(h) {
      n[n.length] = Ge("Override", null, {
        PartName: (h[0] == "/" ? "" : "/") + h,
        ContentType: N0[f][e.bookType] || N0[f].xlsx
      });
    });
  }, o = function(f) {
    (r6[f] || []).forEach(function(h) {
      n[n.length] = Ge("Override", null, {
        PartName: (h[0] == "/" ? "" : "/") + h,
        ContentType: t[f][0]
      });
    });
  };
  return a("workbooks"), s("sheets"), s("charts"), o("themes"), ["strs", "styles"].forEach(a), ["coreprops", "extprops", "custprops"].forEach(o), o("vba"), o("comments"), o("threadedcomments"), o("drawings"), s("metadata"), o("people"), n.length > 2 && (n[n.length] = "</Types>", n[1] = n[1].replace("/>", ">")), n.join("");
}
var Dt = {
  WB: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/officeDocument",
  SHEET: "http://sheetjs.openxmlformats.org/officeDocument/2006/relationships/officeDocument",
  HLINK: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/hyperlink",
  VML: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/vmlDrawing",
  XPATH: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/externalLinkPath",
  XMISS: "http://schemas.microsoft.com/office/2006/relationships/xlExternalLinkPath/xlPathMissing",
  XLINK: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/externalLink",
  CXML: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/customXml",
  CXMLP: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/customXmlProps",
  CMNT: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/comments",
  CORE_PROPS: "http://schemas.openxmlformats.org/package/2006/relationships/metadata/core-properties",
  EXT_PROPS: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/extended-properties",
  CUST_PROPS: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/custom-properties",
  SST: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/sharedStrings",
  STY: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/styles",
  THEME: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/theme",
  CHART: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/chart",
  CHARTEX: "http://schemas.microsoft.com/office/2014/relationships/chartEx",
  CS: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/chartsheet",
  WS: ["http://schemas.openxmlformats.org/officeDocument/2006/relationships/worksheet", "http://purl.oclc.org/ooxml/officeDocument/relationships/worksheet"],
  DS: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/dialogsheet",
  MS: "http://schemas.microsoft.com/office/2006/relationships/xlMacrosheet",
  IMG: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/image",
  DRAW: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/drawing",
  XLMETA: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/sheetMetadata",
  TCMNT: "http://schemas.microsoft.com/office/2017/10/relationships/threadedComment",
  PEOPLE: "http://schemas.microsoft.com/office/2017/10/relationships/person",
  VBA: "http://schemas.microsoft.com/office/2006/relationships/vbaProject"
};
function Ru(r6) {
  var e = r6.lastIndexOf("/");
  return r6.slice(0, e + 1) + "_rels/" + r6.slice(e + 1) + ".rels";
}
function ws(r6) {
  var e = [Ar, Ge("Relationships", null, {
    //'xmlns:ns0': XMLNS.RELS,
    xmlns: kr.RELS
  })];
  return Hr(r6["!id"]).forEach(function(t) {
    e[e.length] = Ge("Relationship", null, r6["!id"][t]);
  }), e.length > 2 && (e[e.length] = "</Relationships>", e[1] = e[1].replace("/>", ">")), e.join("");
}
function qt(r6, e, t, n, i, a) {
  if (i || (i = {}), r6["!id"] || (r6["!id"] = {}), r6["!idx"] || (r6["!idx"] = 1), e < 0) for (e = r6["!idx"]; r6["!id"]["rId" + e]; ++e) ;
  if (r6["!idx"] = e + 1, i.Id = "rId" + e, i.Type = n, i.Target = t, a ? i.TargetMode = a : [Dt.HLINK, Dt.XPATH, Dt.XMISS].indexOf(i.Type) > -1 && (i.TargetMode = "External"), r6["!id"][i.Id]) throw new Error("Cannot rewrite rId " + e);
  return r6["!id"][i.Id] = i, r6[("/" + i.Target).replace("//", "/")] = i, e;
}
function yp(r6) {
  var e = [Ar];
  e.push(`<manifest:manifest xmlns:manifest="urn:oasis:names:tc:opendocument:xmlns:manifest:1.0" manifest:version="1.2">
`), e.push(`  <manifest:file-entry manifest:full-path="/" manifest:version="1.2" manifest:media-type="application/vnd.oasis.opendocument.spreadsheet"/>
`);
  for (var t = 0; t < r6.length; ++t) e.push('  <manifest:file-entry manifest:full-path="' + r6[t][0] + '" manifest:media-type="' + r6[t][1] + `"/>
`);
  return e.push("</manifest:manifest>"), e.join("");
}
function ac(r6, e, t) {
  return ['  <rdf:Description rdf:about="' + r6 + `">
`, '    <rdf:type rdf:resource="http://docs.oasis-open.org/ns/office/1.2/meta/' + (t || "odf") + "#" + e + `"/>
`, `  </rdf:Description>
`].join("");
}
function _p(r6, e) {
  return ['  <rdf:Description rdf:about="' + r6 + `">
`, '    <ns0:hasPart xmlns:ns0="http://docs.oasis-open.org/ns/office/1.2/meta/pkg#" rdf:resource="' + e + `"/>
`, `  </rdf:Description>
`].join("");
}
function Sp(r6) {
  var e = [Ar];
  e.push(`<rdf:RDF xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#">
`);
  for (var t = 0; t != r6.length; ++t) e.push(ac(r6[t][0], r6[t][1])), e.push(_p("", r6[t][0]));
  return e.push(ac("", "Document", "pkg")), e.push("</rdf:RDF>"), e.join("");
}
function Mu() {
  return '<office:document-meta xmlns:office="urn:oasis:names:tc:opendocument:xmlns:office:1.0" xmlns:meta="urn:oasis:names:tc:opendocument:xmlns:meta:1.0" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:xlink="http://www.w3.org/1999/xlink" office:version="1.2"><office:meta><meta:generator>SheetJS ' + M0.version + "</meta:generator></office:meta></office:document-meta>";
}
var La = [["cp:category", "Category"], ["cp:contentStatus", "ContentStatus"], ["cp:keywords", "Keywords"], ["cp:lastModifiedBy", "LastAuthor"], ["cp:lastPrinted", "LastPrinted"], ["cp:revision", "RevNumber"], ["cp:version", "Version"], ["dc:creator", "Author"], ["dc:description", "Comments"], ["dc:identifier", "Identifier"], ["dc:language", "Language"], ["dc:subject", "Subject"], ["dc:title", "Title"], ["dcterms:created", "CreatedDate", "date"], ["dcterms:modified", "ModifiedDate", "date"]];
function Qf(r6, e, t, n, i) {
  i[r6] != null || e == null || e === "" || (i[r6] = e, e = Ht(e), n[n.length] = t ? Ge(r6, e, t) : Ur(r6, e));
}
function Bu(r6, e) {
  var t = e || {}, n = [Ar, Ge("cp:coreProperties", null, {
    //'xmlns': XMLNS.CORE_PROPS,
    "xmlns:cp": kr.CORE_PROPS,
    "xmlns:dc": kr.dc,
    "xmlns:dcterms": kr.dcterms,
    "xmlns:dcmitype": kr.dcmitype,
    "xmlns:xsi": kr.xsi
  })], i = {};
  if (!r6 && !t.Props) return n.join("");
  r6 && (r6.CreatedDate != null && Qf("dcterms:created", typeof r6.CreatedDate == "string" ? r6.CreatedDate : xl(r6.CreatedDate, t.WTF), {
    "xsi:type": "dcterms:W3CDTF"
  }, n, i), r6.ModifiedDate != null && Qf("dcterms:modified", typeof r6.ModifiedDate == "string" ? r6.ModifiedDate : xl(r6.ModifiedDate, t.WTF), {
    "xsi:type": "dcterms:W3CDTF"
  }, n, i));
  for (var a = 0; a != La.length; ++a) {
    var s = La[a], o = t.Props && t.Props[s[1]] != null ? t.Props[s[1]] : r6 ? r6[s[1]] : null;
    o === true ? o = "1" : o === false ? o = "0" : typeof o == "number" && (o = String(o)), o != null && Qf(s[0], o, null, n, i);
  }
  return n.length > 2 && (n[n.length] = "</cp:coreProperties>", n[1] = n[1].replace("/>", ">")), n.join("");
}
var ys = [["Application", "Application", "string"], ["AppVersion", "AppVersion", "string"], ["Company", "Company", "string"], ["DocSecurity", "DocSecurity", "string"], ["Manager", "Manager", "string"], ["HyperlinksChanged", "HyperlinksChanged", "bool"], ["SharedDoc", "SharedDoc", "bool"], ["LinksUpToDate", "LinksUpToDate", "bool"], ["ScaleCrop", "ScaleCrop", "bool"], ["HeadingPairs", "HeadingPairs", "raw"], ["TitlesOfParts", "TitlesOfParts", "raw"]];
var ju = ["Worksheets", "SheetNames", "NamedRanges", "DefinedNames", "Chartsheets", "ChartNames"];
function Uu(r6) {
  var e = [], t = Ge;
  return r6 || (r6 = {}), r6.Application = "SheetJS", e[e.length] = Ar, e[e.length] = Ge("Properties", null, {
    xmlns: kr.EXT_PROPS,
    "xmlns:vt": kr.vt
  }), ys.forEach(function(n) {
    if (r6[n[1]] !== void 0) {
      var i;
      switch (n[2]) {
        case "string":
          i = Ht(String(r6[n[1]]));
          break;
        case "bool":
          i = r6[n[1]] ? "true" : "false";
          break;
      }
      i !== void 0 && (e[e.length] = t(n[0], i));
    }
  }), e[e.length] = t("HeadingPairs", t("vt:vector", t("vt:variant", "<vt:lpstr>Worksheets</vt:lpstr>") + t("vt:variant", t("vt:i4", String(r6.Worksheets))), {
    size: 2,
    baseType: "variant"
  })), e[e.length] = t("TitlesOfParts", t("vt:vector", r6.SheetNames.map(function(n) {
    return "<vt:lpstr>" + Ht(n) + "</vt:lpstr>";
  }).join(""), {
    size: r6.Worksheets,
    baseType: "lpstr"
  })), e.length > 2 && (e[e.length] = "</Properties>", e[1] = e[1].replace("/>", ">")), e.join("");
}
function qu(r6) {
  var e = [Ar, Ge("Properties", null, {
    xmlns: kr.CUST_PROPS,
    "xmlns:vt": kr.vt
  })];
  if (!r6) return e.join("");
  var t = 1;
  return Hr(r6).forEach(function(i) {
    ++t, e[e.length] = Ge("property", Ud(r6[i], true), {
      fmtid: "{D5CDD505-2E9C-101B-9397-08002B2CF9AE}",
      pid: t,
      name: Ht(i)
    });
  }), e.length > 2 && (e[e.length] = "</Properties>", e[1] = e[1].replace("/>", ">")), e.join("");
}
var sc = {
  Title: "Title",
  Subject: "Subject",
  Author: "Author",
  Keywords: "Keywords",
  Comments: "Description",
  LastAuthor: "LastAuthor",
  RevNumber: "Revision",
  Application: "AppName",
  /* TotalTime: 'TotalTime', */
  LastPrinted: "LastPrinted",
  CreatedDate: "Created",
  ModifiedDate: "LastSaved",
  /* Pages */
  /* Words */
  /* Characters */
  Category: "Category",
  /* PresentationFormat */
  Manager: "Manager",
  Company: "Company",
  /* Guid */
  /* HyperlinkBase */
  /* Bytes */
  /* Lines */
  /* Paragraphs */
  /* CharactersWithSpaces */
  AppVersion: "Version",
  ContentStatus: "ContentStatus",
  /* NOTE: missing from schema */
  Identifier: "Identifier",
  /* NOTE: missing from schema */
  Language: "Language"
  /* NOTE: missing from schema */
};
function Ap(r6, e) {
  var t = [];
  return Hr(sc).map(function(n) {
    for (var i = 0; i < La.length; ++i) if (La[i][1] == n) return La[i];
    for (i = 0; i < ys.length; ++i) if (ys[i][1] == n) return ys[i];
    throw n;
  }).forEach(function(n) {
    if (r6[n[1]] != null) {
      var i = e && e.Props && e.Props[n[1]] != null ? e.Props[n[1]] : r6[n[1]];
      switch (n[2]) {
        case "date":
          i = new Date(i).toISOString().replace(/\.\d*Z/, "Z");
          break;
      }
      typeof i == "number" ? i = String(i) : i === true || i === false ? i = i ? "1" : "0" : i instanceof Date && (i = new Date(i).toISOString().replace(/\.\d*Z/, "")), t.push(Ur(sc[n[1]] || n[1], i));
    }
  }), Ge("DocumentProperties", t.join(""), {
    xmlns: En.o
  });
}
function bp(r6, e) {
  var t = ["Worksheets", "SheetNames"], n = "CustomDocumentProperties", i = [];
  return r6 && Hr(r6).forEach(function(a) {
    if (Object.prototype.hasOwnProperty.call(r6, a)) {
      for (var s = 0; s < La.length; ++s) if (a == La[s][1]) return;
      for (s = 0; s < ys.length; ++s) if (a == ys[s][1]) return;
      for (s = 0; s < t.length; ++s) if (a == t[s]) return;
      var o = r6[a], f = "string";
      typeof o == "number" ? (f = "float", o = String(o)) : o === true || o === false ? (f = "boolean", o = o ? "1" : "0") : o = String(o), i.push(Ge(Xh(a), o, {
        "dt:dt": f
      }));
    }
  }), e && Hr(e).forEach(function(a) {
    if (Object.prototype.hasOwnProperty.call(e, a) && !(r6 && Object.prototype.hasOwnProperty.call(r6, a))) {
      var s = e[a], o = "string";
      typeof s == "number" ? (o = "float", s = String(s)) : s === true || s === false ? (o = "boolean", s = s ? "1" : "0") : s instanceof Date ? (o = "dateTime.tz", s = s.toISOString()) : s = String(s), i.push(Ge(Xh(a), s, {
        "dt:dt": o
      }));
    }
  }), "<" + n + ' xmlns="' + En.o + '">' + i.join("") + "</" + n + ">";
}
function Tp(r6) {
  var e = typeof r6 == "string" ? new Date(Date.parse(r6)) : r6, t = e.getTime() / 1e3 + 11644473600, n = t % Math.pow(2, 32), i = (t - n) / Math.pow(2, 32);
  n *= 1e7, i *= 1e7;
  var a = n / Math.pow(2, 32) | 0;
  a > 0 && (n = n % Math.pow(2, 32), i += a);
  var s = Le(8);
  return s.write_shift(4, n), s.write_shift(4, i), s;
}
function oc(r6, e) {
  var t = Le(4), n = Le(4);
  switch (t.write_shift(4, r6 == 80 ? 31 : r6), r6) {
    case 3:
      n.write_shift(-4, e);
      break;
    case 5:
      n = Le(8), n.write_shift(8, e, "f");
      break;
    case 11:
      n.write_shift(4, e ? 1 : 0);
      break;
    case 64:
      n = Tp(e);
      break;
    case 31:
    case 80:
      for (n = Le(4 + 2 * (e.length + 1) + (e.length % 2 ? 0 : 2)), n.write_shift(4, e.length + 1), n.write_shift(0, e, "dbcs"); n.l != n.length; ) n.write_shift(1, 0);
      break;
    default:
      throw new Error("TypedPropertyValue unrecognized type " + r6 + " " + e);
  }
  return jr([t, n]);
}
var Hu = ["CodePage", "Thumbnail", "_PID_LINKBASE", "_PID_HLINKS", "SystemIdentifier", "FMTID"];
function Ep(r6) {
  switch (typeof r6) {
    case "boolean":
      return 11;
    case "number":
      return (r6 | 0) == r6 ? 3 : 5;
    case "string":
      return 31;
    case "object":
      if (r6 instanceof Date) return 64;
      break;
  }
  return -1;
}
function fc(r6, e, t) {
  var n = Le(8), i = [], a = [], s = 8, o = 0, f = Le(8), h = Le(8);
  if (f.write_shift(4, 2), f.write_shift(4, 1200), h.write_shift(4, 1), a.push(f), i.push(h), s += 8 + f.length, !e) {
    h = Le(8), h.write_shift(4, 0), i.unshift(h);
    var c = [Le(4)];
    for (c[0].write_shift(4, r6.length), o = 0; o < r6.length; ++o) {
      var p = r6[o][0];
      for (f = Le(4 + 4 + 2 * (p.length + 1) + (p.length % 2 ? 0 : 2)), f.write_shift(4, o + 2), f.write_shift(4, p.length + 1), f.write_shift(0, p, "dbcs"); f.l != f.length; ) f.write_shift(1, 0);
      c.push(f);
    }
    f = jr(c), a.unshift(f), s += 8 + f.length;
  }
  for (o = 0; o < r6.length; ++o) if (!(e && !e[r6[o][0]]) && !(Hu.indexOf(r6[o][0]) > -1 || ju.indexOf(r6[o][0]) > -1) && r6[o][1] != null) {
    var v = r6[o][1], d = 0;
    if (e) {
      d = +e[r6[o][0]];
      var w = t[d];
      if (w.p == "version" && typeof v == "string") {
        var x = v.split(".");
        v = (+x[0] << 16) + (+x[1] || 0);
      }
      f = oc(w.t, v);
    } else {
      var S = Ep(v);
      S == -1 && (S = 31, v = String(v)), f = oc(S, v);
    }
    a.push(f), h = Le(8), h.write_shift(4, e ? d : 2 + o), i.push(h), s += 8 + f.length;
  }
  var A = 8 * (a.length + 1);
  for (o = 0; o < a.length; ++o) i[o].write_shift(4, A), A += a[o].length;
  return n.write_shift(4, s), n.write_shift(4, a.length), jr([n].concat(i).concat(a));
}
function lc(r6, e, t, n, i, a) {
  var s = Le(i ? 68 : 48), o = [s];
  s.write_shift(2, 65534), s.write_shift(2, 0), s.write_shift(4, 842412599), s.write_shift(16, Xt.utils.consts.HEADER_CLSID, "hex"), s.write_shift(4, i ? 2 : 1), s.write_shift(16, e, "hex"), s.write_shift(4, i ? 68 : 48);
  var f = fc(r6, t, n);
  if (o.push(f), i) {
    var h = fc(i, null, null);
    s.write_shift(16, a, "hex"), s.write_shift(4, 68 + f.length), o.push(h);
  }
  return jr(o);
}
function Np(r6, e) {
  e || (e = Le(r6));
  for (var t = 0; t < r6; ++t) e.write_shift(1, 0);
  return e;
}
function Fp(r6, e) {
  return r6.read_shift(e) === 1;
}
function nn(r6, e) {
  return e || (e = Le(2)), e.write_shift(2, +!!r6), e;
}
function Wu(r6) {
  return r6.read_shift(2, "u");
}
function qn(r6, e) {
  return e || (e = Le(2)), e.write_shift(2, r6), e;
}
function zu(r6, e, t) {
  return t || (t = Le(2)), t.write_shift(1, e == "e" ? +r6 : +!!r6), t.write_shift(1, e == "e" ? 1 : 0), t;
}
function Vu(r6, e, t) {
  var n = r6.read_shift(t && t.biff >= 12 ? 2 : 1), i = "sbcs-cont";
  if (t && t.biff >= 8, !t || t.biff == 8) {
    var a = r6.read_shift(1);
    a && (i = "dbcs-cont");
  } else t.biff == 12 && (i = "wstr");
  t.biff >= 2 && t.biff <= 5 && (i = "cpstr");
  var s = n ? r6.read_shift(n, i) : "";
  return s;
}
function Lp(r6) {
  var e = r6.t || "", t = Le(3 + 0);
  t.write_shift(2, e.length), t.write_shift(1, 1);
  var n = Le(2 * e.length);
  n.write_shift(2 * e.length, e, "utf16le");
  var i = [t, n];
  return jr(i);
}
function Cp(r6, e, t) {
  var n;
  if (t) {
    if (t.biff >= 2 && t.biff <= 5) return r6.read_shift(e, "cpstr");
    if (t.biff >= 12) return r6.read_shift(e, "dbcs-cont");
  }
  var i = r6.read_shift(1);
  return i === 0 ? n = r6.read_shift(e, "sbcs-cont") : n = r6.read_shift(e, "dbcs-cont"), n;
}
function Pp(r6, e, t) {
  var n = r6.read_shift(t && t.biff == 2 ? 1 : 2);
  return n === 0 ? (r6.l++, "") : Cp(r6, n, t);
}
function kp(r6, e, t) {
  if (t.biff > 5) return Pp(r6, e, t);
  var n = r6.read_shift(1);
  return n === 0 ? (r6.l++, "") : r6.read_shift(n, t.biff <= 4 || !r6.lens ? "cpstr" : "sbcs-cont");
}
function Gu(r6, e, t) {
  return t || (t = Le(3 + 2 * r6.length)), t.write_shift(2, r6.length), t.write_shift(1, 1), t.write_shift(31, r6, "utf16le"), t;
}
function hc(r6, e) {
  e || (e = Le(6 + r6.length * 2)), e.write_shift(4, 1 + r6.length);
  for (var t = 0; t < r6.length; ++t) e.write_shift(2, r6.charCodeAt(t));
  return e.write_shift(2, 0), e;
}
function Dp(r6) {
  var e = Le(512), t = 0, n = r6.Target;
  n.slice(0, 7) == "file://" && (n = n.slice(7));
  var i = n.indexOf("#"), a = i > -1 ? 31 : 23;
  switch (n.charAt(0)) {
    case "#":
      a = 28;
      break;
    case ".":
      a &= -3;
      break;
  }
  e.write_shift(4, 2), e.write_shift(4, a);
  var s = [8, 6815827, 6619237, 4849780, 83];
  for (t = 0; t < s.length; ++t) e.write_shift(4, s[t]);
  if (a == 28) n = n.slice(1), hc(n, e);
  else if (a & 2) {
    for (s = "e0 c9 ea 79 f9 ba ce 11 8c 82 00 aa 00 4b a9 0b".split(" "), t = 0; t < s.length; ++t) e.write_shift(1, parseInt(s[t], 16));
    var o = i > -1 ? n.slice(0, i) : n;
    for (e.write_shift(4, 2 * (o.length + 1)), t = 0; t < o.length; ++t) e.write_shift(2, o.charCodeAt(t));
    e.write_shift(2, 0), a & 8 && hc(i > -1 ? n.slice(i + 1) : "", e);
  } else {
    for (s = "03 03 00 00 00 00 00 00 c0 00 00 00 00 00 00 46".split(" "), t = 0; t < s.length; ++t) e.write_shift(1, parseInt(s[t], 16));
    for (var f = 0; n.slice(f * 3, f * 3 + 3) == "../" || n.slice(f * 3, f * 3 + 3) == "..\\"; ) ++f;
    for (e.write_shift(2, f), e.write_shift(4, n.length - 3 * f + 1), t = 0; t < n.length - 3 * f; ++t) e.write_shift(1, n.charCodeAt(t + 3 * f) & 255);
    for (e.write_shift(1, 0), e.write_shift(2, 65535), e.write_shift(2, 57005), t = 0; t < 6; ++t) e.write_shift(4, 0);
  }
  return e.slice(0, e.l);
}
function Da(r6, e, t, n) {
  return n || (n = Le(6)), n.write_shift(2, r6), n.write_shift(2, e), n.write_shift(2, t || 0), n;
}
function Op(r6, e, t) {
  var n = t.biff > 8 ? 4 : 2, i = r6.read_shift(n), a = r6.read_shift(n, "i"), s = r6.read_shift(n, "i");
  return [i, a, s];
}
function Ip(r6) {
  var e = r6.read_shift(2), t = r6.read_shift(2), n = r6.read_shift(2), i = r6.read_shift(2);
  return {
    s: {
      c: n,
      r: e
    },
    e: {
      c: i,
      r: t
    }
  };
}
function Xu(r6, e) {
  return e || (e = Le(8)), e.write_shift(2, r6.s.r), e.write_shift(2, r6.e.r), e.write_shift(2, r6.s.c), e.write_shift(2, r6.e.c), e;
}
function Yl(r6, e, t) {
  var n = 1536, i = 16;
  switch (t.bookType) {
    case "biff8":
      break;
    case "biff5":
      n = 1280, i = 8;
      break;
    case "biff4":
      n = 4, i = 6;
      break;
    case "biff3":
      n = 3, i = 6;
      break;
    case "biff2":
      n = 2, i = 4;
      break;
    case "xla":
      break;
    default:
      throw new Error("unsupported BIFF version");
  }
  var a = Le(i);
  return a.write_shift(2, n), a.write_shift(2, e), i > 4 && a.write_shift(2, 29282), i > 6 && a.write_shift(2, 1997), i > 8 && (a.write_shift(2, 49161), a.write_shift(2, 1), a.write_shift(2, 1798), a.write_shift(2, 0)), a;
}
function Rp(r6, e) {
  var t = !e || e.biff == 8, n = Le(t ? 112 : 54);
  for (n.write_shift(e.biff == 8 ? 2 : 1, 7), t && n.write_shift(1, 0), n.write_shift(4, 859007059), n.write_shift(4, 5458548 | (t ? 0 : 536870912)); n.l < n.length; ) n.write_shift(1, t ? 0 : 32);
  return n;
}
function Mp(r6, e) {
  var t = !e || e.biff >= 8 ? 2 : 1, n = Le(8 + t * r6.name.length);
  n.write_shift(4, r6.pos), n.write_shift(1, r6.hs || 0), n.write_shift(1, r6.dt), n.write_shift(1, r6.name.length), e.biff >= 8 && n.write_shift(1, 1), n.write_shift(t * r6.name.length, r6.name, e.biff < 8 ? "sbcs" : "utf16le");
  var i = n.slice(0, n.l);
  return i.l = n.l, i;
}
function Bp(r6, e) {
  var t = Le(8);
  t.write_shift(4, r6.Count), t.write_shift(4, r6.Unique);
  for (var n = [], i = 0; i < r6.length; ++i) n[i] = Lp(r6[i]);
  var a = jr([t].concat(n));
  return a.parts = [t.length].concat(n.map(function(s) {
    return s.length;
  })), a;
}
function jp() {
  var r6 = Le(18);
  return r6.write_shift(2, 0), r6.write_shift(2, 0), r6.write_shift(2, 29280), r6.write_shift(2, 17600), r6.write_shift(2, 56), r6.write_shift(2, 0), r6.write_shift(2, 0), r6.write_shift(2, 1), r6.write_shift(2, 500), r6;
}
function Up(r6) {
  var e = Le(18), t = 1718;
  return r6 && r6.RTL && (t |= 64), e.write_shift(2, t), e.write_shift(4, 0), e.write_shift(4, 64), e.write_shift(4, 0), e.write_shift(4, 0), e;
}
function qp(r6, e) {
  var t = r6.name || "Arial", n = e && e.biff == 5, i = n ? 15 + t.length : 16 + 2 * t.length, a = Le(i);
  return a.write_shift(2, (r6.sz || 12) * 20), a.write_shift(4, 0), a.write_shift(2, 400), a.write_shift(4, 0), a.write_shift(2, 0), a.write_shift(1, t.length), n || a.write_shift(1, 1), a.write_shift((n ? 1 : 2) * t.length, t, n ? "sbcs" : "utf16le"), a;
}
function Hp(r6, e, t, n) {
  var i = Le(10);
  return Da(r6, e, n, i), i.write_shift(4, t), i;
}
function Wp(r6, e, t, n, i) {
  var a = !i || i.biff == 8, s = Le(6 + 2 + +a + (1 + a) * t.length);
  return Da(r6, e, n, s), s.write_shift(2, t.length), a && s.write_shift(1, 1), s.write_shift((1 + a) * t.length, t, a ? "utf16le" : "sbcs"), s;
}
function zp(r6, e, t, n) {
  var i = t && t.biff == 5;
  n || (n = Le(i ? 3 + e.length : 5 + 2 * e.length)), n.write_shift(2, r6), n.write_shift(i ? 1 : 2, e.length), i || n.write_shift(1, 1), n.write_shift((i ? 1 : 2) * e.length, e, i ? "sbcs" : "utf16le");
  var a = n.length > n.l ? n.slice(0, n.l) : n;
  return a.l == null && (a.l = a.length), a;
}
function Vp(r6, e) {
  var t = e.biff == 8 || !e.biff ? 4 : 2, n = Le(2 * t + 6);
  return n.write_shift(t, r6.s.r), n.write_shift(t, r6.e.r + 1), n.write_shift(2, r6.s.c), n.write_shift(2, r6.e.c + 1), n.write_shift(2, 0), n;
}
function cc(r6, e, t, n) {
  var i = t && t.biff == 5;
  n || (n = Le(i ? 16 : 20)), n.write_shift(2, 0), r6.style ? (n.write_shift(2, r6.numFmtId || 0), n.write_shift(2, 65524)) : (n.write_shift(2, r6.numFmtId || 0), n.write_shift(2, e << 4));
  var a = 0;
  return r6.numFmtId > 0 && i && (a |= 1024), n.write_shift(4, a), n.write_shift(4, 0), i || n.write_shift(4, 0), n.write_shift(2, 0), n;
}
function Gp(r6) {
  var e = Le(8);
  return e.write_shift(4, 0), e.write_shift(2, r6[0] ? r6[0] + 1 : 0), e.write_shift(2, r6[1] ? r6[1] + 1 : 0), e;
}
function Xp(r6, e, t, n, i, a) {
  var s = Le(8);
  return Da(r6, e, n, s), zu(t, a, s), s;
}
function Yp(r6, e, t, n) {
  var i = Le(14);
  return Da(r6, e, n, i), ka(t, i), i;
}
function $p(r6, e, t) {
  if (t.biff < 8) return Kp(r6, e, t);
  for (var n = [], i = r6.l + e, a = r6.read_shift(t.biff > 8 ? 4 : 2); a-- !== 0; ) n.push(Op(r6, t.biff > 8 ? 12 : 6, t));
  if (r6.l != i) throw new Error("Bad ExternSheet: " + r6.l + " != " + i);
  return n;
}
function Kp(r6, e, t) {
  r6[r6.l + 1] == 3 && r6[r6.l]++;
  var n = Vu(r6, e, t);
  return n.charCodeAt(0) == 3 ? n.slice(1) : n;
}
function Jp(r6) {
  var e = Le(2 + r6.length * 8);
  e.write_shift(2, r6.length);
  for (var t = 0; t < r6.length; ++t) Xu(r6[t], e);
  return e;
}
function Zp(r6) {
  var e = Le(24), t = Dr(r6[0]);
  e.write_shift(2, t.r), e.write_shift(2, t.r), e.write_shift(2, t.c), e.write_shift(2, t.c);
  for (var n = "d0 c9 ea 79 f9 ba ce 11 8c 82 00 aa 00 4b a9 0b".split(" "), i = 0; i < 16; ++i) e.write_shift(1, parseInt(n[i], 16));
  return jr([e, Dp(r6[1])]);
}
function Qp(r6) {
  var e = r6[1].Tooltip, t = Le(10 + 2 * (e.length + 1));
  t.write_shift(2, 2048);
  var n = Dr(r6[0]);
  t.write_shift(2, n.r), t.write_shift(2, n.r), t.write_shift(2, n.c), t.write_shift(2, n.c);
  for (var i = 0; i < e.length; ++i) t.write_shift(2, e.charCodeAt(i));
  return t.write_shift(2, 0), t;
}
function e5(r6) {
  return r6 || (r6 = Le(4)), r6.write_shift(2, 1), r6.write_shift(2, 1), r6;
}
function t5(r6, e, t) {
  if (!t.cellStyles) return wi(r6, e);
  var n = t && t.biff >= 12 ? 4 : 2, i = r6.read_shift(n), a = r6.read_shift(n), s = r6.read_shift(n), o = r6.read_shift(n), f = r6.read_shift(2);
  n == 2 && (r6.l += 2);
  var h = {
    s: i,
    e: a,
    w: s,
    ixfe: o,
    flags: f
  };
  return (t.biff >= 5 || !t.biff) && (h.level = f >> 8 & 7), h;
}
function r5(r6, e) {
  var t = Le(12);
  t.write_shift(2, e), t.write_shift(2, e), t.write_shift(2, r6.width * 256), t.write_shift(2, 0);
  var n = 0;
  return r6.hidden && (n |= 1), t.write_shift(1, n), n = r6.level || 0, t.write_shift(1, n), t.write_shift(2, 0), t;
}
function n5(r6) {
  for (var e = Le(2 * r6), t = 0; t < r6; ++t) e.write_shift(2, t + 1);
  return e;
}
function i5(r6, e, t) {
  var n = Le(15);
  return Do(n, r6, e), n.write_shift(8, t, "f"), n;
}
function a5(r6, e, t) {
  var n = Le(9);
  return Do(n, r6, e), n.write_shift(2, t), n;
}
var s5 = function() {
  var r6 = {
    /* Code Pages Supported by Visual FoxPro */
    /*::[*/
    1: 437,
    /*::[*/
    2: 850,
    /*::[*/
    3: 1252,
    /*::[*/
    4: 1e4,
    /*::[*/
    100: 852,
    /*::[*/
    101: 866,
    /*::[*/
    102: 865,
    /*::[*/
    103: 861,
    /*::[*/
    104: 895,
    /*::[*/
    105: 620,
    /*::[*/
    106: 737,
    /*::[*/
    107: 857,
    /*::[*/
    120: 950,
    /*::[*/
    121: 949,
    /*::[*/
    122: 936,
    /*::[*/
    123: 932,
    /*::[*/
    124: 874,
    /*::[*/
    125: 1255,
    /*::[*/
    126: 1256,
    /*::[*/
    150: 10007,
    /*::[*/
    151: 10029,
    /*::[*/
    152: 10006,
    /*::[*/
    200: 1250,
    /*::[*/
    201: 1251,
    /*::[*/
    202: 1254,
    /*::[*/
    203: 1253,
    /* shapefile DBF extension */
    /*::[*/
    0: 20127,
    /*::[*/
    8: 865,
    /*::[*/
    9: 437,
    /*::[*/
    10: 850,
    /*::[*/
    11: 437,
    /*::[*/
    13: 437,
    /*::[*/
    14: 850,
    /*::[*/
    15: 437,
    /*::[*/
    16: 850,
    /*::[*/
    17: 437,
    /*::[*/
    18: 850,
    /*::[*/
    19: 932,
    /*::[*/
    20: 850,
    /*::[*/
    21: 437,
    /*::[*/
    22: 850,
    /*::[*/
    23: 865,
    /*::[*/
    24: 437,
    /*::[*/
    25: 437,
    /*::[*/
    26: 850,
    /*::[*/
    27: 437,
    /*::[*/
    28: 863,
    /*::[*/
    29: 850,
    /*::[*/
    31: 852,
    /*::[*/
    34: 852,
    /*::[*/
    35: 852,
    /*::[*/
    36: 860,
    /*::[*/
    37: 850,
    /*::[*/
    38: 866,
    /*::[*/
    55: 850,
    /*::[*/
    64: 852,
    /*::[*/
    77: 936,
    /*::[*/
    78: 949,
    /*::[*/
    79: 950,
    /*::[*/
    80: 874,
    /*::[*/
    87: 1252,
    /*::[*/
    88: 1252,
    /*::[*/
    89: 1252,
    /*::[*/
    108: 863,
    /*::[*/
    134: 737,
    /*::[*/
    135: 852,
    /*::[*/
    136: 857,
    /*::[*/
    204: 1257,
    /*::[*/
    255: 16969
  }, e = Ml({
    /*::[*/
    1: 437,
    /*::[*/
    2: 850,
    /*::[*/
    3: 1252,
    /*::[*/
    4: 1e4,
    /*::[*/
    100: 852,
    /*::[*/
    101: 866,
    /*::[*/
    102: 865,
    /*::[*/
    103: 861,
    /*::[*/
    104: 895,
    /*::[*/
    105: 620,
    /*::[*/
    106: 737,
    /*::[*/
    107: 857,
    /*::[*/
    120: 950,
    /*::[*/
    121: 949,
    /*::[*/
    122: 936,
    /*::[*/
    123: 932,
    /*::[*/
    124: 874,
    /*::[*/
    125: 1255,
    /*::[*/
    126: 1256,
    /*::[*/
    150: 10007,
    /*::[*/
    151: 10029,
    /*::[*/
    152: 10006,
    /*::[*/
    200: 1250,
    /*::[*/
    201: 1251,
    /*::[*/
    202: 1254,
    /*::[*/
    203: 1253,
    /*::[*/
    0: 20127
  });
  function t(o, f) {
    var h = [], c = Pa(1);
    switch (f.type) {
      case "base64":
        c = ri(ji(o));
        break;
      case "binary":
        c = ri(o);
        break;
      case "buffer":
      case "array":
        c = o;
        break;
    }
    Tn(c, 0);
    var p = c.read_shift(1), v = !!(p & 136), d = false, w = false;
    switch (p) {
      case 2:
        break;
      case 3:
        break;
      case 48:
        d = true, v = true;
        break;
      case 49:
        d = true, v = true;
        break;
      case 131:
        break;
      case 139:
        break;
      case 140:
        w = true;
        break;
      case 245:
        break;
      default:
        throw new Error("DBF Unsupported Version: " + p.toString(16));
    }
    var x = 0, S = 521;
    p == 2 && (x = c.read_shift(2)), c.l += 3, p != 2 && (x = c.read_shift(4)), x > 1048576 && (x = 1e6), p != 2 && (S = c.read_shift(2));
    var A = c.read_shift(2), b = f.codepage || 1252;
    p != 2 && (c.l += 16, c.read_shift(1), c[c.l] !== 0 && (b = r6[c[c.l]]), c.l += 1, c.l += 2), w && (c.l += 36);
    for (var O = [], q = {}, te = Math.min(c.length, p == 2 ? 521 : S - 10 - (d ? 264 : 0)), le = w ? 32 : 11; c.l < te && c[c.l] != 13; ) switch (q = {}, q.name = Ea.utils.decode(b, c.slice(c.l, c.l + le)).replace(/[\u0000\r\n].*$/g, ""), c.l += le, q.type = String.fromCharCode(c.read_shift(1)), p != 2 && !w && (q.offset = c.read_shift(4)), q.len = c.read_shift(1), p == 2 && (q.offset = c.read_shift(2)), q.dec = c.read_shift(1), q.name.length && O.push(q), p != 2 && (c.l += w ? 13 : 14), q.type) {
      case "B":
        (!d || q.len != 8) && f.WTF && console.log("Skipping " + q.name + ":" + q.type);
        break;
      case "G":
      case "P":
        f.WTF && console.log("Skipping " + q.name + ":" + q.type);
        break;
      case "+":
      case "0":
      case "@":
      case "C":
      case "D":
      case "F":
      case "I":
      case "L":
      case "M":
      case "N":
      case "O":
      case "T":
      case "Y":
        break;
      default:
        throw new Error("Unknown Field Type: " + q.type);
    }
    if (c[c.l] !== 13 && (c.l = S - 1), c.read_shift(1) !== 13) throw new Error("DBF Terminator not found " + c.l + " " + c[c.l]);
    c.l = S;
    var j = 0, M = 0;
    for (h[0] = [], M = 0; M != O.length; ++M) h[0][M] = O[M].name;
    for (; x-- > 0; ) {
      if (c[c.l] === 42) {
        c.l += A;
        continue;
      }
      for (++c.l, h[++j] = [], M = 0, M = 0; M != O.length; ++M) {
        var H = c.slice(c.l, c.l + O[M].len);
        c.l += O[M].len, Tn(H, 0);
        var ee = Ea.utils.decode(b, H);
        switch (O[M].type) {
          case "C":
            ee.trim().length && (h[j][M] = ee.replace(/\s+$/, ""));
            break;
          case "D":
            ee.length === 8 ? h[j][M] = new Date(+ee.slice(0, 4), +ee.slice(4, 6) - 1, +ee.slice(6, 8)) : h[j][M] = ee;
            break;
          case "F":
            h[j][M] = parseFloat(ee.trim());
            break;
          case "+":
          case "I":
            h[j][M] = w ? H.read_shift(-4, "i") ^ 2147483648 : H.read_shift(4, "i");
            break;
          case "L":
            switch (ee.trim().toUpperCase()) {
              case "Y":
              case "T":
                h[j][M] = true;
                break;
              case "N":
              case "F":
                h[j][M] = false;
                break;
              case "":
              case "?":
                break;
              default:
                throw new Error("DBF Unrecognized L:|" + ee + "|");
            }
            break;
          case "M":
            if (!v) throw new Error("DBF Unexpected MEMO for type " + p.toString(16));
            h[j][M] = "##MEMO##" + (w ? parseInt(ee.trim(), 10) : H.read_shift(4));
            break;
          case "N":
            ee = ee.replace(/\u0000/g, "").trim(), ee && ee != "." && (h[j][M] = +ee || 0);
            break;
          case "@":
            h[j][M] = new Date(H.read_shift(-8, "f") - 621356832e5);
            break;
          case "T":
            h[j][M] = new Date((H.read_shift(4) - 2440588) * 864e5 + H.read_shift(4));
            break;
          case "Y":
            h[j][M] = H.read_shift(4, "i") / 1e4 + H.read_shift(4, "i") / 1e4 * Math.pow(2, 32);
            break;
          case "O":
            h[j][M] = -H.read_shift(-8, "f");
            break;
          case "B":
            if (d && O[M].len == 8) {
              h[j][M] = H.read_shift(8, "f");
              break;
            }
          case "G":
          case "P":
            H.l += O[M].len;
            break;
          case "0":
            if (O[M].name === "_NullFlags") break;
          default:
            throw new Error("DBF Unsupported data type " + O[M].type);
        }
      }
    }
    if (p != 2 && c.l < c.length && c[c.l++] != 26) throw new Error("DBF EOF Marker missing " + (c.l - 1) + " of " + c.length + " " + c[c.l - 1].toString(16));
    return f && f.sheetRows && (h = h.slice(0, f.sheetRows)), f.DBF = O, h;
  }
  function n(o, f) {
    var h = f || {};
    h.dateNF || (h.dateNF = "yyyymmdd");
    var c = Ls(t(o, h), h);
    return c["!cols"] = h.DBF.map(function(p) {
      return {
        wch: p.len,
        DBF: p
      };
    }), delete h.DBF, c;
  }
  function i(o, f) {
    try {
      return Oa(n(o, f), f);
    } catch (h) {
      if (f && f.WTF) throw h;
    }
    return {
      SheetNames: [],
      Sheets: {}
    };
  }
  var a = {
    B: 8,
    C: 250,
    L: 1,
    D: 8,
    "?": 0,
    "": 0
  };
  function s(o, f) {
    var h = f || {};
    if (+h.codepage >= 0 && _o(+h.codepage), h.type == "string") throw new Error("Cannot write DBF to JS string");
    var c = dn(), p = K0(o, {
      header: 1,
      raw: true,
      cellDates: true
    }), v = p[0], d = p.slice(1), w = o["!cols"] || [], x = 0, S = 0, A = 0, b = 1;
    for (x = 0; x < v.length; ++x) {
      if (((w[x] || {}).DBF || {}).name) {
        v[x] = w[x].DBF.name, ++A;
        continue;
      }
      if (v[x] != null) {
        if (++A, typeof v[x] == "number" && (v[x] = v[x].toString(10)), typeof v[x] != "string") throw new Error("DBF Invalid column name " + v[x] + " |" + typeof v[x] + "|");
        if (v.indexOf(v[x]) !== x) {
          for (S = 0; S < 1024; ++S) if (v.indexOf(v[x] + "_" + S) == -1) {
            v[x] += "_" + S;
            break;
          }
        }
      }
    }
    var O = rr(o["!ref"]), q = [], te = [], le = [];
    for (x = 0; x <= O.e.c - O.s.c; ++x) {
      var j = "", M = "", H = 0, ee = [];
      for (S = 0; S < d.length; ++S) d[S][x] != null && ee.push(d[S][x]);
      if (ee.length == 0 || v[x] == null) {
        q[x] = "?";
        continue;
      }
      for (S = 0; S < ee.length; ++S) {
        switch (typeof ee[S]) {
          case "number":
            M = "B";
            break;
          case "string":
            M = "C";
            break;
          case "boolean":
            M = "L";
            break;
          case "object":
            M = ee[S] instanceof Date ? "D" : "C";
            break;
          default:
            M = "C";
        }
        H = Math.max(H, String(ee[S]).length), j = j && j != M ? "C" : M;
      }
      H > 250 && (H = 250), M = ((w[x] || {}).DBF || {}).type, M == "C" && w[x].DBF.len > H && (H = w[x].DBF.len), j == "B" && M == "N" && (j = "N", le[x] = w[x].DBF.dec, H = w[x].DBF.len), te[x] = j == "C" || M == "N" ? H : a[j] || 0, b += te[x], q[x] = j;
    }
    var F = c.next(32);
    for (F.write_shift(4, 318902576), F.write_shift(4, d.length), F.write_shift(2, 296 + 32 * A), F.write_shift(2, b), x = 0; x < 4; ++x) F.write_shift(4, 0);
    for (F.write_shift(4, 0 | (+e[
      /*::String(*/
      $c
      /*::)*/
    ] || 3) << 8), x = 0, S = 0; x < v.length; ++x) if (v[x] != null) {
      var P = c.next(32), Y = (v[x].slice(-10) + "\0\0\0\0\0\0\0\0\0\0\0").slice(0, 11);
      P.write_shift(1, Y, "sbcs"), P.write_shift(1, q[x] == "?" ? "C" : q[x], "sbcs"), P.write_shift(4, S), P.write_shift(1, te[x] || a[q[x]] || 0), P.write_shift(1, le[x] || 0), P.write_shift(1, 2), P.write_shift(4, 0), P.write_shift(1, 0), P.write_shift(4, 0), P.write_shift(4, 0), S += te[x] || a[q[x]] || 0;
    }
    var Q = c.next(264);
    for (Q.write_shift(4, 13), x = 0; x < 65; ++x) Q.write_shift(4, 0);
    for (x = 0; x < d.length; ++x) {
      var ce = c.next(b);
      for (ce.write_shift(1, 0), S = 0; S < v.length; ++S) if (v[S] != null) switch (q[S]) {
        case "L":
          ce.write_shift(1, d[x][S] == null ? 63 : d[x][S] ? 84 : 70);
          break;
        case "B":
          ce.write_shift(8, d[x][S] || 0, "f");
          break;
        case "N":
          var we = "0";
          for (typeof d[x][S] == "number" && (we = d[x][S].toFixed(le[S] || 0)), A = 0; A < te[S] - we.length; ++A) ce.write_shift(1, 32);
          ce.write_shift(1, we, "sbcs");
          break;
        case "D":
          d[x][S] ? (ce.write_shift(4, ("0000" + d[x][S].getFullYear()).slice(-4), "sbcs"), ce.write_shift(2, ("00" + (d[x][S].getMonth() + 1)).slice(-2), "sbcs"), ce.write_shift(2, ("00" + d[x][S].getDate()).slice(-2), "sbcs")) : ce.write_shift(8, "00000000", "sbcs");
          break;
        case "C":
          var Se = String(d[x][S] != null ? d[x][S] : "").slice(0, te[S]);
          for (ce.write_shift(1, Se, "sbcs"), A = 0; A < te[S] - Se.length; ++A) ce.write_shift(1, 32);
          break;
      }
    }
    return c.next(1).write_shift(1, 26), c.end();
  }
  return {
    to_workbook: i,
    to_sheet: n,
    from_sheet: s
  };
}();
var o5 = function() {
  var r6 = {
    AA: "À",
    BA: "Á",
    CA: "Â",
    DA: 195,
    HA: "Ä",
    JA: 197,
    AE: "È",
    BE: "É",
    CE: "Ê",
    HE: "Ë",
    AI: "Ì",
    BI: "Í",
    CI: "Î",
    HI: "Ï",
    AO: "Ò",
    BO: "Ó",
    CO: "Ô",
    DO: 213,
    HO: "Ö",
    AU: "Ù",
    BU: "Ú",
    CU: "Û",
    HU: "Ü",
    Aa: "à",
    Ba: "á",
    Ca: "â",
    Da: 227,
    Ha: "ä",
    Ja: 229,
    Ae: "è",
    Be: "é",
    Ce: "ê",
    He: "ë",
    Ai: "ì",
    Bi: "í",
    Ci: "î",
    Hi: "ï",
    Ao: "ò",
    Bo: "ó",
    Co: "ô",
    Do: 245,
    Ho: "ö",
    Au: "ù",
    Bu: "ú",
    Cu: "û",
    Hu: "ü",
    KC: "Ç",
    Kc: "ç",
    q: "æ",
    z: "œ",
    a: "Æ",
    j: "Œ",
    DN: 209,
    Dn: 241,
    Hy: 255,
    S: 169,
    c: 170,
    R: 174,
    "B ": 180,
    /*::[*/
    0: 176,
    /*::[*/
    1: 177,
    /*::[*/
    2: 178,
    /*::[*/
    3: 179,
    /*::[*/
    5: 181,
    /*::[*/
    6: 182,
    /*::[*/
    7: 183,
    Q: 185,
    k: 186,
    b: 208,
    i: 216,
    l: 222,
    s: 240,
    y: 248,
    "!": 161,
    '"': 162,
    "#": 163,
    "(": 164,
    "%": 165,
    "'": 167,
    "H ": 168,
    "+": 171,
    ";": 187,
    "<": 188,
    "=": 189,
    ">": 190,
    "?": 191,
    "{": 223
  }, e = new RegExp("\x1BN(" + Hr(r6).join("|").replace(/\|\|\|/, "|\\||").replace(/([?()+])/g, "\\$1") + "|\\|)", "gm"), t = function(v, d) {
    var w = r6[d];
    return typeof w == "number" ? Ih(w) : w;
  }, n = function(v, d, w) {
    var x = d.charCodeAt(0) - 32 << 4 | w.charCodeAt(0) - 48;
    return x == 59 ? v : Ih(x);
  };
  r6["|"] = 254;
  function i(v, d) {
    switch (d.type) {
      case "base64":
        return a(ji(v), d);
      case "binary":
        return a(v, d);
      case "buffer":
        return a(It && Buffer.isBuffer(v) ? v.toString("binary") : Fo(v), d);
      case "array":
        return a(sf(v), d);
    }
    throw new Error("Unrecognized type " + d.type);
  }
  function a(v, d) {
    var w = v.split(/[\n\r]+/), x = -1, S = -1, A = 0, b = 0, O = [], q = [], te = null, le = {}, j = [], M = [], H = [], ee = 0, F;
    for (+d.codepage >= 0 && _o(+d.codepage); A !== w.length; ++A) {
      ee = 0;
      var P = w[A].trim().replace(/\x1B([\x20-\x2F])([\x30-\x3F])/g, n).replace(e, t), Y = P.replace(/;;/g, "\0").split(";").map(function(C) {
        return C.replace(/\u0000/g, ";");
      }), Q = Y[0], ce;
      if (P.length > 0) switch (Q) {
        case "ID":
          break;
        case "E":
          break;
        case "B":
          break;
        case "O":
          break;
        case "W":
          break;
        case "P":
          Y[1].charAt(0) == "P" && q.push(P.slice(3).replace(/;;/g, ";"));
          break;
        case "C":
          var we = false, Se = false, de = false, Ae = false, be = -1, ze = -1;
          for (b = 1; b < Y.length; ++b) switch (Y[b].charAt(0)) {
            case "A":
              break;
            case "X":
              S = parseInt(Y[b].slice(1)) - 1, Se = true;
              break;
            case "Y":
              for (x = parseInt(Y[b].slice(1)) - 1, Se || (S = 0), F = O.length; F <= x; ++F) O[F] = [];
              break;
            case "K":
              ce = Y[b].slice(1), ce.charAt(0) === '"' ? ce = ce.slice(1, ce.length - 1) : ce === "TRUE" ? ce = true : ce === "FALSE" ? ce = false : isNaN(Mi(ce)) ? isNaN(Ao(ce).getDate()) || (ce = an(ce)) : (ce = Mi(ce), te !== null && ou(te) && (ce = cu(ce))), we = true;
              break;
            case "E":
              Ae = true;
              var y = ag(Y[b].slice(1), {
                r: x,
                c: S
              });
              O[x][S] = [O[x][S], y];
              break;
            case "S":
              de = true, O[x][S] = [O[x][S], "S5S"];
              break;
            case "G":
              break;
            case "R":
              be = parseInt(Y[b].slice(1)) - 1;
              break;
            case "C":
              ze = parseInt(Y[b].slice(1)) - 1;
              break;
            default:
              if (d && d.WTF) throw new Error("SYLK bad record " + P);
          }
          if (we && (O[x][S] && O[x][S].length == 2 ? O[x][S][0] = ce : O[x][S] = ce, te = null), de) {
            if (Ae) throw new Error("SYLK shared formula cannot have own formula");
            var L = be > -1 && O[be][ze];
            if (!L || !L[1]) throw new Error("SYLK shared formula cannot find base");
            O[x][S][1] = sg(L[1], {
              r: x - be,
              c: S - ze
            });
          }
          break;
        case "F":
          var N = 0;
          for (b = 1; b < Y.length; ++b) switch (Y[b].charAt(0)) {
            case "X":
              S = parseInt(Y[b].slice(1)) - 1, ++N;
              break;
            case "Y":
              for (x = parseInt(Y[b].slice(1)) - 1, F = O.length; F <= x; ++F) O[F] = [];
              break;
            case "M":
              ee = parseInt(Y[b].slice(1)) / 20;
              break;
            case "F":
              break;
            case "G":
              break;
            case "P":
              te = q[parseInt(Y[b].slice(1))];
              break;
            case "S":
              break;
            case "D":
              break;
            case "N":
              break;
            case "W":
              for (H = Y[b].slice(1).split(" "), F = parseInt(H[0], 10); F <= parseInt(H[1], 10); ++F) ee = parseInt(H[2], 10), M[F - 1] = ee === 0 ? {
                hidden: true
              } : {
                wch: ee
              }, $l(M[F - 1]);
              break;
            case "C":
              S = parseInt(Y[b].slice(1)) - 1, M[S] || (M[S] = {});
              break;
            case "R":
              x = parseInt(Y[b].slice(1)) - 1, j[x] || (j[x] = {}), ee > 0 ? (j[x].hpt = ee, j[x].hpx = Zu(ee)) : ee === 0 && (j[x].hidden = true);
              break;
            default:
              if (d && d.WTF) throw new Error("SYLK bad record " + P);
          }
          N < 1 && (te = null);
          break;
        default:
          if (d && d.WTF) throw new Error("SYLK bad record " + P);
      }
    }
    return j.length > 0 && (le["!rows"] = j), M.length > 0 && (le["!cols"] = M), d && d.sheetRows && (O = O.slice(0, d.sheetRows)), [O, le];
  }
  function s(v, d) {
    var w = i(v, d), x = w[0], S = w[1], A = Ls(x, d);
    return Hr(S).forEach(function(b) {
      A[b] = S[b];
    }), A;
  }
  function o(v, d) {
    return Oa(s(v, d), d);
  }
  function f(v, d, w, x) {
    var S = "C;Y" + (w + 1) + ";X" + (x + 1) + ";K";
    switch (v.t) {
      case "n":
        S += v.v || 0, v.f && !v.F && (S += ";E" + Jl(v.f, {
          r: w,
          c: x
        }));
        break;
      case "b":
        S += v.v ? "TRUE" : "FALSE";
        break;
      case "e":
        S += v.w || v.v;
        break;
      case "d":
        S += '"' + (v.w || v.v) + '"';
        break;
      case "s":
        S += '"' + v.v.replace(/"/g, "").replace(/;/g, ";;") + '"';
        break;
    }
    return S;
  }
  function h(v, d) {
    d.forEach(function(w, x) {
      var S = "F;W" + (x + 1) + " " + (x + 1) + " ";
      w.hidden ? S += "0" : (typeof w.width == "number" && !w.wpx && (w.wpx = G0(w.width)), typeof w.wpx == "number" && !w.wch && (w.wch = X0(w.wpx)), typeof w.wch == "number" && (S += Math.round(w.wch))), S.charAt(S.length - 1) != " " && v.push(S);
    });
  }
  function c(v, d) {
    d.forEach(function(w, x) {
      var S = "F;";
      w.hidden ? S += "M0;" : w.hpt ? S += "M" + 20 * w.hpt + ";" : w.hpx && (S += "M" + 20 * Y0(w.hpx) + ";"), S.length > 2 && v.push(S + "R" + (x + 1));
    });
  }
  function p(v, d) {
    var w = ["ID;PWXL;N;E"], x = [], S = rr(v["!ref"]), A, b = Array.isArray(v), O = `\r
`;
    w.push("P;PGeneral"), w.push("F;P0;DG0G8;M255"), v["!cols"] && h(w, v["!cols"]), v["!rows"] && c(w, v["!rows"]), w.push("B;Y" + (S.e.r - S.s.r + 1) + ";X" + (S.e.c - S.s.c + 1) + ";D" + [S.s.c, S.s.r, S.e.c, S.e.r].join(" "));
    for (var q = S.s.r; q <= S.e.r; ++q) for (var te = S.s.c; te <= S.e.c; ++te) {
      var le = zt({
        r: q,
        c: te
      });
      A = b ? (v[q] || [])[te] : v[le], !(!A || A.v == null && (!A.f || A.F)) && x.push(f(A, v, q, te));
    }
    return w.join(O) + O + x.join(O) + O + "E" + O;
  }
  return {
    to_workbook: o,
    to_sheet: s,
    from_sheet: p
  };
}();
var f5 = /* @__PURE__ */ function() {
  function r6(a, s) {
    switch (s.type) {
      case "base64":
        return e(ji(a), s);
      case "binary":
        return e(a, s);
      case "buffer":
        return e(It && Buffer.isBuffer(a) ? a.toString("binary") : Fo(a), s);
      case "array":
        return e(sf(a), s);
    }
    throw new Error("Unrecognized type " + s.type);
  }
  function e(a, s) {
    for (var o = a.split(`
`), f = -1, h = -1, c = 0, p = []; c !== o.length; ++c) {
      if (o[c].trim() === "BOT") {
        p[++f] = [], h = 0;
        continue;
      }
      if (!(f < 0)) {
        var v = o[c].trim().split(","), d = v[0], w = v[1];
        ++c;
        for (var x = o[c] || ""; (x.match(/["]/g) || []).length & 1 && c < o.length - 1; ) x += `
` + o[++c];
        switch (x = x.trim(), +d) {
          case -1:
            if (x === "BOT") {
              p[++f] = [], h = 0;
              continue;
            } else if (x !== "EOD") throw new Error("Unrecognized DIF special command " + x);
            break;
          case 0:
            x === "TRUE" ? p[f][h] = true : x === "FALSE" ? p[f][h] = false : isNaN(Mi(w)) ? isNaN(Ao(w).getDate()) ? p[f][h] = w : p[f][h] = an(w) : p[f][h] = Mi(w), ++h;
            break;
          case 1:
            x = x.slice(1, x.length - 1), x = x.replace(/""/g, '"'), x && x.match(/^=".*"$/) && (x = x.slice(2, -1)), p[f][h++] = x !== "" ? x : null;
            break;
        }
        if (x === "EOD") break;
      }
    }
    return s && s.sheetRows && (p = p.slice(0, s.sheetRows)), p;
  }
  function t(a, s) {
    return Ls(r6(a, s), s);
  }
  function n(a, s) {
    return Oa(t(a, s), s);
  }
  var i = /* @__PURE__ */ function() {
    var a = function(f, h, c, p, v) {
      f.push(h), f.push(c + "," + p), f.push('"' + v.replace(/"/g, '""') + '"');
    }, s = function(f, h, c, p) {
      f.push(h + "," + c), f.push(h == 1 ? '"' + p.replace(/"/g, '""') + '"' : p);
    };
    return function(f) {
      var h = [], c = rr(f["!ref"]), p, v = Array.isArray(f);
      a(h, "TABLE", 0, 1, "sheetjs"), a(h, "VECTORS", 0, c.e.r - c.s.r + 1, ""), a(h, "TUPLES", 0, c.e.c - c.s.c + 1, ""), a(h, "DATA", 0, 0, "");
      for (var d = c.s.r; d <= c.e.r; ++d) {
        s(h, -1, 0, "BOT");
        for (var w = c.s.c; w <= c.e.c; ++w) {
          var x = zt({
            r: d,
            c: w
          });
          if (p = v ? (f[d] || [])[w] : f[x], !p) {
            s(h, 1, 0, "");
            continue;
          }
          switch (p.t) {
            case "n":
              var S = p.w;
              !S && p.v != null && (S = p.v), S == null ? p.f && !p.F ? s(h, 1, 0, "=" + p.f) : s(h, 1, 0, "") : s(h, 0, S, "V");
              break;
            case "b":
              s(h, 0, p.v ? 1 : 0, p.v ? "TRUE" : "FALSE");
              break;
            case "s":
              s(h, 1, 0, isNaN(p.v) ? p.v : '="' + p.v + '"');
              break;
            case "d":
              p.w || (p.w = la(p.z || lr[14], pn(an(p.v)))), s(h, 0, p.w, "V");
              break;
            default:
              s(h, 1, 0, "");
          }
        }
      }
      s(h, -1, 0, "EOD");
      var A = `\r
`, b = h.join(A);
      return b;
    };
  }();
  return {
    to_workbook: n,
    to_sheet: t,
    from_sheet: i
  };
}();
var Yu = function() {
  function r6(p) {
    return p.replace(/\\b/g, "\\").replace(/\\c/g, ":").replace(/\\n/g, `
`);
  }
  function e(p) {
    return p.replace(/\\/g, "\\b").replace(/:/g, "\\c").replace(/\n/g, "\\n");
  }
  function t(p, v) {
    for (var d = p.split(`
`), w = -1, x = -1, S = 0, A = []; S !== d.length; ++S) {
      var b = d[S].trim().split(":");
      if (b[0] === "cell") {
        var O = Dr(b[1]);
        if (A.length <= O.r) for (w = A.length; w <= O.r; ++w) A[w] || (A[w] = []);
        switch (w = O.r, x = O.c, b[2]) {
          case "t":
            A[w][x] = r6(b[3]);
            break;
          case "v":
            A[w][x] = +b[3];
            break;
          case "vtf":
            var q = b[b.length - 1];
          case "vtc":
            switch (b[3]) {
              case "nl":
                A[w][x] = !!+b[4];
                break;
              default:
                A[w][x] = +b[4];
                break;
            }
            b[2] == "vtf" && (A[w][x] = [A[w][x], q]);
        }
      }
    }
    return v && v.sheetRows && (A = A.slice(0, v.sheetRows)), A;
  }
  function n(p, v) {
    return Ls(t(p, v), v);
  }
  function i(p, v) {
    return Oa(n(p, v), v);
  }
  var a = ["socialcalc:version:1.5", "MIME-Version: 1.0", "Content-Type: multipart/mixed; boundary=SocialCalcSpreadsheetControlSave"].join(`
`), s = ["--SocialCalcSpreadsheetControlSave", "Content-type: text/plain; charset=UTF-8"].join(`
`) + `
`, o = ["# SocialCalc Spreadsheet Control Save", "part:sheet"].join(`
`), f = "--SocialCalcSpreadsheetControlSave--";
  function h(p) {
    if (!p || !p["!ref"]) return "";
    for (var v = [], d = [], w, x = "", S = Ln(p["!ref"]), A = Array.isArray(p), b = S.s.r; b <= S.e.r; ++b) for (var O = S.s.c; O <= S.e.c; ++O) if (x = zt({
      r: b,
      c: O
    }), w = A ? (p[b] || [])[O] : p[x], !(!w || w.v == null || w.t === "z")) {
      switch (d = ["cell", x, "t"], w.t) {
        case "s":
        case "str":
          d.push(e(w.v));
          break;
        case "n":
          w.f ? (d[2] = "vtf", d[3] = "n", d[4] = w.v, d[5] = e(w.f)) : (d[2] = "v", d[3] = w.v);
          break;
        case "b":
          d[2] = "vt" + (w.f ? "f" : "c"), d[3] = "nl", d[4] = w.v ? "1" : "0", d[5] = e(w.f || (w.v ? "TRUE" : "FALSE"));
          break;
        case "d":
          var q = pn(an(w.v));
          d[2] = "vtc", d[3] = "nd", d[4] = "" + q, d[5] = w.w || la(w.z || lr[14], q);
          break;
        case "e":
          continue;
      }
      v.push(d.join(":"));
    }
    return v.push("sheet:c:" + (S.e.c - S.s.c + 1) + ":r:" + (S.e.r - S.s.r + 1) + ":tvf:1"), v.push("valueformat:1:text-wiki"), v.join(`
`);
  }
  function c(p) {
    return [a, s, o, s, h(p), f].join(`
`);
  }
  return {
    to_workbook: i,
    to_sheet: n,
    from_sheet: c
  };
}();
var l5 = /* @__PURE__ */ function() {
  function r6(c, p, v, d, w) {
    w.raw ? p[v][d] = c : c === "" || (c === "TRUE" ? p[v][d] = true : c === "FALSE" ? p[v][d] = false : isNaN(Mi(c)) ? isNaN(Ao(c).getDate()) ? p[v][d] = c : p[v][d] = an(c) : p[v][d] = Mi(c));
  }
  function e(c, p) {
    var v = p || {}, d = [];
    if (!c || c.length === 0) return d;
    for (var w = c.split(/[\r\n]/), x = w.length - 1; x >= 0 && w[x].length === 0; ) --x;
    for (var S = 10, A = 0, b = 0; b <= x; ++b) A = w[b].indexOf(" "), A == -1 ? A = w[b].length : A++, S = Math.max(S, A);
    for (b = 0; b <= x; ++b) {
      d[b] = [];
      var O = 0;
      for (r6(w[b].slice(0, S).trim(), d, b, O, v), O = 1; O <= (w[b].length - S) / 10 + 1; ++O) r6(w[b].slice(S + (O - 1) * 10, S + O * 10).trim(), d, b, O, v);
    }
    return v.sheetRows && (d = d.slice(0, v.sheetRows)), d;
  }
  var t = {
    /*::[*/
    44: ",",
    /*::[*/
    9: "	",
    /*::[*/
    59: ";",
    /*::[*/
    124: "|"
  }, n = {
    /*::[*/
    44: 3,
    /*::[*/
    9: 2,
    /*::[*/
    59: 1,
    /*::[*/
    124: 0
  };
  function i(c) {
    for (var p = {}, v = false, d = 0, w = 0; d < c.length; ++d) (w = c.charCodeAt(d)) == 34 ? v = !v : !v && w in t && (p[w] = (p[w] || 0) + 1);
    w = [];
    for (d in p) Object.prototype.hasOwnProperty.call(p, d) && w.push([p[d], d]);
    if (!w.length) {
      p = n;
      for (d in p) Object.prototype.hasOwnProperty.call(p, d) && w.push([p[d], d]);
    }
    return w.sort(function(x, S) {
      return x[0] - S[0] || n[x[1]] - n[S[1]];
    }), t[w.pop()[1]] || 44;
  }
  function a(c, p) {
    var v = p || {}, d = "", w = v.dense ? [] : {}, x = {
      s: {
        c: 0,
        r: 0
      },
      e: {
        c: 0,
        r: 0
      }
    };
    c.slice(0, 4) == "sep=" ? c.charCodeAt(5) == 13 && c.charCodeAt(6) == 10 ? (d = c.charAt(4), c = c.slice(7)) : c.charCodeAt(5) == 13 || c.charCodeAt(5) == 10 ? (d = c.charAt(4), c = c.slice(6)) : d = i(c.slice(0, 1024)) : v && v.FS ? d = v.FS : d = i(c.slice(0, 1024));
    var S = 0, A = 0, b = 0, O = 0, q = 0, te = d.charCodeAt(0), le = false, j = 0, M = c.charCodeAt(0);
    c = c.replace(/\r\n/mg, `
`);
    var H = v.dateNF != null ? Td(v.dateNF) : null;
    function ee() {
      var F = c.slice(O, q), P = {};
      if (F.charAt(0) == '"' && F.charAt(F.length - 1) == '"' && (F = F.slice(1, -1).replace(/""/g, '"')), F.length === 0) P.t = "z";
      else if (v.raw) P.t = "s", P.v = F;
      else if (F.trim().length === 0) P.t = "s", P.v = F;
      else if (F.charCodeAt(0) == 61) F.charCodeAt(1) == 34 && F.charCodeAt(F.length - 1) == 34 ? (P.t = "s", P.v = F.slice(2, -1).replace(/""/g, '"')) : og(F) ? (P.t = "n", P.f = F.slice(1)) : (P.t = "s", P.v = F);
      else if (F == "TRUE") P.t = "b", P.v = true;
      else if (F == "FALSE") P.t = "b", P.v = false;
      else if (!isNaN(b = Mi(F))) P.t = "n", v.cellText !== false && (P.w = F), P.v = b;
      else if (!isNaN(Ao(F).getDate()) || H && F.match(H)) {
        P.z = v.dateNF || lr[14];
        var Y = 0;
        H && F.match(H) && (F = Ed(F, v.dateNF, F.match(H) || []), Y = 1), v.cellDates ? (P.t = "d", P.v = an(F, Y)) : (P.t = "n", P.v = pn(an(F, Y))), v.cellText !== false && (P.w = la(P.z, P.v instanceof Date ? pn(P.v) : P.v)), v.cellNF || delete P.z;
      } else P.t = "s", P.v = F;
      if (P.t == "z" || (v.dense ? (w[S] || (w[S] = []), w[S][A] = P) : w[zt({
        c: A,
        r: S
      })] = P), O = q + 1, M = c.charCodeAt(O), x.e.c < A && (x.e.c = A), x.e.r < S && (x.e.r = S), j == te) ++A;
      else if (A = 0, ++S, v.sheetRows && v.sheetRows <= S) return true;
    }
    e: for (; q < c.length; ++q) switch (j = c.charCodeAt(q)) {
      case 34:
        M === 34 && (le = !le);
        break;
      case te:
      case 10:
      case 13:
        if (!le && ee()) break e;
        break;
    }
    return q - O > 0 && ee(), w["!ref"] = Sr(x), w;
  }
  function s(c, p) {
    return !(p && p.PRN) || p.FS || c.slice(0, 4) == "sep=" || c.indexOf("	") >= 0 || c.indexOf(",") >= 0 || c.indexOf(";") >= 0 ? a(c, p) : Ls(e(c, p), p);
  }
  function o(c, p) {
    var v = "", d = p.type == "string" ? [0, 0, 0, 0] : _4(c, p);
    switch (p.type) {
      case "base64":
        v = ji(c);
        break;
      case "binary":
        v = c;
        break;
      case "buffer":
        p.codepage == 65001 ? v = c.toString("utf8") : p.codepage && typeof Ea < "u" ? v = Ea.utils.decode(p.codepage, c) : v = It && Buffer.isBuffer(c) ? c.toString("binary") : Fo(c);
        break;
      case "array":
        v = sf(c);
        break;
      case "string":
        v = c;
        break;
      default:
        throw new Error("Unrecognized type " + p.type);
    }
    return d[0] == 239 && d[1] == 187 && d[2] == 191 ? v = po(v.slice(3)) : p.type != "string" && p.type != "buffer" && p.codepage == 65001 ? v = po(v) : p.type == "binary" && typeof Ea < "u" && p.codepage && (v = Ea.utils.decode(p.codepage, Ea.utils.encode(28591, v))), v.slice(0, 19) == "socialcalc:version:" ? Yu.to_sheet(p.type == "string" ? v : po(v), p) : s(v, p);
  }
  function f(c, p) {
    return Oa(o(c, p), p);
  }
  function h(c) {
    for (var p = [], v = rr(c["!ref"]), d, w = Array.isArray(c), x = v.s.r; x <= v.e.r; ++x) {
      for (var S = [], A = v.s.c; A <= v.e.c; ++A) {
        var b = zt({
          r: x,
          c: A
        });
        if (d = w ? (c[x] || [])[A] : c[b], !d || d.v == null) {
          S.push("          ");
          continue;
        }
        for (var O = (d.w || (Ui(d), d.w) || "").slice(0, 10); O.length < 10; ) O += " ";
        S.push(O + (A === 0 ? " " : ""));
      }
      p.push(S.join(""));
    }
    return p.join(`
`);
  }
  return {
    to_workbook: f,
    to_sheet: o,
    from_sheet: h
  };
}();
var uc = /* @__PURE__ */ function() {
  function r6(y, L, N) {
    if (y) {
      Tn(y, y.l || 0);
      for (var C = N.Enum || be; y.l < y.length; ) {
        var z = y.read_shift(2), re = C[z] || C[65535], se = y.read_shift(2), ie = y.l + se, ve = re.f && re.f(y, se, N);
        if (y.l = ie, L(ve, re, z)) return;
      }
    }
  }
  function e(y, L) {
    switch (L.type) {
      case "base64":
        return t(ri(ji(y)), L);
      case "binary":
        return t(ri(y), L);
      case "buffer":
      case "array":
        return t(y, L);
    }
    throw "Unsupported type " + L.type;
  }
  function t(y, L) {
    if (!y) return y;
    var N = L || {}, C = N.dense ? [] : {}, z = "Sheet1", re = "", se = 0, ie = {}, ve = [], Ce = [], Oe = {
      s: {
        r: 0,
        c: 0
      },
      e: {
        r: 0,
        c: 0
      }
    }, qe = N.sheetRows || 0;
    if (y[2] == 0 && (y[3] == 8 || y[3] == 9) && y.length >= 16 && y[14] == 5 && y[15] === 108) throw new Error("Unsupported Works 3 for Mac file");
    if (y[2] == 2) N.Enum = be, r6(y, function(Ie, rt, Be) {
      switch (Be) {
        case 0:
          N.vers = Ie, Ie >= 4096 && (N.qpro = true);
          break;
        case 6:
          Oe = Ie;
          break;
        case 204:
          Ie && (re = Ie);
          break;
        case 222:
          re = Ie;
          break;
        case 15:
        case 51:
          N.qpro || (Ie[1].v = Ie[1].v.slice(1));
        case 13:
        case 14:
        case 16:
          Be == 14 && (Ie[2] & 112) == 112 && (Ie[2] & 15) > 1 && (Ie[2] & 15) < 15 && (Ie[1].z = N.dateNF || lr[14], N.cellDates && (Ie[1].t = "d", Ie[1].v = cu(Ie[1].v))), N.qpro && Ie[3] > se && (C["!ref"] = Sr(Oe), ie[z] = C, ve.push(z), C = N.dense ? [] : {}, Oe = {
            s: {
              r: 0,
              c: 0
            },
            e: {
              r: 0,
              c: 0
            }
          }, se = Ie[3], z = re || "Sheet" + (se + 1), re = "");
          var We = N.dense ? (C[Ie[0].r] || [])[Ie[0].c] : C[zt(Ie[0])];
          if (We) {
            We.t = Ie[1].t, We.v = Ie[1].v, Ie[1].z != null && (We.z = Ie[1].z), Ie[1].f != null && (We.f = Ie[1].f);
            break;
          }
          N.dense ? (C[Ie[0].r] || (C[Ie[0].r] = []), C[Ie[0].r][Ie[0].c] = Ie[1]) : C[zt(Ie[0])] = Ie[1];
          break;
      }
    }, N);
    else if (y[2] == 26 || y[2] == 14) N.Enum = ze, y[2] == 14 && (N.qpro = true, y.l = 0), r6(y, function(Ie, rt, Be) {
      switch (Be) {
        case 204:
          z = Ie;
          break;
        case 22:
          Ie[1].v = Ie[1].v.slice(1);
        case 23:
        case 24:
        case 25:
        case 37:
        case 39:
        case 40:
          if (Ie[3] > se && (C["!ref"] = Sr(Oe), ie[z] = C, ve.push(z), C = N.dense ? [] : {}, Oe = {
            s: {
              r: 0,
              c: 0
            },
            e: {
              r: 0,
              c: 0
            }
          }, se = Ie[3], z = "Sheet" + (se + 1)), qe > 0 && Ie[0].r >= qe) break;
          N.dense ? (C[Ie[0].r] || (C[Ie[0].r] = []), C[Ie[0].r][Ie[0].c] = Ie[1]) : C[zt(Ie[0])] = Ie[1], Oe.e.c < Ie[0].c && (Oe.e.c = Ie[0].c), Oe.e.r < Ie[0].r && (Oe.e.r = Ie[0].r);
          break;
        case 27:
          Ie[14e3] && (Ce[Ie[14e3][0]] = Ie[14e3][1]);
          break;
        case 1537:
          Ce[Ie[0]] = Ie[1], Ie[0] == se && (z = Ie[1]);
          break;
      }
    }, N);
    else throw new Error("Unrecognized LOTUS BOF " + y[2]);
    if (C["!ref"] = Sr(Oe), ie[re || z] = C, ve.push(re || z), !Ce.length) return {
      SheetNames: ve,
      Sheets: ie
    };
    for (var Ye = {}, Te = [], Z = 0; Z < Ce.length; ++Z) ie[ve[Z]] ? (Te.push(Ce[Z] || ve[Z]), Ye[Ce[Z]] = ie[Ce[Z]] || ie[ve[Z]]) : (Te.push(Ce[Z]), Ye[Ce[Z]] = {
      "!ref": "A1"
    });
    return {
      SheetNames: Te,
      Sheets: Ye
    };
  }
  function n(y, L) {
    var N = L || {};
    if (+N.codepage >= 0 && _o(+N.codepage), N.type == "string") throw new Error("Cannot write WK1 to JS string");
    var C = dn(), z = rr(y["!ref"]), re = Array.isArray(y), se = [];
    Xe(C, 0, a(1030)), Xe(C, 6, f(z));
    for (var ie = Math.min(z.e.r, 8191), ve = z.s.r; ve <= ie; ++ve) for (var Ce = qr(ve), Oe = z.s.c; Oe <= z.e.c; ++Oe) {
      ve === z.s.r && (se[Oe] = Jr(Oe));
      var qe = se[Oe] + Ce, Ye = re ? (y[ve] || [])[Oe] : y[qe];
      if (!(!Ye || Ye.t == "z")) if (Ye.t == "n") (Ye.v | 0) == Ye.v && Ye.v >= -32768 && Ye.v <= 32767 ? Xe(C, 13, d(ve, Oe, Ye.v)) : Xe(C, 14, x(ve, Oe, Ye.v));
      else {
        var Te = Ui(Ye);
        Xe(C, 15, p(ve, Oe, Te.slice(0, 239)));
      }
    }
    return Xe(C, 1), C.end();
  }
  function i(y, L) {
    var N = L || {};
    if (+N.codepage >= 0 && _o(+N.codepage), N.type == "string") throw new Error("Cannot write WK3 to JS string");
    var C = dn();
    Xe(C, 0, s(y));
    for (var z = 0, re = 0; z < y.SheetNames.length; ++z) (y.Sheets[y.SheetNames[z]] || {})["!ref"] && Xe(C, 27, Ae(y.SheetNames[z], re++));
    var se = 0;
    for (z = 0; z < y.SheetNames.length; ++z) {
      var ie = y.Sheets[y.SheetNames[z]];
      if (!(!ie || !ie["!ref"])) {
        for (var ve = rr(ie["!ref"]), Ce = Array.isArray(ie), Oe = [], qe = Math.min(ve.e.r, 8191), Ye = ve.s.r; Ye <= qe; ++Ye) for (var Te = qr(Ye), Z = ve.s.c; Z <= ve.e.c; ++Z) {
          Ye === ve.s.r && (Oe[Z] = Jr(Z));
          var Ie = Oe[Z] + Te, rt = Ce ? (ie[Ye] || [])[Z] : ie[Ie];
          if (!(!rt || rt.t == "z")) if (rt.t == "n") Xe(C, 23, ee(Ye, Z, se, rt.v));
          else {
            var Be = Ui(rt);
            Xe(C, 22, j(Ye, Z, se, Be.slice(0, 239)));
          }
        }
        ++se;
      }
    }
    return Xe(C, 1), C.end();
  }
  function a(y) {
    var L = Le(2);
    return L.write_shift(2, y), L;
  }
  function s(y) {
    var L = Le(26);
    L.write_shift(2, 4096), L.write_shift(2, 4), L.write_shift(4, 0);
    for (var N = 0, C = 0, z = 0, re = 0; re < y.SheetNames.length; ++re) {
      var se = y.SheetNames[re], ie = y.Sheets[se];
      if (!(!ie || !ie["!ref"])) {
        ++z;
        var ve = Ln(ie["!ref"]);
        N < ve.e.r && (N = ve.e.r), C < ve.e.c && (C = ve.e.c);
      }
    }
    return N > 8191 && (N = 8191), L.write_shift(2, N), L.write_shift(1, z), L.write_shift(1, C), L.write_shift(2, 0), L.write_shift(2, 0), L.write_shift(1, 1), L.write_shift(1, 2), L.write_shift(4, 0), L.write_shift(4, 0), L;
  }
  function o(y, L, N) {
    var C = {
      s: {
        c: 0,
        r: 0
      },
      e: {
        c: 0,
        r: 0
      }
    };
    return L == 8 && N.qpro ? (C.s.c = y.read_shift(1), y.l++, C.s.r = y.read_shift(2), C.e.c = y.read_shift(1), y.l++, C.e.r = y.read_shift(2), C) : (C.s.c = y.read_shift(2), C.s.r = y.read_shift(2), L == 12 && N.qpro && (y.l += 2), C.e.c = y.read_shift(2), C.e.r = y.read_shift(2), L == 12 && N.qpro && (y.l += 2), C.s.c == 65535 && (C.s.c = C.e.c = C.s.r = C.e.r = 0), C);
  }
  function f(y) {
    var L = Le(8);
    return L.write_shift(2, y.s.c), L.write_shift(2, y.s.r), L.write_shift(2, y.e.c), L.write_shift(2, y.e.r), L;
  }
  function h(y, L, N) {
    var C = [{
      c: 0,
      r: 0
    }, {
      t: "n",
      v: 0
    }, 0, 0];
    return N.qpro && N.vers != 20768 ? (C[0].c = y.read_shift(1), C[3] = y.read_shift(1), C[0].r = y.read_shift(2), y.l += 2) : (C[2] = y.read_shift(1), C[0].c = y.read_shift(2), C[0].r = y.read_shift(2)), C;
  }
  function c(y, L, N) {
    var C = y.l + L, z = h(y, L, N);
    if (z[1].t = "s", N.vers == 20768) {
      y.l++;
      var re = y.read_shift(1);
      return z[1].v = y.read_shift(re, "utf8"), z;
    }
    return N.qpro && y.l++, z[1].v = y.read_shift(C - y.l, "cstr"), z;
  }
  function p(y, L, N) {
    var C = Le(7 + N.length);
    C.write_shift(1, 255), C.write_shift(2, L), C.write_shift(2, y), C.write_shift(1, 39);
    for (var z = 0; z < C.length; ++z) {
      var re = N.charCodeAt(z);
      C.write_shift(1, re >= 128 ? 95 : re);
    }
    return C.write_shift(1, 0), C;
  }
  function v(y, L, N) {
    var C = h(y, L, N);
    return C[1].v = y.read_shift(2, "i"), C;
  }
  function d(y, L, N) {
    var C = Le(7);
    return C.write_shift(1, 255), C.write_shift(2, L), C.write_shift(2, y), C.write_shift(2, N, "i"), C;
  }
  function w(y, L, N) {
    var C = h(y, L, N);
    return C[1].v = y.read_shift(8, "f"), C;
  }
  function x(y, L, N) {
    var C = Le(13);
    return C.write_shift(1, 255), C.write_shift(2, L), C.write_shift(2, y), C.write_shift(8, N, "f"), C;
  }
  function S(y, L, N) {
    var C = y.l + L, z = h(y, L, N);
    if (z[1].v = y.read_shift(8, "f"), N.qpro) y.l = C;
    else {
      var re = y.read_shift(2);
      q(y.slice(y.l, y.l + re), z), y.l += re;
    }
    return z;
  }
  function A(y, L, N) {
    var C = L & 32768;
    return L &= -32769, L = (C ? y : 0) + (L >= 8192 ? L - 16384 : L), (C ? "" : "$") + (N ? Jr(L) : qr(L));
  }
  var b = {
    51: ["FALSE", 0],
    52: ["TRUE", 0],
    70: ["LEN", 1],
    80: ["SUM", 69],
    81: ["AVERAGEA", 69],
    82: ["COUNTA", 69],
    83: ["MINA", 69],
    84: ["MAXA", 69],
    111: ["T", 1]
  }, O = [
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    // eslint-disable-line no-mixed-spaces-and-tabs
    "",
    "+",
    "-",
    "*",
    "/",
    "^",
    "=",
    "<>",
    // eslint-disable-line no-mixed-spaces-and-tabs
    "<=",
    ">=",
    "<",
    ">",
    "",
    "",
    "",
    "",
    // eslint-disable-line no-mixed-spaces-and-tabs
    "&",
    "",
    "",
    "",
    "",
    "",
    "",
    ""
    // eslint-disable-line no-mixed-spaces-and-tabs
  ];
  function q(y, L) {
    Tn(y, 0);
    for (var N = [], C = 0, z = "", re = "", se = "", ie = ""; y.l < y.length; ) {
      var ve = y[y.l++];
      switch (ve) {
        case 0:
          N.push(y.read_shift(8, "f"));
          break;
        case 1:
          re = A(L[0].c, y.read_shift(2), true), z = A(L[0].r, y.read_shift(2), false), N.push(re + z);
          break;
        case 2:
          {
            var Ce = A(L[0].c, y.read_shift(2), true), Oe = A(L[0].r, y.read_shift(2), false);
            re = A(L[0].c, y.read_shift(2), true), z = A(L[0].r, y.read_shift(2), false), N.push(Ce + Oe + ":" + re + z);
          }
          break;
        case 3:
          if (y.l < y.length) {
            console.error("WK1 premature formula end");
            return;
          }
          break;
        case 4:
          N.push("(" + N.pop() + ")");
          break;
        case 5:
          N.push(y.read_shift(2));
          break;
        case 6:
          {
            for (var qe = ""; ve = y[y.l++]; ) qe += String.fromCharCode(ve);
            N.push('"' + qe.replace(/"/g, '""') + '"');
          }
          break;
        case 8:
          N.push("-" + N.pop());
          break;
        case 23:
          N.push("+" + N.pop());
          break;
        case 22:
          N.push("NOT(" + N.pop() + ")");
          break;
        case 20:
        case 21:
          ie = N.pop(), se = N.pop(), N.push(["AND", "OR"][ve - 20] + "(" + se + "," + ie + ")");
          break;
        default:
          if (ve < 32 && O[ve]) ie = N.pop(), se = N.pop(), N.push(se + O[ve] + ie);
          else if (b[ve]) {
            if (C = b[ve][1], C == 69 && (C = y[y.l++]), C > N.length) {
              console.error("WK1 bad formula parse 0x" + ve.toString(16) + ":|" + N.join("|") + "|");
              return;
            }
            var Ye = N.slice(-C);
            N.length -= C, N.push(b[ve][0] + "(" + Ye.join(",") + ")");
          } else return ve <= 7 ? console.error("WK1 invalid opcode " + ve.toString(16)) : ve <= 24 ? console.error("WK1 unsupported op " + ve.toString(16)) : ve <= 30 ? console.error("WK1 invalid opcode " + ve.toString(16)) : ve <= 115 ? console.error("WK1 unsupported function opcode " + ve.toString(16)) : console.error("WK1 unrecognized opcode " + ve.toString(16));
      }
    }
    N.length == 1 ? L[1].f = "" + N[0] : console.error("WK1 bad formula parse |" + N.join("|") + "|");
  }
  function te(y) {
    var L = [{
      c: 0,
      r: 0
    }, {
      t: "n",
      v: 0
    }, 0];
    return L[0].r = y.read_shift(2), L[3] = y[y.l++], L[0].c = y[y.l++], L;
  }
  function le(y, L) {
    var N = te(y);
    return N[1].t = "s", N[1].v = y.read_shift(L - 4, "cstr"), N;
  }
  function j(y, L, N, C) {
    var z = Le(6 + C.length);
    z.write_shift(2, y), z.write_shift(1, N), z.write_shift(1, L), z.write_shift(1, 39);
    for (var re = 0; re < C.length; ++re) {
      var se = C.charCodeAt(re);
      z.write_shift(1, se >= 128 ? 95 : se);
    }
    return z.write_shift(1, 0), z;
  }
  function M(y, L) {
    var N = te(y);
    N[1].v = y.read_shift(2);
    var C = N[1].v >> 1;
    if (N[1].v & 1) switch (C & 7) {
      case 0:
        C = (C >> 3) * 5e3;
        break;
      case 1:
        C = (C >> 3) * 500;
        break;
      case 2:
        C = (C >> 3) / 20;
        break;
      case 3:
        C = (C >> 3) / 200;
        break;
      case 4:
        C = (C >> 3) / 2e3;
        break;
      case 5:
        C = (C >> 3) / 2e4;
        break;
      case 6:
        C = (C >> 3) / 16;
        break;
      case 7:
        C = (C >> 3) / 64;
        break;
    }
    return N[1].v = C, N;
  }
  function H(y, L) {
    var N = te(y), C = y.read_shift(4), z = y.read_shift(4), re = y.read_shift(2);
    if (re == 65535) return C === 0 && z === 3221225472 ? (N[1].t = "e", N[1].v = 15) : C === 0 && z === 3489660928 ? (N[1].t = "e", N[1].v = 42) : N[1].v = 0, N;
    var se = re & 32768;
    return re = (re & 32767) - 16446, N[1].v = (1 - se * 2) * (z * Math.pow(2, re + 32) + C * Math.pow(2, re)), N;
  }
  function ee(y, L, N, C) {
    var z = Le(14);
    if (z.write_shift(2, y), z.write_shift(1, N), z.write_shift(1, L), C == 0) return z.write_shift(4, 0), z.write_shift(4, 0), z.write_shift(2, 65535), z;
    var re = 0, se = 0, ie = 0, ve = 0;
    return C < 0 && (re = 1, C = -C), se = Math.log2(C) | 0, C /= Math.pow(2, se - 31), ve = C >>> 0, ve & 2147483648 || (C /= 2, ++se, ve = C >>> 0), C -= ve, ve |= 2147483648, ve >>>= 0, C *= Math.pow(2, 32), ie = C >>> 0, z.write_shift(4, ie), z.write_shift(4, ve), se += 16383 + (re ? 32768 : 0), z.write_shift(2, se), z;
  }
  function F(y, L) {
    var N = H(y);
    return y.l += L - 14, N;
  }
  function P(y, L) {
    var N = te(y), C = y.read_shift(4);
    return N[1].v = C >> 6, N;
  }
  function Y(y, L) {
    var N = te(y), C = y.read_shift(8, "f");
    return N[1].v = C, N;
  }
  function Q(y, L) {
    var N = Y(y);
    return y.l += L - 10, N;
  }
  function ce(y, L) {
    return y[y.l + L - 1] == 0 ? y.read_shift(L, "cstr") : "";
  }
  function we(y, L) {
    var N = y[y.l++];
    N > L - 1 && (N = L - 1);
    for (var C = ""; C.length < N; ) C += String.fromCharCode(y[y.l++]);
    return C;
  }
  function Se(y, L, N) {
    if (!(!N.qpro || L < 21)) {
      var C = y.read_shift(1);
      y.l += 17, y.l += 1, y.l += 2;
      var z = y.read_shift(L - 21, "cstr");
      return [C, z];
    }
  }
  function de(y, L) {
    for (var N = {}, C = y.l + L; y.l < C; ) {
      var z = y.read_shift(2);
      if (z == 14e3) {
        for (N[z] = [0, ""], N[z][0] = y.read_shift(2); y[y.l]; ) N[z][1] += String.fromCharCode(y[y.l]), y.l++;
        y.l++;
      }
    }
    return N;
  }
  function Ae(y, L) {
    var N = Le(5 + y.length);
    N.write_shift(2, 14e3), N.write_shift(2, L);
    for (var C = 0; C < y.length; ++C) {
      var z = y.charCodeAt(C);
      N[N.l++] = z > 127 ? 95 : z;
    }
    return N[N.l++] = 0, N;
  }
  var be = {
    /*::[*/
    0: {
      n: "BOF",
      f: Wu
    },
    /*::[*/
    1: {
      n: "EOF"
    },
    /*::[*/
    2: {
      n: "CALCMODE"
    },
    /*::[*/
    3: {
      n: "CALCORDER"
    },
    /*::[*/
    4: {
      n: "SPLIT"
    },
    /*::[*/
    5: {
      n: "SYNC"
    },
    /*::[*/
    6: {
      n: "RANGE",
      f: o
    },
    /*::[*/
    7: {
      n: "WINDOW1"
    },
    /*::[*/
    8: {
      n: "COLW1"
    },
    /*::[*/
    9: {
      n: "WINTWO"
    },
    /*::[*/
    10: {
      n: "COLW2"
    },
    /*::[*/
    11: {
      n: "NAME"
    },
    /*::[*/
    12: {
      n: "BLANK"
    },
    /*::[*/
    13: {
      n: "INTEGER",
      f: v
    },
    /*::[*/
    14: {
      n: "NUMBER",
      f: w
    },
    /*::[*/
    15: {
      n: "LABEL",
      f: c
    },
    /*::[*/
    16: {
      n: "FORMULA",
      f: S
    },
    /*::[*/
    24: {
      n: "TABLE"
    },
    /*::[*/
    25: {
      n: "ORANGE"
    },
    /*::[*/
    26: {
      n: "PRANGE"
    },
    /*::[*/
    27: {
      n: "SRANGE"
    },
    /*::[*/
    28: {
      n: "FRANGE"
    },
    /*::[*/
    29: {
      n: "KRANGE1"
    },
    /*::[*/
    32: {
      n: "HRANGE"
    },
    /*::[*/
    35: {
      n: "KRANGE2"
    },
    /*::[*/
    36: {
      n: "PROTEC"
    },
    /*::[*/
    37: {
      n: "FOOTER"
    },
    /*::[*/
    38: {
      n: "HEADER"
    },
    /*::[*/
    39: {
      n: "SETUP"
    },
    /*::[*/
    40: {
      n: "MARGINS"
    },
    /*::[*/
    41: {
      n: "LABELFMT"
    },
    /*::[*/
    42: {
      n: "TITLES"
    },
    /*::[*/
    43: {
      n: "SHEETJS"
    },
    /*::[*/
    45: {
      n: "GRAPH"
    },
    /*::[*/
    46: {
      n: "NGRAPH"
    },
    /*::[*/
    47: {
      n: "CALCCOUNT"
    },
    /*::[*/
    48: {
      n: "UNFORMATTED"
    },
    /*::[*/
    49: {
      n: "CURSORW12"
    },
    /*::[*/
    50: {
      n: "WINDOW"
    },
    /*::[*/
    51: {
      n: "STRING",
      f: c
    },
    /*::[*/
    55: {
      n: "PASSWORD"
    },
    /*::[*/
    56: {
      n: "LOCKED"
    },
    /*::[*/
    60: {
      n: "QUERY"
    },
    /*::[*/
    61: {
      n: "QUERYNAME"
    },
    /*::[*/
    62: {
      n: "PRINT"
    },
    /*::[*/
    63: {
      n: "PRINTNAME"
    },
    /*::[*/
    64: {
      n: "GRAPH2"
    },
    /*::[*/
    65: {
      n: "GRAPHNAME"
    },
    /*::[*/
    66: {
      n: "ZOOM"
    },
    /*::[*/
    67: {
      n: "SYMSPLIT"
    },
    /*::[*/
    68: {
      n: "NSROWS"
    },
    /*::[*/
    69: {
      n: "NSCOLS"
    },
    /*::[*/
    70: {
      n: "RULER"
    },
    /*::[*/
    71: {
      n: "NNAME"
    },
    /*::[*/
    72: {
      n: "ACOMM"
    },
    /*::[*/
    73: {
      n: "AMACRO"
    },
    /*::[*/
    74: {
      n: "PARSE"
    },
    /*::[*/
    102: {
      n: "PRANGES??"
    },
    /*::[*/
    103: {
      n: "RRANGES??"
    },
    /*::[*/
    104: {
      n: "FNAME??"
    },
    /*::[*/
    105: {
      n: "MRANGES??"
    },
    /*::[*/
    204: {
      n: "SHEETNAMECS",
      f: ce
    },
    /*::[*/
    222: {
      n: "SHEETNAMELP",
      f: we
    },
    /*::[*/
    65535: {
      n: ""
    }
  }, ze = {
    /*::[*/
    0: {
      n: "BOF"
    },
    /*::[*/
    1: {
      n: "EOF"
    },
    /*::[*/
    2: {
      n: "PASSWORD"
    },
    /*::[*/
    3: {
      n: "CALCSET"
    },
    /*::[*/
    4: {
      n: "WINDOWSET"
    },
    /*::[*/
    5: {
      n: "SHEETCELLPTR"
    },
    /*::[*/
    6: {
      n: "SHEETLAYOUT"
    },
    /*::[*/
    7: {
      n: "COLUMNWIDTH"
    },
    /*::[*/
    8: {
      n: "HIDDENCOLUMN"
    },
    /*::[*/
    9: {
      n: "USERRANGE"
    },
    /*::[*/
    10: {
      n: "SYSTEMRANGE"
    },
    /*::[*/
    11: {
      n: "ZEROFORCE"
    },
    /*::[*/
    12: {
      n: "SORTKEYDIR"
    },
    /*::[*/
    13: {
      n: "FILESEAL"
    },
    /*::[*/
    14: {
      n: "DATAFILLNUMS"
    },
    /*::[*/
    15: {
      n: "PRINTMAIN"
    },
    /*::[*/
    16: {
      n: "PRINTSTRING"
    },
    /*::[*/
    17: {
      n: "GRAPHMAIN"
    },
    /*::[*/
    18: {
      n: "GRAPHSTRING"
    },
    /*::[*/
    19: {
      n: "??"
    },
    /*::[*/
    20: {
      n: "ERRCELL"
    },
    /*::[*/
    21: {
      n: "NACELL"
    },
    /*::[*/
    22: {
      n: "LABEL16",
      f: le
    },
    /*::[*/
    23: {
      n: "NUMBER17",
      f: H
    },
    /*::[*/
    24: {
      n: "NUMBER18",
      f: M
    },
    /*::[*/
    25: {
      n: "FORMULA19",
      f: F
    },
    /*::[*/
    26: {
      n: "FORMULA1A"
    },
    /*::[*/
    27: {
      n: "XFORMAT",
      f: de
    },
    /*::[*/
    28: {
      n: "DTLABELMISC"
    },
    /*::[*/
    29: {
      n: "DTLABELCELL"
    },
    /*::[*/
    30: {
      n: "GRAPHWINDOW"
    },
    /*::[*/
    31: {
      n: "CPA"
    },
    /*::[*/
    32: {
      n: "LPLAUTO"
    },
    /*::[*/
    33: {
      n: "QUERY"
    },
    /*::[*/
    34: {
      n: "HIDDENSHEET"
    },
    /*::[*/
    35: {
      n: "??"
    },
    /*::[*/
    37: {
      n: "NUMBER25",
      f: P
    },
    /*::[*/
    38: {
      n: "??"
    },
    /*::[*/
    39: {
      n: "NUMBER27",
      f: Y
    },
    /*::[*/
    40: {
      n: "FORMULA28",
      f: Q
    },
    /*::[*/
    142: {
      n: "??"
    },
    /*::[*/
    147: {
      n: "??"
    },
    /*::[*/
    150: {
      n: "??"
    },
    /*::[*/
    151: {
      n: "??"
    },
    /*::[*/
    152: {
      n: "??"
    },
    /*::[*/
    153: {
      n: "??"
    },
    /*::[*/
    154: {
      n: "??"
    },
    /*::[*/
    155: {
      n: "??"
    },
    /*::[*/
    156: {
      n: "??"
    },
    /*::[*/
    163: {
      n: "??"
    },
    /*::[*/
    174: {
      n: "??"
    },
    /*::[*/
    175: {
      n: "??"
    },
    /*::[*/
    176: {
      n: "??"
    },
    /*::[*/
    177: {
      n: "??"
    },
    /*::[*/
    184: {
      n: "??"
    },
    /*::[*/
    185: {
      n: "??"
    },
    /*::[*/
    186: {
      n: "??"
    },
    /*::[*/
    187: {
      n: "??"
    },
    /*::[*/
    188: {
      n: "??"
    },
    /*::[*/
    195: {
      n: "??"
    },
    /*::[*/
    201: {
      n: "??"
    },
    /*::[*/
    204: {
      n: "SHEETNAMECS",
      f: ce
    },
    /*::[*/
    205: {
      n: "??"
    },
    /*::[*/
    206: {
      n: "??"
    },
    /*::[*/
    207: {
      n: "??"
    },
    /*::[*/
    208: {
      n: "??"
    },
    /*::[*/
    256: {
      n: "??"
    },
    /*::[*/
    259: {
      n: "??"
    },
    /*::[*/
    260: {
      n: "??"
    },
    /*::[*/
    261: {
      n: "??"
    },
    /*::[*/
    262: {
      n: "??"
    },
    /*::[*/
    263: {
      n: "??"
    },
    /*::[*/
    265: {
      n: "??"
    },
    /*::[*/
    266: {
      n: "??"
    },
    /*::[*/
    267: {
      n: "??"
    },
    /*::[*/
    268: {
      n: "??"
    },
    /*::[*/
    270: {
      n: "??"
    },
    /*::[*/
    271: {
      n: "??"
    },
    /*::[*/
    384: {
      n: "??"
    },
    /*::[*/
    389: {
      n: "??"
    },
    /*::[*/
    390: {
      n: "??"
    },
    /*::[*/
    393: {
      n: "??"
    },
    /*::[*/
    396: {
      n: "??"
    },
    /*::[*/
    512: {
      n: "??"
    },
    /*::[*/
    514: {
      n: "??"
    },
    /*::[*/
    513: {
      n: "??"
    },
    /*::[*/
    516: {
      n: "??"
    },
    /*::[*/
    517: {
      n: "??"
    },
    /*::[*/
    640: {
      n: "??"
    },
    /*::[*/
    641: {
      n: "??"
    },
    /*::[*/
    642: {
      n: "??"
    },
    /*::[*/
    643: {
      n: "??"
    },
    /*::[*/
    644: {
      n: "??"
    },
    /*::[*/
    645: {
      n: "??"
    },
    /*::[*/
    646: {
      n: "??"
    },
    /*::[*/
    647: {
      n: "??"
    },
    /*::[*/
    648: {
      n: "??"
    },
    /*::[*/
    658: {
      n: "??"
    },
    /*::[*/
    659: {
      n: "??"
    },
    /*::[*/
    660: {
      n: "??"
    },
    /*::[*/
    661: {
      n: "??"
    },
    /*::[*/
    662: {
      n: "??"
    },
    /*::[*/
    665: {
      n: "??"
    },
    /*::[*/
    666: {
      n: "??"
    },
    /*::[*/
    768: {
      n: "??"
    },
    /*::[*/
    772: {
      n: "??"
    },
    /*::[*/
    1537: {
      n: "SHEETINFOQP",
      f: Se
    },
    /*::[*/
    1600: {
      n: "??"
    },
    /*::[*/
    1602: {
      n: "??"
    },
    /*::[*/
    1793: {
      n: "??"
    },
    /*::[*/
    1794: {
      n: "??"
    },
    /*::[*/
    1795: {
      n: "??"
    },
    /*::[*/
    1796: {
      n: "??"
    },
    /*::[*/
    1920: {
      n: "??"
    },
    /*::[*/
    2048: {
      n: "??"
    },
    /*::[*/
    2049: {
      n: "??"
    },
    /*::[*/
    2052: {
      n: "??"
    },
    /*::[*/
    2688: {
      n: "??"
    },
    /*::[*/
    10998: {
      n: "??"
    },
    /*::[*/
    12849: {
      n: "??"
    },
    /*::[*/
    28233: {
      n: "??"
    },
    /*::[*/
    28484: {
      n: "??"
    },
    /*::[*/
    65535: {
      n: ""
    }
  };
  return {
    sheet_to_wk1: n,
    book_to_wk3: i,
    to_workbook: e
  };
}();
var h5 = /^\s|\s$|[\t\n\r]/;
function $u(r6, e) {
  if (!e.bookSST) return "";
  var t = [Ar];
  t[t.length] = Ge("sst", null, {
    xmlns: Fs[0],
    count: r6.Count,
    uniqueCount: r6.Unique
  });
  for (var n = 0; n != r6.length; ++n) if (r6[n] != null) {
    var i = r6[n], a = "<si>";
    i.r ? a += i.r : (a += "<t", i.t || (i.t = ""), i.t.match(h5) && (a += ' xml:space="preserve"'), a += ">" + Ht(i.t) + "</t>"), a += "</si>", t[t.length] = a;
  }
  return t.length > 2 && (t[t.length] = "</sst>", t[1] = t[1].replace("/>", ">")), t.join("");
}
function c5(r6) {
  return [r6.read_shift(4), r6.read_shift(4)];
}
function u5(r6, e) {
  return e || (e = Le(8)), e.write_shift(4, r6.Count), e.write_shift(4, r6.Unique), e;
}
var d5 = np;
function p5(r6) {
  var e = dn();
  Re(e, 159, u5(r6));
  for (var t = 0; t < r6.length; ++t) Re(e, 19, d5(r6[t]));
  return Re(
    e,
    160
    /* BrtEndSst */
  ), e.end();
}
function g5(r6) {
  for (var e = [], t = r6.split(""), n = 0; n < t.length; ++n) e[n] = t[n].charCodeAt(0);
  return e;
}
function Ku(r6) {
  var e = 0, t, n = g5(r6), i = n.length + 1, a, s, o, f, h;
  for (t = Pa(i), t[0] = n.length, a = 1; a != i; ++a) t[a] = n[a - 1];
  for (a = i - 1; a >= 0; --a) s = t[a], o = e & 16384 ? 1 : 0, f = e << 1 & 32767, h = o | f, e = h ^ s;
  return e ^ 52811;
}
var v5 = /* @__PURE__ */ function() {
  function r6(i, a) {
    switch (a.type) {
      case "base64":
        return e(ji(i), a);
      case "binary":
        return e(i, a);
      case "buffer":
        return e(It && Buffer.isBuffer(i) ? i.toString("binary") : Fo(i), a);
      case "array":
        return e(sf(i), a);
    }
    throw new Error("Unrecognized type " + a.type);
  }
  function e(i, a) {
    var s = a || {}, o = s.dense ? [] : {}, f = i.match(/\\trowd.*?\\row\b/g);
    if (!f.length) throw new Error("RTF missing table");
    var h = {
      s: {
        c: 0,
        r: 0
      },
      e: {
        c: 0,
        r: f.length - 1
      }
    };
    return f.forEach(function(c, p) {
      Array.isArray(o) && (o[p] = []);
      for (var v = /\\\w+\b/g, d = 0, w, x = -1; w = v.exec(c); ) {
        switch (w[0]) {
          case "\\cell":
            var S = c.slice(d, v.lastIndex - w[0].length);
            if (S[0] == " " && (S = S.slice(1)), ++x, S.length) {
              var A = {
                v: S,
                t: "s"
              };
              Array.isArray(o) ? o[p][x] = A : o[zt({
                r: p,
                c: x
              })] = A;
            }
            break;
        }
        d = v.lastIndex;
      }
      x > h.e.c && (h.e.c = x);
    }), o["!ref"] = Sr(h), o;
  }
  function t(i, a) {
    return Oa(r6(i, a), a);
  }
  function n(i) {
    for (var a = ["{\\rtf1\\ansi"], s = rr(i["!ref"]), o, f = Array.isArray(i), h = s.s.r; h <= s.e.r; ++h) {
      a.push("\\trowd\\trautofit1");
      for (var c = s.s.c; c <= s.e.c; ++c) a.push("\\cellx" + (c + 1));
      for (a.push("\\pard\\intbl"), c = s.s.c; c <= s.e.c; ++c) {
        var p = zt({
          r: h,
          c
        });
        o = f ? (i[h] || [])[c] : i[p], !(!o || o.v == null && (!o.f || o.F)) && (a.push(" " + (o.w || (Ui(o), o.w))), a.push("\\cell"));
      }
      a.push("\\pard\\intbl\\row");
    }
    return a.join("") + "}";
  }
  return {
    to_workbook: t,
    to_sheet: r6,
    from_sheet: n
  };
}();
function dc(r6) {
  for (var e = 0, t = 1; e != 3; ++e) t = t * 256 + (r6[e] > 255 ? 255 : r6[e] < 0 ? 0 : r6[e]);
  return t.toString(16).toUpperCase().slice(1);
}
var m5 = 6;
var Bi = m5;
function G0(r6) {
  return Math.floor((r6 + Math.round(128 / Bi) / 256) * Bi);
}
function X0(r6) {
  return Math.floor((r6 - 5) / Bi * 100 + 0.5) / 100;
}
function yl(r6) {
  return Math.round((r6 * Bi + 5) / Bi * 256) / 256;
}
function $l(r6) {
  r6.width ? (r6.wpx = G0(r6.width), r6.wch = X0(r6.wpx), r6.MDW = Bi) : r6.wpx ? (r6.wch = X0(r6.wpx), r6.width = yl(r6.wch), r6.MDW = Bi) : typeof r6.wch == "number" && (r6.width = yl(r6.wch), r6.wpx = G0(r6.width), r6.MDW = Bi), r6.customWidth && delete r6.customWidth;
}
var x5 = 96;
var Ju = x5;
function Y0(r6) {
  return r6 * 96 / Ju;
}
function Zu(r6) {
  return r6 * Ju / 96;
}
function w5(r6) {
  var e = ["<numFmts>"];
  return [[5, 8], [23, 26], [41, 44], [
    /*63*/
    50,
    /*66],[164,*/
    392
  ]].forEach(function(t) {
    for (var n = t[0]; n <= t[1]; ++n) r6[n] != null && (e[e.length] = Ge("numFmt", null, {
      numFmtId: n,
      formatCode: Ht(r6[n])
    }));
  }), e.length === 1 ? "" : (e[e.length] = "</numFmts>", e[0] = Ge("numFmts", null, {
    count: e.length - 2
  }).replace("/>", ">"), e.join(""));
}
function y5(r6) {
  var e = [];
  return e[e.length] = Ge("cellXfs", null), r6.forEach(function(t) {
    e[e.length] = Ge("xf", null, t);
  }), e[e.length] = "</cellXfs>", e.length === 2 ? "" : (e[0] = Ge("cellXfs", null, {
    count: e.length - 2
  }).replace("/>", ">"), e.join(""));
}
function Qu(r6, e) {
  var t = [Ar, Ge("styleSheet", null, {
    xmlns: Fs[0],
    "xmlns:vt": kr.vt
  })], n;
  return r6.SSF && (n = w5(r6.SSF)) != null && (t[t.length] = n), t[t.length] = '<fonts count="1"><font><sz val="12"/><color theme="1"/><name val="Calibri"/><family val="2"/><scheme val="minor"/></font></fonts>', t[t.length] = '<fills count="2"><fill><patternFill patternType="none"/></fill><fill><patternFill patternType="gray125"/></fill></fills>', t[t.length] = '<borders count="1"><border><left/><right/><top/><bottom/><diagonal/></border></borders>', t[t.length] = '<cellStyleXfs count="1"><xf numFmtId="0" fontId="0" fillId="0" borderId="0"/></cellStyleXfs>', (n = y5(e.cellXfs)) && (t[t.length] = n), t[t.length] = '<cellStyles count="1"><cellStyle name="Normal" xfId="0" builtinId="0"/></cellStyles>', t[t.length] = '<dxfs count="0"/>', t[t.length] = '<tableStyles count="0" defaultTableStyle="TableStyleMedium9" defaultPivotStyle="PivotStyleMedium4"/>', t.length > 2 && (t[t.length] = "</styleSheet>", t[1] = t[1].replace("/>", ">")), t.join("");
}
function _5(r6, e) {
  var t = r6.read_shift(2), n = Zr(r6);
  return [t, n];
}
function S5(r6, e, t) {
  t || (t = Le(6 + 4 * e.length)), t.write_shift(2, r6), Or(e, t);
  var n = t.length > t.l ? t.slice(0, t.l) : t;
  return t.l == null && (t.l = t.length), n;
}
function A5(r6, e, t) {
  var n = {};
  n.sz = r6.read_shift(2) / 20;
  var i = hp(r6);
  i.fItalic && (n.italic = 1), i.fCondense && (n.condense = 1), i.fExtend && (n.extend = 1), i.fShadow && (n.shadow = 1), i.fOutline && (n.outline = 1), i.fStrikeout && (n.strike = 1);
  var a = r6.read_shift(2);
  switch (a === 700 && (n.bold = 1), r6.read_shift(2)) {
    case 1:
      n.vertAlign = "superscript";
      break;
    case 2:
      n.vertAlign = "subscript";
      break;
  }
  var s = r6.read_shift(1);
  s != 0 && (n.underline = s);
  var o = r6.read_shift(1);
  o > 0 && (n.family = o);
  var f = r6.read_shift(1);
  switch (f > 0 && (n.charset = f), r6.l++, n.color = lp(r6), r6.read_shift(1)) {
    case 1:
      n.scheme = "major";
      break;
    case 2:
      n.scheme = "minor";
      break;
  }
  return n.name = Zr(r6), n;
}
function b5(r6, e) {
  e || (e = Le(25 + 4 * 32)), e.write_shift(2, r6.sz * 20), cp(r6, e), e.write_shift(2, r6.bold ? 700 : 400);
  var t = 0;
  r6.vertAlign == "superscript" ? t = 1 : r6.vertAlign == "subscript" && (t = 2), e.write_shift(2, t), e.write_shift(1, r6.underline || 0), e.write_shift(1, r6.family || 0), e.write_shift(1, r6.charset || 0), e.write_shift(1, 0), z0(r6.color, e);
  var n = 0;
  return r6.scheme == "major" && (n = 1), r6.scheme == "minor" && (n = 2), e.write_shift(1, n), Or(r6.name, e), e.length > e.l ? e.slice(0, e.l) : e;
}
var T5 = ["none", "solid", "mediumGray", "darkGray", "lightGray", "darkHorizontal", "darkVertical", "darkDown", "darkUp", "darkGrid", "darkTrellis", "lightHorizontal", "lightVertical", "lightDown", "lightUp", "lightGrid", "lightTrellis", "gray125", "gray0625"];
var el;
var E5 = wi;
function pc(r6, e) {
  e || (e = Le(4 * 3 + 8 * 7 + 16 * 1)), el || (el = Ml(T5));
  var t = el[r6.patternType];
  t == null && (t = 40), e.write_shift(4, t);
  var n = 0;
  if (t != 40) for (z0({
    auto: 1
  }, e), z0({
    auto: 1
  }, e); n < 12; ++n) e.write_shift(4, 0);
  else {
    for (; n < 4; ++n) e.write_shift(4, 0);
    for (; n < 12; ++n) e.write_shift(4, 0);
  }
  return e.length > e.l ? e.slice(0, e.l) : e;
}
function N5(r6, e) {
  var t = r6.l + e, n = r6.read_shift(2), i = r6.read_shift(2);
  return r6.l = t, {
    ixfe: n,
    numFmtId: i
  };
}
function e1(r6, e, t) {
  t || (t = Le(16)), t.write_shift(2, e || 0), t.write_shift(2, r6.numFmtId || 0), t.write_shift(2, 0), t.write_shift(2, 0), t.write_shift(2, 0), t.write_shift(1, 0), t.write_shift(1, 0);
  var n = 0;
  return t.write_shift(1, n), t.write_shift(1, 0), t.write_shift(1, 0), t.write_shift(1, 0), t;
}
function oo(r6, e) {
  return e || (e = Le(10)), e.write_shift(1, 0), e.write_shift(1, 0), e.write_shift(4, 0), e.write_shift(4, 0), e;
}
var F5 = wi;
function L5(r6, e) {
  return e || (e = Le(51)), e.write_shift(1, 0), oo(null, e), oo(null, e), oo(null, e), oo(null, e), oo(null, e), e.length > e.l ? e.slice(0, e.l) : e;
}
function C5(r6, e) {
  return e || (e = Le(12 + 4 * 10)), e.write_shift(4, r6.xfId), e.write_shift(2, 1), e.write_shift(1, +r6.builtinId), e.write_shift(1, 0), W0(r6.name || "", e), e.length > e.l ? e.slice(0, e.l) : e;
}
function P5(r6, e, t) {
  var n = Le(2052);
  return n.write_shift(4, r6), W0(e, n), W0(t, n), n.length > n.l ? n.slice(0, n.l) : n;
}
function k5(r6, e) {
  if (e) {
    var t = 0;
    [[5, 8], [23, 26], [41, 44], [
      /*63*/
      50,
      /*66],[164,*/
      392
    ]].forEach(function(n) {
      for (var i = n[0]; i <= n[1]; ++i) e[i] != null && ++t;
    }), t != 0 && (Re(r6, 615, ii(t)), [[5, 8], [23, 26], [41, 44], [
      /*63*/
      50,
      /*66],[164,*/
      392
    ]].forEach(function(n) {
      for (var i = n[0]; i <= n[1]; ++i) e[i] != null && Re(r6, 44, S5(i, e[i]));
    }), Re(
      r6,
      616
      /* BrtEndFmts */
    ));
  }
}
function D5(r6) {
  var e = 1;
  Re(r6, 611, ii(e)), Re(r6, 43, b5({
    sz: 12,
    color: {
      theme: 1
    },
    name: "Calibri",
    family: 2,
    scheme: "minor"
  })), Re(
    r6,
    612
    /* BrtEndFonts */
  );
}
function O5(r6) {
  var e = 2;
  Re(r6, 603, ii(e)), Re(r6, 45, pc({
    patternType: "none"
  })), Re(r6, 45, pc({
    patternType: "gray125"
  })), Re(
    r6,
    604
    /* BrtEndFills */
  );
}
function I5(r6) {
  var e = 1;
  Re(r6, 613, ii(e)), Re(r6, 46, L5()), Re(
    r6,
    614
    /* BrtEndBorders */
  );
}
function R5(r6) {
  var e = 1;
  Re(r6, 626, ii(e)), Re(r6, 47, e1({
    numFmtId: 0,
    fontId: 0,
    fillId: 0,
    borderId: 0
  }, 65535)), Re(
    r6,
    627
    /* BrtEndCellStyleXFs */
  );
}
function M5(r6, e) {
  Re(r6, 617, ii(e.length)), e.forEach(function(t) {
    Re(r6, 47, e1(t, 0));
  }), Re(
    r6,
    618
    /* BrtEndCellXFs */
  );
}
function B5(r6) {
  var e = 1;
  Re(r6, 619, ii(e)), Re(r6, 48, C5({
    xfId: 0,
    builtinId: 0,
    name: "Normal"
  })), Re(
    r6,
    620
    /* BrtEndStyles */
  );
}
function j5(r6) {
  var e = 0;
  Re(r6, 505, ii(e)), Re(
    r6,
    506
    /* BrtEndDXFs */
  );
}
function U5(r6) {
  var e = 0;
  Re(r6, 508, P5(e, "TableStyleMedium9", "PivotStyleMedium4")), Re(
    r6,
    509
    /* BrtEndTableStyles */
  );
}
function q5(r6, e) {
  var t = dn();
  return Re(
    t,
    278
    /* BrtBeginStyleSheet */
  ), k5(t, r6.SSF), D5(t), O5(t), I5(t), R5(t), M5(t, e.cellXfs), B5(t), j5(t), U5(t), Re(
    t,
    279
    /* BrtEndStyleSheet */
  ), t.end();
}
function t1(r6, e) {
  if (e && e.themeXLSX) return e.themeXLSX;
  if (r6 && typeof r6.raw == "string") return r6.raw;
  var t = [Ar];
  return t[t.length] = '<a:theme xmlns:a="http://schemas.openxmlformats.org/drawingml/2006/main" name="Office Theme">', t[t.length] = "<a:themeElements>", t[t.length] = '<a:clrScheme name="Office">', t[t.length] = '<a:dk1><a:sysClr val="windowText" lastClr="000000"/></a:dk1>', t[t.length] = '<a:lt1><a:sysClr val="window" lastClr="FFFFFF"/></a:lt1>', t[t.length] = '<a:dk2><a:srgbClr val="1F497D"/></a:dk2>', t[t.length] = '<a:lt2><a:srgbClr val="EEECE1"/></a:lt2>', t[t.length] = '<a:accent1><a:srgbClr val="4F81BD"/></a:accent1>', t[t.length] = '<a:accent2><a:srgbClr val="C0504D"/></a:accent2>', t[t.length] = '<a:accent3><a:srgbClr val="9BBB59"/></a:accent3>', t[t.length] = '<a:accent4><a:srgbClr val="8064A2"/></a:accent4>', t[t.length] = '<a:accent5><a:srgbClr val="4BACC6"/></a:accent5>', t[t.length] = '<a:accent6><a:srgbClr val="F79646"/></a:accent6>', t[t.length] = '<a:hlink><a:srgbClr val="0000FF"/></a:hlink>', t[t.length] = '<a:folHlink><a:srgbClr val="800080"/></a:folHlink>', t[t.length] = "</a:clrScheme>", t[t.length] = '<a:fontScheme name="Office">', t[t.length] = "<a:majorFont>", t[t.length] = '<a:latin typeface="Cambria"/>', t[t.length] = '<a:ea typeface=""/>', t[t.length] = '<a:cs typeface=""/>', t[t.length] = '<a:font script="Jpan" typeface="ＭＳ Ｐゴシック"/>', t[t.length] = '<a:font script="Hang" typeface="맑은 고딕"/>', t[t.length] = '<a:font script="Hans" typeface="宋体"/>', t[t.length] = '<a:font script="Hant" typeface="新細明體"/>', t[t.length] = '<a:font script="Arab" typeface="Times New Roman"/>', t[t.length] = '<a:font script="Hebr" typeface="Times New Roman"/>', t[t.length] = '<a:font script="Thai" typeface="Tahoma"/>', t[t.length] = '<a:font script="Ethi" typeface="Nyala"/>', t[t.length] = '<a:font script="Beng" typeface="Vrinda"/>', t[t.length] = '<a:font script="Gujr" typeface="Shruti"/>', t[t.length] = '<a:font script="Khmr" typeface="MoolBoran"/>', t[t.length] = '<a:font script="Knda" typeface="Tunga"/>', t[t.length] = '<a:font script="Guru" typeface="Raavi"/>', t[t.length] = '<a:font script="Cans" typeface="Euphemia"/>', t[t.length] = '<a:font script="Cher" typeface="Plantagenet Cherokee"/>', t[t.length] = '<a:font script="Yiii" typeface="Microsoft Yi Baiti"/>', t[t.length] = '<a:font script="Tibt" typeface="Microsoft Himalaya"/>', t[t.length] = '<a:font script="Thaa" typeface="MV Boli"/>', t[t.length] = '<a:font script="Deva" typeface="Mangal"/>', t[t.length] = '<a:font script="Telu" typeface="Gautami"/>', t[t.length] = '<a:font script="Taml" typeface="Latha"/>', t[t.length] = '<a:font script="Syrc" typeface="Estrangelo Edessa"/>', t[t.length] = '<a:font script="Orya" typeface="Kalinga"/>', t[t.length] = '<a:font script="Mlym" typeface="Kartika"/>', t[t.length] = '<a:font script="Laoo" typeface="DokChampa"/>', t[t.length] = '<a:font script="Sinh" typeface="Iskoola Pota"/>', t[t.length] = '<a:font script="Mong" typeface="Mongolian Baiti"/>', t[t.length] = '<a:font script="Viet" typeface="Times New Roman"/>', t[t.length] = '<a:font script="Uigh" typeface="Microsoft Uighur"/>', t[t.length] = '<a:font script="Geor" typeface="Sylfaen"/>', t[t.length] = "</a:majorFont>", t[t.length] = "<a:minorFont>", t[t.length] = '<a:latin typeface="Calibri"/>', t[t.length] = '<a:ea typeface=""/>', t[t.length] = '<a:cs typeface=""/>', t[t.length] = '<a:font script="Jpan" typeface="ＭＳ Ｐゴシック"/>', t[t.length] = '<a:font script="Hang" typeface="맑은 고딕"/>', t[t.length] = '<a:font script="Hans" typeface="宋体"/>', t[t.length] = '<a:font script="Hant" typeface="新細明體"/>', t[t.length] = '<a:font script="Arab" typeface="Arial"/>', t[t.length] = '<a:font script="Hebr" typeface="Arial"/>', t[t.length] = '<a:font script="Thai" typeface="Tahoma"/>', t[t.length] = '<a:font script="Ethi" typeface="Nyala"/>', t[t.length] = '<a:font script="Beng" typeface="Vrinda"/>', t[t.length] = '<a:font script="Gujr" typeface="Shruti"/>', t[t.length] = '<a:font script="Khmr" typeface="DaunPenh"/>', t[t.length] = '<a:font script="Knda" typeface="Tunga"/>', t[t.length] = '<a:font script="Guru" typeface="Raavi"/>', t[t.length] = '<a:font script="Cans" typeface="Euphemia"/>', t[t.length] = '<a:font script="Cher" typeface="Plantagenet Cherokee"/>', t[t.length] = '<a:font script="Yiii" typeface="Microsoft Yi Baiti"/>', t[t.length] = '<a:font script="Tibt" typeface="Microsoft Himalaya"/>', t[t.length] = '<a:font script="Thaa" typeface="MV Boli"/>', t[t.length] = '<a:font script="Deva" typeface="Mangal"/>', t[t.length] = '<a:font script="Telu" typeface="Gautami"/>', t[t.length] = '<a:font script="Taml" typeface="Latha"/>', t[t.length] = '<a:font script="Syrc" typeface="Estrangelo Edessa"/>', t[t.length] = '<a:font script="Orya" typeface="Kalinga"/>', t[t.length] = '<a:font script="Mlym" typeface="Kartika"/>', t[t.length] = '<a:font script="Laoo" typeface="DokChampa"/>', t[t.length] = '<a:font script="Sinh" typeface="Iskoola Pota"/>', t[t.length] = '<a:font script="Mong" typeface="Mongolian Baiti"/>', t[t.length] = '<a:font script="Viet" typeface="Arial"/>', t[t.length] = '<a:font script="Uigh" typeface="Microsoft Uighur"/>', t[t.length] = '<a:font script="Geor" typeface="Sylfaen"/>', t[t.length] = "</a:minorFont>", t[t.length] = "</a:fontScheme>", t[t.length] = '<a:fmtScheme name="Office">', t[t.length] = "<a:fillStyleLst>", t[t.length] = '<a:solidFill><a:schemeClr val="phClr"/></a:solidFill>', t[t.length] = '<a:gradFill rotWithShape="1">', t[t.length] = "<a:gsLst>", t[t.length] = '<a:gs pos="0"><a:schemeClr val="phClr"><a:tint val="50000"/><a:satMod val="300000"/></a:schemeClr></a:gs>', t[t.length] = '<a:gs pos="35000"><a:schemeClr val="phClr"><a:tint val="37000"/><a:satMod val="300000"/></a:schemeClr></a:gs>', t[t.length] = '<a:gs pos="100000"><a:schemeClr val="phClr"><a:tint val="15000"/><a:satMod val="350000"/></a:schemeClr></a:gs>', t[t.length] = "</a:gsLst>", t[t.length] = '<a:lin ang="16200000" scaled="1"/>', t[t.length] = "</a:gradFill>", t[t.length] = '<a:gradFill rotWithShape="1">', t[t.length] = "<a:gsLst>", t[t.length] = '<a:gs pos="0"><a:schemeClr val="phClr"><a:tint val="100000"/><a:shade val="100000"/><a:satMod val="130000"/></a:schemeClr></a:gs>', t[t.length] = '<a:gs pos="100000"><a:schemeClr val="phClr"><a:tint val="50000"/><a:shade val="100000"/><a:satMod val="350000"/></a:schemeClr></a:gs>', t[t.length] = "</a:gsLst>", t[t.length] = '<a:lin ang="16200000" scaled="0"/>', t[t.length] = "</a:gradFill>", t[t.length] = "</a:fillStyleLst>", t[t.length] = "<a:lnStyleLst>", t[t.length] = '<a:ln w="9525" cap="flat" cmpd="sng" algn="ctr"><a:solidFill><a:schemeClr val="phClr"><a:shade val="95000"/><a:satMod val="105000"/></a:schemeClr></a:solidFill><a:prstDash val="solid"/></a:ln>', t[t.length] = '<a:ln w="25400" cap="flat" cmpd="sng" algn="ctr"><a:solidFill><a:schemeClr val="phClr"/></a:solidFill><a:prstDash val="solid"/></a:ln>', t[t.length] = '<a:ln w="38100" cap="flat" cmpd="sng" algn="ctr"><a:solidFill><a:schemeClr val="phClr"/></a:solidFill><a:prstDash val="solid"/></a:ln>', t[t.length] = "</a:lnStyleLst>", t[t.length] = "<a:effectStyleLst>", t[t.length] = "<a:effectStyle>", t[t.length] = "<a:effectLst>", t[t.length] = '<a:outerShdw blurRad="40000" dist="20000" dir="5400000" rotWithShape="0"><a:srgbClr val="000000"><a:alpha val="38000"/></a:srgbClr></a:outerShdw>', t[t.length] = "</a:effectLst>", t[t.length] = "</a:effectStyle>", t[t.length] = "<a:effectStyle>", t[t.length] = "<a:effectLst>", t[t.length] = '<a:outerShdw blurRad="40000" dist="23000" dir="5400000" rotWithShape="0"><a:srgbClr val="000000"><a:alpha val="35000"/></a:srgbClr></a:outerShdw>', t[t.length] = "</a:effectLst>", t[t.length] = "</a:effectStyle>", t[t.length] = "<a:effectStyle>", t[t.length] = "<a:effectLst>", t[t.length] = '<a:outerShdw blurRad="40000" dist="23000" dir="5400000" rotWithShape="0"><a:srgbClr val="000000"><a:alpha val="35000"/></a:srgbClr></a:outerShdw>', t[t.length] = "</a:effectLst>", t[t.length] = '<a:scene3d><a:camera prst="orthographicFront"><a:rot lat="0" lon="0" rev="0"/></a:camera><a:lightRig rig="threePt" dir="t"><a:rot lat="0" lon="0" rev="1200000"/></a:lightRig></a:scene3d>', t[t.length] = '<a:sp3d><a:bevelT w="63500" h="25400"/></a:sp3d>', t[t.length] = "</a:effectStyle>", t[t.length] = "</a:effectStyleLst>", t[t.length] = "<a:bgFillStyleLst>", t[t.length] = '<a:solidFill><a:schemeClr val="phClr"/></a:solidFill>', t[t.length] = '<a:gradFill rotWithShape="1">', t[t.length] = "<a:gsLst>", t[t.length] = '<a:gs pos="0"><a:schemeClr val="phClr"><a:tint val="40000"/><a:satMod val="350000"/></a:schemeClr></a:gs>', t[t.length] = '<a:gs pos="40000"><a:schemeClr val="phClr"><a:tint val="45000"/><a:shade val="99000"/><a:satMod val="350000"/></a:schemeClr></a:gs>', t[t.length] = '<a:gs pos="100000"><a:schemeClr val="phClr"><a:shade val="20000"/><a:satMod val="255000"/></a:schemeClr></a:gs>', t[t.length] = "</a:gsLst>", t[t.length] = '<a:path path="circle"><a:fillToRect l="50000" t="-80000" r="50000" b="180000"/></a:path>', t[t.length] = "</a:gradFill>", t[t.length] = '<a:gradFill rotWithShape="1">', t[t.length] = "<a:gsLst>", t[t.length] = '<a:gs pos="0"><a:schemeClr val="phClr"><a:tint val="80000"/><a:satMod val="300000"/></a:schemeClr></a:gs>', t[t.length] = '<a:gs pos="100000"><a:schemeClr val="phClr"><a:shade val="30000"/><a:satMod val="200000"/></a:schemeClr></a:gs>', t[t.length] = "</a:gsLst>", t[t.length] = '<a:path path="circle"><a:fillToRect l="50000" t="50000" r="50000" b="50000"/></a:path>', t[t.length] = "</a:gradFill>", t[t.length] = "</a:bgFillStyleLst>", t[t.length] = "</a:fmtScheme>", t[t.length] = "</a:themeElements>", t[t.length] = "<a:objectDefaults>", t[t.length] = "<a:spDef>", t[t.length] = '<a:spPr/><a:bodyPr/><a:lstStyle/><a:style><a:lnRef idx="1"><a:schemeClr val="accent1"/></a:lnRef><a:fillRef idx="3"><a:schemeClr val="accent1"/></a:fillRef><a:effectRef idx="2"><a:schemeClr val="accent1"/></a:effectRef><a:fontRef idx="minor"><a:schemeClr val="lt1"/></a:fontRef></a:style>', t[t.length] = "</a:spDef>", t[t.length] = "<a:lnDef>", t[t.length] = '<a:spPr/><a:bodyPr/><a:lstStyle/><a:style><a:lnRef idx="2"><a:schemeClr val="accent1"/></a:lnRef><a:fillRef idx="0"><a:schemeClr val="accent1"/></a:fillRef><a:effectRef idx="1"><a:schemeClr val="accent1"/></a:effectRef><a:fontRef idx="minor"><a:schemeClr val="tx1"/></a:fontRef></a:style>', t[t.length] = "</a:lnDef>", t[t.length] = "</a:objectDefaults>", t[t.length] = "<a:extraClrSchemeLst/>", t[t.length] = "</a:theme>", t.join("");
}
function H5(r6, e) {
  return {
    flags: r6.read_shift(4),
    version: r6.read_shift(4),
    name: Zr(r6)
  };
}
function W5(r6) {
  var e = Le(12 + 2 * r6.name.length);
  return e.write_shift(4, r6.flags), e.write_shift(4, r6.version), Or(r6.name, e), e.slice(0, e.l);
}
function z5(r6) {
  for (var e = [], t = r6.read_shift(4); t-- > 0; ) e.push([r6.read_shift(4), r6.read_shift(4)]);
  return e;
}
function V5(r6) {
  var e = Le(4 + 8 * r6.length);
  e.write_shift(4, r6.length);
  for (var t = 0; t < r6.length; ++t) e.write_shift(4, r6[t][0]), e.write_shift(4, r6[t][1]);
  return e;
}
function G5(r6, e) {
  var t = Le(8 + 2 * e.length);
  return t.write_shift(4, r6), Or(e, t), t.slice(0, t.l);
}
function X5(r6) {
  return r6.l += 4, r6.read_shift(4) != 0;
}
function Y5(r6, e) {
  var t = Le(8);
  return t.write_shift(4, r6), t.write_shift(4, e ? 1 : 0), t;
}
function $5() {
  var r6 = dn();
  return Re(r6, 332), Re(r6, 334, ii(1)), Re(r6, 335, W5({
    name: "XLDAPR",
    version: 12e4,
    flags: 3496657072
  })), Re(r6, 336), Re(r6, 339, G5(1, "XLDAPR")), Re(r6, 52), Re(r6, 35, ii(514)), Re(r6, 4096, ii(0)), Re(r6, 4097, qn(1)), Re(r6, 36), Re(r6, 53), Re(r6, 340), Re(r6, 337, Y5(1, true)), Re(r6, 51, V5([[1, 0]])), Re(r6, 338), Re(r6, 333), r6.end();
}
function r1() {
  var r6 = [Ar];
  return r6.push(`<metadata xmlns="http://schemas.openxmlformats.org/spreadsheetml/2006/main" xmlns:xlrd="http://schemas.microsoft.com/office/spreadsheetml/2017/richdata" xmlns:xda="http://schemas.microsoft.com/office/spreadsheetml/2017/dynamicarray">
  <metadataTypes count="1">
    <metadataType name="XLDAPR" minSupportedVersion="120000" copy="1" pasteAll="1" pasteValues="1" merge="1" splitFirst="1" rowColShift="1" clearFormats="1" clearComments="1" assign="1" coerce="1" cellMeta="1"/>
  </metadataTypes>
  <futureMetadata name="XLDAPR" count="1">
    <bk>
      <extLst>
        <ext uri="{bdbb8cdc-fa1e-496e-a857-3c3f30c029c3}">
          <xda:dynamicArrayProperties fDynamic="1" fCollapsed="0"/>
        </ext>
      </extLst>
    </bk>
  </futureMetadata>
  <cellMetadata count="1">
    <bk>
      <rc t="1" v="0"/>
    </bk>
  </cellMetadata>
</metadata>`), r6.join("");
}
function K5(r6) {
  var e = {};
  e.i = r6.read_shift(4);
  var t = {};
  t.r = r6.read_shift(4), t.c = r6.read_shift(4), e.r = zt(t);
  var n = r6.read_shift(1);
  return n & 2 && (e.l = "1"), n & 8 && (e.a = "1"), e;
}
var vs = 1024;
function n1(r6, e) {
  for (var t = [21600, 21600], n = ["m0,0l0", t[1], t[0], t[1], t[0], "0xe"].join(","), i = [Ge("xml", null, {
    "xmlns:v": En.v,
    "xmlns:o": En.o,
    "xmlns:x": En.x,
    "xmlns:mv": En.mv
  }).replace(/\/>/, ">"), Ge("o:shapelayout", Ge("o:idmap", null, {
    "v:ext": "edit",
    data: r6
  }), {
    "v:ext": "edit"
  }), Ge("v:shapetype", [Ge("v:stroke", null, {
    joinstyle: "miter"
  }), Ge("v:path", null, {
    gradientshapeok: "t",
    "o:connecttype": "rect"
  })].join(""), {
    id: "_x0000_t202",
    "o:spt": 202,
    coordsize: t.join(","),
    path: n
  })]; vs < r6 * 1e3; ) vs += 1e3;
  return e.forEach(function(a) {
    var s = Dr(a[0]), o = (
      /*::(*/
      {
        color2: "#BEFF82",
        type: "gradient"
      }
    );
    o.type == "gradient" && (o.angle = "-180");
    var f = o.type == "gradient" ? Ge("o:fill", null, {
      type: "gradientUnscaled",
      "v:ext": "view"
    }) : null, h = Ge("v:fill", f, o), c = {
      on: "t",
      obscured: "t"
    };
    ++vs, i = i.concat([
      "<v:shape" + bo({
        id: "_x0000_s" + vs,
        type: "#_x0000_t202",
        style: "position:absolute; margin-left:80pt;margin-top:5pt;width:104pt;height:64pt;z-index:10" + (a[1].hidden ? ";visibility:hidden" : ""),
        fillcolor: "#ECFAD4",
        strokecolor: "#edeaa1"
      }) + ">",
      h,
      Ge("v:shadow", null, c),
      Ge("v:path", null, {
        "o:connecttype": "none"
      }),
      '<v:textbox><div style="text-align:left"></div></v:textbox>',
      '<x:ClientData ObjectType="Note">',
      "<x:MoveWithCells/>",
      "<x:SizeWithCells/>",
      /* Part 4 19.4.2.3 Anchor (Anchor) */
      Ur("x:Anchor", [s.c + 1, 0, s.r + 1, 0, s.c + 3, 20, s.r + 5, 20].join(",")),
      Ur("x:AutoFill", "False"),
      Ur("x:Row", String(s.r)),
      Ur("x:Column", String(s.c)),
      a[1].hidden ? "" : "<x:Visible/>",
      "</x:ClientData>",
      "</v:shape>"
    ]);
  }), i.push("</xml>"), i.join("");
}
function i1(r6) {
  var e = [Ar, Ge("comments", null, {
    xmlns: Fs[0]
  })], t = [];
  return e.push("<authors>"), r6.forEach(function(n) {
    n[1].forEach(function(i) {
      var a = Ht(i.a);
      t.indexOf(a) == -1 && (t.push(a), e.push("<author>" + a + "</author>")), i.T && i.ID && t.indexOf("tc=" + i.ID) == -1 && (t.push("tc=" + i.ID), e.push("<author>tc=" + i.ID + "</author>"));
    });
  }), t.length == 0 && (t.push("SheetJ5"), e.push("<author>SheetJ5</author>")), e.push("</authors>"), e.push("<commentList>"), r6.forEach(function(n) {
    var i = 0, a = [];
    if (n[1][0] && n[1][0].T && n[1][0].ID ? i = t.indexOf("tc=" + n[1][0].ID) : n[1].forEach(function(f) {
      f.a && (i = t.indexOf(Ht(f.a))), a.push(f.t || "");
    }), e.push('<comment ref="' + n[0] + '" authorId="' + i + '"><text>'), a.length <= 1) e.push(Ur("t", Ht(a[0] || "")));
    else {
      for (var s = `Comment:
    ` + a[0] + `
`, o = 1; o < a.length; ++o) s += `Reply:
    ` + a[o] + `
`;
      e.push(Ur("t", Ht(s)));
    }
    e.push("</text></comment>");
  }), e.push("</commentList>"), e.length > 2 && (e[e.length] = "</comments>", e[1] = e[1].replace("/>", ">")), e.join("");
}
function J5(r6, e, t) {
  var n = [Ar, Ge("ThreadedComments", null, {
    xmlns: kr.TCMNT
  }).replace(/[\/]>/, ">")];
  return r6.forEach(function(i) {
    var a = "";
    (i[1] || []).forEach(function(s, o) {
      if (!s.T) {
        delete s.ID;
        return;
      }
      s.a && e.indexOf(s.a) == -1 && e.push(s.a);
      var f = {
        ref: i[0],
        id: "{54EE7951-7262-4200-6969-" + ("000000000000" + t.tcid++).slice(-12) + "}"
      };
      o == 0 ? a = f.id : f.parentId = a, s.ID = f.id, s.a && (f.personId = "{54EE7950-7262-4200-6969-" + ("000000000000" + e.indexOf(s.a)).slice(-12) + "}"), n.push(Ge("threadedComment", Ur("text", s.t || ""), f));
    });
  }), n.push("</ThreadedComments>"), n.join("");
}
function Z5(r6) {
  var e = [Ar, Ge("personList", null, {
    xmlns: kr.TCMNT,
    "xmlns:x": Fs[0]
  }).replace(/[\/]>/, ">")];
  return r6.forEach(function(t, n) {
    e.push(Ge("person", null, {
      displayName: t,
      id: "{54EE7950-7262-4200-6969-" + ("000000000000" + n).slice(-12) + "}",
      userId: t,
      providerId: "None"
    }));
  }), e.push("</personList>"), e.join("");
}
function Q5(r6) {
  var e = {};
  e.iauthor = r6.read_shift(4);
  var t = Ba(r6);
  return e.rfx = t.s, e.ref = zt(t.s), r6.l += 16, e;
}
function eg(r6, e) {
  return e == null && (e = Le(36)), e.write_shift(4, r6[1].iauthor), Cs(r6[0], e), e.write_shift(4, 0), e.write_shift(4, 0), e.write_shift(4, 0), e.write_shift(4, 0), e;
}
var tg = Zr;
function rg(r6) {
  return Or(r6.slice(0, 54));
}
function ng(r6) {
  var e = dn(), t = [];
  return Re(
    e,
    628
    /* BrtBeginComments */
  ), Re(
    e,
    630
    /* BrtBeginCommentAuthors */
  ), r6.forEach(function(n) {
    n[1].forEach(function(i) {
      t.indexOf(i.a) > -1 || (t.push(i.a.slice(0, 54)), Re(e, 632, rg(i.a)));
    });
  }), Re(
    e,
    631
    /* BrtEndCommentAuthors */
  ), Re(
    e,
    633
    /* BrtBeginCommentList */
  ), r6.forEach(function(n) {
    n[1].forEach(function(i) {
      i.iauthor = t.indexOf(i.a);
      var a = {
        s: Dr(n[0]),
        e: Dr(n[0])
      };
      Re(e, 635, eg([a, i])), i.t && i.t.length > 0 && Re(e, 637, ap(i)), Re(
        e,
        636
        /* BrtEndComment */
      ), delete i.iauthor;
    });
  }), Re(
    e,
    634
    /* BrtEndCommentList */
  ), Re(
    e,
    629
    /* BrtEndComments */
  ), e.end();
}
function ig(r6, e) {
  e.FullPaths.forEach(function(t, n) {
    if (n != 0) {
      var i = t.replace(/[^\/]*[\/]/, "/_VBA_PROJECT_CUR/");
      i.slice(-1) !== "/" && Xt.utils.cfb_add(r6, i, e.FileIndex[n].content);
    }
  });
}
var a1 = ["xlsb", "xlsm", "xlam", "biff8", "xla"];
var ag = /* @__PURE__ */ function() {
  var r6 = /(^|[^A-Za-z_])R(\[?-?\d+\]|[1-9]\d*|)C(\[?-?\d+\]|[1-9]\d*|)(?![A-Za-z0-9_])/g, e = {
    r: 0,
    c: 0
  };
  function t(n, i, a, s) {
    var o = false, f = false;
    a.length == 0 ? f = true : a.charAt(0) == "[" && (f = true, a = a.slice(1, -1)), s.length == 0 ? o = true : s.charAt(0) == "[" && (o = true, s = s.slice(1, -1));
    var h = a.length > 0 ? parseInt(a, 10) | 0 : 0, c = s.length > 0 ? parseInt(s, 10) | 0 : 0;
    return o ? c += e.c : --c, f ? h += e.r : --h, i + (o ? "" : "$") + Jr(c) + (f ? "" : "$") + qr(h);
  }
  return function(i, a) {
    return e = a, i.replace(r6, t);
  };
}();
var Kl = /(^|[^._A-Z0-9])([$]?)([A-Z]{1,2}|[A-W][A-Z]{2}|X[A-E][A-Z]|XF[A-D])([$]?)(10[0-3]\d{4}|104[0-7]\d{3}|1048[0-4]\d{2}|10485[0-6]\d|104857[0-6]|[1-9]\d{0,5})(?![_.\(A-Za-z0-9])/g;
var Jl = /* @__PURE__ */ function() {
  return function(e, t) {
    return e.replace(Kl, function(n, i, a, s, o, f) {
      var h = zl(s) - (a ? 0 : t.c), c = Wl(f) - (o ? 0 : t.r), p = c == 0 ? "" : o ? c + 1 : "[" + c + "]", v = h == 0 ? "" : a ? h + 1 : "[" + h + "]";
      return i + "R" + p + "C" + v;
    });
  };
}();
function sg(r6, e) {
  return r6.replace(Kl, function(t, n, i, a, s, o) {
    return n + (i == "$" ? i + a : Jr(zl(a) + e.c)) + (s == "$" ? s + o : qr(Wl(o) + e.r));
  });
}
function og(r6) {
  return r6.length != 1;
}
function _r(r6) {
  r6.l += 1;
}
function ha(r6, e) {
  var t = r6.read_shift(e == 1 ? 1 : 2);
  return [t & 16383, t >> 14 & 1, t >> 15 & 1];
}
function s1(r6, e, t) {
  var n = 2;
  if (t) {
    if (t.biff >= 2 && t.biff <= 5) return o1(r6);
    t.biff == 12 && (n = 4);
  }
  var i = r6.read_shift(n), a = r6.read_shift(n), s = ha(r6, 2), o = ha(r6, 2);
  return {
    s: {
      r: i,
      c: s[0],
      cRel: s[1],
      rRel: s[2]
    },
    e: {
      r: a,
      c: o[0],
      cRel: o[1],
      rRel: o[2]
    }
  };
}
function o1(r6) {
  var e = ha(r6, 2), t = ha(r6, 2), n = r6.read_shift(1), i = r6.read_shift(1);
  return {
    s: {
      r: e[0],
      c: n,
      cRel: e[1],
      rRel: e[2]
    },
    e: {
      r: t[0],
      c: i,
      cRel: t[1],
      rRel: t[2]
    }
  };
}
function fg(r6, e, t) {
  if (t.biff < 8) return o1(r6);
  var n = r6.read_shift(t.biff == 12 ? 4 : 2), i = r6.read_shift(t.biff == 12 ? 4 : 2), a = ha(r6, 2), s = ha(r6, 2);
  return {
    s: {
      r: n,
      c: a[0],
      cRel: a[1],
      rRel: a[2]
    },
    e: {
      r: i,
      c: s[0],
      cRel: s[1],
      rRel: s[2]
    }
  };
}
function f1(r6, e, t) {
  if (t && t.biff >= 2 && t.biff <= 5) return lg(r6);
  var n = r6.read_shift(t && t.biff == 12 ? 4 : 2), i = ha(r6, 2);
  return {
    r: n,
    c: i[0],
    cRel: i[1],
    rRel: i[2]
  };
}
function lg(r6) {
  var e = ha(r6, 2), t = r6.read_shift(1);
  return {
    r: e[0],
    c: t,
    cRel: e[1],
    rRel: e[2]
  };
}
function hg(r6) {
  var e = r6.read_shift(2), t = r6.read_shift(2);
  return {
    r: e,
    c: t & 255,
    fQuoted: !!(t & 16384),
    cRel: t >> 15,
    rRel: t >> 15
  };
}
function cg(r6, e, t) {
  var n = t && t.biff ? t.biff : 8;
  if (n >= 2 && n <= 5) return ug(r6);
  var i = r6.read_shift(n >= 12 ? 4 : 2), a = r6.read_shift(2), s = (a & 16384) >> 14, o = (a & 32768) >> 15;
  if (a &= 16383, o == 1) for (; i > 524287; ) i -= 1048576;
  if (s == 1) for (; a > 8191; ) a = a - 16384;
  return {
    r: i,
    c: a,
    cRel: s,
    rRel: o
  };
}
function ug(r6) {
  var e = r6.read_shift(2), t = r6.read_shift(1), n = (e & 32768) >> 15, i = (e & 16384) >> 14;
  return e &= 16383, n == 1 && e >= 8192 && (e = e - 16384), i == 1 && t >= 128 && (t = t - 256), {
    r: e,
    c: t,
    cRel: i,
    rRel: n
  };
}
function dg(r6, e, t) {
  var n = (r6[r6.l++] & 96) >> 5, i = s1(r6, t.biff >= 2 && t.biff <= 5 ? 6 : 8, t);
  return [n, i];
}
function pg(r6, e, t) {
  var n = (r6[r6.l++] & 96) >> 5, i = r6.read_shift(2, "i"), a = 8;
  if (t) switch (t.biff) {
    case 5:
      r6.l += 12, a = 6;
      break;
    case 12:
      a = 12;
      break;
  }
  var s = s1(r6, a, t);
  return [n, i, s];
}
function gg(r6, e, t) {
  var n = (r6[r6.l++] & 96) >> 5;
  return r6.l += t && t.biff > 8 ? 12 : t.biff < 8 ? 6 : 8, [n];
}
function vg(r6, e, t) {
  var n = (r6[r6.l++] & 96) >> 5, i = r6.read_shift(2), a = 8;
  if (t) switch (t.biff) {
    case 5:
      r6.l += 12, a = 6;
      break;
    case 12:
      a = 12;
      break;
  }
  return r6.l += a, [n, i];
}
function mg(r6, e, t) {
  var n = (r6[r6.l++] & 96) >> 5, i = fg(r6, e - 1, t);
  return [n, i];
}
function xg(r6, e, t) {
  var n = (r6[r6.l++] & 96) >> 5;
  return r6.l += t.biff == 2 ? 6 : t.biff == 12 ? 14 : 7, [n];
}
function gc(r6) {
  var e = r6[r6.l + 1] & 1, t = 1;
  return r6.l += 4, [e, t];
}
function wg(r6, e, t) {
  r6.l += 2;
  for (var n = r6.read_shift(t && t.biff == 2 ? 1 : 2), i = [], a = 0; a <= n; ++a) i.push(r6.read_shift(t && t.biff == 2 ? 1 : 2));
  return i;
}
function yg(r6, e, t) {
  var n = r6[r6.l + 1] & 255 ? 1 : 0;
  return r6.l += 2, [n, r6.read_shift(t && t.biff == 2 ? 1 : 2)];
}
function _g(r6, e, t) {
  var n = r6[r6.l + 1] & 255 ? 1 : 0;
  return r6.l += 2, [n, r6.read_shift(t && t.biff == 2 ? 1 : 2)];
}
function Sg(r6) {
  var e = r6[r6.l + 1] & 255 ? 1 : 0;
  return r6.l += 2, [e, r6.read_shift(2)];
}
function Ag(r6, e, t) {
  var n = r6[r6.l + 1] & 255 ? 1 : 0;
  return r6.l += t && t.biff == 2 ? 3 : 4, [n];
}
function l1(r6) {
  var e = r6.read_shift(1), t = r6.read_shift(1);
  return [e, t];
}
function bg(r6) {
  return r6.read_shift(2), l1(r6);
}
function Tg(r6) {
  return r6.read_shift(2), l1(r6);
}
function Eg(r6, e, t) {
  var n = (r6[r6.l] & 96) >> 5;
  r6.l += 1;
  var i = f1(r6, 0, t);
  return [n, i];
}
function Ng(r6, e, t) {
  var n = (r6[r6.l] & 96) >> 5;
  r6.l += 1;
  var i = cg(r6, 0, t);
  return [n, i];
}
function Fg(r6, e, t) {
  var n = (r6[r6.l] & 96) >> 5;
  r6.l += 1;
  var i = r6.read_shift(2);
  t && t.biff == 5 && (r6.l += 12);
  var a = f1(r6, 0, t);
  return [n, i, a];
}
function Lg(r6, e, t) {
  var n = (r6[r6.l] & 96) >> 5;
  r6.l += 1;
  var i = r6.read_shift(t && t.biff <= 3 ? 1 : 2);
  return [Lv[i], u1[i], n];
}
function Cg(r6, e, t) {
  var n = r6[r6.l++], i = r6.read_shift(1), a = t && t.biff <= 3 ? [n == 88 ? -1 : 0, r6.read_shift(1)] : Pg(r6);
  return [i, (a[0] === 0 ? u1 : Fv)[a[1]]];
}
function Pg(r6) {
  return [r6[r6.l + 1] >> 7, r6.read_shift(2) & 32767];
}
function kg(r6, e, t) {
  r6.l += t && t.biff == 2 ? 3 : 4;
}
function Dg(r6, e, t) {
  if (r6.l++, t && t.biff == 12) return [r6.read_shift(4, "i"), 0];
  var n = r6.read_shift(2), i = r6.read_shift(t && t.biff == 2 ? 1 : 2);
  return [n, i];
}
function Og(r6) {
  return r6.l++, Po[r6.read_shift(1)];
}
function Ig(r6) {
  return r6.l++, r6.read_shift(2);
}
function Rg(r6) {
  return r6.l++, r6.read_shift(1) !== 0;
}
function Mg(r6) {
  return r6.l++, Ps(r6);
}
function Bg(r6, e, t) {
  return r6.l++, Vu(r6, e - 1, t);
}
function jg(r6, e) {
  var t = [r6.read_shift(1)];
  if (e == 12) switch (t[0]) {
    case 2:
      t[0] = 4;
      break;
    case 4:
      t[0] = 16;
      break;
    case 0:
      t[0] = 1;
      break;
    case 1:
      t[0] = 2;
      break;
  }
  switch (t[0]) {
    case 4:
      t[1] = Fp(r6, 1) ? "TRUE" : "FALSE", e != 12 && (r6.l += 7);
      break;
    case 37:
    case 16:
      t[1] = Po[r6[r6.l]], r6.l += e == 12 ? 4 : 8;
      break;
    case 0:
      r6.l += 8;
      break;
    case 1:
      t[1] = Ps(r6);
      break;
    case 2:
      t[1] = kp(r6, 0, {
        biff: e > 0 && e < 8 ? 2 : e
      });
      break;
    default:
      throw new Error("Bad SerAr: " + t[0]);
  }
  return t;
}
function Ug(r6, e, t) {
  for (var n = r6.read_shift(t.biff == 12 ? 4 : 2), i = [], a = 0; a != n; ++a) i.push((t.biff == 12 ? Ba : Ip)(r6));
  return i;
}
function qg(r6, e, t) {
  var n = 0, i = 0;
  t.biff == 12 ? (n = r6.read_shift(4), i = r6.read_shift(4)) : (i = 1 + r6.read_shift(1), n = 1 + r6.read_shift(2)), t.biff >= 2 && t.biff < 8 && (--n, --i == 0 && (i = 256));
  for (var a = 0, s = []; a != n && (s[a] = []); ++a) for (var o = 0; o != i; ++o) s[a][o] = jg(r6, t.biff);
  return s;
}
function Hg(r6, e, t) {
  var n = r6.read_shift(1) >>> 5 & 3, i = !t || t.biff >= 8 ? 4 : 2, a = r6.read_shift(i);
  switch (t.biff) {
    case 2:
      r6.l += 5;
      break;
    case 3:
    case 4:
      r6.l += 8;
      break;
    case 5:
      r6.l += 12;
      break;
  }
  return [n, 0, a];
}
function Wg(r6, e, t) {
  if (t.biff == 5) return zg(r6);
  var n = r6.read_shift(1) >>> 5 & 3, i = r6.read_shift(2), a = r6.read_shift(4);
  return [n, i, a];
}
function zg(r6) {
  var e = r6.read_shift(1) >>> 5 & 3, t = r6.read_shift(2, "i");
  r6.l += 8;
  var n = r6.read_shift(2);
  return r6.l += 12, [e, t, n];
}
function Vg(r6, e, t) {
  var n = r6.read_shift(1) >>> 5 & 3;
  r6.l += t && t.biff == 2 ? 3 : 4;
  var i = r6.read_shift(t && t.biff == 2 ? 1 : 2);
  return [n, i];
}
function Gg(r6, e, t) {
  var n = r6.read_shift(1) >>> 5 & 3, i = r6.read_shift(t && t.biff == 2 ? 1 : 2);
  return [n, i];
}
function Xg(r6, e, t) {
  var n = r6.read_shift(1) >>> 5 & 3;
  return r6.l += 4, t.biff < 8 && r6.l--, t.biff == 12 && (r6.l += 2), [n];
}
function Yg(r6, e, t) {
  var n = (r6[r6.l++] & 96) >> 5, i = r6.read_shift(2), a = 4;
  if (t) switch (t.biff) {
    case 5:
      a = 15;
      break;
    case 12:
      a = 6;
      break;
  }
  return r6.l += a, [n, i];
}
var $g = wi;
var Kg = wi;
var Jg = wi;
function ko(r6, e, t) {
  return r6.l += 2, [hg(r6)];
}
function Zl(r6) {
  return r6.l += 6, [];
}
var Zg = ko;
var Qg = Zl;
var ev = Zl;
var tv = ko;
function h1(r6) {
  return r6.l += 2, [Wu(r6), r6.read_shift(2) & 1];
}
var rv = ko;
var nv = h1;
var iv = Zl;
var av = ko;
var sv = ko;
var ov = ["Data", "All", "Headers", "??", "?Data2", "??", "?DataHeaders", "??", "Totals", "??", "??", "??", "?DataTotals", "??", "??", "??", "?Current"];
function fv(r6) {
  r6.l += 2;
  var e = r6.read_shift(2), t = r6.read_shift(2), n = r6.read_shift(4), i = r6.read_shift(2), a = r6.read_shift(2), s = ov[t >> 2 & 31];
  return {
    ixti: e,
    coltype: t & 3,
    rt: s,
    idx: n,
    c: i,
    C: a
  };
}
function lv(r6) {
  return r6.l += 2, [r6.read_shift(4)];
}
function hv(r6, e, t) {
  return r6.l += 5, r6.l += 2, r6.l += t.biff == 2 ? 1 : 4, ["PTGSHEET"];
}
function cv(r6, e, t) {
  return r6.l += t.biff == 2 ? 4 : 5, ["PTGENDSHEET"];
}
function uv(r6) {
  var e = r6.read_shift(1) >>> 5 & 3, t = r6.read_shift(2);
  return [e, t];
}
function dv(r6) {
  var e = r6.read_shift(1) >>> 5 & 3, t = r6.read_shift(2);
  return [e, t];
}
function pv(r6) {
  return r6.l += 4, [0, 0];
}
var vc = {
  /*::[*/
  1: {
    n: "PtgExp",
    f: Dg
  },
  /*::[*/
  2: {
    n: "PtgTbl",
    f: Jg
  },
  /*::[*/
  3: {
    n: "PtgAdd",
    f: _r
  },
  /*::[*/
  4: {
    n: "PtgSub",
    f: _r
  },
  /*::[*/
  5: {
    n: "PtgMul",
    f: _r
  },
  /*::[*/
  6: {
    n: "PtgDiv",
    f: _r
  },
  /*::[*/
  7: {
    n: "PtgPower",
    f: _r
  },
  /*::[*/
  8: {
    n: "PtgConcat",
    f: _r
  },
  /*::[*/
  9: {
    n: "PtgLt",
    f: _r
  },
  /*::[*/
  10: {
    n: "PtgLe",
    f: _r
  },
  /*::[*/
  11: {
    n: "PtgEq",
    f: _r
  },
  /*::[*/
  12: {
    n: "PtgGe",
    f: _r
  },
  /*::[*/
  13: {
    n: "PtgGt",
    f: _r
  },
  /*::[*/
  14: {
    n: "PtgNe",
    f: _r
  },
  /*::[*/
  15: {
    n: "PtgIsect",
    f: _r
  },
  /*::[*/
  16: {
    n: "PtgUnion",
    f: _r
  },
  /*::[*/
  17: {
    n: "PtgRange",
    f: _r
  },
  /*::[*/
  18: {
    n: "PtgUplus",
    f: _r
  },
  /*::[*/
  19: {
    n: "PtgUminus",
    f: _r
  },
  /*::[*/
  20: {
    n: "PtgPercent",
    f: _r
  },
  /*::[*/
  21: {
    n: "PtgParen",
    f: _r
  },
  /*::[*/
  22: {
    n: "PtgMissArg",
    f: _r
  },
  /*::[*/
  23: {
    n: "PtgStr",
    f: Bg
  },
  /*::[*/
  26: {
    n: "PtgSheet",
    f: hv
  },
  /*::[*/
  27: {
    n: "PtgEndSheet",
    f: cv
  },
  /*::[*/
  28: {
    n: "PtgErr",
    f: Og
  },
  /*::[*/
  29: {
    n: "PtgBool",
    f: Rg
  },
  /*::[*/
  30: {
    n: "PtgInt",
    f: Ig
  },
  /*::[*/
  31: {
    n: "PtgNum",
    f: Mg
  },
  /*::[*/
  32: {
    n: "PtgArray",
    f: xg
  },
  /*::[*/
  33: {
    n: "PtgFunc",
    f: Lg
  },
  /*::[*/
  34: {
    n: "PtgFuncVar",
    f: Cg
  },
  /*::[*/
  35: {
    n: "PtgName",
    f: Hg
  },
  /*::[*/
  36: {
    n: "PtgRef",
    f: Eg
  },
  /*::[*/
  37: {
    n: "PtgArea",
    f: dg
  },
  /*::[*/
  38: {
    n: "PtgMemArea",
    f: Vg
  },
  /*::[*/
  39: {
    n: "PtgMemErr",
    f: $g
  },
  /*::[*/
  40: {
    n: "PtgMemNoMem",
    f: Kg
  },
  /*::[*/
  41: {
    n: "PtgMemFunc",
    f: Gg
  },
  /*::[*/
  42: {
    n: "PtgRefErr",
    f: Xg
  },
  /*::[*/
  43: {
    n: "PtgAreaErr",
    f: gg
  },
  /*::[*/
  44: {
    n: "PtgRefN",
    f: Ng
  },
  /*::[*/
  45: {
    n: "PtgAreaN",
    f: mg
  },
  /*::[*/
  46: {
    n: "PtgMemAreaN",
    f: uv
  },
  /*::[*/
  47: {
    n: "PtgMemNoMemN",
    f: dv
  },
  /*::[*/
  57: {
    n: "PtgNameX",
    f: Wg
  },
  /*::[*/
  58: {
    n: "PtgRef3d",
    f: Fg
  },
  /*::[*/
  59: {
    n: "PtgArea3d",
    f: pg
  },
  /*::[*/
  60: {
    n: "PtgRefErr3d",
    f: Yg
  },
  /*::[*/
  61: {
    n: "PtgAreaErr3d",
    f: vg
  },
  /*::[*/
  255: {}
};
var gv = {
  /*::[*/
  64: 32,
  /*::[*/
  96: 32,
  /*::[*/
  65: 33,
  /*::[*/
  97: 33,
  /*::[*/
  66: 34,
  /*::[*/
  98: 34,
  /*::[*/
  67: 35,
  /*::[*/
  99: 35,
  /*::[*/
  68: 36,
  /*::[*/
  100: 36,
  /*::[*/
  69: 37,
  /*::[*/
  101: 37,
  /*::[*/
  70: 38,
  /*::[*/
  102: 38,
  /*::[*/
  71: 39,
  /*::[*/
  103: 39,
  /*::[*/
  72: 40,
  /*::[*/
  104: 40,
  /*::[*/
  73: 41,
  /*::[*/
  105: 41,
  /*::[*/
  74: 42,
  /*::[*/
  106: 42,
  /*::[*/
  75: 43,
  /*::[*/
  107: 43,
  /*::[*/
  76: 44,
  /*::[*/
  108: 44,
  /*::[*/
  77: 45,
  /*::[*/
  109: 45,
  /*::[*/
  78: 46,
  /*::[*/
  110: 46,
  /*::[*/
  79: 47,
  /*::[*/
  111: 47,
  /*::[*/
  88: 34,
  /*::[*/
  120: 34,
  /*::[*/
  89: 57,
  /*::[*/
  121: 57,
  /*::[*/
  90: 58,
  /*::[*/
  122: 58,
  /*::[*/
  91: 59,
  /*::[*/
  123: 59,
  /*::[*/
  92: 60,
  /*::[*/
  124: 60,
  /*::[*/
  93: 61,
  /*::[*/
  125: 61
};
var vv = {
  /*::[*/
  1: {
    n: "PtgElfLel",
    f: h1
  },
  /*::[*/
  2: {
    n: "PtgElfRw",
    f: av
  },
  /*::[*/
  3: {
    n: "PtgElfCol",
    f: Zg
  },
  /*::[*/
  6: {
    n: "PtgElfRwV",
    f: sv
  },
  /*::[*/
  7: {
    n: "PtgElfColV",
    f: tv
  },
  /*::[*/
  10: {
    n: "PtgElfRadical",
    f: rv
  },
  /*::[*/
  11: {
    n: "PtgElfRadicalS",
    f: iv
  },
  /*::[*/
  13: {
    n: "PtgElfColS",
    f: Qg
  },
  /*::[*/
  15: {
    n: "PtgElfColSV",
    f: ev
  },
  /*::[*/
  16: {
    n: "PtgElfRadicalLel",
    f: nv
  },
  /*::[*/
  25: {
    n: "PtgList",
    f: fv
  },
  /*::[*/
  29: {
    n: "PtgSxName",
    f: lv
  },
  /*::[*/
  255: {}
};
var mv = {
  /*::[*/
  0: {
    n: "PtgAttrNoop",
    f: pv
  },
  /*::[*/
  1: {
    n: "PtgAttrSemi",
    f: Ag
  },
  /*::[*/
  2: {
    n: "PtgAttrIf",
    f: _g
  },
  /*::[*/
  4: {
    n: "PtgAttrChoose",
    f: wg
  },
  /*::[*/
  8: {
    n: "PtgAttrGoto",
    f: yg
  },
  /*::[*/
  16: {
    n: "PtgAttrSum",
    f: kg
  },
  /*::[*/
  32: {
    n: "PtgAttrBaxcel",
    f: gc
  },
  /*::[*/
  33: {
    n: "PtgAttrBaxcel",
    f: gc
  },
  /*::[*/
  64: {
    n: "PtgAttrSpace",
    f: bg
  },
  /*::[*/
  65: {
    n: "PtgAttrSpaceSemi",
    f: Tg
  },
  /*::[*/
  128: {
    n: "PtgAttrIfError",
    f: Sg
  },
  /*::[*/
  255: {}
};
function xv(r6, e, t, n) {
  if (n.biff < 8) return wi(r6, e);
  for (var i = r6.l + e, a = [], s = 0; s !== t.length; ++s) switch (t[s][0]) {
    case "PtgArray":
      t[s][1] = qg(r6, 0, n), a.push(t[s][1]);
      break;
    case "PtgMemArea":
      t[s][2] = Ug(r6, t[s][1], n), a.push(t[s][2]);
      break;
    case "PtgExp":
      n && n.biff == 12 && (t[s][1][1] = r6.read_shift(4), a.push(t[s][1]));
      break;
    case "PtgList":
    case "PtgElfRadicalS":
    case "PtgElfColS":
    case "PtgElfColSV":
      throw "Unsupported " + t[s][0];
  }
  return e = i - r6.l, e !== 0 && a.push(wi(r6, e)), a;
}
function wv(r6, e, t) {
  for (var n = r6.l + e, i, a, s = []; n != r6.l; ) e = n - r6.l, a = r6[r6.l], i = vc[a] || vc[gv[a]], (a === 24 || a === 25) && (i = (a === 24 ? vv : mv)[r6[r6.l + 1]]), !i || !i.f ? wi(r6, e) : s.push([i.n, i.f(r6, e, t)]);
  return s;
}
function yv(r6) {
  for (var e = [], t = 0; t < r6.length; ++t) {
    for (var n = r6[t], i = [], a = 0; a < n.length; ++a) {
      var s = n[a];
      if (s) switch (s[0]) {
        case 2:
          i.push('"' + s[1].replace(/"/g, '""') + '"');
          break;
        default:
          i.push(s[1]);
      }
      else i.push("");
    }
    e.push(i.join(","));
  }
  return e.join(";");
}
var _v = {
  PtgAdd: "+",
  PtgConcat: "&",
  PtgDiv: "/",
  PtgEq: "=",
  PtgGe: ">=",
  PtgGt: ">",
  PtgLe: "<=",
  PtgLt: "<",
  PtgMul: "*",
  PtgNe: "<>",
  PtgPower: "^",
  PtgSub: "-"
};
function Sv(r6, e) {
  if (!r6 && !(e && e.biff <= 5 && e.biff >= 2)) throw new Error("empty sheet name");
  return /[^\w\u4E00-\u9FFF\u3040-\u30FF]/.test(r6) ? "'" + r6 + "'" : r6;
}
function c1(r6, e, t) {
  if (!r6) return "SH33TJSERR0";
  if (t.biff > 8 && (!r6.XTI || !r6.XTI[e])) return r6.SheetNames[e];
  if (!r6.XTI) return "SH33TJSERR6";
  var n = r6.XTI[e];
  if (t.biff < 8) return e > 1e4 && (e -= 65536), e < 0 && (e = -e), e == 0 ? "" : r6.XTI[e - 1];
  if (!n) return "SH33TJSERR1";
  var i = "";
  if (t.biff > 8) switch (r6[n[0]][0]) {
    case 357:
      return i = n[1] == -1 ? "#REF" : r6.SheetNames[n[1]], n[1] == n[2] ? i : i + ":" + r6.SheetNames[n[2]];
    case 358:
      return t.SID != null ? r6.SheetNames[t.SID] : "SH33TJSSAME" + r6[n[0]][0];
    case 355:
    default:
      return "SH33TJSSRC" + r6[n[0]][0];
  }
  switch (r6[n[0]][0][0]) {
    case 1025:
      return i = n[1] == -1 ? "#REF" : r6.SheetNames[n[1]] || "SH33TJSERR3", n[1] == n[2] ? i : i + ":" + r6.SheetNames[n[2]];
    case 14849:
      return r6[n[0]].slice(1).map(function(a) {
        return a.Name;
      }).join(";;");
    default:
      return r6[n[0]][0][3] ? (i = n[1] == -1 ? "#REF" : r6[n[0]][0][3][n[1]] || "SH33TJSERR4", n[1] == n[2] ? i : i + ":" + r6[n[0]][0][3][n[2]]) : "SH33TJSERR2";
  }
}
function mc(r6, e, t) {
  var n = c1(r6, e, t);
  return n == "#REF" ? n : Sv(n, t);
}
function Ns(r6, e, t, n, i) {
  var a = i && i.biff || 8, s = (
    /*range != null ? range :*/
    {
      s: {
        c: 0,
        r: 0
      },
      e: {
        c: 0,
        r: 0
      }
    }
  ), o = [], f, h, c, p = 0, v = 0, d, w = "";
  if (!r6[0] || !r6[0][0]) return "";
  for (var x = -1, S = "", A = 0, b = r6[0].length; A < b; ++A) {
    var O = r6[0][A];
    switch (O[0]) {
      case "PtgUminus":
        o.push("-" + o.pop());
        break;
      case "PtgUplus":
        o.push("+" + o.pop());
        break;
      case "PtgPercent":
        o.push(o.pop() + "%");
        break;
      case "PtgAdd":
      case "PtgConcat":
      case "PtgDiv":
      case "PtgEq":
      case "PtgGe":
      case "PtgGt":
      case "PtgLe":
      case "PtgLt":
      case "PtgMul":
      case "PtgNe":
      case "PtgPower":
      case "PtgSub":
        if (f = o.pop(), h = o.pop(), x >= 0) {
          switch (r6[0][x][1][0]) {
            case 0:
              S = fr(" ", r6[0][x][1][1]);
              break;
            case 1:
              S = fr("\r", r6[0][x][1][1]);
              break;
            default:
              if (S = "", i.WTF) throw new Error("Unexpected PtgAttrSpaceType " + r6[0][x][1][0]);
          }
          h = h + S, x = -1;
        }
        o.push(h + _v[O[0]] + f);
        break;
      case "PtgIsect":
        f = o.pop(), h = o.pop(), o.push(h + " " + f);
        break;
      case "PtgUnion":
        f = o.pop(), h = o.pop(), o.push(h + "," + f);
        break;
      case "PtgRange":
        f = o.pop(), h = o.pop(), o.push(h + ":" + f);
        break;
      case "PtgAttrChoose":
        break;
      case "PtgAttrGoto":
        break;
      case "PtgAttrIf":
        break;
      case "PtgAttrIfError":
        break;
      case "PtgRef":
        c = vo(O[1][1], s, i), o.push(mo(c, a));
        break;
      case "PtgRefN":
        c = t ? vo(O[1][1], t, i) : O[1][1], o.push(mo(c, a));
        break;
      case "PtgRef3d":
        p = /*::Number(*/
        O[1][1], c = vo(O[1][2], s, i), w = mc(n, p, i), o.push(w + "!" + mo(c, a));
        break;
      case "PtgFunc":
      case "PtgFuncVar":
        var q = O[1][0], te = O[1][1];
        q || (q = 0), q &= 127;
        var le = q == 0 ? [] : o.slice(-q);
        o.length -= q, te === "User" && (te = le.shift()), o.push(te + "(" + le.join(",") + ")");
        break;
      case "PtgBool":
        o.push(O[1] ? "TRUE" : "FALSE");
        break;
      case "PtgInt":
        o.push(
          /*::String(*/
          O[1]
          /*::)*/
        );
        break;
      case "PtgNum":
        o.push(String(O[1]));
        break;
      case "PtgStr":
        o.push('"' + O[1].replace(/"/g, '""') + '"');
        break;
      case "PtgErr":
        o.push(
          /*::String(*/
          O[1]
          /*::)*/
        );
        break;
      case "PtgAreaN":
        d = tc(O[1][1], t ? {
          s: t
        } : s, i), o.push(Zf(d, i));
        break;
      case "PtgArea":
        d = tc(O[1][1], s, i), o.push(Zf(d, i));
        break;
      case "PtgArea3d":
        p = /*::Number(*/
        O[1][1], d = O[1][2], w = mc(n, p, i), o.push(w + "!" + Zf(d, i));
        break;
      case "PtgAttrSum":
        o.push("SUM(" + o.pop() + ")");
        break;
      case "PtgAttrBaxcel":
      case "PtgAttrSemi":
        break;
      case "PtgName":
        v = O[1][2];
        var j = (n.names || [])[v - 1] || (n[0] || [])[v], M = j ? j.Name : "SH33TJSNAME" + String(v);
        M && M.slice(0, 6) == "_xlfn." && !i.xlfn && (M = M.slice(6)), o.push(M);
        break;
      case "PtgNameX":
        var H = O[1][1];
        v = O[1][2];
        var ee;
        if (i.biff <= 5) H < 0 && (H = -H), n[H] && (ee = n[H][v]);
        else {
          var F = "";
          if (((n[H] || [])[0] || [])[0] == 14849 || (((n[H] || [])[0] || [])[0] == 1025 ? n[H][v] && n[H][v].itab > 0 && (F = n.SheetNames[n[H][v].itab - 1] + "!") : F = n.SheetNames[v - 1] + "!"), n[H] && n[H][v]) F += n[H][v].Name;
          else if (n[0] && n[0][v]) F += n[0][v].Name;
          else {
            var P = (c1(n, H, i) || "").split(";;");
            P[v - 1] ? F = P[v - 1] : F += "SH33TJSERRX";
          }
          o.push(F);
          break;
        }
        ee || (ee = {
          Name: "SH33TJSERRY"
        }), o.push(ee.Name);
        break;
      case "PtgParen":
        var Y = "(", Q = ")";
        if (x >= 0) {
          switch (S = "", r6[0][x][1][0]) {
            case 2:
              Y = fr(" ", r6[0][x][1][1]) + Y;
              break;
            case 3:
              Y = fr("\r", r6[0][x][1][1]) + Y;
              break;
            case 4:
              Q = fr(" ", r6[0][x][1][1]) + Q;
              break;
            case 5:
              Q = fr("\r", r6[0][x][1][1]) + Q;
              break;
            default:
              if (i.WTF) throw new Error("Unexpected PtgAttrSpaceType " + r6[0][x][1][0]);
          }
          x = -1;
        }
        o.push(Y + o.pop() + Q);
        break;
      case "PtgRefErr":
        o.push("#REF!");
        break;
      case "PtgRefErr3d":
        o.push("#REF!");
        break;
      case "PtgExp":
        c = {
          c: O[1][1],
          r: O[1][0]
        };
        var ce = {
          c: t.c,
          r: t.r
        };
        if (n.sharedf[zt(c)]) {
          var we = n.sharedf[zt(c)];
          o.push(Ns(we, s, ce, n, i));
        } else {
          var Se = false;
          for (f = 0; f != n.arrayf.length; ++f) if (h = n.arrayf[f], !(c.c < h[0].s.c || c.c > h[0].e.c) && !(c.r < h[0].s.r || c.r > h[0].e.r)) {
            o.push(Ns(h[1], s, ce, n, i)), Se = true;
            break;
          }
          Se || o.push(
            /*::String(*/
            O[1]
            /*::)*/
          );
        }
        break;
      case "PtgArray":
        o.push("{" + yv(
          /*::(*/
          O[1]
          /*:: :any)*/
        ) + "}");
        break;
      case "PtgMemArea":
        break;
      case "PtgAttrSpace":
      case "PtgAttrSpaceSemi":
        x = A;
        break;
      case "PtgTbl":
        break;
      case "PtgMemErr":
        break;
      case "PtgMissArg":
        o.push("");
        break;
      case "PtgAreaErr":
        o.push("#REF!");
        break;
      case "PtgAreaErr3d":
        o.push("#REF!");
        break;
      case "PtgList":
        o.push("Table" + O[1].idx + "[#" + O[1].rt + "]");
        break;
      case "PtgMemAreaN":
      case "PtgMemNoMemN":
      case "PtgAttrNoop":
      case "PtgSheet":
      case "PtgEndSheet":
        break;
      case "PtgMemFunc":
        break;
      case "PtgMemNoMem":
        break;
      case "PtgElfCol":
      case "PtgElfColS":
      case "PtgElfColSV":
      case "PtgElfColV":
      case "PtgElfLel":
      case "PtgElfRadical":
      case "PtgElfRadicalLel":
      case "PtgElfRadicalS":
      case "PtgElfRw":
      case "PtgElfRwV":
        throw new Error("Unsupported ELFs");
      case "PtgSxName":
        throw new Error("Unrecognized Formula Token: " + String(O));
      default:
        throw new Error("Unrecognized Formula Token: " + String(O));
    }
    var de = ["PtgAttrSpace", "PtgAttrSpaceSemi", "PtgAttrGoto"];
    if (i.biff != 3 && x >= 0 && de.indexOf(r6[0][A][0]) == -1) {
      O = r6[0][x];
      var Ae = true;
      switch (O[1][0]) {
        case 4:
          Ae = false;
        case 0:
          S = fr(" ", O[1][1]);
          break;
        case 5:
          Ae = false;
        case 1:
          S = fr("\r", O[1][1]);
          break;
        default:
          if (S = "", i.WTF) throw new Error("Unexpected PtgAttrSpaceType " + O[1][0]);
      }
      o.push((Ae ? S : "") + o.pop() + (Ae ? "" : S)), x = -1;
    }
  }
  if (o.length > 1 && i.WTF) throw new Error("bad formula stack");
  return o[0];
}
function Av(r6) {
  if (r6 == null) {
    var e = Le(8);
    return e.write_shift(1, 3), e.write_shift(1, 0), e.write_shift(2, 0), e.write_shift(2, 0), e.write_shift(2, 65535), e;
  } else if (typeof r6 == "number") return ka(r6);
  return ka(0);
}
function bv(r6, e, t, n, i) {
  var a = Da(e, t, i), s = Av(r6.v), o = Le(6), f = 33;
  o.write_shift(2, f), o.write_shift(4, 0);
  for (var h = Le(r6.bf.length), c = 0; c < r6.bf.length; ++c) h[c] = r6.bf[c];
  var p = jr([a, s, o, h]);
  return p;
}
function of(r6, e, t) {
  var n = r6.read_shift(4), i = wv(r6, n, t), a = r6.read_shift(4), s = a > 0 ? xv(r6, a, i, t) : null;
  return [i, s];
}
var Tv = of;
var ff = of;
var Ev = of;
var Nv = of;
var Fv = {
  0: "BEEP",
  1: "OPEN",
  2: "OPEN.LINKS",
  3: "CLOSE.ALL",
  4: "SAVE",
  5: "SAVE.AS",
  6: "FILE.DELETE",
  7: "PAGE.SETUP",
  8: "PRINT",
  9: "PRINTER.SETUP",
  10: "QUIT",
  11: "NEW.WINDOW",
  12: "ARRANGE.ALL",
  13: "WINDOW.SIZE",
  14: "WINDOW.MOVE",
  15: "FULL",
  16: "CLOSE",
  17: "RUN",
  22: "SET.PRINT.AREA",
  23: "SET.PRINT.TITLES",
  24: "SET.PAGE.BREAK",
  25: "REMOVE.PAGE.BREAK",
  26: "FONT",
  27: "DISPLAY",
  28: "PROTECT.DOCUMENT",
  29: "PRECISION",
  30: "A1.R1C1",
  31: "CALCULATE.NOW",
  32: "CALCULATION",
  34: "DATA.FIND",
  35: "EXTRACT",
  36: "DATA.DELETE",
  37: "SET.DATABASE",
  38: "SET.CRITERIA",
  39: "SORT",
  40: "DATA.SERIES",
  41: "TABLE",
  42: "FORMAT.NUMBER",
  43: "ALIGNMENT",
  44: "STYLE",
  45: "BORDER",
  46: "CELL.PROTECTION",
  47: "COLUMN.WIDTH",
  48: "UNDO",
  49: "CUT",
  50: "COPY",
  51: "PASTE",
  52: "CLEAR",
  53: "PASTE.SPECIAL",
  54: "EDIT.DELETE",
  55: "INSERT",
  56: "FILL.RIGHT",
  57: "FILL.DOWN",
  61: "DEFINE.NAME",
  62: "CREATE.NAMES",
  63: "FORMULA.GOTO",
  64: "FORMULA.FIND",
  65: "SELECT.LAST.CELL",
  66: "SHOW.ACTIVE.CELL",
  67: "GALLERY.AREA",
  68: "GALLERY.BAR",
  69: "GALLERY.COLUMN",
  70: "GALLERY.LINE",
  71: "GALLERY.PIE",
  72: "GALLERY.SCATTER",
  73: "COMBINATION",
  74: "PREFERRED",
  75: "ADD.OVERLAY",
  76: "GRIDLINES",
  77: "SET.PREFERRED",
  78: "AXES",
  79: "LEGEND",
  80: "ATTACH.TEXT",
  81: "ADD.ARROW",
  82: "SELECT.CHART",
  83: "SELECT.PLOT.AREA",
  84: "PATTERNS",
  85: "MAIN.CHART",
  86: "OVERLAY",
  87: "SCALE",
  88: "FORMAT.LEGEND",
  89: "FORMAT.TEXT",
  90: "EDIT.REPEAT",
  91: "PARSE",
  92: "JUSTIFY",
  93: "HIDE",
  94: "UNHIDE",
  95: "WORKSPACE",
  96: "FORMULA",
  97: "FORMULA.FILL",
  98: "FORMULA.ARRAY",
  99: "DATA.FIND.NEXT",
  100: "DATA.FIND.PREV",
  101: "FORMULA.FIND.NEXT",
  102: "FORMULA.FIND.PREV",
  103: "ACTIVATE",
  104: "ACTIVATE.NEXT",
  105: "ACTIVATE.PREV",
  106: "UNLOCKED.NEXT",
  107: "UNLOCKED.PREV",
  108: "COPY.PICTURE",
  109: "SELECT",
  110: "DELETE.NAME",
  111: "DELETE.FORMAT",
  112: "VLINE",
  113: "HLINE",
  114: "VPAGE",
  115: "HPAGE",
  116: "VSCROLL",
  117: "HSCROLL",
  118: "ALERT",
  119: "NEW",
  120: "CANCEL.COPY",
  121: "SHOW.CLIPBOARD",
  122: "MESSAGE",
  124: "PASTE.LINK",
  125: "APP.ACTIVATE",
  126: "DELETE.ARROW",
  127: "ROW.HEIGHT",
  128: "FORMAT.MOVE",
  129: "FORMAT.SIZE",
  130: "FORMULA.REPLACE",
  131: "SEND.KEYS",
  132: "SELECT.SPECIAL",
  133: "APPLY.NAMES",
  134: "REPLACE.FONT",
  135: "FREEZE.PANES",
  136: "SHOW.INFO",
  137: "SPLIT",
  138: "ON.WINDOW",
  139: "ON.DATA",
  140: "DISABLE.INPUT",
  142: "OUTLINE",
  143: "LIST.NAMES",
  144: "FILE.CLOSE",
  145: "SAVE.WORKBOOK",
  146: "DATA.FORM",
  147: "COPY.CHART",
  148: "ON.TIME",
  149: "WAIT",
  150: "FORMAT.FONT",
  151: "FILL.UP",
  152: "FILL.LEFT",
  153: "DELETE.OVERLAY",
  155: "SHORT.MENUS",
  159: "SET.UPDATE.STATUS",
  161: "COLOR.PALETTE",
  162: "DELETE.STYLE",
  163: "WINDOW.RESTORE",
  164: "WINDOW.MAXIMIZE",
  166: "CHANGE.LINK",
  167: "CALCULATE.DOCUMENT",
  168: "ON.KEY",
  169: "APP.RESTORE",
  170: "APP.MOVE",
  171: "APP.SIZE",
  172: "APP.MINIMIZE",
  173: "APP.MAXIMIZE",
  174: "BRING.TO.FRONT",
  175: "SEND.TO.BACK",
  185: "MAIN.CHART.TYPE",
  186: "OVERLAY.CHART.TYPE",
  187: "SELECT.END",
  188: "OPEN.MAIL",
  189: "SEND.MAIL",
  190: "STANDARD.FONT",
  191: "CONSOLIDATE",
  192: "SORT.SPECIAL",
  193: "GALLERY.3D.AREA",
  194: "GALLERY.3D.COLUMN",
  195: "GALLERY.3D.LINE",
  196: "GALLERY.3D.PIE",
  197: "VIEW.3D",
  198: "GOAL.SEEK",
  199: "WORKGROUP",
  200: "FILL.GROUP",
  201: "UPDATE.LINK",
  202: "PROMOTE",
  203: "DEMOTE",
  204: "SHOW.DETAIL",
  206: "UNGROUP",
  207: "OBJECT.PROPERTIES",
  208: "SAVE.NEW.OBJECT",
  209: "SHARE",
  210: "SHARE.NAME",
  211: "DUPLICATE",
  212: "APPLY.STYLE",
  213: "ASSIGN.TO.OBJECT",
  214: "OBJECT.PROTECTION",
  215: "HIDE.OBJECT",
  216: "SET.EXTRACT",
  217: "CREATE.PUBLISHER",
  218: "SUBSCRIBE.TO",
  219: "ATTRIBUTES",
  220: "SHOW.TOOLBAR",
  222: "PRINT.PREVIEW",
  223: "EDIT.COLOR",
  224: "SHOW.LEVELS",
  225: "FORMAT.MAIN",
  226: "FORMAT.OVERLAY",
  227: "ON.RECALC",
  228: "EDIT.SERIES",
  229: "DEFINE.STYLE",
  240: "LINE.PRINT",
  243: "ENTER.DATA",
  249: "GALLERY.RADAR",
  250: "MERGE.STYLES",
  251: "EDITION.OPTIONS",
  252: "PASTE.PICTURE",
  253: "PASTE.PICTURE.LINK",
  254: "SPELLING",
  256: "ZOOM",
  259: "INSERT.OBJECT",
  260: "WINDOW.MINIMIZE",
  265: "SOUND.NOTE",
  266: "SOUND.PLAY",
  267: "FORMAT.SHAPE",
  268: "EXTEND.POLYGON",
  269: "FORMAT.AUTO",
  272: "GALLERY.3D.BAR",
  273: "GALLERY.3D.SURFACE",
  274: "FILL.AUTO",
  276: "CUSTOMIZE.TOOLBAR",
  277: "ADD.TOOL",
  278: "EDIT.OBJECT",
  279: "ON.DOUBLECLICK",
  280: "ON.ENTRY",
  281: "WORKBOOK.ADD",
  282: "WORKBOOK.MOVE",
  283: "WORKBOOK.COPY",
  284: "WORKBOOK.OPTIONS",
  285: "SAVE.WORKSPACE",
  288: "CHART.WIZARD",
  289: "DELETE.TOOL",
  290: "MOVE.TOOL",
  291: "WORKBOOK.SELECT",
  292: "WORKBOOK.ACTIVATE",
  293: "ASSIGN.TO.TOOL",
  295: "COPY.TOOL",
  296: "RESET.TOOL",
  297: "CONSTRAIN.NUMERIC",
  298: "PASTE.TOOL",
  302: "WORKBOOK.NEW",
  305: "SCENARIO.CELLS",
  306: "SCENARIO.DELETE",
  307: "SCENARIO.ADD",
  308: "SCENARIO.EDIT",
  309: "SCENARIO.SHOW",
  310: "SCENARIO.SHOW.NEXT",
  311: "SCENARIO.SUMMARY",
  312: "PIVOT.TABLE.WIZARD",
  313: "PIVOT.FIELD.PROPERTIES",
  314: "PIVOT.FIELD",
  315: "PIVOT.ITEM",
  316: "PIVOT.ADD.FIELDS",
  318: "OPTIONS.CALCULATION",
  319: "OPTIONS.EDIT",
  320: "OPTIONS.VIEW",
  321: "ADDIN.MANAGER",
  322: "MENU.EDITOR",
  323: "ATTACH.TOOLBARS",
  324: "VBAActivate",
  325: "OPTIONS.CHART",
  328: "VBA.INSERT.FILE",
  330: "VBA.PROCEDURE.DEFINITION",
  336: "ROUTING.SLIP",
  338: "ROUTE.DOCUMENT",
  339: "MAIL.LOGON",
  342: "INSERT.PICTURE",
  343: "EDIT.TOOL",
  344: "GALLERY.DOUGHNUT",
  350: "CHART.TREND",
  352: "PIVOT.ITEM.PROPERTIES",
  354: "WORKBOOK.INSERT",
  355: "OPTIONS.TRANSITION",
  356: "OPTIONS.GENERAL",
  370: "FILTER.ADVANCED",
  373: "MAIL.ADD.MAILER",
  374: "MAIL.DELETE.MAILER",
  375: "MAIL.REPLY",
  376: "MAIL.REPLY.ALL",
  377: "MAIL.FORWARD",
  378: "MAIL.NEXT.LETTER",
  379: "DATA.LABEL",
  380: "INSERT.TITLE",
  381: "FONT.PROPERTIES",
  382: "MACRO.OPTIONS",
  383: "WORKBOOK.HIDE",
  384: "WORKBOOK.UNHIDE",
  385: "WORKBOOK.DELETE",
  386: "WORKBOOK.NAME",
  388: "GALLERY.CUSTOM",
  390: "ADD.CHART.AUTOFORMAT",
  391: "DELETE.CHART.AUTOFORMAT",
  392: "CHART.ADD.DATA",
  393: "AUTO.OUTLINE",
  394: "TAB.ORDER",
  395: "SHOW.DIALOG",
  396: "SELECT.ALL",
  397: "UNGROUP.SHEETS",
  398: "SUBTOTAL.CREATE",
  399: "SUBTOTAL.REMOVE",
  400: "RENAME.OBJECT",
  412: "WORKBOOK.SCROLL",
  413: "WORKBOOK.NEXT",
  414: "WORKBOOK.PREV",
  415: "WORKBOOK.TAB.SPLIT",
  416: "FULL.SCREEN",
  417: "WORKBOOK.PROTECT",
  420: "SCROLLBAR.PROPERTIES",
  421: "PIVOT.SHOW.PAGES",
  422: "TEXT.TO.COLUMNS",
  423: "FORMAT.CHARTTYPE",
  424: "LINK.FORMAT",
  425: "TRACER.DISPLAY",
  430: "TRACER.NAVIGATE",
  431: "TRACER.CLEAR",
  432: "TRACER.ERROR",
  433: "PIVOT.FIELD.GROUP",
  434: "PIVOT.FIELD.UNGROUP",
  435: "CHECKBOX.PROPERTIES",
  436: "LABEL.PROPERTIES",
  437: "LISTBOX.PROPERTIES",
  438: "EDITBOX.PROPERTIES",
  439: "PIVOT.REFRESH",
  440: "LINK.COMBO",
  441: "OPEN.TEXT",
  442: "HIDE.DIALOG",
  443: "SET.DIALOG.FOCUS",
  444: "ENABLE.OBJECT",
  445: "PUSHBUTTON.PROPERTIES",
  446: "SET.DIALOG.DEFAULT",
  447: "FILTER",
  448: "FILTER.SHOW.ALL",
  449: "CLEAR.OUTLINE",
  450: "FUNCTION.WIZARD",
  451: "ADD.LIST.ITEM",
  452: "SET.LIST.ITEM",
  453: "REMOVE.LIST.ITEM",
  454: "SELECT.LIST.ITEM",
  455: "SET.CONTROL.VALUE",
  456: "SAVE.COPY.AS",
  458: "OPTIONS.LISTS.ADD",
  459: "OPTIONS.LISTS.DELETE",
  460: "SERIES.AXES",
  461: "SERIES.X",
  462: "SERIES.Y",
  463: "ERRORBAR.X",
  464: "ERRORBAR.Y",
  465: "FORMAT.CHART",
  466: "SERIES.ORDER",
  467: "MAIL.LOGOFF",
  468: "CLEAR.ROUTING.SLIP",
  469: "APP.ACTIVATE.MICROSOFT",
  470: "MAIL.EDIT.MAILER",
  471: "ON.SHEET",
  472: "STANDARD.WIDTH",
  473: "SCENARIO.MERGE",
  474: "SUMMARY.INFO",
  475: "FIND.FILE",
  476: "ACTIVE.CELL.FONT",
  477: "ENABLE.TIPWIZARD",
  478: "VBA.MAKE.ADDIN",
  480: "INSERTDATATABLE",
  481: "WORKGROUP.OPTIONS",
  482: "MAIL.SEND.MAILER",
  485: "AUTOCORRECT",
  489: "POST.DOCUMENT",
  491: "PICKLIST",
  493: "VIEW.SHOW",
  494: "VIEW.DEFINE",
  495: "VIEW.DELETE",
  509: "SHEET.BACKGROUND",
  510: "INSERT.MAP.OBJECT",
  511: "OPTIONS.MENONO",
  517: "MSOCHECKS",
  518: "NORMAL",
  519: "LAYOUT",
  520: "RM.PRINT.AREA",
  521: "CLEAR.PRINT.AREA",
  522: "ADD.PRINT.AREA",
  523: "MOVE.BRK",
  545: "HIDECURR.NOTE",
  546: "HIDEALL.NOTES",
  547: "DELETE.NOTE",
  548: "TRAVERSE.NOTES",
  549: "ACTIVATE.NOTES",
  620: "PROTECT.REVISIONS",
  621: "UNPROTECT.REVISIONS",
  647: "OPTIONS.ME",
  653: "WEB.PUBLISH",
  667: "NEWWEBQUERY",
  673: "PIVOT.TABLE.CHART",
  753: "OPTIONS.SAVE",
  755: "OPTIONS.SPELL",
  808: "HIDEALL.INKANNOTS"
};
var u1 = {
  0: "COUNT",
  1: "IF",
  2: "ISNA",
  3: "ISERROR",
  4: "SUM",
  5: "AVERAGE",
  6: "MIN",
  7: "MAX",
  8: "ROW",
  9: "COLUMN",
  10: "NA",
  11: "NPV",
  12: "STDEV",
  13: "DOLLAR",
  14: "FIXED",
  15: "SIN",
  16: "COS",
  17: "TAN",
  18: "ATAN",
  19: "PI",
  20: "SQRT",
  21: "EXP",
  22: "LN",
  23: "LOG10",
  24: "ABS",
  25: "INT",
  26: "SIGN",
  27: "ROUND",
  28: "LOOKUP",
  29: "INDEX",
  30: "REPT",
  31: "MID",
  32: "LEN",
  33: "VALUE",
  34: "TRUE",
  35: "FALSE",
  36: "AND",
  37: "OR",
  38: "NOT",
  39: "MOD",
  40: "DCOUNT",
  41: "DSUM",
  42: "DAVERAGE",
  43: "DMIN",
  44: "DMAX",
  45: "DSTDEV",
  46: "VAR",
  47: "DVAR",
  48: "TEXT",
  49: "LINEST",
  50: "TREND",
  51: "LOGEST",
  52: "GROWTH",
  53: "GOTO",
  54: "HALT",
  55: "RETURN",
  56: "PV",
  57: "FV",
  58: "NPER",
  59: "PMT",
  60: "RATE",
  61: "MIRR",
  62: "IRR",
  63: "RAND",
  64: "MATCH",
  65: "DATE",
  66: "TIME",
  67: "DAY",
  68: "MONTH",
  69: "YEAR",
  70: "WEEKDAY",
  71: "HOUR",
  72: "MINUTE",
  73: "SECOND",
  74: "NOW",
  75: "AREAS",
  76: "ROWS",
  77: "COLUMNS",
  78: "OFFSET",
  79: "ABSREF",
  80: "RELREF",
  81: "ARGUMENT",
  82: "SEARCH",
  83: "TRANSPOSE",
  84: "ERROR",
  85: "STEP",
  86: "TYPE",
  87: "ECHO",
  88: "SET.NAME",
  89: "CALLER",
  90: "DEREF",
  91: "WINDOWS",
  92: "SERIES",
  93: "DOCUMENTS",
  94: "ACTIVE.CELL",
  95: "SELECTION",
  96: "RESULT",
  97: "ATAN2",
  98: "ASIN",
  99: "ACOS",
  100: "CHOOSE",
  101: "HLOOKUP",
  102: "VLOOKUP",
  103: "LINKS",
  104: "INPUT",
  105: "ISREF",
  106: "GET.FORMULA",
  107: "GET.NAME",
  108: "SET.VALUE",
  109: "LOG",
  110: "EXEC",
  111: "CHAR",
  112: "LOWER",
  113: "UPPER",
  114: "PROPER",
  115: "LEFT",
  116: "RIGHT",
  117: "EXACT",
  118: "TRIM",
  119: "REPLACE",
  120: "SUBSTITUTE",
  121: "CODE",
  122: "NAMES",
  123: "DIRECTORY",
  124: "FIND",
  125: "CELL",
  126: "ISERR",
  127: "ISTEXT",
  128: "ISNUMBER",
  129: "ISBLANK",
  130: "T",
  131: "N",
  132: "FOPEN",
  133: "FCLOSE",
  134: "FSIZE",
  135: "FREADLN",
  136: "FREAD",
  137: "FWRITELN",
  138: "FWRITE",
  139: "FPOS",
  140: "DATEVALUE",
  141: "TIMEVALUE",
  142: "SLN",
  143: "SYD",
  144: "DDB",
  145: "GET.DEF",
  146: "REFTEXT",
  147: "TEXTREF",
  148: "INDIRECT",
  149: "REGISTER",
  150: "CALL",
  151: "ADD.BAR",
  152: "ADD.MENU",
  153: "ADD.COMMAND",
  154: "ENABLE.COMMAND",
  155: "CHECK.COMMAND",
  156: "RENAME.COMMAND",
  157: "SHOW.BAR",
  158: "DELETE.MENU",
  159: "DELETE.COMMAND",
  160: "GET.CHART.ITEM",
  161: "DIALOG.BOX",
  162: "CLEAN",
  163: "MDETERM",
  164: "MINVERSE",
  165: "MMULT",
  166: "FILES",
  167: "IPMT",
  168: "PPMT",
  169: "COUNTA",
  170: "CANCEL.KEY",
  171: "FOR",
  172: "WHILE",
  173: "BREAK",
  174: "NEXT",
  175: "INITIATE",
  176: "REQUEST",
  177: "POKE",
  178: "EXECUTE",
  179: "TERMINATE",
  180: "RESTART",
  181: "HELP",
  182: "GET.BAR",
  183: "PRODUCT",
  184: "FACT",
  185: "GET.CELL",
  186: "GET.WORKSPACE",
  187: "GET.WINDOW",
  188: "GET.DOCUMENT",
  189: "DPRODUCT",
  190: "ISNONTEXT",
  191: "GET.NOTE",
  192: "NOTE",
  193: "STDEVP",
  194: "VARP",
  195: "DSTDEVP",
  196: "DVARP",
  197: "TRUNC",
  198: "ISLOGICAL",
  199: "DCOUNTA",
  200: "DELETE.BAR",
  201: "UNREGISTER",
  204: "USDOLLAR",
  205: "FINDB",
  206: "SEARCHB",
  207: "REPLACEB",
  208: "LEFTB",
  209: "RIGHTB",
  210: "MIDB",
  211: "LENB",
  212: "ROUNDUP",
  213: "ROUNDDOWN",
  214: "ASC",
  215: "DBCS",
  216: "RANK",
  219: "ADDRESS",
  220: "DAYS360",
  221: "TODAY",
  222: "VDB",
  223: "ELSE",
  224: "ELSE.IF",
  225: "END.IF",
  226: "FOR.CELL",
  227: "MEDIAN",
  228: "SUMPRODUCT",
  229: "SINH",
  230: "COSH",
  231: "TANH",
  232: "ASINH",
  233: "ACOSH",
  234: "ATANH",
  235: "DGET",
  236: "CREATE.OBJECT",
  237: "VOLATILE",
  238: "LAST.ERROR",
  239: "CUSTOM.UNDO",
  240: "CUSTOM.REPEAT",
  241: "FORMULA.CONVERT",
  242: "GET.LINK.INFO",
  243: "TEXT.BOX",
  244: "INFO",
  245: "GROUP",
  246: "GET.OBJECT",
  247: "DB",
  248: "PAUSE",
  251: "RESUME",
  252: "FREQUENCY",
  253: "ADD.TOOLBAR",
  254: "DELETE.TOOLBAR",
  255: "User",
  256: "RESET.TOOLBAR",
  257: "EVALUATE",
  258: "GET.TOOLBAR",
  259: "GET.TOOL",
  260: "SPELLING.CHECK",
  261: "ERROR.TYPE",
  262: "APP.TITLE",
  263: "WINDOW.TITLE",
  264: "SAVE.TOOLBAR",
  265: "ENABLE.TOOL",
  266: "PRESS.TOOL",
  267: "REGISTER.ID",
  268: "GET.WORKBOOK",
  269: "AVEDEV",
  270: "BETADIST",
  271: "GAMMALN",
  272: "BETAINV",
  273: "BINOMDIST",
  274: "CHIDIST",
  275: "CHIINV",
  276: "COMBIN",
  277: "CONFIDENCE",
  278: "CRITBINOM",
  279: "EVEN",
  280: "EXPONDIST",
  281: "FDIST",
  282: "FINV",
  283: "FISHER",
  284: "FISHERINV",
  285: "FLOOR",
  286: "GAMMADIST",
  287: "GAMMAINV",
  288: "CEILING",
  289: "HYPGEOMDIST",
  290: "LOGNORMDIST",
  291: "LOGINV",
  292: "NEGBINOMDIST",
  293: "NORMDIST",
  294: "NORMSDIST",
  295: "NORMINV",
  296: "NORMSINV",
  297: "STANDARDIZE",
  298: "ODD",
  299: "PERMUT",
  300: "POISSON",
  301: "TDIST",
  302: "WEIBULL",
  303: "SUMXMY2",
  304: "SUMX2MY2",
  305: "SUMX2PY2",
  306: "CHITEST",
  307: "CORREL",
  308: "COVAR",
  309: "FORECAST",
  310: "FTEST",
  311: "INTERCEPT",
  312: "PEARSON",
  313: "RSQ",
  314: "STEYX",
  315: "SLOPE",
  316: "TTEST",
  317: "PROB",
  318: "DEVSQ",
  319: "GEOMEAN",
  320: "HARMEAN",
  321: "SUMSQ",
  322: "KURT",
  323: "SKEW",
  324: "ZTEST",
  325: "LARGE",
  326: "SMALL",
  327: "QUARTILE",
  328: "PERCENTILE",
  329: "PERCENTRANK",
  330: "MODE",
  331: "TRIMMEAN",
  332: "TINV",
  334: "MOVIE.COMMAND",
  335: "GET.MOVIE",
  336: "CONCATENATE",
  337: "POWER",
  338: "PIVOT.ADD.DATA",
  339: "GET.PIVOT.TABLE",
  340: "GET.PIVOT.FIELD",
  341: "GET.PIVOT.ITEM",
  342: "RADIANS",
  343: "DEGREES",
  344: "SUBTOTAL",
  345: "SUMIF",
  346: "COUNTIF",
  347: "COUNTBLANK",
  348: "SCENARIO.GET",
  349: "OPTIONS.LISTS.GET",
  350: "ISPMT",
  351: "DATEDIF",
  352: "DATESTRING",
  353: "NUMBERSTRING",
  354: "ROMAN",
  355: "OPEN.DIALOG",
  356: "SAVE.DIALOG",
  357: "VIEW.GET",
  358: "GETPIVOTDATA",
  359: "HYPERLINK",
  360: "PHONETIC",
  361: "AVERAGEA",
  362: "MAXA",
  363: "MINA",
  364: "STDEVPA",
  365: "VARPA",
  366: "STDEVA",
  367: "VARA",
  368: "BAHTTEXT",
  369: "THAIDAYOFWEEK",
  370: "THAIDIGIT",
  371: "THAIMONTHOFYEAR",
  372: "THAINUMSOUND",
  373: "THAINUMSTRING",
  374: "THAISTRINGLENGTH",
  375: "ISTHAIDIGIT",
  376: "ROUNDBAHTDOWN",
  377: "ROUNDBAHTUP",
  378: "THAIYEAR",
  379: "RTD",
  380: "CUBEVALUE",
  381: "CUBEMEMBER",
  382: "CUBEMEMBERPROPERTY",
  383: "CUBERANKEDMEMBER",
  384: "HEX2BIN",
  385: "HEX2DEC",
  386: "HEX2OCT",
  387: "DEC2BIN",
  388: "DEC2HEX",
  389: "DEC2OCT",
  390: "OCT2BIN",
  391: "OCT2HEX",
  392: "OCT2DEC",
  393: "BIN2DEC",
  394: "BIN2OCT",
  395: "BIN2HEX",
  396: "IMSUB",
  397: "IMDIV",
  398: "IMPOWER",
  399: "IMABS",
  400: "IMSQRT",
  401: "IMLN",
  402: "IMLOG2",
  403: "IMLOG10",
  404: "IMSIN",
  405: "IMCOS",
  406: "IMEXP",
  407: "IMARGUMENT",
  408: "IMCONJUGATE",
  409: "IMAGINARY",
  410: "IMREAL",
  411: "COMPLEX",
  412: "IMSUM",
  413: "IMPRODUCT",
  414: "SERIESSUM",
  415: "FACTDOUBLE",
  416: "SQRTPI",
  417: "QUOTIENT",
  418: "DELTA",
  419: "GESTEP",
  420: "ISEVEN",
  421: "ISODD",
  422: "MROUND",
  423: "ERF",
  424: "ERFC",
  425: "BESSELJ",
  426: "BESSELK",
  427: "BESSELY",
  428: "BESSELI",
  429: "XIRR",
  430: "XNPV",
  431: "PRICEMAT",
  432: "YIELDMAT",
  433: "INTRATE",
  434: "RECEIVED",
  435: "DISC",
  436: "PRICEDISC",
  437: "YIELDDISC",
  438: "TBILLEQ",
  439: "TBILLPRICE",
  440: "TBILLYIELD",
  441: "PRICE",
  442: "YIELD",
  443: "DOLLARDE",
  444: "DOLLARFR",
  445: "NOMINAL",
  446: "EFFECT",
  447: "CUMPRINC",
  448: "CUMIPMT",
  449: "EDATE",
  450: "EOMONTH",
  451: "YEARFRAC",
  452: "COUPDAYBS",
  453: "COUPDAYS",
  454: "COUPDAYSNC",
  455: "COUPNCD",
  456: "COUPNUM",
  457: "COUPPCD",
  458: "DURATION",
  459: "MDURATION",
  460: "ODDLPRICE",
  461: "ODDLYIELD",
  462: "ODDFPRICE",
  463: "ODDFYIELD",
  464: "RANDBETWEEN",
  465: "WEEKNUM",
  466: "AMORDEGRC",
  467: "AMORLINC",
  468: "CONVERT",
  724: "SHEETJS",
  469: "ACCRINT",
  470: "ACCRINTM",
  471: "WORKDAY",
  472: "NETWORKDAYS",
  473: "GCD",
  474: "MULTINOMIAL",
  475: "LCM",
  476: "FVSCHEDULE",
  477: "CUBEKPIMEMBER",
  478: "CUBESET",
  479: "CUBESETCOUNT",
  480: "IFERROR",
  481: "COUNTIFS",
  482: "SUMIFS",
  483: "AVERAGEIF",
  484: "AVERAGEIFS"
};
var Lv = {
  2: 1,
  3: 1,
  10: 0,
  15: 1,
  16: 1,
  17: 1,
  18: 1,
  19: 0,
  20: 1,
  21: 1,
  22: 1,
  23: 1,
  24: 1,
  25: 1,
  26: 1,
  27: 2,
  30: 2,
  31: 3,
  32: 1,
  33: 1,
  34: 0,
  35: 0,
  38: 1,
  39: 2,
  40: 3,
  41: 3,
  42: 3,
  43: 3,
  44: 3,
  45: 3,
  47: 3,
  48: 2,
  53: 1,
  61: 3,
  63: 0,
  65: 3,
  66: 3,
  67: 1,
  68: 1,
  69: 1,
  70: 1,
  71: 1,
  72: 1,
  73: 1,
  74: 0,
  75: 1,
  76: 1,
  77: 1,
  79: 2,
  80: 2,
  83: 1,
  85: 0,
  86: 1,
  89: 0,
  90: 1,
  94: 0,
  95: 0,
  97: 2,
  98: 1,
  99: 1,
  101: 3,
  102: 3,
  105: 1,
  106: 1,
  108: 2,
  111: 1,
  112: 1,
  113: 1,
  114: 1,
  117: 2,
  118: 1,
  119: 4,
  121: 1,
  126: 1,
  127: 1,
  128: 1,
  129: 1,
  130: 1,
  131: 1,
  133: 1,
  134: 1,
  135: 1,
  136: 2,
  137: 2,
  138: 2,
  140: 1,
  141: 1,
  142: 3,
  143: 4,
  144: 4,
  161: 1,
  162: 1,
  163: 1,
  164: 1,
  165: 2,
  172: 1,
  175: 2,
  176: 2,
  177: 3,
  178: 2,
  179: 1,
  184: 1,
  186: 1,
  189: 3,
  190: 1,
  195: 3,
  196: 3,
  197: 1,
  198: 1,
  199: 3,
  201: 1,
  207: 4,
  210: 3,
  211: 1,
  212: 2,
  213: 2,
  214: 1,
  215: 1,
  225: 0,
  229: 1,
  230: 1,
  231: 1,
  232: 1,
  233: 1,
  234: 1,
  235: 3,
  244: 1,
  247: 4,
  252: 2,
  257: 1,
  261: 1,
  271: 1,
  273: 4,
  274: 2,
  275: 2,
  276: 2,
  277: 3,
  278: 3,
  279: 1,
  280: 3,
  281: 3,
  282: 3,
  283: 1,
  284: 1,
  285: 2,
  286: 4,
  287: 3,
  288: 2,
  289: 4,
  290: 3,
  291: 3,
  292: 3,
  293: 4,
  294: 1,
  295: 3,
  296: 1,
  297: 3,
  298: 1,
  299: 2,
  300: 3,
  301: 3,
  302: 4,
  303: 2,
  304: 2,
  305: 2,
  306: 2,
  307: 2,
  308: 2,
  309: 3,
  310: 2,
  311: 2,
  312: 2,
  313: 2,
  314: 2,
  315: 2,
  316: 4,
  325: 2,
  326: 2,
  327: 2,
  328: 2,
  331: 2,
  332: 2,
  337: 2,
  342: 1,
  343: 1,
  346: 2,
  347: 1,
  350: 4,
  351: 3,
  352: 1,
  353: 2,
  360: 1,
  368: 1,
  369: 1,
  370: 1,
  371: 1,
  372: 1,
  373: 1,
  374: 1,
  375: 1,
  376: 1,
  377: 1,
  378: 1,
  382: 3,
  385: 1,
  392: 1,
  393: 1,
  396: 2,
  397: 2,
  398: 2,
  399: 1,
  400: 1,
  401: 1,
  402: 1,
  403: 1,
  404: 1,
  405: 1,
  406: 1,
  407: 1,
  408: 1,
  409: 1,
  410: 1,
  414: 4,
  415: 1,
  416: 1,
  417: 2,
  420: 1,
  421: 1,
  422: 2,
  424: 1,
  425: 2,
  426: 2,
  427: 2,
  428: 2,
  430: 3,
  438: 3,
  439: 3,
  440: 3,
  443: 2,
  444: 2,
  445: 2,
  446: 2,
  447: 6,
  448: 6,
  449: 2,
  450: 2,
  464: 2,
  468: 3,
  476: 2,
  479: 1,
  480: 2,
  65535: 0
};
function Cv(r6) {
  var e = "of:=" + r6.replace(Kl, "$1[.$2$3$4$5]").replace(/\]:\[/g, ":");
  return e.replace(/;/g, "|").replace(/,/g, ";");
}
function Pv(r6) {
  return r6.replace(/\./, "!");
}
var xo = typeof Map < "u";
function Ql(r6, e, t) {
  var n = 0, i = r6.length;
  if (t) {
    if (xo ? t.has(e) : Object.prototype.hasOwnProperty.call(t, e)) {
      for (var a = xo ? t.get(e) : t[e]; n < a.length; ++n) if (r6[a[n]].t === e) return r6.Count++, a[n];
    }
  } else for (; n < i; ++n) if (r6[n].t === e) return r6.Count++, n;
  return r6[i] = {
    t: e
  }, r6.Count++, r6.Unique++, t && (xo ? (t.has(e) || t.set(e, []), t.get(e).push(i)) : (Object.prototype.hasOwnProperty.call(t, e) || (t[e] = []), t[e].push(i))), i;
}
function lf(r6, e) {
  var t = {
    min: r6 + 1,
    max: r6 + 1
  }, n = -1;
  return e.MDW && (Bi = e.MDW), e.width != null ? t.customWidth = 1 : e.wpx != null ? n = X0(e.wpx) : e.wch != null && (n = e.wch), n > -1 ? (t.width = yl(n), t.customWidth = 1) : e.width != null && (t.width = e.width), e.hidden && (t.hidden = true), e.level != null && (t.outlineLevel = t.level = e.level), t;
}
function d1(r6, e) {
  if (r6) {
    var t = [0.7, 0.7, 0.75, 0.75, 0.3, 0.3];
    e == "xlml" && (t = [1, 1, 1, 1, 0.5, 0.5]), r6.left == null && (r6.left = t[0]), r6.right == null && (r6.right = t[1]), r6.top == null && (r6.top = t[2]), r6.bottom == null && (r6.bottom = t[3]), r6.header == null && (r6.header = t[4]), r6.footer == null && (r6.footer = t[5]);
  }
}
function pa(r6, e, t) {
  var n = t.revssf[e.z != null ? e.z : "General"], i = 60, a = r6.length;
  if (n == null && t.ssf) {
    for (; i < 392; ++i) if (t.ssf[i] == null) {
      fu(e.z, i), t.ssf[i] = e.z, t.revssf[e.z] = n = i;
      break;
    }
  }
  for (i = 0; i != a; ++i) if (r6[i].numFmtId === n) return i;
  return r6[a] = {
    numFmtId: n,
    fontId: 0,
    fillId: 0,
    borderId: 0,
    xfId: 0,
    applyNumberFormat: 1
  }, a;
}
function kv(r6, e, t) {
  if (r6 && r6["!ref"]) {
    var n = rr(r6["!ref"]);
    if (n.e.c < n.s.c || n.e.r < n.s.r) throw new Error("Bad range (" + t + "): " + r6["!ref"]);
  }
}
function Dv(r6) {
  if (r6.length === 0) return "";
  for (var e = '<mergeCells count="' + r6.length + '">', t = 0; t != r6.length; ++t) e += '<mergeCell ref="' + Sr(r6[t]) + '"/>';
  return e + "</mergeCells>";
}
function Ov(r6, e, t, n, i) {
  var a = false, s = {}, o = null;
  if (n.bookType !== "xlsx" && e.vbaraw) {
    var f = e.SheetNames[t];
    try {
      e.Workbook && (f = e.Workbook.Sheets[t].CodeName || f);
    } catch {
    }
    a = true, s.codeName = Di(Ht(f));
  }
  if (r6 && r6["!outline"]) {
    var h = {
      summaryBelow: 1,
      summaryRight: 1
    };
    r6["!outline"].above && (h.summaryBelow = 0), r6["!outline"].left && (h.summaryRight = 0), o = (o || "") + Ge("outlinePr", null, h);
  }
  !a && !o || (i[i.length] = Ge("sheetPr", o, s));
}
var Iv = ["objects", "scenarios", "selectLockedCells", "selectUnlockedCells"];
var Rv = ["formatColumns", "formatRows", "formatCells", "insertColumns", "insertRows", "insertHyperlinks", "deleteColumns", "deleteRows", "sort", "autoFilter", "pivotTables"];
function Mv(r6) {
  var e = {
    sheet: 1
  };
  return Iv.forEach(function(t) {
    r6[t] != null && r6[t] && (e[t] = "1");
  }), Rv.forEach(function(t) {
    r6[t] != null && !r6[t] && (e[t] = "0");
  }), r6.password && (e.password = Ku(r6.password).toString(16).toUpperCase()), Ge("sheetProtection", null, e);
}
function Bv(r6) {
  return d1(r6), Ge("pageMargins", null, r6);
}
function jv(r6, e) {
  for (var t = ["<cols>"], n, i = 0; i != e.length; ++i) (n = e[i]) && (t[t.length] = Ge("col", null, lf(i, n)));
  return t[t.length] = "</cols>", t.join("");
}
function Uv(r6, e, t, n) {
  var i = typeof r6.ref == "string" ? r6.ref : Sr(r6.ref);
  t.Workbook || (t.Workbook = {
    Sheets: []
  }), t.Workbook.Names || (t.Workbook.Names = []);
  var a = t.Workbook.Names, s = Ln(i);
  s.s.r == s.e.r && (s.e.r = Ln(e["!ref"]).e.r, i = Sr(s));
  for (var o = 0; o < a.length; ++o) {
    var f = a[o];
    if (f.Name == "_xlnm._FilterDatabase" && f.Sheet == n) {
      f.Ref = "'" + t.SheetNames[n] + "'!" + i;
      break;
    }
  }
  return o == a.length && a.push({
    Name: "_xlnm._FilterDatabase",
    Sheet: n,
    Ref: "'" + t.SheetNames[n] + "'!" + i
  }), Ge("autoFilter", null, {
    ref: i
  });
}
function qv(r6, e, t, n) {
  var i = {
    workbookViewId: "0"
  };
  return (((n || {}).Workbook || {}).Views || [])[0] && (i.rightToLeft = n.Workbook.Views[0].RTL ? "1" : "0"), Ge("sheetViews", Ge("sheetView", null, i), {});
}
function Hv(r6, e, t, n) {
  if (r6.c && t["!comments"].push([e, r6.c]), r6.v === void 0 && typeof r6.f != "string" || r6.t === "z" && !r6.f) return "";
  var i = "", a = r6.t, s = r6.v;
  if (r6.t !== "z") switch (r6.t) {
    case "b":
      i = r6.v ? "1" : "0";
      break;
    case "n":
      i = "" + r6.v;
      break;
    case "e":
      i = Po[r6.v];
      break;
    case "d":
      n && n.cellDates ? i = an(r6.v, -1).toISOString() : (r6 = gn(r6), r6.t = "n", i = "" + (r6.v = pn(an(r6.v)))), typeof r6.z > "u" && (r6.z = lr[14]);
      break;
    default:
      i = r6.v;
      break;
  }
  var o = Ur("v", Ht(i)), f = {
    r: e
  }, h = pa(n.cellXfs, r6, n);
  switch (h !== 0 && (f.s = h), r6.t) {
    case "n":
      break;
    case "d":
      f.t = "d";
      break;
    case "b":
      f.t = "b";
      break;
    case "e":
      f.t = "e";
      break;
    case "z":
      break;
    default:
      if (r6.v == null) {
        delete r6.t;
        break;
      }
      if (r6.v.length > 32767) throw new Error("Text length must not exceed 32767 characters");
      if (n && n.bookSST) {
        o = Ur("v", "" + Ql(n.Strings, r6.v, n.revStrings)), f.t = "s";
        break;
      }
      f.t = "str";
      break;
  }
  if (r6.t != a && (r6.t = a, r6.v = s), typeof r6.f == "string" && r6.f) {
    var c = r6.F && r6.F.slice(0, e.length) == e ? {
      t: "array",
      ref: r6.F
    } : null;
    o = Ge("f", Ht(r6.f), c) + (r6.v != null ? o : "");
  }
  return r6.l && t["!links"].push([e, r6.l]), r6.D && (f.cm = 1), Ge("c", o, f);
}
function Wv(r6, e, t, n) {
  var i = [], a = [], s = rr(r6["!ref"]), o = "", f, h = "", c = [], p = 0, v = 0, d = r6["!rows"], w = Array.isArray(r6), x = {
    r: h
  }, S, A = -1;
  for (v = s.s.c; v <= s.e.c; ++v) c[v] = Jr(v);
  for (p = s.s.r; p <= s.e.r; ++p) {
    for (a = [], h = qr(p), v = s.s.c; v <= s.e.c; ++v) {
      f = c[v] + h;
      var b = w ? (r6[p] || [])[v] : r6[f];
      b !== void 0 && (o = Hv(b, f, r6, e)) != null && a.push(o);
    }
    (a.length > 0 || d && d[p]) && (x = {
      r: h
    }, d && d[p] && (S = d[p], S.hidden && (x.hidden = 1), A = -1, S.hpx ? A = Y0(S.hpx) : S.hpt && (A = S.hpt), A > -1 && (x.ht = A, x.customHeight = 1), S.level && (x.outlineLevel = S.level)), i[i.length] = Ge("row", a.join(""), x));
  }
  if (d) for (; p < d.length; ++p) d && d[p] && (x = {
    r: p + 1
  }, S = d[p], S.hidden && (x.hidden = 1), A = -1, S.hpx ? A = Y0(S.hpx) : S.hpt && (A = S.hpt), A > -1 && (x.ht = A, x.customHeight = 1), S.level && (x.outlineLevel = S.level), i[i.length] = Ge("row", "", x));
  return i.join("");
}
function p1(r6, e, t, n) {
  var i = [Ar, Ge("worksheet", null, {
    xmlns: Fs[0],
    "xmlns:r": kr.r
  })], a = t.SheetNames[r6], s = 0, o = "", f = t.Sheets[a];
  f == null && (f = {});
  var h = f["!ref"] || "A1", c = rr(h);
  if (c.e.c > 16383 || c.e.r > 1048575) {
    if (e.WTF) throw new Error("Range " + h + " exceeds format limit A1:XFD1048576");
    c.e.c = Math.min(c.e.c, 16383), c.e.r = Math.min(c.e.c, 1048575), h = Sr(c);
  }
  n || (n = {}), f["!comments"] = [];
  var p = [];
  Ov(f, t, r6, e, i), i[i.length] = Ge("dimension", null, {
    ref: h
  }), i[i.length] = qv(f, e, r6, t), e.sheetFormat && (i[i.length] = Ge("sheetFormatPr", null, {
    defaultRowHeight: e.sheetFormat.defaultRowHeight || "16",
    baseColWidth: e.sheetFormat.baseColWidth || "10",
    outlineLevelRow: e.sheetFormat.outlineLevelRow || "7"
  })), f["!cols"] != null && f["!cols"].length > 0 && (i[i.length] = jv(f, f["!cols"])), i[s = i.length] = "<sheetData/>", f["!links"] = [], f["!ref"] != null && (o = Wv(f, e), o.length > 0 && (i[i.length] = o)), i.length > s + 1 && (i[i.length] = "</sheetData>", i[s] = i[s].replace("/>", ">")), f["!protect"] && (i[i.length] = Mv(f["!protect"])), f["!autofilter"] != null && (i[i.length] = Uv(f["!autofilter"], f, t, r6)), f["!merges"] != null && f["!merges"].length > 0 && (i[i.length] = Dv(f["!merges"]));
  var v = -1, d, w = -1;
  return (
    /*::(*/
    f["!links"].length > 0 && (i[i.length] = "<hyperlinks>", f["!links"].forEach(function(x) {
      x[1].Target && (d = {
        ref: x[0]
      }, x[1].Target.charAt(0) != "#" && (w = qt(n, -1, Ht(x[1].Target).replace(/#.*$/, ""), Dt.HLINK), d["r:id"] = "rId" + w), (v = x[1].Target.indexOf("#")) > -1 && (d.location = Ht(x[1].Target.slice(v + 1))), x[1].Tooltip && (d.tooltip = Ht(x[1].Tooltip)), i[i.length] = Ge("hyperlink", null, d));
    }), i[i.length] = "</hyperlinks>"), delete f["!links"], f["!margins"] != null && (i[i.length] = Bv(f["!margins"])), (!e || e.ignoreEC || e.ignoreEC == null) && (i[i.length] = Ur("ignoredErrors", Ge("ignoredError", null, {
      numberStoredAsText: 1,
      sqref: h
    }))), p.length > 0 && (w = qt(n, -1, "../drawings/drawing" + (r6 + 1) + ".xml", Dt.DRAW), i[i.length] = Ge("drawing", null, {
      "r:id": "rId" + w
    }), f["!drawing"] = p), f["!comments"].length > 0 && (w = qt(n, -1, "../drawings/vmlDrawing" + (r6 + 1) + ".vml", Dt.VML), i[i.length] = Ge("legacyDrawing", null, {
      "r:id": "rId" + w
    }), f["!legacy"] = w), i.length > 1 && (i[i.length] = "</worksheet>", i[1] = i[1].replace("/>", ">")), i.join("")
  );
}
function zv(r6, e) {
  var t = {}, n = r6.l + e;
  t.r = r6.read_shift(4), r6.l += 4;
  var i = r6.read_shift(2);
  r6.l += 1;
  var a = r6.read_shift(1);
  return r6.l = n, a & 7 && (t.level = a & 7), a & 16 && (t.hidden = true), a & 32 && (t.hpt = i / 20), t;
}
function Vv(r6, e, t) {
  var n = Le(145), i = (t["!rows"] || [])[r6] || {};
  n.write_shift(4, r6), n.write_shift(4, 0);
  var a = 320;
  i.hpx ? a = Y0(i.hpx) * 20 : i.hpt && (a = i.hpt * 20), n.write_shift(2, a), n.write_shift(1, 0);
  var s = 0;
  i.level && (s |= i.level), i.hidden && (s |= 16), (i.hpx || i.hpt) && (s |= 32), n.write_shift(1, s), n.write_shift(1, 0);
  var o = 0, f = n.l;
  n.l += 4;
  for (var h = {
    r: r6,
    c: 0
  }, c = 0; c < 16; ++c) if (!(e.s.c > c + 1 << 10 || e.e.c < c << 10)) {
    for (var p = -1, v = -1, d = c << 10; d < c + 1 << 10; ++d) {
      h.c = d;
      var w = Array.isArray(t) ? (t[h.r] || [])[h.c] : t[zt(h)];
      w && (p < 0 && (p = d), v = d);
    }
    p < 0 || (++o, n.write_shift(4, p), n.write_shift(4, v));
  }
  var x = n.l;
  return n.l = f, n.write_shift(4, o), n.l = x, n.length > n.l ? n.slice(0, n.l) : n;
}
function Gv(r6, e, t, n) {
  var i = Vv(n, t, e);
  (i.length > 17 || (e["!rows"] || [])[n]) && Re(r6, 0, i);
}
var Xv = Ba;
var Yv = Cs;
function $v() {
}
function Kv(r6, e) {
  var t = {}, n = r6[r6.l];
  return ++r6.l, t.above = !(n & 64), t.left = !(n & 128), r6.l += 18, t.name = sp(r6), t;
}
function Jv(r6, e, t) {
  t == null && (t = Le(84 + 4 * r6.length));
  var n = 192;
  e && (e.above && (n &= -65), e.left && (n &= -129)), t.write_shift(1, n);
  for (var i = 1; i < 3; ++i) t.write_shift(1, 0);
  return z0({
    auto: 1
  }, t), t.write_shift(-4, -1), t.write_shift(-4, -1), Lu(r6, t), t.slice(0, t.l);
}
function Zv(r6) {
  var e = Hn(r6);
  return [e];
}
function Qv(r6, e, t) {
  return t == null && (t = Le(8)), Ia(e, t);
}
function em(r6) {
  var e = Ra(r6);
  return [e];
}
function tm(r6, e, t) {
  return t == null && (t = Le(4)), Ma(e, t);
}
function rm(r6) {
  var e = Hn(r6), t = r6.read_shift(1);
  return [e, t, "b"];
}
function nm(r6, e, t) {
  return t == null && (t = Le(9)), Ia(e, t), t.write_shift(1, r6.v ? 1 : 0), t;
}
function im(r6) {
  var e = Ra(r6), t = r6.read_shift(1);
  return [e, t, "b"];
}
function am(r6, e, t) {
  return t == null && (t = Le(5)), Ma(e, t), t.write_shift(1, r6.v ? 1 : 0), t;
}
function sm(r6) {
  var e = Hn(r6), t = r6.read_shift(1);
  return [e, t, "e"];
}
function om(r6, e, t) {
  return t == null && (t = Le(9)), Ia(e, t), t.write_shift(1, r6.v), t;
}
function fm(r6) {
  var e = Ra(r6), t = r6.read_shift(1);
  return [e, t, "e"];
}
function lm(r6, e, t) {
  return t == null && (t = Le(8)), Ma(e, t), t.write_shift(1, r6.v), t.write_shift(2, 0), t.write_shift(1, 0), t;
}
function hm(r6) {
  var e = Hn(r6), t = r6.read_shift(4);
  return [e, t, "s"];
}
function cm(r6, e, t) {
  return t == null && (t = Le(12)), Ia(e, t), t.write_shift(4, e.v), t;
}
function um(r6) {
  var e = Ra(r6), t = r6.read_shift(4);
  return [e, t, "s"];
}
function dm(r6, e, t) {
  return t == null && (t = Le(8)), Ma(e, t), t.write_shift(4, e.v), t;
}
function pm(r6) {
  var e = Hn(r6), t = Ps(r6);
  return [e, t, "n"];
}
function gm(r6, e, t) {
  return t == null && (t = Le(16)), Ia(e, t), ka(r6.v, t), t;
}
function vm(r6) {
  var e = Ra(r6), t = Ps(r6);
  return [e, t, "n"];
}
function mm(r6, e, t) {
  return t == null && (t = Le(12)), Ma(e, t), ka(r6.v, t), t;
}
function xm(r6) {
  var e = Hn(r6), t = Cu(r6);
  return [e, t, "n"];
}
function wm(r6, e, t) {
  return t == null && (t = Le(12)), Ia(e, t), Pu(r6.v, t), t;
}
function ym(r6) {
  var e = Ra(r6), t = Cu(r6);
  return [e, t, "n"];
}
function _m(r6, e, t) {
  return t == null && (t = Le(8)), Ma(e, t), Pu(r6.v, t), t;
}
function Sm(r6) {
  var e = Hn(r6), t = Vl(r6);
  return [e, t, "is"];
}
function Am(r6) {
  var e = Hn(r6), t = Zr(r6);
  return [e, t, "str"];
}
function bm(r6, e, t) {
  return t == null && (t = Le(12 + 4 * r6.v.length)), Ia(e, t), Or(r6.v, t), t.length > t.l ? t.slice(0, t.l) : t;
}
function Tm(r6) {
  var e = Ra(r6), t = Zr(r6);
  return [e, t, "str"];
}
function Em(r6, e, t) {
  return t == null && (t = Le(8 + 4 * r6.v.length)), Ma(e, t), Or(r6.v, t), t.length > t.l ? t.slice(0, t.l) : t;
}
function Nm(r6, e, t) {
  var n = r6.l + e, i = Hn(r6);
  i.r = t["!row"];
  var a = r6.read_shift(1), s = [i, a, "b"];
  if (t.cellFormula) {
    r6.l += 2;
    var o = ff(r6, n - r6.l, t);
    s[3] = Ns(o, null, i, t.supbooks, t);
  } else r6.l = n;
  return s;
}
function Fm(r6, e, t) {
  var n = r6.l + e, i = Hn(r6);
  i.r = t["!row"];
  var a = r6.read_shift(1), s = [i, a, "e"];
  if (t.cellFormula) {
    r6.l += 2;
    var o = ff(r6, n - r6.l, t);
    s[3] = Ns(o, null, i, t.supbooks, t);
  } else r6.l = n;
  return s;
}
function Lm(r6, e, t) {
  var n = r6.l + e, i = Hn(r6);
  i.r = t["!row"];
  var a = Ps(r6), s = [i, a, "n"];
  if (t.cellFormula) {
    r6.l += 2;
    var o = ff(r6, n - r6.l, t);
    s[3] = Ns(o, null, i, t.supbooks, t);
  } else r6.l = n;
  return s;
}
function Cm(r6, e, t) {
  var n = r6.l + e, i = Hn(r6);
  i.r = t["!row"];
  var a = Zr(r6), s = [i, a, "str"];
  if (t.cellFormula) {
    r6.l += 2;
    var o = ff(r6, n - r6.l, t);
    s[3] = Ns(o, null, i, t.supbooks, t);
  } else r6.l = n;
  return s;
}
var Pm = Ba;
var km = Cs;
function Dm(r6, e) {
  return e == null && (e = Le(4)), e.write_shift(4, r6), e;
}
function Om(r6, e) {
  var t = r6.l + e, n = Ba(r6), i = Gl(r6), a = Zr(r6), s = Zr(r6), o = Zr(r6);
  r6.l = t;
  var f = {
    rfx: n,
    relId: i,
    loc: a,
    display: o
  };
  return s && (f.Tooltip = s), f;
}
function Im(r6, e) {
  var t = Le(50 + 4 * (r6[1].Target.length + (r6[1].Tooltip || "").length));
  Cs({
    s: Dr(r6[0]),
    e: Dr(r6[0])
  }, t), Xl("rId" + e, t);
  var n = r6[1].Target.indexOf("#"), i = n == -1 ? "" : r6[1].Target.slice(n + 1);
  return Or(i || "", t), Or(r6[1].Tooltip || "", t), Or("", t), t.slice(0, t.l);
}
function Rm() {
}
function Mm(r6, e, t) {
  var n = r6.l + e, i = ku(r6), a = r6.read_shift(1), s = [i];
  if (s[2] = a, t.cellFormula) {
    var o = Tv(r6, n - r6.l, t);
    s[1] = o;
  } else r6.l = n;
  return s;
}
function Bm(r6, e, t) {
  var n = r6.l + e, i = Ba(r6), a = [i];
  if (t.cellFormula) {
    var s = Nv(r6, n - r6.l, t);
    a[1] = s, r6.l = n;
  } else r6.l = n;
  return a;
}
function jm(r6, e, t) {
  t == null && (t = Le(18));
  var n = lf(r6, e);
  t.write_shift(-4, r6), t.write_shift(-4, r6), t.write_shift(4, (n.width || 10) * 256), t.write_shift(
    4,
    0
    /*ixfe*/
  );
  var i = 0;
  return e.hidden && (i |= 1), typeof n.width == "number" && (i |= 2), e.level && (i |= e.level << 8), t.write_shift(2, i), t;
}
var g1 = ["left", "right", "top", "bottom", "header", "footer"];
function Um(r6) {
  var e = {};
  return g1.forEach(function(t) {
    e[t] = Ps(r6);
  }), e;
}
function qm(r6, e) {
  return e == null && (e = Le(6 * 8)), d1(r6), g1.forEach(function(t) {
    ka(r6[t], e);
  }), e;
}
function Hm(r6) {
  var e = r6.read_shift(2);
  return r6.l += 28, {
    RTL: e & 32
  };
}
function Wm(r6, e, t) {
  t == null && (t = Le(30));
  var n = 924;
  return (((e || {}).Views || [])[0] || {}).RTL && (n |= 32), t.write_shift(2, n), t.write_shift(4, 0), t.write_shift(4, 0), t.write_shift(4, 0), t.write_shift(1, 0), t.write_shift(1, 0), t.write_shift(2, 0), t.write_shift(2, 100), t.write_shift(2, 0), t.write_shift(2, 0), t.write_shift(2, 0), t.write_shift(4, 0), t;
}
function zm(r6) {
  var e = Le(24);
  return e.write_shift(4, 4), e.write_shift(4, 1), Cs(r6, e), e;
}
function Vm(r6, e) {
  return e == null && (e = Le(16 * 4 + 2)), e.write_shift(2, r6.password ? Ku(r6.password) : 0), e.write_shift(4, 1), [
    ["objects", false],
    // fObjects
    ["scenarios", false],
    // fScenarios
    ["formatCells", true],
    // fFormatCells
    ["formatColumns", true],
    // fFormatColumns
    ["formatRows", true],
    // fFormatRows
    ["insertColumns", true],
    // fInsertColumns
    ["insertRows", true],
    // fInsertRows
    ["insertHyperlinks", true],
    // fInsertHyperlinks
    ["deleteColumns", true],
    // fDeleteColumns
    ["deleteRows", true],
    // fDeleteRows
    ["selectLockedCells", false],
    // fSelLockedCells
    ["sort", true],
    // fSort
    ["autoFilter", true],
    // fAutoFilter
    ["pivotTables", true],
    // fPivotTables
    ["selectUnlockedCells", false]
    // fSelUnlockedCells
  ].forEach(function(t) {
    t[1] ? e.write_shift(4, r6[t[0]] != null && !r6[t[0]] ? 1 : 0) : e.write_shift(4, r6[t[0]] != null && r6[t[0]] ? 0 : 1);
  }), e;
}
function Gm() {
}
function Xm() {
}
function Ym(r6, e, t, n, i, a, s) {
  if (e.v === void 0) return false;
  var o = "";
  switch (e.t) {
    case "b":
      o = e.v ? "1" : "0";
      break;
    case "d":
      e = gn(e), e.z = e.z || lr[14], e.v = pn(an(e.v)), e.t = "n";
      break;
    case "n":
    case "e":
      o = "" + e.v;
      break;
    default:
      o = e.v;
      break;
  }
  var f = {
    r: t,
    c: n
  };
  switch (f.s = pa(i.cellXfs, e, i), e.l && a["!links"].push([zt(f), e.l]), e.c && a["!comments"].push([zt(f), e.c]), e.t) {
    case "s":
    case "str":
      return i.bookSST ? (o = Ql(i.Strings, e.v, i.revStrings), f.t = "s", f.v = o, s ? Re(r6, 18, dm(e, f)) : Re(r6, 7, cm(e, f))) : (f.t = "str", s ? Re(r6, 17, Em(e, f)) : Re(r6, 6, bm(e, f))), true;
    case "n":
      return e.v == (e.v | 0) && e.v > -1e3 && e.v < 1e3 ? s ? Re(r6, 13, _m(e, f)) : Re(r6, 2, wm(e, f)) : s ? Re(r6, 16, mm(e, f)) : Re(r6, 5, gm(e, f)), true;
    case "b":
      return f.t = "b", s ? Re(r6, 15, am(e, f)) : Re(r6, 4, nm(e, f)), true;
    case "e":
      return f.t = "e", s ? Re(r6, 14, lm(e, f)) : Re(r6, 3, om(e, f)), true;
  }
  return s ? Re(r6, 12, tm(e, f)) : Re(r6, 1, Qv(e, f)), true;
}
function $m(r6, e, t, n) {
  var i = rr(e["!ref"] || "A1"), a, s = "", o = [];
  Re(
    r6,
    145
    /* BrtBeginSheetData */
  );
  var f = Array.isArray(e), h = i.e.r;
  e["!rows"] && (h = Math.max(i.e.r, e["!rows"].length - 1));
  for (var c = i.s.r; c <= h; ++c) {
    s = qr(c), Gv(r6, e, i, c);
    var p = false;
    if (c <= i.e.r) for (var v = i.s.c; v <= i.e.c; ++v) {
      c === i.s.r && (o[v] = Jr(v)), a = o[v] + s;
      var d = f ? (e[c] || [])[v] : e[a];
      if (!d) {
        p = false;
        continue;
      }
      p = Ym(r6, d, c, v, n, e, p);
    }
  }
  Re(
    r6,
    146
    /* BrtEndSheetData */
  );
}
function Km(r6, e) {
  !e || !e["!merges"] || (Re(r6, 177, Dm(e["!merges"].length)), e["!merges"].forEach(function(t) {
    Re(r6, 176, km(t));
  }), Re(
    r6,
    178
    /* BrtEndMergeCells */
  ));
}
function Jm(r6, e) {
  !e || !e["!cols"] || (Re(
    r6,
    390
    /* BrtBeginColInfos */
  ), e["!cols"].forEach(function(t, n) {
    t && Re(r6, 60, jm(n, t));
  }), Re(
    r6,
    391
    /* BrtEndColInfos */
  ));
}
function Zm(r6, e) {
  !e || !e["!ref"] || (Re(
    r6,
    648
    /* BrtBeginCellIgnoreECs */
  ), Re(r6, 649, zm(rr(e["!ref"]))), Re(
    r6,
    650
    /* BrtEndCellIgnoreECs */
  ));
}
function Qm(r6, e, t) {
  e["!links"].forEach(function(n) {
    if (n[1].Target) {
      var i = qt(t, -1, n[1].Target.replace(/#.*$/, ""), Dt.HLINK);
      Re(r6, 494, Im(n, i));
    }
  }), delete e["!links"];
}
function ex(r6, e, t, n) {
  if (e["!comments"].length > 0) {
    var i = qt(n, -1, "../drawings/vmlDrawing" + (t + 1) + ".vml", Dt.VML);
    Re(r6, 551, Xl("rId" + i)), e["!legacy"] = i;
  }
}
function tx(r6, e, t, n) {
  if (e["!autofilter"]) {
    var i = e["!autofilter"], a = typeof i.ref == "string" ? i.ref : Sr(i.ref);
    t.Workbook || (t.Workbook = {
      Sheets: []
    }), t.Workbook.Names || (t.Workbook.Names = []);
    var s = t.Workbook.Names, o = Ln(a);
    o.s.r == o.e.r && (o.e.r = Ln(e["!ref"]).e.r, a = Sr(o));
    for (var f = 0; f < s.length; ++f) {
      var h = s[f];
      if (h.Name == "_xlnm._FilterDatabase" && h.Sheet == n) {
        h.Ref = "'" + t.SheetNames[n] + "'!" + a;
        break;
      }
    }
    f == s.length && s.push({
      Name: "_xlnm._FilterDatabase",
      Sheet: n,
      Ref: "'" + t.SheetNames[n] + "'!" + a
    }), Re(r6, 161, Cs(rr(a))), Re(
      r6,
      162
      /* BrtEndAFilter */
    );
  }
}
function rx(r6, e, t) {
  Re(
    r6,
    133
    /* BrtBeginWsViews */
  ), Re(r6, 137, Wm(e, t)), Re(
    r6,
    138
    /* BrtEndWsView */
  ), Re(
    r6,
    134
    /* BrtEndWsViews */
  );
}
function nx(r6, e) {
  e["!protect"] && Re(r6, 535, Vm(e["!protect"]));
}
function ix(r6, e, t, n) {
  var i = dn(), a = t.SheetNames[r6], s = t.Sheets[a] || {}, o = a;
  try {
    t && t.Workbook && (o = t.Workbook.Sheets[r6].CodeName || o);
  } catch {
  }
  var f = rr(s["!ref"] || "A1");
  if (f.e.c > 16383 || f.e.r > 1048575) {
    if (e.WTF) throw new Error("Range " + (s["!ref"] || "A1") + " exceeds format limit A1:XFD1048576");
    f.e.c = Math.min(f.e.c, 16383), f.e.r = Math.min(f.e.c, 1048575);
  }
  return s["!links"] = [], s["!comments"] = [], Re(
    i,
    129
    /* BrtBeginSheet */
  ), (t.vbaraw || s["!outline"]) && Re(i, 147, Jv(o, s["!outline"])), Re(i, 148, Yv(f)), rx(i, s, t.Workbook), Jm(i, s), $m(i, s, r6, e), nx(i, s), tx(i, s, t, r6), Km(i, s), Qm(i, s, n), s["!margins"] && Re(i, 476, qm(s["!margins"])), (!e || e.ignoreEC || e.ignoreEC == null) && Zm(i, s), ex(i, s, r6, n), Re(
    i,
    130
    /* BrtEndSheet */
  ), i.end();
}
function ax(r6, e) {
  r6.l += 10;
  var t = Zr(r6);
  return {
    name: t
  };
}
var sx = [["allowRefreshQuery", false, "bool"], ["autoCompressPictures", true, "bool"], ["backupFile", false, "bool"], ["checkCompatibility", false, "bool"], ["CodeName", ""], ["date1904", false, "bool"], ["defaultThemeVersion", 0, "int"], ["filterPrivacy", false, "bool"], ["hidePivotFieldList", false, "bool"], ["promptedSolutions", false, "bool"], ["publishItems", false, "bool"], ["refreshAllConnections", false, "bool"], ["saveExternalLinkValues", true, "bool"], ["showBorderUnselectedTables", true, "bool"], ["showInkAnnotation", true, "bool"], ["showObjects", "all"], ["showPivotChartFilter", false, "bool"], ["updateLinks", "userSet"]];
function ox(r6) {
  return !r6.Workbook || !r6.Workbook.WBProps ? "false" : Bd(r6.Workbook.WBProps.date1904) ? "true" : "false";
}
var fx = "][*?/\\".split("");
function v1(r6, e) {
  if (r6.length > 31) {
    if (e) return false;
    throw new Error("Sheet names cannot exceed 31 chars");
  }
  var t = true;
  return fx.forEach(function(n) {
    if (r6.indexOf(n) != -1) {
      if (!e) throw new Error("Sheet name cannot contain : \\ / ? * [ ]");
      t = false;
    }
  }), t;
}
function lx(r6, e, t) {
  r6.forEach(function(n, i) {
    v1(n);
    for (var a = 0; a < i; ++a) if (n == r6[a]) throw new Error("Duplicate Sheet Name: " + n);
    if (t) {
      var s = e && e[i] && e[i].CodeName || n;
      if (s.charCodeAt(0) == 95 && s.length > 22) throw new Error("Bad Code Name: Worksheet" + s);
    }
  });
}
function hx(r6) {
  if (!r6 || !r6.SheetNames || !r6.Sheets) throw new Error("Invalid Workbook");
  if (!r6.SheetNames.length) throw new Error("Workbook is empty");
  var e = r6.Workbook && r6.Workbook.Sheets || [];
  lx(r6.SheetNames, e, !!r6.vbaraw);
  for (var t = 0; t < r6.SheetNames.length; ++t) kv(r6.Sheets[r6.SheetNames[t]], r6.SheetNames[t], t);
}
function m1(r6) {
  var e = [Ar];
  e[e.length] = Ge("workbook", null, {
    xmlns: Fs[0],
    //'xmlns:mx': XMLNS.mx,
    //'xmlns:s': XMLNS_main[0],
    "xmlns:r": kr.r
  });
  var t = r6.Workbook && (r6.Workbook.Names || []).length > 0, n = {
    codeName: "ThisWorkbook"
  };
  r6.Workbook && r6.Workbook.WBProps && (sx.forEach(function(o) {
    r6.Workbook.WBProps[o[0]] != null && r6.Workbook.WBProps[o[0]] != o[1] && (n[o[0]] = r6.Workbook.WBProps[o[0]]);
  }), r6.Workbook.WBProps.CodeName && (n.codeName = r6.Workbook.WBProps.CodeName, delete n.CodeName)), e[e.length] = Ge("workbookPr", null, n);
  var i = r6.Workbook && r6.Workbook.Sheets || [], a = 0;
  if (i && i[0] && i[0].Hidden) {
    for (e[e.length] = "<bookViews>", a = 0; a != r6.SheetNames.length && !(!i[a] || !i[a].Hidden); ++a) ;
    a == r6.SheetNames.length && (a = 0), e[e.length] = '<workbookView firstSheet="' + a + '" activeTab="' + a + '"/>', e[e.length] = "</bookViews>";
  }
  for (e[e.length] = "<sheets>", a = 0; a != r6.SheetNames.length; ++a) {
    var s = {
      name: Ht(r6.SheetNames[a].slice(0, 31))
    };
    if (s.sheetId = "" + (a + 1), s["r:id"] = "rId" + (a + 1), i[a]) switch (i[a].Hidden) {
      case 1:
        s.state = "hidden";
        break;
      case 2:
        s.state = "veryHidden";
        break;
    }
    e[e.length] = Ge("sheet", null, s);
  }
  return e[e.length] = "</sheets>", t && (e[e.length] = "<definedNames>", r6.Workbook && r6.Workbook.Names && r6.Workbook.Names.forEach(function(o) {
    var f = {
      name: o.Name
    };
    o.Comment && (f.comment = o.Comment), o.Sheet != null && (f.localSheetId = "" + o.Sheet), o.Hidden && (f.hidden = "1"), o.Ref && (e[e.length] = Ge("definedName", Ht(o.Ref), f));
  }), e[e.length] = "</definedNames>"), e.length > 2 && (e[e.length] = "</workbook>", e[1] = e[1].replace("/>", ">")), e.join("");
}
function cx(r6, e) {
  var t = {};
  return t.Hidden = r6.read_shift(4), t.iTabID = r6.read_shift(4), t.strRelID = wl(r6), t.name = Zr(r6), t;
}
function ux(r6, e) {
  return e || (e = Le(127)), e.write_shift(4, r6.Hidden), e.write_shift(4, r6.iTabID), Xl(r6.strRelID, e), Or(r6.name.slice(0, 31), e), e.length > e.l ? e.slice(0, e.l) : e;
}
function dx(r6, e) {
  var t = {}, n = r6.read_shift(4);
  t.defaultThemeVersion = r6.read_shift(4);
  var i = e > 8 ? Zr(r6) : "";
  return i.length > 0 && (t.CodeName = i), t.autoCompressPictures = !!(n & 65536), t.backupFile = !!(n & 64), t.checkCompatibility = !!(n & 4096), t.date1904 = !!(n & 1), t.filterPrivacy = !!(n & 8), t.hidePivotFieldList = !!(n & 1024), t.promptedSolutions = !!(n & 16), t.publishItems = !!(n & 2048), t.refreshAllConnections = !!(n & 262144), t.saveExternalLinkValues = !!(n & 128), t.showBorderUnselectedTables = !!(n & 4), t.showInkAnnotation = !!(n & 32), t.showObjects = ["all", "placeholders", "none"][n >> 13 & 3], t.showPivotChartFilter = !!(n & 32768), t.updateLinks = ["userSet", "never", "always"][n >> 8 & 3], t;
}
function px(r6, e) {
  e || (e = Le(72));
  var t = 0;
  return r6 && r6.filterPrivacy && (t |= 8), e.write_shift(4, t), e.write_shift(4, 0), Lu(r6 && r6.CodeName || "ThisWorkbook", e), e.slice(0, e.l);
}
function gx(r6, e, t) {
  var n = r6.l + e;
  r6.l += 4, r6.l += 1;
  var i = r6.read_shift(4), a = op(r6), s = Ev(r6, 0, t), o = Gl(r6);
  r6.l = n;
  var f = {
    Name: a,
    Ptg: s
  };
  return i < 268435455 && (f.Sheet = i), o && (f.Comment = o), f;
}
function vx(r6, e) {
  Re(
    r6,
    143
    /* BrtBeginBundleShs */
  );
  for (var t = 0; t != e.SheetNames.length; ++t) {
    var n = e.Workbook && e.Workbook.Sheets && e.Workbook.Sheets[t] && e.Workbook.Sheets[t].Hidden || 0, i = {
      Hidden: n,
      iTabID: t + 1,
      strRelID: "rId" + (t + 1),
      name: e.SheetNames[t]
    };
    Re(r6, 156, ux(i));
  }
  Re(
    r6,
    144
    /* BrtEndBundleShs */
  );
}
function mx(r6, e) {
  e || (e = Le(127));
  for (var t = 0; t != 4; ++t) e.write_shift(4, 0);
  return Or("SheetJS", e), Or(M0.version, e), Or(M0.version, e), Or("7262", e), e.length > e.l ? e.slice(0, e.l) : e;
}
function xx(r6, e) {
  e || (e = Le(29)), e.write_shift(-4, 0), e.write_shift(-4, 460), e.write_shift(4, 28800), e.write_shift(4, 17600), e.write_shift(4, 500), e.write_shift(4, r6), e.write_shift(4, r6);
  var t = 120;
  return e.write_shift(1, t), e.length > e.l ? e.slice(0, e.l) : e;
}
function wx(r6, e) {
  if (!(!e.Workbook || !e.Workbook.Sheets)) {
    for (var t = e.Workbook.Sheets, n = 0, i = -1, a = -1; n < t.length; ++n) !t[n] || !t[n].Hidden && i == -1 ? i = n : t[n].Hidden == 1 && a == -1 && (a = n);
    a > i || (Re(
      r6,
      135
      /* BrtBeginBookViews */
    ), Re(r6, 158, xx(i)), Re(
      r6,
      136
      /* BrtEndBookViews */
    ));
  }
}
function yx(r6, e) {
  var t = dn();
  return Re(
    t,
    131
    /* BrtBeginBook */
  ), Re(t, 128, mx()), Re(t, 153, px(r6.Workbook && r6.Workbook.WBProps || null)), wx(t, r6), vx(t, r6), Re(
    t,
    132
    /* BrtEndBook */
  ), t.end();
}
function _x(r6, e, t) {
  return (e.slice(-4) === ".bin" ? yx : m1)(r6);
}
function Sx(r6, e, t, n, i) {
  return (e.slice(-4) === ".bin" ? ix : p1)(r6, t, n, i);
}
function Ax(r6, e, t) {
  return (e.slice(-4) === ".bin" ? q5 : Qu)(r6, t);
}
function bx(r6, e, t) {
  return (e.slice(-4) === ".bin" ? p5 : $u)(r6, t);
}
function Tx(r6, e, t) {
  return (e.slice(-4) === ".bin" ? ng : i1)(r6);
}
function Ex(r6) {
  return (r6.slice(-4) === ".bin" ? $5 : r1)();
}
function Nx(r6, e) {
  var t = [];
  return r6.Props && t.push(Ap(r6.Props, e)), r6.Custprops && t.push(bp(r6.Props, r6.Custprops)), t.join("");
}
function Fx() {
  return "";
}
function Lx(r6, e) {
  var t = ['<Style ss:ID="Default" ss:Name="Normal"><NumberFormat/></Style>'];
  return e.cellXfs.forEach(function(n, i) {
    var a = [];
    a.push(Ge("NumberFormat", null, {
      "ss:Format": Ht(lr[n.numFmtId])
    }));
    var s = (
      /*::(*/
      {
        "ss:ID": "s" + (21 + i)
      }
    );
    t.push(Ge("Style", a.join(""), s));
  }), Ge("Styles", t.join(""));
}
function x1(r6) {
  return Ge("NamedRange", null, {
    "ss:Name": r6.Name,
    "ss:RefersTo": "=" + Jl(r6.Ref, {
      r: 0,
      c: 0
    })
  });
}
function Cx(r6) {
  if (!((r6 || {}).Workbook || {}).Names) return "";
  for (var e = r6.Workbook.Names, t = [], n = 0; n < e.length; ++n) {
    var i = e[n];
    i.Sheet == null && (i.Name.match(/^_xlfn\./) || t.push(x1(i)));
  }
  return Ge("Names", t.join(""));
}
function Px(r6, e, t, n) {
  if (!r6 || !((n || {}).Workbook || {}).Names) return "";
  for (var i = n.Workbook.Names, a = [], s = 0; s < i.length; ++s) {
    var o = i[s];
    o.Sheet == t && (o.Name.match(/^_xlfn\./) || a.push(x1(o)));
  }
  return a.join("");
}
function kx(r6, e, t, n) {
  if (!r6) return "";
  var i = [];
  if (r6["!margins"] && (i.push("<PageSetup>"), r6["!margins"].header && i.push(Ge("Header", null, {
    "x:Margin": r6["!margins"].header
  })), r6["!margins"].footer && i.push(Ge("Footer", null, {
    "x:Margin": r6["!margins"].footer
  })), i.push(Ge("PageMargins", null, {
    "x:Bottom": r6["!margins"].bottom || "0.75",
    "x:Left": r6["!margins"].left || "0.7",
    "x:Right": r6["!margins"].right || "0.7",
    "x:Top": r6["!margins"].top || "0.75"
  })), i.push("</PageSetup>")), n && n.Workbook && n.Workbook.Sheets && n.Workbook.Sheets[t]) if (n.Workbook.Sheets[t].Hidden) i.push(Ge("Visible", n.Workbook.Sheets[t].Hidden == 1 ? "SheetHidden" : "SheetVeryHidden", {}));
  else {
    for (var a = 0; a < t && !(n.Workbook.Sheets[a] && !n.Workbook.Sheets[a].Hidden); ++a) ;
    a == t && i.push("<Selected/>");
  }
  return ((((n || {}).Workbook || {}).Views || [])[0] || {}).RTL && i.push("<DisplayRightToLeft/>"), r6["!protect"] && (i.push(Ur("ProtectContents", "True")), r6["!protect"].objects && i.push(Ur("ProtectObjects", "True")), r6["!protect"].scenarios && i.push(Ur("ProtectScenarios", "True")), r6["!protect"].selectLockedCells != null && !r6["!protect"].selectLockedCells ? i.push(Ur("EnableSelection", "NoSelection")) : r6["!protect"].selectUnlockedCells != null && !r6["!protect"].selectUnlockedCells && i.push(Ur("EnableSelection", "UnlockedCells")), [["formatCells", "AllowFormatCells"], ["formatColumns", "AllowSizeCols"], ["formatRows", "AllowSizeRows"], ["insertColumns", "AllowInsertCols"], ["insertRows", "AllowInsertRows"], ["insertHyperlinks", "AllowInsertHyperlinks"], ["deleteColumns", "AllowDeleteCols"], ["deleteRows", "AllowDeleteRows"], ["sort", "AllowSort"], ["autoFilter", "AllowFilter"], ["pivotTables", "AllowUsePivotTables"]].forEach(function(s) {
    r6["!protect"][s[0]] && i.push("<" + s[1] + "/>");
  })), i.length == 0 ? "" : Ge("WorksheetOptions", i.join(""), {
    xmlns: En.x
  });
}
function Dx(r6) {
  return r6.map(function(e) {
    var t = Md(e.t || ""), n = Ge("ss:Data", t, {
      xmlns: "http://www.w3.org/TR/REC-html40"
    });
    return Ge("Comment", n, {
      "ss:Author": e.a
    });
  }).join("");
}
function Ox(r6, e, t, n, i, a, s) {
  if (!r6 || r6.v == null && r6.f == null) return "";
  var o = {};
  if (r6.f && (o["ss:Formula"] = "=" + Ht(Jl(r6.f, s))), r6.F && r6.F.slice(0, e.length) == e) {
    var f = Dr(r6.F.slice(e.length + 1));
    o["ss:ArrayRange"] = "RC:R" + (f.r == s.r ? "" : "[" + (f.r - s.r) + "]") + "C" + (f.c == s.c ? "" : "[" + (f.c - s.c) + "]");
  }
  if (r6.l && r6.l.Target && (o["ss:HRef"] = Ht(r6.l.Target), r6.l.Tooltip && (o["x:HRefScreenTip"] = Ht(r6.l.Tooltip))), t["!merges"]) for (var h = t["!merges"], c = 0; c != h.length; ++c) h[c].s.c != s.c || h[c].s.r != s.r || (h[c].e.c > h[c].s.c && (o["ss:MergeAcross"] = h[c].e.c - h[c].s.c), h[c].e.r > h[c].s.r && (o["ss:MergeDown"] = h[c].e.r - h[c].s.r));
  var p = "", v = "";
  switch (r6.t) {
    case "z":
      if (!n.sheetStubs) return "";
      break;
    case "n":
      p = "Number", v = String(r6.v);
      break;
    case "b":
      p = "Boolean", v = r6.v ? "1" : "0";
      break;
    case "e":
      p = "Error", v = Po[r6.v];
      break;
    case "d":
      p = "DateTime", v = new Date(r6.v).toISOString(), r6.z == null && (r6.z = r6.z || lr[14]);
      break;
    case "s":
      p = "String", v = Rd(r6.v || "");
      break;
  }
  var d = pa(n.cellXfs, r6, n);
  o["ss:StyleID"] = "s" + (21 + d), o["ss:Index"] = s.c + 1;
  var w = r6.v != null ? v : "", x = r6.t == "z" ? "" : '<Data ss:Type="' + p + '">' + w + "</Data>";
  return (r6.c || []).length > 0 && (x += Dx(r6.c)), Ge("Cell", x, o);
}
function Ix(r6, e) {
  var t = '<Row ss:Index="' + (r6 + 1) + '"';
  return e && (e.hpt && !e.hpx && (e.hpx = Zu(e.hpt)), e.hpx && (t += ' ss:AutoFitHeight="0" ss:Height="' + e.hpx + '"'), e.hidden && (t += ' ss:Hidden="1"')), t + ">";
}
function Rx(r6, e, t, n) {
  if (!r6["!ref"]) return "";
  var i = rr(r6["!ref"]), a = r6["!merges"] || [], s = 0, o = [];
  r6["!cols"] && r6["!cols"].forEach(function(S, A) {
    $l(S);
    var b = !!S.width, O = lf(A, S), q = {
      "ss:Index": A + 1
    };
    b && (q["ss:Width"] = G0(O.width)), S.hidden && (q["ss:Hidden"] = "1"), o.push(Ge("Column", null, q));
  });
  for (var f = Array.isArray(r6), h = i.s.r; h <= i.e.r; ++h) {
    for (var c = [Ix(h, (r6["!rows"] || [])[h])], p = i.s.c; p <= i.e.c; ++p) {
      var v = false;
      for (s = 0; s != a.length; ++s) if (!(a[s].s.c > p) && !(a[s].s.r > h) && !(a[s].e.c < p) && !(a[s].e.r < h)) {
        (a[s].s.c != p || a[s].s.r != h) && (v = true);
        break;
      }
      if (!v) {
        var d = {
          r: h,
          c: p
        }, w = zt(d), x = f ? (r6[h] || [])[p] : r6[w];
        c.push(Ox(x, w, r6, e, t, n, d));
      }
    }
    c.push("</Row>"), c.length > 2 && o.push(c.join(""));
  }
  return o.join("");
}
function Mx(r6, e, t) {
  var n = [], i = t.SheetNames[r6], a = t.Sheets[i], s = a ? Px(a, e, r6, t) : "";
  return s.length > 0 && n.push("<Names>" + s + "</Names>"), s = a ? Rx(a, e, r6, t) : "", s.length > 0 && n.push("<Table>" + s + "</Table>"), n.push(kx(a, e, r6, t)), n.join("");
}
function Bx(r6, e) {
  e || (e = {}), r6.SSF || (r6.SSF = gn(lr)), r6.SSF && (nf(), rf(r6.SSF), e.revssf = af(r6.SSF), e.revssf[r6.SSF[65535]] = 0, e.ssf = r6.SSF, e.cellXfs = [], pa(e.cellXfs, {}, {
    revssf: {
      General: 0
    }
  }));
  var t = [];
  t.push(Nx(r6, e)), t.push(Fx()), t.push(""), t.push("");
  for (var n = 0; n < r6.SheetNames.length; ++n) t.push(Ge("Worksheet", Mx(n, e, r6), {
    "ss:Name": Ht(r6.SheetNames[n])
  }));
  return t[2] = Lx(r6, e), t[3] = Cx(r6), Ar + Ge("Workbook", t.join(""), {
    xmlns: En.ss,
    "xmlns:o": En.o,
    "xmlns:x": En.x,
    "xmlns:ss": En.ss,
    "xmlns:dt": En.dt,
    "xmlns:html": En.html
  });
}
var tl = {
  SI: "e0859ff2f94f6810ab9108002b27b3d9",
  DSI: "02d5cdd59c2e1b10939708002b2cf9ae",
  UDI: "05d5cdd59c2e1b10939708002b2cf9ae"
};
function jx(r6, e) {
  var t = [], n = [], i = [], a = 0, s, o = zh(nc, "n"), f = zh(ic, "n");
  if (r6.Props) for (s = Hr(r6.Props), a = 0; a < s.length; ++a) (Object.prototype.hasOwnProperty.call(o, s[a]) ? t : Object.prototype.hasOwnProperty.call(f, s[a]) ? n : i).push([s[a], r6.Props[s[a]]]);
  if (r6.Custprops) for (s = Hr(r6.Custprops), a = 0; a < s.length; ++a) Object.prototype.hasOwnProperty.call(r6.Props || {}, s[a]) || (Object.prototype.hasOwnProperty.call(o, s[a]) ? t : Object.prototype.hasOwnProperty.call(f, s[a]) ? n : i).push([s[a], r6.Custprops[s[a]]]);
  var h = [];
  for (a = 0; a < i.length; ++a) Hu.indexOf(i[a][0]) > -1 || ju.indexOf(i[a][0]) > -1 || i[a][1] != null && h.push(i[a]);
  n.length && Xt.utils.cfb_add(e, "/SummaryInformation", lc(n, tl.SI, f, ic)), (t.length || h.length) && Xt.utils.cfb_add(e, "/DocumentSummaryInformation", lc(t, tl.DSI, o, nc, h.length ? h : null, tl.UDI));
}
function Ux(r6, e) {
  var t = e || {}, n = Xt.utils.cfb_new({
    root: "R"
  }), i = "/Workbook";
  switch (t.bookType || "xls") {
    case "xls":
      t.bookType = "biff8";
    case "xla":
      t.bookType || (t.bookType = "xla");
    case "biff8":
      i = "/Workbook", t.biff = 8;
      break;
    case "biff5":
      i = "/Book", t.biff = 5;
      break;
    default:
      throw new Error("invalid type " + t.bookType + " for XLS CFB");
  }
  return Xt.utils.cfb_add(n, i, w1(r6, t)), t.biff == 8 && (r6.Props || r6.Custprops) && jx(r6, n), t.biff == 8 && r6.vbaraw && ig(n, Xt.read(r6.vbaraw, {
    type: typeof r6.vbaraw == "string" ? "binary" : "buffer"
  })), n;
}
var qx = {
  /*::[*/
  0: {
    /* n:"BrtRowHdr", */
    f: zv
  },
  /*::[*/
  1: {
    /* n:"BrtCellBlank", */
    f: Zv
  },
  /*::[*/
  2: {
    /* n:"BrtCellRk", */
    f: xm
  },
  /*::[*/
  3: {
    /* n:"BrtCellError", */
    f: sm
  },
  /*::[*/
  4: {
    /* n:"BrtCellBool", */
    f: rm
  },
  /*::[*/
  5: {
    /* n:"BrtCellReal", */
    f: pm
  },
  /*::[*/
  6: {
    /* n:"BrtCellSt", */
    f: Am
  },
  /*::[*/
  7: {
    /* n:"BrtCellIsst", */
    f: hm
  },
  /*::[*/
  8: {
    /* n:"BrtFmlaString", */
    f: Cm
  },
  /*::[*/
  9: {
    /* n:"BrtFmlaNum", */
    f: Lm
  },
  /*::[*/
  10: {
    /* n:"BrtFmlaBool", */
    f: Nm
  },
  /*::[*/
  11: {
    /* n:"BrtFmlaError", */
    f: Fm
  },
  /*::[*/
  12: {
    /* n:"BrtShortBlank", */
    f: em
  },
  /*::[*/
  13: {
    /* n:"BrtShortRk", */
    f: ym
  },
  /*::[*/
  14: {
    /* n:"BrtShortError", */
    f: fm
  },
  /*::[*/
  15: {
    /* n:"BrtShortBool", */
    f: im
  },
  /*::[*/
  16: {
    /* n:"BrtShortReal", */
    f: vm
  },
  /*::[*/
  17: {
    /* n:"BrtShortSt", */
    f: Tm
  },
  /*::[*/
  18: {
    /* n:"BrtShortIsst", */
    f: um
  },
  /*::[*/
  19: {
    /* n:"BrtSSTItem", */
    f: Vl
  },
  /*::[*/
  20: {
    /* n:"BrtPCDIMissing" */
  },
  /*::[*/
  21: {
    /* n:"BrtPCDINumber" */
  },
  /*::[*/
  22: {
    /* n:"BrtPCDIBoolean" */
  },
  /*::[*/
  23: {
    /* n:"BrtPCDIError" */
  },
  /*::[*/
  24: {
    /* n:"BrtPCDIString" */
  },
  /*::[*/
  25: {
    /* n:"BrtPCDIDatetime" */
  },
  /*::[*/
  26: {
    /* n:"BrtPCDIIndex" */
  },
  /*::[*/
  27: {
    /* n:"BrtPCDIAMissing" */
  },
  /*::[*/
  28: {
    /* n:"BrtPCDIANumber" */
  },
  /*::[*/
  29: {
    /* n:"BrtPCDIABoolean" */
  },
  /*::[*/
  30: {
    /* n:"BrtPCDIAError" */
  },
  /*::[*/
  31: {
    /* n:"BrtPCDIAString" */
  },
  /*::[*/
  32: {
    /* n:"BrtPCDIADatetime" */
  },
  /*::[*/
  33: {
    /* n:"BrtPCRRecord" */
  },
  /*::[*/
  34: {
    /* n:"BrtPCRRecordDt" */
  },
  /*::[*/
  35: {
    /* n:"BrtFRTBegin", */
    T: 1
  },
  /*::[*/
  36: {
    /* n:"BrtFRTEnd", */
    T: -1
  },
  /*::[*/
  37: {
    /* n:"BrtACBegin", */
    T: 1
  },
  /*::[*/
  38: {
    /* n:"BrtACEnd", */
    T: -1
  },
  /*::[*/
  39: {
    /* n:"BrtName", */
    f: gx
  },
  /*::[*/
  40: {
    /* n:"BrtIndexRowBlock" */
  },
  /*::[*/
  42: {
    /* n:"BrtIndexBlock" */
  },
  /*::[*/
  43: {
    /* n:"BrtFont", */
    f: A5
  },
  /*::[*/
  44: {
    /* n:"BrtFmt", */
    f: _5
  },
  /*::[*/
  45: {
    /* n:"BrtFill", */
    f: E5
  },
  /*::[*/
  46: {
    /* n:"BrtBorder", */
    f: F5
  },
  /*::[*/
  47: {
    /* n:"BrtXF", */
    f: N5
  },
  /*::[*/
  48: {
    /* n:"BrtStyle" */
  },
  /*::[*/
  49: {
    /* n:"BrtCellMeta", */
    f: ep
  },
  /*::[*/
  50: {
    /* n:"BrtValueMeta" */
  },
  /*::[*/
  51: {
    /* n:"BrtMdb" */
    f: z5
  },
  /*::[*/
  52: {
    /* n:"BrtBeginFmd", */
    T: 1
  },
  /*::[*/
  53: {
    /* n:"BrtEndFmd", */
    T: -1
  },
  /*::[*/
  54: {
    /* n:"BrtBeginMdx", */
    T: 1
  },
  /*::[*/
  55: {
    /* n:"BrtEndMdx", */
    T: -1
  },
  /*::[*/
  56: {
    /* n:"BrtBeginMdxTuple", */
    T: 1
  },
  /*::[*/
  57: {
    /* n:"BrtEndMdxTuple", */
    T: -1
  },
  /*::[*/
  58: {
    /* n:"BrtMdxMbrIstr" */
  },
  /*::[*/
  59: {
    /* n:"BrtStr" */
  },
  /*::[*/
  60: {
    /* n:"BrtColInfo", */
    f: t5
  },
  /*::[*/
  62: {
    /* n:"BrtCellRString", */
    f: Sm
  },
  /*::[*/
  63: {
    /* n:"BrtCalcChainItem$", */
    f: K5
  },
  /*::[*/
  64: {
    /* n:"BrtDVal", */
    f: Gm
  },
  /*::[*/
  65: {
    /* n:"BrtSxvcellNum" */
  },
  /*::[*/
  66: {
    /* n:"BrtSxvcellStr" */
  },
  /*::[*/
  67: {
    /* n:"BrtSxvcellBool" */
  },
  /*::[*/
  68: {
    /* n:"BrtSxvcellErr" */
  },
  /*::[*/
  69: {
    /* n:"BrtSxvcellDate" */
  },
  /*::[*/
  70: {
    /* n:"BrtSxvcellNil" */
  },
  /*::[*/
  128: {
    /* n:"BrtFileVersion" */
  },
  /*::[*/
  129: {
    /* n:"BrtBeginSheet", */
    T: 1
  },
  /*::[*/
  130: {
    /* n:"BrtEndSheet", */
    T: -1
  },
  /*::[*/
  131: {
    /* n:"BrtBeginBook", */
    T: 1,
    f: wi,
    p: 0
  },
  /*::[*/
  132: {
    /* n:"BrtEndBook", */
    T: -1
  },
  /*::[*/
  133: {
    /* n:"BrtBeginWsViews", */
    T: 1
  },
  /*::[*/
  134: {
    /* n:"BrtEndWsViews", */
    T: -1
  },
  /*::[*/
  135: {
    /* n:"BrtBeginBookViews", */
    T: 1
  },
  /*::[*/
  136: {
    /* n:"BrtEndBookViews", */
    T: -1
  },
  /*::[*/
  137: {
    /* n:"BrtBeginWsView", */
    T: 1,
    f: Hm
  },
  /*::[*/
  138: {
    /* n:"BrtEndWsView", */
    T: -1
  },
  /*::[*/
  139: {
    /* n:"BrtBeginCsViews", */
    T: 1
  },
  /*::[*/
  140: {
    /* n:"BrtEndCsViews", */
    T: -1
  },
  /*::[*/
  141: {
    /* n:"BrtBeginCsView", */
    T: 1
  },
  /*::[*/
  142: {
    /* n:"BrtEndCsView", */
    T: -1
  },
  /*::[*/
  143: {
    /* n:"BrtBeginBundleShs", */
    T: 1
  },
  /*::[*/
  144: {
    /* n:"BrtEndBundleShs", */
    T: -1
  },
  /*::[*/
  145: {
    /* n:"BrtBeginSheetData", */
    T: 1
  },
  /*::[*/
  146: {
    /* n:"BrtEndSheetData", */
    T: -1
  },
  /*::[*/
  147: {
    /* n:"BrtWsProp", */
    f: Kv
  },
  /*::[*/
  148: {
    /* n:"BrtWsDim", */
    f: Xv,
    p: 16
  },
  /*::[*/
  151: {
    /* n:"BrtPane", */
    f: Rm
  },
  /*::[*/
  152: {
    /* n:"BrtSel" */
  },
  /*::[*/
  153: {
    /* n:"BrtWbProp", */
    f: dx
  },
  /*::[*/
  154: {
    /* n:"BrtWbFactoid" */
  },
  /*::[*/
  155: {
    /* n:"BrtFileRecover" */
  },
  /*::[*/
  156: {
    /* n:"BrtBundleSh", */
    f: cx
  },
  /*::[*/
  157: {
    /* n:"BrtCalcProp" */
  },
  /*::[*/
  158: {
    /* n:"BrtBookView" */
  },
  /*::[*/
  159: {
    /* n:"BrtBeginSst", */
    T: 1,
    f: c5
  },
  /*::[*/
  160: {
    /* n:"BrtEndSst", */
    T: -1
  },
  /*::[*/
  161: {
    /* n:"BrtBeginAFilter", */
    T: 1,
    f: Ba
  },
  /*::[*/
  162: {
    /* n:"BrtEndAFilter", */
    T: -1
  },
  /*::[*/
  163: {
    /* n:"BrtBeginFilterColumn", */
    T: 1
  },
  /*::[*/
  164: {
    /* n:"BrtEndFilterColumn", */
    T: -1
  },
  /*::[*/
  165: {
    /* n:"BrtBeginFilters", */
    T: 1
  },
  /*::[*/
  166: {
    /* n:"BrtEndFilters", */
    T: -1
  },
  /*::[*/
  167: {
    /* n:"BrtFilter" */
  },
  /*::[*/
  168: {
    /* n:"BrtColorFilter" */
  },
  /*::[*/
  169: {
    /* n:"BrtIconFilter" */
  },
  /*::[*/
  170: {
    /* n:"BrtTop10Filter" */
  },
  /*::[*/
  171: {
    /* n:"BrtDynamicFilter" */
  },
  /*::[*/
  172: {
    /* n:"BrtBeginCustomFilters", */
    T: 1
  },
  /*::[*/
  173: {
    /* n:"BrtEndCustomFilters", */
    T: -1
  },
  /*::[*/
  174: {
    /* n:"BrtCustomFilter" */
  },
  /*::[*/
  175: {
    /* n:"BrtAFilterDateGroupItem" */
  },
  /*::[*/
  176: {
    /* n:"BrtMergeCell", */
    f: Pm
  },
  /*::[*/
  177: {
    /* n:"BrtBeginMergeCells", */
    T: 1
  },
  /*::[*/
  178: {
    /* n:"BrtEndMergeCells", */
    T: -1
  },
  /*::[*/
  179: {
    /* n:"BrtBeginPivotCacheDef", */
    T: 1
  },
  /*::[*/
  180: {
    /* n:"BrtEndPivotCacheDef", */
    T: -1
  },
  /*::[*/
  181: {
    /* n:"BrtBeginPCDFields", */
    T: 1
  },
  /*::[*/
  182: {
    /* n:"BrtEndPCDFields", */
    T: -1
  },
  /*::[*/
  183: {
    /* n:"BrtBeginPCDField", */
    T: 1
  },
  /*::[*/
  184: {
    /* n:"BrtEndPCDField", */
    T: -1
  },
  /*::[*/
  185: {
    /* n:"BrtBeginPCDSource", */
    T: 1
  },
  /*::[*/
  186: {
    /* n:"BrtEndPCDSource", */
    T: -1
  },
  /*::[*/
  187: {
    /* n:"BrtBeginPCDSRange", */
    T: 1
  },
  /*::[*/
  188: {
    /* n:"BrtEndPCDSRange", */
    T: -1
  },
  /*::[*/
  189: {
    /* n:"BrtBeginPCDFAtbl", */
    T: 1
  },
  /*::[*/
  190: {
    /* n:"BrtEndPCDFAtbl", */
    T: -1
  },
  /*::[*/
  191: {
    /* n:"BrtBeginPCDIRun", */
    T: 1
  },
  /*::[*/
  192: {
    /* n:"BrtEndPCDIRun", */
    T: -1
  },
  /*::[*/
  193: {
    /* n:"BrtBeginPivotCacheRecords", */
    T: 1
  },
  /*::[*/
  194: {
    /* n:"BrtEndPivotCacheRecords", */
    T: -1
  },
  /*::[*/
  195: {
    /* n:"BrtBeginPCDHierarchies", */
    T: 1
  },
  /*::[*/
  196: {
    /* n:"BrtEndPCDHierarchies", */
    T: -1
  },
  /*::[*/
  197: {
    /* n:"BrtBeginPCDHierarchy", */
    T: 1
  },
  /*::[*/
  198: {
    /* n:"BrtEndPCDHierarchy", */
    T: -1
  },
  /*::[*/
  199: {
    /* n:"BrtBeginPCDHFieldsUsage", */
    T: 1
  },
  /*::[*/
  200: {
    /* n:"BrtEndPCDHFieldsUsage", */
    T: -1
  },
  /*::[*/
  201: {
    /* n:"BrtBeginExtConnection", */
    T: 1
  },
  /*::[*/
  202: {
    /* n:"BrtEndExtConnection", */
    T: -1
  },
  /*::[*/
  203: {
    /* n:"BrtBeginECDbProps", */
    T: 1
  },
  /*::[*/
  204: {
    /* n:"BrtEndECDbProps", */
    T: -1
  },
  /*::[*/
  205: {
    /* n:"BrtBeginECOlapProps", */
    T: 1
  },
  /*::[*/
  206: {
    /* n:"BrtEndECOlapProps", */
    T: -1
  },
  /*::[*/
  207: {
    /* n:"BrtBeginPCDSConsol", */
    T: 1
  },
  /*::[*/
  208: {
    /* n:"BrtEndPCDSConsol", */
    T: -1
  },
  /*::[*/
  209: {
    /* n:"BrtBeginPCDSCPages", */
    T: 1
  },
  /*::[*/
  210: {
    /* n:"BrtEndPCDSCPages", */
    T: -1
  },
  /*::[*/
  211: {
    /* n:"BrtBeginPCDSCPage", */
    T: 1
  },
  /*::[*/
  212: {
    /* n:"BrtEndPCDSCPage", */
    T: -1
  },
  /*::[*/
  213: {
    /* n:"BrtBeginPCDSCPItem", */
    T: 1
  },
  /*::[*/
  214: {
    /* n:"BrtEndPCDSCPItem", */
    T: -1
  },
  /*::[*/
  215: {
    /* n:"BrtBeginPCDSCSets", */
    T: 1
  },
  /*::[*/
  216: {
    /* n:"BrtEndPCDSCSets", */
    T: -1
  },
  /*::[*/
  217: {
    /* n:"BrtBeginPCDSCSet", */
    T: 1
  },
  /*::[*/
  218: {
    /* n:"BrtEndPCDSCSet", */
    T: -1
  },
  /*::[*/
  219: {
    /* n:"BrtBeginPCDFGroup", */
    T: 1
  },
  /*::[*/
  220: {
    /* n:"BrtEndPCDFGroup", */
    T: -1
  },
  /*::[*/
  221: {
    /* n:"BrtBeginPCDFGItems", */
    T: 1
  },
  /*::[*/
  222: {
    /* n:"BrtEndPCDFGItems", */
    T: -1
  },
  /*::[*/
  223: {
    /* n:"BrtBeginPCDFGRange", */
    T: 1
  },
  /*::[*/
  224: {
    /* n:"BrtEndPCDFGRange", */
    T: -1
  },
  /*::[*/
  225: {
    /* n:"BrtBeginPCDFGDiscrete", */
    T: 1
  },
  /*::[*/
  226: {
    /* n:"BrtEndPCDFGDiscrete", */
    T: -1
  },
  /*::[*/
  227: {
    /* n:"BrtBeginPCDSDTupleCache", */
    T: 1
  },
  /*::[*/
  228: {
    /* n:"BrtEndPCDSDTupleCache", */
    T: -1
  },
  /*::[*/
  229: {
    /* n:"BrtBeginPCDSDTCEntries", */
    T: 1
  },
  /*::[*/
  230: {
    /* n:"BrtEndPCDSDTCEntries", */
    T: -1
  },
  /*::[*/
  231: {
    /* n:"BrtBeginPCDSDTCEMembers", */
    T: 1
  },
  /*::[*/
  232: {
    /* n:"BrtEndPCDSDTCEMembers", */
    T: -1
  },
  /*::[*/
  233: {
    /* n:"BrtBeginPCDSDTCEMember", */
    T: 1
  },
  /*::[*/
  234: {
    /* n:"BrtEndPCDSDTCEMember", */
    T: -1
  },
  /*::[*/
  235: {
    /* n:"BrtBeginPCDSDTCQueries", */
    T: 1
  },
  /*::[*/
  236: {
    /* n:"BrtEndPCDSDTCQueries", */
    T: -1
  },
  /*::[*/
  237: {
    /* n:"BrtBeginPCDSDTCQuery", */
    T: 1
  },
  /*::[*/
  238: {
    /* n:"BrtEndPCDSDTCQuery", */
    T: -1
  },
  /*::[*/
  239: {
    /* n:"BrtBeginPCDSDTCSets", */
    T: 1
  },
  /*::[*/
  240: {
    /* n:"BrtEndPCDSDTCSets", */
    T: -1
  },
  /*::[*/
  241: {
    /* n:"BrtBeginPCDSDTCSet", */
    T: 1
  },
  /*::[*/
  242: {
    /* n:"BrtEndPCDSDTCSet", */
    T: -1
  },
  /*::[*/
  243: {
    /* n:"BrtBeginPCDCalcItems", */
    T: 1
  },
  /*::[*/
  244: {
    /* n:"BrtEndPCDCalcItems", */
    T: -1
  },
  /*::[*/
  245: {
    /* n:"BrtBeginPCDCalcItem", */
    T: 1
  },
  /*::[*/
  246: {
    /* n:"BrtEndPCDCalcItem", */
    T: -1
  },
  /*::[*/
  247: {
    /* n:"BrtBeginPRule", */
    T: 1
  },
  /*::[*/
  248: {
    /* n:"BrtEndPRule", */
    T: -1
  },
  /*::[*/
  249: {
    /* n:"BrtBeginPRFilters", */
    T: 1
  },
  /*::[*/
  250: {
    /* n:"BrtEndPRFilters", */
    T: -1
  },
  /*::[*/
  251: {
    /* n:"BrtBeginPRFilter", */
    T: 1
  },
  /*::[*/
  252: {
    /* n:"BrtEndPRFilter", */
    T: -1
  },
  /*::[*/
  253: {
    /* n:"BrtBeginPNames", */
    T: 1
  },
  /*::[*/
  254: {
    /* n:"BrtEndPNames", */
    T: -1
  },
  /*::[*/
  255: {
    /* n:"BrtBeginPName", */
    T: 1
  },
  /*::[*/
  256: {
    /* n:"BrtEndPName", */
    T: -1
  },
  /*::[*/
  257: {
    /* n:"BrtBeginPNPairs", */
    T: 1
  },
  /*::[*/
  258: {
    /* n:"BrtEndPNPairs", */
    T: -1
  },
  /*::[*/
  259: {
    /* n:"BrtBeginPNPair", */
    T: 1
  },
  /*::[*/
  260: {
    /* n:"BrtEndPNPair", */
    T: -1
  },
  /*::[*/
  261: {
    /* n:"BrtBeginECWebProps", */
    T: 1
  },
  /*::[*/
  262: {
    /* n:"BrtEndECWebProps", */
    T: -1
  },
  /*::[*/
  263: {
    /* n:"BrtBeginEcWpTables", */
    T: 1
  },
  /*::[*/
  264: {
    /* n:"BrtEndECWPTables", */
    T: -1
  },
  /*::[*/
  265: {
    /* n:"BrtBeginECParams", */
    T: 1
  },
  /*::[*/
  266: {
    /* n:"BrtEndECParams", */
    T: -1
  },
  /*::[*/
  267: {
    /* n:"BrtBeginECParam", */
    T: 1
  },
  /*::[*/
  268: {
    /* n:"BrtEndECParam", */
    T: -1
  },
  /*::[*/
  269: {
    /* n:"BrtBeginPCDKPIs", */
    T: 1
  },
  /*::[*/
  270: {
    /* n:"BrtEndPCDKPIs", */
    T: -1
  },
  /*::[*/
  271: {
    /* n:"BrtBeginPCDKPI", */
    T: 1
  },
  /*::[*/
  272: {
    /* n:"BrtEndPCDKPI", */
    T: -1
  },
  /*::[*/
  273: {
    /* n:"BrtBeginDims", */
    T: 1
  },
  /*::[*/
  274: {
    /* n:"BrtEndDims", */
    T: -1
  },
  /*::[*/
  275: {
    /* n:"BrtBeginDim", */
    T: 1
  },
  /*::[*/
  276: {
    /* n:"BrtEndDim", */
    T: -1
  },
  /*::[*/
  277: {
    /* n:"BrtIndexPartEnd" */
  },
  /*::[*/
  278: {
    /* n:"BrtBeginStyleSheet", */
    T: 1
  },
  /*::[*/
  279: {
    /* n:"BrtEndStyleSheet", */
    T: -1
  },
  /*::[*/
  280: {
    /* n:"BrtBeginSXView", */
    T: 1
  },
  /*::[*/
  281: {
    /* n:"BrtEndSXVI", */
    T: -1
  },
  /*::[*/
  282: {
    /* n:"BrtBeginSXVI", */
    T: 1
  },
  /*::[*/
  283: {
    /* n:"BrtBeginSXVIs", */
    T: 1
  },
  /*::[*/
  284: {
    /* n:"BrtEndSXVIs", */
    T: -1
  },
  /*::[*/
  285: {
    /* n:"BrtBeginSXVD", */
    T: 1
  },
  /*::[*/
  286: {
    /* n:"BrtEndSXVD", */
    T: -1
  },
  /*::[*/
  287: {
    /* n:"BrtBeginSXVDs", */
    T: 1
  },
  /*::[*/
  288: {
    /* n:"BrtEndSXVDs", */
    T: -1
  },
  /*::[*/
  289: {
    /* n:"BrtBeginSXPI", */
    T: 1
  },
  /*::[*/
  290: {
    /* n:"BrtEndSXPI", */
    T: -1
  },
  /*::[*/
  291: {
    /* n:"BrtBeginSXPIs", */
    T: 1
  },
  /*::[*/
  292: {
    /* n:"BrtEndSXPIs", */
    T: -1
  },
  /*::[*/
  293: {
    /* n:"BrtBeginSXDI", */
    T: 1
  },
  /*::[*/
  294: {
    /* n:"BrtEndSXDI", */
    T: -1
  },
  /*::[*/
  295: {
    /* n:"BrtBeginSXDIs", */
    T: 1
  },
  /*::[*/
  296: {
    /* n:"BrtEndSXDIs", */
    T: -1
  },
  /*::[*/
  297: {
    /* n:"BrtBeginSXLI", */
    T: 1
  },
  /*::[*/
  298: {
    /* n:"BrtEndSXLI", */
    T: -1
  },
  /*::[*/
  299: {
    /* n:"BrtBeginSXLIRws", */
    T: 1
  },
  /*::[*/
  300: {
    /* n:"BrtEndSXLIRws", */
    T: -1
  },
  /*::[*/
  301: {
    /* n:"BrtBeginSXLICols", */
    T: 1
  },
  /*::[*/
  302: {
    /* n:"BrtEndSXLICols", */
    T: -1
  },
  /*::[*/
  303: {
    /* n:"BrtBeginSXFormat", */
    T: 1
  },
  /*::[*/
  304: {
    /* n:"BrtEndSXFormat", */
    T: -1
  },
  /*::[*/
  305: {
    /* n:"BrtBeginSXFormats", */
    T: 1
  },
  /*::[*/
  306: {
    /* n:"BrtEndSxFormats", */
    T: -1
  },
  /*::[*/
  307: {
    /* n:"BrtBeginSxSelect", */
    T: 1
  },
  /*::[*/
  308: {
    /* n:"BrtEndSxSelect", */
    T: -1
  },
  /*::[*/
  309: {
    /* n:"BrtBeginISXVDRws", */
    T: 1
  },
  /*::[*/
  310: {
    /* n:"BrtEndISXVDRws", */
    T: -1
  },
  /*::[*/
  311: {
    /* n:"BrtBeginISXVDCols", */
    T: 1
  },
  /*::[*/
  312: {
    /* n:"BrtEndISXVDCols", */
    T: -1
  },
  /*::[*/
  313: {
    /* n:"BrtEndSXLocation", */
    T: -1
  },
  /*::[*/
  314: {
    /* n:"BrtBeginSXLocation", */
    T: 1
  },
  /*::[*/
  315: {
    /* n:"BrtEndSXView", */
    T: -1
  },
  /*::[*/
  316: {
    /* n:"BrtBeginSXTHs", */
    T: 1
  },
  /*::[*/
  317: {
    /* n:"BrtEndSXTHs", */
    T: -1
  },
  /*::[*/
  318: {
    /* n:"BrtBeginSXTH", */
    T: 1
  },
  /*::[*/
  319: {
    /* n:"BrtEndSXTH", */
    T: -1
  },
  /*::[*/
  320: {
    /* n:"BrtBeginISXTHRws", */
    T: 1
  },
  /*::[*/
  321: {
    /* n:"BrtEndISXTHRws", */
    T: -1
  },
  /*::[*/
  322: {
    /* n:"BrtBeginISXTHCols", */
    T: 1
  },
  /*::[*/
  323: {
    /* n:"BrtEndISXTHCols", */
    T: -1
  },
  /*::[*/
  324: {
    /* n:"BrtBeginSXTDMPS", */
    T: 1
  },
  /*::[*/
  325: {
    /* n:"BrtEndSXTDMPs", */
    T: -1
  },
  /*::[*/
  326: {
    /* n:"BrtBeginSXTDMP", */
    T: 1
  },
  /*::[*/
  327: {
    /* n:"BrtEndSXTDMP", */
    T: -1
  },
  /*::[*/
  328: {
    /* n:"BrtBeginSXTHItems", */
    T: 1
  },
  /*::[*/
  329: {
    /* n:"BrtEndSXTHItems", */
    T: -1
  },
  /*::[*/
  330: {
    /* n:"BrtBeginSXTHItem", */
    T: 1
  },
  /*::[*/
  331: {
    /* n:"BrtEndSXTHItem", */
    T: -1
  },
  /*::[*/
  332: {
    /* n:"BrtBeginMetadata", */
    T: 1
  },
  /*::[*/
  333: {
    /* n:"BrtEndMetadata", */
    T: -1
  },
  /*::[*/
  334: {
    /* n:"BrtBeginEsmdtinfo", */
    T: 1
  },
  /*::[*/
  335: {
    /* n:"BrtMdtinfo", */
    f: H5
  },
  /*::[*/
  336: {
    /* n:"BrtEndEsmdtinfo", */
    T: -1
  },
  /*::[*/
  337: {
    /* n:"BrtBeginEsmdb", */
    f: X5,
    T: 1
  },
  /*::[*/
  338: {
    /* n:"BrtEndEsmdb", */
    T: -1
  },
  /*::[*/
  339: {
    /* n:"BrtBeginEsfmd", */
    T: 1
  },
  /*::[*/
  340: {
    /* n:"BrtEndEsfmd", */
    T: -1
  },
  /*::[*/
  341: {
    /* n:"BrtBeginSingleCells", */
    T: 1
  },
  /*::[*/
  342: {
    /* n:"BrtEndSingleCells", */
    T: -1
  },
  /*::[*/
  343: {
    /* n:"BrtBeginList", */
    T: 1
  },
  /*::[*/
  344: {
    /* n:"BrtEndList", */
    T: -1
  },
  /*::[*/
  345: {
    /* n:"BrtBeginListCols", */
    T: 1
  },
  /*::[*/
  346: {
    /* n:"BrtEndListCols", */
    T: -1
  },
  /*::[*/
  347: {
    /* n:"BrtBeginListCol", */
    T: 1
  },
  /*::[*/
  348: {
    /* n:"BrtEndListCol", */
    T: -1
  },
  /*::[*/
  349: {
    /* n:"BrtBeginListXmlCPr", */
    T: 1
  },
  /*::[*/
  350: {
    /* n:"BrtEndListXmlCPr", */
    T: -1
  },
  /*::[*/
  351: {
    /* n:"BrtListCCFmla" */
  },
  /*::[*/
  352: {
    /* n:"BrtListTrFmla" */
  },
  /*::[*/
  353: {
    /* n:"BrtBeginExternals", */
    T: 1
  },
  /*::[*/
  354: {
    /* n:"BrtEndExternals", */
    T: -1
  },
  /*::[*/
  355: {
    /* n:"BrtSupBookSrc", */
    f: wl
  },
  /*::[*/
  357: {
    /* n:"BrtSupSelf" */
  },
  /*::[*/
  358: {
    /* n:"BrtSupSame" */
  },
  /*::[*/
  359: {
    /* n:"BrtSupTabs" */
  },
  /*::[*/
  360: {
    /* n:"BrtBeginSupBook", */
    T: 1
  },
  /*::[*/
  361: {
    /* n:"BrtPlaceholderName" */
  },
  /*::[*/
  362: {
    /* n:"BrtExternSheet", */
    f: $p
  },
  /*::[*/
  363: {
    /* n:"BrtExternTableStart" */
  },
  /*::[*/
  364: {
    /* n:"BrtExternTableEnd" */
  },
  /*::[*/
  366: {
    /* n:"BrtExternRowHdr" */
  },
  /*::[*/
  367: {
    /* n:"BrtExternCellBlank" */
  },
  /*::[*/
  368: {
    /* n:"BrtExternCellReal" */
  },
  /*::[*/
  369: {
    /* n:"BrtExternCellBool" */
  },
  /*::[*/
  370: {
    /* n:"BrtExternCellError" */
  },
  /*::[*/
  371: {
    /* n:"BrtExternCellString" */
  },
  /*::[*/
  372: {
    /* n:"BrtBeginEsmdx", */
    T: 1
  },
  /*::[*/
  373: {
    /* n:"BrtEndEsmdx", */
    T: -1
  },
  /*::[*/
  374: {
    /* n:"BrtBeginMdxSet", */
    T: 1
  },
  /*::[*/
  375: {
    /* n:"BrtEndMdxSet", */
    T: -1
  },
  /*::[*/
  376: {
    /* n:"BrtBeginMdxMbrProp", */
    T: 1
  },
  /*::[*/
  377: {
    /* n:"BrtEndMdxMbrProp", */
    T: -1
  },
  /*::[*/
  378: {
    /* n:"BrtBeginMdxKPI", */
    T: 1
  },
  /*::[*/
  379: {
    /* n:"BrtEndMdxKPI", */
    T: -1
  },
  /*::[*/
  380: {
    /* n:"BrtBeginEsstr", */
    T: 1
  },
  /*::[*/
  381: {
    /* n:"BrtEndEsstr", */
    T: -1
  },
  /*::[*/
  382: {
    /* n:"BrtBeginPRFItem", */
    T: 1
  },
  /*::[*/
  383: {
    /* n:"BrtEndPRFItem", */
    T: -1
  },
  /*::[*/
  384: {
    /* n:"BrtBeginPivotCacheIDs", */
    T: 1
  },
  /*::[*/
  385: {
    /* n:"BrtEndPivotCacheIDs", */
    T: -1
  },
  /*::[*/
  386: {
    /* n:"BrtBeginPivotCacheID", */
    T: 1
  },
  /*::[*/
  387: {
    /* n:"BrtEndPivotCacheID", */
    T: -1
  },
  /*::[*/
  388: {
    /* n:"BrtBeginISXVIs", */
    T: 1
  },
  /*::[*/
  389: {
    /* n:"BrtEndISXVIs", */
    T: -1
  },
  /*::[*/
  390: {
    /* n:"BrtBeginColInfos", */
    T: 1
  },
  /*::[*/
  391: {
    /* n:"BrtEndColInfos", */
    T: -1
  },
  /*::[*/
  392: {
    /* n:"BrtBeginRwBrk", */
    T: 1
  },
  /*::[*/
  393: {
    /* n:"BrtEndRwBrk", */
    T: -1
  },
  /*::[*/
  394: {
    /* n:"BrtBeginColBrk", */
    T: 1
  },
  /*::[*/
  395: {
    /* n:"BrtEndColBrk", */
    T: -1
  },
  /*::[*/
  396: {
    /* n:"BrtBrk" */
  },
  /*::[*/
  397: {
    /* n:"BrtUserBookView" */
  },
  /*::[*/
  398: {
    /* n:"BrtInfo" */
  },
  /*::[*/
  399: {
    /* n:"BrtCUsr" */
  },
  /*::[*/
  400: {
    /* n:"BrtUsr" */
  },
  /*::[*/
  401: {
    /* n:"BrtBeginUsers", */
    T: 1
  },
  /*::[*/
  403: {
    /* n:"BrtEOF" */
  },
  /*::[*/
  404: {
    /* n:"BrtUCR" */
  },
  /*::[*/
  405: {
    /* n:"BrtRRInsDel" */
  },
  /*::[*/
  406: {
    /* n:"BrtRREndInsDel" */
  },
  /*::[*/
  407: {
    /* n:"BrtRRMove" */
  },
  /*::[*/
  408: {
    /* n:"BrtRREndMove" */
  },
  /*::[*/
  409: {
    /* n:"BrtRRChgCell" */
  },
  /*::[*/
  410: {
    /* n:"BrtRREndChgCell" */
  },
  /*::[*/
  411: {
    /* n:"BrtRRHeader" */
  },
  /*::[*/
  412: {
    /* n:"BrtRRUserView" */
  },
  /*::[*/
  413: {
    /* n:"BrtRRRenSheet" */
  },
  /*::[*/
  414: {
    /* n:"BrtRRInsertSh" */
  },
  /*::[*/
  415: {
    /* n:"BrtRRDefName" */
  },
  /*::[*/
  416: {
    /* n:"BrtRRNote" */
  },
  /*::[*/
  417: {
    /* n:"BrtRRConflict" */
  },
  /*::[*/
  418: {
    /* n:"BrtRRTQSIF" */
  },
  /*::[*/
  419: {
    /* n:"BrtRRFormat" */
  },
  /*::[*/
  420: {
    /* n:"BrtRREndFormat" */
  },
  /*::[*/
  421: {
    /* n:"BrtRRAutoFmt" */
  },
  /*::[*/
  422: {
    /* n:"BrtBeginUserShViews", */
    T: 1
  },
  /*::[*/
  423: {
    /* n:"BrtBeginUserShView", */
    T: 1
  },
  /*::[*/
  424: {
    /* n:"BrtEndUserShView", */
    T: -1
  },
  /*::[*/
  425: {
    /* n:"BrtEndUserShViews", */
    T: -1
  },
  /*::[*/
  426: {
    /* n:"BrtArrFmla", */
    f: Mm
  },
  /*::[*/
  427: {
    /* n:"BrtShrFmla", */
    f: Bm
  },
  /*::[*/
  428: {
    /* n:"BrtTable" */
  },
  /*::[*/
  429: {
    /* n:"BrtBeginExtConnections", */
    T: 1
  },
  /*::[*/
  430: {
    /* n:"BrtEndExtConnections", */
    T: -1
  },
  /*::[*/
  431: {
    /* n:"BrtBeginPCDCalcMems", */
    T: 1
  },
  /*::[*/
  432: {
    /* n:"BrtEndPCDCalcMems", */
    T: -1
  },
  /*::[*/
  433: {
    /* n:"BrtBeginPCDCalcMem", */
    T: 1
  },
  /*::[*/
  434: {
    /* n:"BrtEndPCDCalcMem", */
    T: -1
  },
  /*::[*/
  435: {
    /* n:"BrtBeginPCDHGLevels", */
    T: 1
  },
  /*::[*/
  436: {
    /* n:"BrtEndPCDHGLevels", */
    T: -1
  },
  /*::[*/
  437: {
    /* n:"BrtBeginPCDHGLevel", */
    T: 1
  },
  /*::[*/
  438: {
    /* n:"BrtEndPCDHGLevel", */
    T: -1
  },
  /*::[*/
  439: {
    /* n:"BrtBeginPCDHGLGroups", */
    T: 1
  },
  /*::[*/
  440: {
    /* n:"BrtEndPCDHGLGroups", */
    T: -1
  },
  /*::[*/
  441: {
    /* n:"BrtBeginPCDHGLGroup", */
    T: 1
  },
  /*::[*/
  442: {
    /* n:"BrtEndPCDHGLGroup", */
    T: -1
  },
  /*::[*/
  443: {
    /* n:"BrtBeginPCDHGLGMembers", */
    T: 1
  },
  /*::[*/
  444: {
    /* n:"BrtEndPCDHGLGMembers", */
    T: -1
  },
  /*::[*/
  445: {
    /* n:"BrtBeginPCDHGLGMember", */
    T: 1
  },
  /*::[*/
  446: {
    /* n:"BrtEndPCDHGLGMember", */
    T: -1
  },
  /*::[*/
  447: {
    /* n:"BrtBeginQSI", */
    T: 1
  },
  /*::[*/
  448: {
    /* n:"BrtEndQSI", */
    T: -1
  },
  /*::[*/
  449: {
    /* n:"BrtBeginQSIR", */
    T: 1
  },
  /*::[*/
  450: {
    /* n:"BrtEndQSIR", */
    T: -1
  },
  /*::[*/
  451: {
    /* n:"BrtBeginDeletedNames", */
    T: 1
  },
  /*::[*/
  452: {
    /* n:"BrtEndDeletedNames", */
    T: -1
  },
  /*::[*/
  453: {
    /* n:"BrtBeginDeletedName", */
    T: 1
  },
  /*::[*/
  454: {
    /* n:"BrtEndDeletedName", */
    T: -1
  },
  /*::[*/
  455: {
    /* n:"BrtBeginQSIFs", */
    T: 1
  },
  /*::[*/
  456: {
    /* n:"BrtEndQSIFs", */
    T: -1
  },
  /*::[*/
  457: {
    /* n:"BrtBeginQSIF", */
    T: 1
  },
  /*::[*/
  458: {
    /* n:"BrtEndQSIF", */
    T: -1
  },
  /*::[*/
  459: {
    /* n:"BrtBeginAutoSortScope", */
    T: 1
  },
  /*::[*/
  460: {
    /* n:"BrtEndAutoSortScope", */
    T: -1
  },
  /*::[*/
  461: {
    /* n:"BrtBeginConditionalFormatting", */
    T: 1
  },
  /*::[*/
  462: {
    /* n:"BrtEndConditionalFormatting", */
    T: -1
  },
  /*::[*/
  463: {
    /* n:"BrtBeginCFRule", */
    T: 1
  },
  /*::[*/
  464: {
    /* n:"BrtEndCFRule", */
    T: -1
  },
  /*::[*/
  465: {
    /* n:"BrtBeginIconSet", */
    T: 1
  },
  /*::[*/
  466: {
    /* n:"BrtEndIconSet", */
    T: -1
  },
  /*::[*/
  467: {
    /* n:"BrtBeginDatabar", */
    T: 1
  },
  /*::[*/
  468: {
    /* n:"BrtEndDatabar", */
    T: -1
  },
  /*::[*/
  469: {
    /* n:"BrtBeginColorScale", */
    T: 1
  },
  /*::[*/
  470: {
    /* n:"BrtEndColorScale", */
    T: -1
  },
  /*::[*/
  471: {
    /* n:"BrtCFVO" */
  },
  /*::[*/
  472: {
    /* n:"BrtExternValueMeta" */
  },
  /*::[*/
  473: {
    /* n:"BrtBeginColorPalette", */
    T: 1
  },
  /*::[*/
  474: {
    /* n:"BrtEndColorPalette", */
    T: -1
  },
  /*::[*/
  475: {
    /* n:"BrtIndexedColor" */
  },
  /*::[*/
  476: {
    /* n:"BrtMargins", */
    f: Um
  },
  /*::[*/
  477: {
    /* n:"BrtPrintOptions" */
  },
  /*::[*/
  478: {
    /* n:"BrtPageSetup" */
  },
  /*::[*/
  479: {
    /* n:"BrtBeginHeaderFooter", */
    T: 1
  },
  /*::[*/
  480: {
    /* n:"BrtEndHeaderFooter", */
    T: -1
  },
  /*::[*/
  481: {
    /* n:"BrtBeginSXCrtFormat", */
    T: 1
  },
  /*::[*/
  482: {
    /* n:"BrtEndSXCrtFormat", */
    T: -1
  },
  /*::[*/
  483: {
    /* n:"BrtBeginSXCrtFormats", */
    T: 1
  },
  /*::[*/
  484: {
    /* n:"BrtEndSXCrtFormats", */
    T: -1
  },
  /*::[*/
  485: {
    /* n:"BrtWsFmtInfo", */
    f: $v
  },
  /*::[*/
  486: {
    /* n:"BrtBeginMgs", */
    T: 1
  },
  /*::[*/
  487: {
    /* n:"BrtEndMGs", */
    T: -1
  },
  /*::[*/
  488: {
    /* n:"BrtBeginMGMaps", */
    T: 1
  },
  /*::[*/
  489: {
    /* n:"BrtEndMGMaps", */
    T: -1
  },
  /*::[*/
  490: {
    /* n:"BrtBeginMG", */
    T: 1
  },
  /*::[*/
  491: {
    /* n:"BrtEndMG", */
    T: -1
  },
  /*::[*/
  492: {
    /* n:"BrtBeginMap", */
    T: 1
  },
  /*::[*/
  493: {
    /* n:"BrtEndMap", */
    T: -1
  },
  /*::[*/
  494: {
    /* n:"BrtHLink", */
    f: Om
  },
  /*::[*/
  495: {
    /* n:"BrtBeginDCon", */
    T: 1
  },
  /*::[*/
  496: {
    /* n:"BrtEndDCon", */
    T: -1
  },
  /*::[*/
  497: {
    /* n:"BrtBeginDRefs", */
    T: 1
  },
  /*::[*/
  498: {
    /* n:"BrtEndDRefs", */
    T: -1
  },
  /*::[*/
  499: {
    /* n:"BrtDRef" */
  },
  /*::[*/
  500: {
    /* n:"BrtBeginScenMan", */
    T: 1
  },
  /*::[*/
  501: {
    /* n:"BrtEndScenMan", */
    T: -1
  },
  /*::[*/
  502: {
    /* n:"BrtBeginSct", */
    T: 1
  },
  /*::[*/
  503: {
    /* n:"BrtEndSct", */
    T: -1
  },
  /*::[*/
  504: {
    /* n:"BrtSlc" */
  },
  /*::[*/
  505: {
    /* n:"BrtBeginDXFs", */
    T: 1
  },
  /*::[*/
  506: {
    /* n:"BrtEndDXFs", */
    T: -1
  },
  /*::[*/
  507: {
    /* n:"BrtDXF" */
  },
  /*::[*/
  508: {
    /* n:"BrtBeginTableStyles", */
    T: 1
  },
  /*::[*/
  509: {
    /* n:"BrtEndTableStyles", */
    T: -1
  },
  /*::[*/
  510: {
    /* n:"BrtBeginTableStyle", */
    T: 1
  },
  /*::[*/
  511: {
    /* n:"BrtEndTableStyle", */
    T: -1
  },
  /*::[*/
  512: {
    /* n:"BrtTableStyleElement" */
  },
  /*::[*/
  513: {
    /* n:"BrtTableStyleClient" */
  },
  /*::[*/
  514: {
    /* n:"BrtBeginVolDeps", */
    T: 1
  },
  /*::[*/
  515: {
    /* n:"BrtEndVolDeps", */
    T: -1
  },
  /*::[*/
  516: {
    /* n:"BrtBeginVolType", */
    T: 1
  },
  /*::[*/
  517: {
    /* n:"BrtEndVolType", */
    T: -1
  },
  /*::[*/
  518: {
    /* n:"BrtBeginVolMain", */
    T: 1
  },
  /*::[*/
  519: {
    /* n:"BrtEndVolMain", */
    T: -1
  },
  /*::[*/
  520: {
    /* n:"BrtBeginVolTopic", */
    T: 1
  },
  /*::[*/
  521: {
    /* n:"BrtEndVolTopic", */
    T: -1
  },
  /*::[*/
  522: {
    /* n:"BrtVolSubtopic" */
  },
  /*::[*/
  523: {
    /* n:"BrtVolRef" */
  },
  /*::[*/
  524: {
    /* n:"BrtVolNum" */
  },
  /*::[*/
  525: {
    /* n:"BrtVolErr" */
  },
  /*::[*/
  526: {
    /* n:"BrtVolStr" */
  },
  /*::[*/
  527: {
    /* n:"BrtVolBool" */
  },
  /*::[*/
  528: {
    /* n:"BrtBeginCalcChain$", */
    T: 1
  },
  /*::[*/
  529: {
    /* n:"BrtEndCalcChain$", */
    T: -1
  },
  /*::[*/
  530: {
    /* n:"BrtBeginSortState", */
    T: 1
  },
  /*::[*/
  531: {
    /* n:"BrtEndSortState", */
    T: -1
  },
  /*::[*/
  532: {
    /* n:"BrtBeginSortCond", */
    T: 1
  },
  /*::[*/
  533: {
    /* n:"BrtEndSortCond", */
    T: -1
  },
  /*::[*/
  534: {
    /* n:"BrtBookProtection" */
  },
  /*::[*/
  535: {
    /* n:"BrtSheetProtection" */
  },
  /*::[*/
  536: {
    /* n:"BrtRangeProtection" */
  },
  /*::[*/
  537: {
    /* n:"BrtPhoneticInfo" */
  },
  /*::[*/
  538: {
    /* n:"BrtBeginECTxtWiz", */
    T: 1
  },
  /*::[*/
  539: {
    /* n:"BrtEndECTxtWiz", */
    T: -1
  },
  /*::[*/
  540: {
    /* n:"BrtBeginECTWFldInfoLst", */
    T: 1
  },
  /*::[*/
  541: {
    /* n:"BrtEndECTWFldInfoLst", */
    T: -1
  },
  /*::[*/
  542: {
    /* n:"BrtBeginECTwFldInfo", */
    T: 1
  },
  /*::[*/
  548: {
    /* n:"BrtFileSharing" */
  },
  /*::[*/
  549: {
    /* n:"BrtOleSize" */
  },
  /*::[*/
  550: {
    /* n:"BrtDrawing", */
    f: wl
  },
  /*::[*/
  551: {
    /* n:"BrtLegacyDrawing" */
  },
  /*::[*/
  552: {
    /* n:"BrtLegacyDrawingHF" */
  },
  /*::[*/
  553: {
    /* n:"BrtWebOpt" */
  },
  /*::[*/
  554: {
    /* n:"BrtBeginWebPubItems", */
    T: 1
  },
  /*::[*/
  555: {
    /* n:"BrtEndWebPubItems", */
    T: -1
  },
  /*::[*/
  556: {
    /* n:"BrtBeginWebPubItem", */
    T: 1
  },
  /*::[*/
  557: {
    /* n:"BrtEndWebPubItem", */
    T: -1
  },
  /*::[*/
  558: {
    /* n:"BrtBeginSXCondFmt", */
    T: 1
  },
  /*::[*/
  559: {
    /* n:"BrtEndSXCondFmt", */
    T: -1
  },
  /*::[*/
  560: {
    /* n:"BrtBeginSXCondFmts", */
    T: 1
  },
  /*::[*/
  561: {
    /* n:"BrtEndSXCondFmts", */
    T: -1
  },
  /*::[*/
  562: {
    /* n:"BrtBkHim" */
  },
  /*::[*/
  564: {
    /* n:"BrtColor" */
  },
  /*::[*/
  565: {
    /* n:"BrtBeginIndexedColors", */
    T: 1
  },
  /*::[*/
  566: {
    /* n:"BrtEndIndexedColors", */
    T: -1
  },
  /*::[*/
  569: {
    /* n:"BrtBeginMRUColors", */
    T: 1
  },
  /*::[*/
  570: {
    /* n:"BrtEndMRUColors", */
    T: -1
  },
  /*::[*/
  572: {
    /* n:"BrtMRUColor" */
  },
  /*::[*/
  573: {
    /* n:"BrtBeginDVals", */
    T: 1
  },
  /*::[*/
  574: {
    /* n:"BrtEndDVals", */
    T: -1
  },
  /*::[*/
  577: {
    /* n:"BrtSupNameStart" */
  },
  /*::[*/
  578: {
    /* n:"BrtSupNameValueStart" */
  },
  /*::[*/
  579: {
    /* n:"BrtSupNameValueEnd" */
  },
  /*::[*/
  580: {
    /* n:"BrtSupNameNum" */
  },
  /*::[*/
  581: {
    /* n:"BrtSupNameErr" */
  },
  /*::[*/
  582: {
    /* n:"BrtSupNameSt" */
  },
  /*::[*/
  583: {
    /* n:"BrtSupNameNil" */
  },
  /*::[*/
  584: {
    /* n:"BrtSupNameBool" */
  },
  /*::[*/
  585: {
    /* n:"BrtSupNameFmla" */
  },
  /*::[*/
  586: {
    /* n:"BrtSupNameBits" */
  },
  /*::[*/
  587: {
    /* n:"BrtSupNameEnd" */
  },
  /*::[*/
  588: {
    /* n:"BrtEndSupBook", */
    T: -1
  },
  /*::[*/
  589: {
    /* n:"BrtCellSmartTagProperty" */
  },
  /*::[*/
  590: {
    /* n:"BrtBeginCellSmartTag", */
    T: 1
  },
  /*::[*/
  591: {
    /* n:"BrtEndCellSmartTag", */
    T: -1
  },
  /*::[*/
  592: {
    /* n:"BrtBeginCellSmartTags", */
    T: 1
  },
  /*::[*/
  593: {
    /* n:"BrtEndCellSmartTags", */
    T: -1
  },
  /*::[*/
  594: {
    /* n:"BrtBeginSmartTags", */
    T: 1
  },
  /*::[*/
  595: {
    /* n:"BrtEndSmartTags", */
    T: -1
  },
  /*::[*/
  596: {
    /* n:"BrtSmartTagType" */
  },
  /*::[*/
  597: {
    /* n:"BrtBeginSmartTagTypes", */
    T: 1
  },
  /*::[*/
  598: {
    /* n:"BrtEndSmartTagTypes", */
    T: -1
  },
  /*::[*/
  599: {
    /* n:"BrtBeginSXFilters", */
    T: 1
  },
  /*::[*/
  600: {
    /* n:"BrtEndSXFilters", */
    T: -1
  },
  /*::[*/
  601: {
    /* n:"BrtBeginSXFILTER", */
    T: 1
  },
  /*::[*/
  602: {
    /* n:"BrtEndSXFilter", */
    T: -1
  },
  /*::[*/
  603: {
    /* n:"BrtBeginFills", */
    T: 1
  },
  /*::[*/
  604: {
    /* n:"BrtEndFills", */
    T: -1
  },
  /*::[*/
  605: {
    /* n:"BrtBeginCellWatches", */
    T: 1
  },
  /*::[*/
  606: {
    /* n:"BrtEndCellWatches", */
    T: -1
  },
  /*::[*/
  607: {
    /* n:"BrtCellWatch" */
  },
  /*::[*/
  608: {
    /* n:"BrtBeginCRErrs", */
    T: 1
  },
  /*::[*/
  609: {
    /* n:"BrtEndCRErrs", */
    T: -1
  },
  /*::[*/
  610: {
    /* n:"BrtCrashRecErr" */
  },
  /*::[*/
  611: {
    /* n:"BrtBeginFonts", */
    T: 1
  },
  /*::[*/
  612: {
    /* n:"BrtEndFonts", */
    T: -1
  },
  /*::[*/
  613: {
    /* n:"BrtBeginBorders", */
    T: 1
  },
  /*::[*/
  614: {
    /* n:"BrtEndBorders", */
    T: -1
  },
  /*::[*/
  615: {
    /* n:"BrtBeginFmts", */
    T: 1
  },
  /*::[*/
  616: {
    /* n:"BrtEndFmts", */
    T: -1
  },
  /*::[*/
  617: {
    /* n:"BrtBeginCellXFs", */
    T: 1
  },
  /*::[*/
  618: {
    /* n:"BrtEndCellXFs", */
    T: -1
  },
  /*::[*/
  619: {
    /* n:"BrtBeginStyles", */
    T: 1
  },
  /*::[*/
  620: {
    /* n:"BrtEndStyles", */
    T: -1
  },
  /*::[*/
  625: {
    /* n:"BrtBigName" */
  },
  /*::[*/
  626: {
    /* n:"BrtBeginCellStyleXFs", */
    T: 1
  },
  /*::[*/
  627: {
    /* n:"BrtEndCellStyleXFs", */
    T: -1
  },
  /*::[*/
  628: {
    /* n:"BrtBeginComments", */
    T: 1
  },
  /*::[*/
  629: {
    /* n:"BrtEndComments", */
    T: -1
  },
  /*::[*/
  630: {
    /* n:"BrtBeginCommentAuthors", */
    T: 1
  },
  /*::[*/
  631: {
    /* n:"BrtEndCommentAuthors", */
    T: -1
  },
  /*::[*/
  632: {
    /* n:"BrtCommentAuthor", */
    f: tg
  },
  /*::[*/
  633: {
    /* n:"BrtBeginCommentList", */
    T: 1
  },
  /*::[*/
  634: {
    /* n:"BrtEndCommentList", */
    T: -1
  },
  /*::[*/
  635: {
    /* n:"BrtBeginComment", */
    T: 1,
    f: Q5
  },
  /*::[*/
  636: {
    /* n:"BrtEndComment", */
    T: -1
  },
  /*::[*/
  637: {
    /* n:"BrtCommentText", */
    f: ip
  },
  /*::[*/
  638: {
    /* n:"BrtBeginOleObjects", */
    T: 1
  },
  /*::[*/
  639: {
    /* n:"BrtOleObject" */
  },
  /*::[*/
  640: {
    /* n:"BrtEndOleObjects", */
    T: -1
  },
  /*::[*/
  641: {
    /* n:"BrtBeginSxrules", */
    T: 1
  },
  /*::[*/
  642: {
    /* n:"BrtEndSxRules", */
    T: -1
  },
  /*::[*/
  643: {
    /* n:"BrtBeginActiveXControls", */
    T: 1
  },
  /*::[*/
  644: {
    /* n:"BrtActiveX" */
  },
  /*::[*/
  645: {
    /* n:"BrtEndActiveXControls", */
    T: -1
  },
  /*::[*/
  646: {
    /* n:"BrtBeginPCDSDTCEMembersSortBy", */
    T: 1
  },
  /*::[*/
  648: {
    /* n:"BrtBeginCellIgnoreECs", */
    T: 1
  },
  /*::[*/
  649: {
    /* n:"BrtCellIgnoreEC" */
  },
  /*::[*/
  650: {
    /* n:"BrtEndCellIgnoreECs", */
    T: -1
  },
  /*::[*/
  651: {
    /* n:"BrtCsProp", */
    f: ax
  },
  /*::[*/
  652: {
    /* n:"BrtCsPageSetup" */
  },
  /*::[*/
  653: {
    /* n:"BrtBeginUserCsViews", */
    T: 1
  },
  /*::[*/
  654: {
    /* n:"BrtEndUserCsViews", */
    T: -1
  },
  /*::[*/
  655: {
    /* n:"BrtBeginUserCsView", */
    T: 1
  },
  /*::[*/
  656: {
    /* n:"BrtEndUserCsView", */
    T: -1
  },
  /*::[*/
  657: {
    /* n:"BrtBeginPcdSFCIEntries", */
    T: 1
  },
  /*::[*/
  658: {
    /* n:"BrtEndPCDSFCIEntries", */
    T: -1
  },
  /*::[*/
  659: {
    /* n:"BrtPCDSFCIEntry" */
  },
  /*::[*/
  660: {
    /* n:"BrtBeginListParts", */
    T: 1
  },
  /*::[*/
  661: {
    /* n:"BrtListPart" */
  },
  /*::[*/
  662: {
    /* n:"BrtEndListParts", */
    T: -1
  },
  /*::[*/
  663: {
    /* n:"BrtSheetCalcProp" */
  },
  /*::[*/
  664: {
    /* n:"BrtBeginFnGroup", */
    T: 1
  },
  /*::[*/
  665: {
    /* n:"BrtFnGroup" */
  },
  /*::[*/
  666: {
    /* n:"BrtEndFnGroup", */
    T: -1
  },
  /*::[*/
  667: {
    /* n:"BrtSupAddin" */
  },
  /*::[*/
  668: {
    /* n:"BrtSXTDMPOrder" */
  },
  /*::[*/
  669: {
    /* n:"BrtCsProtection" */
  },
  /*::[*/
  671: {
    /* n:"BrtBeginWsSortMap", */
    T: 1
  },
  /*::[*/
  672: {
    /* n:"BrtEndWsSortMap", */
    T: -1
  },
  /*::[*/
  673: {
    /* n:"BrtBeginRRSort", */
    T: 1
  },
  /*::[*/
  674: {
    /* n:"BrtEndRRSort", */
    T: -1
  },
  /*::[*/
  675: {
    /* n:"BrtRRSortItem" */
  },
  /*::[*/
  676: {
    /* n:"BrtFileSharingIso" */
  },
  /*::[*/
  677: {
    /* n:"BrtBookProtectionIso" */
  },
  /*::[*/
  678: {
    /* n:"BrtSheetProtectionIso" */
  },
  /*::[*/
  679: {
    /* n:"BrtCsProtectionIso" */
  },
  /*::[*/
  680: {
    /* n:"BrtRangeProtectionIso" */
  },
  /*::[*/
  681: {
    /* n:"BrtDValList" */
  },
  /*::[*/
  1024: {
    /* n:"BrtRwDescent" */
  },
  /*::[*/
  1025: {
    /* n:"BrtKnownFonts" */
  },
  /*::[*/
  1026: {
    /* n:"BrtBeginSXTupleSet", */
    T: 1
  },
  /*::[*/
  1027: {
    /* n:"BrtEndSXTupleSet", */
    T: -1
  },
  /*::[*/
  1028: {
    /* n:"BrtBeginSXTupleSetHeader", */
    T: 1
  },
  /*::[*/
  1029: {
    /* n:"BrtEndSXTupleSetHeader", */
    T: -1
  },
  /*::[*/
  1030: {
    /* n:"BrtSXTupleSetHeaderItem" */
  },
  /*::[*/
  1031: {
    /* n:"BrtBeginSXTupleSetData", */
    T: 1
  },
  /*::[*/
  1032: {
    /* n:"BrtEndSXTupleSetData", */
    T: -1
  },
  /*::[*/
  1033: {
    /* n:"BrtBeginSXTupleSetRow", */
    T: 1
  },
  /*::[*/
  1034: {
    /* n:"BrtEndSXTupleSetRow", */
    T: -1
  },
  /*::[*/
  1035: {
    /* n:"BrtSXTupleSetRowItem" */
  },
  /*::[*/
  1036: {
    /* n:"BrtNameExt" */
  },
  /*::[*/
  1037: {
    /* n:"BrtPCDH14" */
  },
  /*::[*/
  1038: {
    /* n:"BrtBeginPCDCalcMem14", */
    T: 1
  },
  /*::[*/
  1039: {
    /* n:"BrtEndPCDCalcMem14", */
    T: -1
  },
  /*::[*/
  1040: {
    /* n:"BrtSXTH14" */
  },
  /*::[*/
  1041: {
    /* n:"BrtBeginSparklineGroup", */
    T: 1
  },
  /*::[*/
  1042: {
    /* n:"BrtEndSparklineGroup", */
    T: -1
  },
  /*::[*/
  1043: {
    /* n:"BrtSparkline" */
  },
  /*::[*/
  1044: {
    /* n:"BrtSXDI14" */
  },
  /*::[*/
  1045: {
    /* n:"BrtWsFmtInfoEx14" */
  },
  /*::[*/
  1046: {
    /* n:"BrtBeginConditionalFormatting14", */
    T: 1
  },
  /*::[*/
  1047: {
    /* n:"BrtEndConditionalFormatting14", */
    T: -1
  },
  /*::[*/
  1048: {
    /* n:"BrtBeginCFRule14", */
    T: 1
  },
  /*::[*/
  1049: {
    /* n:"BrtEndCFRule14", */
    T: -1
  },
  /*::[*/
  1050: {
    /* n:"BrtCFVO14" */
  },
  /*::[*/
  1051: {
    /* n:"BrtBeginDatabar14", */
    T: 1
  },
  /*::[*/
  1052: {
    /* n:"BrtBeginIconSet14", */
    T: 1
  },
  /*::[*/
  1053: {
    /* n:"BrtDVal14", */
    f: Xm
  },
  /*::[*/
  1054: {
    /* n:"BrtBeginDVals14", */
    T: 1
  },
  /*::[*/
  1055: {
    /* n:"BrtColor14" */
  },
  /*::[*/
  1056: {
    /* n:"BrtBeginSparklines", */
    T: 1
  },
  /*::[*/
  1057: {
    /* n:"BrtEndSparklines", */
    T: -1
  },
  /*::[*/
  1058: {
    /* n:"BrtBeginSparklineGroups", */
    T: 1
  },
  /*::[*/
  1059: {
    /* n:"BrtEndSparklineGroups", */
    T: -1
  },
  /*::[*/
  1061: {
    /* n:"BrtSXVD14" */
  },
  /*::[*/
  1062: {
    /* n:"BrtBeginSXView14", */
    T: 1
  },
  /*::[*/
  1063: {
    /* n:"BrtEndSXView14", */
    T: -1
  },
  /*::[*/
  1064: {
    /* n:"BrtBeginSXView16", */
    T: 1
  },
  /*::[*/
  1065: {
    /* n:"BrtEndSXView16", */
    T: -1
  },
  /*::[*/
  1066: {
    /* n:"BrtBeginPCD14", */
    T: 1
  },
  /*::[*/
  1067: {
    /* n:"BrtEndPCD14", */
    T: -1
  },
  /*::[*/
  1068: {
    /* n:"BrtBeginExtConn14", */
    T: 1
  },
  /*::[*/
  1069: {
    /* n:"BrtEndExtConn14", */
    T: -1
  },
  /*::[*/
  1070: {
    /* n:"BrtBeginSlicerCacheIDs", */
    T: 1
  },
  /*::[*/
  1071: {
    /* n:"BrtEndSlicerCacheIDs", */
    T: -1
  },
  /*::[*/
  1072: {
    /* n:"BrtBeginSlicerCacheID", */
    T: 1
  },
  /*::[*/
  1073: {
    /* n:"BrtEndSlicerCacheID", */
    T: -1
  },
  /*::[*/
  1075: {
    /* n:"BrtBeginSlicerCache", */
    T: 1
  },
  /*::[*/
  1076: {
    /* n:"BrtEndSlicerCache", */
    T: -1
  },
  /*::[*/
  1077: {
    /* n:"BrtBeginSlicerCacheDef", */
    T: 1
  },
  /*::[*/
  1078: {
    /* n:"BrtEndSlicerCacheDef", */
    T: -1
  },
  /*::[*/
  1079: {
    /* n:"BrtBeginSlicersEx", */
    T: 1
  },
  /*::[*/
  1080: {
    /* n:"BrtEndSlicersEx", */
    T: -1
  },
  /*::[*/
  1081: {
    /* n:"BrtBeginSlicerEx", */
    T: 1
  },
  /*::[*/
  1082: {
    /* n:"BrtEndSlicerEx", */
    T: -1
  },
  /*::[*/
  1083: {
    /* n:"BrtBeginSlicer", */
    T: 1
  },
  /*::[*/
  1084: {
    /* n:"BrtEndSlicer", */
    T: -1
  },
  /*::[*/
  1085: {
    /* n:"BrtSlicerCachePivotTables" */
  },
  /*::[*/
  1086: {
    /* n:"BrtBeginSlicerCacheOlapImpl", */
    T: 1
  },
  /*::[*/
  1087: {
    /* n:"BrtEndSlicerCacheOlapImpl", */
    T: -1
  },
  /*::[*/
  1088: {
    /* n:"BrtBeginSlicerCacheLevelsData", */
    T: 1
  },
  /*::[*/
  1089: {
    /* n:"BrtEndSlicerCacheLevelsData", */
    T: -1
  },
  /*::[*/
  1090: {
    /* n:"BrtBeginSlicerCacheLevelData", */
    T: 1
  },
  /*::[*/
  1091: {
    /* n:"BrtEndSlicerCacheLevelData", */
    T: -1
  },
  /*::[*/
  1092: {
    /* n:"BrtBeginSlicerCacheSiRanges", */
    T: 1
  },
  /*::[*/
  1093: {
    /* n:"BrtEndSlicerCacheSiRanges", */
    T: -1
  },
  /*::[*/
  1094: {
    /* n:"BrtBeginSlicerCacheSiRange", */
    T: 1
  },
  /*::[*/
  1095: {
    /* n:"BrtEndSlicerCacheSiRange", */
    T: -1
  },
  /*::[*/
  1096: {
    /* n:"BrtSlicerCacheOlapItem" */
  },
  /*::[*/
  1097: {
    /* n:"BrtBeginSlicerCacheSelections", */
    T: 1
  },
  /*::[*/
  1098: {
    /* n:"BrtSlicerCacheSelection" */
  },
  /*::[*/
  1099: {
    /* n:"BrtEndSlicerCacheSelections", */
    T: -1
  },
  /*::[*/
  1100: {
    /* n:"BrtBeginSlicerCacheNative", */
    T: 1
  },
  /*::[*/
  1101: {
    /* n:"BrtEndSlicerCacheNative", */
    T: -1
  },
  /*::[*/
  1102: {
    /* n:"BrtSlicerCacheNativeItem" */
  },
  /*::[*/
  1103: {
    /* n:"BrtRangeProtection14" */
  },
  /*::[*/
  1104: {
    /* n:"BrtRangeProtectionIso14" */
  },
  /*::[*/
  1105: {
    /* n:"BrtCellIgnoreEC14" */
  },
  /*::[*/
  1111: {
    /* n:"BrtList14" */
  },
  /*::[*/
  1112: {
    /* n:"BrtCFIcon" */
  },
  /*::[*/
  1113: {
    /* n:"BrtBeginSlicerCachesPivotCacheIDs", */
    T: 1
  },
  /*::[*/
  1114: {
    /* n:"BrtEndSlicerCachesPivotCacheIDs", */
    T: -1
  },
  /*::[*/
  1115: {
    /* n:"BrtBeginSlicers", */
    T: 1
  },
  /*::[*/
  1116: {
    /* n:"BrtEndSlicers", */
    T: -1
  },
  /*::[*/
  1117: {
    /* n:"BrtWbProp14" */
  },
  /*::[*/
  1118: {
    /* n:"BrtBeginSXEdit", */
    T: 1
  },
  /*::[*/
  1119: {
    /* n:"BrtEndSXEdit", */
    T: -1
  },
  /*::[*/
  1120: {
    /* n:"BrtBeginSXEdits", */
    T: 1
  },
  /*::[*/
  1121: {
    /* n:"BrtEndSXEdits", */
    T: -1
  },
  /*::[*/
  1122: {
    /* n:"BrtBeginSXChange", */
    T: 1
  },
  /*::[*/
  1123: {
    /* n:"BrtEndSXChange", */
    T: -1
  },
  /*::[*/
  1124: {
    /* n:"BrtBeginSXChanges", */
    T: 1
  },
  /*::[*/
  1125: {
    /* n:"BrtEndSXChanges", */
    T: -1
  },
  /*::[*/
  1126: {
    /* n:"BrtSXTupleItems" */
  },
  /*::[*/
  1128: {
    /* n:"BrtBeginSlicerStyle", */
    T: 1
  },
  /*::[*/
  1129: {
    /* n:"BrtEndSlicerStyle", */
    T: -1
  },
  /*::[*/
  1130: {
    /* n:"BrtSlicerStyleElement" */
  },
  /*::[*/
  1131: {
    /* n:"BrtBeginStyleSheetExt14", */
    T: 1
  },
  /*::[*/
  1132: {
    /* n:"BrtEndStyleSheetExt14", */
    T: -1
  },
  /*::[*/
  1133: {
    /* n:"BrtBeginSlicerCachesPivotCacheID", */
    T: 1
  },
  /*::[*/
  1134: {
    /* n:"BrtEndSlicerCachesPivotCacheID", */
    T: -1
  },
  /*::[*/
  1135: {
    /* n:"BrtBeginConditionalFormattings", */
    T: 1
  },
  /*::[*/
  1136: {
    /* n:"BrtEndConditionalFormattings", */
    T: -1
  },
  /*::[*/
  1137: {
    /* n:"BrtBeginPCDCalcMemExt", */
    T: 1
  },
  /*::[*/
  1138: {
    /* n:"BrtEndPCDCalcMemExt", */
    T: -1
  },
  /*::[*/
  1139: {
    /* n:"BrtBeginPCDCalcMemsExt", */
    T: 1
  },
  /*::[*/
  1140: {
    /* n:"BrtEndPCDCalcMemsExt", */
    T: -1
  },
  /*::[*/
  1141: {
    /* n:"BrtPCDField14" */
  },
  /*::[*/
  1142: {
    /* n:"BrtBeginSlicerStyles", */
    T: 1
  },
  /*::[*/
  1143: {
    /* n:"BrtEndSlicerStyles", */
    T: -1
  },
  /*::[*/
  1144: {
    /* n:"BrtBeginSlicerStyleElements", */
    T: 1
  },
  /*::[*/
  1145: {
    /* n:"BrtEndSlicerStyleElements", */
    T: -1
  },
  /*::[*/
  1146: {
    /* n:"BrtCFRuleExt" */
  },
  /*::[*/
  1147: {
    /* n:"BrtBeginSXCondFmt14", */
    T: 1
  },
  /*::[*/
  1148: {
    /* n:"BrtEndSXCondFmt14", */
    T: -1
  },
  /*::[*/
  1149: {
    /* n:"BrtBeginSXCondFmts14", */
    T: 1
  },
  /*::[*/
  1150: {
    /* n:"BrtEndSXCondFmts14", */
    T: -1
  },
  /*::[*/
  1152: {
    /* n:"BrtBeginSortCond14", */
    T: 1
  },
  /*::[*/
  1153: {
    /* n:"BrtEndSortCond14", */
    T: -1
  },
  /*::[*/
  1154: {
    /* n:"BrtEndDVals14", */
    T: -1
  },
  /*::[*/
  1155: {
    /* n:"BrtEndIconSet14", */
    T: -1
  },
  /*::[*/
  1156: {
    /* n:"BrtEndDatabar14", */
    T: -1
  },
  /*::[*/
  1157: {
    /* n:"BrtBeginColorScale14", */
    T: 1
  },
  /*::[*/
  1158: {
    /* n:"BrtEndColorScale14", */
    T: -1
  },
  /*::[*/
  1159: {
    /* n:"BrtBeginSxrules14", */
    T: 1
  },
  /*::[*/
  1160: {
    /* n:"BrtEndSxrules14", */
    T: -1
  },
  /*::[*/
  1161: {
    /* n:"BrtBeginPRule14", */
    T: 1
  },
  /*::[*/
  1162: {
    /* n:"BrtEndPRule14", */
    T: -1
  },
  /*::[*/
  1163: {
    /* n:"BrtBeginPRFilters14", */
    T: 1
  },
  /*::[*/
  1164: {
    /* n:"BrtEndPRFilters14", */
    T: -1
  },
  /*::[*/
  1165: {
    /* n:"BrtBeginPRFilter14", */
    T: 1
  },
  /*::[*/
  1166: {
    /* n:"BrtEndPRFilter14", */
    T: -1
  },
  /*::[*/
  1167: {
    /* n:"BrtBeginPRFItem14", */
    T: 1
  },
  /*::[*/
  1168: {
    /* n:"BrtEndPRFItem14", */
    T: -1
  },
  /*::[*/
  1169: {
    /* n:"BrtBeginCellIgnoreECs14", */
    T: 1
  },
  /*::[*/
  1170: {
    /* n:"BrtEndCellIgnoreECs14", */
    T: -1
  },
  /*::[*/
  1171: {
    /* n:"BrtDxf14" */
  },
  /*::[*/
  1172: {
    /* n:"BrtBeginDxF14s", */
    T: 1
  },
  /*::[*/
  1173: {
    /* n:"BrtEndDxf14s", */
    T: -1
  },
  /*::[*/
  1177: {
    /* n:"BrtFilter14" */
  },
  /*::[*/
  1178: {
    /* n:"BrtBeginCustomFilters14", */
    T: 1
  },
  /*::[*/
  1180: {
    /* n:"BrtCustomFilter14" */
  },
  /*::[*/
  1181: {
    /* n:"BrtIconFilter14" */
  },
  /*::[*/
  1182: {
    /* n:"BrtPivotCacheConnectionName" */
  },
  /*::[*/
  2048: {
    /* n:"BrtBeginDecoupledPivotCacheIDs", */
    T: 1
  },
  /*::[*/
  2049: {
    /* n:"BrtEndDecoupledPivotCacheIDs", */
    T: -1
  },
  /*::[*/
  2050: {
    /* n:"BrtDecoupledPivotCacheID" */
  },
  /*::[*/
  2051: {
    /* n:"BrtBeginPivotTableRefs", */
    T: 1
  },
  /*::[*/
  2052: {
    /* n:"BrtEndPivotTableRefs", */
    T: -1
  },
  /*::[*/
  2053: {
    /* n:"BrtPivotTableRef" */
  },
  /*::[*/
  2054: {
    /* n:"BrtSlicerCacheBookPivotTables" */
  },
  /*::[*/
  2055: {
    /* n:"BrtBeginSxvcells", */
    T: 1
  },
  /*::[*/
  2056: {
    /* n:"BrtEndSxvcells", */
    T: -1
  },
  /*::[*/
  2057: {
    /* n:"BrtBeginSxRow", */
    T: 1
  },
  /*::[*/
  2058: {
    /* n:"BrtEndSxRow", */
    T: -1
  },
  /*::[*/
  2060: {
    /* n:"BrtPcdCalcMem15" */
  },
  /*::[*/
  2067: {
    /* n:"BrtQsi15" */
  },
  /*::[*/
  2068: {
    /* n:"BrtBeginWebExtensions", */
    T: 1
  },
  /*::[*/
  2069: {
    /* n:"BrtEndWebExtensions", */
    T: -1
  },
  /*::[*/
  2070: {
    /* n:"BrtWebExtension" */
  },
  /*::[*/
  2071: {
    /* n:"BrtAbsPath15" */
  },
  /*::[*/
  2072: {
    /* n:"BrtBeginPivotTableUISettings", */
    T: 1
  },
  /*::[*/
  2073: {
    /* n:"BrtEndPivotTableUISettings", */
    T: -1
  },
  /*::[*/
  2075: {
    /* n:"BrtTableSlicerCacheIDs" */
  },
  /*::[*/
  2076: {
    /* n:"BrtTableSlicerCacheID" */
  },
  /*::[*/
  2077: {
    /* n:"BrtBeginTableSlicerCache", */
    T: 1
  },
  /*::[*/
  2078: {
    /* n:"BrtEndTableSlicerCache", */
    T: -1
  },
  /*::[*/
  2079: {
    /* n:"BrtSxFilter15" */
  },
  /*::[*/
  2080: {
    /* n:"BrtBeginTimelineCachePivotCacheIDs", */
    T: 1
  },
  /*::[*/
  2081: {
    /* n:"BrtEndTimelineCachePivotCacheIDs", */
    T: -1
  },
  /*::[*/
  2082: {
    /* n:"BrtTimelineCachePivotCacheID" */
  },
  /*::[*/
  2083: {
    /* n:"BrtBeginTimelineCacheIDs", */
    T: 1
  },
  /*::[*/
  2084: {
    /* n:"BrtEndTimelineCacheIDs", */
    T: -1
  },
  /*::[*/
  2085: {
    /* n:"BrtBeginTimelineCacheID", */
    T: 1
  },
  /*::[*/
  2086: {
    /* n:"BrtEndTimelineCacheID", */
    T: -1
  },
  /*::[*/
  2087: {
    /* n:"BrtBeginTimelinesEx", */
    T: 1
  },
  /*::[*/
  2088: {
    /* n:"BrtEndTimelinesEx", */
    T: -1
  },
  /*::[*/
  2089: {
    /* n:"BrtBeginTimelineEx", */
    T: 1
  },
  /*::[*/
  2090: {
    /* n:"BrtEndTimelineEx", */
    T: -1
  },
  /*::[*/
  2091: {
    /* n:"BrtWorkBookPr15" */
  },
  /*::[*/
  2092: {
    /* n:"BrtPCDH15" */
  },
  /*::[*/
  2093: {
    /* n:"BrtBeginTimelineStyle", */
    T: 1
  },
  /*::[*/
  2094: {
    /* n:"BrtEndTimelineStyle", */
    T: -1
  },
  /*::[*/
  2095: {
    /* n:"BrtTimelineStyleElement" */
  },
  /*::[*/
  2096: {
    /* n:"BrtBeginTimelineStylesheetExt15", */
    T: 1
  },
  /*::[*/
  2097: {
    /* n:"BrtEndTimelineStylesheetExt15", */
    T: -1
  },
  /*::[*/
  2098: {
    /* n:"BrtBeginTimelineStyles", */
    T: 1
  },
  /*::[*/
  2099: {
    /* n:"BrtEndTimelineStyles", */
    T: -1
  },
  /*::[*/
  2100: {
    /* n:"BrtBeginTimelineStyleElements", */
    T: 1
  },
  /*::[*/
  2101: {
    /* n:"BrtEndTimelineStyleElements", */
    T: -1
  },
  /*::[*/
  2102: {
    /* n:"BrtDxf15" */
  },
  /*::[*/
  2103: {
    /* n:"BrtBeginDxfs15", */
    T: 1
  },
  /*::[*/
  2104: {
    /* n:"BrtEndDxfs15", */
    T: -1
  },
  /*::[*/
  2105: {
    /* n:"BrtSlicerCacheHideItemsWithNoData" */
  },
  /*::[*/
  2106: {
    /* n:"BrtBeginItemUniqueNames", */
    T: 1
  },
  /*::[*/
  2107: {
    /* n:"BrtEndItemUniqueNames", */
    T: -1
  },
  /*::[*/
  2108: {
    /* n:"BrtItemUniqueName" */
  },
  /*::[*/
  2109: {
    /* n:"BrtBeginExtConn15", */
    T: 1
  },
  /*::[*/
  2110: {
    /* n:"BrtEndExtConn15", */
    T: -1
  },
  /*::[*/
  2111: {
    /* n:"BrtBeginOledbPr15", */
    T: 1
  },
  /*::[*/
  2112: {
    /* n:"BrtEndOledbPr15", */
    T: -1
  },
  /*::[*/
  2113: {
    /* n:"BrtBeginDataFeedPr15", */
    T: 1
  },
  /*::[*/
  2114: {
    /* n:"BrtEndDataFeedPr15", */
    T: -1
  },
  /*::[*/
  2115: {
    /* n:"BrtTextPr15" */
  },
  /*::[*/
  2116: {
    /* n:"BrtRangePr15" */
  },
  /*::[*/
  2117: {
    /* n:"BrtDbCommand15" */
  },
  /*::[*/
  2118: {
    /* n:"BrtBeginDbTables15", */
    T: 1
  },
  /*::[*/
  2119: {
    /* n:"BrtEndDbTables15", */
    T: -1
  },
  /*::[*/
  2120: {
    /* n:"BrtDbTable15" */
  },
  /*::[*/
  2121: {
    /* n:"BrtBeginDataModel", */
    T: 1
  },
  /*::[*/
  2122: {
    /* n:"BrtEndDataModel", */
    T: -1
  },
  /*::[*/
  2123: {
    /* n:"BrtBeginModelTables", */
    T: 1
  },
  /*::[*/
  2124: {
    /* n:"BrtEndModelTables", */
    T: -1
  },
  /*::[*/
  2125: {
    /* n:"BrtModelTable" */
  },
  /*::[*/
  2126: {
    /* n:"BrtBeginModelRelationships", */
    T: 1
  },
  /*::[*/
  2127: {
    /* n:"BrtEndModelRelationships", */
    T: -1
  },
  /*::[*/
  2128: {
    /* n:"BrtModelRelationship" */
  },
  /*::[*/
  2129: {
    /* n:"BrtBeginECTxtWiz15", */
    T: 1
  },
  /*::[*/
  2130: {
    /* n:"BrtEndECTxtWiz15", */
    T: -1
  },
  /*::[*/
  2131: {
    /* n:"BrtBeginECTWFldInfoLst15", */
    T: 1
  },
  /*::[*/
  2132: {
    /* n:"BrtEndECTWFldInfoLst15", */
    T: -1
  },
  /*::[*/
  2133: {
    /* n:"BrtBeginECTWFldInfo15", */
    T: 1
  },
  /*::[*/
  2134: {
    /* n:"BrtFieldListActiveItem" */
  },
  /*::[*/
  2135: {
    /* n:"BrtPivotCacheIdVersion" */
  },
  /*::[*/
  2136: {
    /* n:"BrtSXDI15" */
  },
  /*::[*/
  2137: {
    /* n:"BrtBeginModelTimeGroupings", */
    T: 1
  },
  /*::[*/
  2138: {
    /* n:"BrtEndModelTimeGroupings", */
    T: -1
  },
  /*::[*/
  2139: {
    /* n:"BrtBeginModelTimeGrouping", */
    T: 1
  },
  /*::[*/
  2140: {
    /* n:"BrtEndModelTimeGrouping", */
    T: -1
  },
  /*::[*/
  2141: {
    /* n:"BrtModelTimeGroupingCalcCol" */
  },
  /*::[*/
  3072: {
    /* n:"BrtUid" */
  },
  /*::[*/
  3073: {
    /* n:"BrtRevisionPtr" */
  },
  /*::[*/
  4096: {
    /* n:"BrtBeginDynamicArrayPr", */
    T: 1
  },
  /*::[*/
  4097: {
    /* n:"BrtEndDynamicArrayPr", */
    T: -1
  },
  /*::[*/
  5002: {
    /* n:"BrtBeginRichValueBlock", */
    T: 1
  },
  /*::[*/
  5003: {
    /* n:"BrtEndRichValueBlock", */
    T: -1
  },
  /*::[*/
  5081: {
    /* n:"BrtBeginRichFilters", */
    T: 1
  },
  /*::[*/
  5082: {
    /* n:"BrtEndRichFilters", */
    T: -1
  },
  /*::[*/
  5083: {
    /* n:"BrtRichFilter" */
  },
  /*::[*/
  5084: {
    /* n:"BrtBeginRichFilterColumn", */
    T: 1
  },
  /*::[*/
  5085: {
    /* n:"BrtEndRichFilterColumn", */
    T: -1
  },
  /*::[*/
  5086: {
    /* n:"BrtBeginCustomRichFilters", */
    T: 1
  },
  /*::[*/
  5087: {
    /* n:"BrtEndCustomRichFilters", */
    T: -1
  },
  /*::[*/
  5088: {
    /* n:"BrtCustomRichFilter" */
  },
  /*::[*/
  5089: {
    /* n:"BrtTop10RichFilter" */
  },
  /*::[*/
  5090: {
    /* n:"BrtDynamicRichFilter" */
  },
  /*::[*/
  5092: {
    /* n:"BrtBeginRichSortCondition", */
    T: 1
  },
  /*::[*/
  5093: {
    /* n:"BrtEndRichSortCondition", */
    T: -1
  },
  /*::[*/
  5094: {
    /* n:"BrtRichFilterDateGroupItem" */
  },
  /*::[*/
  5095: {
    /* n:"BrtBeginCalcFeatures", */
    T: 1
  },
  /*::[*/
  5096: {
    /* n:"BrtEndCalcFeatures", */
    T: -1
  },
  /*::[*/
  5097: {
    /* n:"BrtCalcFeature" */
  },
  /*::[*/
  5099: {
    /* n:"BrtExternalLinksPr" */
  },
  /*::[*/
  65535: {
    n: ""
  }
};
function Xe(r6, e, t, n) {
  var i = e;
  if (!isNaN(i)) {
    var a = n || (t || []).length || 0, s = r6.next(4);
    s.write_shift(2, i), s.write_shift(2, a), /*:: len != null &&*/
    a > 0 && Hl(t) && r6.push(t);
  }
}
function Hx(r6, e, t, n) {
  var i = n || (t || []).length || 0;
  if (i <= 8224) return Xe(r6, e, t, i);
  var a = e;
  if (!isNaN(a)) {
    for (var s = t.parts || [], o = 0, f = 0, h = 0; h + (s[o] || 8224) <= 8224; ) h += s[o] || 8224, o++;
    var c = r6.next(4);
    for (c.write_shift(2, a), c.write_shift(2, h), r6.push(t.slice(f, f + h)), f += h; f < i; ) {
      for (c = r6.next(4), c.write_shift(2, 60), h = 0; h + (s[o] || 8224) <= 8224; ) h += s[o] || 8224, o++;
      c.write_shift(2, h), r6.push(t.slice(f, f + h)), f += h;
    }
  }
}
function Do(r6, e, t) {
  return r6 || (r6 = Le(7)), r6.write_shift(2, e), r6.write_shift(2, t), r6.write_shift(2, 0), r6.write_shift(1, 0), r6;
}
function Wx(r6, e, t, n) {
  var i = Le(9);
  return Do(i, r6, e), zu(t, n || "b", i), i;
}
function zx(r6, e, t) {
  var n = Le(8 + 2 * t.length);
  return Do(n, r6, e), n.write_shift(1, t.length), n.write_shift(t.length, t, "sbcs"), n.l < n.length ? n.slice(0, n.l) : n;
}
function Vx(r6, e, t, n) {
  if (e.v != null) switch (e.t) {
    case "d":
    case "n":
      var i = e.t == "d" ? pn(an(e.v)) : e.v;
      i == (i | 0) && i >= 0 && i < 65536 ? Xe(r6, 2, a5(t, n, i)) : Xe(r6, 3, i5(t, n, i));
      return;
    case "b":
    case "e":
      Xe(r6, 5, Wx(t, n, e.v, e.t));
      return;
    case "s":
    case "str":
      Xe(r6, 4, zx(t, n, (e.v || "").slice(0, 255)));
      return;
  }
  Xe(r6, 1, Do(null, t, n));
}
function Gx(r6, e, t, n) {
  var i = Array.isArray(e), a = rr(e["!ref"] || "A1"), s, o = "", f = [];
  if (a.e.c > 255 || a.e.r > 16383) {
    if (n.WTF) throw new Error("Range " + (e["!ref"] || "A1") + " exceeds format limit A1:IV16384");
    a.e.c = Math.min(a.e.c, 255), a.e.r = Math.min(a.e.c, 16383), s = Sr(a);
  }
  for (var h = a.s.r; h <= a.e.r; ++h) {
    o = qr(h);
    for (var c = a.s.c; c <= a.e.c; ++c) {
      h === a.s.r && (f[c] = Jr(c)), s = f[c] + o;
      var p = i ? (e[h] || [])[c] : e[s];
      p && Vx(r6, p, h, c);
    }
  }
}
function Xx(r6, e) {
  for (var t = e || {}, n = dn(), i = 0, a = 0; a < r6.SheetNames.length; ++a) r6.SheetNames[a] == t.sheet && (i = a);
  if (i == 0 && t.sheet && r6.SheetNames[0] != t.sheet) throw new Error("Sheet not found: " + t.sheet);
  return Xe(n, t.biff == 4 ? 1033 : t.biff == 3 ? 521 : 9, Yl(r6, 16, t)), Gx(n, r6.Sheets[r6.SheetNames[i]], i, t), Xe(n, 10), n.end();
}
function Yx(r6, e, t) {
  Xe(r6, 49, qp({
    sz: 12,
    color: {
      theme: 1
    },
    name: "Arial",
    family: 2,
    scheme: "minor"
  }, t));
}
function $x(r6, e, t) {
  e && [[5, 8], [23, 26], [41, 44], [
    /*63*/
    50,
    /*66],[164,*/
    392
  ]].forEach(function(n) {
    for (var i = n[0]; i <= n[1]; ++i) e[i] != null && Xe(r6, 1054, zp(i, e[i], t));
  });
}
function Kx(r6, e) {
  var t = Le(19);
  t.write_shift(4, 2151), t.write_shift(4, 0), t.write_shift(4, 0), t.write_shift(2, 3), t.write_shift(1, 1), t.write_shift(4, 0), Xe(r6, 2151, t), t = Le(39), t.write_shift(4, 2152), t.write_shift(4, 0), t.write_shift(4, 0), t.write_shift(2, 3), t.write_shift(1, 0), t.write_shift(4, 0), t.write_shift(2, 1), t.write_shift(4, 4), t.write_shift(2, 0), Xu(rr(e["!ref"] || "A1"), t), t.write_shift(4, 4), Xe(r6, 2152, t);
}
function Jx(r6, e) {
  for (var t = 0; t < 16; ++t) Xe(r6, 224, cc({
    numFmtId: 0,
    style: true
  }, 0, e));
  e.cellXfs.forEach(function(n) {
    Xe(r6, 224, cc(n, 0, e));
  });
}
function Zx(r6, e) {
  for (var t = 0; t < e["!links"].length; ++t) {
    var n = e["!links"][t];
    Xe(r6, 440, Zp(n)), n[1].Tooltip && Xe(r6, 2048, Qp(n));
  }
  delete e["!links"];
}
function Qx(r6, e) {
  if (e) {
    var t = 0;
    e.forEach(function(n, i) {
      ++t <= 256 && n && Xe(r6, 125, r5(lf(i, n), i));
    });
  }
}
function e4(r6, e, t, n, i) {
  var a = 16 + pa(i.cellXfs, e, i);
  if (e.v == null && !e.bf) {
    Xe(r6, 513, Da(t, n, a));
    return;
  }
  if (e.bf) Xe(r6, 6, bv(e, t, n, i, a));
  else switch (e.t) {
    case "d":
    case "n":
      var s = e.t == "d" ? pn(an(e.v)) : e.v;
      Xe(r6, 515, Yp(t, n, s, a));
      break;
    case "b":
    case "e":
      Xe(r6, 517, Xp(t, n, e.v, a, i, e.t));
      break;
    case "s":
    case "str":
      if (i.bookSST) {
        var o = Ql(i.Strings, e.v, i.revStrings);
        Xe(r6, 253, Hp(t, n, o, a));
      } else Xe(r6, 516, Wp(t, n, (e.v || "").slice(0, 255), a, i));
      break;
    default:
      Xe(r6, 513, Da(t, n, a));
  }
}
function t4(r6, e, t) {
  var n = dn(), i = t.SheetNames[r6], a = t.Sheets[i] || {}, s = (t || {}).Workbook || {}, o = (s.Sheets || [])[r6] || {}, f = Array.isArray(a), h = e.biff == 8, c, p = "", v = [], d = rr(a["!ref"] || "A1"), w = h ? 65536 : 16384;
  if (d.e.c > 255 || d.e.r >= w) {
    if (e.WTF) throw new Error("Range " + (a["!ref"] || "A1") + " exceeds format limit A1:IV16384");
    d.e.c = Math.min(d.e.c, 255), d.e.r = Math.min(d.e.c, w - 1);
  }
  Xe(n, 2057, Yl(t, 16, e)), Xe(n, 13, qn(1)), Xe(n, 12, qn(100)), Xe(n, 15, nn(true)), Xe(n, 17, nn(false)), Xe(n, 16, ka(1e-3)), Xe(n, 95, nn(true)), Xe(n, 42, nn(false)), Xe(n, 43, nn(false)), Xe(n, 130, qn(1)), Xe(n, 128, Gp([0, 0])), Xe(n, 131, nn(false)), Xe(n, 132, nn(false)), h && Qx(n, a["!cols"]), Xe(n, 512, Vp(d, e)), h && (a["!links"] = []);
  for (var x = d.s.r; x <= d.e.r; ++x) {
    p = qr(x);
    for (var S = d.s.c; S <= d.e.c; ++S) {
      x === d.s.r && (v[S] = Jr(S)), c = v[S] + p;
      var A = f ? (a[x] || [])[S] : a[c];
      A && (e4(n, A, x, S, e), h && A.l && a["!links"].push([c, A.l]));
    }
  }
  var b = o.CodeName || o.name || i;
  return h && Xe(n, 574, Up((s.Views || [])[0])), h && (a["!merges"] || []).length && Xe(n, 229, Jp(a["!merges"])), h && Zx(n, a), Xe(n, 442, Gu(b)), h && Kx(n, a), Xe(
    n,
    10
    /* EOF */
  ), n.end();
}
function r4(r6, e, t) {
  var n = dn(), i = (r6 || {}).Workbook || {}, a = i.Sheets || [], s = (
    /*::((*/
    i.WBProps || {
      /*::CodeName:"ThisWorkbook"*/
    }
  ), o = t.biff == 8, f = t.biff == 5;
  if (Xe(n, 2057, Yl(r6, 5, t)), t.bookType == "xla" && Xe(
    n,
    135
    /* Addin */
  ), Xe(n, 225, o ? qn(1200) : null), Xe(n, 193, Np(2)), f && Xe(
    n,
    191
    /* ToolbarHdr */
  ), f && Xe(
    n,
    192
    /* ToolbarEnd */
  ), Xe(
    n,
    226
    /* InterfaceEnd */
  ), Xe(n, 92, Rp("SheetJS", t)), Xe(n, 66, qn(o ? 1200 : 1252)), o && Xe(n, 353, qn(0)), o && Xe(
    n,
    448
    /* Excel9File */
  ), Xe(n, 317, n5(r6.SheetNames.length)), o && r6.vbaraw && Xe(
    n,
    211
    /* ObProj */
  ), o && r6.vbaraw) {
    var h = s.CodeName || "ThisWorkbook";
    Xe(n, 442, Gu(h));
  }
  Xe(n, 156, qn(17)), Xe(n, 25, nn(false)), Xe(n, 18, nn(false)), Xe(n, 19, qn(0)), o && Xe(n, 431, nn(false)), o && Xe(n, 444, qn(0)), Xe(n, 61, jp()), Xe(n, 64, nn(false)), Xe(n, 141, qn(0)), Xe(n, 34, nn(ox(r6) == "true")), Xe(n, 14, nn(true)), o && Xe(n, 439, nn(false)), Xe(n, 218, qn(0)), Yx(n, r6, t), $x(n, r6.SSF, t), Jx(n, t), o && Xe(n, 352, nn(false));
  var c = n.end(), p = dn();
  o && Xe(p, 140, e5()), o && t.Strings && Hx(p, 252, Bp(t.Strings)), Xe(
    p,
    10
    /* EOF */
  );
  var v = p.end(), d = dn(), w = 0, x = 0;
  for (x = 0; x < r6.SheetNames.length; ++x) w += (o ? 12 : 11) + (o ? 2 : 1) * r6.SheetNames[x].length;
  var S = c.length + w + v.length;
  for (x = 0; x < r6.SheetNames.length; ++x) {
    var A = a[x] || {};
    Xe(d, 133, Mp({
      pos: S,
      hs: A.Hidden || 0,
      dt: 0,
      name: r6.SheetNames[x]
    }, t)), S += e[x].length;
  }
  var b = d.end();
  if (w != b.length) throw new Error("BS8 " + w + " != " + b.length);
  var O = [];
  return c.length && O.push(c), b.length && O.push(b), v.length && O.push(v), jr(O);
}
function n4(r6, e) {
  var t = e || {}, n = [];
  r6 && !r6.SSF && (r6.SSF = gn(lr)), r6 && r6.SSF && (nf(), rf(r6.SSF), t.revssf = af(r6.SSF), t.revssf[r6.SSF[65535]] = 0, t.ssf = r6.SSF), t.Strings = /*::((*/
  [], t.Strings.Count = 0, t.Strings.Unique = 0, eh(t), t.cellXfs = [], pa(t.cellXfs, {}, {
    revssf: {
      General: 0
    }
  }), r6.Props || (r6.Props = {});
  for (var i = 0; i < r6.SheetNames.length; ++i) n[n.length] = t4(i, t, r6);
  return n.unshift(r4(r6, n, t)), jr(n);
}
function w1(r6, e) {
  for (var t = 0; t <= r6.SheetNames.length; ++t) {
    var n = r6.Sheets[r6.SheetNames[t]];
    if (!(!n || !n["!ref"])) {
      var i = Ln(n["!ref"]);
      i.e.c > 255 && typeof console < "u" && console.error && console.error("Worksheet '" + r6.SheetNames[t] + "' extends beyond column IV (255).  Data may be lost.");
    }
  }
  var a = e || {};
  switch (a.biff || 2) {
    case 8:
    case 5:
      return n4(r6, e);
    case 4:
    case 3:
    case 2:
      return Xx(r6, e);
  }
  throw new Error("invalid type " + a.bookType + " for BIFF");
}
function i4(r6, e, t, n) {
  for (var i = r6["!merges"] || [], a = [], s = e.s.c; s <= e.e.c; ++s) {
    for (var o = 0, f = 0, h = 0; h < i.length; ++h) if (!(i[h].s.r > t || i[h].s.c > s) && !(i[h].e.r < t || i[h].e.c < s)) {
      if (i[h].s.r < t || i[h].s.c < s) {
        o = -1;
        break;
      }
      o = i[h].e.r - i[h].s.r + 1, f = i[h].e.c - i[h].s.c + 1;
      break;
    }
    if (!(o < 0)) {
      var c = zt({
        r: t,
        c: s
      }), p = n.dense ? (r6[t] || [])[s] : r6[c], v = p && p.v != null && (p.h || Id(p.w || (Ui(p), p.w) || "")) || "", d = {};
      o > 1 && (d.rowspan = o), f > 1 && (d.colspan = f), n.editable ? v = '<span contenteditable="true">' + v + "</span>" : p && (d["data-t"] = p && p.t || "z", p.v != null && (d["data-v"] = p.v), p.z != null && (d["data-z"] = p.z), p.l && (p.l.Target || "#").charAt(0) != "#" && (v = '<a href="' + p.l.Target + '">' + v + "</a>")), d.id = (n.id || "sjs") + "-" + c, a.push(Ge("td", v, d));
    }
  }
  var w = "<tr>";
  return w + a.join("") + "</tr>";
}
var a4 = '<html><head><meta charset="utf-8"/><title>SheetJS Table Export</title></head><body>';
var s4 = "</body></html>";
function o4(r6, e, t) {
  var n = [];
  return n.join("") + "<table" + (t && t.id ? ' id="' + t.id + '"' : "") + ">";
}
function y1(r6, e) {
  var t = e || {}, n = t.header != null ? t.header : a4, i = t.footer != null ? t.footer : s4, a = [n], s = Ln(r6["!ref"]);
  t.dense = Array.isArray(r6), a.push(o4(r6, s, t));
  for (var o = s.s.r; o <= s.e.r; ++o) a.push(i4(r6, s, o, t));
  return a.push("</table>" + i), a.join("");
}
function _1(r6, e, t) {
  var n = t || {}, i = 0, a = 0;
  if (n.origin != null) if (typeof n.origin == "number") i = n.origin;
  else {
    var s = typeof n.origin == "string" ? Dr(n.origin) : n.origin;
    i = s.r, a = s.c;
  }
  var o = e.getElementsByTagName("tr"), f = Math.min(n.sheetRows || 1e7, o.length), h = {
    s: {
      r: 0,
      c: 0
    },
    e: {
      r: i,
      c: a
    }
  };
  if (r6["!ref"]) {
    var c = Ln(r6["!ref"]);
    h.s.r = Math.min(h.s.r, c.s.r), h.s.c = Math.min(h.s.c, c.s.c), h.e.r = Math.max(h.e.r, c.e.r), h.e.c = Math.max(h.e.c, c.e.c), i == -1 && (h.e.r = i = c.e.r + 1);
  }
  var p = [], v = 0, d = r6["!rows"] || (r6["!rows"] = []), w = 0, x = 0, S = 0, A = 0, b = 0, O = 0;
  for (r6["!cols"] || (r6["!cols"] = []); w < o.length && x < f; ++w) {
    var q = o[w];
    if (xc(q)) {
      if (n.display) continue;
      d[x] = {
        hidden: true
      };
    }
    var te = q.children;
    for (S = A = 0; S < te.length; ++S) {
      var le = te[S];
      if (!(n.display && xc(le))) {
        var j = le.hasAttribute("data-v") ? le.getAttribute("data-v") : le.hasAttribute("v") ? le.getAttribute("v") : jd(le.innerHTML), M = le.getAttribute("data-z") || le.getAttribute("z");
        for (v = 0; v < p.length; ++v) {
          var H = p[v];
          H.s.c == A + a && H.s.r < x + i && x + i <= H.e.r && (A = H.e.c + 1 - a, v = -1);
        }
        O = +le.getAttribute("colspan") || 1, ((b = +le.getAttribute("rowspan") || 1) > 1 || O > 1) && p.push({
          s: {
            r: x + i,
            c: A + a
          },
          e: {
            r: x + i + (b || 1) - 1,
            c: A + a + (O || 1) - 1
          }
        });
        var ee = {
          t: "s",
          v: j
        }, F = le.getAttribute("data-t") || le.getAttribute("t") || "";
        j != null && (j.length == 0 ? ee.t = F || "z" : n.raw || j.trim().length == 0 || F == "s" || (j === "TRUE" ? ee = {
          t: "b",
          v: true
        } : j === "FALSE" ? ee = {
          t: "b",
          v: false
        } : isNaN(Mi(j)) ? isNaN(Ao(j).getDate()) || (ee = {
          t: "d",
          v: an(j)
        }, n.cellDates || (ee = {
          t: "n",
          v: pn(ee.v)
        }), ee.z = n.dateNF || lr[14]) : ee = {
          t: "n",
          v: Mi(j)
        })), ee.z === void 0 && M != null && (ee.z = M);
        var P = "", Y = le.getElementsByTagName("A");
        if (Y && Y.length) for (var Q = 0; Q < Y.length && !(Y[Q].hasAttribute("href") && (P = Y[Q].getAttribute("href"), P.charAt(0) != "#")); ++Q) ;
        P && P.charAt(0) != "#" && (ee.l = {
          Target: P
        }), n.dense ? (r6[x + i] || (r6[x + i] = []), r6[x + i][A + a] = ee) : r6[zt({
          c: A + a,
          r: x + i
        })] = ee, h.e.c < A + a && (h.e.c = A + a), A += O;
      }
    }
    ++x;
  }
  return p.length && (r6["!merges"] = (r6["!merges"] || []).concat(p)), h.e.r = Math.max(h.e.r, x - 1 + i), r6["!ref"] = Sr(h), x >= f && (r6["!fullref"] = Sr((h.e.r = o.length - w + x - 1 + i, h))), r6;
}
function S1(r6, e) {
  var t = e || {}, n = t.dense ? [] : {};
  return _1(n, r6, e);
}
function f4(r6, e) {
  return Oa(S1(r6, e), e);
}
function xc(r6) {
  var e = "", t = l4(r6);
  return t && (e = t(r6).getPropertyValue("display")), e || (e = r6.style && r6.style.display), e === "none";
}
function l4(r6) {
  return r6.ownerDocument.defaultView && typeof r6.ownerDocument.defaultView.getComputedStyle == "function" ? r6.ownerDocument.defaultView.getComputedStyle : typeof getComputedStyle == "function" ? getComputedStyle : null;
}
var h4 = function() {
  var r6 = ["<office:master-styles>", '<style:master-page style:name="mp1" style:page-layout-name="mp1">', "<style:header/>", '<style:header-left style:display="false"/>', "<style:footer/>", '<style:footer-left style:display="false"/>', "</style:master-page>", "</office:master-styles>"].join(""), e = "<office:document-styles " + bo({
    "xmlns:office": "urn:oasis:names:tc:opendocument:xmlns:office:1.0",
    "xmlns:table": "urn:oasis:names:tc:opendocument:xmlns:table:1.0",
    "xmlns:style": "urn:oasis:names:tc:opendocument:xmlns:style:1.0",
    "xmlns:text": "urn:oasis:names:tc:opendocument:xmlns:text:1.0",
    "xmlns:draw": "urn:oasis:names:tc:opendocument:xmlns:drawing:1.0",
    "xmlns:fo": "urn:oasis:names:tc:opendocument:xmlns:xsl-fo-compatible:1.0",
    "xmlns:xlink": "http://www.w3.org/1999/xlink",
    "xmlns:dc": "http://purl.org/dc/elements/1.1/",
    "xmlns:number": "urn:oasis:names:tc:opendocument:xmlns:datastyle:1.0",
    "xmlns:svg": "urn:oasis:names:tc:opendocument:xmlns:svg-compatible:1.0",
    "xmlns:of": "urn:oasis:names:tc:opendocument:xmlns:of:1.2",
    "office:version": "1.2"
  }) + ">" + r6 + "</office:document-styles>";
  return function() {
    return Ar + e;
  };
}();
var wc = /* @__PURE__ */ function() {
  var r6 = function(a) {
    return Ht(a).replace(/  +/g, function(s) {
      return '<text:s text:c="' + s.length + '"/>';
    }).replace(/\t/g, "<text:tab/>").replace(/\n/g, "</text:p><text:p>").replace(/^ /, "<text:s/>").replace(/ $/, "<text:s/>");
  }, e = `          <table:table-cell />
`, t = `          <table:covered-table-cell/>
`, n = function(a, s, o) {
    var f = [];
    f.push('      <table:table table:name="' + Ht(s.SheetNames[o]) + `" table:style-name="ta1">
`);
    var h = 0, c = 0, p = Ln(a["!ref"] || "A1"), v = a["!merges"] || [], d = 0, w = Array.isArray(a);
    if (a["!cols"]) for (c = 0; c <= p.e.c; ++c) f.push("        <table:table-column" + (a["!cols"][c] ? ' table:style-name="co' + a["!cols"][c].ods + '"' : "") + `></table:table-column>
`);
    var x = "", S = a["!rows"] || [];
    for (h = 0; h < p.s.r; ++h) x = S[h] ? ' table:style-name="ro' + S[h].ods + '"' : "", f.push("        <table:table-row" + x + `></table:table-row>
`);
    for (; h <= p.e.r; ++h) {
      for (x = S[h] ? ' table:style-name="ro' + S[h].ods + '"' : "", f.push("        <table:table-row" + x + `>
`), c = 0; c < p.s.c; ++c) f.push(e);
      for (; c <= p.e.c; ++c) {
        var A = false, b = {}, O = "";
        for (d = 0; d != v.length; ++d) if (!(v[d].s.c > c) && !(v[d].s.r > h) && !(v[d].e.c < c) && !(v[d].e.r < h)) {
          (v[d].s.c != c || v[d].s.r != h) && (A = true), b["table:number-columns-spanned"] = v[d].e.c - v[d].s.c + 1, b["table:number-rows-spanned"] = v[d].e.r - v[d].s.r + 1;
          break;
        }
        if (A) {
          f.push(t);
          continue;
        }
        var q = zt({
          r: h,
          c
        }), te = w ? (a[h] || [])[c] : a[q];
        if (te && te.f && (b["table:formula"] = Ht(Cv(te.f)), te.F && te.F.slice(0, q.length) == q)) {
          var le = Ln(te.F);
          b["table:number-matrix-columns-spanned"] = le.e.c - le.s.c + 1, b["table:number-matrix-rows-spanned"] = le.e.r - le.s.r + 1;
        }
        if (!te) {
          f.push(e);
          continue;
        }
        switch (te.t) {
          case "b":
            O = te.v ? "TRUE" : "FALSE", b["office:value-type"] = "boolean", b["office:boolean-value"] = te.v ? "true" : "false";
            break;
          case "n":
            O = te.w || String(te.v || 0), b["office:value-type"] = "float", b["office:value"] = te.v || 0;
            break;
          case "s":
          case "str":
            O = te.v == null ? "" : te.v, b["office:value-type"] = "string";
            break;
          case "d":
            O = te.w || an(te.v).toISOString(), b["office:value-type"] = "date", b["office:date-value"] = an(te.v).toISOString(), b["table:style-name"] = "ce1";
            break;
          default:
            f.push(e);
            continue;
        }
        var j = r6(O);
        if (te.l && te.l.Target) {
          var M = te.l.Target;
          M = M.charAt(0) == "#" ? "#" + Pv(M.slice(1)) : M, M.charAt(0) != "#" && !M.match(/^\w+:/) && (M = "../" + M), j = Ge("text:a", j, {
            "xlink:href": M.replace(/&/g, "&amp;")
          });
        }
        f.push("          " + Ge("table:table-cell", Ge("text:p", j, {}), b) + `
`);
      }
      f.push(`        </table:table-row>
`);
    }
    return f.push(`      </table:table>
`), f.join("");
  }, i = function(a, s) {
    a.push(` <office:automatic-styles>
`), a.push(`  <number:date-style style:name="N37" number:automatic-order="true">
`), a.push(`   <number:month number:style="long"/>
`), a.push(`   <number:text>/</number:text>
`), a.push(`   <number:day number:style="long"/>
`), a.push(`   <number:text>/</number:text>
`), a.push(`   <number:year/>
`), a.push(`  </number:date-style>
`);
    var o = 0;
    s.SheetNames.map(function(h) {
      return s.Sheets[h];
    }).forEach(function(h) {
      if (h && h["!cols"]) {
        for (var c = 0; c < h["!cols"].length; ++c) if (h["!cols"][c]) {
          var p = h["!cols"][c];
          if (p.width == null && p.wpx == null && p.wch == null) continue;
          $l(p), p.ods = o;
          var v = h["!cols"][c].wpx + "px";
          a.push('  <style:style style:name="co' + o + `" style:family="table-column">
`), a.push('   <style:table-column-properties fo:break-before="auto" style:column-width="' + v + `"/>
`), a.push(`  </style:style>
`), ++o;
        }
      }
    });
    var f = 0;
    s.SheetNames.map(function(h) {
      return s.Sheets[h];
    }).forEach(function(h) {
      if (h && h["!rows"]) {
        for (var c = 0; c < h["!rows"].length; ++c) if (h["!rows"][c]) {
          h["!rows"][c].ods = f;
          var p = h["!rows"][c].hpx + "px";
          a.push('  <style:style style:name="ro' + f + `" style:family="table-row">
`), a.push('   <style:table-row-properties fo:break-before="auto" style:row-height="' + p + `"/>
`), a.push(`  </style:style>
`), ++f;
        }
      }
    }), a.push(`  <style:style style:name="ta1" style:family="table" style:master-page-name="mp1">
`), a.push(`   <style:table-properties table:display="true" style:writing-mode="lr-tb"/>
`), a.push(`  </style:style>
`), a.push(`  <style:style style:name="ce1" style:family="table-cell" style:parent-style-name="Default" style:data-style-name="N37"/>
`), a.push(` </office:automatic-styles>
`);
  };
  return function(s, o) {
    var f = [Ar], h = bo({
      "xmlns:office": "urn:oasis:names:tc:opendocument:xmlns:office:1.0",
      "xmlns:table": "urn:oasis:names:tc:opendocument:xmlns:table:1.0",
      "xmlns:style": "urn:oasis:names:tc:opendocument:xmlns:style:1.0",
      "xmlns:text": "urn:oasis:names:tc:opendocument:xmlns:text:1.0",
      "xmlns:draw": "urn:oasis:names:tc:opendocument:xmlns:drawing:1.0",
      "xmlns:fo": "urn:oasis:names:tc:opendocument:xmlns:xsl-fo-compatible:1.0",
      "xmlns:xlink": "http://www.w3.org/1999/xlink",
      "xmlns:dc": "http://purl.org/dc/elements/1.1/",
      "xmlns:meta": "urn:oasis:names:tc:opendocument:xmlns:meta:1.0",
      "xmlns:number": "urn:oasis:names:tc:opendocument:xmlns:datastyle:1.0",
      "xmlns:presentation": "urn:oasis:names:tc:opendocument:xmlns:presentation:1.0",
      "xmlns:svg": "urn:oasis:names:tc:opendocument:xmlns:svg-compatible:1.0",
      "xmlns:chart": "urn:oasis:names:tc:opendocument:xmlns:chart:1.0",
      "xmlns:dr3d": "urn:oasis:names:tc:opendocument:xmlns:dr3d:1.0",
      "xmlns:math": "http://www.w3.org/1998/Math/MathML",
      "xmlns:form": "urn:oasis:names:tc:opendocument:xmlns:form:1.0",
      "xmlns:script": "urn:oasis:names:tc:opendocument:xmlns:script:1.0",
      "xmlns:ooo": "http://openoffice.org/2004/office",
      "xmlns:ooow": "http://openoffice.org/2004/writer",
      "xmlns:oooc": "http://openoffice.org/2004/calc",
      "xmlns:dom": "http://www.w3.org/2001/xml-events",
      "xmlns:xforms": "http://www.w3.org/2002/xforms",
      "xmlns:xsd": "http://www.w3.org/2001/XMLSchema",
      "xmlns:xsi": "http://www.w3.org/2001/XMLSchema-instance",
      "xmlns:sheet": "urn:oasis:names:tc:opendocument:sh33tjs:1.0",
      "xmlns:rpt": "http://openoffice.org/2005/report",
      "xmlns:of": "urn:oasis:names:tc:opendocument:xmlns:of:1.2",
      "xmlns:xhtml": "http://www.w3.org/1999/xhtml",
      "xmlns:grddl": "http://www.w3.org/2003/g/data-view#",
      "xmlns:tableooo": "http://openoffice.org/2009/table",
      "xmlns:drawooo": "http://openoffice.org/2010/draw",
      "xmlns:calcext": "urn:org:documentfoundation:names:experimental:calc:xmlns:calcext:1.0",
      "xmlns:loext": "urn:org:documentfoundation:names:experimental:office:xmlns:loext:1.0",
      "xmlns:field": "urn:openoffice:names:experimental:ooo-ms-interop:xmlns:field:1.0",
      "xmlns:formx": "urn:openoffice:names:experimental:ooxml-odf-interop:xmlns:form:1.0",
      "xmlns:css3t": "http://www.w3.org/TR/css3-text/",
      "office:version": "1.2"
    }), c = bo({
      "xmlns:config": "urn:oasis:names:tc:opendocument:xmlns:config:1.0",
      "office:mimetype": "application/vnd.oasis.opendocument.spreadsheet"
    });
    o.bookType == "fods" ? (f.push("<office:document" + h + c + `>
`), f.push(Mu().replace(/office:document-meta/g, "office:meta"))) : f.push("<office:document-content" + h + `>
`), i(f, s), f.push(`  <office:body>
`), f.push(`    <office:spreadsheet>
`);
    for (var p = 0; p != s.SheetNames.length; ++p) f.push(n(s.Sheets[s.SheetNames[p]], s, p));
    return f.push(`    </office:spreadsheet>
`), f.push(`  </office:body>
`), o.bookType == "fods" ? f.push("</office:document>") : f.push("</office:document-content>"), f.join("");
  };
}();
function A1(r6, e) {
  if (e.bookType == "fods") return wc(r6, e);
  var t = Bl(), n = "", i = [], a = [];
  return n = "mimetype", bt(t, n, "application/vnd.oasis.opendocument.spreadsheet"), n = "content.xml", bt(t, n, wc(r6, e)), i.push([n, "text/xml"]), a.push([n, "ContentFile"]), n = "styles.xml", bt(t, n, h4(r6, e)), i.push([n, "text/xml"]), a.push([n, "StylesFile"]), n = "meta.xml", bt(t, n, Ar + Mu(
    /*::wb, opts*/
  )), i.push([n, "text/xml"]), a.push([n, "MetadataFile"]), n = "manifest.rdf", bt(t, n, Sp(
    a
    /*, opts*/
  )), i.push([n, "application/rdf+xml"]), n = "META-INF/manifest.xml", bt(t, n, yp(
    i
    /*, opts*/
  )), t;
}
function $0(r6) {
  return new DataView(r6.buffer, r6.byteOffset, r6.byteLength);
}
function c4(r6) {
  return typeof TextEncoder < "u" ? new TextEncoder().encode(r6) : ri(Di(r6));
}
function u4(r6, e) {
  e: for (var t = 0; t <= r6.length - e.length; ++t) {
    for (var n = 0; n < e.length; ++n) if (r6[t + n] != e[n]) continue e;
    return true;
  }
  return false;
}
function ca(r6) {
  var e = r6.reduce(function(i, a) {
    return i + a.length;
  }, 0), t = new Uint8Array(e), n = 0;
  return r6.forEach(function(i) {
    t.set(i, n), n += i.length;
  }), t;
}
function d4(r6, e, t) {
  var n = Math.floor(t == 0 ? 0 : Math.LOG10E * Math.log(Math.abs(t))) + 6176 - 20, i = t / Math.pow(10, n - 6176);
  r6[e + 15] |= n >> 7, r6[e + 14] |= (n & 127) << 1;
  for (var a = 0; i >= 1; ++a, i /= 256) r6[e + a] = i & 255;
  r6[e + 15] |= t >= 0 ? 0 : 128;
}
function To(r6, e) {
  var t = e ? e[0] : 0, n = r6[t] & 127;
  e: if (r6[t++] >= 128 && (n |= (r6[t] & 127) << 7, r6[t++] < 128 || (n |= (r6[t] & 127) << 14, r6[t++] < 128) || (n |= (r6[t] & 127) << 21, r6[t++] < 128) || (n += (r6[t] & 127) * Math.pow(2, 28), ++t, r6[t++] < 128) || (n += (r6[t] & 127) * Math.pow(2, 35), ++t, r6[t++] < 128) || (n += (r6[t] & 127) * Math.pow(2, 42), ++t, r6[t++] < 128))) break e;
  return e && (e[0] = t), n;
}
function Ut(r6) {
  var e = new Uint8Array(7);
  e[0] = r6 & 127;
  var t = 1;
  e: if (r6 > 127) {
    if (e[t - 1] |= 128, e[t] = r6 >> 7 & 127, ++t, r6 <= 16383 || (e[t - 1] |= 128, e[t] = r6 >> 14 & 127, ++t, r6 <= 2097151) || (e[t - 1] |= 128, e[t] = r6 >> 21 & 127, ++t, r6 <= 268435455) || (e[t - 1] |= 128, e[t] = r6 / 256 >>> 21 & 127, ++t, r6 <= 34359738367) || (e[t - 1] |= 128, e[t] = r6 / 65536 >>> 21 & 127, ++t, r6 <= 4398046511103)) break e;
    e[t - 1] |= 128, e[t] = r6 / 16777216 >>> 21 & 127, ++t;
  }
  return e.slice(0, t);
}
function _s(r6) {
  var e = 0, t = r6[e] & 127;
  e: if (r6[e++] >= 128) {
    if (t |= (r6[e] & 127) << 7, r6[e++] < 128 || (t |= (r6[e] & 127) << 14, r6[e++] < 128) || (t |= (r6[e] & 127) << 21, r6[e++] < 128)) break e;
    t |= (r6[e] & 127) << 28;
  }
  return t;
}
function Nr(r6) {
  for (var e = [], t = [0]; t[0] < r6.length; ) {
    var n = t[0], i = To(r6, t), a = i & 7;
    i = Math.floor(i / 8);
    var s = 0, o;
    if (i == 0) break;
    switch (a) {
      case 0:
        {
          for (var f = t[0]; r6[t[0]++] >= 128; ) ;
          o = r6.slice(f, t[0]);
        }
        break;
      case 5:
        s = 4, o = r6.slice(t[0], t[0] + s), t[0] += s;
        break;
      case 1:
        s = 8, o = r6.slice(t[0], t[0] + s), t[0] += s;
        break;
      case 2:
        s = To(r6, t), o = r6.slice(t[0], t[0] + s), t[0] += s;
        break;
      case 3:
      case 4:
      default:
        throw new Error("PB Type ".concat(a, " for Field ").concat(i, " at offset ").concat(n));
    }
    var h = {
      data: o,
      type: a
    };
    e[i] == null ? e[i] = [h] : e[i].push(h);
  }
  return e;
}
function Mr(r6) {
  var e = [];
  return r6.forEach(function(t, n) {
    t.forEach(function(i) {
      i.data && (e.push(Ut(n * 8 + i.type)), i.type == 2 && e.push(Ut(i.data.length)), e.push(i.data));
    });
  }), ca(e);
}
function Jn(r6) {
  for (var e, t = [], n = [0]; n[0] < r6.length; ) {
    var i = To(r6, n), a = Nr(r6.slice(n[0], n[0] + i));
    n[0] += i;
    var s = {
      id: _s(a[1][0].data),
      messages: []
    };
    a[2].forEach(function(o) {
      var f = Nr(o.data), h = _s(f[3][0].data);
      s.messages.push({
        meta: f,
        data: r6.slice(n[0], n[0] + h)
      }), n[0] += h;
    }), (e = a[3]) != null && e[0] && (s.merge = _s(a[3][0].data) >>> 0 > 0), t.push(s);
  }
  return t;
}
function ls(r6) {
  var e = [];
  return r6.forEach(function(t) {
    var n = [];
    n[1] = [{
      data: Ut(t.id),
      type: 0
    }], n[2] = [], t.merge != null && (n[3] = [{
      data: Ut(+!!t.merge),
      type: 0
    }]);
    var i = [];
    t.messages.forEach(function(s) {
      i.push(s.data), s.meta[3] = [{
        type: 0,
        data: Ut(s.data.length)
      }], n[2].push({
        data: Mr(s.meta),
        type: 2
      });
    });
    var a = Mr(n);
    e.push(Ut(a.length)), e.push(a), i.forEach(function(s) {
      return e.push(s);
    });
  }), ca(e);
}
function p4(r6, e) {
  if (r6 != 0) throw new Error("Unexpected Snappy chunk type ".concat(r6));
  for (var t = [0], n = To(e, t), i = []; t[0] < e.length; ) {
    var a = e[t[0]] & 3;
    if (a == 0) {
      var s = e[t[0]++] >> 2;
      if (s < 60) ++s;
      else {
        var o = s - 59;
        s = e[t[0]], o > 1 && (s |= e[t[0] + 1] << 8), o > 2 && (s |= e[t[0] + 2] << 16), o > 3 && (s |= e[t[0] + 3] << 24), s >>>= 0, s++, t[0] += o;
      }
      i.push(e.slice(t[0], t[0] + s)), t[0] += s;
      continue;
    } else {
      var f = 0, h = 0;
      if (a == 1 ? (h = (e[t[0]] >> 2 & 7) + 4, f = (e[t[0]++] & 224) << 3, f |= e[t[0]++]) : (h = (e[t[0]++] >> 2) + 1, a == 2 ? (f = e[t[0]] | e[t[0] + 1] << 8, t[0] += 2) : (f = (e[t[0]] | e[t[0] + 1] << 8 | e[t[0] + 2] << 16 | e[t[0] + 3] << 24) >>> 0, t[0] += 4)), i = [ca(i)], f == 0) throw new Error("Invalid offset 0");
      if (f > i[0].length) throw new Error("Invalid offset beyond length");
      if (h >= f) for (i.push(i[0].slice(-f)), h -= f; h >= i[i.length - 1].length; ) i.push(i[i.length - 1]), h -= i[i.length - 1].length;
      i.push(i[0].slice(-f, -f + h));
    }
  }
  var c = ca(i);
  if (c.length != n) throw new Error("Unexpected length: ".concat(c.length, " != ").concat(n));
  return c;
}
function Zn(r6) {
  for (var e = [], t = 0; t < r6.length; ) {
    var n = r6[t++], i = r6[t] | r6[t + 1] << 8 | r6[t + 2] << 16;
    t += 3, e.push(p4(n, r6.slice(t, t + i))), t += i;
  }
  if (t !== r6.length) throw new Error("data is not a valid framed stream!");
  return ca(e);
}
function hs(r6) {
  for (var e = [], t = 0; t < r6.length; ) {
    var n = Math.min(r6.length - t, 268435455), i = new Uint8Array(4);
    e.push(i);
    var a = Ut(n), s = a.length;
    e.push(a), n <= 60 ? (s++, e.push(new Uint8Array([n - 1 << 2]))) : n <= 256 ? (s += 2, e.push(new Uint8Array([240, n - 1 & 255]))) : n <= 65536 ? (s += 3, e.push(new Uint8Array([244, n - 1 & 255, n - 1 >> 8 & 255]))) : n <= 16777216 ? (s += 4, e.push(new Uint8Array([248, n - 1 & 255, n - 1 >> 8 & 255, n - 1 >> 16 & 255]))) : n <= 4294967296 && (s += 5, e.push(new Uint8Array([252, n - 1 & 255, n - 1 >> 8 & 255, n - 1 >> 16 & 255, n - 1 >>> 24 & 255]))), e.push(r6.slice(t, t + n)), s += n, i[0] = 0, i[1] = s & 255, i[2] = s >> 8 & 255, i[3] = s >> 16 & 255, t += n;
  }
  return ca(e);
}
function rl(r6, e) {
  var t = new Uint8Array(32), n = $0(t), i = 12, a = 0;
  switch (t[0] = 5, r6.t) {
    case "n":
      t[1] = 2, d4(t, i, r6.v), a |= 1, i += 16;
      break;
    case "b":
      t[1] = 6, n.setFloat64(i, r6.v ? 1 : 0, true), a |= 2, i += 8;
      break;
    case "s":
      if (e.indexOf(r6.v) == -1) throw new Error("Value ".concat(r6.v, " missing from SST!"));
      t[1] = 3, n.setUint32(i, e.indexOf(r6.v), true), a |= 8, i += 4;
      break;
    default:
      throw "unsupported cell type " + r6.t;
  }
  return n.setUint32(8, a, true), t.slice(0, i);
}
function nl(r6, e) {
  var t = new Uint8Array(32), n = $0(t), i = 12, a = 0;
  switch (t[0] = 3, r6.t) {
    case "n":
      t[2] = 2, n.setFloat64(i, r6.v, true), a |= 32, i += 8;
      break;
    case "b":
      t[2] = 6, n.setFloat64(i, r6.v ? 1 : 0, true), a |= 32, i += 8;
      break;
    case "s":
      if (e.indexOf(r6.v) == -1) throw new Error("Value ".concat(r6.v, " missing from SST!"));
      t[2] = 3, n.setUint32(i, e.indexOf(r6.v), true), a |= 16, i += 4;
      break;
    default:
      throw "unsupported cell type " + r6.t;
  }
  return n.setUint32(4, a, true), t.slice(0, i);
}
function na(r6) {
  var e = Nr(r6);
  return To(e[1][0].data);
}
function g4(r6, e, t) {
  var n, i, a, s;
  if (!((n = r6[6]) != null && n[0]) || !((i = r6[7]) != null && i[0])) throw "Mutation only works on post-BNC storages!";
  var o = ((s = (a = r6[8]) == null ? void 0 : a[0]) == null ? void 0 : s.data) && _s(r6[8][0].data) > 0 || false;
  if (o) throw "Math only works with normal offsets";
  for (var f = 0, h = $0(r6[7][0].data), c = 0, p = [], v = $0(r6[4][0].data), d = 0, w = [], x = 0; x < e.length; ++x) {
    if (e[x] == null) {
      h.setUint16(x * 2, 65535, true), v.setUint16(x * 2, 65535);
      continue;
    }
    h.setUint16(x * 2, c, true), v.setUint16(x * 2, d, true);
    var S, A;
    switch (typeof e[x]) {
      case "string":
        S = rl({
          t: "s",
          v: e[x]
        }, t), A = nl({
          t: "s",
          v: e[x]
        }, t);
        break;
      case "number":
        S = rl({
          t: "n",
          v: e[x]
        }, t), A = nl({
          t: "n",
          v: e[x]
        }, t);
        break;
      case "boolean":
        S = rl({
          t: "b",
          v: e[x]
        }, t), A = nl({
          t: "b",
          v: e[x]
        }, t);
        break;
      default:
        throw new Error("Unsupported value " + e[x]);
    }
    p.push(S), c += S.length, w.push(A), d += A.length, ++f;
  }
  for (r6[2][0].data = Ut(f); x < r6[7][0].data.length / 2; ++x) h.setUint16(x * 2, 65535, true), v.setUint16(x * 2, 65535, true);
  return r6[6][0].data = ca(p), r6[3][0].data = ca(w), f;
}
function v4(r6, e) {
  if (!e || !e.numbers) throw new Error("Must pass a `numbers` option -- check the README");
  var t = r6.Sheets[r6.SheetNames[0]];
  r6.SheetNames.length > 1 && console.error("The Numbers writer currently writes only the first table");
  var n = Ln(t["!ref"]);
  n.s.r = n.s.c = 0;
  var i = false;
  n.e.c > 9 && (i = true, n.e.c = 9), n.e.r > 49 && (i = true, n.e.r = 49), i && console.error("The Numbers writer is currently limited to ".concat(Sr(n)));
  var a = K0(t, {
    range: n,
    header: 1
  }), s = ["~Sh33tJ5~"];
  a.forEach(function(L) {
    return L.forEach(function(N) {
      typeof N == "string" && s.push(N);
    });
  });
  var o = {}, f = [], h = Xt.read(e.numbers, {
    type: "base64"
  });
  h.FileIndex.map(function(L, N) {
    return [L, h.FullPaths[N]];
  }).forEach(function(L) {
    var N = L[0], C = L[1];
    if (N.type == 2 && N.name.match(/\.iwa/)) {
      var z = N.content, re = Zn(z), se = Jn(re);
      se.forEach(function(ie) {
        f.push(ie.id), o[ie.id] = {
          deps: [],
          location: C,
          type: _s(ie.messages[0].meta[1][0].data)
        };
      });
    }
  }), f.sort(function(L, N) {
    return L - N;
  });
  var c = f.filter(function(L) {
    return L > 1;
  }).map(function(L) {
    return [L, Ut(L)];
  });
  h.FileIndex.map(function(L, N) {
    return [L, h.FullPaths[N]];
  }).forEach(function(L) {
    var N = L[0];
    if (L[1], !!N.name.match(/\.iwa/)) {
      var C = Jn(Zn(N.content));
      C.forEach(function(z) {
        z.messages.forEach(function(re) {
          c.forEach(function(se) {
            z.messages.some(function(ie) {
              return _s(ie.meta[1][0].data) != 11006 && u4(ie.data, se[1]);
            }) && o[se[0]].deps.push(z.id);
          });
        });
      });
    }
  });
  for (var p = Xt.find(h, o[1].location), v = Jn(Zn(p.content)), d, w = 0; w < v.length; ++w) {
    var x = v[w];
    x.id == 1 && (d = x);
  }
  var S = na(Nr(d.messages[0].data)[1][0].data);
  for (p = Xt.find(h, o[S].location), v = Jn(Zn(p.content)), w = 0; w < v.length; ++w) x = v[w], x.id == S && (d = x);
  for (S = na(Nr(d.messages[0].data)[2][0].data), p = Xt.find(h, o[S].location), v = Jn(Zn(p.content)), w = 0; w < v.length; ++w) x = v[w], x.id == S && (d = x);
  for (S = na(Nr(d.messages[0].data)[2][0].data), p = Xt.find(h, o[S].location), v = Jn(Zn(p.content)), w = 0; w < v.length; ++w) x = v[w], x.id == S && (d = x);
  var A = Nr(d.messages[0].data);
  {
    A[6][0].data = Ut(n.e.r + 1), A[7][0].data = Ut(n.e.c + 1);
    var b = na(A[46][0].data), O = Xt.find(h, o[b].location), q = Jn(Zn(O.content));
    {
      for (var te = 0; te < q.length && q[te].id != b; ++te) ;
      if (q[te].id != b) throw "Bad ColumnRowUIDMapArchive";
      var le = Nr(q[te].messages[0].data);
      le[1] = [], le[2] = [], le[3] = [];
      for (var j = 0; j <= n.e.c; ++j) {
        var M = [];
        M[1] = M[2] = [{
          type: 0,
          data: Ut(j + 420690)
        }], le[1].push({
          type: 2,
          data: Mr(M)
        }), le[2].push({
          type: 0,
          data: Ut(j)
        }), le[3].push({
          type: 0,
          data: Ut(j)
        });
      }
      le[4] = [], le[5] = [], le[6] = [];
      for (var H = 0; H <= n.e.r; ++H) M = [], M[1] = M[2] = [{
        type: 0,
        data: Ut(H + 726270)
      }], le[4].push({
        type: 2,
        data: Mr(M)
      }), le[5].push({
        type: 0,
        data: Ut(H)
      }), le[6].push({
        type: 0,
        data: Ut(H)
      });
      q[te].messages[0].data = Mr(le);
    }
    O.content = hs(ls(q)), O.size = O.content.length, delete A[46];
    var ee = Nr(A[4][0].data);
    {
      ee[7][0].data = Ut(n.e.r + 1);
      var F = Nr(ee[1][0].data), P = na(F[2][0].data);
      O = Xt.find(h, o[P].location), q = Jn(Zn(O.content));
      {
        if (q[0].id != P) throw "Bad HeaderStorageBucket";
        var Y = Nr(q[0].messages[0].data);
        for (H = 0; H < a.length; ++H) {
          var Q = Nr(Y[2][0].data);
          Q[1][0].data = Ut(H), Q[4][0].data = Ut(a[H].length), Y[2][H] = {
            type: Y[2][0].type,
            data: Mr(Q)
          };
        }
        q[0].messages[0].data = Mr(Y);
      }
      O.content = hs(ls(q)), O.size = O.content.length;
      var ce = na(ee[2][0].data);
      O = Xt.find(h, o[ce].location), q = Jn(Zn(O.content));
      {
        if (q[0].id != ce) throw "Bad HeaderStorageBucket";
        for (Y = Nr(q[0].messages[0].data), j = 0; j <= n.e.c; ++j) Q = Nr(Y[2][0].data), Q[1][0].data = Ut(j), Q[4][0].data = Ut(n.e.r + 1), Y[2][j] = {
          type: Y[2][0].type,
          data: Mr(Q)
        };
        q[0].messages[0].data = Mr(Y);
      }
      O.content = hs(ls(q)), O.size = O.content.length;
      var we = na(ee[4][0].data);
      (function() {
        for (var L = Xt.find(h, o[we].location), N = Jn(Zn(L.content)), C, z = 0; z < N.length; ++z) {
          var re = N[z];
          re.id == we && (C = re);
        }
        var se = Nr(C.messages[0].data);
        {
          se[3] = [];
          var ie = [];
          s.forEach(function(Oe, qe) {
            ie[1] = [{
              type: 0,
              data: Ut(qe)
            }], ie[2] = [{
              type: 0,
              data: Ut(1)
            }], ie[3] = [{
              type: 2,
              data: c4(Oe)
            }], se[3].push({
              type: 2,
              data: Mr(ie)
            });
          });
        }
        C.messages[0].data = Mr(se);
        var ve = ls(N), Ce = hs(ve);
        L.content = Ce, L.size = L.content.length;
      })();
      var Se = Nr(ee[3][0].data);
      {
        var de = Se[1][0];
        delete Se[2];
        var Ae = Nr(de.data);
        {
          var be = na(Ae[2][0].data);
          (function() {
            for (var L = Xt.find(h, o[be].location), N = Jn(Zn(L.content)), C, z = 0; z < N.length; ++z) {
              var re = N[z];
              re.id == be && (C = re);
            }
            var se = Nr(C.messages[0].data);
            {
              delete se[6], delete Se[7];
              var ie = new Uint8Array(se[5][0].data);
              se[5] = [];
              for (var ve = 0, Ce = 0; Ce <= n.e.r; ++Ce) {
                var Oe = Nr(ie);
                ve += g4(Oe, a[Ce], s), Oe[1][0].data = Ut(Ce), se[5].push({
                  data: Mr(Oe),
                  type: 2
                });
              }
              se[1] = [{
                type: 0,
                data: Ut(n.e.c + 1)
              }], se[2] = [{
                type: 0,
                data: Ut(n.e.r + 1)
              }], se[3] = [{
                type: 0,
                data: Ut(ve)
              }], se[4] = [{
                type: 0,
                data: Ut(n.e.r + 1)
              }];
            }
            C.messages[0].data = Mr(se);
            var qe = ls(N), Ye = hs(qe);
            L.content = Ye, L.size = L.content.length;
          })();
        }
        de.data = Mr(Ae);
      }
      ee[3][0].data = Mr(Se);
    }
    A[4][0].data = Mr(ee);
  }
  d.messages[0].data = Mr(A);
  var ze = ls(v), y = hs(ze);
  return p.content = y, p.size = p.content.length, h;
}
function m4(r6) {
  return function(t) {
    for (var n = 0; n != r6.length; ++n) {
      var i = r6[n];
      t[i[0]] === void 0 && (t[i[0]] = i[1]), i[2] === "n" && (t[i[0]] = Number(t[i[0]]));
    }
  };
}
function eh(r6) {
  m4([
    ["cellDates", false],
    /* write date cells with type `d` */
    ["bookSST", false],
    /* Generate Shared String Table */
    ["bookType", "xlsx"],
    /* Type of workbook (xlsx/m/b) */
    ["compression", false],
    /* Use file compression */
    ["WTF", false]
    /* WTF mode (throws errors) */
  ])(r6);
}
function x4(r6, e) {
  return e.bookType == "ods" ? A1(r6, e) : e.bookType == "numbers" ? v4(r6, e) : e.bookType == "xlsb" ? w4(r6, e) : y4(r6, e);
}
function w4(r6, e) {
  vs = 1024, r6 && !r6.SSF && (r6.SSF = gn(lr)), r6 && r6.SSF && (nf(), rf(r6.SSF), e.revssf = af(r6.SSF), e.revssf[r6.SSF[65535]] = 0, e.ssf = r6.SSF), e.rels = {}, e.wbrels = {}, e.Strings = /*::((*/
  [], e.Strings.Count = 0, e.Strings.Unique = 0, xo ? e.revStrings = /* @__PURE__ */ new Map() : (e.revStrings = {}, e.revStrings.foo = [], delete e.revStrings.foo);
  var t = e.bookType == "xlsb" ? "bin" : "xml", n = a1.indexOf(e.bookType) > -1, i = Ou();
  eh(e = e || {});
  var a = Bl(), s = "", o = 0;
  if (e.cellXfs = [], pa(e.cellXfs, {}, {
    revssf: {
      General: 0
    }
  }), r6.Props || (r6.Props = {}), s = "docProps/core.xml", bt(a, s, Bu(r6.Props, e)), i.coreprops.push(s), qt(e.rels, 2, s, Dt.CORE_PROPS), s = "docProps/app.xml", !(r6.Props && r6.Props.SheetNames)) if (!r6.Workbook || !r6.Workbook.Sheets) r6.Props.SheetNames = r6.SheetNames;
  else {
    for (var f = [], h = 0; h < r6.SheetNames.length; ++h) (r6.Workbook.Sheets[h] || {}).Hidden != 2 && f.push(r6.SheetNames[h]);
    r6.Props.SheetNames = f;
  }
  for (r6.Props.Worksheets = r6.Props.SheetNames.length, bt(a, s, Uu(r6.Props)), i.extprops.push(s), qt(e.rels, 3, s, Dt.EXT_PROPS), r6.Custprops !== r6.Props && Hr(r6.Custprops || {}).length > 0 && (s = "docProps/custom.xml", bt(a, s, qu(r6.Custprops)), i.custprops.push(s), qt(e.rels, 4, s, Dt.CUST_PROPS)), o = 1; o <= r6.SheetNames.length; ++o) {
    var c = {
      "!id": {}
    }, p = r6.Sheets[r6.SheetNames[o - 1]], v = (p || {})["!type"] || "sheet";
    switch (v) {
      case "chart":
      default:
        s = "xl/worksheets/sheet" + o + "." + t, bt(a, s, Sx(o - 1, s, e, r6, c)), i.sheets.push(s), qt(e.wbrels, -1, "worksheets/sheet" + o + "." + t, Dt.WS[0]);
    }
    if (p) {
      var d = p["!comments"], w = false, x = "";
      d && d.length > 0 && (x = "xl/comments" + o + "." + t, bt(a, x, Tx(d, x)), i.comments.push(x), qt(c, -1, "../comments" + o + "." + t, Dt.CMNT), w = true), p["!legacy"] && w && bt(a, "xl/drawings/vmlDrawing" + o + ".vml", n1(o, p["!comments"])), delete p["!comments"], delete p["!legacy"];
    }
    c["!id"].rId1 && bt(a, Ru(s), ws(c));
  }
  return e.Strings != null && e.Strings.length > 0 && (s = "xl/sharedStrings." + t, bt(a, s, bx(e.Strings, s, e)), i.strs.push(s), qt(e.wbrels, -1, "sharedStrings." + t, Dt.SST)), s = "xl/workbook." + t, bt(a, s, _x(r6, s)), i.workbooks.push(s), qt(e.rels, 1, s, Dt.WB), s = "xl/theme/theme1.xml", bt(a, s, t1(r6.Themes, e)), i.themes.push(s), qt(e.wbrels, -1, "theme/theme1.xml", Dt.THEME), s = "xl/styles." + t, bt(a, s, Ax(r6, s, e)), i.styles.push(s), qt(e.wbrels, -1, "styles." + t, Dt.STY), r6.vbaraw && n && (s = "xl/vbaProject.bin", bt(a, s, r6.vbaraw), i.vba.push(s), qt(e.wbrels, -1, "vbaProject.bin", Dt.VBA)), s = "xl/metadata." + t, bt(a, s, Ex(s)), i.metadata.push(s), qt(e.wbrels, -1, "metadata." + t, Dt.XLMETA), bt(a, "[Content_Types].xml", Iu(i, e)), bt(a, "_rels/.rels", ws(e.rels)), bt(a, "xl/_rels/workbook." + t + ".rels", ws(e.wbrels)), delete e.revssf, delete e.ssf, a;
}
function y4(r6, e) {
  vs = 1024, r6 && !r6.SSF && (r6.SSF = gn(lr)), r6 && r6.SSF && (nf(), rf(r6.SSF), e.revssf = af(r6.SSF), e.revssf[r6.SSF[65535]] = 0, e.ssf = r6.SSF), e.rels = {}, e.wbrels = {}, e.Strings = /*::((*/
  [], e.Strings.Count = 0, e.Strings.Unique = 0, xo ? e.revStrings = /* @__PURE__ */ new Map() : (e.revStrings = {}, e.revStrings.foo = [], delete e.revStrings.foo);
  var t = "xml", n = a1.indexOf(e.bookType) > -1, i = Ou();
  eh(e = e || {});
  var a = Bl(), s = "", o = 0;
  if (e.cellXfs = [], pa(e.cellXfs, {}, {
    revssf: {
      General: 0
    }
  }), r6.Props || (r6.Props = {}), s = "docProps/core.xml", bt(a, s, Bu(r6.Props, e)), i.coreprops.push(s), qt(e.rels, 2, s, Dt.CORE_PROPS), s = "docProps/app.xml", !(r6.Props && r6.Props.SheetNames)) if (!r6.Workbook || !r6.Workbook.Sheets) r6.Props.SheetNames = r6.SheetNames;
  else {
    for (var f = [], h = 0; h < r6.SheetNames.length; ++h) (r6.Workbook.Sheets[h] || {}).Hidden != 2 && f.push(r6.SheetNames[h]);
    r6.Props.SheetNames = f;
  }
  r6.Props.Worksheets = r6.Props.SheetNames.length, bt(a, s, Uu(r6.Props)), i.extprops.push(s), qt(e.rels, 3, s, Dt.EXT_PROPS), r6.Custprops !== r6.Props && Hr(r6.Custprops || {}).length > 0 && (s = "docProps/custom.xml", bt(a, s, qu(r6.Custprops)), i.custprops.push(s), qt(e.rels, 4, s, Dt.CUST_PROPS));
  var c = ["SheetJ5"];
  for (e.tcid = 0, o = 1; o <= r6.SheetNames.length; ++o) {
    var p = {
      "!id": {}
    }, v = r6.Sheets[r6.SheetNames[o - 1]], d = (v || {})["!type"] || "sheet";
    switch (d) {
      case "chart":
      default:
        s = "xl/worksheets/sheet" + o + "." + t, bt(a, s, p1(o - 1, e, r6, p)), i.sheets.push(s), qt(e.wbrels, -1, "worksheets/sheet" + o + "." + t, Dt.WS[0]);
    }
    if (v) {
      var w = v["!comments"], x = false, S = "";
      if (w && w.length > 0) {
        var A = false;
        w.forEach(function(b) {
          b[1].forEach(function(O) {
            O.T == true && (A = true);
          });
        }), A && (S = "xl/threadedComments/threadedComment" + o + "." + t, bt(a, S, J5(w, c, e)), i.threadedcomments.push(S), qt(p, -1, "../threadedComments/threadedComment" + o + "." + t, Dt.TCMNT)), S = "xl/comments" + o + "." + t, bt(a, S, i1(w)), i.comments.push(S), qt(p, -1, "../comments" + o + "." + t, Dt.CMNT), x = true;
      }
      v["!legacy"] && x && bt(a, "xl/drawings/vmlDrawing" + o + ".vml", n1(o, v["!comments"])), delete v["!comments"], delete v["!legacy"];
    }
    p["!id"].rId1 && bt(a, Ru(s), ws(p));
  }
  return e.Strings != null && e.Strings.length > 0 && (s = "xl/sharedStrings." + t, bt(a, s, $u(e.Strings, e)), i.strs.push(s), qt(e.wbrels, -1, "sharedStrings." + t, Dt.SST)), s = "xl/workbook." + t, bt(a, s, m1(r6)), i.workbooks.push(s), qt(e.rels, 1, s, Dt.WB), s = "xl/theme/theme1.xml", bt(a, s, t1(r6.Themes, e)), i.themes.push(s), qt(e.wbrels, -1, "theme/theme1.xml", Dt.THEME), s = "xl/styles." + t, bt(a, s, Qu(r6, e)), i.styles.push(s), qt(e.wbrels, -1, "styles." + t, Dt.STY), r6.vbaraw && n && (s = "xl/vbaProject.bin", bt(a, s, r6.vbaraw), i.vba.push(s), qt(e.wbrels, -1, "vbaProject.bin", Dt.VBA)), s = "xl/metadata." + t, bt(a, s, r1()), i.metadata.push(s), qt(e.wbrels, -1, "metadata." + t, Dt.XLMETA), c.length > 1 && (s = "xl/persons/person.xml", bt(a, s, Z5(c)), i.people.push(s), qt(e.wbrels, -1, "persons/person.xml", Dt.PEOPLE)), bt(a, "[Content_Types].xml", Iu(i, e)), bt(a, "_rels/.rels", ws(e.rels)), bt(a, "xl/_rels/workbook." + t + ".rels", ws(e.wbrels)), delete e.revssf, delete e.ssf, a;
}
function _4(r6, e) {
  var t = "";
  switch ((e || {}).type || "base64") {
    case "buffer":
      return [r6[0], r6[1], r6[2], r6[3], r6[4], r6[5], r6[6], r6[7]];
    case "base64":
      t = ji(r6.slice(0, 12));
      break;
    case "binary":
      t = r6;
      break;
    case "array":
      return [r6[0], r6[1], r6[2], r6[3], r6[4], r6[5], r6[6], r6[7]];
    default:
      throw new Error("Unrecognized type " + (e && e.type || "undefined"));
  }
  return [t.charCodeAt(0), t.charCodeAt(1), t.charCodeAt(2), t.charCodeAt(3), t.charCodeAt(4), t.charCodeAt(5), t.charCodeAt(6), t.charCodeAt(7)];
}
function b1(r6, e) {
  switch (e.type) {
    case "base64":
    case "binary":
      break;
    case "buffer":
    case "array":
      e.type = "";
      break;
    case "file":
      return Lo(e.file, Xt.write(r6, {
        type: It ? "buffer" : ""
      }));
    case "string":
      throw new Error("'string' output type invalid for '" + e.bookType + "' files");
    default:
      throw new Error("Unrecognized type " + e.type);
  }
  return Xt.write(r6, e);
}
function S4(r6, e) {
  var t = gn(e || {}), n = x4(r6, t);
  return A4(n, t);
}
function A4(r6, e) {
  var t = {}, n = It ? "nodebuffer" : typeof Uint8Array < "u" ? "array" : "string";
  if (e.compression && (t.compression = "DEFLATE"), e.password) t.type = n;
  else switch (e.type) {
    case "base64":
      t.type = "base64";
      break;
    case "binary":
      t.type = "string";
      break;
    case "string":
      throw new Error("'string' output type invalid for '" + e.bookType + "' files");
    case "buffer":
    case "file":
      t.type = n;
      break;
    default:
      throw new Error("Unrecognized type " + e.type);
  }
  var i = r6.FullPaths ? Xt.write(r6, {
    fileType: "zip",
    type: (
      /*::(*/
      {
        nodebuffer: "buffer",
        string: "binary"
      }[t.type] || t.type
    ),
    compression: !!e.compression
  }) : r6.generate(t);
  if (typeof Deno < "u" && typeof i == "string") {
    if (e.type == "binary" || e.type == "base64") return i;
    i = new Uint8Array(tf(i));
  }
  return e.password && typeof encrypt_agile < "u" ? b1(encrypt_agile(i, e.password), e) : e.type === "file" ? Lo(e.file, i) : e.type == "string" ? po(
    /*::(*/
    i
    /*:: :any)*/
  ) : i;
}
function b4(r6, e) {
  var t = e || {}, n = Ux(r6, t);
  return b1(n, t);
}
function gi(r6, e, t) {
  t || (t = "");
  var n = t + r6;
  switch (e.type) {
    case "base64":
      return So(Di(n));
    case "binary":
      return Di(n);
    case "string":
      return r6;
    case "file":
      return Lo(e.file, n, "utf8");
    case "buffer":
      return It ? Hi(n, "utf8") : typeof TextEncoder < "u" ? new TextEncoder().encode(n) : gi(n, {
        type: "binary"
      }).split("").map(function(i) {
        return i.charCodeAt(0);
      });
  }
  throw new Error("Unrecognized type " + e.type);
}
function T4(r6, e) {
  switch (e.type) {
    case "base64":
      return So(r6);
    case "binary":
      return r6;
    case "string":
      return r6;
    case "file":
      return Lo(e.file, r6, "binary");
    case "buffer":
      return It ? Hi(r6, "binary") : r6.split("").map(function(t) {
        return t.charCodeAt(0);
      });
  }
  throw new Error("Unrecognized type " + e.type);
}
function F0(r6, e) {
  switch (e.type) {
    case "string":
    case "base64":
    case "binary":
      for (var t = "", n = 0; n < r6.length; ++n) t += String.fromCharCode(r6[n]);
      return e.type == "base64" ? So(t) : e.type == "string" ? po(t) : t;
    case "file":
      return Lo(e.file, r6);
    case "buffer":
      return r6;
    default:
      throw new Error("Unrecognized type " + e.type);
  }
}
function T1(r6, e) {
  Z2(), hx(r6);
  var t = gn(e || {});
  if (t.cellStyles && (t.cellNF = true, t.sheetStubs = true), t.type == "array") {
    t.type = "binary";
    var n = T1(r6, t);
    return t.type = "array", tf(n);
  }
  var i = 0;
  if (t.sheet && (typeof t.sheet == "number" ? i = t.sheet : i = r6.SheetNames.indexOf(t.sheet), !r6.SheetNames[i])) throw new Error("Sheet not found: " + t.sheet + " : " + typeof t.sheet);
  switch (t.bookType || "xlsb") {
    case "xml":
    case "xlml":
      return gi(Bx(r6, t), t);
    case "slk":
    case "sylk":
      return gi(o5.from_sheet(r6.Sheets[r6.SheetNames[i]], t), t);
    case "htm":
    case "html":
      return gi(y1(r6.Sheets[r6.SheetNames[i]], t), t);
    case "txt":
      return T4(E1(r6.Sheets[r6.SheetNames[i]], t), t);
    case "csv":
      return gi(th(r6.Sheets[r6.SheetNames[i]], t), t, "\uFEFF");
    case "dif":
      return gi(f5.from_sheet(r6.Sheets[r6.SheetNames[i]], t), t);
    case "dbf":
      return F0(s5.from_sheet(r6.Sheets[r6.SheetNames[i]], t), t);
    case "prn":
      return gi(l5.from_sheet(r6.Sheets[r6.SheetNames[i]], t), t);
    case "rtf":
      return gi(v5.from_sheet(r6.Sheets[r6.SheetNames[i]], t), t);
    case "eth":
      return gi(Yu.from_sheet(r6.Sheets[r6.SheetNames[i]], t), t);
    case "fods":
      return gi(A1(r6, t), t);
    case "wk1":
      return F0(uc.sheet_to_wk1(r6.Sheets[r6.SheetNames[i]], t), t);
    case "wk3":
      return F0(uc.book_to_wk3(r6, t), t);
    case "biff2":
      t.biff || (t.biff = 2);
    case "biff3":
      t.biff || (t.biff = 3);
    case "biff4":
      return t.biff || (t.biff = 4), F0(w1(r6, t), t);
    case "biff5":
      t.biff || (t.biff = 5);
    case "biff8":
    case "xla":
    case "xls":
      return t.biff || (t.biff = 8), b4(r6, t);
    case "xlsx":
    case "xlsm":
    case "xlam":
    case "xlsb":
    case "numbers":
    case "ods":
      return S4(r6, t);
    default:
      throw new Error("Unrecognized bookType |" + t.bookType + "|");
  }
}
function E4(r6) {
  if (!r6.bookType) {
    var e = {
      xls: "biff8",
      htm: "html",
      slk: "sylk",
      socialcalc: "eth",
      Sh33tJS: "WTF"
    }, t = r6.file.slice(r6.file.lastIndexOf(".")).toLowerCase();
    t.match(/^\.[a-z]+$/) && (r6.bookType = t.slice(1)), r6.bookType = e[r6.bookType] || r6.bookType;
  }
}
function N4(r6, e, t) {
  var n = t || {};
  return n.type = "file", n.file = e, E4(n), T1(r6, n);
}
function F4(r6, e, t, n, i, a, s, o) {
  var f = qr(t), h = o.defval, c = o.raw || !Object.prototype.hasOwnProperty.call(o, "raw"), p = true, v = i === 1 ? [] : {};
  if (i !== 1) if (Object.defineProperty) try {
    Object.defineProperty(v, "__rowNum__", {
      value: t,
      enumerable: false
    });
  } catch {
    v.__rowNum__ = t;
  }
  else v.__rowNum__ = t;
  if (!s || r6[t]) for (var d = e.s.c; d <= e.e.c; ++d) {
    var w = s ? r6[t][d] : r6[n[d] + f];
    if (w === void 0 || w.t === void 0) {
      if (h === void 0) continue;
      a[d] != null && (v[a[d]] = h);
      continue;
    }
    var x = w.v;
    switch (w.t) {
      case "z":
        if (x == null) break;
        continue;
      case "e":
        x = x == 0 ? null : void 0;
        break;
      case "s":
      case "d":
      case "b":
      case "n":
        break;
      default:
        throw new Error("unrecognized type " + w.t);
    }
    if (a[d] != null) {
      if (x == null) {
        if (w.t == "e" && x === null) v[a[d]] = null;
        else if (h !== void 0) v[a[d]] = h;
        else if (c && x === null) v[a[d]] = null;
        else continue;
      } else v[a[d]] = c && (w.t !== "n" || w.t === "n" && o.rawNumbers !== false) ? x : Ui(w, x, o);
      x != null && (p = false);
    }
  }
  return {
    row: v,
    isempty: p
  };
}
function K0(r6, e) {
  if (r6 == null || r6["!ref"] == null) return [];
  var t = {
    t: "n",
    v: 0
  }, n = 0, i = 1, a = [], s = 0, o = "", f = {
    s: {
      r: 0,
      c: 0
    },
    e: {
      r: 0,
      c: 0
    }
  }, h = e || {}, c = h.range != null ? h.range : r6["!ref"];
  switch (h.header === 1 ? n = 1 : h.header === "A" ? n = 2 : Array.isArray(h.header) ? n = 3 : h.header == null && (n = 0), typeof c) {
    case "string":
      f = rr(c);
      break;
    case "number":
      f = rr(r6["!ref"]), f.s.r = c;
      break;
    default:
      f = c;
  }
  n > 0 && (i = 0);
  var p = qr(f.s.r), v = [], d = [], w = 0, x = 0, S = Array.isArray(r6), A = f.s.r, b = 0, O = {};
  S && !r6[A] && (r6[A] = []);
  var q = h.skipHidden && r6["!cols"] || [], te = h.skipHidden && r6["!rows"] || [];
  for (b = f.s.c; b <= f.e.c; ++b) if (!(q[b] || {}).hidden) switch (v[b] = Jr(b), t = S ? r6[A][b] : r6[v[b] + p], n) {
    case 1:
      a[b] = b - f.s.c;
      break;
    case 2:
      a[b] = v[b];
      break;
    case 3:
      a[b] = h.header[b - f.s.c];
      break;
    default:
      if (t == null && (t = {
        w: "__EMPTY",
        t: "s"
      }), o = s = Ui(t, null, h), x = O[s] || 0, !x) O[s] = 1;
      else {
        do
          o = s + "_" + x++;
        while (O[o]);
        O[s] = x, O[o] = 1;
      }
      a[b] = o;
  }
  for (A = f.s.r + i; A <= f.e.r; ++A) if (!(te[A] || {}).hidden) {
    var le = F4(r6, f, A, v, n, a, S, h);
    (le.isempty === false || (n === 1 ? h.blankrows !== false : h.blankrows)) && (d[w++] = le.row);
  }
  return d.length = w, d;
}
var yc = /"/g;
function L4(r6, e, t, n, i, a, s, o) {
  for (var f = true, h = [], c = "", p = qr(t), v = e.s.c; v <= e.e.c; ++v) if (n[v]) {
    var d = o.dense ? (r6[t] || [])[v] : r6[n[v] + p];
    if (d == null) c = "";
    else if (d.v != null) {
      f = false, c = "" + (o.rawNumbers && d.t == "n" ? d.v : Ui(d, null, o));
      for (var w = 0, x = 0; w !== c.length; ++w) if ((x = c.charCodeAt(w)) === i || x === a || x === 34 || o.forceQuotes) {
        c = '"' + c.replace(yc, '""') + '"';
        break;
      }
      c == "ID" && (c = '"ID"');
    } else d.f != null && !d.F ? (f = false, c = "=" + d.f, c.indexOf(",") >= 0 && (c = '"' + c.replace(yc, '""') + '"')) : c = "";
    h.push(c);
  }
  return o.blankrows === false && f ? null : h.join(s);
}
function th(r6, e) {
  var t = [], n = e ?? {};
  if (r6 == null || r6["!ref"] == null) return "";
  var i = rr(r6["!ref"]), a = n.FS !== void 0 ? n.FS : ",", s = a.charCodeAt(0), o = n.RS !== void 0 ? n.RS : `
`, f = o.charCodeAt(0), h = new RegExp((a == "|" ? "\\|" : a) + "+$"), c = "", p = [];
  n.dense = Array.isArray(r6);
  for (var v = n.skipHidden && r6["!cols"] || [], d = n.skipHidden && r6["!rows"] || [], w = i.s.c; w <= i.e.c; ++w) (v[w] || {}).hidden || (p[w] = Jr(w));
  for (var x = 0, S = i.s.r; S <= i.e.r; ++S) (d[S] || {}).hidden || (c = L4(r6, i, S, p, s, f, a, n), c != null && (n.strip && (c = c.replace(h, "")), (c || n.blankrows !== false) && t.push((x++ ? o : "") + c)));
  return delete n.dense, t.join("");
}
function E1(r6, e) {
  e || (e = {}), e.FS = "	", e.RS = `
`;
  var t = th(r6, e);
  return t;
}
function C4(r6) {
  var e = "", t, n = "";
  if (r6 == null || r6["!ref"] == null) return [];
  var i = rr(r6["!ref"]), a = "", s = [], o, f = [], h = Array.isArray(r6);
  for (o = i.s.c; o <= i.e.c; ++o) s[o] = Jr(o);
  for (var c = i.s.r; c <= i.e.r; ++c) for (a = qr(c), o = i.s.c; o <= i.e.c; ++o) if (e = s[o] + a, t = h ? (r6[c] || [])[o] : r6[e], n = "", t !== void 0) {
    if (t.F != null) {
      if (e = t.F, !t.f) continue;
      n = t.f, e.indexOf(":") == -1 && (e = e + ":" + e);
    }
    if (t.f != null) n = t.f;
    else {
      if (t.t == "z") continue;
      if (t.t == "n" && t.v != null) n = "" + t.v;
      else if (t.t == "b") n = t.v ? "TRUE" : "FALSE";
      else if (t.w !== void 0) n = "'" + t.w;
      else {
        if (t.v === void 0) continue;
        t.t == "s" ? n = "'" + t.v : n = "" + t.v;
      }
    }
    f[f.length] = e + "=" + n;
  }
  return f;
}
function N1(r6, e, t) {
  var n = t || {}, i = +!n.skipHeader, a = r6 || {}, s = 0, o = 0;
  if (a && n.origin != null) if (typeof n.origin == "number") s = n.origin;
  else {
    var f = typeof n.origin == "string" ? Dr(n.origin) : n.origin;
    s = f.r, o = f.c;
  }
  var h, c = {
    s: {
      c: 0,
      r: 0
    },
    e: {
      c: o,
      r: s + e.length - 1 + i
    }
  };
  if (a["!ref"]) {
    var p = rr(a["!ref"]);
    c.e.c = Math.max(c.e.c, p.e.c), c.e.r = Math.max(c.e.r, p.e.r), s == -1 && (s = p.e.r + 1, c.e.r = s + e.length - 1 + i);
  } else s == -1 && (s = 0, c.e.r = e.length - 1 + i);
  var v = n.header || [], d = 0;
  e.forEach(function(x, S) {
    Hr(x).forEach(function(A) {
      (d = v.indexOf(A)) == -1 && (v[d = v.length] = A);
      var b = x[A], O = "z", q = "", te = zt({
        c: o + d,
        r: s + S + i
      });
      h = Eo(a, te), b && typeof b == "object" && !(b instanceof Date) ? a[te] = b : (typeof b == "number" ? O = "n" : typeof b == "boolean" ? O = "b" : typeof b == "string" ? O = "s" : b instanceof Date ? (O = "d", n.cellDates || (O = "n", b = pn(b)), q = n.dateNF || lr[14]) : b === null && n.nullError && (O = "e", b = 0), h ? (h.t = O, h.v = b, delete h.w, delete h.R, q && (h.z = q)) : a[te] = h = {
        t: O,
        v: b
      }, q && (h.z = q));
    });
  }), c.e.c = Math.max(c.e.c, o + v.length - 1);
  var w = qr(s);
  if (i) for (d = 0; d < v.length; ++d) a[Jr(d + o) + w] = {
    t: "s",
    v: v[d]
  };
  return a["!ref"] = Sr(c), a;
}
function P4(r6, e) {
  return N1(null, r6, e);
}
function Eo(r6, e, t) {
  if (typeof e == "string") {
    if (Array.isArray(r6)) {
      var n = Dr(e);
      return r6[n.r] || (r6[n.r] = []), r6[n.r][n.c] || (r6[n.r][n.c] = {
        t: "z"
      });
    }
    return r6[e] || (r6[e] = {
      t: "z"
    });
  }
  return typeof e != "number" ? Eo(r6, zt(e)) : Eo(r6, zt({
    r: e,
    c: t || 0
  }));
}
function k4(r6, e) {
  if (typeof e == "number") {
    if (e >= 0 && r6.SheetNames.length > e) return e;
    throw new Error("Cannot find sheet # " + e);
  } else if (typeof e == "string") {
    var t = r6.SheetNames.indexOf(e);
    if (t > -1) return t;
    throw new Error("Cannot find sheet name |" + e + "|");
  } else throw new Error("Cannot find sheet |" + e + "|");
}
function D4() {
  return {
    SheetNames: [],
    Sheets: {}
  };
}
function O4(r6, e, t, n) {
  var i = 1;
  if (!t) for (; i <= 65535 && r6.SheetNames.indexOf(t = "Sheet" + i) != -1; ++i, t = void 0) ;
  if (!t || r6.SheetNames.length >= 65535) throw new Error("Too many worksheets");
  if (n && r6.SheetNames.indexOf(t) >= 0) {
    var a = t.match(/(^.*?)(\d+)$/);
    i = a && +a[2] || 0;
    var s = a && a[1] || t;
    for (++i; i <= 65535 && r6.SheetNames.indexOf(t = s + i) != -1; ++i) ;
  }
  if (v1(t), r6.SheetNames.indexOf(t) >= 0) throw new Error("Worksheet with name |" + t + "| already exists!");
  return r6.SheetNames.push(t), r6.Sheets[t] = e, t;
}
function I4(r6, e, t) {
  r6.Workbook || (r6.Workbook = {}), r6.Workbook.Sheets || (r6.Workbook.Sheets = []);
  var n = k4(r6, e);
  switch (r6.Workbook.Sheets[n] || (r6.Workbook.Sheets[n] = {}), t) {
    case 0:
    case 1:
    case 2:
      break;
    default:
      throw new Error("Bad sheet visibility setting " + t);
  }
  r6.Workbook.Sheets[n].Hidden = t;
}
function R4(r6, e) {
  return r6.z = e, r6;
}
function F1(r6, e, t) {
  return e ? (r6.l = {
    Target: e
  }, t && (r6.l.Tooltip = t)) : delete r6.l, r6;
}
function M4(r6, e, t) {
  return F1(r6, "#" + e, t);
}
function B4(r6, e, t) {
  r6.c || (r6.c = []), r6.c.push({
    t: e,
    a: t || "SheetJS"
  });
}
function j4(r6, e, t, n) {
  for (var i = typeof e != "string" ? e : rr(e), a = typeof e == "string" ? e : Sr(e), s = i.s.r; s <= i.e.r; ++s) for (var o = i.s.c; o <= i.e.c; ++o) {
    var f = Eo(r6, s, o);
    f.t = "n", f.F = a, delete f.v, s == i.s.r && o == i.s.c && (f.f = t, n && (f.D = true));
  }
  return r6;
}
var fo = {
  encode_col: Jr,
  encode_row: qr,
  encode_cell: zt,
  encode_range: Sr,
  decode_col: zl,
  decode_row: Wl,
  split_cell: Qd,
  decode_cell: Dr,
  decode_range: Ln,
  format_cell: Ui,
  sheet_add_aoa: Fu,
  sheet_add_json: N1,
  sheet_add_dom: _1,
  aoa_to_sheet: Ls,
  json_to_sheet: P4,
  table_to_sheet: S1,
  table_to_book: f4,
  sheet_to_csv: th,
  sheet_to_txt: E1,
  sheet_to_json: K0,
  sheet_to_html: y1,
  sheet_to_formulae: C4,
  sheet_to_row_object_array: K0,
  sheet_get_cell: Eo,
  book_new: D4,
  book_append_sheet: O4,
  book_set_sheet_visibility: I4,
  cell_set_number_format: R4,
  cell_set_hyperlink: F1,
  cell_set_internal_link: M4,
  cell_add_comment: B4,
  sheet_set_array_formula: j4,
  consts: {
    SHEET_VISIBLE: 0,
    SHEET_HIDDEN: 1,
    SHEET_VERY_HIDDEN: 2
  }
};
function Wt(r6) {
  "@babel/helpers - typeof";
  return Wt = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(e) {
    return typeof e;
  } : function(e) {
    return e && typeof Symbol == "function" && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e;
  }, Wt(r6);
}
var Kr = Uint8Array;
var Fn = Uint16Array;
var rh = Int32Array;
var hf = new Kr([
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  1,
  1,
  1,
  1,
  2,
  2,
  2,
  2,
  3,
  3,
  3,
  3,
  4,
  4,
  4,
  4,
  5,
  5,
  5,
  5,
  0,
  /* unused */
  0,
  0,
  /* impossible */
  0
]);
var cf = new Kr([
  0,
  0,
  0,
  0,
  1,
  1,
  2,
  2,
  3,
  3,
  4,
  4,
  5,
  5,
  6,
  6,
  7,
  7,
  8,
  8,
  9,
  9,
  10,
  10,
  11,
  11,
  12,
  12,
  13,
  13,
  /* unused */
  0,
  0
]);
var _l = new Kr([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]);
var L1 = function(r6, e) {
  for (var t = new Fn(31), n = 0; n < 31; ++n) t[n] = e += 1 << r6[n - 1];
  for (var i = new rh(t[30]), n = 1; n < 30; ++n) for (var a = t[n]; a < t[n + 1]; ++a) i[a] = a - t[n] << 5 | n;
  return {
    b: t,
    r: i
  };
};
var C1 = L1(hf, 2);
var P1 = C1.b;
var Sl = C1.r;
P1[28] = 258, Sl[258] = 28;
var k1 = L1(cf, 0);
var U4 = k1.b;
var _c = k1.r;
var Al = new Fn(32768);
for (tr = 0; tr < 32768; ++tr) {
  ia = (tr & 43690) >> 1 | (tr & 21845) << 1;
  ia = (ia & 52428) >> 2 | (ia & 13107) << 2, ia = (ia & 61680) >> 4 | (ia & 3855) << 4, Al[tr] = ((ia & 65280) >> 8 | (ia & 255) << 8) >> 1;
}
var ia;
var tr;
var xi = function(r6, e, t) {
  for (var n = r6.length, i = 0, a = new Fn(e); i < n; ++i) r6[i] && ++a[r6[i] - 1];
  var s = new Fn(e);
  for (i = 1; i < e; ++i) s[i] = s[i - 1] + a[i - 1] << 1;
  var o;
  if (t) {
    o = new Fn(1 << e);
    var f = 15 - e;
    for (i = 0; i < n; ++i) if (r6[i]) for (var h = i << 4 | r6[i], c = e - r6[i], p = s[r6[i] - 1]++ << c, v = p | (1 << c) - 1; p <= v; ++p) o[Al[p] >> f] = h;
  } else for (o = new Fn(n), i = 0; i < n; ++i) r6[i] && (o[i] = Al[s[r6[i] - 1]++] >> 15 - r6[i]);
  return o;
};
var ua = new Kr(288);
for (tr = 0; tr < 144; ++tr) ua[tr] = 8;
var tr;
for (tr = 144; tr < 256; ++tr) ua[tr] = 9;
var tr;
for (tr = 256; tr < 280; ++tr) ua[tr] = 7;
var tr;
for (tr = 280; tr < 288; ++tr) ua[tr] = 8;
var tr;
var No = new Kr(32);
for (tr = 0; tr < 32; ++tr) No[tr] = 5;
var tr;
var q4 = xi(ua, 9, 0);
var H4 = xi(ua, 9, 1);
var W4 = xi(No, 5, 0);
var z4 = xi(No, 5, 1);
var il = function(r6) {
  for (var e = r6[0], t = 1; t < r6.length; ++t) r6[t] > e && (e = r6[t]);
  return e;
};
var Qn = function(r6, e, t) {
  var n = e / 8 | 0;
  return (r6[n] | r6[n + 1] << 8) >> (e & 7) & t;
};
var al = function(r6, e) {
  var t = e / 8 | 0;
  return (r6[t] | r6[t + 1] << 8 | r6[t + 2] << 16) >> (e & 7);
};
var nh = function(r6) {
  return (r6 + 7) / 8 | 0;
};
var D1 = function(r6, e, t) {
  return (e == null || e < 0) && (e = 0), (t == null || t > r6.length) && (t = r6.length), new Kr(r6.subarray(e, t));
};
var V4 = [
  "unexpected EOF",
  "invalid block type",
  "invalid length/literal",
  "invalid distance",
  "stream finished",
  "no stream handler",
  ,
  "no callback",
  "invalid UTF-8 data",
  "extra field too long",
  "date not in range 1980-2099",
  "filename too long",
  "stream finishing",
  "invalid zip data"
  // determined by unknown compression method
];
var ti = function(r6, e, t) {
  var n = new Error(e || V4[r6]);
  if (n.code = r6, Error.captureStackTrace && Error.captureStackTrace(n, ti), !t) throw n;
  return n;
};
var G4 = function(r6, e, t, n) {
  var i = r6.length, a = n ? n.length : 0;
  if (!i || e.f && !e.l) return t || new Kr(0);
  var s = !t, o = s || e.i != 2, f = e.i;
  s && (t = new Kr(i * 3));
  var h = function(Ce) {
    var Oe = t.length;
    if (Ce > Oe) {
      var qe = new Kr(Math.max(Oe * 2, Ce));
      qe.set(t), t = qe;
    }
  }, c = e.f || 0, p = e.p || 0, v = e.b || 0, d = e.l, w = e.d, x = e.m, S = e.n, A = i * 8;
  do {
    if (!d) {
      c = Qn(r6, p, 1);
      var b = Qn(r6, p + 1, 3);
      if (p += 3, b) {
        if (b == 1) d = H4, w = z4, x = 9, S = 5;
        else if (b == 2) {
          var le = Qn(r6, p, 31) + 257, j = Qn(r6, p + 10, 15) + 4, M = le + Qn(r6, p + 5, 31) + 1;
          p += 14;
          for (var H = new Kr(M), ee = new Kr(19), F = 0; F < j; ++F) ee[_l[F]] = Qn(r6, p + F * 3, 7);
          p += j * 3;
          for (var P = il(ee), Y = (1 << P) - 1, Q = xi(ee, P, 1), F = 0; F < M; ) {
            var ce = Q[Qn(r6, p, Y)];
            p += ce & 15;
            var O = ce >> 4;
            if (O < 16) H[F++] = O;
            else {
              var we = 0, Se = 0;
              for (O == 16 ? (Se = 3 + Qn(r6, p, 3), p += 2, we = H[F - 1]) : O == 17 ? (Se = 3 + Qn(r6, p, 7), p += 3) : O == 18 && (Se = 11 + Qn(r6, p, 127), p += 7); Se--; ) H[F++] = we;
            }
          }
          var de = H.subarray(0, le), Ae = H.subarray(le);
          x = il(de), S = il(Ae), d = xi(de, x, 1), w = xi(Ae, S, 1);
        } else ti(1);
      } else {
        var O = nh(p) + 4, q = r6[O - 4] | r6[O - 3] << 8, te = O + q;
        if (te > i) {
          f && ti(0);
          break;
        }
        o && h(v + q), t.set(r6.subarray(O, te), v), e.b = v += q, e.p = p = te * 8, e.f = c;
        continue;
      }
      if (p > A) {
        f && ti(0);
        break;
      }
    }
    o && h(v + 131072);
    for (var be = (1 << x) - 1, ze = (1 << S) - 1, y = p; ; y = p) {
      var we = d[al(r6, p) & be], L = we >> 4;
      if (p += we & 15, p > A) {
        f && ti(0);
        break;
      }
      if (we || ti(2), L < 256) t[v++] = L;
      else if (L == 256) {
        y = p, d = null;
        break;
      } else {
        var N = L - 254;
        if (L > 264) {
          var F = L - 257, C = hf[F];
          N = Qn(r6, p, (1 << C) - 1) + P1[F], p += C;
        }
        var z = w[al(r6, p) & ze], re = z >> 4;
        z || ti(3), p += z & 15;
        var Ae = U4[re];
        if (re > 3) {
          var C = cf[re];
          Ae += al(r6, p) & (1 << C) - 1, p += C;
        }
        if (p > A) {
          f && ti(0);
          break;
        }
        o && h(v + 131072);
        var se = v + N;
        if (v < Ae) {
          var ie = a - Ae, ve = Math.min(Ae, se);
          for (ie + v < 0 && ti(3); v < ve; ++v) t[v] = n[ie + v];
        }
        for (; v < se; ++v) t[v] = t[v - Ae];
      }
    }
    e.l = d, e.p = y, e.b = v, e.f = c, d && (c = 1, e.m = x, e.d = w, e.n = S);
  } while (!c);
  return v != t.length && s ? D1(t, 0, v) : t.subarray(0, v);
};
var ki = function(r6, e, t) {
  t <<= e & 7;
  var n = e / 8 | 0;
  r6[n] |= t, r6[n + 1] |= t >> 8;
};
var lo = function(r6, e, t) {
  t <<= e & 7;
  var n = e / 8 | 0;
  r6[n] |= t, r6[n + 1] |= t >> 8, r6[n + 2] |= t >> 16;
};
var sl = function(r6, e) {
  for (var t = [], n = 0; n < r6.length; ++n) r6[n] && t.push({
    s: n,
    f: r6[n]
  });
  var i = t.length, a = t.slice();
  if (!i) return {
    t: I1,
    l: 0
  };
  if (i == 1) {
    var s = new Kr(t[0].s + 1);
    return s[t[0].s] = 1, {
      t: s,
      l: 1
    };
  }
  t.sort(function(te, le) {
    return te.f - le.f;
  }), t.push({
    s: -1,
    f: 25001
  });
  var o = t[0], f = t[1], h = 0, c = 1, p = 2;
  for (t[0] = {
    s: -1,
    f: o.f + f.f,
    l: o,
    r: f
  }; c != i - 1; ) o = t[t[h].f < t[p].f ? h++ : p++], f = t[h != c && t[h].f < t[p].f ? h++ : p++], t[c++] = {
    s: -1,
    f: o.f + f.f,
    l: o,
    r: f
  };
  for (var v = a[0].s, n = 1; n < i; ++n) a[n].s > v && (v = a[n].s);
  var d = new Fn(v + 1), w = bl(t[c - 1], d, 0);
  if (w > e) {
    var n = 0, x = 0, S = w - e, A = 1 << S;
    for (a.sort(function(le, j) {
      return d[j.s] - d[le.s] || le.f - j.f;
    }); n < i; ++n) {
      var b = a[n].s;
      if (d[b] > e) x += A - (1 << w - d[b]), d[b] = e;
      else break;
    }
    for (x >>= S; x > 0; ) {
      var O = a[n].s;
      d[O] < e ? x -= 1 << e - d[O]++ - 1 : ++n;
    }
    for (; n >= 0 && x; --n) {
      var q = a[n].s;
      d[q] == e && (--d[q], ++x);
    }
    w = e;
  }
  return {
    t: new Kr(d),
    l: w
  };
};
var bl = function(r6, e, t) {
  return r6.s == -1 ? Math.max(bl(r6.l, e, t + 1), bl(r6.r, e, t + 1)) : e[r6.s] = t;
};
var Sc = function(r6) {
  for (var e = r6.length; e && !r6[--e]; ) ;
  for (var t = new Fn(++e), n = 0, i = r6[0], a = 1, s = function(f) {
    t[n++] = f;
  }, o = 1; o <= e; ++o) if (r6[o] == i && o != e) ++a;
  else {
    if (!i && a > 2) {
      for (; a > 138; a -= 138) s(32754);
      a > 2 && (s(a > 10 ? a - 11 << 5 | 28690 : a - 3 << 5 | 12305), a = 0);
    } else if (a > 3) {
      for (s(i), --a; a > 6; a -= 6) s(8304);
      a > 2 && (s(a - 3 << 5 | 8208), a = 0);
    }
    for (; a--; ) s(i);
    a = 1, i = r6[o];
  }
  return {
    c: t.subarray(0, n),
    n: e
  };
};
var ho = function(r6, e) {
  for (var t = 0, n = 0; n < e.length; ++n) t += r6[n] * e[n];
  return t;
};
var O1 = function(r6, e, t) {
  var n = t.length, i = nh(e + 2);
  r6[i] = n & 255, r6[i + 1] = n >> 8, r6[i + 2] = r6[i] ^ 255, r6[i + 3] = r6[i + 1] ^ 255;
  for (var a = 0; a < n; ++a) r6[i + a + 4] = t[a];
  return (i + 4 + n) * 8;
};
var Ac = function(r6, e, t, n, i, a, s, o, f, h, c) {
  ki(e, c++, t), ++i[256];
  for (var p = sl(i, 15), v = p.t, d = p.l, w = sl(a, 15), x = w.t, S = w.l, A = Sc(v), b = A.c, O = A.n, q = Sc(x), te = q.c, le = q.n, j = new Fn(19), M = 0; M < b.length; ++M) ++j[b[M] & 31];
  for (var M = 0; M < te.length; ++M) ++j[te[M] & 31];
  for (var H = sl(j, 7), ee = H.t, F = H.l, P = 19; P > 4 && !ee[_l[P - 1]]; --P) ;
  var Y = h + 5 << 3, Q = ho(i, ua) + ho(a, No) + s, ce = ho(i, v) + ho(a, x) + s + 14 + 3 * P + ho(j, ee) + 2 * j[16] + 3 * j[17] + 7 * j[18];
  if (f >= 0 && Y <= Q && Y <= ce) return O1(e, c, r6.subarray(f, f + h));
  var we, Se, de, Ae;
  if (ki(e, c, 1 + (ce < Q)), c += 2, ce < Q) {
    we = xi(v, d, 0), Se = v, de = xi(x, S, 0), Ae = x;
    var be = xi(ee, F, 0);
    ki(e, c, O - 257), ki(e, c + 5, le - 1), ki(e, c + 10, P - 4), c += 14;
    for (var M = 0; M < P; ++M) ki(e, c + 3 * M, ee[_l[M]]);
    c += 3 * P;
    for (var ze = [b, te], y = 0; y < 2; ++y) for (var L = ze[y], M = 0; M < L.length; ++M) {
      var N = L[M] & 31;
      ki(e, c, be[N]), c += ee[N], N > 15 && (ki(e, c, L[M] >> 5 & 127), c += L[M] >> 12);
    }
  } else we = q4, Se = ua, de = W4, Ae = No;
  for (var M = 0; M < o; ++M) {
    var C = n[M];
    if (C > 255) {
      var N = C >> 18 & 31;
      lo(e, c, we[N + 257]), c += Se[N + 257], N > 7 && (ki(e, c, C >> 23 & 31), c += hf[N]);
      var z = C & 31;
      lo(e, c, de[z]), c += Ae[z], z > 3 && (lo(e, c, C >> 5 & 8191), c += cf[z]);
    } else lo(e, c, we[C]), c += Se[C];
  }
  return lo(e, c, we[256]), c + Se[256];
};
var X4 = new rh([65540, 131080, 131088, 131104, 262176, 1048704, 1048832, 2114560, 2117632]);
var I1 = new Kr(0);
var Y4 = function(r6, e, t, n, i, a) {
  var s = a.z || r6.length, o = new Kr(n + s + 5 * (1 + Math.ceil(s / 7e3)) + i), f = o.subarray(n, o.length - i), h = a.l, c = (a.r || 0) & 7;
  if (e) {
    c && (f[0] = a.r >> 3);
    for (var p = X4[e - 1], v = p >> 13, d = p & 8191, w = (1 << t) - 1, x = a.p || new Fn(32768), S = a.h || new Fn(w + 1), A = Math.ceil(t / 3), b = 2 * A, O = function(Ye) {
      return (r6[Ye] ^ r6[Ye + 1] << A ^ r6[Ye + 2] << b) & w;
    }, q = new rh(25e3), te = new Fn(288), le = new Fn(32), j = 0, M = 0, H = a.i || 0, ee = 0, F = a.w || 0, P = 0; H + 2 < s; ++H) {
      var Y = O(H), Q = H & 32767, ce = S[Y];
      if (x[Q] = ce, S[Y] = Q, F <= H) {
        var we = s - H;
        if ((j > 7e3 || ee > 24576) && (we > 423 || !h)) {
          c = Ac(r6, f, 0, q, te, le, M, ee, P, H - P, c), ee = j = M = 0, P = H;
          for (var Se = 0; Se < 286; ++Se) te[Se] = 0;
          for (var Se = 0; Se < 30; ++Se) le[Se] = 0;
        }
        var de = 2, Ae = 0, be = d, ze = Q - ce & 32767;
        if (we > 2 && Y == O(H - ze)) for (var y = Math.min(v, we) - 1, L = Math.min(32767, H), N = Math.min(258, we); ze <= L && --be && Q != ce; ) {
          if (r6[H + de] == r6[H + de - ze]) {
            for (var C = 0; C < N && r6[H + C] == r6[H + C - ze]; ++C) ;
            if (C > de) {
              if (de = C, Ae = ze, C > y) break;
              for (var z = Math.min(ze, C - 2), re = 0, Se = 0; Se < z; ++Se) {
                var se = H - ze + Se & 32767, ie = x[se], ve = se - ie & 32767;
                ve > re && (re = ve, ce = se);
              }
            }
          }
          Q = ce, ce = x[Q], ze += Q - ce & 32767;
        }
        if (Ae) {
          q[ee++] = 268435456 | Sl[de] << 18 | _c[Ae];
          var Ce = Sl[de] & 31, Oe = _c[Ae] & 31;
          M += hf[Ce] + cf[Oe], ++te[257 + Ce], ++le[Oe], F = H + de, ++j;
        } else q[ee++] = r6[H], ++te[r6[H]];
      }
    }
    for (H = Math.max(H, F); H < s; ++H) q[ee++] = r6[H], ++te[r6[H]];
    c = Ac(r6, f, h, q, te, le, M, ee, P, H - P, c), h || (a.r = c & 7 | f[c / 8 | 0] << 3, c -= 7, a.h = S, a.p = x, a.i = H, a.w = F);
  } else {
    for (var H = a.w || 0; H < s + h; H += 65535) {
      var qe = H + 65535;
      qe >= s && (f[c / 8 | 0] = h, qe = s), c = O1(f, c + 1, r6.subarray(H, qe));
    }
    a.i = s;
  }
  return D1(o, 0, n + nh(c) + i);
};
var R1 = function() {
  var r6 = 1, e = 0;
  return {
    p: function(t) {
      for (var n = r6, i = e, a = t.length | 0, s = 0; s != a; ) {
        for (var o = Math.min(s + 2655, a); s < o; ++s) i += n += t[s];
        n = (n & 65535) + 15 * (n >> 16), i = (i & 65535) + 15 * (i >> 16);
      }
      r6 = n, e = i;
    },
    d: function() {
      return r6 %= 65521, e %= 65521, (r6 & 255) << 24 | (r6 & 65280) << 8 | (e & 255) << 8 | e >> 8;
    }
  };
};
var $4 = function(r6, e, t, n, i) {
  if (!i && (i = {
    l: 1
  }, e.dictionary)) {
    var a = e.dictionary.subarray(-32768), s = new Kr(a.length + r6.length);
    s.set(a), s.set(r6, a.length), r6 = s, i.w = a.length;
  }
  return Y4(r6, e.level == null ? 6 : e.level, e.mem == null ? i.l ? Math.ceil(Math.max(8, Math.min(13, Math.log(r6.length))) * 1.5) : 20 : 12 + e.mem, t, n, i);
};
var M1 = function(r6, e, t) {
  for (; t; ++e) r6[e] = t, t >>>= 8;
};
var K4 = function(r6, e) {
  var t = e.level, n = t == 0 ? 0 : t < 6 ? 1 : t == 9 ? 3 : 2;
  if (r6[0] = 120, r6[1] = n << 6 | (e.dictionary && 32), r6[1] |= 31 - (r6[0] << 8 | r6[1]) % 31, e.dictionary) {
    var i = R1();
    i.p(e.dictionary), M1(r6, 2, i.d());
  }
};
var J4 = function(r6, e) {
  return ((r6[0] & 15) != 8 || r6[0] >> 4 > 7 || (r6[0] << 8 | r6[1]) % 31) && ti(6, "invalid zlib data"), (r6[1] >> 5 & 1) == +!e && ti(6, "invalid zlib data: " + (r6[1] & 32 ? "need" : "unexpected") + " dictionary"), (r6[1] >> 3 & 4) + 2;
};
function Tl(r6, e) {
  e || (e = {});
  var t = R1();
  t.p(r6);
  var n = $4(r6, e, e.dictionary ? 6 : 2, 4);
  return K4(n, e), M1(n, n.length - 4, t.d()), n;
}
function Z4(r6, e) {
  return G4(r6.subarray(J4(r6, e && e.dictionary), -4), {
    i: 2
  }, e && e.out, e && e.dictionary);
}
var Q4 = typeof TextDecoder < "u" && new TextDecoder();
var e3 = 0;
try {
  Q4.decode(I1, {
    stream: true
  }), e3 = 1;
} catch {
}
var dt = /* @__PURE__ */ function() {
  return typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : this;
}();
function ol() {
  dt.console && typeof dt.console.log == "function" && dt.console.log.apply(dt.console, arguments);
}
var Kt = {
  log: ol,
  warn: function(r6) {
    dt.console && (typeof dt.console.warn == "function" ? dt.console.warn.apply(dt.console, arguments) : ol.call(null, arguments));
  },
  error: function(r6) {
    dt.console && (typeof dt.console.error == "function" ? dt.console.error.apply(dt.console, arguments) : ol(r6));
  }
};
function fl(r6, e, t) {
  var n = new XMLHttpRequest();
  n.open("GET", r6), n.responseType = "blob", n.onload = function() {
    Ta(n.response, e, t);
  }, n.onerror = function() {
    Kt.error("could not download file");
  }, n.send();
}
function bc(r6) {
  var e = new XMLHttpRequest();
  e.open("HEAD", r6, false);
  try {
    e.send();
  } catch {
  }
  return e.status >= 200 && e.status <= 299;
}
function L0(r6) {
  try {
    r6.dispatchEvent(new MouseEvent("click"));
  } catch {
    var e = document.createEvent("MouseEvents");
    e.initMouseEvent("click", true, true, window, 0, 0, 0, 80, 20, false, false, false, false, 0, null), r6.dispatchEvent(e);
  }
}
var wo;
var El;
var Ta = dt.saveAs || ((typeof window > "u" ? "undefined" : Wt(window)) !== "object" || window !== dt ? function() {
} : typeof HTMLAnchorElement < "u" && "download" in HTMLAnchorElement.prototype ? function(r6, e, t) {
  var n = dt.URL || dt.webkitURL, i = document.createElement("a");
  e = e || r6.name || "download", i.download = e, i.rel = "noopener", typeof r6 == "string" ? (i.href = r6, i.origin !== location.origin ? bc(i.href) ? fl(r6, e, t) : L0(i, i.target = "_blank") : L0(i)) : (i.href = n.createObjectURL(r6), setTimeout(function() {
    n.revokeObjectURL(i.href);
  }, 4e4), setTimeout(function() {
    L0(i);
  }, 0));
} : "msSaveOrOpenBlob" in navigator ? function(r6, e, t) {
  if (e = e || r6.name || "download", typeof r6 == "string") {
    if (bc(r6)) fl(r6, e, t);
    else {
      var n = document.createElement("a");
      n.href = r6, n.target = "_blank", setTimeout(function() {
        L0(n);
      });
    }
  } else navigator.msSaveOrOpenBlob(function(i, a) {
    return a === void 0 ? a = {
      autoBom: false
    } : Wt(a) !== "object" && (Kt.warn("Deprecated: Expected third argument to be a object"), a = {
      autoBom: !a
    }), a.autoBom && /^\s*(?:text\/\S*|application\/xml|\S*\/\S*\+xml)\s*;.*charset\s*=\s*utf-8/i.test(i.type) ? new Blob([String.fromCharCode(65279), i], {
      type: i.type
    }) : i;
  }(r6, t), e);
} : function(r6, e, t, n) {
  if ((n = n || open("", "_blank")) && (n.document.title = n.document.body.innerText = "downloading..."), typeof r6 == "string") return fl(r6, e, t);
  var i = r6.type === "application/octet-stream", a = /constructor/i.test(dt.HTMLElement) || dt.safari, s = /CriOS\/[\d]+/.test(navigator.userAgent);
  if ((s || i && a) && (typeof FileReader > "u" ? "undefined" : Wt(FileReader)) === "object") {
    var o = new FileReader();
    o.onloadend = function() {
      var c = o.result;
      c = s ? c : c.replace(/^data:[^;]*;/, "data:attachment/file;"), n ? n.location.href = c : location = c, n = null;
    }, o.readAsDataURL(r6);
  } else {
    var f = dt.URL || dt.webkitURL, h = f.createObjectURL(r6);
    n ? n.location = h : location.href = h, n = null, setTimeout(function() {
      f.revokeObjectURL(h);
    }, 4e4);
  }
});
function B1(r6) {
  var e;
  r6 = r6 || "", this.ok = false, r6.charAt(0) == "#" && (r6 = r6.substr(1, 6)), r6 = {
    aliceblue: "f0f8ff",
    antiquewhite: "faebd7",
    aqua: "00ffff",
    aquamarine: "7fffd4",
    azure: "f0ffff",
    beige: "f5f5dc",
    bisque: "ffe4c4",
    black: "000000",
    blanchedalmond: "ffebcd",
    blue: "0000ff",
    blueviolet: "8a2be2",
    brown: "a52a2a",
    burlywood: "deb887",
    cadetblue: "5f9ea0",
    chartreuse: "7fff00",
    chocolate: "d2691e",
    coral: "ff7f50",
    cornflowerblue: "6495ed",
    cornsilk: "fff8dc",
    crimson: "dc143c",
    cyan: "00ffff",
    darkblue: "00008b",
    darkcyan: "008b8b",
    darkgoldenrod: "b8860b",
    darkgray: "a9a9a9",
    darkgreen: "006400",
    darkkhaki: "bdb76b",
    darkmagenta: "8b008b",
    darkolivegreen: "556b2f",
    darkorange: "ff8c00",
    darkorchid: "9932cc",
    darkred: "8b0000",
    darksalmon: "e9967a",
    darkseagreen: "8fbc8f",
    darkslateblue: "483d8b",
    darkslategray: "2f4f4f",
    darkturquoise: "00ced1",
    darkviolet: "9400d3",
    deeppink: "ff1493",
    deepskyblue: "00bfff",
    dimgray: "696969",
    dodgerblue: "1e90ff",
    feldspar: "d19275",
    firebrick: "b22222",
    floralwhite: "fffaf0",
    forestgreen: "228b22",
    fuchsia: "ff00ff",
    gainsboro: "dcdcdc",
    ghostwhite: "f8f8ff",
    gold: "ffd700",
    goldenrod: "daa520",
    gray: "808080",
    green: "008000",
    greenyellow: "adff2f",
    honeydew: "f0fff0",
    hotpink: "ff69b4",
    indianred: "cd5c5c",
    indigo: "4b0082",
    ivory: "fffff0",
    khaki: "f0e68c",
    lavender: "e6e6fa",
    lavenderblush: "fff0f5",
    lawngreen: "7cfc00",
    lemonchiffon: "fffacd",
    lightblue: "add8e6",
    lightcoral: "f08080",
    lightcyan: "e0ffff",
    lightgoldenrodyellow: "fafad2",
    lightgrey: "d3d3d3",
    lightgreen: "90ee90",
    lightpink: "ffb6c1",
    lightsalmon: "ffa07a",
    lightseagreen: "20b2aa",
    lightskyblue: "87cefa",
    lightslateblue: "8470ff",
    lightslategray: "778899",
    lightsteelblue: "b0c4de",
    lightyellow: "ffffe0",
    lime: "00ff00",
    limegreen: "32cd32",
    linen: "faf0e6",
    magenta: "ff00ff",
    maroon: "800000",
    mediumaquamarine: "66cdaa",
    mediumblue: "0000cd",
    mediumorchid: "ba55d3",
    mediumpurple: "9370d8",
    mediumseagreen: "3cb371",
    mediumslateblue: "7b68ee",
    mediumspringgreen: "00fa9a",
    mediumturquoise: "48d1cc",
    mediumvioletred: "c71585",
    midnightblue: "191970",
    mintcream: "f5fffa",
    mistyrose: "ffe4e1",
    moccasin: "ffe4b5",
    navajowhite: "ffdead",
    navy: "000080",
    oldlace: "fdf5e6",
    olive: "808000",
    olivedrab: "6b8e23",
    orange: "ffa500",
    orangered: "ff4500",
    orchid: "da70d6",
    palegoldenrod: "eee8aa",
    palegreen: "98fb98",
    paleturquoise: "afeeee",
    palevioletred: "d87093",
    papayawhip: "ffefd5",
    peachpuff: "ffdab9",
    peru: "cd853f",
    pink: "ffc0cb",
    plum: "dda0dd",
    powderblue: "b0e0e6",
    purple: "800080",
    red: "ff0000",
    rosybrown: "bc8f8f",
    royalblue: "4169e1",
    saddlebrown: "8b4513",
    salmon: "fa8072",
    sandybrown: "f4a460",
    seagreen: "2e8b57",
    seashell: "fff5ee",
    sienna: "a0522d",
    silver: "c0c0c0",
    skyblue: "87ceeb",
    slateblue: "6a5acd",
    slategray: "708090",
    snow: "fffafa",
    springgreen: "00ff7f",
    steelblue: "4682b4",
    tan: "d2b48c",
    teal: "008080",
    thistle: "d8bfd8",
    tomato: "ff6347",
    turquoise: "40e0d0",
    violet: "ee82ee",
    violetred: "d02090",
    wheat: "f5deb3",
    white: "ffffff",
    whitesmoke: "f5f5f5",
    yellow: "ffff00",
    yellowgreen: "9acd32"
  }[r6 = (r6 = r6.replace(/ /g, "")).toLowerCase()] || r6;
  for (var t = [{
    re: /^rgb\((\d{1,3}),\s*(\d{1,3}),\s*(\d{1,3})\)$/,
    example: ["rgb(123, 234, 45)", "rgb(255,234,245)"],
    process: function(o) {
      return [parseInt(o[1]), parseInt(o[2]), parseInt(o[3])];
    }
  }, {
    re: /^(\w{2})(\w{2})(\w{2})$/,
    example: ["#00ff00", "336699"],
    process: function(o) {
      return [parseInt(o[1], 16), parseInt(o[2], 16), parseInt(o[3], 16)];
    }
  }, {
    re: /^(\w{1})(\w{1})(\w{1})$/,
    example: ["#fb0", "f0f"],
    process: function(o) {
      return [parseInt(o[1] + o[1], 16), parseInt(o[2] + o[2], 16), parseInt(o[3] + o[3], 16)];
    }
  }], n = 0; n < t.length; n++) {
    var i = t[n].re, a = t[n].process, s = i.exec(r6);
    s && (e = a(s), this.r = e[0], this.g = e[1], this.b = e[2], this.ok = true);
  }
  this.r = this.r < 0 || isNaN(this.r) ? 0 : this.r > 255 ? 255 : this.r, this.g = this.g < 0 || isNaN(this.g) ? 0 : this.g > 255 ? 255 : this.g, this.b = this.b < 0 || isNaN(this.b) ? 0 : this.b > 255 ? 255 : this.b, this.toRGB = function() {
    return "rgb(" + this.r + ", " + this.g + ", " + this.b + ")";
  }, this.toHex = function() {
    var o = this.r.toString(16), f = this.g.toString(16), h = this.b.toString(16);
    return o.length == 1 && (o = "0" + o), f.length == 1 && (f = "0" + f), h.length == 1 && (h = "0" + h), "#" + o + f + h;
  };
}
function ll(r6, e) {
  var t = r6[0], n = r6[1], i = r6[2], a = r6[3];
  t = Gr(t, n, i, a, e[0], 7, -680876936), a = Gr(a, t, n, i, e[1], 12, -389564586), i = Gr(i, a, t, n, e[2], 17, 606105819), n = Gr(n, i, a, t, e[3], 22, -1044525330), t = Gr(t, n, i, a, e[4], 7, -176418897), a = Gr(a, t, n, i, e[5], 12, 1200080426), i = Gr(i, a, t, n, e[6], 17, -1473231341), n = Gr(n, i, a, t, e[7], 22, -45705983), t = Gr(t, n, i, a, e[8], 7, 1770035416), a = Gr(a, t, n, i, e[9], 12, -1958414417), i = Gr(i, a, t, n, e[10], 17, -42063), n = Gr(n, i, a, t, e[11], 22, -1990404162), t = Gr(t, n, i, a, e[12], 7, 1804603682), a = Gr(a, t, n, i, e[13], 12, -40341101), i = Gr(i, a, t, n, e[14], 17, -1502002290), t = Xr(t, n = Gr(n, i, a, t, e[15], 22, 1236535329), i, a, e[1], 5, -165796510), a = Xr(a, t, n, i, e[6], 9, -1069501632), i = Xr(i, a, t, n, e[11], 14, 643717713), n = Xr(n, i, a, t, e[0], 20, -373897302), t = Xr(t, n, i, a, e[5], 5, -701558691), a = Xr(a, t, n, i, e[10], 9, 38016083), i = Xr(i, a, t, n, e[15], 14, -660478335), n = Xr(n, i, a, t, e[4], 20, -405537848), t = Xr(t, n, i, a, e[9], 5, 568446438), a = Xr(a, t, n, i, e[14], 9, -1019803690), i = Xr(i, a, t, n, e[3], 14, -187363961), n = Xr(n, i, a, t, e[8], 20, 1163531501), t = Xr(t, n, i, a, e[13], 5, -1444681467), a = Xr(a, t, n, i, e[2], 9, -51403784), i = Xr(i, a, t, n, e[7], 14, 1735328473), t = Yr(t, n = Xr(n, i, a, t, e[12], 20, -1926607734), i, a, e[5], 4, -378558), a = Yr(a, t, n, i, e[8], 11, -2022574463), i = Yr(i, a, t, n, e[11], 16, 1839030562), n = Yr(n, i, a, t, e[14], 23, -35309556), t = Yr(t, n, i, a, e[1], 4, -1530992060), a = Yr(a, t, n, i, e[4], 11, 1272893353), i = Yr(i, a, t, n, e[7], 16, -155497632), n = Yr(n, i, a, t, e[10], 23, -1094730640), t = Yr(t, n, i, a, e[13], 4, 681279174), a = Yr(a, t, n, i, e[0], 11, -358537222), i = Yr(i, a, t, n, e[3], 16, -722521979), n = Yr(n, i, a, t, e[6], 23, 76029189), t = Yr(t, n, i, a, e[9], 4, -640364487), a = Yr(a, t, n, i, e[12], 11, -421815835), i = Yr(i, a, t, n, e[15], 16, 530742520), t = $r(t, n = Yr(n, i, a, t, e[2], 23, -995338651), i, a, e[0], 6, -198630844), a = $r(a, t, n, i, e[7], 10, 1126891415), i = $r(i, a, t, n, e[14], 15, -1416354905), n = $r(n, i, a, t, e[5], 21, -57434055), t = $r(t, n, i, a, e[12], 6, 1700485571), a = $r(a, t, n, i, e[3], 10, -1894986606), i = $r(i, a, t, n, e[10], 15, -1051523), n = $r(n, i, a, t, e[1], 21, -2054922799), t = $r(t, n, i, a, e[8], 6, 1873313359), a = $r(a, t, n, i, e[15], 10, -30611744), i = $r(i, a, t, n, e[6], 15, -1560198380), n = $r(n, i, a, t, e[13], 21, 1309151649), t = $r(t, n, i, a, e[4], 6, -145523070), a = $r(a, t, n, i, e[11], 10, -1120210379), i = $r(i, a, t, n, e[2], 15, 718787259), n = $r(n, i, a, t, e[9], 21, -343485551), r6[0] = fa(t, r6[0]), r6[1] = fa(n, r6[1]), r6[2] = fa(i, r6[2]), r6[3] = fa(a, r6[3]);
}
function uf(r6, e, t, n, i, a) {
  return e = fa(fa(e, r6), fa(n, a)), fa(e << i | e >>> 32 - i, t);
}
function Gr(r6, e, t, n, i, a, s) {
  return uf(e & t | ~e & n, r6, e, i, a, s);
}
function Xr(r6, e, t, n, i, a, s) {
  return uf(e & n | t & ~n, r6, e, i, a, s);
}
function Yr(r6, e, t, n, i, a, s) {
  return uf(e ^ t ^ n, r6, e, i, a, s);
}
function $r(r6, e, t, n, i, a, s) {
  return uf(t ^ (e | ~n), r6, e, i, a, s);
}
function j1(r6) {
  var e, t = r6.length, n = [1732584193, -271733879, -1732584194, 271733878];
  for (e = 64; e <= r6.length; e += 64) ll(n, t3(r6.substring(e - 64, e)));
  r6 = r6.substring(e - 64);
  var i = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
  for (e = 0; e < r6.length; e++) i[e >> 2] |= r6.charCodeAt(e) << (e % 4 << 3);
  if (i[e >> 2] |= 128 << (e % 4 << 3), e > 55) for (ll(n, i), e = 0; e < 16; e++) i[e] = 0;
  return i[14] = 8 * t, ll(n, i), n;
}
function t3(r6) {
  var e, t = [];
  for (e = 0; e < 64; e += 4) t[e >> 2] = r6.charCodeAt(e) + (r6.charCodeAt(e + 1) << 8) + (r6.charCodeAt(e + 2) << 16) + (r6.charCodeAt(e + 3) << 24);
  return t;
}
wo = dt.atob.bind(dt), El = dt.btoa.bind(dt);
var Tc = "0123456789abcdef".split("");
function r3(r6) {
  for (var e = "", t = 0; t < 4; t++) e += Tc[r6 >> 8 * t + 4 & 15] + Tc[r6 >> 8 * t & 15];
  return e;
}
function n3(r6) {
  return String.fromCharCode((255 & r6) >> 0, (65280 & r6) >> 8, (16711680 & r6) >> 16, (4278190080 & r6) >> 24);
}
function Nl(r6) {
  return j1(r6).map(n3).join("");
}
var i3 = function(r6) {
  for (var e = 0; e < r6.length; e++) r6[e] = r3(r6[e]);
  return r6.join("");
}(j1("hello")) != "5d41402abc4b2a76b9719d911017c592";
function fa(r6, e) {
  if (i3) {
    var t = (65535 & r6) + (65535 & e);
    return (r6 >> 16) + (e >> 16) + (t >> 16) << 16 | 65535 & t;
  }
  return r6 + e & 4294967295;
}
function Fl(r6, e) {
  var t, n, i, a;
  if (r6 !== t) {
    for (var s = (i = r6, a = 1 + (256 / r6.length >> 0), new Array(a + 1).join(i)), o = [], f = 0; f < 256; f++) o[f] = f;
    var h = 0;
    for (f = 0; f < 256; f++) {
      var c = o[f];
      h = (h + c + s.charCodeAt(f)) % 256, o[f] = o[h], o[h] = c;
    }
    t = r6, n = o;
  } else o = n;
  var p = e.length, v = 0, d = 0, w = "";
  for (f = 0; f < p; f++) d = (d + (c = o[v = (v + 1) % 256])) % 256, o[v] = o[d], o[d] = c, s = o[(o[v] + o[d]) % 256], w += String.fromCharCode(e.charCodeAt(f) ^ s);
  return w;
}
var Ec = {
  print: 4,
  modify: 8,
  copy: 16,
  "annot-forms": 32
};
function ps(r6, e, t, n) {
  this.v = 1, this.r = 2;
  var i = 192;
  r6.forEach(function(o) {
    if (Ec.perm !== void 0) throw new Error("Invalid permission: " + o);
    i += Ec[o];
  }), this.padding = "(¿N^NuAd\0NVÿú\b..\0¶Ðh>/\f©þdSiz";
  var a = (e + this.padding).substr(0, 32), s = (t + this.padding).substr(0, 32);
  this.O = this.processOwnerPassword(a, s), this.P = -(1 + (255 ^ i)), this.encryptionKey = Nl(a + this.O + this.lsbFirstWord(this.P) + this.hexToBytes(n)).substr(0, 5), this.U = Fl(this.encryptionKey, this.padding);
}
function gs(r6) {
  if (/[^\u0000-\u00ff]/.test(r6)) throw new Error("Invalid PDF Name Object: " + r6 + ", Only accept ASCII characters.");
  for (var e = "", t = r6.length, n = 0; n < t; n++) {
    var i = r6.charCodeAt(n);
    i < 33 || i === 35 || i === 37 || i === 40 || i === 41 || i === 47 || i === 60 || i === 62 || i === 91 || i === 93 || i === 123 || i === 125 || i > 126 ? e += "#" + ("0" + i.toString(16)).slice(-2) : e += r6[n];
  }
  return e;
}
function Nc(r6) {
  if (Wt(r6) !== "object") throw new Error("Invalid Context passed to initialize PubSub (jsPDF-module)");
  var e = {};
  this.subscribe = function(t, n, i) {
    if (i = i || false, typeof t != "string" || typeof n != "function" || typeof i != "boolean") throw new Error("Invalid arguments passed to PubSub.subscribe (jsPDF-module)");
    e.hasOwnProperty(t) || (e[t] = {});
    var a = Math.random().toString(35);
    return e[t][a] = [n, !!i], a;
  }, this.unsubscribe = function(t) {
    for (var n in e) if (e[n][t]) return delete e[n][t], Object.keys(e[n]).length === 0 && delete e[n], true;
    return false;
  }, this.publish = function(t) {
    if (e.hasOwnProperty(t)) {
      var n = Array.prototype.slice.call(arguments, 1), i = [];
      for (var a in e[t]) {
        var s = e[t][a];
        try {
          s[0].apply(r6, n);
        } catch (o) {
          dt.console && Kt.error("jsPDF PubSub Error", o.message, o);
        }
        s[1] && i.push(a);
      }
      i.length && i.forEach(this.unsubscribe);
    }
  }, this.getTopics = function() {
    return e;
  };
}
function J0(r6) {
  if (!(this instanceof J0)) return new J0(r6);
  var e = "opacity,stroke-opacity".split(",");
  for (var t in r6) r6.hasOwnProperty(t) && e.indexOf(t) >= 0 && (this[t] = r6[t]);
  this.id = "", this.objectNumber = -1;
}
function U1(r6, e) {
  this.gState = r6, this.matrix = e, this.id = "", this.objectNumber = -1;
}
function Fa(r6, e, t, n, i) {
  if (!(this instanceof Fa)) return new Fa(r6, e, t, n, i);
  this.type = r6 === "axial" ? 2 : 3, this.coords = e, this.colors = t, U1.call(this, n, i);
}
function ms(r6, e, t, n, i) {
  if (!(this instanceof ms)) return new ms(r6, e, t, n, i);
  this.boundingBox = r6, this.xStep = e, this.yStep = t, this.stream = "", this.cloneIndex = 0, U1.call(this, n, i);
}
function ut(r6) {
  var e, t = typeof arguments[0] == "string" ? arguments[0] : "p", n = arguments[1], i = arguments[2], a = arguments[3], s = [], o = 1, f = 16, h = "S", c = null;
  Wt(r6 = r6 || {}) === "object" && (t = r6.orientation, n = r6.unit || n, i = r6.format || i, a = r6.compress || r6.compressPdf || a, (c = r6.encryption || null) !== null && (c.userPassword = c.userPassword || "", c.ownerPassword = c.ownerPassword || "", c.userPermissions = c.userPermissions || []), o = typeof r6.userUnit == "number" ? Math.abs(r6.userUnit) : 1, r6.precision !== void 0 && (e = r6.precision), r6.floatPrecision !== void 0 && (f = r6.floatPrecision), h = r6.defaultPathOperation || "S"), s = r6.filters || (a === true ? ["FlateEncode"] : s), n = n || "mm", t = ("" + (t || "P")).toLowerCase();
  var p = r6.putOnlyUsedFonts || false, v = {}, d = {
    internal: {},
    __private__: {}
  };
  d.__private__.PubSub = Nc;
  var w = "1.3", x = d.__private__.getPdfVersion = function() {
    return w;
  };
  d.__private__.setPdfVersion = function(g) {
    w = g;
  };
  var S = {
    a0: [2383.94, 3370.39],
    a1: [1683.78, 2383.94],
    a2: [1190.55, 1683.78],
    a3: [841.89, 1190.55],
    a4: [595.28, 841.89],
    a5: [419.53, 595.28],
    a6: [297.64, 419.53],
    a7: [209.76, 297.64],
    a8: [147.4, 209.76],
    a9: [104.88, 147.4],
    a10: [73.7, 104.88],
    b0: [2834.65, 4008.19],
    b1: [2004.09, 2834.65],
    b2: [1417.32, 2004.09],
    b3: [1000.63, 1417.32],
    b4: [708.66, 1000.63],
    b5: [498.9, 708.66],
    b6: [354.33, 498.9],
    b7: [249.45, 354.33],
    b8: [175.75, 249.45],
    b9: [124.72, 175.75],
    b10: [87.87, 124.72],
    c0: [2599.37, 3676.54],
    c1: [1836.85, 2599.37],
    c2: [1298.27, 1836.85],
    c3: [918.43, 1298.27],
    c4: [649.13, 918.43],
    c5: [459.21, 649.13],
    c6: [323.15, 459.21],
    c7: [229.61, 323.15],
    c8: [161.57, 229.61],
    c9: [113.39, 161.57],
    c10: [79.37, 113.39],
    dl: [311.81, 623.62],
    letter: [612, 792],
    "government-letter": [576, 756],
    legal: [612, 1008],
    "junior-legal": [576, 360],
    ledger: [1224, 792],
    tabloid: [792, 1224],
    "credit-card": [153, 243]
  };
  d.__private__.getPageFormats = function() {
    return S;
  };
  var A = d.__private__.getPageFormat = function(g) {
    return S[g];
  };
  i = i || "a4";
  var b = {
    COMPAT: "compat",
    ADVANCED: "advanced"
  }, O = b.COMPAT;
  function q() {
    this.saveGraphicsState(), Z(new lt(Qe, 0, 0, -Qe, 0, Vi() * Qe).toString() + " cm"), this.setFontSize(this.getFontSize() / Qe), h = "n", O = b.ADVANCED;
  }
  function te() {
    this.restoreGraphicsState(), h = "S", O = b.COMPAT;
  }
  var le = d.__private__.combineFontStyleAndFontWeight = function(g, E) {
    if (g == "bold" && E == "normal" || g == "bold" && E == 400 || g == "normal" && E == "italic" || g == "bold" && E == "italic") throw new Error("Invalid Combination of fontweight and fontstyle");
    return E && (g = E == 400 || E === "normal" ? g === "italic" ? "italic" : "normal" : E != 700 && E !== "bold" || g !== "normal" ? (E == 700 ? "bold" : E) + "" + g : "bold"), g;
  };
  d.advancedAPI = function(g) {
    var E = O === b.COMPAT;
    return E && q.call(this), typeof g != "function" || (g(this), E && te.call(this)), this;
  }, d.compatAPI = function(g) {
    var E = O === b.ADVANCED;
    return E && te.call(this), typeof g != "function" || (g(this), E && q.call(this)), this;
  }, d.isAdvancedAPI = function() {
    return O === b.ADVANCED;
  };
  var j, M = function(g) {
    if (O !== b.ADVANCED) throw new Error(g + " is only available in 'advanced' API mode. You need to call advancedAPI() first.");
  }, H = d.roundToPrecision = d.__private__.roundToPrecision = function(g, E) {
    var J = e || E;
    if (isNaN(g) || isNaN(J)) throw new Error("Invalid argument passed to jsPDF.roundToPrecision");
    return g.toFixed(J).replace(/0+$/, "");
  };
  j = d.hpf = d.__private__.hpf = typeof f == "number" ? function(g) {
    if (isNaN(g)) throw new Error("Invalid argument passed to jsPDF.hpf");
    return H(g, f);
  } : f === "smart" ? function(g) {
    if (isNaN(g)) throw new Error("Invalid argument passed to jsPDF.hpf");
    return H(g, g > -1 && g < 1 ? 16 : 5);
  } : function(g) {
    if (isNaN(g)) throw new Error("Invalid argument passed to jsPDF.hpf");
    return H(g, 16);
  };
  var ee = d.f2 = d.__private__.f2 = function(g) {
    if (isNaN(g)) throw new Error("Invalid argument passed to jsPDF.f2");
    return H(g, 2);
  }, F = d.__private__.f3 = function(g) {
    if (isNaN(g)) throw new Error("Invalid argument passed to jsPDF.f3");
    return H(g, 3);
  }, P = d.scale = d.__private__.scale = function(g) {
    if (isNaN(g)) throw new Error("Invalid argument passed to jsPDF.scale");
    return O === b.COMPAT ? g * Qe : O === b.ADVANCED ? g : void 0;
  }, Y = function(g) {
    return O === b.COMPAT ? Vi() - g : O === b.ADVANCED ? g : void 0;
  }, Q = function(g) {
    return P(Y(g));
  };
  d.__private__.setPrecision = d.setPrecision = function(g) {
    typeof parseInt(g, 10) == "number" && (e = parseInt(g, 10));
  };
  var ce, we = "00000000000000000000000000000000", Se = d.__private__.getFileId = function() {
    return we;
  }, de = d.__private__.setFileId = function(g) {
    return we = g !== void 0 && /^[a-fA-F0-9]{32}$/.test(g) ? g.toUpperCase() : we.split("").map(function() {
      return "ABCDEF0123456789".charAt(Math.floor(16 * Math.random()));
    }).join(""), c !== null && (zr = new ps(c.userPermissions, c.userPassword, c.ownerPassword, we)), we;
  };
  d.setFileId = function(g) {
    return de(g), this;
  }, d.getFileId = function() {
    return Se();
  };
  var Ae = d.__private__.convertDateToPDFDate = function(g) {
    var E = g.getTimezoneOffset(), J = E < 0 ? "+" : "-", ne = Math.floor(Math.abs(E / 60)), ue = Math.abs(E % 60), Fe = [J, N(ne), "'", N(ue), "'"].join("");
    return ["D:", g.getFullYear(), N(g.getMonth() + 1), N(g.getDate()), N(g.getHours()), N(g.getMinutes()), N(g.getSeconds()), Fe].join("");
  }, be = d.__private__.convertPDFDateToDate = function(g) {
    var E = parseInt(g.substr(2, 4), 10), J = parseInt(g.substr(6, 2), 10) - 1, ne = parseInt(g.substr(8, 2), 10), ue = parseInt(g.substr(10, 2), 10), Fe = parseInt(g.substr(12, 2), 10), je = parseInt(g.substr(14, 2), 10);
    return new Date(E, J, ne, ue, Fe, je, 0);
  }, ze = d.__private__.setCreationDate = function(g) {
    var E;
    if (g === void 0 && (g = /* @__PURE__ */ new Date()), g instanceof Date) E = Ae(g);
    else {
      if (!/^D:(20[0-2][0-9]|203[0-7]|19[7-9][0-9])(0[0-9]|1[0-2])([0-2][0-9]|3[0-1])(0[0-9]|1[0-9]|2[0-3])(0[0-9]|[1-5][0-9])(0[0-9]|[1-5][0-9])(\+0[0-9]|\+1[0-4]|-0[0-9]|-1[0-1])'(0[0-9]|[1-5][0-9])'?$/.test(g)) throw new Error("Invalid argument passed to jsPDF.setCreationDate");
      E = g;
    }
    return ce = E;
  }, y = d.__private__.getCreationDate = function(g) {
    var E = ce;
    return g === "jsDate" && (E = be(ce)), E;
  };
  d.setCreationDate = function(g) {
    return ze(g), this;
  }, d.getCreationDate = function(g) {
    return y(g);
  };
  var L, N = d.__private__.padd2 = function(g) {
    return ("0" + parseInt(g)).slice(-2);
  }, C = d.__private__.padd2Hex = function(g) {
    return ("00" + (g = g.toString())).substr(g.length);
  }, z = 0, re = [], se = [], ie = 0, ve = [], Ce = [], Oe = false, qe = se, Ye = function() {
    z = 0, ie = 0, se = [], re = [], ve = [], U = ir(), W = ir();
  };
  d.__private__.setCustomOutputDestination = function(g) {
    Oe = true, qe = g;
  };
  var Te = function(g) {
    Oe || (qe = g);
  };
  d.__private__.resetCustomOutputDestination = function() {
    Oe = false, qe = se;
  };
  var Z = d.__private__.out = function(g) {
    return g = g.toString(), ie += g.length + 1, qe.push(g), qe;
  }, Ie = d.__private__.write = function(g) {
    return Z(arguments.length === 1 ? g.toString() : Array.prototype.join.call(arguments, " "));
  }, rt = d.__private__.getArrayBuffer = function(g) {
    for (var E = g.length, J = new ArrayBuffer(E), ne = new Uint8Array(J); E--; ) ne[E] = g.charCodeAt(E);
    return J;
  }, Be = [["Helvetica", "helvetica", "normal", "WinAnsiEncoding"], ["Helvetica-Bold", "helvetica", "bold", "WinAnsiEncoding"], ["Helvetica-Oblique", "helvetica", "italic", "WinAnsiEncoding"], ["Helvetica-BoldOblique", "helvetica", "bolditalic", "WinAnsiEncoding"], ["Courier", "courier", "normal", "WinAnsiEncoding"], ["Courier-Bold", "courier", "bold", "WinAnsiEncoding"], ["Courier-Oblique", "courier", "italic", "WinAnsiEncoding"], ["Courier-BoldOblique", "courier", "bolditalic", "WinAnsiEncoding"], ["Times-Roman", "times", "normal", "WinAnsiEncoding"], ["Times-Bold", "times", "bold", "WinAnsiEncoding"], ["Times-Italic", "times", "italic", "WinAnsiEncoding"], ["Times-BoldItalic", "times", "bolditalic", "WinAnsiEncoding"], ["ZapfDingbats", "zapfdingbats", "normal", null], ["Symbol", "symbol", "normal", null]];
  d.__private__.getStandardFonts = function() {
    return Be;
  };
  var We = r6.fontSize || 16;
  d.__private__.setFontSize = d.setFontSize = function(g) {
    return We = O === b.ADVANCED ? g / Qe : g, this;
  };
  var $e, Je = d.__private__.getFontSize = d.getFontSize = function() {
    return O === b.COMPAT ? We : We * Qe;
  }, st = r6.R2L || false;
  d.__private__.setR2L = d.setR2L = function(g) {
    return st = g, this;
  }, d.__private__.getR2L = d.getR2L = function() {
    return st;
  };
  var ot, gt = d.__private__.setZoomMode = function(g) {
    var E = [void 0, null, "fullwidth", "fullheight", "fullpage", "original"];
    if (/^(?:\d+\.\d*|\d*\.\d+|\d+)%$/.test(g)) $e = g;
    else if (isNaN(g)) {
      if (E.indexOf(g) === -1) throw new Error('zoom must be Integer (e.g. 2), a percentage Value (e.g. 300%) or fullwidth, fullheight, fullpage, original. "' + g + '" is not recognized.');
      $e = g;
    } else $e = parseInt(g, 10);
  };
  d.__private__.getZoomMode = function() {
    return $e;
  };
  var _t, Tt = d.__private__.setPageMode = function(g) {
    if ([void 0, null, "UseNone", "UseOutlines", "UseThumbs", "FullScreen"].indexOf(g) == -1) throw new Error('Page mode must be one of UseNone, UseOutlines, UseThumbs, or FullScreen. "' + g + '" is not recognized.');
    ot = g;
  };
  d.__private__.getPageMode = function() {
    return ot;
  };
  var Et = d.__private__.setLayoutMode = function(g) {
    if ([void 0, null, "continuous", "single", "twoleft", "tworight", "two"].indexOf(g) == -1) throw new Error('Layout mode must be one of continuous, single, twoleft, tworight. "' + g + '" is not recognized.');
    _t = g;
  };
  d.__private__.getLayoutMode = function() {
    return _t;
  }, d.__private__.setDisplayMode = d.setDisplayMode = function(g, E, J) {
    return gt(g), Et(E), Tt(J), this;
  };
  var ct = {
    title: "",
    subject: "",
    author: "",
    keywords: "",
    creator: ""
  };
  d.__private__.getDocumentProperty = function(g) {
    if (Object.keys(ct).indexOf(g) === -1) throw new Error("Invalid argument passed to jsPDF.getDocumentProperty");
    return ct[g];
  }, d.__private__.getDocumentProperties = function() {
    return ct;
  }, d.__private__.setDocumentProperties = d.setProperties = d.setDocumentProperties = function(g) {
    for (var E in ct) ct.hasOwnProperty(E) && g[E] && (ct[E] = g[E]);
    return this;
  }, d.__private__.setDocumentProperty = function(g, E) {
    if (Object.keys(ct).indexOf(g) === -1) throw new Error("Invalid arguments passed to jsPDF.setDocumentProperty");
    return ct[g] = E;
  };
  var At, Qe, br, Ft, sn, Rt = {}, Jt = {}, Cn = [], Ct = {}, oi = {}, er = {}, mn = {}, Wn = null, Yt = 0, vt = [], kt = new Nc(d), _i = r6.hotfixes || [], Tr = {}, Pn = {}, kn = [], lt = function g(E, J, ne, ue, Fe, je) {
    if (!(this instanceof g)) return new g(E, J, ne, ue, Fe, je);
    isNaN(E) && (E = 1), isNaN(J) && (J = 0), isNaN(ne) && (ne = 0), isNaN(ue) && (ue = 1), isNaN(Fe) && (Fe = 0), isNaN(je) && (je = 0), this._matrix = [E, J, ne, ue, Fe, je];
  };
  Object.defineProperty(lt.prototype, "sx", {
    get: function() {
      return this._matrix[0];
    },
    set: function(g) {
      this._matrix[0] = g;
    }
  }), Object.defineProperty(lt.prototype, "shy", {
    get: function() {
      return this._matrix[1];
    },
    set: function(g) {
      this._matrix[1] = g;
    }
  }), Object.defineProperty(lt.prototype, "shx", {
    get: function() {
      return this._matrix[2];
    },
    set: function(g) {
      this._matrix[2] = g;
    }
  }), Object.defineProperty(lt.prototype, "sy", {
    get: function() {
      return this._matrix[3];
    },
    set: function(g) {
      this._matrix[3] = g;
    }
  }), Object.defineProperty(lt.prototype, "tx", {
    get: function() {
      return this._matrix[4];
    },
    set: function(g) {
      this._matrix[4] = g;
    }
  }), Object.defineProperty(lt.prototype, "ty", {
    get: function() {
      return this._matrix[5];
    },
    set: function(g) {
      this._matrix[5] = g;
    }
  }), Object.defineProperty(lt.prototype, "a", {
    get: function() {
      return this._matrix[0];
    },
    set: function(g) {
      this._matrix[0] = g;
    }
  }), Object.defineProperty(lt.prototype, "b", {
    get: function() {
      return this._matrix[1];
    },
    set: function(g) {
      this._matrix[1] = g;
    }
  }), Object.defineProperty(lt.prototype, "c", {
    get: function() {
      return this._matrix[2];
    },
    set: function(g) {
      this._matrix[2] = g;
    }
  }), Object.defineProperty(lt.prototype, "d", {
    get: function() {
      return this._matrix[3];
    },
    set: function(g) {
      this._matrix[3] = g;
    }
  }), Object.defineProperty(lt.prototype, "e", {
    get: function() {
      return this._matrix[4];
    },
    set: function(g) {
      this._matrix[4] = g;
    }
  }), Object.defineProperty(lt.prototype, "f", {
    get: function() {
      return this._matrix[5];
    },
    set: function(g) {
      this._matrix[5] = g;
    }
  }), Object.defineProperty(lt.prototype, "rotation", {
    get: function() {
      return Math.atan2(this.shx, this.sx);
    }
  }), Object.defineProperty(lt.prototype, "scaleX", {
    get: function() {
      return this.decompose().scale.sx;
    }
  }), Object.defineProperty(lt.prototype, "scaleY", {
    get: function() {
      return this.decompose().scale.sy;
    }
  }), Object.defineProperty(lt.prototype, "isIdentity", {
    get: function() {
      return this.sx === 1 && this.shy === 0 && this.shx === 0 && this.sy === 1 && this.tx === 0 && this.ty === 0;
    }
  }), lt.prototype.join = function(g) {
    return [this.sx, this.shy, this.shx, this.sy, this.tx, this.ty].map(j).join(g);
  }, lt.prototype.multiply = function(g) {
    var E = g.sx * this.sx + g.shy * this.shx, J = g.sx * this.shy + g.shy * this.sy, ne = g.shx * this.sx + g.sy * this.shx, ue = g.shx * this.shy + g.sy * this.sy, Fe = g.tx * this.sx + g.ty * this.shx + this.tx, je = g.tx * this.shy + g.ty * this.sy + this.ty;
    return new lt(E, J, ne, ue, Fe, je);
  }, lt.prototype.decompose = function() {
    var g = this.sx, E = this.shy, J = this.shx, ne = this.sy, ue = this.tx, Fe = this.ty, je = Math.sqrt(g * g + E * E), nt = (g /= je) * J + (E /= je) * ne;
    J -= g * nt, ne -= E * nt;
    var ft = Math.sqrt(J * J + ne * ne);
    return nt /= ft, g * (ne /= ft) < E * (J /= ft) && (g = -g, E = -E, nt = -nt, je = -je), {
      scale: new lt(je, 0, 0, ft, 0, 0),
      translate: new lt(1, 0, 0, 1, ue, Fe),
      rotate: new lt(g, E, -E, g, 0, 0),
      skew: new lt(1, 0, nt, 1, 0, 0)
    };
  }, lt.prototype.toString = function(g) {
    return this.join(" ");
  }, lt.prototype.inversed = function() {
    var g = this.sx, E = this.shy, J = this.shx, ne = this.sy, ue = this.tx, Fe = this.ty, je = 1 / (g * ne - E * J), nt = ne * je, ft = -E * je, yt = -J * je, xt = g * je;
    return new lt(nt, ft, yt, xt, -nt * ue - yt * Fe, -ft * ue - xt * Fe);
  }, lt.prototype.applyToPoint = function(g) {
    var E = g.x * this.sx + g.y * this.shx + this.tx, J = g.x * this.shy + g.y * this.sy + this.ty;
    return new Ga(E, J);
  }, lt.prototype.applyToRectangle = function(g) {
    var E = this.applyToPoint(g), J = this.applyToPoint(new Ga(g.x + g.w, g.y + g.h));
    return new qs(E.x, E.y, J.x - E.x, J.y - E.y);
  }, lt.prototype.clone = function() {
    var g = this.sx, E = this.shy, J = this.shx, ne = this.sy, ue = this.tx, Fe = this.ty;
    return new lt(g, E, J, ne, ue, Fe);
  }, d.Matrix = lt;
  var xn = d.matrixMult = function(g, E) {
    return E.multiply(g);
  }, on = new lt(1, 0, 0, 1, 0, 0);
  d.unitMatrix = d.identityMatrix = on;
  var Wr = function(g, E) {
    if (!oi[g]) {
      var J = (E instanceof Fa ? "Sh" : "P") + (Object.keys(Ct).length + 1).toString(10);
      E.id = J, oi[g] = J, Ct[J] = E, kt.publish("addPattern", E);
    }
  };
  d.ShadingPattern = Fa, d.TilingPattern = ms, d.addShadingPattern = function(g, E) {
    return M("addShadingPattern()"), Wr(g, E), this;
  }, d.beginTilingPattern = function(g) {
    M("beginTilingPattern()"), $o(g.boundingBox[0], g.boundingBox[1], g.boundingBox[2] - g.boundingBox[0], g.boundingBox[3] - g.boundingBox[1], g.matrix);
  }, d.endTilingPattern = function(g, E) {
    M("endTilingPattern()"), E.stream = Ce[L].join(`
`), Wr(g, E), kt.publish("endTilingPattern", E), kn.pop().restore();
  };
  var hr = d.__private__.newObject = function() {
    var g = ir();
    return D(g, true), g;
  }, ir = d.__private__.newObjectDeferred = function() {
    return z++, re[z] = function() {
      return ie;
    }, z;
  }, D = function(g, E) {
    return E = typeof E == "boolean" && E, re[g] = ie, E && Z(g + " 0 obj"), g;
  }, X = d.__private__.newAdditionalObject = function() {
    var g = {
      objId: ir(),
      content: ""
    };
    return ve.push(g), g;
  }, U = ir(), W = ir(), G = d.__private__.decodeColorString = function(g) {
    var E = g.split(" ");
    if (E.length !== 2 || E[1] !== "g" && E[1] !== "G") E.length === 5 && (E[4] === "k" || E[4] === "K") && (E = [(1 - E[0]) * (1 - E[3]), (1 - E[1]) * (1 - E[3]), (1 - E[2]) * (1 - E[3]), "r"]);
    else {
      var J = parseFloat(E[0]);
      E = [J, J, J, "r"];
    }
    for (var ne = "#", ue = 0; ue < 3; ue++) ne += ("0" + Math.floor(255 * parseFloat(E[ue])).toString(16)).slice(-2);
    return ne;
  }, K = d.__private__.encodeColorString = function(g) {
    var E;
    typeof g == "string" && (g = {
      ch1: g
    });
    var J = g.ch1, ne = g.ch2, ue = g.ch3, Fe = g.ch4, je = g.pdfColorType === "draw" ? ["G", "RG", "K"] : ["g", "rg", "k"];
    if (typeof J == "string" && J.charAt(0) !== "#") {
      var nt = new B1(J);
      if (nt.ok) J = nt.toHex();
      else if (!/^\d*\.?\d*$/.test(J)) throw new Error('Invalid color "' + J + '" passed to jsPDF.encodeColorString.');
    }
    if (typeof J == "string" && /^#[0-9A-Fa-f]{3}$/.test(J) && (J = "#" + J[1] + J[1] + J[2] + J[2] + J[3] + J[3]), typeof J == "string" && /^#[0-9A-Fa-f]{6}$/.test(J)) {
      var ft = parseInt(J.substr(1), 16);
      J = ft >> 16 & 255, ne = ft >> 8 & 255, ue = 255 & ft;
    }
    if (ne === void 0 || Fe === void 0 && J === ne && ne === ue) {
      if (typeof J == "string") E = J + " " + je[0];
      else switch (g.precision) {
        case 2:
          E = ee(J / 255) + " " + je[0];
          break;
        case 3:
        default:
          E = F(J / 255) + " " + je[0];
      }
    } else if (Fe === void 0 || Wt(Fe) === "object") {
      if (Fe && !isNaN(Fe.a) && Fe.a === 0) return E = ["1.", "1.", "1.", je[1]].join(" ");
      if (typeof J == "string") E = [J, ne, ue, je[1]].join(" ");
      else switch (g.precision) {
        case 2:
          E = [ee(J / 255), ee(ne / 255), ee(ue / 255), je[1]].join(" ");
          break;
        default:
        case 3:
          E = [F(J / 255), F(ne / 255), F(ue / 255), je[1]].join(" ");
      }
    } else if (typeof J == "string") E = [J, ne, ue, Fe, je[2]].join(" ");
    else switch (g.precision) {
      case 2:
        E = [ee(J), ee(ne), ee(ue), ee(Fe), je[2]].join(" ");
        break;
      case 3:
      default:
        E = [F(J), F(ne), F(ue), F(Fe), je[2]].join(" ");
    }
    return E;
  }, ge = d.__private__.getFilters = function() {
    return s;
  }, Ee = d.__private__.putStream = function(g) {
    var E = (g = g || {}).data || "", J = g.filters || ge(), ne = g.alreadyAppliedFilters || [], ue = g.addLength1 || false, Fe = E.length, je = g.objectId, nt = function(Vr) {
      return Vr;
    };
    if (c !== null && je === void 0) throw new Error("ObjectId must be passed to putStream for file encryption");
    c !== null && (nt = zr.encryptor(je, 0));
    var ft = {};
    J === true && (J = ["FlateEncode"]);
    var yt = g.additionalKeyValues || [], xt = (ft = ut.API.processDataByFilters !== void 0 ? ut.API.processDataByFilters(E, J) : {
      data: E,
      reverseChain: []
    }).reverseChain + (Array.isArray(ne) ? ne.join(" ") : ne.toString());
    if (ft.data.length !== 0 && (yt.push({
      key: "Length",
      value: ft.data.length
    }), ue === true && yt.push({
      key: "Length1",
      value: Fe
    })), xt.length != 0) if (xt.split("/").length - 1 == 1) yt.push({
      key: "Filter",
      value: xt
    });
    else {
      yt.push({
        key: "Filter",
        value: "[" + xt + "]"
      });
      for (var Lt = 0; Lt < yt.length; Lt += 1) if (yt[Lt].key === "DecodeParms") {
        for (var nr = [], ar = 0; ar < ft.reverseChain.split("/").length - 1; ar += 1) nr.push("null");
        nr.push(yt[Lt].value), yt[Lt].value = "[" + nr.join(" ") + "]";
      }
    }
    Z("<<");
    for (var xr = 0; xr < yt.length; xr++) Z("/" + yt[xr].key + " " + yt[xr].value);
    Z(">>"), ft.data.length !== 0 && (Z("stream"), Z(nt(ft.data)), Z("endstream"));
  }, pe = d.__private__.putPage = function(g) {
    var E = g.number, J = g.data, ne = g.objId, ue = g.contentsObjId;
    D(ne, true), Z("<</Type /Page"), Z("/Parent " + g.rootDictionaryObjId + " 0 R"), Z("/Resources " + g.resourceDictionaryObjId + " 0 R"), Z("/MediaBox [" + parseFloat(j(g.mediaBox.bottomLeftX)) + " " + parseFloat(j(g.mediaBox.bottomLeftY)) + " " + j(g.mediaBox.topRightX) + " " + j(g.mediaBox.topRightY) + "]"), g.cropBox !== null && Z("/CropBox [" + j(g.cropBox.bottomLeftX) + " " + j(g.cropBox.bottomLeftY) + " " + j(g.cropBox.topRightX) + " " + j(g.cropBox.topRightY) + "]"), g.bleedBox !== null && Z("/BleedBox [" + j(g.bleedBox.bottomLeftX) + " " + j(g.bleedBox.bottomLeftY) + " " + j(g.bleedBox.topRightX) + " " + j(g.bleedBox.topRightY) + "]"), g.trimBox !== null && Z("/TrimBox [" + j(g.trimBox.bottomLeftX) + " " + j(g.trimBox.bottomLeftY) + " " + j(g.trimBox.topRightX) + " " + j(g.trimBox.topRightY) + "]"), g.artBox !== null && Z("/ArtBox [" + j(g.artBox.bottomLeftX) + " " + j(g.artBox.bottomLeftY) + " " + j(g.artBox.topRightX) + " " + j(g.artBox.topRightY) + "]"), typeof g.userUnit == "number" && g.userUnit !== 1 && Z("/UserUnit " + g.userUnit), kt.publish("putPage", {
      objId: ne,
      pageContext: vt[E],
      pageNumber: E,
      page: J
    }), Z("/Contents " + ue + " 0 R"), Z(">>"), Z("endobj");
    var Fe = J.join(`
`);
    return O === b.ADVANCED && (Fe += `
Q`), D(ue, true), Ee({
      data: Fe,
      filters: ge(),
      objectId: ue
    }), Z("endobj"), ne;
  }, ye = d.__private__.putPages = function() {
    var g, E, J = [];
    for (g = 1; g <= Yt; g++) vt[g].objId = ir(), vt[g].contentsObjId = ir();
    for (g = 1; g <= Yt; g++) J.push(pe({
      number: g,
      data: Ce[g],
      objId: vt[g].objId,
      contentsObjId: vt[g].contentsObjId,
      mediaBox: vt[g].mediaBox,
      cropBox: vt[g].cropBox,
      bleedBox: vt[g].bleedBox,
      trimBox: vt[g].trimBox,
      artBox: vt[g].artBox,
      userUnit: vt[g].userUnit,
      rootDictionaryObjId: U,
      resourceDictionaryObjId: W
    }));
    D(U, true), Z("<</Type /Pages");
    var ne = "/Kids [";
    for (E = 0; E < Yt; E++) ne += J[E] + " 0 R ";
    Z(ne + "]"), Z("/Count " + Yt), Z(">>"), Z("endobj"), kt.publish("postPutPages");
  }, _e = function(g) {
    kt.publish("putFont", {
      font: g,
      out: Z,
      newObject: hr,
      putStream: Ee
    }), g.isAlreadyPutted !== true && (g.objectNumber = hr(), Z("<<"), Z("/Type /Font"), Z("/BaseFont /" + gs(g.postScriptName)), Z("/Subtype /Type1"), typeof g.encoding == "string" && Z("/Encoding /" + g.encoding), Z("/FirstChar 32"), Z("/LastChar 255"), Z(">>"), Z("endobj"));
  }, Ue = function() {
    for (var g in Rt) Rt.hasOwnProperty(g) && (p === false || p === true && v.hasOwnProperty(g)) && _e(Rt[g]);
  }, Ve = function(g) {
    g.objectNumber = hr();
    var E = [];
    E.push({
      key: "Type",
      value: "/XObject"
    }), E.push({
      key: "Subtype",
      value: "/Form"
    }), E.push({
      key: "BBox",
      value: "[" + [j(g.x), j(g.y), j(g.x + g.width), j(g.y + g.height)].join(" ") + "]"
    }), E.push({
      key: "Matrix",
      value: "[" + g.matrix.toString() + "]"
    });
    var J = g.pages[1].join(`
`);
    Ee({
      data: J,
      additionalKeyValues: E,
      objectId: g.objectNumber
    }), Z("endobj");
  }, tt = function() {
    for (var g in Tr) Tr.hasOwnProperty(g) && Ve(Tr[g]);
  }, He = function(g, E) {
    var J, ne = [], ue = 1 / (E - 1);
    for (J = 0; J < 1; J += ue) ne.push(J);
    if (ne.push(1), g[0].offset != 0) {
      var Fe = {
        offset: 0,
        color: g[0].color
      };
      g.unshift(Fe);
    }
    if (g[g.length - 1].offset != 1) {
      var je = {
        offset: 1,
        color: g[g.length - 1].color
      };
      g.push(je);
    }
    for (var nt = "", ft = 0, yt = 0; yt < ne.length; yt++) {
      for (J = ne[yt]; J > g[ft + 1].offset; ) ft++;
      var xt = g[ft].offset, Lt = (J - xt) / (g[ft + 1].offset - xt), nr = g[ft].color, ar = g[ft + 1].color;
      nt += C(Math.round((1 - Lt) * nr[0] + Lt * ar[0]).toString(16)) + C(Math.round((1 - Lt) * nr[1] + Lt * ar[1]).toString(16)) + C(Math.round((1 - Lt) * nr[2] + Lt * ar[2]).toString(16));
    }
    return nt.trim();
  }, et = function(g, E) {
    E || (E = 21);
    var J = hr(), ne = He(g.colors, E), ue = [];
    ue.push({
      key: "FunctionType",
      value: "0"
    }), ue.push({
      key: "Domain",
      value: "[0.0 1.0]"
    }), ue.push({
      key: "Size",
      value: "[" + E + "]"
    }), ue.push({
      key: "BitsPerSample",
      value: "8"
    }), ue.push({
      key: "Range",
      value: "[0.0 1.0 0.0 1.0 0.0 1.0]"
    }), ue.push({
      key: "Decode",
      value: "[0.0 1.0 0.0 1.0 0.0 1.0]"
    }), Ee({
      data: ne,
      additionalKeyValues: ue,
      alreadyAppliedFilters: ["/ASCIIHexDecode"],
      objectId: J
    }), Z("endobj"), g.objectNumber = hr(), Z("<< /ShadingType " + g.type), Z("/ColorSpace /DeviceRGB");
    var Fe = "/Coords [" + j(parseFloat(g.coords[0])) + " " + j(parseFloat(g.coords[1])) + " ";
    g.type === 2 ? Fe += j(parseFloat(g.coords[2])) + " " + j(parseFloat(g.coords[3])) : Fe += j(parseFloat(g.coords[2])) + " " + j(parseFloat(g.coords[3])) + " " + j(parseFloat(g.coords[4])) + " " + j(parseFloat(g.coords[5])), Z(Fe += "]"), g.matrix && Z("/Matrix [" + g.matrix.toString() + "]"), Z("/Function " + J + " 0 R"), Z("/Extend [true true]"), Z(">>"), Z("endobj");
  }, pt = function(g, E) {
    var J = ir(), ne = hr();
    E.push({
      resourcesOid: J,
      objectOid: ne
    }), g.objectNumber = ne;
    var ue = [];
    ue.push({
      key: "Type",
      value: "/Pattern"
    }), ue.push({
      key: "PatternType",
      value: "1"
    }), ue.push({
      key: "PaintType",
      value: "1"
    }), ue.push({
      key: "TilingType",
      value: "1"
    }), ue.push({
      key: "BBox",
      value: "[" + g.boundingBox.map(j).join(" ") + "]"
    }), ue.push({
      key: "XStep",
      value: j(g.xStep)
    }), ue.push({
      key: "YStep",
      value: j(g.yStep)
    }), ue.push({
      key: "Resources",
      value: J + " 0 R"
    }), g.matrix && ue.push({
      key: "Matrix",
      value: "[" + g.matrix.toString() + "]"
    }), Ee({
      data: g.stream,
      additionalKeyValues: ue,
      objectId: g.objectNumber
    }), Z("endobj");
  }, Mt = function(g) {
    var E;
    for (E in Ct) Ct.hasOwnProperty(E) && (Ct[E] instanceof Fa ? et(Ct[E]) : Ct[E] instanceof ms && pt(Ct[E], g));
  }, Vt = function(g) {
    for (var E in g.objectNumber = hr(), Z("<<"), g) switch (E) {
      case "opacity":
        Z("/ca " + ee(g[E]));
        break;
      case "stroke-opacity":
        Z("/CA " + ee(g[E]));
    }
    Z(">>"), Z("endobj");
  }, mr = function() {
    var g;
    for (g in er) er.hasOwnProperty(g) && Vt(er[g]);
  }, zn = function() {
    for (var g in Z("/XObject <<"), Tr) Tr.hasOwnProperty(g) && Tr[g].objectNumber >= 0 && Z("/" + g + " " + Tr[g].objectNumber + " 0 R");
    kt.publish("putXobjectDict"), Z(">>");
  }, Si = function() {
    zr.oid = hr(), Z("<<"), Z("/Filter /Standard"), Z("/V " + zr.v), Z("/R " + zr.r), Z("/U <" + zr.toHexString(zr.U) + ">"), Z("/O <" + zr.toHexString(zr.O) + ">"), Z("/P " + zr.P), Z(">>"), Z("endobj");
  }, fi = function() {
    for (var g in Z("/Font <<"), Rt) Rt.hasOwnProperty(g) && (p === false || p === true && v.hasOwnProperty(g)) && Z("/" + g + " " + Rt[g].objectNumber + " 0 R");
    Z(">>");
  }, Vn = function() {
    if (Object.keys(Ct).length > 0) {
      for (var g in Z("/Shading <<"), Ct) Ct.hasOwnProperty(g) && Ct[g] instanceof Fa && Ct[g].objectNumber >= 0 && Z("/" + g + " " + Ct[g].objectNumber + " 0 R");
      kt.publish("putShadingPatternDict"), Z(">>");
    }
  }, li = function(g) {
    if (Object.keys(Ct).length > 0) {
      for (var E in Z("/Pattern <<"), Ct) Ct.hasOwnProperty(E) && Ct[E] instanceof d.TilingPattern && Ct[E].objectNumber >= 0 && Ct[E].objectNumber < g && Z("/" + E + " " + Ct[E].objectNumber + " 0 R");
      kt.publish("putTilingPatternDict"), Z(">>");
    }
  }, wn = function() {
    if (Object.keys(er).length > 0) {
      var g;
      for (g in Z("/ExtGState <<"), er) er.hasOwnProperty(g) && er[g].objectNumber >= 0 && Z("/" + g + " " + er[g].objectNumber + " 0 R");
      kt.publish("putGStateDict"), Z(">>");
    }
  }, cr = function(g) {
    D(g.resourcesOid, true), Z("<<"), Z("/ProcSet [/PDF /Text /ImageB /ImageC /ImageI]"), fi(), Vn(), li(g.objectOid), wn(), zn(), Z(">>"), Z("endobj");
  }, Oo = function() {
    var g = [];
    Ue(), mr(), tt(), Mt(g), kt.publish("putResources"), g.forEach(cr), cr({
      resourcesOid: W,
      objectOid: Number.MAX_SAFE_INTEGER
    }), kt.publish("postPutResources");
  }, Io = function() {
    kt.publish("putAdditionalObjects");
    for (var g = 0; g < ve.length; g++) {
      var E = ve[g];
      D(E.objId, true), Z(E.content), Z("endobj");
    }
    kt.publish("postPutAdditionalObjects");
  }, Ro = function(g) {
    Jt[g.fontName] = Jt[g.fontName] || {}, Jt[g.fontName][g.fontStyle] = g.id;
  }, ks = function(g, E, J, ne, ue) {
    var Fe = {
      id: "F" + (Object.keys(Rt).length + 1).toString(10),
      postScriptName: g,
      fontName: E,
      fontStyle: J,
      encoding: ne,
      isStandardFont: ue || false,
      metadata: {}
    };
    return kt.publish("addFont", {
      font: Fe,
      instance: this
    }), Rt[Fe.id] = Fe, Ro(Fe), Fe.id;
  }, pf = function(g) {
    for (var E = 0, J = Be.length; E < J; E++) {
      var ne = ks.call(this, g[E][0], g[E][1], g[E][2], Be[E][3], true);
      p === false && (v[ne] = true);
      var ue = g[E][0].split("-");
      Ro({
        id: ne,
        fontName: ue[0],
        fontStyle: ue[1] || ""
      });
    }
    kt.publish("addFonts", {
      fonts: Rt,
      dictionary: Jt
    });
  }, Gn = function(g) {
    return g.foo = function() {
      try {
        return g.apply(this, arguments);
      } catch (ne) {
        var E = ne.stack || "";
        ~E.indexOf(" at ") && (E = E.split(" at ")[1]);
        var J = "Error in function " + E.split(`
`)[0].split("<")[0] + ": " + ne.message;
        if (!dt.console) throw new Error(J);
        dt.console.error(J, ne), dt.alert && alert(J);
      }
    }, g.foo.bar = g, g.foo;
  }, Ua = function(g, E) {
    var J, ne, ue, Fe, je, nt, ft, yt, xt;
    if (ue = (E = E || {}).sourceEncoding || "Unicode", je = E.outputEncoding, (E.autoencode || je) && Rt[At].metadata && Rt[At].metadata[ue] && Rt[At].metadata[ue].encoding && (Fe = Rt[At].metadata[ue].encoding, !je && Rt[At].encoding && (je = Rt[At].encoding), !je && Fe.codePages && (je = Fe.codePages[0]), typeof je == "string" && (je = Fe[je]), je)) {
      for (ft = false, nt = [], J = 0, ne = g.length; J < ne; J++) (yt = je[g.charCodeAt(J)]) ? nt.push(String.fromCharCode(yt)) : nt.push(g[J]), nt[J].charCodeAt(0) >> 8 && (ft = true);
      g = nt.join("");
    }
    for (J = g.length; ft === void 0 && J !== 0; ) g.charCodeAt(J - 1) >> 8 && (ft = true), J--;
    if (!ft) return g;
    for (nt = E.noBOM ? [] : [254, 255], J = 0, ne = g.length; J < ne; J++) {
      if ((xt = (yt = g.charCodeAt(J)) >> 8) >> 8) throw new Error("Character at position " + J + " of string '" + g + "' exceeds 16bits. Cannot be encoded into UCS-2 BE");
      nt.push(xt), nt.push(yt - (xt << 8));
    }
    return String.fromCharCode.apply(void 0, nt);
  }, fn = d.__private__.pdfEscape = d.pdfEscape = function(g, E) {
    return Ua(g, E).replace(/\\/g, "\\\\").replace(/\(/g, "\\(").replace(/\)/g, "\\)");
  }, Ds = d.__private__.beginPage = function(g) {
    Ce[++Yt] = [], vt[Yt] = {
      objId: 0,
      contentsObjId: 0,
      userUnit: Number(o),
      artBox: null,
      bleedBox: null,
      cropBox: null,
      trimBox: null,
      mediaBox: {
        bottomLeftX: 0,
        bottomLeftY: 0,
        topRightX: Number(g[0]),
        topRightY: Number(g[1])
      }
    }, Bo(Yt), Te(Ce[L]);
  }, Mo = function(g, E) {
    var J, ne, ue;
    switch (t = E || t, typeof g == "string" && (J = A(g.toLowerCase()), Array.isArray(J) && (ne = J[0], ue = J[1])), Array.isArray(g) && (ne = g[0] * Qe, ue = g[1] * Qe), isNaN(ne) && (ne = i[0], ue = i[1]), (ne > 14400 || ue > 14400) && (Kt.warn("A page in a PDF can not be wider or taller than 14400 userUnit. jsPDF limits the width/height to 14400"), ne = Math.min(14400, ne), ue = Math.min(14400, ue)), i = [ne, ue], t.substr(0, 1)) {
      case "l":
        ue > ne && (i = [ue, ne]);
        break;
      case "p":
        ne > ue && (i = [ue, ne]);
    }
    Ds(i), zo(Ms), Z(Xn), js !== 0 && Z(js + " J"), Us !== 0 && Z(Us + " j"), kt.publish("addPage", {
      pageNumber: Yt
    });
  }, gf = function(g) {
    g > 0 && g <= Yt && (Ce.splice(g, 1), vt.splice(g, 1), Yt--, L > Yt && (L = Yt), this.setPage(L));
  }, Bo = function(g) {
    g > 0 && g <= Yt && (L = g);
  }, vf = d.__private__.getNumberOfPages = d.getNumberOfPages = function() {
    return Ce.length - 1;
  }, jo = function(g, E, J) {
    var ne, ue = void 0;
    return J = J || {}, g = g !== void 0 ? g : Rt[At].fontName, E = E !== void 0 ? E : Rt[At].fontStyle, ne = g.toLowerCase(), Jt[ne] !== void 0 && Jt[ne][E] !== void 0 ? ue = Jt[ne][E] : Jt[g] !== void 0 && Jt[g][E] !== void 0 ? ue = Jt[g][E] : J.disableWarning === false && Kt.warn("Unable to look up font label for font '" + g + "', '" + E + "'. Refer to getFontList() for available fonts."), ue || J.noFallback || (ue = Jt.times[E]) == null && (ue = Jt.times.normal), ue;
  }, mf = d.__private__.putInfo = function() {
    var g = hr(), E = function(ne) {
      return ne;
    };
    for (var J in c !== null && (E = zr.encryptor(g, 0)), Z("<<"), Z("/Producer (" + fn(E("jsPDF " + ut.version)) + ")"), ct) ct.hasOwnProperty(J) && ct[J] && Z("/" + J.substr(0, 1).toUpperCase() + J.substr(1) + " (" + fn(E(ct[J])) + ")");
    Z("/CreationDate (" + fn(E(ce)) + ")"), Z(">>"), Z("endobj");
  }, Os = d.__private__.putCatalog = function(g) {
    var E = (g = g || {}).rootDictionaryObjId || U;
    switch (hr(), Z("<<"), Z("/Type /Catalog"), Z("/Pages " + E + " 0 R"), $e || ($e = "fullwidth"), $e) {
      case "fullwidth":
        Z("/OpenAction [3 0 R /FitH null]");
        break;
      case "fullheight":
        Z("/OpenAction [3 0 R /FitV null]");
        break;
      case "fullpage":
        Z("/OpenAction [3 0 R /Fit]");
        break;
      case "original":
        Z("/OpenAction [3 0 R /XYZ null null 1]");
        break;
      default:
        var J = "" + $e;
        J.substr(J.length - 1) === "%" && ($e = parseInt($e) / 100), typeof $e == "number" && Z("/OpenAction [3 0 R /XYZ null null " + ee($e) + "]");
    }
    switch (_t || (_t = "continuous"), _t) {
      case "continuous":
        Z("/PageLayout /OneColumn");
        break;
      case "single":
        Z("/PageLayout /SinglePage");
        break;
      case "two":
      case "twoleft":
        Z("/PageLayout /TwoColumnLeft");
        break;
      case "tworight":
        Z("/PageLayout /TwoColumnRight");
    }
    ot && Z("/PageMode /" + ot), kt.publish("putCatalog"), Z(">>"), Z("endobj");
  }, xf = d.__private__.putTrailer = function() {
    Z("trailer"), Z("<<"), Z("/Size " + (z + 1)), Z("/Root " + z + " 0 R"), Z("/Info " + (z - 1) + " 0 R"), c !== null && Z("/Encrypt " + zr.oid + " 0 R"), Z("/ID [ <" + we + "> <" + we + "> ]"), Z(">>");
  }, wf = d.__private__.putHeader = function() {
    Z("%PDF-" + w), Z("%ºß¬à");
  }, yf = d.__private__.putXRef = function() {
    var g = "0000000000";
    Z("xref"), Z("0 " + (z + 1)), Z("0000000000 65535 f ");
    for (var E = 1; E <= z; E++) typeof re[E] == "function" ? Z((g + re[E]()).slice(-10) + " 00000 n ") : re[E] !== void 0 ? Z((g + re[E]).slice(-10) + " 00000 n ") : Z("0000000000 00000 n ");
  }, Ai = d.__private__.buildDocument = function() {
    Ye(), Te(se), kt.publish("buildDocument"), wf(), ye(), Io(), Oo(), c !== null && Si(), mf(), Os();
    var g = ie;
    return yf(), xf(), Z("startxref"), Z("" + g), Z("%%EOF"), Te(Ce[L]), se.join(`
`);
  }, qa = d.__private__.getBlob = function(g) {
    return new Blob([rt(g)], {
      type: "application/pdf"
    });
  }, Ha = d.output = d.__private__.output = Gn(function(g, E) {
    switch (typeof (E = E || {}) == "string" ? E = {
      filename: E
    } : E.filename = E.filename || "generated.pdf", g) {
      case void 0:
        return Ai();
      case "save":
        d.save(E.filename);
        break;
      case "arraybuffer":
        return rt(Ai());
      case "blob":
        return qa(Ai());
      case "bloburi":
      case "bloburl":
        if (dt.URL !== void 0 && typeof dt.URL.createObjectURL == "function") return dt.URL && dt.URL.createObjectURL(qa(Ai())) || void 0;
        Kt.warn("bloburl is not supported by your system, because URL.createObjectURL is not supported by your browser.");
        break;
      case "datauristring":
      case "dataurlstring":
        var J = "", ne = Ai();
        try {
          J = El(ne);
        } catch {
          J = El(unescape(encodeURIComponent(ne)));
        }
        return "data:application/pdf;filename=" + E.filename + ";base64," + J;
      case "pdfobjectnewwindow":
        if (Object.prototype.toString.call(dt) === "[object Window]") {
          var ue = "https://cdnjs.cloudflare.com/ajax/libs/pdfobject/2.1.1/pdfobject.min.js", Fe = ' integrity="sha512-4ze/a9/4jqu+tX9dfOqJYSvyYd5M6qum/3HpCLr+/Jqf0whc37VUbkpNGHR7/8pSnCFw47T1fmIpwBV7UySh3g==" crossorigin="anonymous"';
          E.pdfObjectUrl && (ue = E.pdfObjectUrl, Fe = "");
          var je = '<html><style>html, body { padding: 0; margin: 0; } iframe { width: 100%; height: 100%; border: 0;}  </style><body><script src="' + ue + '"' + Fe + '><\/script><script >PDFObject.embed("' + this.output("dataurlstring") + '", ' + JSON.stringify(E) + ");<\/script></body></html>", nt = dt.open();
          return nt !== null && nt.document.write(je), nt;
        }
        throw new Error("The option pdfobjectnewwindow just works in a browser-environment.");
      case "pdfjsnewwindow":
        if (Object.prototype.toString.call(dt) === "[object Window]") {
          var ft = '<html><style>html, body { padding: 0; margin: 0; } iframe { width: 100%; height: 100%; border: 0;}  </style><body><iframe id="pdfViewer" src="' + (E.pdfJsUrl || "examples/PDF.js/web/viewer.html") + "?file=&downloadName=" + E.filename + '" width="500px" height="400px" /></body></html>', yt = dt.open();
          if (yt !== null) {
            yt.document.write(ft);
            var xt = this;
            yt.document.documentElement.querySelector("#pdfViewer").onload = function() {
              yt.document.title = E.filename, yt.document.documentElement.querySelector("#pdfViewer").contentWindow.PDFViewerApplication.open(xt.output("bloburl"));
            };
          }
          return yt;
        }
        throw new Error("The option pdfjsnewwindow just works in a browser-environment.");
      case "dataurlnewwindow":
        if (Object.prototype.toString.call(dt) !== "[object Window]") throw new Error("The option dataurlnewwindow just works in a browser-environment.");
        var Lt = '<html><style>html, body { padding: 0; margin: 0; } iframe { width: 100%; height: 100%; border: 0;}  </style><body><iframe src="' + this.output("datauristring", E) + '"></iframe></body></html>', nr = dt.open();
        if (nr !== null && (nr.document.write(Lt), nr.document.title = E.filename), nr || typeof safari > "u") return nr;
        break;
      case "datauri":
      case "dataurl":
        return dt.document.location.href = this.output("datauristring", E);
      default:
        return null;
    }
  }), Uo = function(g) {
    return Array.isArray(_i) === true && _i.indexOf(g) > -1;
  };
  switch (n) {
    case "pt":
      Qe = 1;
      break;
    case "mm":
      Qe = 72 / 25.4;
      break;
    case "cm":
      Qe = 72 / 2.54;
      break;
    case "in":
      Qe = 72;
      break;
    case "px":
      Qe = Uo("px_scaling") == 1 ? 0.75 : 96 / 72;
      break;
    case "pc":
    case "em":
      Qe = 12;
      break;
    case "ex":
      Qe = 6;
      break;
    default:
      if (typeof n != "number") throw new Error("Invalid unit: " + n);
      Qe = n;
  }
  var zr = null;
  ze(), de();
  var _f = function(g) {
    return c !== null ? zr.encryptor(g, 0) : function(E) {
      return E;
    };
  }, qo = d.__private__.getPageInfo = d.getPageInfo = function(g) {
    if (isNaN(g) || g % 1 != 0) throw new Error("Invalid argument passed to jsPDF.getPageInfo");
    return {
      objId: vt[g].objId,
      pageNumber: g,
      pageContext: vt[g]
    };
  }, mt = d.__private__.getPageInfoByObjId = function(g) {
    if (isNaN(g) || g % 1 != 0) throw new Error("Invalid argument passed to jsPDF.getPageInfoByObjId");
    for (var E in vt) if (vt[E].objId === g) break;
    return qo(E);
  }, Sf = d.__private__.getCurrentPageInfo = d.getCurrentPageInfo = function() {
    return {
      objId: vt[L].objId,
      pageNumber: L,
      pageContext: vt[L]
    };
  };
  d.addPage = function() {
    return Mo.apply(this, arguments), this;
  }, d.setPage = function() {
    return Bo.apply(this, arguments), Te.call(this, Ce[L]), this;
  }, d.insertPage = function(g) {
    return this.addPage(), this.movePage(L, g), this;
  }, d.movePage = function(g, E) {
    var J, ne;
    if (g > E) {
      J = Ce[g], ne = vt[g];
      for (var ue = g; ue > E; ue--) Ce[ue] = Ce[ue - 1], vt[ue] = vt[ue - 1];
      Ce[E] = J, vt[E] = ne, this.setPage(E);
    } else if (g < E) {
      J = Ce[g], ne = vt[g];
      for (var Fe = g; Fe < E; Fe++) Ce[Fe] = Ce[Fe + 1], vt[Fe] = vt[Fe + 1];
      Ce[E] = J, vt[E] = ne, this.setPage(E);
    }
    return this;
  }, d.deletePage = function() {
    return gf.apply(this, arguments), this;
  }, d.__private__.text = d.text = function(g, E, J, ne, ue) {
    var Fe, je, nt, ft, yt, xt, Lt, nr, ar, xr = (ne = ne || {}).scope || this;
    if (typeof g == "number" && typeof E == "number" && (typeof J == "string" || Array.isArray(J))) {
      var Vr = J;
      J = E, E = g, g = Vr;
    }
    if (arguments[3] instanceof lt ? (M("The transform parameter of text() with a Matrix value"), ar = ue) : (nt = arguments[4], ft = arguments[5], Wt(Lt = arguments[3]) === "object" && Lt !== null || (typeof nt == "string" && (ft = nt, nt = null), typeof Lt == "string" && (ft = Lt, Lt = null), typeof Lt == "number" && (nt = Lt, Lt = null), ne = {
      flags: Lt,
      angle: nt,
      align: ft
    })), isNaN(E) || isNaN(J) || g == null) throw new Error("Invalid arguments passed to jsPDF.text");
    if (g.length === 0) return xr;
    var Fr = "", Yn = false, yn = typeof ne.lineHeightFactor == "number" ? ne.lineHeightFactor : va, ui = xr.internal.scaleFactor;
    function Ko(Zt) {
      return Zt = Zt.split("	").join(Array(ne.TabLen || 9).join(" ")), fn(Zt, Lt);
    }
    function Vs(Zt) {
      for (var Qt, dr = Zt.concat(), Er = [], Fi = dr.length; Fi--; ) typeof (Qt = dr.shift()) == "string" ? Er.push(Qt) : Array.isArray(Zt) && (Qt.length === 1 || Qt[1] === void 0 && Qt[2] === void 0) ? Er.push(Qt[0]) : Er.push([Qt[0], Qt[1], Qt[2]]);
      return Er;
    }
    function Gs(Zt, Qt) {
      var dr;
      if (typeof Zt == "string") dr = Qt(Zt)[0];
      else if (Array.isArray(Zt)) {
        for (var Er, Fi, eo = Zt.concat(), ns = [], t0 = eo.length; t0--; ) typeof (Er = eo.shift()) == "string" ? ns.push(Qt(Er)[0]) : Array.isArray(Er) && typeof Er[0] == "string" && (Fi = Qt(Er[0], Er[1], Er[2]), ns.push([Fi[0], Fi[1], Fi[2]]));
        dr = ns;
      }
      return dr;
    }
    var Ya = false, Xs = true;
    if (typeof g == "string") Ya = true;
    else if (Array.isArray(g)) {
      var Ys = g.concat();
      je = [];
      for (var $a, Ir = Ys.length; Ir--; ) (typeof ($a = Ys.shift()) != "string" || Array.isArray($a) && typeof $a[0] != "string") && (Xs = false);
      Ya = Xs;
    }
    if (Ya === false) throw new Error('Type of text must be string or Array. "' + g + '" is not recognized.');
    typeof g == "string" && (g = g.match(/[\r?\n]/) ? g.split(/\r\n|\r|\n/g) : [g]);
    var Ka = We / xr.internal.scaleFactor, Ja = Ka * (yn - 1);
    switch (ne.baseline) {
      case "bottom":
        J -= Ja;
        break;
      case "top":
        J += Ka - Ja;
        break;
      case "hanging":
        J += Ka - 2 * Ja;
        break;
      case "middle":
        J += Ka / 2 - Ja;
    }
    if ((xt = ne.maxWidth || 0) > 0 && (typeof g == "string" ? g = xr.splitTextToSize(g, xt) : Object.prototype.toString.call(g) === "[object Array]" && (g = g.reduce(function(Zt, Qt) {
      return Zt.concat(xr.splitTextToSize(Qt, xt));
    }, []))), Fe = {
      text: g,
      x: E,
      y: J,
      options: ne,
      mutex: {
        pdfEscape: fn,
        activeFontKey: At,
        fonts: Rt,
        activeFontSize: We
      }
    }, kt.publish("preProcessText", Fe), g = Fe.text, nt = (ne = Fe.options).angle, !(ar instanceof lt) && nt && typeof nt == "number") {
      nt *= Math.PI / 180, ne.rotationDirection === 0 && (nt = -nt), O === b.ADVANCED && (nt = -nt);
      var Za = Math.cos(nt), $s = Math.sin(nt);
      ar = new lt(Za, $s, -$s, Za, 0, 0);
    } else nt && nt instanceof lt && (ar = nt);
    O !== b.ADVANCED || ar || (ar = on), (yt = ne.charSpace || Va) !== void 0 && (Fr += j(P(yt)) + ` Tc
`, this.setCharSpace(this.getCharSpace() || 0)), (nr = ne.horizontalScale) !== void 0 && (Fr += j(100 * nr) + ` Tz
`), ne.lang;
    var ln = -1, kf = ne.renderingMode !== void 0 ? ne.renderingMode : ne.stroke, Ks = xr.internal.getCurrentPageInfo().pageContext;
    switch (kf) {
      case 0:
      case false:
      case "fill":
        ln = 0;
        break;
      case 1:
      case true:
      case "stroke":
        ln = 1;
        break;
      case 2:
      case "fillThenStroke":
        ln = 2;
        break;
      case 3:
      case "invisible":
        ln = 3;
        break;
      case 4:
      case "fillAndAddForClipping":
        ln = 4;
        break;
      case 5:
      case "strokeAndAddPathForClipping":
        ln = 5;
        break;
      case 6:
      case "fillThenStrokeAndAddToPathForClipping":
        ln = 6;
        break;
      case 7:
      case "addToPathForClipping":
        ln = 7;
    }
    var Jo = Ks.usedRenderingMode !== void 0 ? Ks.usedRenderingMode : -1;
    ln !== -1 ? Fr += ln + ` Tr
` : Jo !== -1 && (Fr += `0 Tr
`), ln !== -1 && (Ks.usedRenderingMode = ln), ft = ne.align || "left";
    var Dn, Qa = We * yn, Zo = xr.internal.pageSize.getWidth(), Qo = Rt[At];
    yt = ne.charSpace || Va, xt = ne.maxWidth || 0, Lt = Object.assign({
      autoencode: true,
      noBOM: true
    }, ne.flags);
    var Gi = [], wa = function(Zt) {
      return xr.getStringUnitWidth(Zt, {
        font: Qo,
        charSpace: yt,
        fontSize: We,
        doKerning: false
      }) * We / ui;
    };
    if (Object.prototype.toString.call(g) === "[object Array]") {
      var hn;
      je = Vs(g), ft !== "left" && (Dn = je.map(wa));
      var Qr, Xi = 0;
      if (ft === "right") {
        E -= Dn[0], g = [], Ir = je.length;
        for (var Ti = 0; Ti < Ir; Ti++) Ti === 0 ? (Qr = ci(E), hn = bi(J)) : (Qr = P(Xi - Dn[Ti]), hn = -Qa), g.push([je[Ti], Qr, hn]), Xi = Dn[Ti];
      } else if (ft === "center") {
        E -= Dn[0] / 2, g = [], Ir = je.length;
        for (var Ei = 0; Ei < Ir; Ei++) Ei === 0 ? (Qr = ci(E), hn = bi(J)) : (Qr = P((Xi - Dn[Ei]) / 2), hn = -Qa), g.push([je[Ei], Qr, hn]), Xi = Dn[Ei];
      } else if (ft === "left") {
        g = [], Ir = je.length;
        for (var es = 0; es < Ir; es++) g.push(je[es]);
      } else if (ft === "justify" && Qo.encoding === "Identity-H") {
        g = [], Ir = je.length, xt = xt !== 0 ? xt : Zo;
        for (var Ni = 0, ur = 0; ur < Ir; ur++) if (hn = ur === 0 ? bi(J) : -Qa, Qr = ur === 0 ? ci(E) : Ni, ur < Ir - 1) {
          var Js = P((xt - Dn[ur]) / (je[ur].split(" ").length - 1)), en = je[ur].split(" ");
          g.push([en[0] + " ", Qr, hn]), Ni = 0;
          for (var On = 1; On < en.length; On++) {
            var ts = (wa(en[On - 1] + " " + en[On]) - wa(en[On])) * ui + Js;
            On == en.length - 1 ? g.push([en[On], ts, 0]) : g.push([en[On] + " ", ts, 0]), Ni -= ts;
          }
        } else g.push([je[ur], Qr, hn]);
        g.push(["", Ni, 0]);
      } else {
        if (ft !== "justify") throw new Error('Unrecognized alignment option, use "left", "center", "right" or "justify".');
        for (g = [], Ir = je.length, xt = xt !== 0 ? xt : Zo, ur = 0; ur < Ir; ur++) hn = ur === 0 ? bi(J) : -Qa, Qr = ur === 0 ? ci(E) : 0, ur < Ir - 1 ? Gi.push(j(P((xt - Dn[ur]) / (je[ur].split(" ").length - 1)))) : Gi.push(0), g.push([je[ur], Qr, hn]);
      }
    }
    var e0 = typeof ne.R2L == "boolean" ? ne.R2L : st;
    e0 === true && (g = Gs(g, function(Zt, Qt, dr) {
      return [Zt.split("").reverse().join(""), Qt, dr];
    })), Fe = {
      text: g,
      x: E,
      y: J,
      options: ne,
      mutex: {
        pdfEscape: fn,
        activeFontKey: At,
        fonts: Rt,
        activeFontSize: We
      }
    }, kt.publish("postProcessText", Fe), g = Fe.text, Yn = Fe.mutex.isHex || false;
    var Zs = Rt[At].encoding;
    Zs !== "WinAnsiEncoding" && Zs !== "StandardEncoding" || (g = Gs(g, function(Zt, Qt, dr) {
      return [Ko(Zt), Qt, dr];
    })), je = Vs(g), g = [];
    for (var ya, _a, Yi, Sa = 0, rs = 1, Aa = Array.isArray(je[0]) ? rs : Sa, $i = "", Qs = function(Zt, Qt, dr) {
      var Er = "";
      return dr instanceof lt ? (dr = typeof ne.angle == "number" ? xn(dr, new lt(1, 0, 0, 1, Zt, Qt)) : xn(new lt(1, 0, 0, 1, Zt, Qt), dr), O === b.ADVANCED && (dr = xn(new lt(1, 0, 0, -1, 0, 0), dr)), Er = dr.join(" ") + ` Tm
`) : Er = j(Zt) + " " + j(Qt) + ` Td
`, Er;
    }, In = 0; In < je.length; In++) {
      switch ($i = "", Aa) {
        case rs:
          Yi = (Yn ? "<" : "(") + je[In][0] + (Yn ? ">" : ")"), ya = parseFloat(je[In][1]), _a = parseFloat(je[In][2]);
          break;
        case Sa:
          Yi = (Yn ? "<" : "(") + je[In] + (Yn ? ">" : ")"), ya = ci(E), _a = bi(J);
      }
      Gi !== void 0 && Gi[In] !== void 0 && ($i = Gi[In] + ` Tw
`), In === 0 ? g.push($i + Qs(ya, _a, ar) + Yi) : Aa === Sa ? g.push($i + Yi) : Aa === rs && g.push($i + Qs(ya, _a, ar) + Yi);
    }
    g = Aa === Sa ? g.join(` Tj
T* `) : g.join(` Tj
`), g += ` Tj
`;
    var Rn = `BT
/`;
    return Rn += At + " " + We + ` Tf
`, Rn += j(We * yn) + ` TL
`, Rn += ma + `
`, Rn += Fr, Rn += g, Z(Rn += "ET"), v[At] = true, xr;
  };
  var Af = d.__private__.clip = d.clip = function(g) {
    return Z(g === "evenodd" ? "W*" : "W"), this;
  };
  d.clipEvenOdd = function() {
    return Af("evenodd");
  }, d.__private__.discardPath = d.discardPath = function() {
    return Z("n"), this;
  };
  var hi = d.__private__.isValidStyle = function(g) {
    var E = false;
    return [void 0, null, "S", "D", "F", "DF", "FD", "f", "f*", "B", "B*", "n"].indexOf(g) !== -1 && (E = true), E;
  };
  d.__private__.setDefaultPathOperation = d.setDefaultPathOperation = function(g) {
    return hi(g) && (h = g), this;
  };
  var Ho = d.__private__.getStyle = d.getStyle = function(g) {
    var E = h;
    switch (g) {
      case "D":
      case "S":
        E = "S";
        break;
      case "F":
        E = "f";
        break;
      case "FD":
      case "DF":
        E = "B";
        break;
      case "f":
      case "f*":
      case "B":
      case "B*":
        E = g;
    }
    return E;
  }, Wo = d.close = function() {
    return Z("h"), this;
  };
  d.stroke = function() {
    return Z("S"), this;
  }, d.fill = function(g) {
    return Wa("f", g), this;
  }, d.fillEvenOdd = function(g) {
    return Wa("f*", g), this;
  }, d.fillStroke = function(g) {
    return Wa("B", g), this;
  }, d.fillStrokeEvenOdd = function(g) {
    return Wa("B*", g), this;
  };
  var Wa = function(g, E) {
    Wt(E) === "object" ? Tf(E, g) : Z(g);
  }, Is = function(g) {
    g === null || O === b.ADVANCED && g === void 0 || (g = Ho(g), Z(g));
  };
  function bf(g, E, J, ne, ue) {
    var Fe = new ms(E || this.boundingBox, J || this.xStep, ne || this.yStep, this.gState, ue || this.matrix);
    Fe.stream = this.stream;
    var je = g + "$$" + this.cloneIndex++ + "$$";
    return Wr(je, Fe), Fe;
  }
  var Tf = function(g, E) {
    var J = oi[g.key], ne = Ct[J];
    if (ne instanceof Fa) Z("q"), Z(Ef(E)), ne.gState && d.setGState(ne.gState), Z(g.matrix.toString() + " cm"), Z("/" + J + " sh"), Z("Q");
    else if (ne instanceof ms) {
      var ue = new lt(1, 0, 0, -1, 0, Vi());
      g.matrix && (ue = ue.multiply(g.matrix || on), J = bf.call(ne, g.key, g.boundingBox, g.xStep, g.yStep, ue).id), Z("q"), Z("/Pattern cs"), Z("/" + J + " scn"), ne.gState && d.setGState(ne.gState), Z(E), Z("Q");
    }
  }, Ef = function(g) {
    switch (g) {
      case "f":
      case "F":
        return "W n";
      case "f*":
        return "W* n";
      case "B":
        return "W S";
      case "B*":
        return "W* S";
      case "S":
        return "W S";
      case "n":
        return "W n";
    }
  }, Rs = d.moveTo = function(g, E) {
    return Z(j(P(g)) + " " + j(Q(E)) + " m"), this;
  }, ga = d.lineTo = function(g, E) {
    return Z(j(P(g)) + " " + j(Q(E)) + " l"), this;
  }, Wi = d.curveTo = function(g, E, J, ne, ue, Fe) {
    return Z([j(P(g)), j(Q(E)), j(P(J)), j(Q(ne)), j(P(ue)), j(Q(Fe)), "c"].join(" ")), this;
  };
  d.__private__.line = d.line = function(g, E, J, ne, ue) {
    if (isNaN(g) || isNaN(E) || isNaN(J) || isNaN(ne) || !hi(ue)) throw new Error("Invalid arguments passed to jsPDF.line");
    return O === b.COMPAT ? this.lines([[J - g, ne - E]], g, E, [1, 1], ue || "S") : this.lines([[J - g, ne - E]], g, E, [1, 1]).stroke();
  }, d.__private__.lines = d.lines = function(g, E, J, ne, ue, Fe) {
    var je, nt, ft, yt, xt, Lt, nr, ar, xr, Vr, Fr, Yn;
    if (typeof g == "number" && (Yn = J, J = E, E = g, g = Yn), ne = ne || [1, 1], Fe = Fe || false, isNaN(E) || isNaN(J) || !Array.isArray(g) || !Array.isArray(ne) || !hi(ue) || typeof Fe != "boolean") throw new Error("Invalid arguments passed to jsPDF.lines");
    for (Rs(E, J), je = ne[0], nt = ne[1], yt = g.length, Vr = E, Fr = J, ft = 0; ft < yt; ft++) (xt = g[ft]).length === 2 ? (Vr = xt[0] * je + Vr, Fr = xt[1] * nt + Fr, ga(Vr, Fr)) : (Lt = xt[0] * je + Vr, nr = xt[1] * nt + Fr, ar = xt[2] * je + Vr, xr = xt[3] * nt + Fr, Vr = xt[4] * je + Vr, Fr = xt[5] * nt + Fr, Wi(Lt, nr, ar, xr, Vr, Fr));
    return Fe && Wo(), Is(ue), this;
  }, d.path = function(g) {
    for (var E = 0; E < g.length; E++) {
      var J = g[E], ne = J.c;
      switch (J.op) {
        case "m":
          Rs(ne[0], ne[1]);
          break;
        case "l":
          ga(ne[0], ne[1]);
          break;
        case "c":
          Wi.apply(this, ne);
          break;
        case "h":
          Wo();
      }
    }
    return this;
  }, d.__private__.rect = d.rect = function(g, E, J, ne, ue) {
    if (isNaN(g) || isNaN(E) || isNaN(J) || isNaN(ne) || !hi(ue)) throw new Error("Invalid arguments passed to jsPDF.rect");
    return O === b.COMPAT && (ne = -ne), Z([j(P(g)), j(Q(E)), j(P(J)), j(P(ne)), "re"].join(" ")), Is(ue), this;
  }, d.__private__.triangle = d.triangle = function(g, E, J, ne, ue, Fe, je) {
    if (isNaN(g) || isNaN(E) || isNaN(J) || isNaN(ne) || isNaN(ue) || isNaN(Fe) || !hi(je)) throw new Error("Invalid arguments passed to jsPDF.triangle");
    return this.lines([[J - g, ne - E], [ue - J, Fe - ne], [g - ue, E - Fe]], g, E, [1, 1], je, true), this;
  }, d.__private__.roundedRect = d.roundedRect = function(g, E, J, ne, ue, Fe, je) {
    if (isNaN(g) || isNaN(E) || isNaN(J) || isNaN(ne) || isNaN(ue) || isNaN(Fe) || !hi(je)) throw new Error("Invalid arguments passed to jsPDF.roundedRect");
    var nt = 4 / 3 * (Math.SQRT2 - 1);
    return ue = Math.min(ue, 0.5 * J), Fe = Math.min(Fe, 0.5 * ne), this.lines([[J - 2 * ue, 0], [ue * nt, 0, ue, Fe - Fe * nt, ue, Fe], [0, ne - 2 * Fe], [0, Fe * nt, -ue * nt, Fe, -ue, Fe], [2 * ue - J, 0], [-ue * nt, 0, -ue, -Fe * nt, -ue, -Fe], [0, 2 * Fe - ne], [0, -Fe * nt, ue * nt, -Fe, ue, -Fe]], g + ue, E, [1, 1], je, true), this;
  }, d.__private__.ellipse = d.ellipse = function(g, E, J, ne, ue) {
    if (isNaN(g) || isNaN(E) || isNaN(J) || isNaN(ne) || !hi(ue)) throw new Error("Invalid arguments passed to jsPDF.ellipse");
    var Fe = 4 / 3 * (Math.SQRT2 - 1) * J, je = 4 / 3 * (Math.SQRT2 - 1) * ne;
    return Rs(g + J, E), Wi(g + J, E - je, g + Fe, E - ne, g, E - ne), Wi(g - Fe, E - ne, g - J, E - je, g - J, E), Wi(g - J, E + je, g - Fe, E + ne, g, E + ne), Wi(g + Fe, E + ne, g + J, E + je, g + J, E), Is(ue), this;
  }, d.__private__.circle = d.circle = function(g, E, J, ne) {
    if (isNaN(g) || isNaN(E) || isNaN(J) || !hi(ne)) throw new Error("Invalid arguments passed to jsPDF.circle");
    return this.ellipse(g, E, J, J, ne);
  }, d.setFont = function(g, E, J) {
    return J && (E = le(E, J)), At = jo(g, E, {
      disableWarning: false
    }), this;
  };
  var Nf = d.__private__.getFont = d.getFont = function() {
    return Rt[jo.apply(d, arguments)];
  };
  d.__private__.getFontList = d.getFontList = function() {
    var g, E, J = {};
    for (g in Jt) if (Jt.hasOwnProperty(g)) for (E in J[g] = [], Jt[g]) Jt[g].hasOwnProperty(E) && J[g].push(E);
    return J;
  }, d.addFont = function(g, E, J, ne, ue) {
    var Fe = ["StandardEncoding", "MacRomanEncoding", "Identity-H", "WinAnsiEncoding"];
    return arguments[3] && Fe.indexOf(arguments[3]) !== -1 ? ue = arguments[3] : arguments[3] && Fe.indexOf(arguments[3]) == -1 && (J = le(J, ne)), ue = ue || "Identity-H", ks.call(this, g, E, J, ue);
  };
  var va, Ms = r6.lineWidth || 0.200025, za = d.__private__.getLineWidth = d.getLineWidth = function() {
    return Ms;
  }, zo = d.__private__.setLineWidth = d.setLineWidth = function(g) {
    return Ms = g, Z(j(P(g)) + " w"), this;
  };
  d.__private__.setLineDash = ut.API.setLineDash = ut.API.setLineDashPattern = function(g, E) {
    if (g = g || [], E = E || 0, isNaN(E) || !Array.isArray(g)) throw new Error("Invalid arguments passed to jsPDF.setLineDash");
    return g = g.map(function(J) {
      return j(P(J));
    }).join(" "), E = j(P(E)), Z("[" + g + "] " + E + " d"), this;
  };
  var Vo = d.__private__.getLineHeight = d.getLineHeight = function() {
    return We * va;
  };
  d.__private__.getLineHeight = d.getLineHeight = function() {
    return We * va;
  };
  var Go = d.__private__.setLineHeightFactor = d.setLineHeightFactor = function(g) {
    return typeof (g = g || 1.15) == "number" && (va = g), this;
  }, Xo = d.__private__.getLineHeightFactor = d.getLineHeightFactor = function() {
    return va;
  };
  Go(r6.lineHeight);
  var ci = d.__private__.getHorizontalCoordinate = function(g) {
    return P(g);
  }, bi = d.__private__.getVerticalCoordinate = function(g) {
    return O === b.ADVANCED ? g : vt[L].mediaBox.topRightY - vt[L].mediaBox.bottomLeftY - P(g);
  }, Ff = d.__private__.getHorizontalCoordinateString = d.getHorizontalCoordinateString = function(g) {
    return j(ci(g));
  }, zi = d.__private__.getVerticalCoordinateString = d.getVerticalCoordinateString = function(g) {
    return j(bi(g));
  }, Xn = r6.strokeColor || "0 G";
  d.__private__.getStrokeColor = d.getDrawColor = function() {
    return G(Xn);
  }, d.__private__.setStrokeColor = d.setDrawColor = function(g, E, J, ne) {
    return Xn = K({
      ch1: g,
      ch2: E,
      ch3: J,
      ch4: ne,
      pdfColorType: "draw",
      precision: 2
    }), Z(Xn), this;
  };
  var Bs = r6.fillColor || "0 g";
  d.__private__.getFillColor = d.getFillColor = function() {
    return G(Bs);
  }, d.__private__.setFillColor = d.setFillColor = function(g, E, J, ne) {
    return Bs = K({
      ch1: g,
      ch2: E,
      ch3: J,
      ch4: ne,
      pdfColorType: "fill",
      precision: 2
    }), Z(Bs), this;
  };
  var ma = r6.textColor || "0 g", Lf = d.__private__.getTextColor = d.getTextColor = function() {
    return G(ma);
  };
  d.__private__.setTextColor = d.setTextColor = function(g, E, J, ne) {
    return ma = K({
      ch1: g,
      ch2: E,
      ch3: J,
      ch4: ne,
      pdfColorType: "text",
      precision: 3
    }), this;
  };
  var Va = r6.charSpace, Cf = d.__private__.getCharSpace = d.getCharSpace = function() {
    return parseFloat(Va || 0);
  };
  d.__private__.setCharSpace = d.setCharSpace = function(g) {
    if (isNaN(g)) throw new Error("Invalid argument passed to jsPDF.setCharSpace");
    return Va = g, this;
  };
  var js = 0;
  d.CapJoinStyles = {
    0: 0,
    butt: 0,
    but: 0,
    miter: 0,
    1: 1,
    round: 1,
    rounded: 1,
    circle: 1,
    2: 2,
    projecting: 2,
    project: 2,
    square: 2,
    bevel: 2
  }, d.__private__.setLineCap = d.setLineCap = function(g) {
    var E = d.CapJoinStyles[g];
    if (E === void 0) throw new Error("Line cap style of '" + g + "' is not recognized. See or extend .CapJoinStyles property for valid styles");
    return js = E, Z(E + " J"), this;
  };
  var Us = 0;
  d.__private__.setLineJoin = d.setLineJoin = function(g) {
    var E = d.CapJoinStyles[g];
    if (E === void 0) throw new Error("Line join style of '" + g + "' is not recognized. See or extend .CapJoinStyles property for valid styles");
    return Us = E, Z(E + " j"), this;
  }, d.__private__.setLineMiterLimit = d.__private__.setMiterLimit = d.setLineMiterLimit = d.setMiterLimit = function(g) {
    if (g = g || 0, isNaN(g)) throw new Error("Invalid argument passed to jsPDF.setLineMiterLimit");
    return Z(j(P(g)) + " M"), this;
  }, d.GState = J0, d.setGState = function(g) {
    (g = typeof g == "string" ? er[mn[g]] : Yo(null, g)).equals(Wn) || (Z("/" + g.id + " gs"), Wn = g);
  };
  var Yo = function(g, E) {
    if (!g || !mn[g]) {
      var J = false;
      for (var ne in er) if (er.hasOwnProperty(ne) && er[ne].equals(E)) {
        J = true;
        break;
      }
      if (J) E = er[ne];
      else {
        var ue = "GS" + (Object.keys(er).length + 1).toString(10);
        er[ue] = E, E.id = ue;
      }
      return g && (mn[g] = E.id), kt.publish("addGState", E), E;
    }
  };
  d.addGState = function(g, E) {
    return Yo(g, E), this;
  }, d.saveGraphicsState = function() {
    return Z("q"), Cn.push({
      key: At,
      size: We,
      color: ma
    }), this;
  }, d.restoreGraphicsState = function() {
    Z("Q");
    var g = Cn.pop();
    return At = g.key, We = g.size, ma = g.color, Wn = null, this;
  }, d.setCurrentTransformationMatrix = function(g) {
    return Z(g.toString() + " cm"), this;
  }, d.comment = function(g) {
    return Z("#" + g), this;
  };
  var Ga = function(g, E) {
    var J = g || 0;
    Object.defineProperty(this, "x", {
      enumerable: true,
      get: function() {
        return J;
      },
      set: function(Fe) {
        isNaN(Fe) || (J = parseFloat(Fe));
      }
    });
    var ne = E || 0;
    Object.defineProperty(this, "y", {
      enumerable: true,
      get: function() {
        return ne;
      },
      set: function(Fe) {
        isNaN(Fe) || (ne = parseFloat(Fe));
      }
    });
    var ue = "pt";
    return Object.defineProperty(this, "type", {
      enumerable: true,
      get: function() {
        return ue;
      },
      set: function(Fe) {
        ue = Fe.toString();
      }
    }), this;
  }, qs = function(g, E, J, ne) {
    Ga.call(this, g, E), this.type = "rect";
    var ue = J || 0;
    Object.defineProperty(this, "w", {
      enumerable: true,
      get: function() {
        return ue;
      },
      set: function(je) {
        isNaN(je) || (ue = parseFloat(je));
      }
    });
    var Fe = ne || 0;
    return Object.defineProperty(this, "h", {
      enumerable: true,
      get: function() {
        return Fe;
      },
      set: function(je) {
        isNaN(je) || (Fe = parseFloat(je));
      }
    }), this;
  }, Hs = function() {
    this.page = Yt, this.currentPage = L, this.pages = Ce.slice(0), this.pagesContext = vt.slice(0), this.x = br, this.y = Ft, this.matrix = sn, this.width = xa(L), this.height = Vi(L), this.outputDestination = qe, this.id = "", this.objectNumber = -1;
  };
  Hs.prototype.restore = function() {
    Yt = this.page, L = this.currentPage, vt = this.pagesContext, Ce = this.pages, br = this.x, Ft = this.y, sn = this.matrix, Ws(L, this.width), zs(L, this.height), qe = this.outputDestination;
  };
  var $o = function(g, E, J, ne, ue) {
    kn.push(new Hs()), Yt = L = 0, Ce = [], br = g, Ft = E, sn = ue, Ds([J, ne]);
  }, Pf = function(g) {
    if (Pn[g]) kn.pop().restore();
    else {
      var E = new Hs(), J = "Xo" + (Object.keys(Tr).length + 1).toString(10);
      E.id = J, Pn[g] = J, Tr[J] = E, kt.publish("addFormObject", E), kn.pop().restore();
    }
  };
  for (var Xa in d.beginFormObject = function(g, E, J, ne, ue) {
    return $o(g, E, J, ne, ue), this;
  }, d.endFormObject = function(g) {
    return Pf(g), this;
  }, d.doFormObject = function(g, E) {
    var J = Tr[Pn[g]];
    return Z("q"), Z(E.toString() + " cm"), Z("/" + J.id + " Do"), Z("Q"), this;
  }, d.getFormObject = function(g) {
    var E = Tr[Pn[g]];
    return {
      x: E.x,
      y: E.y,
      width: E.width,
      height: E.height,
      matrix: E.matrix
    };
  }, d.save = function(g, E) {
    return g = g || "generated.pdf", (E = E || {}).returnPromise = E.returnPromise || false, E.returnPromise === false ? (Ta(qa(Ai()), g), typeof Ta.unload == "function" && dt.setTimeout && setTimeout(Ta.unload, 911), this) : new Promise(function(J, ne) {
      try {
        var ue = Ta(qa(Ai()), g);
        typeof Ta.unload == "function" && dt.setTimeout && setTimeout(Ta.unload, 911), J(ue);
      } catch (Fe) {
        ne(Fe.message);
      }
    });
  }, ut.API) ut.API.hasOwnProperty(Xa) && (Xa === "events" && ut.API.events.length ? function(g, E) {
    var J, ne, ue;
    for (ue = E.length - 1; ue !== -1; ue--) J = E[ue][0], ne = E[ue][1], g.subscribe.apply(g, [J].concat(typeof ne == "function" ? [ne] : ne));
  }(kt, ut.API.events) : d[Xa] = ut.API[Xa]);
  var xa = d.getPageWidth = function(g) {
    return (vt[g = g || L].mediaBox.topRightX - vt[g].mediaBox.bottomLeftX) / Qe;
  }, Ws = d.setPageWidth = function(g, E) {
    vt[g].mediaBox.topRightX = E * Qe + vt[g].mediaBox.bottomLeftX;
  }, Vi = d.getPageHeight = function(g) {
    return (vt[g = g || L].mediaBox.topRightY - vt[g].mediaBox.bottomLeftY) / Qe;
  }, zs = d.setPageHeight = function(g, E) {
    vt[g].mediaBox.topRightY = E * Qe + vt[g].mediaBox.bottomLeftY;
  };
  return d.internal = {
    pdfEscape: fn,
    getStyle: Ho,
    getFont: Nf,
    getFontSize: Je,
    getCharSpace: Cf,
    getTextColor: Lf,
    getLineHeight: Vo,
    getLineHeightFactor: Xo,
    getLineWidth: za,
    write: Ie,
    getHorizontalCoordinate: ci,
    getVerticalCoordinate: bi,
    getCoordinateString: Ff,
    getVerticalCoordinateString: zi,
    collections: {},
    newObject: hr,
    newAdditionalObject: X,
    newObjectDeferred: ir,
    newObjectDeferredBegin: D,
    getFilters: ge,
    putStream: Ee,
    events: kt,
    scaleFactor: Qe,
    pageSize: {
      getWidth: function() {
        return xa(L);
      },
      setWidth: function(g) {
        Ws(L, g);
      },
      getHeight: function() {
        return Vi(L);
      },
      setHeight: function(g) {
        zs(L, g);
      }
    },
    encryptionOptions: c,
    encryption: zr,
    getEncryptor: _f,
    output: Ha,
    getNumberOfPages: vf,
    pages: Ce,
    out: Z,
    f2: ee,
    f3: F,
    getPageInfo: qo,
    getPageInfoByObjId: mt,
    getCurrentPageInfo: Sf,
    getPDFVersion: x,
    Point: Ga,
    Rectangle: qs,
    Matrix: lt,
    hasHotfix: Uo
  }, Object.defineProperty(d.internal.pageSize, "width", {
    get: function() {
      return xa(L);
    },
    set: function(g) {
      Ws(L, g);
    },
    enumerable: true,
    configurable: true
  }), Object.defineProperty(d.internal.pageSize, "height", {
    get: function() {
      return Vi(L);
    },
    set: function(g) {
      zs(L, g);
    },
    enumerable: true,
    configurable: true
  }), pf.call(d, Be), At = "F1", Mo(i, t), kt.publish("initialized"), d;
}
ps.prototype.lsbFirstWord = function(r6) {
  return String.fromCharCode(r6 >> 0 & 255, r6 >> 8 & 255, r6 >> 16 & 255, r6 >> 24 & 255);
}, ps.prototype.toHexString = function(r6) {
  return r6.split("").map(function(e) {
    return ("0" + (255 & e.charCodeAt(0)).toString(16)).slice(-2);
  }).join("");
}, ps.prototype.hexToBytes = function(r6) {
  for (var e = [], t = 0; t < r6.length; t += 2) e.push(String.fromCharCode(parseInt(r6.substr(t, 2), 16)));
  return e.join("");
}, ps.prototype.processOwnerPassword = function(r6, e) {
  return Fl(Nl(e).substr(0, 5), r6);
}, ps.prototype.encryptor = function(r6, e) {
  var t = Nl(this.encryptionKey + String.fromCharCode(255 & r6, r6 >> 8 & 255, r6 >> 16 & 255, 255 & e, e >> 8 & 255)).substr(0, 10);
  return function(n) {
    return Fl(t, n);
  };
}, J0.prototype.equals = function(r6) {
  var e, t = "id,objectNumber,equals";
  if (!r6 || Wt(r6) !== Wt(this)) return false;
  var n = 0;
  for (e in this) if (!(t.indexOf(e) >= 0)) {
    if (this.hasOwnProperty(e) && !r6.hasOwnProperty(e) || this[e] !== r6[e]) return false;
    n++;
  }
  for (e in r6) r6.hasOwnProperty(e) && t.indexOf(e) < 0 && n--;
  return n === 0;
}, ut.API = {
  events: []
}, ut.version = "3.0.1";
var or = ut.API;
var ih = 1;
var ja = function(r6) {
  return r6.replace(/\\/g, "\\\\").replace(/\(/g, "\\(").replace(/\)/g, "\\)");
};
var cs = function(r6) {
  return r6.replace(/\\\\/g, "\\").replace(/\\\(/g, "(").replace(/\\\)/g, ")");
};
var wt = function(r6) {
  return r6.toFixed(2);
};
var aa = function(r6) {
  return r6.toFixed(5);
};
or.__acroform__ = {};
var vn = function(r6, e) {
  r6.prototype = Object.create(e.prototype), r6.prototype.constructor = r6;
};
var Fc = function(r6) {
  return r6 * ih;
};
var vi = function(r6) {
  var e = new H1(), t = at.internal.getHeight(r6) || 0, n = at.internal.getWidth(r6) || 0;
  return e.BBox = [0, 0, Number(wt(n)), Number(wt(t))], e;
};
var a3 = or.__acroform__.setBit = function(r6, e) {
  if (r6 = r6 || 0, e = e || 0, isNaN(r6) || isNaN(e)) throw new Error("Invalid arguments passed to jsPDF.API.__acroform__.setBit");
  return r6 |= 1 << e;
};
var s3 = or.__acroform__.clearBit = function(r6, e) {
  if (r6 = r6 || 0, e = e || 0, isNaN(r6) || isNaN(e)) throw new Error("Invalid arguments passed to jsPDF.API.__acroform__.clearBit");
  return r6 &= ~(1 << e);
};
var o3 = or.__acroform__.getBit = function(r6, e) {
  if (isNaN(r6) || isNaN(e)) throw new Error("Invalid arguments passed to jsPDF.API.__acroform__.getBit");
  return r6 & 1 << e ? 1 : 0;
};
var pr = or.__acroform__.getBitForPdf = function(r6, e) {
  if (isNaN(r6) || isNaN(e)) throw new Error("Invalid arguments passed to jsPDF.API.__acroform__.getBitForPdf");
  return o3(r6, e - 1);
};
var gr = or.__acroform__.setBitForPdf = function(r6, e) {
  if (isNaN(r6) || isNaN(e)) throw new Error("Invalid arguments passed to jsPDF.API.__acroform__.setBitForPdf");
  return a3(r6, e - 1);
};
var vr = or.__acroform__.clearBitForPdf = function(r6, e) {
  if (isNaN(r6) || isNaN(e)) throw new Error("Invalid arguments passed to jsPDF.API.__acroform__.clearBitForPdf");
  return s3(r6, e - 1);
};
var f3 = or.__acroform__.calculateCoordinates = function(r6, e) {
  var t = e.internal.getHorizontalCoordinate, n = e.internal.getVerticalCoordinate, i = r6[0], a = r6[1], s = r6[2], o = r6[3], f = {};
  return f.lowerLeft_X = t(i) || 0, f.lowerLeft_Y = n(a + o) || 0, f.upperRight_X = t(i + s) || 0, f.upperRight_Y = n(a) || 0, [Number(wt(f.lowerLeft_X)), Number(wt(f.lowerLeft_Y)), Number(wt(f.upperRight_X)), Number(wt(f.upperRight_Y))];
};
var l3 = function(r6) {
  if (r6.appearanceStreamContent) return r6.appearanceStreamContent;
  if (r6.V || r6.DV) {
    var e = [], t = r6._V || r6.DV, n = Ll(r6, t), i = r6.scope.internal.getFont(r6.fontName, r6.fontStyle).id;
    e.push("/Tx BMC"), e.push("q"), e.push("BT"), e.push(r6.scope.__private__.encodeColorString(r6.color)), e.push("/" + i + " " + wt(n.fontSize) + " Tf"), e.push("1 0 0 1 0 0 Tm"), e.push(n.text), e.push("ET"), e.push("Q"), e.push("EMC");
    var a = vi(r6);
    return a.scope = r6.scope, a.stream = e.join(`
`), a;
  }
};
var Ll = function(r6, e) {
  var t = r6.fontSize === 0 ? r6.maxFontSize : r6.fontSize, n = {
    text: "",
    fontSize: ""
  }, i = (e = (e = e.substr(0, 1) == "(" ? e.substr(1) : e).substr(e.length - 1) == ")" ? e.substr(0, e.length - 1) : e).split(" ");
  i = r6.multiline ? i.map(function(F) {
    return F.split(`
`);
  }) : i.map(function(F) {
    return [F];
  });
  var a = t, s = at.internal.getHeight(r6) || 0;
  s = s < 0 ? -s : s;
  var o = at.internal.getWidth(r6) || 0;
  o = o < 0 ? -o : o;
  var f = function(F, P, Y) {
    if (F + 1 < i.length) {
      var Q = P + " " + i[F + 1][0];
      return C0(Q, r6, Y).width <= o - 4;
    }
    return false;
  };
  a++;
  e: for (; a > 0; ) {
    e = "", a--;
    var h, c, p = C0("3", r6, a).height, v = r6.multiline ? s - a : (s - p) / 2, d = v += 2, w = 0, x = 0, S = 0;
    if (a <= 0) {
      e = `(...) Tj
`, e += "% Width of Text: " + C0(e, r6, a = 12).width + ", FieldWidth:" + o + `
`;
      break;
    }
    for (var A = "", b = 0, O = 0; O < i.length; O++) if (i.hasOwnProperty(O)) {
      var q = false;
      if (i[O].length !== 1 && S !== i[O].length - 1) {
        if ((p + 2) * (b + 2) + 2 > s) continue e;
        A += i[O][S], q = true, x = O, O--;
      } else {
        A = (A += i[O][S] + " ").substr(A.length - 1) == " " ? A.substr(0, A.length - 1) : A;
        var te = parseInt(O), le = f(te, A, a), j = O >= i.length - 1;
        if (le && !j) {
          A += " ", S = 0;
          continue;
        }
        if (le || j) {
          if (j) x = te;
          else if (r6.multiline && (p + 2) * (b + 2) + 2 > s) continue e;
        } else {
          if (!r6.multiline || (p + 2) * (b + 2) + 2 > s) continue e;
          x = te;
        }
      }
      for (var M = "", H = w; H <= x; H++) {
        var ee = i[H];
        if (r6.multiline) {
          if (H === x) {
            M += ee[S] + " ", S = (S + 1) % ee.length;
            continue;
          }
          if (H === w) {
            M += ee[ee.length - 1] + " ";
            continue;
          }
        }
        M += ee[0] + " ";
      }
      switch (M = M.substr(M.length - 1) == " " ? M.substr(0, M.length - 1) : M, c = C0(M, r6, a).width, r6.textAlign) {
        case "right":
          h = o - c - 2;
          break;
        case "center":
          h = (o - c) / 2;
          break;
        case "left":
        default:
          h = 2;
      }
      e += wt(h) + " " + wt(d) + ` Td
`, e += "(" + ja(M) + `) Tj
`, e += -wt(h) + ` 0 Td
`, d = -(a + 2), c = 0, w = q ? x : x + 1, b++, A = "";
    }
    break;
  }
  return n.text = e, n.fontSize = a, n;
};
var C0 = function(r6, e, t) {
  var n = e.scope.internal.getFont(e.fontName, e.fontStyle), i = e.scope.getStringUnitWidth(r6, {
    font: n,
    fontSize: parseFloat(t),
    charSpace: 0
  }) * parseFloat(t);
  return {
    height: e.scope.getStringUnitWidth("3", {
      font: n,
      fontSize: parseFloat(t),
      charSpace: 0
    }) * parseFloat(t) * 1.5,
    width: i
  };
};
var h3 = {
  fields: [],
  xForms: [],
  acroFormDictionaryRoot: null,
  printedOut: false,
  internal: null,
  isInitialized: false
};
var c3 = function(r6, e) {
  var t = {
    type: "reference",
    object: r6
  };
  e.internal.getPageInfo(r6.page).pageContext.annotations.find(function(n) {
    return n.type === t.type && n.object === t.object;
  }) === void 0 && e.internal.getPageInfo(r6.page).pageContext.annotations.push(t);
};
var u3 = function(r6, e) {
  for (var t in r6) if (r6.hasOwnProperty(t)) {
    var n = t, i = r6[t];
    e.internal.newObjectDeferredBegin(i.objId, true), Wt(i) === "object" && typeof i.putStream == "function" && i.putStream(), delete r6[n];
  }
};
var d3 = function(r6, e) {
  if (e.scope = r6, r6.internal !== void 0 && (r6.internal.acroformPlugin === void 0 || r6.internal.acroformPlugin.isInitialized === false)) {
    if (ai.FieldNum = 0, r6.internal.acroformPlugin = JSON.parse(JSON.stringify(h3)), r6.internal.acroformPlugin.acroFormDictionaryRoot) throw new Error("Exception while creating AcroformDictionary");
    ih = r6.internal.scaleFactor, r6.internal.acroformPlugin.acroFormDictionaryRoot = new W1(), r6.internal.acroformPlugin.acroFormDictionaryRoot.scope = r6, r6.internal.acroformPlugin.acroFormDictionaryRoot._eventID = r6.internal.events.subscribe("postPutResources", function() {
      (function(t) {
        t.internal.events.unsubscribe(t.internal.acroformPlugin.acroFormDictionaryRoot._eventID), delete t.internal.acroformPlugin.acroFormDictionaryRoot._eventID, t.internal.acroformPlugin.printedOut = true;
      })(r6);
    }), r6.internal.events.subscribe("buildDocument", function() {
      (function(t) {
        t.internal.acroformPlugin.acroFormDictionaryRoot.objId = void 0;
        var n = t.internal.acroformPlugin.acroFormDictionaryRoot.Fields;
        for (var i in n) if (n.hasOwnProperty(i)) {
          var a = n[i];
          a.objId = void 0, a.hasAnnotation && c3(a, t);
        }
      })(r6);
    }), r6.internal.events.subscribe("putCatalog", function() {
      (function(t) {
        if (t.internal.acroformPlugin.acroFormDictionaryRoot === void 0) throw new Error("putCatalogCallback: Root missing.");
        t.internal.write("/AcroForm " + t.internal.acroformPlugin.acroFormDictionaryRoot.objId + " 0 R");
      })(r6);
    }), r6.internal.events.subscribe("postPutPages", function(t) {
      (function(n, i) {
        var a = !n;
        for (var s in n || (i.internal.newObjectDeferredBegin(i.internal.acroformPlugin.acroFormDictionaryRoot.objId, true), i.internal.acroformPlugin.acroFormDictionaryRoot.putStream()), n = n || i.internal.acroformPlugin.acroFormDictionaryRoot.Kids) if (n.hasOwnProperty(s)) {
          var o = n[s], f = [], h = o.Rect;
          if (o.Rect && (o.Rect = f3(o.Rect, i)), i.internal.newObjectDeferredBegin(o.objId, true), o.DA = at.createDefaultAppearanceStream(o), Wt(o) === "object" && typeof o.getKeyValueListForStream == "function" && (f = o.getKeyValueListForStream()), o.Rect = h, o.hasAppearanceStream && !o.appearanceStreamContent) {
            var c = l3(o);
            f.push({
              key: "AP",
              value: "<</N " + c + ">>"
            }), i.internal.acroformPlugin.xForms.push(c);
          }
          if (o.appearanceStreamContent) {
            var p = "";
            for (var v in o.appearanceStreamContent) if (o.appearanceStreamContent.hasOwnProperty(v)) {
              var d = o.appearanceStreamContent[v];
              if (p += "/" + v + " ", p += "<<", Object.keys(d).length >= 1 || Array.isArray(d)) {
                for (var s in d) if (d.hasOwnProperty(s)) {
                  var w = d[s];
                  typeof w == "function" && (w = w.call(i, o)), p += "/" + s + " " + w + " ", i.internal.acroformPlugin.xForms.indexOf(w) >= 0 || i.internal.acroformPlugin.xForms.push(w);
                }
              } else typeof (w = d) == "function" && (w = w.call(i, o)), p += "/" + s + " " + w, i.internal.acroformPlugin.xForms.indexOf(w) >= 0 || i.internal.acroformPlugin.xForms.push(w);
              p += ">>";
            }
            f.push({
              key: "AP",
              value: `<<
` + p + ">>"
            });
          }
          i.internal.putStream({
            additionalKeyValues: f,
            objectId: o.objId
          }), i.internal.out("endobj");
        }
        a && u3(i.internal.acroformPlugin.xForms, i);
      })(t, r6);
    }), r6.internal.acroformPlugin.isInitialized = true;
  }
};
var q1 = or.__acroform__.arrayToPdfArray = function(r6, e, t) {
  var n = function(s) {
    return s;
  };
  if (Array.isArray(r6)) {
    for (var i = "[", a = 0; a < r6.length; a++) switch (a !== 0 && (i += " "), Wt(r6[a])) {
      case "boolean":
      case "number":
      case "object":
        i += r6[a].toString();
        break;
      case "string":
        r6[a].substr(0, 1) !== "/" ? (e !== void 0 && t && (n = t.internal.getEncryptor(e)), i += "(" + ja(n(r6[a].toString())) + ")") : i += r6[a].toString();
    }
    return i += "]";
  }
  throw new Error("Invalid argument passed to jsPDF.__acroform__.arrayToPdfArray");
};
var hl = function(r6, e, t) {
  var n = function(i) {
    return i;
  };
  return e !== void 0 && t && (n = t.internal.getEncryptor(e)), (r6 = r6 || "").toString(), r6 = "(" + ja(n(r6)) + ")";
};
var mi = function() {
  this._objId = void 0, this._scope = void 0, Object.defineProperty(this, "objId", {
    get: function() {
      if (this._objId === void 0) {
        if (this.scope === void 0) return;
        this._objId = this.scope.internal.newObjectDeferred();
      }
      return this._objId;
    },
    set: function(r6) {
      this._objId = r6;
    }
  }), Object.defineProperty(this, "scope", {
    value: this._scope,
    writable: true
  });
};
mi.prototype.toString = function() {
  return this.objId + " 0 R";
}, mi.prototype.putStream = function() {
  var r6 = this.getKeyValueListForStream();
  this.scope.internal.putStream({
    data: this.stream,
    additionalKeyValues: r6,
    objectId: this.objId
  }), this.scope.internal.out("endobj");
}, mi.prototype.getKeyValueListForStream = function() {
  var r6 = [], e = Object.getOwnPropertyNames(this).filter(function(a) {
    return a != "content" && a != "appearanceStreamContent" && a != "scope" && a != "objId" && a.substring(0, 1) != "_";
  });
  for (var t in e) if (Object.getOwnPropertyDescriptor(this, e[t]).configurable === false) {
    var n = e[t], i = this[n];
    i && (Array.isArray(i) ? r6.push({
      key: n,
      value: q1(i, this.objId, this.scope)
    }) : i instanceof mi ? (i.scope = this.scope, r6.push({
      key: n,
      value: i.objId + " 0 R"
    })) : typeof i != "function" && r6.push({
      key: n,
      value: i
    }));
  }
  return r6;
};
var H1 = function() {
  mi.call(this), Object.defineProperty(this, "Type", {
    value: "/XObject",
    configurable: false,
    writable: true
  }), Object.defineProperty(this, "Subtype", {
    value: "/Form",
    configurable: false,
    writable: true
  }), Object.defineProperty(this, "FormType", {
    value: 1,
    configurable: false,
    writable: true
  });
  var r6, e = [];
  Object.defineProperty(this, "BBox", {
    configurable: false,
    get: function() {
      return e;
    },
    set: function(t) {
      e = t;
    }
  }), Object.defineProperty(this, "Resources", {
    value: "2 0 R",
    configurable: false,
    writable: true
  }), Object.defineProperty(this, "stream", {
    enumerable: false,
    configurable: true,
    set: function(t) {
      r6 = t.trim();
    },
    get: function() {
      return r6 || null;
    }
  });
};
vn(H1, mi);
var W1 = function() {
  mi.call(this);
  var r6, e = [];
  Object.defineProperty(this, "Kids", {
    enumerable: false,
    configurable: true,
    get: function() {
      return e.length > 0 ? e : void 0;
    }
  }), Object.defineProperty(this, "Fields", {
    enumerable: false,
    configurable: false,
    get: function() {
      return e;
    }
  }), Object.defineProperty(this, "DA", {
    enumerable: false,
    configurable: false,
    get: function() {
      if (r6) {
        var t = function(n) {
          return n;
        };
        return this.scope && (t = this.scope.internal.getEncryptor(this.objId)), "(" + ja(t(r6)) + ")";
      }
    },
    set: function(t) {
      r6 = t;
    }
  });
};
vn(W1, mi);
var ai = function r() {
  mi.call(this);
  var e = 4;
  Object.defineProperty(this, "F", {
    enumerable: false,
    configurable: false,
    get: function() {
      return e;
    },
    set: function(A) {
      if (isNaN(A)) throw new Error('Invalid value "' + A + '" for attribute F supplied.');
      e = A;
    }
  }), Object.defineProperty(this, "showWhenPrinted", {
    enumerable: true,
    configurable: true,
    get: function() {
      return !!pr(e, 3);
    },
    set: function(A) {
      A ? this.F = gr(e, 3) : this.F = vr(e, 3);
    }
  });
  var t = 0;
  Object.defineProperty(this, "Ff", {
    enumerable: false,
    configurable: false,
    get: function() {
      return t;
    },
    set: function(A) {
      if (isNaN(A)) throw new Error('Invalid value "' + A + '" for attribute Ff supplied.');
      t = A;
    }
  });
  var n = [];
  Object.defineProperty(this, "Rect", {
    enumerable: false,
    configurable: false,
    get: function() {
      if (n.length !== 0) return n;
    },
    set: function(A) {
      n = A !== void 0 ? A : [];
    }
  }), Object.defineProperty(this, "x", {
    enumerable: true,
    configurable: true,
    get: function() {
      return !n || isNaN(n[0]) ? 0 : n[0];
    },
    set: function(A) {
      n[0] = A;
    }
  }), Object.defineProperty(this, "y", {
    enumerable: true,
    configurable: true,
    get: function() {
      return !n || isNaN(n[1]) ? 0 : n[1];
    },
    set: function(A) {
      n[1] = A;
    }
  }), Object.defineProperty(this, "width", {
    enumerable: true,
    configurable: true,
    get: function() {
      return !n || isNaN(n[2]) ? 0 : n[2];
    },
    set: function(A) {
      n[2] = A;
    }
  }), Object.defineProperty(this, "height", {
    enumerable: true,
    configurable: true,
    get: function() {
      return !n || isNaN(n[3]) ? 0 : n[3];
    },
    set: function(A) {
      n[3] = A;
    }
  });
  var i = "";
  Object.defineProperty(this, "FT", {
    enumerable: true,
    configurable: false,
    get: function() {
      return i;
    },
    set: function(A) {
      switch (A) {
        case "/Btn":
        case "/Tx":
        case "/Ch":
        case "/Sig":
          i = A;
          break;
        default:
          throw new Error('Invalid value "' + A + '" for attribute FT supplied.');
      }
    }
  });
  var a = null;
  Object.defineProperty(this, "T", {
    enumerable: true,
    configurable: false,
    get: function() {
      if (!a || a.length < 1) {
        if (this instanceof Z0) return;
        a = "FieldObject" + r.FieldNum++;
      }
      var A = function(b) {
        return b;
      };
      return this.scope && (A = this.scope.internal.getEncryptor(this.objId)), "(" + ja(A(a)) + ")";
    },
    set: function(A) {
      a = A.toString();
    }
  }), Object.defineProperty(this, "fieldName", {
    configurable: true,
    enumerable: true,
    get: function() {
      return a;
    },
    set: function(A) {
      a = A;
    }
  });
  var s = "helvetica";
  Object.defineProperty(this, "fontName", {
    enumerable: true,
    configurable: true,
    get: function() {
      return s;
    },
    set: function(A) {
      s = A;
    }
  });
  var o = "normal";
  Object.defineProperty(this, "fontStyle", {
    enumerable: true,
    configurable: true,
    get: function() {
      return o;
    },
    set: function(A) {
      o = A;
    }
  });
  var f = 0;
  Object.defineProperty(this, "fontSize", {
    enumerable: true,
    configurable: true,
    get: function() {
      return f;
    },
    set: function(A) {
      f = A;
    }
  });
  var h = void 0;
  Object.defineProperty(this, "maxFontSize", {
    enumerable: true,
    configurable: true,
    get: function() {
      return h === void 0 ? 50 / ih : h;
    },
    set: function(A) {
      h = A;
    }
  });
  var c = "black";
  Object.defineProperty(this, "color", {
    enumerable: true,
    configurable: true,
    get: function() {
      return c;
    },
    set: function(A) {
      c = A;
    }
  });
  var p = "/F1 0 Tf 0 g";
  Object.defineProperty(this, "DA", {
    enumerable: true,
    configurable: false,
    get: function() {
      if (!(!p || this instanceof Z0 || this instanceof Ca)) return hl(p, this.objId, this.scope);
    },
    set: function(A) {
      A = A.toString(), p = A;
    }
  });
  var v = null;
  Object.defineProperty(this, "DV", {
    enumerable: false,
    configurable: false,
    get: function() {
      if (v) return this instanceof Pr ? v : hl(v, this.objId, this.scope);
    },
    set: function(A) {
      A = A.toString(), v = this instanceof Pr ? A : A.substr(0, 1) === "(" ? cs(A.substr(1, A.length - 2)) : cs(A);
    }
  }), Object.defineProperty(this, "defaultValue", {
    enumerable: true,
    configurable: true,
    get: function() {
      return this instanceof Pr ? cs(v.substr(1, v.length - 1)) : v;
    },
    set: function(A) {
      A = A.toString(), v = this instanceof Pr ? "/" + A : A;
    }
  });
  var d = null;
  Object.defineProperty(this, "_V", {
    enumerable: false,
    configurable: false,
    get: function() {
      if (d) return d;
    },
    set: function(A) {
      this.V = A;
    }
  }), Object.defineProperty(this, "V", {
    enumerable: false,
    configurable: false,
    get: function() {
      if (d) return this instanceof Pr ? d : hl(d, this.objId, this.scope);
    },
    set: function(A) {
      A = A.toString(), d = this instanceof Pr ? A : A.substr(0, 1) === "(" ? cs(A.substr(1, A.length - 2)) : cs(A);
    }
  }), Object.defineProperty(this, "value", {
    enumerable: true,
    configurable: true,
    get: function() {
      return this instanceof Pr ? cs(d.substr(1, d.length - 1)) : d;
    },
    set: function(A) {
      A = A.toString(), d = this instanceof Pr ? "/" + A : A;
    }
  }), Object.defineProperty(this, "hasAnnotation", {
    enumerable: true,
    configurable: true,
    get: function() {
      return this.Rect;
    }
  }), Object.defineProperty(this, "Type", {
    enumerable: true,
    configurable: false,
    get: function() {
      return this.hasAnnotation ? "/Annot" : null;
    }
  }), Object.defineProperty(this, "Subtype", {
    enumerable: true,
    configurable: false,
    get: function() {
      return this.hasAnnotation ? "/Widget" : null;
    }
  });
  var w, x = false;
  Object.defineProperty(this, "hasAppearanceStream", {
    enumerable: true,
    configurable: true,
    get: function() {
      return x;
    },
    set: function(A) {
      A = !!A, x = A;
    }
  }), Object.defineProperty(this, "page", {
    enumerable: true,
    configurable: true,
    get: function() {
      if (w) return w;
    },
    set: function(A) {
      w = A;
    }
  }), Object.defineProperty(this, "readOnly", {
    enumerable: true,
    configurable: true,
    get: function() {
      return !!pr(this.Ff, 1);
    },
    set: function(A) {
      A ? this.Ff = gr(this.Ff, 1) : this.Ff = vr(this.Ff, 1);
    }
  }), Object.defineProperty(this, "required", {
    enumerable: true,
    configurable: true,
    get: function() {
      return !!pr(this.Ff, 2);
    },
    set: function(A) {
      A ? this.Ff = gr(this.Ff, 2) : this.Ff = vr(this.Ff, 2);
    }
  }), Object.defineProperty(this, "noExport", {
    enumerable: true,
    configurable: true,
    get: function() {
      return !!pr(this.Ff, 3);
    },
    set: function(A) {
      A ? this.Ff = gr(this.Ff, 3) : this.Ff = vr(this.Ff, 3);
    }
  });
  var S = null;
  Object.defineProperty(this, "Q", {
    enumerable: true,
    configurable: false,
    get: function() {
      if (S !== null) return S;
    },
    set: function(A) {
      if ([0, 1, 2].indexOf(A) === -1) throw new Error('Invalid value "' + A + '" for attribute Q supplied.');
      S = A;
    }
  }), Object.defineProperty(this, "textAlign", {
    get: function() {
      var A;
      switch (S) {
        case 0:
        default:
          A = "left";
          break;
        case 1:
          A = "center";
          break;
        case 2:
          A = "right";
      }
      return A;
    },
    configurable: true,
    enumerable: true,
    set: function(A) {
      switch (A) {
        case "right":
        case 2:
          S = 2;
          break;
        case "center":
        case 1:
          S = 1;
          break;
        case "left":
        case 0:
        default:
          S = 0;
      }
    }
  });
};
vn(ai, mi);
var Ss = function() {
  ai.call(this), this.FT = "/Ch", this.V = "()", this.fontName = "zapfdingbats";
  var r6 = 0;
  Object.defineProperty(this, "TI", {
    enumerable: true,
    configurable: false,
    get: function() {
      return r6;
    },
    set: function(t) {
      r6 = t;
    }
  }), Object.defineProperty(this, "topIndex", {
    enumerable: true,
    configurable: true,
    get: function() {
      return r6;
    },
    set: function(t) {
      r6 = t;
    }
  });
  var e = [];
  Object.defineProperty(this, "Opt", {
    enumerable: true,
    configurable: false,
    get: function() {
      return q1(e, this.objId, this.scope);
    },
    set: function(t) {
      var n, i;
      i = [], typeof (n = t) == "string" && (i = function(a, s, o) {
        o || (o = 1);
        for (var f, h = []; f = s.exec(a); ) h.push(f[o]);
        return h;
      }(n, /\((.*?)\)/g)), e = i;
    }
  }), this.getOptions = function() {
    return e;
  }, this.setOptions = function(t) {
    e = t, this.sort && e.sort();
  }, this.addOption = function(t) {
    t = (t = t || "").toString(), e.push(t), this.sort && e.sort();
  }, this.removeOption = function(t, n) {
    for (n = n || false, t = (t = t || "").toString(); e.indexOf(t) !== -1 && (e.splice(e.indexOf(t), 1), n !== false); ) ;
  }, Object.defineProperty(this, "combo", {
    enumerable: true,
    configurable: true,
    get: function() {
      return !!pr(this.Ff, 18);
    },
    set: function(t) {
      t ? this.Ff = gr(this.Ff, 18) : this.Ff = vr(this.Ff, 18);
    }
  }), Object.defineProperty(this, "edit", {
    enumerable: true,
    configurable: true,
    get: function() {
      return !!pr(this.Ff, 19);
    },
    set: function(t) {
      this.combo === true && (t ? this.Ff = gr(this.Ff, 19) : this.Ff = vr(this.Ff, 19));
    }
  }), Object.defineProperty(this, "sort", {
    enumerable: true,
    configurable: true,
    get: function() {
      return !!pr(this.Ff, 20);
    },
    set: function(t) {
      t ? (this.Ff = gr(this.Ff, 20), e.sort()) : this.Ff = vr(this.Ff, 20);
    }
  }), Object.defineProperty(this, "multiSelect", {
    enumerable: true,
    configurable: true,
    get: function() {
      return !!pr(this.Ff, 22);
    },
    set: function(t) {
      t ? this.Ff = gr(this.Ff, 22) : this.Ff = vr(this.Ff, 22);
    }
  }), Object.defineProperty(this, "doNotSpellCheck", {
    enumerable: true,
    configurable: true,
    get: function() {
      return !!pr(this.Ff, 23);
    },
    set: function(t) {
      t ? this.Ff = gr(this.Ff, 23) : this.Ff = vr(this.Ff, 23);
    }
  }), Object.defineProperty(this, "commitOnSelChange", {
    enumerable: true,
    configurable: true,
    get: function() {
      return !!pr(this.Ff, 27);
    },
    set: function(t) {
      t ? this.Ff = gr(this.Ff, 27) : this.Ff = vr(this.Ff, 27);
    }
  }), this.hasAppearanceStream = false;
};
vn(Ss, ai);
var As = function() {
  Ss.call(this), this.fontName = "helvetica", this.combo = false;
};
vn(As, Ss);
var bs = function() {
  As.call(this), this.combo = true;
};
vn(bs, As);
var D0 = function() {
  bs.call(this), this.edit = true;
};
vn(D0, bs);
var Pr = function() {
  ai.call(this), this.FT = "/Btn", Object.defineProperty(this, "noToggleToOff", {
    enumerable: true,
    configurable: true,
    get: function() {
      return !!pr(this.Ff, 15);
    },
    set: function(t) {
      t ? this.Ff = gr(this.Ff, 15) : this.Ff = vr(this.Ff, 15);
    }
  }), Object.defineProperty(this, "radio", {
    enumerable: true,
    configurable: true,
    get: function() {
      return !!pr(this.Ff, 16);
    },
    set: function(t) {
      t ? this.Ff = gr(this.Ff, 16) : this.Ff = vr(this.Ff, 16);
    }
  }), Object.defineProperty(this, "pushButton", {
    enumerable: true,
    configurable: true,
    get: function() {
      return !!pr(this.Ff, 17);
    },
    set: function(t) {
      t ? this.Ff = gr(this.Ff, 17) : this.Ff = vr(this.Ff, 17);
    }
  }), Object.defineProperty(this, "radioIsUnison", {
    enumerable: true,
    configurable: true,
    get: function() {
      return !!pr(this.Ff, 26);
    },
    set: function(t) {
      t ? this.Ff = gr(this.Ff, 26) : this.Ff = vr(this.Ff, 26);
    }
  });
  var r6, e = {};
  Object.defineProperty(this, "MK", {
    enumerable: false,
    configurable: false,
    get: function() {
      var t = function(a) {
        return a;
      };
      if (this.scope && (t = this.scope.internal.getEncryptor(this.objId)), Object.keys(e).length !== 0) {
        var n, i = [];
        for (n in i.push("<<"), e) i.push("/" + n + " (" + ja(t(e[n])) + ")");
        return i.push(">>"), i.join(`
`);
      }
    },
    set: function(t) {
      Wt(t) === "object" && (e = t);
    }
  }), Object.defineProperty(this, "caption", {
    enumerable: true,
    configurable: true,
    get: function() {
      return e.CA || "";
    },
    set: function(t) {
      typeof t == "string" && (e.CA = t);
    }
  }), Object.defineProperty(this, "AS", {
    enumerable: false,
    configurable: false,
    get: function() {
      return r6;
    },
    set: function(t) {
      r6 = t;
    }
  }), Object.defineProperty(this, "appearanceState", {
    enumerable: true,
    configurable: true,
    get: function() {
      return r6.substr(1, r6.length - 1);
    },
    set: function(t) {
      r6 = "/" + t;
    }
  });
};
vn(Pr, ai);
var O0 = function() {
  Pr.call(this), this.pushButton = true;
};
vn(O0, Pr);
var Ts = function() {
  Pr.call(this), this.radio = true, this.pushButton = false;
  var r6 = [];
  Object.defineProperty(this, "Kids", {
    enumerable: true,
    configurable: false,
    get: function() {
      return r6;
    },
    set: function(e) {
      r6 = e !== void 0 ? e : [];
    }
  });
};
vn(Ts, Pr);
var Z0 = function() {
  var r6, e;
  ai.call(this), Object.defineProperty(this, "Parent", {
    enumerable: false,
    configurable: false,
    get: function() {
      return r6;
    },
    set: function(i) {
      r6 = i;
    }
  }), Object.defineProperty(this, "optionName", {
    enumerable: false,
    configurable: true,
    get: function() {
      return e;
    },
    set: function(i) {
      e = i;
    }
  });
  var t, n = {};
  Object.defineProperty(this, "MK", {
    enumerable: false,
    configurable: false,
    get: function() {
      var i = function(o) {
        return o;
      };
      this.scope && (i = this.scope.internal.getEncryptor(this.objId));
      var a, s = [];
      for (a in s.push("<<"), n) s.push("/" + a + " (" + ja(i(n[a])) + ")");
      return s.push(">>"), s.join(`
`);
    },
    set: function(i) {
      Wt(i) === "object" && (n = i);
    }
  }), Object.defineProperty(this, "caption", {
    enumerable: true,
    configurable: true,
    get: function() {
      return n.CA || "";
    },
    set: function(i) {
      typeof i == "string" && (n.CA = i);
    }
  }), Object.defineProperty(this, "AS", {
    enumerable: false,
    configurable: false,
    get: function() {
      return t;
    },
    set: function(i) {
      t = i;
    }
  }), Object.defineProperty(this, "appearanceState", {
    enumerable: true,
    configurable: true,
    get: function() {
      return t.substr(1, t.length - 1);
    },
    set: function(i) {
      t = "/" + i;
    }
  }), this.caption = "l", this.appearanceState = "Off", this._AppearanceType = at.RadioButton.Circle, this.appearanceStreamContent = this._AppearanceType.createAppearanceStream(this.optionName);
};
vn(Z0, ai), Ts.prototype.setAppearance = function(r6) {
  if (!("createAppearanceStream" in r6) || !("getCA" in r6)) throw new Error("Couldn't assign Appearance to RadioButton. Appearance was Invalid!");
  for (var e in this.Kids) if (this.Kids.hasOwnProperty(e)) {
    var t = this.Kids[e];
    t.appearanceStreamContent = r6.createAppearanceStream(t.optionName), t.caption = r6.getCA();
  }
}, Ts.prototype.createOption = function(r6) {
  var e = new Z0();
  return e.Parent = this, e.optionName = r6, this.Kids.push(e), p3.call(this.scope, e), e;
};
var I0 = function() {
  Pr.call(this), this.fontName = "zapfdingbats", this.caption = "3", this.appearanceState = "On", this.value = "On", this.textAlign = "center", this.appearanceStreamContent = at.CheckBox.createAppearanceStream();
};
vn(I0, Pr);
var Ca = function() {
  ai.call(this), this.FT = "/Tx", Object.defineProperty(this, "multiline", {
    enumerable: true,
    configurable: true,
    get: function() {
      return !!pr(this.Ff, 13);
    },
    set: function(e) {
      e ? this.Ff = gr(this.Ff, 13) : this.Ff = vr(this.Ff, 13);
    }
  }), Object.defineProperty(this, "fileSelect", {
    enumerable: true,
    configurable: true,
    get: function() {
      return !!pr(this.Ff, 21);
    },
    set: function(e) {
      e ? this.Ff = gr(this.Ff, 21) : this.Ff = vr(this.Ff, 21);
    }
  }), Object.defineProperty(this, "doNotSpellCheck", {
    enumerable: true,
    configurable: true,
    get: function() {
      return !!pr(this.Ff, 23);
    },
    set: function(e) {
      e ? this.Ff = gr(this.Ff, 23) : this.Ff = vr(this.Ff, 23);
    }
  }), Object.defineProperty(this, "doNotScroll", {
    enumerable: true,
    configurable: true,
    get: function() {
      return !!pr(this.Ff, 24);
    },
    set: function(e) {
      e ? this.Ff = gr(this.Ff, 24) : this.Ff = vr(this.Ff, 24);
    }
  }), Object.defineProperty(this, "comb", {
    enumerable: true,
    configurable: true,
    get: function() {
      return !!pr(this.Ff, 25);
    },
    set: function(e) {
      e ? this.Ff = gr(this.Ff, 25) : this.Ff = vr(this.Ff, 25);
    }
  }), Object.defineProperty(this, "richText", {
    enumerable: true,
    configurable: true,
    get: function() {
      return !!pr(this.Ff, 26);
    },
    set: function(e) {
      e ? this.Ff = gr(this.Ff, 26) : this.Ff = vr(this.Ff, 26);
    }
  });
  var r6 = null;
  Object.defineProperty(this, "MaxLen", {
    enumerable: true,
    configurable: false,
    get: function() {
      return r6;
    },
    set: function(e) {
      r6 = e;
    }
  }), Object.defineProperty(this, "maxLength", {
    enumerable: true,
    configurable: true,
    get: function() {
      return r6;
    },
    set: function(e) {
      Number.isInteger(e) && (r6 = e);
    }
  }), Object.defineProperty(this, "hasAppearanceStream", {
    enumerable: true,
    configurable: true,
    get: function() {
      return this.V || this.DV;
    }
  });
};
vn(Ca, ai);
var R0 = function() {
  Ca.call(this), Object.defineProperty(this, "password", {
    enumerable: true,
    configurable: true,
    get: function() {
      return !!pr(this.Ff, 14);
    },
    set: function(r6) {
      r6 ? this.Ff = gr(this.Ff, 14) : this.Ff = vr(this.Ff, 14);
    }
  }), this.password = true;
};
vn(R0, Ca);
var at = {
  CheckBox: {
    createAppearanceStream: function() {
      return {
        N: {
          On: at.CheckBox.YesNormal
        },
        D: {
          On: at.CheckBox.YesPushDown,
          Off: at.CheckBox.OffPushDown
        }
      };
    },
    YesPushDown: function(r6) {
      var e = vi(r6);
      e.scope = r6.scope;
      var t = [], n = r6.scope.internal.getFont(r6.fontName, r6.fontStyle).id, i = r6.scope.__private__.encodeColorString(r6.color), a = Ll(r6, r6.caption);
      return t.push("0.749023 g"), t.push("0 0 " + wt(at.internal.getWidth(r6)) + " " + wt(at.internal.getHeight(r6)) + " re"), t.push("f"), t.push("BMC"), t.push("q"), t.push("0 0 1 rg"), t.push("/" + n + " " + wt(a.fontSize) + " Tf " + i), t.push("BT"), t.push(a.text), t.push("ET"), t.push("Q"), t.push("EMC"), e.stream = t.join(`
`), e;
    },
    YesNormal: function(r6) {
      var e = vi(r6);
      e.scope = r6.scope;
      var t = r6.scope.internal.getFont(r6.fontName, r6.fontStyle).id, n = r6.scope.__private__.encodeColorString(r6.color), i = [], a = at.internal.getHeight(r6), s = at.internal.getWidth(r6), o = Ll(r6, r6.caption);
      return i.push("1 g"), i.push("0 0 " + wt(s) + " " + wt(a) + " re"), i.push("f"), i.push("q"), i.push("0 0 1 rg"), i.push("0 0 " + wt(s - 1) + " " + wt(a - 1) + " re"), i.push("W"), i.push("n"), i.push("0 g"), i.push("BT"), i.push("/" + t + " " + wt(o.fontSize) + " Tf " + n), i.push(o.text), i.push("ET"), i.push("Q"), e.stream = i.join(`
`), e;
    },
    OffPushDown: function(r6) {
      var e = vi(r6);
      e.scope = r6.scope;
      var t = [];
      return t.push("0.749023 g"), t.push("0 0 " + wt(at.internal.getWidth(r6)) + " " + wt(at.internal.getHeight(r6)) + " re"), t.push("f"), e.stream = t.join(`
`), e;
    }
  },
  RadioButton: {
    Circle: {
      createAppearanceStream: function(r6) {
        var e = {
          D: {
            Off: at.RadioButton.Circle.OffPushDown
          },
          N: {}
        };
        return e.N[r6] = at.RadioButton.Circle.YesNormal, e.D[r6] = at.RadioButton.Circle.YesPushDown, e;
      },
      getCA: function() {
        return "l";
      },
      YesNormal: function(r6) {
        var e = vi(r6);
        e.scope = r6.scope;
        var t = [], n = at.internal.getWidth(r6) <= at.internal.getHeight(r6) ? at.internal.getWidth(r6) / 4 : at.internal.getHeight(r6) / 4;
        n = Number((0.9 * n).toFixed(5));
        var i = at.internal.Bezier_C, a = Number((n * i).toFixed(5));
        return t.push("q"), t.push("1 0 0 1 " + aa(at.internal.getWidth(r6) / 2) + " " + aa(at.internal.getHeight(r6) / 2) + " cm"), t.push(n + " 0 m"), t.push(n + " " + a + " " + a + " " + n + " 0 " + n + " c"), t.push("-" + a + " " + n + " -" + n + " " + a + " -" + n + " 0 c"), t.push("-" + n + " -" + a + " -" + a + " -" + n + " 0 -" + n + " c"), t.push(a + " -" + n + " " + n + " -" + a + " " + n + " 0 c"), t.push("f"), t.push("Q"), e.stream = t.join(`
`), e;
      },
      YesPushDown: function(r6) {
        var e = vi(r6);
        e.scope = r6.scope;
        var t = [], n = at.internal.getWidth(r6) <= at.internal.getHeight(r6) ? at.internal.getWidth(r6) / 4 : at.internal.getHeight(r6) / 4;
        n = Number((0.9 * n).toFixed(5));
        var i = Number((2 * n).toFixed(5)), a = Number((i * at.internal.Bezier_C).toFixed(5)), s = Number((n * at.internal.Bezier_C).toFixed(5));
        return t.push("0.749023 g"), t.push("q"), t.push("1 0 0 1 " + aa(at.internal.getWidth(r6) / 2) + " " + aa(at.internal.getHeight(r6) / 2) + " cm"), t.push(i + " 0 m"), t.push(i + " " + a + " " + a + " " + i + " 0 " + i + " c"), t.push("-" + a + " " + i + " -" + i + " " + a + " -" + i + " 0 c"), t.push("-" + i + " -" + a + " -" + a + " -" + i + " 0 -" + i + " c"), t.push(a + " -" + i + " " + i + " -" + a + " " + i + " 0 c"), t.push("f"), t.push("Q"), t.push("0 g"), t.push("q"), t.push("1 0 0 1 " + aa(at.internal.getWidth(r6) / 2) + " " + aa(at.internal.getHeight(r6) / 2) + " cm"), t.push(n + " 0 m"), t.push(n + " " + s + " " + s + " " + n + " 0 " + n + " c"), t.push("-" + s + " " + n + " -" + n + " " + s + " -" + n + " 0 c"), t.push("-" + n + " -" + s + " -" + s + " -" + n + " 0 -" + n + " c"), t.push(s + " -" + n + " " + n + " -" + s + " " + n + " 0 c"), t.push("f"), t.push("Q"), e.stream = t.join(`
`), e;
      },
      OffPushDown: function(r6) {
        var e = vi(r6);
        e.scope = r6.scope;
        var t = [], n = at.internal.getWidth(r6) <= at.internal.getHeight(r6) ? at.internal.getWidth(r6) / 4 : at.internal.getHeight(r6) / 4;
        n = Number((0.9 * n).toFixed(5));
        var i = Number((2 * n).toFixed(5)), a = Number((i * at.internal.Bezier_C).toFixed(5));
        return t.push("0.749023 g"), t.push("q"), t.push("1 0 0 1 " + aa(at.internal.getWidth(r6) / 2) + " " + aa(at.internal.getHeight(r6) / 2) + " cm"), t.push(i + " 0 m"), t.push(i + " " + a + " " + a + " " + i + " 0 " + i + " c"), t.push("-" + a + " " + i + " -" + i + " " + a + " -" + i + " 0 c"), t.push("-" + i + " -" + a + " -" + a + " -" + i + " 0 -" + i + " c"), t.push(a + " -" + i + " " + i + " -" + a + " " + i + " 0 c"), t.push("f"), t.push("Q"), e.stream = t.join(`
`), e;
      }
    },
    Cross: {
      createAppearanceStream: function(r6) {
        var e = {
          D: {
            Off: at.RadioButton.Cross.OffPushDown
          },
          N: {}
        };
        return e.N[r6] = at.RadioButton.Cross.YesNormal, e.D[r6] = at.RadioButton.Cross.YesPushDown, e;
      },
      getCA: function() {
        return "8";
      },
      YesNormal: function(r6) {
        var e = vi(r6);
        e.scope = r6.scope;
        var t = [], n = at.internal.calculateCross(r6);
        return t.push("q"), t.push("1 1 " + wt(at.internal.getWidth(r6) - 2) + " " + wt(at.internal.getHeight(r6) - 2) + " re"), t.push("W"), t.push("n"), t.push(wt(n.x1.x) + " " + wt(n.x1.y) + " m"), t.push(wt(n.x2.x) + " " + wt(n.x2.y) + " l"), t.push(wt(n.x4.x) + " " + wt(n.x4.y) + " m"), t.push(wt(n.x3.x) + " " + wt(n.x3.y) + " l"), t.push("s"), t.push("Q"), e.stream = t.join(`
`), e;
      },
      YesPushDown: function(r6) {
        var e = vi(r6);
        e.scope = r6.scope;
        var t = at.internal.calculateCross(r6), n = [];
        return n.push("0.749023 g"), n.push("0 0 " + wt(at.internal.getWidth(r6)) + " " + wt(at.internal.getHeight(r6)) + " re"), n.push("f"), n.push("q"), n.push("1 1 " + wt(at.internal.getWidth(r6) - 2) + " " + wt(at.internal.getHeight(r6) - 2) + " re"), n.push("W"), n.push("n"), n.push(wt(t.x1.x) + " " + wt(t.x1.y) + " m"), n.push(wt(t.x2.x) + " " + wt(t.x2.y) + " l"), n.push(wt(t.x4.x) + " " + wt(t.x4.y) + " m"), n.push(wt(t.x3.x) + " " + wt(t.x3.y) + " l"), n.push("s"), n.push("Q"), e.stream = n.join(`
`), e;
      },
      OffPushDown: function(r6) {
        var e = vi(r6);
        e.scope = r6.scope;
        var t = [];
        return t.push("0.749023 g"), t.push("0 0 " + wt(at.internal.getWidth(r6)) + " " + wt(at.internal.getHeight(r6)) + " re"), t.push("f"), e.stream = t.join(`
`), e;
      }
    }
  },
  createDefaultAppearanceStream: function(r6) {
    var e = r6.scope.internal.getFont(r6.fontName, r6.fontStyle).id, t = r6.scope.__private__.encodeColorString(r6.color);
    return "/" + e + " " + r6.fontSize + " Tf " + t;
  }
};
at.internal = {
  Bezier_C: 0.551915024494,
  calculateCross: function(r6) {
    var e = at.internal.getWidth(r6), t = at.internal.getHeight(r6), n = Math.min(e, t);
    return {
      x1: {
        x: (e - n) / 2,
        y: (t - n) / 2 + n
      },
      x2: {
        x: (e - n) / 2 + n,
        y: (t - n) / 2
      },
      x3: {
        x: (e - n) / 2,
        y: (t - n) / 2
      },
      x4: {
        x: (e - n) / 2 + n,
        y: (t - n) / 2 + n
      }
    };
  }
}, at.internal.getWidth = function(r6) {
  var e = 0;
  return Wt(r6) === "object" && (e = Fc(r6.Rect[2])), e;
}, at.internal.getHeight = function(r6) {
  var e = 0;
  return Wt(r6) === "object" && (e = Fc(r6.Rect[3])), e;
};
var p3 = or.addField = function(r6) {
  if (d3(this, r6), !(r6 instanceof ai)) throw new Error("Invalid argument passed to jsPDF.addField.");
  var e;
  return (e = r6).scope.internal.acroformPlugin.printedOut && (e.scope.internal.acroformPlugin.printedOut = false, e.scope.internal.acroformPlugin.acroFormDictionaryRoot = null), e.scope.internal.acroformPlugin.acroFormDictionaryRoot.Fields.push(e), r6.page = r6.scope.internal.getCurrentPageInfo().pageNumber, this;
};
or.AcroFormChoiceField = Ss, or.AcroFormListBox = As, or.AcroFormComboBox = bs, or.AcroFormEditBox = D0, or.AcroFormButton = Pr, or.AcroFormPushButton = O0, or.AcroFormRadioButton = Ts, or.AcroFormCheckBox = I0, or.AcroFormTextField = Ca, or.AcroFormPasswordField = R0, or.AcroFormAppearance = at, or.AcroForm = {
  ChoiceField: Ss,
  ListBox: As,
  ComboBox: bs,
  EditBox: D0,
  Button: Pr,
  PushButton: O0,
  RadioButton: Ts,
  CheckBox: I0,
  TextField: Ca,
  PasswordField: R0,
  Appearance: at
}, ut.AcroForm = {
  ChoiceField: Ss,
  ListBox: As,
  ComboBox: bs,
  EditBox: D0,
  Button: Pr,
  PushButton: O0,
  RadioButton: Ts,
  CheckBox: I0,
  TextField: Ca,
  PasswordField: R0,
  Appearance: at
};
function z1(r6) {
  return r6.reduce(function(e, t, n) {
    return e[t] = n, e;
  }, {});
}
(function(r6) {
  r6.__addimage__ = {};
  var e = "UNKNOWN", t = {
    PNG: [[137, 80, 78, 71]],
    TIFF: [[77, 77, 0, 42], [73, 73, 42, 0]],
    JPEG: [[255, 216, 255, 224, void 0, void 0, 74, 70, 73, 70, 0], [255, 216, 255, 225, void 0, void 0, 69, 120, 105, 102, 0, 0], [255, 216, 255, 219], [255, 216, 255, 238]],
    JPEG2000: [[0, 0, 0, 12, 106, 80, 32, 32]],
    GIF87a: [[71, 73, 70, 56, 55, 97]],
    GIF89a: [[71, 73, 70, 56, 57, 97]],
    WEBP: [[82, 73, 70, 70, void 0, void 0, void 0, void 0, 87, 69, 66, 80]],
    BMP: [[66, 77], [66, 65], [67, 73], [67, 80], [73, 67], [80, 84]]
  }, n = r6.__addimage__.getImageFileTypeByImageData = function(F, P) {
    var Y, Q, ce, we, Se, de = e;
    if ((P = P || e) === "RGBA" || F.data !== void 0 && F.data instanceof Uint8ClampedArray && "height" in F && "width" in F) return "RGBA";
    if (le(F)) for (Se in t) for (ce = t[Se], Y = 0; Y < ce.length; Y += 1) {
      for (we = true, Q = 0; Q < ce[Y].length; Q += 1) if (ce[Y][Q] !== void 0 && ce[Y][Q] !== F[Q]) {
        we = false;
        break;
      }
      if (we === true) {
        de = Se;
        break;
      }
    }
    else for (Se in t) for (ce = t[Se], Y = 0; Y < ce.length; Y += 1) {
      for (we = true, Q = 0; Q < ce[Y].length; Q += 1) if (ce[Y][Q] !== void 0 && ce[Y][Q] !== F.charCodeAt(Q)) {
        we = false;
        break;
      }
      if (we === true) {
        de = Se;
        break;
      }
    }
    return de === e && P !== e && (de = P), de;
  }, i = function F(P) {
    for (var Y = this.internal.write, Q = this.internal.putStream, ce = (0, this.internal.getFilters)(); ce.indexOf("FlateEncode") !== -1; ) ce.splice(ce.indexOf("FlateEncode"), 1);
    P.objectId = this.internal.newObject();
    var we = [];
    if (we.push({
      key: "Type",
      value: "/XObject"
    }), we.push({
      key: "Subtype",
      value: "/Image"
    }), we.push({
      key: "Width",
      value: P.width
    }), we.push({
      key: "Height",
      value: P.height
    }), P.colorSpace === S.INDEXED ? we.push({
      key: "ColorSpace",
      value: "[/Indexed /DeviceRGB " + (P.palette.length / 3 - 1) + " " + ("sMask" in P && P.sMask !== void 0 ? P.objectId + 2 : P.objectId + 1) + " 0 R]"
    }) : (we.push({
      key: "ColorSpace",
      value: "/" + P.colorSpace
    }), P.colorSpace === S.DEVICE_CMYK && we.push({
      key: "Decode",
      value: "[1 0 1 0 1 0 1 0]"
    })), we.push({
      key: "BitsPerComponent",
      value: P.bitsPerComponent
    }), "decodeParameters" in P && P.decodeParameters !== void 0 && we.push({
      key: "DecodeParms",
      value: "<<" + P.decodeParameters + ">>"
    }), "transparency" in P && Array.isArray(P.transparency)) {
      for (var Se = "", de = 0, Ae = P.transparency.length; de < Ae; de++) Se += P.transparency[de] + " " + P.transparency[de] + " ";
      we.push({
        key: "Mask",
        value: "[" + Se + "]"
      });
    }
    P.sMask !== void 0 && we.push({
      key: "SMask",
      value: P.objectId + 1 + " 0 R"
    });
    var be = P.filter !== void 0 ? ["/" + P.filter] : void 0;
    if (Q({
      data: P.data,
      additionalKeyValues: we,
      alreadyAppliedFilters: be,
      objectId: P.objectId
    }), Y("endobj"), "sMask" in P && P.sMask !== void 0) {
      var ze = "/Predictor " + P.predictor + " /Colors 1 /BitsPerComponent " + P.bitsPerComponent + " /Columns " + P.width, y = {
        width: P.width,
        height: P.height,
        colorSpace: "DeviceGray",
        bitsPerComponent: P.bitsPerComponent,
        decodeParameters: ze,
        data: P.sMask
      };
      "filter" in P && (y.filter = P.filter), F.call(this, y);
    }
    if (P.colorSpace === S.INDEXED) {
      var L = this.internal.newObject();
      Q({
        data: M(new Uint8Array(P.palette)),
        objectId: L
      }), Y("endobj");
    }
  }, a = function() {
    var F = this.internal.collections.addImage_images;
    for (var P in F) i.call(this, F[P]);
  }, s = function() {
    var F, P = this.internal.collections.addImage_images, Y = this.internal.write;
    for (var Q in P) Y("/I" + (F = P[Q]).index, F.objectId, "0", "R");
  }, o = function() {
    this.internal.collections.addImage_images || (this.internal.collections.addImage_images = {}, this.internal.events.subscribe("putResources", a), this.internal.events.subscribe("putXobjectDict", s));
  }, f = function() {
    var F = this.internal.collections.addImage_images;
    return o.call(this), F;
  }, h = function() {
    return Object.keys(this.internal.collections.addImage_images).length;
  }, c = function(F) {
    return typeof r6["process" + F.toUpperCase()] == "function";
  }, p = function(F) {
    return Wt(F) === "object" && F.nodeType === 1;
  }, v = function(F, P) {
    if (F.nodeName === "IMG" && F.hasAttribute("src")) {
      var Y = "" + F.getAttribute("src");
      if (Y.indexOf("data:image/") === 0) return wo(unescape(Y).split("base64,").pop());
      var Q = r6.loadFile(Y, true);
      if (Q !== void 0) return Q;
    }
    if (F.nodeName === "CANVAS") {
      if (F.width === 0 || F.height === 0) throw new Error("Given canvas must have data. Canvas width: " + F.width + ", height: " + F.height);
      var ce;
      switch (P) {
        case "PNG":
          ce = "image/png";
          break;
        case "WEBP":
          ce = "image/webp";
          break;
        case "JPEG":
        case "JPG":
        default:
          ce = "image/jpeg";
      }
      return wo(F.toDataURL(ce, 1).split("base64,").pop());
    }
  }, d = function(F) {
    var P = this.internal.collections.addImage_images;
    if (P) {
      for (var Y in P) if (F === P[Y].alias) return P[Y];
    }
  }, w = function(F, P, Y) {
    return F || P || (F = -96, P = -96), F < 0 && (F = -1 * Y.width * 72 / F / this.internal.scaleFactor), P < 0 && (P = -1 * Y.height * 72 / P / this.internal.scaleFactor), F === 0 && (F = P * Y.width / Y.height), P === 0 && (P = F * Y.height / Y.width), [F, P];
  }, x = function(F, P, Y, Q, ce, we) {
    var Se = w.call(this, Y, Q, ce), de = this.internal.getCoordinateString, Ae = this.internal.getVerticalCoordinateString, be = f.call(this);
    if (Y = Se[0], Q = Se[1], be[ce.index] = ce, we) {
      we *= Math.PI / 180;
      var ze = Math.cos(we), y = Math.sin(we), L = function(C) {
        return C.toFixed(4);
      }, N = [L(ze), L(y), L(-1 * y), L(ze), 0, 0, "cm"];
    }
    this.internal.write("q"), we ? (this.internal.write([1, "0", "0", 1, de(F), Ae(P + Q), "cm"].join(" ")), this.internal.write(N.join(" ")), this.internal.write([de(Y), "0", "0", de(Q), "0", "0", "cm"].join(" "))) : this.internal.write([de(Y), "0", "0", de(Q), de(F), Ae(P + Q), "cm"].join(" ")), this.isAdvancedAPI() && this.internal.write([1, 0, 0, -1, 0, 0, "cm"].join(" ")), this.internal.write("/I" + ce.index + " Do"), this.internal.write("Q");
  }, S = r6.color_spaces = {
    DEVICE_RGB: "DeviceRGB",
    DEVICE_GRAY: "DeviceGray",
    DEVICE_CMYK: "DeviceCMYK",
    CAL_GREY: "CalGray",
    CAL_RGB: "CalRGB",
    LAB: "Lab",
    ICC_BASED: "ICCBased",
    INDEXED: "Indexed",
    PATTERN: "Pattern",
    SEPARATION: "Separation",
    DEVICE_N: "DeviceN"
  };
  r6.decode = {
    DCT_DECODE: "DCTDecode",
    FLATE_DECODE: "FlateDecode",
    LZW_DECODE: "LZWDecode",
    JPX_DECODE: "JPXDecode",
    JBIG2_DECODE: "JBIG2Decode",
    ASCII85_DECODE: "ASCII85Decode",
    ASCII_HEX_DECODE: "ASCIIHexDecode",
    RUN_LENGTH_DECODE: "RunLengthDecode",
    CCITT_FAX_DECODE: "CCITTFaxDecode"
  };
  var A = r6.image_compression = {
    NONE: "NONE",
    FAST: "FAST",
    MEDIUM: "MEDIUM",
    SLOW: "SLOW"
  }, b = r6.__addimage__.sHashCode = function(F) {
    var P, Y, Q = 0;
    if (typeof F == "string") for (Y = F.length, P = 0; P < Y; P++) Q = (Q << 5) - Q + F.charCodeAt(P), Q |= 0;
    else if (le(F)) for (Y = F.byteLength / 2, P = 0; P < Y; P++) Q = (Q << 5) - Q + F[P], Q |= 0;
    return Q;
  }, O = r6.__addimage__.validateStringAsBase64 = function(F) {
    (F = F || "").toString().trim();
    var P = true;
    return F.length === 0 && (P = false), F.length % 4 != 0 && (P = false), /^[A-Za-z0-9+/]+$/.test(F.substr(0, F.length - 2)) === false && (P = false), /^[A-Za-z0-9/][A-Za-z0-9+/]|[A-Za-z0-9+/]=|==$/.test(F.substr(-2)) === false && (P = false), P;
  }, q = r6.__addimage__.extractImageFromDataUrl = function(F) {
    if (F == null || !(F = F.trim()).startsWith("data:")) return null;
    var P = F.indexOf(",");
    return P < 0 ? null : F.substring(0, P).trim().endsWith("base64") ? F.substring(P + 1) : null;
  }, te = r6.__addimage__.supportsArrayBuffer = function() {
    return typeof ArrayBuffer < "u" && typeof Uint8Array < "u";
  };
  r6.__addimage__.isArrayBuffer = function(F) {
    return te() && F instanceof ArrayBuffer;
  };
  var le = r6.__addimage__.isArrayBufferView = function(F) {
    return te() && typeof Uint32Array < "u" && (F instanceof Int8Array || F instanceof Uint8Array || typeof Uint8ClampedArray < "u" && F instanceof Uint8ClampedArray || F instanceof Int16Array || F instanceof Uint16Array || F instanceof Int32Array || F instanceof Uint32Array || F instanceof Float32Array || F instanceof Float64Array);
  }, j = r6.__addimage__.binaryStringToUint8Array = function(F) {
    for (var P = F.length, Y = new Uint8Array(P), Q = 0; Q < P; Q++) Y[Q] = F.charCodeAt(Q);
    return Y;
  }, M = r6.__addimage__.arrayBufferToBinaryString = function(F) {
    for (var P = "", Y = le(F) ? F : new Uint8Array(F), Q = 0; Q < Y.length; Q += 8192) P += String.fromCharCode.apply(null, Y.subarray(Q, Q + 8192));
    return P;
  };
  r6.addImage = function() {
    var F, P, Y, Q, ce, we, Se, de, Ae;
    if (typeof arguments[1] == "number" ? (P = e, Y = arguments[1], Q = arguments[2], ce = arguments[3], we = arguments[4], Se = arguments[5], de = arguments[6], Ae = arguments[7]) : (P = arguments[1], Y = arguments[2], Q = arguments[3], ce = arguments[4], we = arguments[5], Se = arguments[6], de = arguments[7], Ae = arguments[8]), Wt(F = arguments[0]) === "object" && !p(F) && "imageData" in F) {
      var be = F;
      F = be.imageData, P = be.format || P || e, Y = be.x || Y || 0, Q = be.y || Q || 0, ce = be.w || be.width || ce, we = be.h || be.height || we, Se = be.alias || Se, de = be.compression || de, Ae = be.rotation || be.angle || Ae;
    }
    var ze = this.internal.getFilters();
    if (de === void 0 && ze.indexOf("FlateEncode") !== -1 && (de = "SLOW"), isNaN(Y) || isNaN(Q)) throw new Error("Invalid coordinates passed to jsPDF.addImage");
    o.call(this);
    var y = H.call(this, F, P, Se, de);
    return x.call(this, Y, Q, ce, we, y, Ae), this;
  };
  var H = function(F, P, Y, Q) {
    var ce, we, Se;
    if (typeof F == "string" && n(F) === e) {
      F = unescape(F);
      var de = ee(F, false);
      (de !== "" || (de = r6.loadFile(F, true)) !== void 0) && (F = de);
    }
    if (p(F) && (F = v(F, P)), P = n(F, P), !c(P)) throw new Error("addImage does not support files of type '" + P + "', please ensure that a plugin for '" + P + "' support is added.");
    if (((Se = Y) == null || Se.length === 0) && (Y = function(Ae) {
      return typeof Ae == "string" || le(Ae) ? b(Ae) : le(Ae.data) ? b(Ae.data) : null;
    }(F)), (ce = d.call(this, Y)) || (te() && (F instanceof Uint8Array || P === "RGBA" || (we = F, F = j(F))), ce = this["process" + P.toUpperCase()](F, h.call(this), Y, function(Ae) {
      return Ae && typeof Ae == "string" && (Ae = Ae.toUpperCase()), Ae in r6.image_compression ? Ae : A.NONE;
    }(Q), we)), !ce) throw new Error("An unknown error occurred whilst processing the image.");
    return ce;
  }, ee = r6.__addimage__.convertBase64ToBinaryString = function(F, P) {
    P = typeof P != "boolean" || P;
    var Y, Q = "";
    if (typeof F == "string") {
      var ce;
      Y = (ce = q(F)) !== null && ce !== void 0 ? ce : F;
      try {
        Q = wo(Y);
      } catch (we) {
        if (P) throw O(Y) ? new Error("atob-Error in jsPDF.convertBase64ToBinaryString " + we.message) : new Error("Supplied Data is not a valid base64-String jsPDF.convertBase64ToBinaryString ");
      }
    }
    return Q;
  };
  r6.getImageProperties = function(F) {
    var P, Y, Q = "";
    if (p(F) && (F = v(F)), typeof F == "string" && n(F) === e && ((Q = ee(F, false)) === "" && (Q = r6.loadFile(F) || ""), F = Q), Y = n(F), !c(Y)) throw new Error("addImage does not support files of type '" + Y + "', please ensure that a plugin for '" + Y + "' support is added.");
    if (!te() || F instanceof Uint8Array || (F = j(F)), !(P = this["process" + Y.toUpperCase()](F))) throw new Error("An unknown error occurred whilst processing the image");
    return P.fileType = Y, P;
  };
})(ut.API), /**
* @license
* Copyright (c) 2014 Steven Spungin (TwelveTone LLC)  steven@twelvetone.tv
*
* Licensed under the MIT License.
* http://opensource.org/licenses/mit-license
*/
function(r6) {
  var e = function(t) {
    if (t !== void 0 && t != "") return true;
  };
  ut.API.events.push(["addPage", function(t) {
    this.internal.getPageInfo(t.pageNumber).pageContext.annotations = [];
  }]), r6.events.push(["putPage", function(t) {
    for (var n, i, a, s = this.internal.getCoordinateString, o = this.internal.getVerticalCoordinateString, f = this.internal.getPageInfoByObjId(t.objId), h = t.pageContext.annotations, c = false, p = 0; p < h.length && !c; p++) switch ((n = h[p]).type) {
      case "link":
        (e(n.options.url) || e(n.options.pageNumber)) && (c = true);
        break;
      case "reference":
      case "text":
      case "freetext":
        c = true;
    }
    if (c != 0) {
      this.internal.write("/Annots [");
      for (var v = 0; v < h.length; v++) {
        n = h[v];
        var d = this.internal.pdfEscape, w = this.internal.getEncryptor(t.objId);
        switch (n.type) {
          case "reference":
            this.internal.write(" " + n.object.objId + " 0 R ");
            break;
          case "text":
            var x = this.internal.newAdditionalObject(), S = this.internal.newAdditionalObject(), A = this.internal.getEncryptor(x.objId), b = n.title || "Note";
            a = "<</Type /Annot /Subtype /Text " + (i = "/Rect [" + s(n.bounds.x) + " " + o(n.bounds.y + n.bounds.h) + " " + s(n.bounds.x + n.bounds.w) + " " + o(n.bounds.y) + "] ") + "/Contents (" + d(A(n.contents)) + ")", a += " /Popup " + S.objId + " 0 R", a += " /P " + f.objId + " 0 R", a += " /T (" + d(A(b)) + ") >>", x.content = a;
            var O = x.objId + " 0 R";
            a = "<</Type /Annot /Subtype /Popup " + (i = "/Rect [" + s(n.bounds.x + 30) + " " + o(n.bounds.y + n.bounds.h) + " " + s(n.bounds.x + n.bounds.w + 30) + " " + o(n.bounds.y) + "] ") + " /Parent " + O, n.open && (a += " /Open true"), a += " >>", S.content = a, this.internal.write(x.objId, "0 R", S.objId, "0 R");
            break;
          case "freetext":
            i = "/Rect [" + s(n.bounds.x) + " " + o(n.bounds.y) + " " + s(n.bounds.x + n.bounds.w) + " " + o(n.bounds.y + n.bounds.h) + "] ";
            var q = n.color || "#000000";
            a = "<</Type /Annot /Subtype /FreeText " + i + "/Contents (" + d(w(n.contents)) + ")", a += " /DS(font: Helvetica,sans-serif 12.0pt; text-align:left; color:#" + q + ")", a += " /Border [0 0 0]", a += " >>", this.internal.write(a);
            break;
          case "link":
            if (n.options.name) {
              var te = this.annotations._nameMap[n.options.name];
              n.options.pageNumber = te.page, n.options.top = te.y;
            } else n.options.top || (n.options.top = 0);
            if (i = "/Rect [" + n.finalBounds.x + " " + n.finalBounds.y + " " + n.finalBounds.w + " " + n.finalBounds.h + "] ", a = "", n.options.url) a = "<</Type /Annot /Subtype /Link " + i + "/Border [0 0 0] /A <</S /URI /URI (" + d(w(n.options.url)) + ") >>";
            else if (n.options.pageNumber) switch (a = "<</Type /Annot /Subtype /Link " + i + "/Border [0 0 0] /Dest [" + this.internal.getPageInfo(n.options.pageNumber).objId + " 0 R", n.options.magFactor = n.options.magFactor || "XYZ", n.options.magFactor) {
              case "Fit":
                a += " /Fit]";
                break;
              case "FitH":
                a += " /FitH " + n.options.top + "]";
                break;
              case "FitV":
                n.options.left = n.options.left || 0, a += " /FitV " + n.options.left + "]";
                break;
              case "XYZ":
              default:
                var le = o(n.options.top);
                n.options.left = n.options.left || 0, n.options.zoom === void 0 && (n.options.zoom = 0), a += " /XYZ " + n.options.left + " " + le + " " + n.options.zoom + "]";
            }
            a != "" && (a += " >>", this.internal.write(a));
        }
      }
      this.internal.write("]");
    }
  }]), r6.createAnnotation = function(t) {
    var n = this.internal.getCurrentPageInfo();
    switch (t.type) {
      case "link":
        this.link(t.bounds.x, t.bounds.y, t.bounds.w, t.bounds.h, t);
        break;
      case "text":
      case "freetext":
        n.pageContext.annotations.push(t);
    }
  }, r6.link = function(t, n, i, a, s) {
    var o = this.internal.getCurrentPageInfo(), f = this.internal.getCoordinateString, h = this.internal.getVerticalCoordinateString;
    o.pageContext.annotations.push({
      finalBounds: {
        x: f(t),
        y: h(n),
        w: f(t + i),
        h: h(n + a)
      },
      options: s,
      type: "link"
    });
  }, r6.textWithLink = function(t, n, i, a) {
    var s, o, f = this.getTextWidth(t), h = this.internal.getLineHeight() / this.internal.scaleFactor;
    if (a.maxWidth !== void 0) {
      o = a.maxWidth;
      var c = this.splitTextToSize(t, o).length;
      s = Math.ceil(h * c);
    } else o = f, s = h;
    return this.text(t, n, i, a), i += 0.2 * h, a.align === "center" && (n -= f / 2), a.align === "right" && (n -= f), this.link(n, i - h, o, s, a), f;
  }, r6.getTextWidth = function(t) {
    var n = this.internal.getFontSize();
    return this.getStringUnitWidth(t) * n / this.internal.scaleFactor;
  };
}(ut.API), /**
* @license
* Copyright (c) 2017 Aras Abbasi
*
* Licensed under the MIT License.
* http://opensource.org/licenses/mit-license
*/
function(r6) {
  var e = {
    1569: [65152],
    1570: [65153, 65154],
    1571: [65155, 65156],
    1572: [65157, 65158],
    1573: [65159, 65160],
    1574: [65161, 65162, 65163, 65164],
    1575: [65165, 65166],
    1576: [65167, 65168, 65169, 65170],
    1577: [65171, 65172],
    1578: [65173, 65174, 65175, 65176],
    1579: [65177, 65178, 65179, 65180],
    1580: [65181, 65182, 65183, 65184],
    1581: [65185, 65186, 65187, 65188],
    1582: [65189, 65190, 65191, 65192],
    1583: [65193, 65194],
    1584: [65195, 65196],
    1585: [65197, 65198],
    1586: [65199, 65200],
    1587: [65201, 65202, 65203, 65204],
    1588: [65205, 65206, 65207, 65208],
    1589: [65209, 65210, 65211, 65212],
    1590: [65213, 65214, 65215, 65216],
    1591: [65217, 65218, 65219, 65220],
    1592: [65221, 65222, 65223, 65224],
    1593: [65225, 65226, 65227, 65228],
    1594: [65229, 65230, 65231, 65232],
    1601: [65233, 65234, 65235, 65236],
    1602: [65237, 65238, 65239, 65240],
    1603: [65241, 65242, 65243, 65244],
    1604: [65245, 65246, 65247, 65248],
    1605: [65249, 65250, 65251, 65252],
    1606: [65253, 65254, 65255, 65256],
    1607: [65257, 65258, 65259, 65260],
    1608: [65261, 65262],
    1609: [65263, 65264, 64488, 64489],
    1610: [65265, 65266, 65267, 65268],
    1649: [64336, 64337],
    1655: [64477],
    1657: [64358, 64359, 64360, 64361],
    1658: [64350, 64351, 64352, 64353],
    1659: [64338, 64339, 64340, 64341],
    1662: [64342, 64343, 64344, 64345],
    1663: [64354, 64355, 64356, 64357],
    1664: [64346, 64347, 64348, 64349],
    1667: [64374, 64375, 64376, 64377],
    1668: [64370, 64371, 64372, 64373],
    1670: [64378, 64379, 64380, 64381],
    1671: [64382, 64383, 64384, 64385],
    1672: [64392, 64393],
    1676: [64388, 64389],
    1677: [64386, 64387],
    1678: [64390, 64391],
    1681: [64396, 64397],
    1688: [64394, 64395],
    1700: [64362, 64363, 64364, 64365],
    1702: [64366, 64367, 64368, 64369],
    1705: [64398, 64399, 64400, 64401],
    1709: [64467, 64468, 64469, 64470],
    1711: [64402, 64403, 64404, 64405],
    1713: [64410, 64411, 64412, 64413],
    1715: [64406, 64407, 64408, 64409],
    1722: [64414, 64415],
    1723: [64416, 64417, 64418, 64419],
    1726: [64426, 64427, 64428, 64429],
    1728: [64420, 64421],
    1729: [64422, 64423, 64424, 64425],
    1733: [64480, 64481],
    1734: [64473, 64474],
    1735: [64471, 64472],
    1736: [64475, 64476],
    1737: [64482, 64483],
    1739: [64478, 64479],
    1740: [64508, 64509, 64510, 64511],
    1744: [64484, 64485, 64486, 64487],
    1746: [64430, 64431],
    1747: [64432, 64433]
  }, t = {
    65247: {
      65154: 65269,
      65156: 65271,
      65160: 65273,
      65166: 65275
    },
    65248: {
      65154: 65270,
      65156: 65272,
      65160: 65274,
      65166: 65276
    },
    65165: {
      65247: {
        65248: {
          65258: 65010
        }
      }
    },
    1617: {
      1612: 64606,
      1613: 64607,
      1614: 64608,
      1615: 64609,
      1616: 64610
    }
  }, n = {
    1612: 64606,
    1613: 64607,
    1614: 64608,
    1615: 64609,
    1616: 64610
  }, i = [1570, 1571, 1573, 1575];
  r6.__arabicParser__ = {};
  var a = r6.__arabicParser__.isInArabicSubstitutionA = function(x) {
    return e[x.charCodeAt(0)] !== void 0;
  }, s = r6.__arabicParser__.isArabicLetter = function(x) {
    return typeof x == "string" && /^[\u0600-\u06FF\u0750-\u077F\u08A0-\u08FF\uFB50-\uFDFF\uFE70-\uFEFF]+$/.test(x);
  }, o = r6.__arabicParser__.isArabicEndLetter = function(x) {
    return s(x) && a(x) && e[x.charCodeAt(0)].length <= 2;
  }, f = r6.__arabicParser__.isArabicAlfLetter = function(x) {
    return s(x) && i.indexOf(x.charCodeAt(0)) >= 0;
  };
  r6.__arabicParser__.arabicLetterHasIsolatedForm = function(x) {
    return s(x) && a(x) && e[x.charCodeAt(0)].length >= 1;
  };
  var h = r6.__arabicParser__.arabicLetterHasFinalForm = function(x) {
    return s(x) && a(x) && e[x.charCodeAt(0)].length >= 2;
  };
  r6.__arabicParser__.arabicLetterHasInitialForm = function(x) {
    return s(x) && a(x) && e[x.charCodeAt(0)].length >= 3;
  };
  var c = r6.__arabicParser__.arabicLetterHasMedialForm = function(x) {
    return s(x) && a(x) && e[x.charCodeAt(0)].length == 4;
  }, p = r6.__arabicParser__.resolveLigatures = function(x) {
    var S = 0, A = t, b = "", O = 0;
    for (S = 0; S < x.length; S += 1) A[x.charCodeAt(S)] !== void 0 ? (O++, typeof (A = A[x.charCodeAt(S)]) == "number" && (b += String.fromCharCode(A), A = t, O = 0), S === x.length - 1 && (A = t, b += x.charAt(S - (O - 1)), S -= O - 1, O = 0)) : (A = t, b += x.charAt(S - O), S -= O, O = 0);
    return b;
  };
  r6.__arabicParser__.isArabicDiacritic = function(x) {
    return x !== void 0 && n[x.charCodeAt(0)] !== void 0;
  };
  var v = r6.__arabicParser__.getCorrectForm = function(x, S, A) {
    return s(x) ? a(x) === false ? -1 : !h(x) || !s(S) && !s(A) || !s(A) && o(S) || o(x) && !s(S) || o(x) && f(S) || o(x) && o(S) ? 0 : c(x) && s(S) && !o(S) && s(A) && h(A) ? 3 : o(x) || !s(A) ? 1 : 2 : -1;
  }, d = function(x) {
    var S = 0, A = 0, b = 0, O = "", q = "", te = "", le = (x = x || "").split("\\s+"), j = [];
    for (S = 0; S < le.length; S += 1) {
      for (j.push(""), A = 0; A < le[S].length; A += 1) O = le[S][A], q = le[S][A - 1], te = le[S][A + 1], s(O) ? (b = v(O, q, te), j[S] += b !== -1 ? String.fromCharCode(e[O.charCodeAt(0)][b]) : O) : j[S] += O;
      j[S] = p(j[S]);
    }
    return j.join(" ");
  }, w = r6.__arabicParser__.processArabic = r6.processArabic = function() {
    var x, S = typeof arguments[0] == "string" ? arguments[0] : arguments[0].text, A = [];
    if (Array.isArray(S)) {
      var b = 0;
      for (A = [], b = 0; b < S.length; b += 1) Array.isArray(S[b]) ? A.push([d(S[b][0]), S[b][1], S[b][2]]) : A.push([d(S[b])]);
      x = A;
    } else x = d(S);
    return typeof arguments[0] == "string" ? x : (arguments[0].text = x, arguments[0]);
  };
  r6.events.push(["preProcessText", w]);
}(ut.API), ut.API.autoPrint = function(r6) {
  var e;
  switch ((r6 = r6 || {}).variant = r6.variant || "non-conform", r6.variant) {
    case "javascript":
      this.addJS("print({});");
      break;
    case "non-conform":
    default:
      this.internal.events.subscribe("postPutResources", function() {
        e = this.internal.newObject(), this.internal.out("<<"), this.internal.out("/S /Named"), this.internal.out("/Type /Action"), this.internal.out("/N /Print"), this.internal.out(">>"), this.internal.out("endobj");
      }), this.internal.events.subscribe("putCatalog", function() {
        this.internal.out("/OpenAction " + e + " 0 R");
      });
  }
  return this;
}, /**
* @license
* Copyright (c) 2014 Steven Spungin (TwelveTone LLC)  steven@twelvetone.tv
*
* Licensed under the MIT License.
* http://opensource.org/licenses/mit-license
*/
function(r6) {
  var e = function() {
    var t = void 0;
    Object.defineProperty(this, "pdf", {
      get: function() {
        return t;
      },
      set: function(o) {
        t = o;
      }
    });
    var n = 150;
    Object.defineProperty(this, "width", {
      get: function() {
        return n;
      },
      set: function(o) {
        n = isNaN(o) || Number.isInteger(o) === false || o < 0 ? 150 : o, this.getContext("2d").pageWrapXEnabled && (this.getContext("2d").pageWrapX = n + 1);
      }
    });
    var i = 300;
    Object.defineProperty(this, "height", {
      get: function() {
        return i;
      },
      set: function(o) {
        i = isNaN(o) || Number.isInteger(o) === false || o < 0 ? 300 : o, this.getContext("2d").pageWrapYEnabled && (this.getContext("2d").pageWrapY = i + 1);
      }
    });
    var a = [];
    Object.defineProperty(this, "childNodes", {
      get: function() {
        return a;
      },
      set: function(o) {
        a = o;
      }
    });
    var s = {};
    Object.defineProperty(this, "style", {
      get: function() {
        return s;
      },
      set: function(o) {
        s = o;
      }
    }), Object.defineProperty(this, "parentNode", {});
  };
  e.prototype.getContext = function(t, n) {
    var i;
    if ((t = t || "2d") !== "2d") return null;
    for (i in n) this.pdf.context2d.hasOwnProperty(i) && (this.pdf.context2d[i] = n[i]);
    return this.pdf.context2d._canvas = this, this.pdf.context2d;
  }, e.prototype.toDataURL = function() {
    throw new Error("toDataURL is not implemented.");
  }, r6.events.push(["initialized", function() {
    this.canvas = new e(), this.canvas.pdf = this;
  }]);
}(ut.API), function(r6) {
  var e = {
    left: 0,
    top: 0,
    bottom: 0,
    right: 0
  }, t = false, n = function() {
    this.internal.__cell__ === void 0 && (this.internal.__cell__ = {}, this.internal.__cell__.padding = 3, this.internal.__cell__.headerFunction = void 0, this.internal.__cell__.margins = Object.assign({}, e), this.internal.__cell__.margins.width = this.getPageWidth(), i.call(this));
  }, i = function() {
    this.internal.__cell__.lastCell = new a(), this.internal.__cell__.pages = 1;
  }, a = function() {
    var f = arguments[0];
    Object.defineProperty(this, "x", {
      enumerable: true,
      get: function() {
        return f;
      },
      set: function(x) {
        f = x;
      }
    });
    var h = arguments[1];
    Object.defineProperty(this, "y", {
      enumerable: true,
      get: function() {
        return h;
      },
      set: function(x) {
        h = x;
      }
    });
    var c = arguments[2];
    Object.defineProperty(this, "width", {
      enumerable: true,
      get: function() {
        return c;
      },
      set: function(x) {
        c = x;
      }
    });
    var p = arguments[3];
    Object.defineProperty(this, "height", {
      enumerable: true,
      get: function() {
        return p;
      },
      set: function(x) {
        p = x;
      }
    });
    var v = arguments[4];
    Object.defineProperty(this, "text", {
      enumerable: true,
      get: function() {
        return v;
      },
      set: function(x) {
        v = x;
      }
    });
    var d = arguments[5];
    Object.defineProperty(this, "lineNumber", {
      enumerable: true,
      get: function() {
        return d;
      },
      set: function(x) {
        d = x;
      }
    });
    var w = arguments[6];
    return Object.defineProperty(this, "align", {
      enumerable: true,
      get: function() {
        return w;
      },
      set: function(x) {
        w = x;
      }
    }), this;
  };
  a.prototype.clone = function() {
    return new a(this.x, this.y, this.width, this.height, this.text, this.lineNumber, this.align);
  }, a.prototype.toArray = function() {
    return [this.x, this.y, this.width, this.height, this.text, this.lineNumber, this.align];
  }, r6.setHeaderFunction = function(f) {
    return n.call(this), this.internal.__cell__.headerFunction = typeof f == "function" ? f : void 0, this;
  }, r6.getTextDimensions = function(f, h) {
    n.call(this);
    var c = (h = h || {}).fontSize || this.getFontSize(), p = h.font || this.getFont(), v = h.scaleFactor || this.internal.scaleFactor, d = 0, w = 0, x = 0, S = this;
    if (!Array.isArray(f) && typeof f != "string") {
      if (typeof f != "number") throw new Error("getTextDimensions expects text-parameter to be of type String or type Number or an Array of Strings.");
      f = String(f);
    }
    var A = h.maxWidth;
    A > 0 ? typeof f == "string" ? f = this.splitTextToSize(f, A) : Object.prototype.toString.call(f) === "[object Array]" && (f = f.reduce(function(O, q) {
      return O.concat(S.splitTextToSize(q, A));
    }, [])) : f = Array.isArray(f) ? f : [f];
    for (var b = 0; b < f.length; b++) d < (x = this.getStringUnitWidth(f[b], {
      font: p
    }) * c) && (d = x);
    return d !== 0 && (w = f.length), {
      w: d /= v,
      h: Math.max((w * c * this.getLineHeightFactor() - c * (this.getLineHeightFactor() - 1)) / v, 0)
    };
  }, r6.cellAddPage = function() {
    n.call(this), this.addPage();
    var f = this.internal.__cell__.margins || e;
    return this.internal.__cell__.lastCell = new a(f.left, f.top, void 0, void 0), this.internal.__cell__.pages += 1, this;
  };
  var s = r6.cell = function() {
    var f;
    f = arguments[0] instanceof a ? arguments[0] : new a(arguments[0], arguments[1], arguments[2], arguments[3], arguments[4], arguments[5]), n.call(this);
    var h = this.internal.__cell__.lastCell, c = this.internal.__cell__.padding, p = this.internal.__cell__.margins || e, v = this.internal.__cell__.tableHeaderRow, d = this.internal.__cell__.printHeaders;
    return h.lineNumber !== void 0 && (h.lineNumber === f.lineNumber ? (f.x = (h.x || 0) + (h.width || 0), f.y = h.y || 0) : h.y + h.height + f.height + p.bottom > this.getPageHeight() ? (this.cellAddPage(), f.y = p.top, d && v && (this.printHeaderRow(f.lineNumber, true), f.y += v[0].height)) : f.y = h.y + h.height || f.y), f.text[0] !== void 0 && (this.rect(f.x, f.y, f.width, f.height, t === true ? "FD" : void 0), f.align === "right" ? this.text(f.text, f.x + f.width - c, f.y + c, {
      align: "right",
      baseline: "top"
    }) : f.align === "center" ? this.text(f.text, f.x + f.width / 2, f.y + c, {
      align: "center",
      baseline: "top",
      maxWidth: f.width - c - c
    }) : this.text(f.text, f.x + c, f.y + c, {
      align: "left",
      baseline: "top",
      maxWidth: f.width - c - c
    })), this.internal.__cell__.lastCell = f, this;
  };
  r6.table = function(f, h, c, p, v) {
    if (n.call(this), !c) throw new Error("No data for PDF table.");
    var d, w, x, S, A = [], b = [], O = [], q = {}, te = {}, le = [], j = [], M = (v = v || {}).autoSize || false, H = v.printHeaders !== false, ee = v.css && v.css["font-size"] !== void 0 ? 16 * v.css["font-size"] : v.fontSize || 12, F = v.margins || Object.assign({
      width: this.getPageWidth()
    }, e), P = typeof v.padding == "number" ? v.padding : 3, Y = v.headerBackgroundColor || "#c8c8c8", Q = v.headerTextColor || "#000";
    if (i.call(this), this.internal.__cell__.printHeaders = H, this.internal.__cell__.margins = F, this.internal.__cell__.table_font_size = ee, this.internal.__cell__.padding = P, this.internal.__cell__.headerBackgroundColor = Y, this.internal.__cell__.headerTextColor = Q, this.setFontSize(ee), p == null) b = A = Object.keys(c[0]), O = A.map(function() {
      return "left";
    });
    else if (Array.isArray(p) && Wt(p[0]) === "object") for (A = p.map(function(be) {
      return be.name;
    }), b = p.map(function(be) {
      return be.prompt || be.name || "";
    }), O = p.map(function(be) {
      return be.align || "left";
    }), d = 0; d < p.length; d += 1) te[p[d].name] = p[d].width * (19.049976 / 25.4);
    else Array.isArray(p) && typeof p[0] == "string" && (b = A = p, O = A.map(function() {
      return "left";
    }));
    if (M || Array.isArray(p) && typeof p[0] == "string") for (d = 0; d < A.length; d += 1) {
      for (q[S = A[d]] = c.map(function(be) {
        return be[S];
      }), this.setFont(void 0, "bold"), le.push(this.getTextDimensions(b[d], {
        fontSize: this.internal.__cell__.table_font_size,
        scaleFactor: this.internal.scaleFactor
      }).w), w = q[S], this.setFont(void 0, "normal"), x = 0; x < w.length; x += 1) le.push(this.getTextDimensions(w[x], {
        fontSize: this.internal.__cell__.table_font_size,
        scaleFactor: this.internal.scaleFactor
      }).w);
      te[S] = Math.max.apply(null, le) + P + P, le = [];
    }
    if (H) {
      var ce = {};
      for (d = 0; d < A.length; d += 1) ce[A[d]] = {}, ce[A[d]].text = b[d], ce[A[d]].align = O[d];
      var we = o.call(this, ce, te);
      j = A.map(function(be) {
        return new a(f, h, te[be], we, ce[be].text, void 0, ce[be].align);
      }), this.setTableHeaderRow(j), this.printHeaderRow(1, false);
    }
    var Se = p.reduce(function(be, ze) {
      return be[ze.name] = ze.align, be;
    }, {});
    for (d = 0; d < c.length; d += 1) {
      "rowStart" in v && v.rowStart instanceof Function && v.rowStart({
        row: d,
        data: c[d]
      }, this);
      var de = o.call(this, c[d], te);
      for (x = 0; x < A.length; x += 1) {
        var Ae = c[d][A[x]];
        "cellStart" in v && v.cellStart instanceof Function && v.cellStart({
          row: d,
          col: x,
          data: Ae
        }, this), s.call(this, new a(f, h, te[A[x]], de, Ae, d + 2, Se[A[x]]));
      }
    }
    return this.internal.__cell__.table_x = f, this.internal.__cell__.table_y = h, this;
  };
  var o = function(f, h) {
    var c = this.internal.__cell__.padding, p = this.internal.__cell__.table_font_size, v = this.internal.scaleFactor;
    return Object.keys(f).map(function(d) {
      var w = f[d];
      return this.splitTextToSize(w.hasOwnProperty("text") ? w.text : w, h[d] - c - c);
    }, this).map(function(d) {
      return this.getLineHeightFactor() * d.length * p / v + c + c;
    }, this).reduce(function(d, w) {
      return Math.max(d, w);
    }, 0);
  };
  r6.setTableHeaderRow = function(f) {
    n.call(this), this.internal.__cell__.tableHeaderRow = f;
  }, r6.printHeaderRow = function(f, h) {
    if (n.call(this), !this.internal.__cell__.tableHeaderRow) throw new Error("Property tableHeaderRow does not exist.");
    var c;
    if (t = true, typeof this.internal.__cell__.headerFunction == "function") {
      var p = this.internal.__cell__.headerFunction(this, this.internal.__cell__.pages);
      this.internal.__cell__.lastCell = new a(p[0], p[1], p[2], p[3], void 0, -1);
    }
    this.setFont(void 0, "bold");
    for (var v = [], d = 0; d < this.internal.__cell__.tableHeaderRow.length; d += 1) {
      c = this.internal.__cell__.tableHeaderRow[d].clone(), h && (c.y = this.internal.__cell__.margins.top || 0, v.push(c)), c.lineNumber = f;
      var w = this.getTextColor();
      this.setTextColor(this.internal.__cell__.headerTextColor), this.setFillColor(this.internal.__cell__.headerBackgroundColor), s.call(this, c), this.setTextColor(w);
    }
    v.length > 0 && this.setTableHeaderRow(v), this.setFont(void 0, "normal"), t = false;
  };
}(ut.API);
var V1 = {
  italic: ["italic", "oblique", "normal"],
  oblique: ["oblique", "italic", "normal"],
  normal: ["normal", "oblique", "italic"]
};
var G1 = ["ultra-condensed", "extra-condensed", "condensed", "semi-condensed", "normal", "semi-expanded", "expanded", "extra-expanded", "ultra-expanded"];
var Cl = z1(G1);
var X1 = [100, 200, 300, 400, 500, 600, 700, 800, 900];
var g3 = z1(X1);
function Pl(r6) {
  var e = r6.family.replace(/"|'/g, "").toLowerCase(), t = function(a) {
    return V1[a = a || "normal"] ? a : "normal";
  }(r6.style), n = function(a) {
    if (!a) return 400;
    if (typeof a == "number") return a >= 100 && a <= 900 && a % 100 == 0 ? a : 400;
    if (/^\d00$/.test(a)) return parseInt(a);
    switch (a) {
      case "bold":
        return 700;
      case "normal":
      default:
        return 400;
    }
  }(r6.weight), i = function(a) {
    return typeof Cl[a = a || "normal"] == "number" ? a : "normal";
  }(r6.stretch);
  return {
    family: e,
    style: t,
    weight: n,
    stretch: i,
    src: r6.src || [],
    ref: r6.ref || {
      name: e,
      style: [i, t, n].join(" ")
    }
  };
}
function Lc(r6, e, t, n) {
  var i;
  for (i = t; i >= 0 && i < e.length; i += n) if (r6[e[i]]) return r6[e[i]];
  for (i = t; i >= 0 && i < e.length; i -= n) if (r6[e[i]]) return r6[e[i]];
}
var v3 = {
  "sans-serif": "helvetica",
  fixed: "courier",
  monospace: "courier",
  terminal: "courier",
  cursive: "times",
  fantasy: "times",
  serif: "times"
};
var Cc = {
  caption: "times",
  icon: "times",
  menu: "times",
  "message-box": "times",
  "small-caption": "times",
  "status-bar": "times"
};
function Pc(r6) {
  return [r6.stretch, r6.style, r6.weight, r6.family].join(" ");
}
function m3(r6, e, t) {
  for (var n = (t = t || {}).defaultFontFamily || "times", i = Object.assign({}, v3, t.genericFontFamilies || {}), a = null, s = null, o = 0; o < e.length; ++o) if (i[(a = Pl(e[o])).family] && (a.family = i[a.family]), r6.hasOwnProperty(a.family)) {
    s = r6[a.family];
    break;
  }
  if (!(s = s || r6[n])) throw new Error("Could not find a font-family for the rule '" + Pc(a) + "' and default family '" + n + "'.");
  if (s = function(f, h) {
    if (h[f]) return h[f];
    var c = Cl[f], p = c <= Cl.normal ? -1 : 1, v = Lc(h, G1, c, p);
    if (!v) throw new Error("Could not find a matching font-stretch value for " + f);
    return v;
  }(a.stretch, s), s = function(f, h) {
    if (h[f]) return h[f];
    for (var c = V1[f], p = 0; p < c.length; ++p) if (h[c[p]]) return h[c[p]];
    throw new Error("Could not find a matching font-style for " + f);
  }(a.style, s), !(s = function(f, h) {
    if (h[f]) return h[f];
    if (f === 400 && h[500]) return h[500];
    if (f === 500 && h[400]) return h[400];
    var c = g3[f], p = Lc(h, X1, c, f < 400 ? -1 : 1);
    if (!p) throw new Error("Could not find a matching font-weight for value " + f);
    return p;
  }(a.weight, s))) throw new Error("Failed to resolve a font for the rule '" + Pc(a) + "'.");
  return s;
}
function kc(r6) {
  return r6.trimLeft();
}
function x3(r6, e) {
  for (var t = 0; t < r6.length; ) {
    if (r6.charAt(t) === e) return [r6.substring(0, t), r6.substring(t + 1)];
    t += 1;
  }
  return null;
}
function w3(r6) {
  var e = r6.match(/^(-[a-z_]|[a-z_])[a-z0-9_-]*/i);
  return e === null ? null : [e[0], r6.substring(e[0].length)];
}
var P0;
var Dc;
var Oc;
var cl = ["times"];
(function(r6) {
  var e, t, n, i, a, s, o, f, h, c = function(y) {
    return y = y || {}, this.isStrokeTransparent = y.isStrokeTransparent || false, this.strokeOpacity = y.strokeOpacity || 1, this.strokeStyle = y.strokeStyle || "#000000", this.fillStyle = y.fillStyle || "#000000", this.isFillTransparent = y.isFillTransparent || false, this.fillOpacity = y.fillOpacity || 1, this.font = y.font || "10px sans-serif", this.textBaseline = y.textBaseline || "alphabetic", this.textAlign = y.textAlign || "left", this.lineWidth = y.lineWidth || 1, this.lineJoin = y.lineJoin || "miter", this.lineCap = y.lineCap || "butt", this.path = y.path || [], this.transform = y.transform !== void 0 ? y.transform.clone() : new f(), this.globalCompositeOperation = y.globalCompositeOperation || "normal", this.globalAlpha = y.globalAlpha || 1, this.clip_path = y.clip_path || [], this.currentPoint = y.currentPoint || new s(), this.miterLimit = y.miterLimit || 10, this.lastPoint = y.lastPoint || new s(), this.lineDashOffset = y.lineDashOffset || 0, this.lineDash = y.lineDash || [], this.margin = y.margin || [0, 0, 0, 0], this.prevPageLastElemOffset = y.prevPageLastElemOffset || 0, this.ignoreClearRect = typeof y.ignoreClearRect != "boolean" || y.ignoreClearRect, this;
  };
  r6.events.push(["initialized", function() {
    this.context2d = new p(this), e = this.internal.f2, t = this.internal.getCoordinateString, n = this.internal.getVerticalCoordinateString, i = this.internal.getHorizontalCoordinate, a = this.internal.getVerticalCoordinate, s = this.internal.Point, o = this.internal.Rectangle, f = this.internal.Matrix, h = new c();
  }]);
  var p = function(y) {
    Object.defineProperty(this, "canvas", {
      get: function() {
        return {
          parentNode: false,
          style: false
        };
      }
    });
    var L = y;
    Object.defineProperty(this, "pdf", {
      get: function() {
        return L;
      }
    });
    var N = false;
    Object.defineProperty(this, "pageWrapXEnabled", {
      get: function() {
        return N;
      },
      set: function(Te) {
        N = !!Te;
      }
    });
    var C = false;
    Object.defineProperty(this, "pageWrapYEnabled", {
      get: function() {
        return C;
      },
      set: function(Te) {
        C = !!Te;
      }
    });
    var z = 0;
    Object.defineProperty(this, "posX", {
      get: function() {
        return z;
      },
      set: function(Te) {
        isNaN(Te) || (z = Te);
      }
    });
    var re = 0;
    Object.defineProperty(this, "posY", {
      get: function() {
        return re;
      },
      set: function(Te) {
        isNaN(Te) || (re = Te);
      }
    }), Object.defineProperty(this, "margin", {
      get: function() {
        return h.margin;
      },
      set: function(Te) {
        var Z;
        typeof Te == "number" ? Z = [Te, Te, Te, Te] : ((Z = new Array(4))[0] = Te[0], Z[1] = Te.length >= 2 ? Te[1] : Z[0], Z[2] = Te.length >= 3 ? Te[2] : Z[0], Z[3] = Te.length >= 4 ? Te[3] : Z[1]), h.margin = Z;
      }
    });
    var se = false;
    Object.defineProperty(this, "autoPaging", {
      get: function() {
        return se;
      },
      set: function(Te) {
        se = Te;
      }
    });
    var ie = 0;
    Object.defineProperty(this, "lastBreak", {
      get: function() {
        return ie;
      },
      set: function(Te) {
        ie = Te;
      }
    });
    var ve = [];
    Object.defineProperty(this, "pageBreaks", {
      get: function() {
        return ve;
      },
      set: function(Te) {
        ve = Te;
      }
    }), Object.defineProperty(this, "ctx", {
      get: function() {
        return h;
      },
      set: function(Te) {
        Te instanceof c && (h = Te);
      }
    }), Object.defineProperty(this, "path", {
      get: function() {
        return h.path;
      },
      set: function(Te) {
        h.path = Te;
      }
    });
    var Ce = [];
    Object.defineProperty(this, "ctxStack", {
      get: function() {
        return Ce;
      },
      set: function(Te) {
        Ce = Te;
      }
    }), Object.defineProperty(this, "fillStyle", {
      get: function() {
        return this.ctx.fillStyle;
      },
      set: function(Te) {
        var Z;
        Z = v(Te), this.ctx.fillStyle = Z.style, this.ctx.isFillTransparent = Z.a === 0, this.ctx.fillOpacity = Z.a, this.pdf.setFillColor(Z.r, Z.g, Z.b, {
          a: Z.a
        }), this.pdf.setTextColor(Z.r, Z.g, Z.b, {
          a: Z.a
        });
      }
    }), Object.defineProperty(this, "strokeStyle", {
      get: function() {
        return this.ctx.strokeStyle;
      },
      set: function(Te) {
        var Z = v(Te);
        this.ctx.strokeStyle = Z.style, this.ctx.isStrokeTransparent = Z.a === 0, this.ctx.strokeOpacity = Z.a, Z.a === 0 ? this.pdf.setDrawColor(255, 255, 255) : (Z.a, this.pdf.setDrawColor(Z.r, Z.g, Z.b));
      }
    }), Object.defineProperty(this, "lineCap", {
      get: function() {
        return this.ctx.lineCap;
      },
      set: function(Te) {
        ["butt", "round", "square"].indexOf(Te) !== -1 && (this.ctx.lineCap = Te, this.pdf.setLineCap(Te));
      }
    }), Object.defineProperty(this, "lineWidth", {
      get: function() {
        return this.ctx.lineWidth;
      },
      set: function(Te) {
        isNaN(Te) || (this.ctx.lineWidth = Te, this.pdf.setLineWidth(Te));
      }
    }), Object.defineProperty(this, "lineJoin", {
      get: function() {
        return this.ctx.lineJoin;
      },
      set: function(Te) {
        ["bevel", "round", "miter"].indexOf(Te) !== -1 && (this.ctx.lineJoin = Te, this.pdf.setLineJoin(Te));
      }
    }), Object.defineProperty(this, "miterLimit", {
      get: function() {
        return this.ctx.miterLimit;
      },
      set: function(Te) {
        isNaN(Te) || (this.ctx.miterLimit = Te, this.pdf.setMiterLimit(Te));
      }
    }), Object.defineProperty(this, "textBaseline", {
      get: function() {
        return this.ctx.textBaseline;
      },
      set: function(Te) {
        this.ctx.textBaseline = Te;
      }
    }), Object.defineProperty(this, "textAlign", {
      get: function() {
        return this.ctx.textAlign;
      },
      set: function(Te) {
        ["right", "end", "center", "left", "start"].indexOf(Te) !== -1 && (this.ctx.textAlign = Te);
      }
    });
    var Oe = null;
    function qe(Te, Z) {
      if (Oe === null) {
        var Ie = function(rt) {
          var Be = [];
          return Object.keys(rt).forEach(function(We) {
            rt[We].forEach(function($e) {
              var Je = null;
              switch ($e) {
                case "bold":
                  Je = {
                    family: We,
                    weight: "bold"
                  };
                  break;
                case "italic":
                  Je = {
                    family: We,
                    style: "italic"
                  };
                  break;
                case "bolditalic":
                  Je = {
                    family: We,
                    weight: "bold",
                    style: "italic"
                  };
                  break;
                case "":
                case "normal":
                  Je = {
                    family: We
                  };
              }
              Je !== null && (Je.ref = {
                name: We,
                style: $e
              }, Be.push(Je));
            });
          }), Be;
        }(Te.getFontList());
        Oe = function(rt) {
          for (var Be = {}, We = 0; We < rt.length; ++We) {
            var $e = Pl(rt[We]), Je = $e.family, st = $e.stretch, ot = $e.style, gt = $e.weight;
            Be[Je] = Be[Je] || {}, Be[Je][st] = Be[Je][st] || {}, Be[Je][st][ot] = Be[Je][st][ot] || {}, Be[Je][st][ot][gt] = $e;
          }
          return Be;
        }(Ie.concat(Z));
      }
      return Oe;
    }
    var Ye = null;
    Object.defineProperty(this, "fontFaces", {
      get: function() {
        return Ye;
      },
      set: function(Te) {
        Oe = null, Ye = Te;
      }
    }), Object.defineProperty(this, "font", {
      get: function() {
        return this.ctx.font;
      },
      set: function(Te) {
        var Z;
        if (this.ctx.font = Te, (Z = /^\s*(?=(?:(?:[-a-z]+\s*){0,2}(italic|oblique))?)(?=(?:(?:[-a-z]+\s*){0,2}(small-caps))?)(?=(?:(?:[-a-z]+\s*){0,2}(bold(?:er)?|lighter|[1-9]00))?)(?:(?:normal|\1|\2|\3)\s*){0,3}((?:xx?-)?(?:small|large)|medium|smaller|larger|[.\d]+(?:\%|in|[cem]m|ex|p[ctx]))(?:\s*\/\s*(normal|[.\d]+(?:\%|in|[cem]m|ex|p[ctx])))?\s*([-_,\"\'\sa-z]+?)\s*$/i.exec(Te)) !== null) {
          var Ie = Z[1];
          Z[2];
          var rt = Z[3], Be = Z[4];
          Z[5];
          var We = Z[6], $e = /^([.\d]+)((?:%|in|[cem]m|ex|p[ctx]))$/i.exec(Be)[2];
          Be = Math.floor($e === "px" ? parseFloat(Be) * this.pdf.internal.scaleFactor : $e === "em" ? parseFloat(Be) * this.pdf.getFontSize() : parseFloat(Be) * this.pdf.internal.scaleFactor), this.pdf.setFontSize(Be);
          var Je = function(ct) {
            var At, Qe, br = [], Ft = ct.trim();
            if (Ft === "") return cl;
            if (Ft in Cc) return [Cc[Ft]];
            for (; Ft !== ""; ) {
              switch (Qe = null, At = (Ft = kc(Ft)).charAt(0)) {
                case '"':
                case "'":
                  Qe = x3(Ft.substring(1), At);
                  break;
                default:
                  Qe = w3(Ft);
              }
              if (Qe === null || (br.push(Qe[0]), (Ft = kc(Qe[1])) !== "" && Ft.charAt(0) !== ",")) return cl;
              Ft = Ft.replace(/^,/, "");
            }
            return br;
          }(We);
          if (this.fontFaces) {
            var st = m3(qe(this.pdf, this.fontFaces), Je.map(function(ct) {
              return {
                family: ct,
                stretch: "normal",
                weight: rt,
                style: Ie
              };
            }));
            this.pdf.setFont(st.ref.name, st.ref.style);
          } else {
            var ot = "";
            (rt === "bold" || parseInt(rt, 10) >= 700 || Ie === "bold") && (ot = "bold"), Ie === "italic" && (ot += "italic"), ot.length === 0 && (ot = "normal");
            for (var gt = "", _t = {
              arial: "Helvetica",
              Arial: "Helvetica",
              verdana: "Helvetica",
              Verdana: "Helvetica",
              helvetica: "Helvetica",
              Helvetica: "Helvetica",
              "sans-serif": "Helvetica",
              fixed: "Courier",
              monospace: "Courier",
              terminal: "Courier",
              cursive: "Times",
              fantasy: "Times",
              serif: "Times"
            }, Tt = 0; Tt < Je.length; Tt++) {
              if (this.pdf.internal.getFont(Je[Tt], ot, {
                noFallback: true,
                disableWarning: true
              }) !== void 0) {
                gt = Je[Tt];
                break;
              }
              if (ot === "bolditalic" && this.pdf.internal.getFont(Je[Tt], "bold", {
                noFallback: true,
                disableWarning: true
              }) !== void 0) gt = Je[Tt], ot = "bold";
              else if (this.pdf.internal.getFont(Je[Tt], "normal", {
                noFallback: true,
                disableWarning: true
              }) !== void 0) {
                gt = Je[Tt], ot = "normal";
                break;
              }
            }
            if (gt === "") {
              for (var Et = 0; Et < Je.length; Et++) if (_t[Je[Et]]) {
                gt = _t[Je[Et]];
                break;
              }
            }
            gt = gt === "" ? "Times" : gt, this.pdf.setFont(gt, ot);
          }
        }
      }
    }), Object.defineProperty(this, "globalCompositeOperation", {
      get: function() {
        return this.ctx.globalCompositeOperation;
      },
      set: function(Te) {
        this.ctx.globalCompositeOperation = Te;
      }
    }), Object.defineProperty(this, "globalAlpha", {
      get: function() {
        return this.ctx.globalAlpha;
      },
      set: function(Te) {
        this.ctx.globalAlpha = Te;
      }
    }), Object.defineProperty(this, "lineDashOffset", {
      get: function() {
        return this.ctx.lineDashOffset;
      },
      set: function(Te) {
        this.ctx.lineDashOffset = Te, ze.call(this);
      }
    }), Object.defineProperty(this, "lineDash", {
      get: function() {
        return this.ctx.lineDash;
      },
      set: function(Te) {
        this.ctx.lineDash = Te, ze.call(this);
      }
    }), Object.defineProperty(this, "ignoreClearRect", {
      get: function() {
        return this.ctx.ignoreClearRect;
      },
      set: function(Te) {
        this.ctx.ignoreClearRect = !!Te;
      }
    });
  };
  p.prototype.setLineDash = function(y) {
    this.lineDash = y;
  }, p.prototype.getLineDash = function() {
    return this.lineDash.length % 2 ? this.lineDash.concat(this.lineDash) : this.lineDash.slice();
  }, p.prototype.fill = function() {
    q.call(this, "fill", false);
  }, p.prototype.stroke = function() {
    q.call(this, "stroke", false);
  }, p.prototype.beginPath = function() {
    this.path = [{
      type: "begin"
    }];
  }, p.prototype.moveTo = function(y, L) {
    if (isNaN(y) || isNaN(L)) throw Kt.error("jsPDF.context2d.moveTo: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.moveTo");
    var N = this.ctx.transform.applyToPoint(new s(y, L));
    this.path.push({
      type: "mt",
      x: N.x,
      y: N.y
    }), this.ctx.lastPoint = new s(y, L);
  }, p.prototype.closePath = function() {
    var y = new s(0, 0), L = 0;
    for (L = this.path.length - 1; L !== -1; L--) if (this.path[L].type === "begin" && Wt(this.path[L + 1]) === "object" && typeof this.path[L + 1].x == "number") {
      y = new s(this.path[L + 1].x, this.path[L + 1].y);
      break;
    }
    this.path.push({
      type: "close"
    }), this.ctx.lastPoint = new s(y.x, y.y);
  }, p.prototype.lineTo = function(y, L) {
    if (isNaN(y) || isNaN(L)) throw Kt.error("jsPDF.context2d.lineTo: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.lineTo");
    var N = this.ctx.transform.applyToPoint(new s(y, L));
    this.path.push({
      type: "lt",
      x: N.x,
      y: N.y
    }), this.ctx.lastPoint = new s(N.x, N.y);
  }, p.prototype.clip = function() {
    this.ctx.clip_path = JSON.parse(JSON.stringify(this.path)), q.call(this, null, true);
  }, p.prototype.quadraticCurveTo = function(y, L, N, C) {
    if (isNaN(N) || isNaN(C) || isNaN(y) || isNaN(L)) throw Kt.error("jsPDF.context2d.quadraticCurveTo: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.quadraticCurveTo");
    var z = this.ctx.transform.applyToPoint(new s(N, C)), re = this.ctx.transform.applyToPoint(new s(y, L));
    this.path.push({
      type: "qct",
      x1: re.x,
      y1: re.y,
      x: z.x,
      y: z.y
    }), this.ctx.lastPoint = new s(z.x, z.y);
  }, p.prototype.bezierCurveTo = function(y, L, N, C, z, re) {
    if (isNaN(z) || isNaN(re) || isNaN(y) || isNaN(L) || isNaN(N) || isNaN(C)) throw Kt.error("jsPDF.context2d.bezierCurveTo: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.bezierCurveTo");
    var se = this.ctx.transform.applyToPoint(new s(z, re)), ie = this.ctx.transform.applyToPoint(new s(y, L)), ve = this.ctx.transform.applyToPoint(new s(N, C));
    this.path.push({
      type: "bct",
      x1: ie.x,
      y1: ie.y,
      x2: ve.x,
      y2: ve.y,
      x: se.x,
      y: se.y
    }), this.ctx.lastPoint = new s(se.x, se.y);
  }, p.prototype.arc = function(y, L, N, C, z, re) {
    if (isNaN(y) || isNaN(L) || isNaN(N) || isNaN(C) || isNaN(z)) throw Kt.error("jsPDF.context2d.arc: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.arc");
    if (re = !!re, !this.ctx.transform.isIdentity) {
      var se = this.ctx.transform.applyToPoint(new s(y, L));
      y = se.x, L = se.y;
      var ie = this.ctx.transform.applyToPoint(new s(0, N)), ve = this.ctx.transform.applyToPoint(new s(0, 0));
      N = Math.sqrt(Math.pow(ie.x - ve.x, 2) + Math.pow(ie.y - ve.y, 2));
    }
    Math.abs(z - C) >= 2 * Math.PI && (C = 0, z = 2 * Math.PI), this.path.push({
      type: "arc",
      x: y,
      y: L,
      radius: N,
      startAngle: C,
      endAngle: z,
      counterclockwise: re
    });
  }, p.prototype.arcTo = function(y, L, N, C, z) {
    throw new Error("arcTo not implemented.");
  }, p.prototype.rect = function(y, L, N, C) {
    if (isNaN(y) || isNaN(L) || isNaN(N) || isNaN(C)) throw Kt.error("jsPDF.context2d.rect: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.rect");
    this.moveTo(y, L), this.lineTo(y + N, L), this.lineTo(y + N, L + C), this.lineTo(y, L + C), this.lineTo(y, L), this.lineTo(y + N, L), this.lineTo(y, L);
  }, p.prototype.fillRect = function(y, L, N, C) {
    if (isNaN(y) || isNaN(L) || isNaN(N) || isNaN(C)) throw Kt.error("jsPDF.context2d.fillRect: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.fillRect");
    if (!d.call(this)) {
      var z = {};
      this.lineCap !== "butt" && (z.lineCap = this.lineCap, this.lineCap = "butt"), this.lineJoin !== "miter" && (z.lineJoin = this.lineJoin, this.lineJoin = "miter"), this.beginPath(), this.rect(y, L, N, C), this.fill(), z.hasOwnProperty("lineCap") && (this.lineCap = z.lineCap), z.hasOwnProperty("lineJoin") && (this.lineJoin = z.lineJoin);
    }
  }, p.prototype.strokeRect = function(y, L, N, C) {
    if (isNaN(y) || isNaN(L) || isNaN(N) || isNaN(C)) throw Kt.error("jsPDF.context2d.strokeRect: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.strokeRect");
    w.call(this) || (this.beginPath(), this.rect(y, L, N, C), this.stroke());
  }, p.prototype.clearRect = function(y, L, N, C) {
    if (isNaN(y) || isNaN(L) || isNaN(N) || isNaN(C)) throw Kt.error("jsPDF.context2d.clearRect: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.clearRect");
    this.ignoreClearRect || (this.fillStyle = "#ffffff", this.fillRect(y, L, N, C));
  }, p.prototype.save = function(y) {
    y = typeof y != "boolean" || y;
    for (var L = this.pdf.internal.getCurrentPageInfo().pageNumber, N = 0; N < this.pdf.internal.getNumberOfPages(); N++) this.pdf.setPage(N + 1), this.pdf.internal.out("q");
    if (this.pdf.setPage(L), y) {
      this.ctx.fontSize = this.pdf.internal.getFontSize();
      var C = new c(this.ctx);
      this.ctxStack.push(this.ctx), this.ctx = C;
    }
  }, p.prototype.restore = function(y) {
    y = typeof y != "boolean" || y;
    for (var L = this.pdf.internal.getCurrentPageInfo().pageNumber, N = 0; N < this.pdf.internal.getNumberOfPages(); N++) this.pdf.setPage(N + 1), this.pdf.internal.out("Q");
    this.pdf.setPage(L), y && this.ctxStack.length !== 0 && (this.ctx = this.ctxStack.pop(), this.fillStyle = this.ctx.fillStyle, this.strokeStyle = this.ctx.strokeStyle, this.font = this.ctx.font, this.lineCap = this.ctx.lineCap, this.lineWidth = this.ctx.lineWidth, this.lineJoin = this.ctx.lineJoin, this.lineDash = this.ctx.lineDash, this.lineDashOffset = this.ctx.lineDashOffset);
  }, p.prototype.toDataURL = function() {
    throw new Error("toDataUrl not implemented.");
  };
  var v = function(y) {
    var L, N, C, z;
    if (y.isCanvasGradient === true && (y = y.getColor()), !y) return {
      r: 0,
      g: 0,
      b: 0,
      a: 0,
      style: y
    };
    if (/transparent|rgba\s*\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*,\s*0+\s*\)/.test(y)) L = 0, N = 0, C = 0, z = 0;
    else {
      var re = /rgb\s*\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*\)/.exec(y);
      if (re !== null) L = parseInt(re[1]), N = parseInt(re[2]), C = parseInt(re[3]), z = 1;
      else if ((re = /rgba\s*\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*,\s*([\d.]+)\s*\)/.exec(y)) !== null) L = parseInt(re[1]), N = parseInt(re[2]), C = parseInt(re[3]), z = parseFloat(re[4]);
      else {
        if (z = 1, typeof y == "string" && y.charAt(0) !== "#") {
          var se = new B1(y);
          y = se.ok ? se.toHex() : "#000000";
        }
        y.length === 4 ? (L = y.substring(1, 2), L += L, N = y.substring(2, 3), N += N, C = y.substring(3, 4), C += C) : (L = y.substring(1, 3), N = y.substring(3, 5), C = y.substring(5, 7)), L = parseInt(L, 16), N = parseInt(N, 16), C = parseInt(C, 16);
      }
    }
    return {
      r: L,
      g: N,
      b: C,
      a: z,
      style: y
    };
  }, d = function() {
    return this.ctx.isFillTransparent || this.globalAlpha == 0;
  }, w = function() {
    return !!(this.ctx.isStrokeTransparent || this.globalAlpha == 0);
  };
  p.prototype.fillText = function(y, L, N, C) {
    if (isNaN(L) || isNaN(N) || typeof y != "string") throw Kt.error("jsPDF.context2d.fillText: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.fillText");
    if (C = isNaN(C) ? void 0 : C, !d.call(this)) {
      var z = de(this.ctx.transform.rotation), re = this.ctx.transform.scaleX;
      P.call(this, {
        text: y,
        x: L,
        y: N,
        scale: re,
        angle: z,
        align: this.textAlign,
        maxWidth: C
      });
    }
  }, p.prototype.strokeText = function(y, L, N, C) {
    if (isNaN(L) || isNaN(N) || typeof y != "string") throw Kt.error("jsPDF.context2d.strokeText: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.strokeText");
    if (!w.call(this)) {
      C = isNaN(C) ? void 0 : C;
      var z = de(this.ctx.transform.rotation), re = this.ctx.transform.scaleX;
      P.call(this, {
        text: y,
        x: L,
        y: N,
        scale: re,
        renderingMode: "stroke",
        angle: z,
        align: this.textAlign,
        maxWidth: C
      });
    }
  }, p.prototype.measureText = function(y) {
    if (typeof y != "string") throw Kt.error("jsPDF.context2d.measureText: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.measureText");
    var L = this.pdf, N = this.pdf.internal.scaleFactor, C = L.internal.getFontSize(), z = L.getStringUnitWidth(y) * C / L.internal.scaleFactor, re = function(se) {
      var ie = (se = se || {}).width || 0;
      return Object.defineProperty(this, "width", {
        get: function() {
          return ie;
        }
      }), this;
    };
    return new re({
      width: z *= Math.round(96 * N / 72 * 1e4) / 1e4
    });
  }, p.prototype.scale = function(y, L) {
    if (isNaN(y) || isNaN(L)) throw Kt.error("jsPDF.context2d.scale: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.scale");
    var N = new f(y, 0, 0, L, 0, 0);
    this.ctx.transform = this.ctx.transform.multiply(N);
  }, p.prototype.rotate = function(y) {
    if (isNaN(y)) throw Kt.error("jsPDF.context2d.rotate: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.rotate");
    var L = new f(Math.cos(y), Math.sin(y), -Math.sin(y), Math.cos(y), 0, 0);
    this.ctx.transform = this.ctx.transform.multiply(L);
  }, p.prototype.translate = function(y, L) {
    if (isNaN(y) || isNaN(L)) throw Kt.error("jsPDF.context2d.translate: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.translate");
    var N = new f(1, 0, 0, 1, y, L);
    this.ctx.transform = this.ctx.transform.multiply(N);
  }, p.prototype.transform = function(y, L, N, C, z, re) {
    if (isNaN(y) || isNaN(L) || isNaN(N) || isNaN(C) || isNaN(z) || isNaN(re)) throw Kt.error("jsPDF.context2d.transform: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.transform");
    var se = new f(y, L, N, C, z, re);
    this.ctx.transform = this.ctx.transform.multiply(se);
  }, p.prototype.setTransform = function(y, L, N, C, z, re) {
    y = isNaN(y) ? 1 : y, L = isNaN(L) ? 0 : L, N = isNaN(N) ? 0 : N, C = isNaN(C) ? 1 : C, z = isNaN(z) ? 0 : z, re = isNaN(re) ? 0 : re, this.ctx.transform = new f(y, L, N, C, z, re);
  };
  var x = function() {
    return this.margin[0] > 0 || this.margin[1] > 0 || this.margin[2] > 0 || this.margin[3] > 0;
  };
  p.prototype.drawImage = function(y, L, N, C, z, re, se, ie, ve) {
    var Ce = this.pdf.getImageProperties(y), Oe = 1, qe = 1, Ye = 1, Te = 1;
    C !== void 0 && ie !== void 0 && (Ye = ie / C, Te = ve / z, Oe = Ce.width / C * ie / C, qe = Ce.height / z * ve / z), re === void 0 && (re = L, se = N, L = 0, N = 0), C !== void 0 && ie === void 0 && (ie = C, ve = z), C === void 0 && ie === void 0 && (ie = Ce.width, ve = Ce.height);
    for (var Z, Ie = this.ctx.transform.decompose(), rt = de(Ie.rotate.shx), Be = new f(), We = (Be = (Be = (Be = Be.multiply(Ie.translate)).multiply(Ie.skew)).multiply(Ie.scale)).applyToRectangle(new o(re - L * Ye, se - N * Te, C * Oe, z * qe)), $e = S.call(this, We), Je = [], st = 0; st < $e.length; st += 1) Je.indexOf($e[st]) === -1 && Je.push($e[st]);
    if (O(Je), this.autoPaging) for (var ot = Je[0], gt = Je[Je.length - 1], _t = ot; _t < gt + 1; _t++) {
      this.pdf.setPage(_t);
      var Tt = this.pdf.internal.pageSize.width - this.margin[3] - this.margin[1], Et = _t === 1 ? this.posY + this.margin[0] : this.margin[0], ct = this.pdf.internal.pageSize.height - this.posY - this.margin[0] - this.margin[2], At = this.pdf.internal.pageSize.height - this.margin[0] - this.margin[2], Qe = _t === 1 ? 0 : ct + (_t - 2) * At;
      if (this.ctx.clip_path.length !== 0) {
        var br = this.path;
        Z = JSON.parse(JSON.stringify(this.ctx.clip_path)), this.path = b(Z, this.posX + this.margin[3], -Qe + Et + this.ctx.prevPageLastElemOffset), te.call(this, "fill", true), this.path = br;
      }
      var Ft = JSON.parse(JSON.stringify(We));
      Ft = b([Ft], this.posX + this.margin[3], -Qe + Et + this.ctx.prevPageLastElemOffset)[0];
      var sn = (_t > ot || _t < gt) && x.call(this);
      sn && (this.pdf.saveGraphicsState(), this.pdf.rect(this.margin[3], this.margin[0], Tt, At, null).clip().discardPath()), this.pdf.addImage(y, "JPEG", Ft.x, Ft.y, Ft.w, Ft.h, null, null, rt), sn && this.pdf.restoreGraphicsState();
    }
    else this.pdf.addImage(y, "JPEG", We.x, We.y, We.w, We.h, null, null, rt);
  };
  var S = function(y, L, N) {
    var C = [];
    L = L || this.pdf.internal.pageSize.width, N = N || this.pdf.internal.pageSize.height - this.margin[0] - this.margin[2];
    var z = this.posY + this.ctx.prevPageLastElemOffset;
    switch (y.type) {
      default:
      case "mt":
      case "lt":
        C.push(Math.floor((y.y + z) / N) + 1);
        break;
      case "arc":
        C.push(Math.floor((y.y + z - y.radius) / N) + 1), C.push(Math.floor((y.y + z + y.radius) / N) + 1);
        break;
      case "qct":
        var re = Ae(this.ctx.lastPoint.x, this.ctx.lastPoint.y, y.x1, y.y1, y.x, y.y);
        C.push(Math.floor((re.y + z) / N) + 1), C.push(Math.floor((re.y + re.h + z) / N) + 1);
        break;
      case "bct":
        var se = be(this.ctx.lastPoint.x, this.ctx.lastPoint.y, y.x1, y.y1, y.x2, y.y2, y.x, y.y);
        C.push(Math.floor((se.y + z) / N) + 1), C.push(Math.floor((se.y + se.h + z) / N) + 1);
        break;
      case "rect":
        C.push(Math.floor((y.y + z) / N) + 1), C.push(Math.floor((y.y + y.h + z) / N) + 1);
    }
    for (var ie = 0; ie < C.length; ie += 1) for (; this.pdf.internal.getNumberOfPages() < C[ie]; ) A.call(this);
    return C;
  }, A = function() {
    var y = this.fillStyle, L = this.strokeStyle, N = this.font, C = this.lineCap, z = this.lineWidth, re = this.lineJoin;
    this.pdf.addPage(), this.fillStyle = y, this.strokeStyle = L, this.font = N, this.lineCap = C, this.lineWidth = z, this.lineJoin = re;
  }, b = function(y, L, N) {
    for (var C = 0; C < y.length; C++) switch (y[C].type) {
      case "bct":
        y[C].x2 += L, y[C].y2 += N;
      case "qct":
        y[C].x1 += L, y[C].y1 += N;
      case "mt":
      case "lt":
      case "arc":
      default:
        y[C].x += L, y[C].y += N;
    }
    return y;
  }, O = function(y) {
    return y.sort(function(L, N) {
      return L - N;
    });
  }, q = function(y, L) {
    for (var N, C, z = this.fillStyle, re = this.strokeStyle, se = this.lineCap, ie = this.lineWidth, ve = Math.abs(ie * this.ctx.transform.scaleX), Ce = this.lineJoin, Oe = JSON.parse(JSON.stringify(this.path)), qe = JSON.parse(JSON.stringify(this.path)), Ye = [], Te = 0; Te < qe.length; Te++) if (qe[Te].x !== void 0) for (var Z = S.call(this, qe[Te]), Ie = 0; Ie < Z.length; Ie += 1) Ye.indexOf(Z[Ie]) === -1 && Ye.push(Z[Ie]);
    for (var rt = 0; rt < Ye.length; rt++) for (; this.pdf.internal.getNumberOfPages() < Ye[rt]; ) A.call(this);
    if (O(Ye), this.autoPaging) for (var Be = Ye[0], We = Ye[Ye.length - 1], $e = Be; $e < We + 1; $e++) {
      this.pdf.setPage($e), this.fillStyle = z, this.strokeStyle = re, this.lineCap = se, this.lineWidth = ve, this.lineJoin = Ce;
      var Je = this.pdf.internal.pageSize.width - this.margin[3] - this.margin[1], st = $e === 1 ? this.posY + this.margin[0] : this.margin[0], ot = this.pdf.internal.pageSize.height - this.posY - this.margin[0] - this.margin[2], gt = this.pdf.internal.pageSize.height - this.margin[0] - this.margin[2], _t = $e === 1 ? 0 : ot + ($e - 2) * gt;
      if (this.ctx.clip_path.length !== 0) {
        var Tt = this.path;
        N = JSON.parse(JSON.stringify(this.ctx.clip_path)), this.path = b(N, this.posX + this.margin[3], -_t + st + this.ctx.prevPageLastElemOffset), te.call(this, y, true), this.path = Tt;
      }
      if (C = JSON.parse(JSON.stringify(Oe)), this.path = b(C, this.posX + this.margin[3], -_t + st + this.ctx.prevPageLastElemOffset), L === false || $e === 0) {
        var Et = ($e > Be || $e < We) && x.call(this);
        Et && (this.pdf.saveGraphicsState(), this.pdf.rect(this.margin[3], this.margin[0], Je, gt, null).clip().discardPath()), te.call(this, y, L), Et && this.pdf.restoreGraphicsState();
      }
      this.lineWidth = ie;
    }
    else this.lineWidth = ve, te.call(this, y, L), this.lineWidth = ie;
    this.path = Oe;
  }, te = function(y, L) {
    if ((y !== "stroke" || L || !w.call(this)) && (y === "stroke" || L || !d.call(this))) {
      for (var N, C, z = [], re = this.path, se = 0; se < re.length; se++) {
        var ie = re[se];
        switch (ie.type) {
          case "begin":
            z.push({
              begin: true
            });
            break;
          case "close":
            z.push({
              close: true
            });
            break;
          case "mt":
            z.push({
              start: ie,
              deltas: [],
              abs: []
            });
            break;
          case "lt":
            var ve = z.length;
            if (re[se - 1] && !isNaN(re[se - 1].x) && (N = [ie.x - re[se - 1].x, ie.y - re[se - 1].y], ve > 0)) {
              for (; ve >= 0; ve--) if (z[ve - 1].close !== true && z[ve - 1].begin !== true) {
                z[ve - 1].deltas.push(N), z[ve - 1].abs.push(ie);
                break;
              }
            }
            break;
          case "bct":
            N = [ie.x1 - re[se - 1].x, ie.y1 - re[se - 1].y, ie.x2 - re[se - 1].x, ie.y2 - re[se - 1].y, ie.x - re[se - 1].x, ie.y - re[se - 1].y], z[z.length - 1].deltas.push(N);
            break;
          case "qct":
            var Ce = re[se - 1].x + 2 / 3 * (ie.x1 - re[se - 1].x), Oe = re[se - 1].y + 2 / 3 * (ie.y1 - re[se - 1].y), qe = ie.x + 2 / 3 * (ie.x1 - ie.x), Ye = ie.y + 2 / 3 * (ie.y1 - ie.y), Te = ie.x, Z = ie.y;
            N = [Ce - re[se - 1].x, Oe - re[se - 1].y, qe - re[se - 1].x, Ye - re[se - 1].y, Te - re[se - 1].x, Z - re[se - 1].y], z[z.length - 1].deltas.push(N);
            break;
          case "arc":
            z.push({
              deltas: [],
              abs: [],
              arc: true
            }), Array.isArray(z[z.length - 1].abs) && z[z.length - 1].abs.push(ie);
        }
      }
      C = L ? null : y === "stroke" ? "stroke" : "fill";
      for (var Ie = false, rt = 0; rt < z.length; rt++) if (z[rt].arc) for (var Be = z[rt].abs, We = 0; We < Be.length; We++) {
        var $e = Be[We];
        $e.type === "arc" ? M.call(this, $e.x, $e.y, $e.radius, $e.startAngle, $e.endAngle, $e.counterclockwise, void 0, L, !Ie) : Y.call(this, $e.x, $e.y), Ie = true;
      }
      else if (z[rt].close === true) this.pdf.internal.out("h"), Ie = false;
      else if (z[rt].begin !== true) {
        var Je = z[rt].start.x, st = z[rt].start.y;
        Q.call(this, z[rt].deltas, Je, st), Ie = true;
      }
      C && H.call(this, C), L && ee.call(this);
    }
  }, le = function(y) {
    var L = this.pdf.internal.getFontSize() / this.pdf.internal.scaleFactor, N = L * (this.pdf.internal.getLineHeightFactor() - 1);
    switch (this.ctx.textBaseline) {
      case "bottom":
        return y - N;
      case "top":
        return y + L - N;
      case "hanging":
        return y + L - 2 * N;
      case "middle":
        return y + L / 2 - N;
      case "ideographic":
        return y;
      case "alphabetic":
      default:
        return y;
    }
  }, j = function(y) {
    return y + this.pdf.internal.getFontSize() / this.pdf.internal.scaleFactor * (this.pdf.internal.getLineHeightFactor() - 1);
  };
  p.prototype.createLinearGradient = function() {
    var y = function() {
    };
    return y.colorStops = [], y.addColorStop = function(L, N) {
      this.colorStops.push([L, N]);
    }, y.getColor = function() {
      return this.colorStops.length === 0 ? "#000000" : this.colorStops[0][1];
    }, y.isCanvasGradient = true, y;
  }, p.prototype.createPattern = function() {
    return this.createLinearGradient();
  }, p.prototype.createRadialGradient = function() {
    return this.createLinearGradient();
  };
  var M = function(y, L, N, C, z, re, se, ie, ve) {
    for (var Ce = we.call(this, N, C, z, re), Oe = 0; Oe < Ce.length; Oe++) {
      var qe = Ce[Oe];
      Oe === 0 && (ve ? F.call(this, qe.x1 + y, qe.y1 + L) : Y.call(this, qe.x1 + y, qe.y1 + L)), ce.call(this, y, L, qe.x2, qe.y2, qe.x3, qe.y3, qe.x4, qe.y4);
    }
    ie ? ee.call(this) : H.call(this, se);
  }, H = function(y) {
    switch (y) {
      case "stroke":
        this.pdf.internal.out("S");
        break;
      case "fill":
        this.pdf.internal.out("f");
    }
  }, ee = function() {
    this.pdf.clip(), this.pdf.discardPath();
  }, F = function(y, L) {
    this.pdf.internal.out(t(y) + " " + n(L) + " m");
  }, P = function(y) {
    var L;
    switch (y.align) {
      case "right":
      case "end":
        L = "right";
        break;
      case "center":
        L = "center";
        break;
      case "left":
      case "start":
      default:
        L = "left";
    }
    var N = this.pdf.getTextDimensions(y.text), C = le.call(this, y.y), z = j.call(this, C) - N.h, re = this.ctx.transform.applyToPoint(new s(y.x, C)), se = this.ctx.transform.decompose(), ie = new f();
    ie = (ie = (ie = ie.multiply(se.translate)).multiply(se.skew)).multiply(se.scale);
    for (var ve, Ce, Oe, qe = this.ctx.transform.applyToRectangle(new o(y.x, C, N.w, N.h)), Ye = ie.applyToRectangle(new o(y.x, z, N.w, N.h)), Te = S.call(this, Ye), Z = [], Ie = 0; Ie < Te.length; Ie += 1) Z.indexOf(Te[Ie]) === -1 && Z.push(Te[Ie]);
    if (O(Z), this.autoPaging) for (var rt = Z[0], Be = Z[Z.length - 1], We = rt; We < Be + 1; We++) {
      this.pdf.setPage(We);
      var $e = We === 1 ? this.posY + this.margin[0] : this.margin[0], Je = this.pdf.internal.pageSize.height - this.posY - this.margin[0] - this.margin[2], st = this.pdf.internal.pageSize.height - this.margin[2], ot = st - this.margin[0], gt = this.pdf.internal.pageSize.width - this.margin[1], _t = gt - this.margin[3], Tt = We === 1 ? 0 : Je + (We - 2) * ot;
      if (this.ctx.clip_path.length !== 0) {
        var Et = this.path;
        ve = JSON.parse(JSON.stringify(this.ctx.clip_path)), this.path = b(ve, this.posX + this.margin[3], -1 * Tt + $e), te.call(this, "fill", true), this.path = Et;
      }
      var ct = b([JSON.parse(JSON.stringify(Ye))], this.posX + this.margin[3], -Tt + $e + this.ctx.prevPageLastElemOffset)[0];
      y.scale >= 0.01 && (Ce = this.pdf.internal.getFontSize(), this.pdf.setFontSize(Ce * y.scale), Oe = this.lineWidth, this.lineWidth = Oe * y.scale);
      var At = this.autoPaging !== "text";
      if (At || ct.y + ct.h <= st) {
        if (At || ct.y >= $e && ct.x <= gt) {
          var Qe = At ? y.text : this.pdf.splitTextToSize(y.text, y.maxWidth || gt - ct.x)[0], br = b([JSON.parse(JSON.stringify(qe))], this.posX + this.margin[3], -Tt + $e + this.ctx.prevPageLastElemOffset)[0], Ft = At && (We > rt || We < Be) && x.call(this);
          Ft && (this.pdf.saveGraphicsState(), this.pdf.rect(this.margin[3], this.margin[0], _t, ot, null).clip().discardPath()), this.pdf.text(Qe, br.x, br.y, {
            angle: y.angle,
            align: L,
            renderingMode: y.renderingMode
          }), Ft && this.pdf.restoreGraphicsState();
        }
      } else ct.y < st && (this.ctx.prevPageLastElemOffset += st - ct.y);
      y.scale >= 0.01 && (this.pdf.setFontSize(Ce), this.lineWidth = Oe);
    }
    else y.scale >= 0.01 && (Ce = this.pdf.internal.getFontSize(), this.pdf.setFontSize(Ce * y.scale), Oe = this.lineWidth, this.lineWidth = Oe * y.scale), this.pdf.text(y.text, re.x + this.posX, re.y + this.posY, {
      angle: y.angle,
      align: L,
      renderingMode: y.renderingMode,
      maxWidth: y.maxWidth
    }), y.scale >= 0.01 && (this.pdf.setFontSize(Ce), this.lineWidth = Oe);
  }, Y = function(y, L, N, C) {
    N = N || 0, C = C || 0, this.pdf.internal.out(t(y + N) + " " + n(L + C) + " l");
  }, Q = function(y, L, N) {
    return this.pdf.lines(y, L, N, null, null);
  }, ce = function(y, L, N, C, z, re, se, ie) {
    this.pdf.internal.out([e(i(N + y)), e(a(C + L)), e(i(z + y)), e(a(re + L)), e(i(se + y)), e(a(ie + L)), "c"].join(" "));
  }, we = function(y, L, N, C) {
    for (var z = 2 * Math.PI, re = Math.PI / 2; L > N; ) L -= z;
    var se = Math.abs(N - L);
    se < z && C && (se = z - se);
    for (var ie = [], ve = C ? -1 : 1, Ce = L; se > 1e-5; ) {
      var Oe = Ce + ve * Math.min(se, re);
      ie.push(Se.call(this, y, Ce, Oe)), se -= Math.abs(Oe - Ce), Ce = Oe;
    }
    return ie;
  }, Se = function(y, L, N) {
    var C = (N - L) / 2, z = y * Math.cos(C), re = y * Math.sin(C), se = z, ie = -re, ve = se * se + ie * ie, Ce = ve + se * z + ie * re, Oe = 4 / 3 * (Math.sqrt(2 * ve * Ce) - Ce) / (se * re - ie * z), qe = se - Oe * ie, Ye = ie + Oe * se, Te = qe, Z = -Ye, Ie = C + L, rt = Math.cos(Ie), Be = Math.sin(Ie);
    return {
      x1: y * Math.cos(L),
      y1: y * Math.sin(L),
      x2: qe * rt - Ye * Be,
      y2: qe * Be + Ye * rt,
      x3: Te * rt - Z * Be,
      y3: Te * Be + Z * rt,
      x4: y * Math.cos(N),
      y4: y * Math.sin(N)
    };
  }, de = function(y) {
    return 180 * y / Math.PI;
  }, Ae = function(y, L, N, C, z, re) {
    var se = y + 0.5 * (N - y), ie = L + 0.5 * (C - L), ve = z + 0.5 * (N - z), Ce = re + 0.5 * (C - re), Oe = Math.min(y, z, se, ve), qe = Math.max(y, z, se, ve), Ye = Math.min(L, re, ie, Ce), Te = Math.max(L, re, ie, Ce);
    return new o(Oe, Ye, qe - Oe, Te - Ye);
  }, be = function(y, L, N, C, z, re, se, ie) {
    var ve, Ce, Oe, qe, Ye, Te, Z, Ie, rt, Be, We, $e, Je, st, ot = N - y, gt = C - L, _t = z - N, Tt = re - C, Et = se - z, ct = ie - re;
    for (Ce = 0; Ce < 41; Ce++) rt = (Z = (Oe = y + (ve = Ce / 40) * ot) + ve * ((Ye = N + ve * _t) - Oe)) + ve * (Ye + ve * (z + ve * Et - Ye) - Z), Be = (Ie = (qe = L + ve * gt) + ve * ((Te = C + ve * Tt) - qe)) + ve * (Te + ve * (re + ve * ct - Te) - Ie), Ce == 0 ? (We = rt, $e = Be, Je = rt, st = Be) : (We = Math.min(We, rt), $e = Math.min($e, Be), Je = Math.max(Je, rt), st = Math.max(st, Be));
    return new o(Math.round(We), Math.round($e), Math.round(Je - We), Math.round(st - $e));
  }, ze = function() {
    if (this.prevLineDash || this.ctx.lineDash.length || this.ctx.lineDashOffset) {
      var y, L, N = (y = this.ctx.lineDash, L = this.ctx.lineDashOffset, JSON.stringify({
        lineDash: y,
        lineDashOffset: L
      }));
      this.prevLineDash !== N && (this.pdf.setLineDash(this.ctx.lineDash, this.ctx.lineDashOffset), this.prevLineDash = N);
    }
  };
})(ut.API), /**
* @license
* jsPDF filters PlugIn
* Copyright (c) 2014 Aras Abbasi
*
* Licensed under the MIT License.
* http://opensource.org/licenses/mit-license
*/
function(r6) {
  var e = function(a) {
    var s, o, f, h, c, p, v, d, w, x;
    for (o = [], f = 0, h = (a += s = "\0\0\0\0".slice(a.length % 4 || 4)).length; h > f; f += 4) (c = (a.charCodeAt(f) << 24) + (a.charCodeAt(f + 1) << 16) + (a.charCodeAt(f + 2) << 8) + a.charCodeAt(f + 3)) !== 0 ? (p = (c = ((c = ((c = ((c = (c - (x = c % 85)) / 85) - (w = c % 85)) / 85) - (d = c % 85)) / 85) - (v = c % 85)) / 85) % 85, o.push(p + 33, v + 33, d + 33, w + 33, x + 33)) : o.push(122);
    return function(S, A) {
      for (var b = A; b > 0; b--) S.pop();
    }(o, s.length), String.fromCharCode.apply(String, o) + "~>";
  }, t = function(a) {
    var s, o, f, h, c, p = String, v = "length", d = 255, w = "charCodeAt", x = "slice", S = "replace";
    for (a[x](-2), a = a[x](0, -2)[S](/\s/g, "")[S]("z", "!!!!!"), f = [], h = 0, c = (a += s = "uuuuu"[x](a[v] % 5 || 5))[v]; c > h; h += 5) o = 52200625 * (a[w](h) - 33) + 614125 * (a[w](h + 1) - 33) + 7225 * (a[w](h + 2) - 33) + 85 * (a[w](h + 3) - 33) + (a[w](h + 4) - 33), f.push(d & o >> 24, d & o >> 16, d & o >> 8, d & o);
    return function(A, b) {
      for (var O = b; O > 0; O--) A.pop();
    }(f, s[v]), p.fromCharCode.apply(p, f);
  }, n = function(a) {
    var s = new RegExp(/^([0-9A-Fa-f]{2})+$/);
    if ((a = a.replace(/\s/g, "")).indexOf(">") !== -1 && (a = a.substr(0, a.indexOf(">"))), a.length % 2 && (a += "0"), s.test(a) === false) return "";
    for (var o = "", f = 0; f < a.length; f += 2) o += String.fromCharCode("0x" + (a[f] + a[f + 1]));
    return o;
  }, i = function(a) {
    for (var s = new Uint8Array(a.length), o = a.length; o--; ) s[o] = a.charCodeAt(o);
    return a = (s = Tl(s)).reduce(function(f, h) {
      return f + String.fromCharCode(h);
    }, "");
  };
  r6.processDataByFilters = function(a, s) {
    var o = 0, f = a || "", h = [];
    for (typeof (s = s || []) == "string" && (s = [s]), o = 0; o < s.length; o += 1) switch (s[o]) {
      case "ASCII85Decode":
      case "/ASCII85Decode":
        f = t(f), h.push("/ASCII85Encode");
        break;
      case "ASCII85Encode":
      case "/ASCII85Encode":
        f = e(f), h.push("/ASCII85Decode");
        break;
      case "ASCIIHexDecode":
      case "/ASCIIHexDecode":
        f = n(f), h.push("/ASCIIHexEncode");
        break;
      case "ASCIIHexEncode":
      case "/ASCIIHexEncode":
        f = f.split("").map(function(c) {
          return ("0" + c.charCodeAt().toString(16)).slice(-2);
        }).join("") + ">", h.push("/ASCIIHexDecode");
        break;
      case "FlateEncode":
      case "/FlateEncode":
        f = i(f), h.push("/FlateDecode");
        break;
      default:
        throw new Error('The filter: "' + s[o] + '" is not implemented');
    }
    return {
      data: f,
      reverseChain: h.reverse().join(" ")
    };
  };
}(ut.API), /**
* @license
* jsPDF fileloading PlugIn
* Copyright (c) 2018 Aras Abbasi (aras.abbasi@gmail.com)
*
* Licensed under the MIT License.
* http://opensource.org/licenses/mit-license
*/
function(r6) {
  r6.loadFile = function(e, t, n) {
    return function(i, a, s) {
      a = a !== false, s = typeof s == "function" ? s : function() {
      };
      var o = void 0;
      try {
        o = function(f, h, c) {
          var p = new XMLHttpRequest(), v = 0, d = function(w) {
            var x = w.length, S = [], A = String.fromCharCode;
            for (v = 0; v < x; v += 1) S.push(A(255 & w.charCodeAt(v)));
            return S.join("");
          };
          if (p.open("GET", f, !h), p.overrideMimeType("text/plain; charset=x-user-defined"), h === false && (p.onload = function() {
            p.status === 200 ? c(d(this.responseText)) : c(void 0);
          }), p.send(null), h && p.status === 200) return d(p.responseText);
        }(i, a, s);
      } catch {
      }
      return o;
    }(e, t, n);
  }, r6.loadImageFile = r6.loadFile;
}(ut.API), function(r6) {
  function e() {
    return (dt.html2canvas ? Promise.resolve(dt.html2canvas) : import("./html2canvas.esm-1a1724a1-JMHMFZKW.js")).catch(function(s) {
      return Promise.reject(new Error("Could not load html2canvas: " + s));
    }).then(function(s) {
      return s.default ? s.default : s;
    });
  }
  function t() {
    return (dt.DOMPurify ? Promise.resolve(dt.DOMPurify) : import("./purify.es-78c333b1-RMLJBMGN.js")).catch(function(s) {
      return Promise.reject(new Error("Could not load dompurify: " + s));
    }).then(function(s) {
      return s.default ? s.default : s;
    });
  }
  var n = function(s) {
    var o = Wt(s);
    return o === "undefined" ? "undefined" : o === "string" || s instanceof String ? "string" : o === "number" || s instanceof Number ? "number" : o === "function" || s instanceof Function ? "function" : s && s.constructor === Array ? "array" : s && s.nodeType === 1 ? "element" : o === "object" ? "object" : "unknown";
  }, i = function(s, o) {
    var f = document.createElement(s);
    for (var h in o.className && (f.className = o.className), o.innerHTML && o.dompurify && (f.innerHTML = o.dompurify.sanitize(o.innerHTML)), o.style) f.style[h] = o.style[h];
    return f;
  }, a = function s(o) {
    var f = Object.assign(s.convert(Promise.resolve()), JSON.parse(JSON.stringify(s.template))), h = s.convert(Promise.resolve(), f);
    return h = (h = h.setProgress(1, s, 1, [s])).set(o);
  };
  (a.prototype = Object.create(Promise.prototype)).constructor = a, a.convert = function(s, o) {
    return s.__proto__ = o || a.prototype, s;
  }, a.template = {
    prop: {
      src: null,
      container: null,
      overlay: null,
      canvas: null,
      img: null,
      pdf: null,
      pageSize: null,
      callback: function() {
      }
    },
    progress: {
      val: 0,
      state: null,
      n: 0,
      stack: []
    },
    opt: {
      filename: "file.pdf",
      margin: [0, 0, 0, 0],
      enableLinks: true,
      x: 0,
      y: 0,
      html2canvas: {},
      jsPDF: {},
      backgroundColor: "transparent"
    }
  }, a.prototype.from = function(s, o) {
    return this.then(function() {
      switch (o = o || function(f) {
        switch (n(f)) {
          case "string":
            return "string";
          case "element":
            return f.nodeName.toLowerCase() === "canvas" ? "canvas" : "element";
          default:
            return "unknown";
        }
      }(s)) {
        case "string":
          return this.then(t).then(function(f) {
            return this.set({
              src: i("div", {
                innerHTML: s,
                dompurify: f
              })
            });
          });
        case "element":
          return this.set({
            src: s
          });
        case "canvas":
          return this.set({
            canvas: s
          });
        case "img":
          return this.set({
            img: s
          });
        default:
          return this.error("Unknown source type.");
      }
    });
  }, a.prototype.to = function(s) {
    switch (s) {
      case "container":
        return this.toContainer();
      case "canvas":
        return this.toCanvas();
      case "img":
        return this.toImg();
      case "pdf":
        return this.toPdf();
      default:
        return this.error("Invalid target.");
    }
  }, a.prototype.toContainer = function() {
    return this.thenList([function() {
      return this.prop.src || this.error("Cannot duplicate - no source HTML.");
    }, function() {
      return this.prop.pageSize || this.setPageSize();
    }]).then(function() {
      var s = {
        position: "relative",
        display: "inline-block",
        width: (typeof this.opt.width != "number" || isNaN(this.opt.width) || typeof this.opt.windowWidth != "number" || isNaN(this.opt.windowWidth) ? Math.max(this.prop.src.clientWidth, this.prop.src.scrollWidth, this.prop.src.offsetWidth) : this.opt.windowWidth) + "px",
        left: 0,
        right: 0,
        top: 0,
        margin: "auto",
        backgroundColor: this.opt.backgroundColor
      }, o = function f(h, c) {
        for (var p = h.nodeType === 3 ? document.createTextNode(h.nodeValue) : h.cloneNode(false), v = h.firstChild; v; v = v.nextSibling) c !== true && v.nodeType === 1 && v.nodeName === "SCRIPT" || p.appendChild(f(v, c));
        return h.nodeType === 1 && (h.nodeName === "CANVAS" ? (p.width = h.width, p.height = h.height, p.getContext("2d").drawImage(h, 0, 0)) : h.nodeName !== "TEXTAREA" && h.nodeName !== "SELECT" || (p.value = h.value), p.addEventListener("load", function() {
          p.scrollTop = h.scrollTop, p.scrollLeft = h.scrollLeft;
        }, true)), p;
      }(this.prop.src, this.opt.html2canvas.javascriptEnabled);
      o.tagName === "BODY" && (s.height = Math.max(document.body.scrollHeight, document.body.offsetHeight, document.documentElement.clientHeight, document.documentElement.scrollHeight, document.documentElement.offsetHeight) + "px"), this.prop.overlay = i("div", {
        className: "html2pdf__overlay",
        style: {
          position: "fixed",
          overflow: "hidden",
          zIndex: 1e3,
          left: "-100000px",
          right: 0,
          bottom: 0,
          top: 0
        }
      }), this.prop.container = i("div", {
        className: "html2pdf__container",
        style: s
      }), this.prop.container.appendChild(o), this.prop.container.firstChild.appendChild(i("div", {
        style: {
          clear: "both",
          border: "0 none transparent",
          margin: 0,
          padding: 0,
          height: 0
        }
      })), this.prop.container.style.float = "none", this.prop.overlay.appendChild(this.prop.container), document.body.appendChild(this.prop.overlay), this.prop.container.firstChild.style.position = "relative", this.prop.container.height = Math.max(this.prop.container.firstChild.clientHeight, this.prop.container.firstChild.scrollHeight, this.prop.container.firstChild.offsetHeight) + "px";
    });
  }, a.prototype.toCanvas = function() {
    var s = [function() {
      return document.body.contains(this.prop.container) || this.toContainer();
    }];
    return this.thenList(s).then(e).then(function(o) {
      var f = Object.assign({}, this.opt.html2canvas);
      return delete f.onrendered, o(this.prop.container, f);
    }).then(function(o) {
      (this.opt.html2canvas.onrendered || function() {
      })(o), this.prop.canvas = o, document.body.removeChild(this.prop.overlay);
    });
  }, a.prototype.toContext2d = function() {
    var s = [function() {
      return document.body.contains(this.prop.container) || this.toContainer();
    }];
    return this.thenList(s).then(e).then(function(o) {
      var f = this.opt.jsPDF, h = this.opt.fontFaces, c = typeof this.opt.width != "number" || isNaN(this.opt.width) || typeof this.opt.windowWidth != "number" || isNaN(this.opt.windowWidth) ? 1 : this.opt.width / this.opt.windowWidth, p = Object.assign({
        async: true,
        allowTaint: true,
        scale: c,
        scrollX: this.opt.scrollX || 0,
        scrollY: this.opt.scrollY || 0,
        backgroundColor: "#ffffff",
        imageTimeout: 15e3,
        logging: true,
        proxy: null,
        removeContainer: true,
        foreignObjectRendering: false,
        useCORS: false
      }, this.opt.html2canvas);
      if (delete p.onrendered, f.context2d.autoPaging = this.opt.autoPaging === void 0 || this.opt.autoPaging, f.context2d.posX = this.opt.x, f.context2d.posY = this.opt.y, f.context2d.margin = this.opt.margin, f.context2d.fontFaces = h, h) for (var v = 0; v < h.length; ++v) {
        var d = h[v], w = d.src.find(function(x) {
          return x.format === "truetype";
        });
        w && f.addFont(w.url, d.ref.name, d.ref.style);
      }
      return p.windowHeight = p.windowHeight || 0, p.windowHeight = p.windowHeight == 0 ? Math.max(this.prop.container.clientHeight, this.prop.container.scrollHeight, this.prop.container.offsetHeight) : p.windowHeight, f.context2d.save(true), o(this.prop.container, p);
    }).then(function(o) {
      this.opt.jsPDF.context2d.restore(true), (this.opt.html2canvas.onrendered || function() {
      })(o), this.prop.canvas = o, document.body.removeChild(this.prop.overlay);
    });
  }, a.prototype.toImg = function() {
    return this.thenList([function() {
      return this.prop.canvas || this.toCanvas();
    }]).then(function() {
      var s = this.prop.canvas.toDataURL("image/" + this.opt.image.type, this.opt.image.quality);
      this.prop.img = document.createElement("img"), this.prop.img.src = s;
    });
  }, a.prototype.toPdf = function() {
    return this.thenList([function() {
      return this.toContext2d();
    }]).then(function() {
      this.prop.pdf = this.prop.pdf || this.opt.jsPDF;
    });
  }, a.prototype.output = function(s, o, f) {
    return (f = f || "pdf").toLowerCase() === "img" || f.toLowerCase() === "image" ? this.outputImg(s, o) : this.outputPdf(s, o);
  }, a.prototype.outputPdf = function(s, o) {
    return this.thenList([function() {
      return this.prop.pdf || this.toPdf();
    }]).then(function() {
      return this.prop.pdf.output(s, o);
    });
  }, a.prototype.outputImg = function(s) {
    return this.thenList([function() {
      return this.prop.img || this.toImg();
    }]).then(function() {
      switch (s) {
        case void 0:
        case "img":
          return this.prop.img;
        case "datauristring":
        case "dataurlstring":
          return this.prop.img.src;
        case "datauri":
        case "dataurl":
          return document.location.href = this.prop.img.src;
        default:
          throw 'Image output type "' + s + '" is not supported.';
      }
    });
  }, a.prototype.save = function(s) {
    return this.thenList([function() {
      return this.prop.pdf || this.toPdf();
    }]).set(s ? {
      filename: s
    } : null).then(function() {
      this.prop.pdf.save(this.opt.filename);
    });
  }, a.prototype.doCallback = function() {
    return this.thenList([function() {
      return this.prop.pdf || this.toPdf();
    }]).then(function() {
      this.prop.callback(this.prop.pdf);
    });
  }, a.prototype.set = function(s) {
    if (n(s) !== "object") return this;
    var o = Object.keys(s || {}).map(function(f) {
      if (f in a.template.prop) return function() {
        this.prop[f] = s[f];
      };
      switch (f) {
        case "margin":
          return this.setMargin.bind(this, s.margin);
        case "jsPDF":
          return function() {
            return this.opt.jsPDF = s.jsPDF, this.setPageSize();
          };
        case "pageSize":
          return this.setPageSize.bind(this, s.pageSize);
        default:
          return function() {
            this.opt[f] = s[f];
          };
      }
    }, this);
    return this.then(function() {
      return this.thenList(o);
    });
  }, a.prototype.get = function(s, o) {
    return this.then(function() {
      var f = s in a.template.prop ? this.prop[s] : this.opt[s];
      return o ? o(f) : f;
    });
  }, a.prototype.setMargin = function(s) {
    return this.then(function() {
      switch (n(s)) {
        case "number":
          s = [s, s, s, s];
        case "array":
          if (s.length === 2 && (s = [s[0], s[1], s[0], s[1]]), s.length === 4) break;
        default:
          return this.error("Invalid margin array.");
      }
      this.opt.margin = s;
    }).then(this.setPageSize);
  }, a.prototype.setPageSize = function(s) {
    function o(f, h) {
      return Math.floor(f * h / 72 * 96);
    }
    return this.then(function() {
      (s = s || ut.getPageSize(this.opt.jsPDF)).hasOwnProperty("inner") || (s.inner = {
        width: s.width - this.opt.margin[1] - this.opt.margin[3],
        height: s.height - this.opt.margin[0] - this.opt.margin[2]
      }, s.inner.px = {
        width: o(s.inner.width, s.k),
        height: o(s.inner.height, s.k)
      }, s.inner.ratio = s.inner.height / s.inner.width), this.prop.pageSize = s;
    });
  }, a.prototype.setProgress = function(s, o, f, h) {
    return s != null && (this.progress.val = s), o != null && (this.progress.state = o), f != null && (this.progress.n = f), h != null && (this.progress.stack = h), this.progress.ratio = this.progress.val / this.progress.state, this;
  }, a.prototype.updateProgress = function(s, o, f, h) {
    return this.setProgress(s ? this.progress.val + s : null, o || null, f ? this.progress.n + f : null, h ? this.progress.stack.concat(h) : null);
  }, a.prototype.then = function(s, o) {
    var f = this;
    return this.thenCore(s, o, function(h, c) {
      return f.updateProgress(null, null, 1, [h]), Promise.prototype.then.call(this, function(p) {
        return f.updateProgress(null, h), p;
      }).then(h, c).then(function(p) {
        return f.updateProgress(1), p;
      });
    });
  }, a.prototype.thenCore = function(s, o, f) {
    f = f || Promise.prototype.then, s && (s = s.bind(this)), o && (o = o.bind(this));
    var h = Promise.toString().indexOf("[native code]") !== -1 && Promise.name === "Promise" ? this : a.convert(Object.assign({}, this), Promise.prototype), c = f.call(h, s, o);
    return a.convert(c, this.__proto__);
  }, a.prototype.thenExternal = function(s, o) {
    return Promise.prototype.then.call(this, s, o);
  }, a.prototype.thenList = function(s) {
    var o = this;
    return s.forEach(function(f) {
      o = o.thenCore(f);
    }), o;
  }, a.prototype.catch = function(s) {
    s && (s = s.bind(this));
    var o = Promise.prototype.catch.call(this, s);
    return a.convert(o, this);
  }, a.prototype.catchExternal = function(s) {
    return Promise.prototype.catch.call(this, s);
  }, a.prototype.error = function(s) {
    return this.then(function() {
      throw new Error(s);
    });
  }, a.prototype.using = a.prototype.set, a.prototype.saveAs = a.prototype.save, a.prototype.export = a.prototype.output, a.prototype.run = a.prototype.then, ut.getPageSize = function(s, o, f) {
    if (Wt(s) === "object") {
      var h = s;
      s = h.orientation, o = h.unit || o, f = h.format || f;
    }
    o = o || "mm", f = f || "a4", s = ("" + (s || "P")).toLowerCase();
    var c, p = ("" + f).toLowerCase(), v = {
      a0: [2383.94, 3370.39],
      a1: [1683.78, 2383.94],
      a2: [1190.55, 1683.78],
      a3: [841.89, 1190.55],
      a4: [595.28, 841.89],
      a5: [419.53, 595.28],
      a6: [297.64, 419.53],
      a7: [209.76, 297.64],
      a8: [147.4, 209.76],
      a9: [104.88, 147.4],
      a10: [73.7, 104.88],
      b0: [2834.65, 4008.19],
      b1: [2004.09, 2834.65],
      b2: [1417.32, 2004.09],
      b3: [1000.63, 1417.32],
      b4: [708.66, 1000.63],
      b5: [498.9, 708.66],
      b6: [354.33, 498.9],
      b7: [249.45, 354.33],
      b8: [175.75, 249.45],
      b9: [124.72, 175.75],
      b10: [87.87, 124.72],
      c0: [2599.37, 3676.54],
      c1: [1836.85, 2599.37],
      c2: [1298.27, 1836.85],
      c3: [918.43, 1298.27],
      c4: [649.13, 918.43],
      c5: [459.21, 649.13],
      c6: [323.15, 459.21],
      c7: [229.61, 323.15],
      c8: [161.57, 229.61],
      c9: [113.39, 161.57],
      c10: [79.37, 113.39],
      dl: [311.81, 623.62],
      letter: [612, 792],
      "government-letter": [576, 756],
      legal: [612, 1008],
      "junior-legal": [576, 360],
      ledger: [1224, 792],
      tabloid: [792, 1224],
      "credit-card": [153, 243]
    };
    switch (o) {
      case "pt":
        c = 1;
        break;
      case "mm":
        c = 72 / 25.4;
        break;
      case "cm":
        c = 72 / 2.54;
        break;
      case "in":
        c = 72;
        break;
      case "px":
        c = 0.75;
        break;
      case "pc":
      case "em":
        c = 12;
        break;
      case "ex":
        c = 6;
        break;
      default:
        throw "Invalid unit: " + o;
    }
    var d, w = 0, x = 0;
    if (v.hasOwnProperty(p)) w = v[p][1] / c, x = v[p][0] / c;
    else try {
      w = f[1], x = f[0];
    } catch {
      throw new Error("Invalid format: " + f);
    }
    if (s === "p" || s === "portrait") s = "p", x > w && (d = x, x = w, w = d);
    else {
      if (s !== "l" && s !== "landscape") throw "Invalid orientation: " + s;
      s = "l", w > x && (d = x, x = w, w = d);
    }
    return {
      width: x,
      height: w,
      unit: o,
      k: c,
      orientation: s
    };
  }, r6.html = function(s, o) {
    (o = o || {}).callback = o.callback || function() {
    }, o.html2canvas = o.html2canvas || {}, o.html2canvas.canvas = o.html2canvas.canvas || this.canvas, o.jsPDF = o.jsPDF || this, o.fontFaces = o.fontFaces ? o.fontFaces.map(Pl) : null;
    var f = new a(o);
    return o.worker ? f : f.from(s).doCallback();
  };
}(ut.API), ut.API.addJS = function(r6) {
  return Oc = r6, this.internal.events.subscribe("postPutResources", function() {
    P0 = this.internal.newObject(), this.internal.out("<<"), this.internal.out("/Names [(EmbeddedJS) " + (P0 + 1) + " 0 R]"), this.internal.out(">>"), this.internal.out("endobj"), Dc = this.internal.newObject(), this.internal.out("<<"), this.internal.out("/S /JavaScript"), this.internal.out("/JS (" + Oc + ")"), this.internal.out(">>"), this.internal.out("endobj");
  }), this.internal.events.subscribe("putCatalog", function() {
    P0 !== void 0 && Dc !== void 0 && this.internal.out("/Names <</JavaScript " + P0 + " 0 R>>");
  }), this;
}, /**
* @license
* Copyright (c) 2014 Steven Spungin (TwelveTone LLC)  steven@twelvetone.tv
*
* Licensed under the MIT License.
* http://opensource.org/licenses/mit-license
*/
function(r6) {
  var e;
  r6.events.push(["postPutResources", function() {
    var t = this, n = /^(\d+) 0 obj$/;
    if (this.outline.root.children.length > 0) for (var i = t.outline.render().split(/\r\n/), a = 0; a < i.length; a++) {
      var s = i[a], o = n.exec(s);
      if (o != null) {
        var f = o[1];
        t.internal.newObjectDeferredBegin(f, false);
      }
      t.internal.write(s);
    }
    if (this.outline.createNamedDestinations) {
      var h = this.internal.pages.length, c = [];
      for (a = 0; a < h; a++) {
        var p = t.internal.newObject();
        c.push(p);
        var v = t.internal.getPageInfo(a + 1);
        t.internal.write("<< /D[" + v.objId + " 0 R /XYZ null null null]>> endobj");
      }
      var d = t.internal.newObject();
      for (t.internal.write("<< /Names [ "), a = 0; a < c.length; a++) t.internal.write("(page_" + (a + 1) + ")" + c[a] + " 0 R");
      t.internal.write(" ] >>", "endobj"), e = t.internal.newObject(), t.internal.write("<< /Dests " + d + " 0 R"), t.internal.write(">>", "endobj");
    }
  }]), r6.events.push(["putCatalog", function() {
    this.outline.root.children.length > 0 && (this.internal.write("/Outlines", this.outline.makeRef(this.outline.root)), this.outline.createNamedDestinations && this.internal.write("/Names " + e + " 0 R"));
  }]), r6.events.push(["initialized", function() {
    var t = this;
    t.outline = {
      createNamedDestinations: false,
      root: {
        children: []
      }
    }, t.outline.add = function(n, i, a) {
      var s = {
        title: i,
        options: a,
        children: []
      };
      return n == null && (n = this.root), n.children.push(s), s;
    }, t.outline.render = function() {
      return this.ctx = {}, this.ctx.val = "", this.ctx.pdf = t, this.genIds_r(this.root), this.renderRoot(this.root), this.renderItems(this.root), this.ctx.val;
    }, t.outline.genIds_r = function(n) {
      n.id = t.internal.newObjectDeferred();
      for (var i = 0; i < n.children.length; i++) this.genIds_r(n.children[i]);
    }, t.outline.renderRoot = function(n) {
      this.objStart(n), this.line("/Type /Outlines"), n.children.length > 0 && (this.line("/First " + this.makeRef(n.children[0])), this.line("/Last " + this.makeRef(n.children[n.children.length - 1]))), this.line("/Count " + this.count_r({
        count: 0
      }, n)), this.objEnd();
    }, t.outline.renderItems = function(n) {
      for (var i = this.ctx.pdf.internal.getVerticalCoordinateString, a = 0; a < n.children.length; a++) {
        var s = n.children[a];
        this.objStart(s), this.line("/Title " + this.makeString(s.title)), this.line("/Parent " + this.makeRef(n)), a > 0 && this.line("/Prev " + this.makeRef(n.children[a - 1])), a < n.children.length - 1 && this.line("/Next " + this.makeRef(n.children[a + 1])), s.children.length > 0 && (this.line("/First " + this.makeRef(s.children[0])), this.line("/Last " + this.makeRef(s.children[s.children.length - 1])));
        var o = this.count = this.count_r({
          count: 0
        }, s);
        if (o > 0 && this.line("/Count " + o), s.options && s.options.pageNumber) {
          var f = t.internal.getPageInfo(s.options.pageNumber);
          this.line("/Dest [" + f.objId + " 0 R /XYZ 0 " + i(0) + " 0]");
        }
        this.objEnd();
      }
      for (var h = 0; h < n.children.length; h++) this.renderItems(n.children[h]);
    }, t.outline.line = function(n) {
      this.ctx.val += n + `\r
`;
    }, t.outline.makeRef = function(n) {
      return n.id + " 0 R";
    }, t.outline.makeString = function(n) {
      return "(" + t.internal.pdfEscape(n) + ")";
    }, t.outline.objStart = function(n) {
      this.ctx.val += `\r
` + n.id + ` 0 obj\r
<<\r
`;
    }, t.outline.objEnd = function() {
      this.ctx.val += `>> \r
endobj\r
`;
    }, t.outline.count_r = function(n, i) {
      for (var a = 0; a < i.children.length; a++) n.count++, this.count_r(n, i.children[a]);
      return n.count;
    };
  }]);
}(ut.API), /**
* @license
*
* Licensed under the MIT License.
* http://opensource.org/licenses/mit-license
*/
function(r6) {
  var e = [192, 193, 194, 195, 196, 197, 198, 199];
  r6.processJPEG = function(t, n, i, a, s, o) {
    var f, h = this.decode.DCT_DECODE, c = null;
    if (typeof t == "string" || this.__addimage__.isArrayBuffer(t) || this.__addimage__.isArrayBufferView(t)) {
      switch (t = s || t, t = this.__addimage__.isArrayBuffer(t) ? new Uint8Array(t) : t, (f = function(p) {
        for (var v, d = 256 * p.charCodeAt(4) + p.charCodeAt(5), w = p.length, x = {
          width: 0,
          height: 0,
          numcomponents: 1
        }, S = 4; S < w; S += 2) {
          if (S += d, e.indexOf(p.charCodeAt(S + 1)) !== -1) {
            v = 256 * p.charCodeAt(S + 5) + p.charCodeAt(S + 6), x = {
              width: 256 * p.charCodeAt(S + 7) + p.charCodeAt(S + 8),
              height: v,
              numcomponents: p.charCodeAt(S + 9)
            };
            break;
          }
          d = 256 * p.charCodeAt(S + 2) + p.charCodeAt(S + 3);
        }
        return x;
      }(t = this.__addimage__.isArrayBufferView(t) ? this.__addimage__.arrayBufferToBinaryString(t) : t)).numcomponents) {
        case 1:
          o = this.color_spaces.DEVICE_GRAY;
          break;
        case 4:
          o = this.color_spaces.DEVICE_CMYK;
          break;
        case 3:
          o = this.color_spaces.DEVICE_RGB;
      }
      c = {
        data: t,
        width: f.width,
        height: f.height,
        colorSpace: o,
        bitsPerComponent: 8,
        filter: h,
        index: n,
        alias: i
      };
    }
    return c;
  };
}(ut.API);
var us;
var k0;
var Ic;
var Rc;
var Mc;
var y3 = function() {
  var r6, e, t;
  function n(a) {
    var s, o, f, h, c, p, v, d, w, x, S, A, b, O;
    for (this.data = a, this.pos = 8, this.palette = [], this.imgData = [], this.transparency = {}, this.animation = null, this.text = {}, p = null; ; ) {
      switch (s = this.readUInt32(), w = function() {
        var q, te;
        for (te = [], q = 0; q < 4; ++q) te.push(String.fromCharCode(this.data[this.pos++]));
        return te;
      }.call(this).join("")) {
        case "IHDR":
          this.width = this.readUInt32(), this.height = this.readUInt32(), this.bits = this.data[this.pos++], this.colorType = this.data[this.pos++], this.compressionMethod = this.data[this.pos++], this.filterMethod = this.data[this.pos++], this.interlaceMethod = this.data[this.pos++];
          break;
        case "acTL":
          this.animation = {
            numFrames: this.readUInt32(),
            numPlays: this.readUInt32() || 1 / 0,
            frames: []
          };
          break;
        case "PLTE":
          this.palette = this.read(s);
          break;
        case "fcTL":
          p && this.animation.frames.push(p), this.pos += 4, p = {
            width: this.readUInt32(),
            height: this.readUInt32(),
            xOffset: this.readUInt32(),
            yOffset: this.readUInt32()
          }, c = this.readUInt16(), h = this.readUInt16() || 100, p.delay = 1e3 * c / h, p.disposeOp = this.data[this.pos++], p.blendOp = this.data[this.pos++], p.data = [];
          break;
        case "IDAT":
        case "fdAT":
          for (w === "fdAT" && (this.pos += 4, s -= 4), a = (p != null ? p.data : void 0) || this.imgData, A = 0; 0 <= s ? A < s : A > s; 0 <= s ? ++A : --A) a.push(this.data[this.pos++]);
          break;
        case "tRNS":
          switch (this.transparency = {}, this.colorType) {
            case 3:
              if (f = this.palette.length / 3, this.transparency.indexed = this.read(s), this.transparency.indexed.length > f) throw new Error("More transparent colors than palette size");
              if ((x = f - this.transparency.indexed.length) > 0) for (b = 0; 0 <= x ? b < x : b > x; 0 <= x ? ++b : --b) this.transparency.indexed.push(255);
              break;
            case 0:
              this.transparency.grayscale = this.read(s)[0];
              break;
            case 2:
              this.transparency.rgb = this.read(s);
          }
          break;
        case "tEXt":
          v = (S = this.read(s)).indexOf(0), d = String.fromCharCode.apply(String, S.slice(0, v)), this.text[d] = String.fromCharCode.apply(String, S.slice(v + 1));
          break;
        case "IEND":
          return p && this.animation.frames.push(p), this.colors = function() {
            switch (this.colorType) {
              case 0:
              case 3:
              case 4:
                return 1;
              case 2:
              case 6:
                return 3;
            }
          }.call(this), this.hasAlphaChannel = (O = this.colorType) === 4 || O === 6, o = this.colors + (this.hasAlphaChannel ? 1 : 0), this.pixelBitlength = this.bits * o, this.colorSpace = function() {
            switch (this.colors) {
              case 1:
                return "DeviceGray";
              case 3:
                return "DeviceRGB";
            }
          }.call(this), void (this.imgData = new Uint8Array(this.imgData));
        default:
          this.pos += s;
      }
      if (this.pos += 4, this.pos > this.data.length) throw new Error("Incomplete or corrupt PNG file");
    }
  }
  n.prototype.read = function(a) {
    var s, o;
    for (o = [], s = 0; 0 <= a ? s < a : s > a; 0 <= a ? ++s : --s) o.push(this.data[this.pos++]);
    return o;
  }, n.prototype.readUInt32 = function() {
    return this.data[this.pos++] << 24 | this.data[this.pos++] << 16 | this.data[this.pos++] << 8 | this.data[this.pos++];
  }, n.prototype.readUInt16 = function() {
    return this.data[this.pos++] << 8 | this.data[this.pos++];
  }, n.prototype.decodePixels = function(a) {
    var s = this.pixelBitlength / 8, o = new Uint8Array(this.width * this.height * s), f = 0, h = this;
    if (a == null && (a = this.imgData), a.length === 0) return new Uint8Array(0);
    function c(p, v, d, w) {
      var x, S, A, b, O, q, te, le, j, M, H, ee, F, P, Y, Q, ce, we, Se, de, Ae, be = Math.ceil((h.width - p) / d), ze = Math.ceil((h.height - v) / w), y = h.width == be && h.height == ze;
      for (P = s * be, ee = y ? o : new Uint8Array(P * ze), q = a.length, F = 0, S = 0; F < ze && f < q; ) {
        switch (a[f++]) {
          case 0:
            for (b = ce = 0; ce < P; b = ce += 1) ee[S++] = a[f++];
            break;
          case 1:
            for (b = we = 0; we < P; b = we += 1) x = a[f++], O = b < s ? 0 : ee[S - s], ee[S++] = (x + O) % 256;
            break;
          case 2:
            for (b = Se = 0; Se < P; b = Se += 1) x = a[f++], A = (b - b % s) / s, Y = F && ee[(F - 1) * P + A * s + b % s], ee[S++] = (Y + x) % 256;
            break;
          case 3:
            for (b = de = 0; de < P; b = de += 1) x = a[f++], A = (b - b % s) / s, O = b < s ? 0 : ee[S - s], Y = F && ee[(F - 1) * P + A * s + b % s], ee[S++] = (x + Math.floor((O + Y) / 2)) % 256;
            break;
          case 4:
            for (b = Ae = 0; Ae < P; b = Ae += 1) x = a[f++], A = (b - b % s) / s, O = b < s ? 0 : ee[S - s], F === 0 ? Y = Q = 0 : (Y = ee[(F - 1) * P + A * s + b % s], Q = A && ee[(F - 1) * P + (A - 1) * s + b % s]), te = O + Y - Q, le = Math.abs(te - O), M = Math.abs(te - Y), H = Math.abs(te - Q), j = le <= M && le <= H ? O : M <= H ? Y : Q, ee[S++] = (x + j) % 256;
            break;
          default:
            throw new Error("Invalid filter algorithm: " + a[f - 1]);
        }
        if (!y) {
          var L = ((v + F * w) * h.width + p) * s, N = F * P;
          for (b = 0; b < be; b += 1) {
            for (var C = 0; C < s; C += 1) o[L++] = ee[N++];
            L += (d - 1) * s;
          }
        }
        F++;
      }
    }
    return a = Z4(a), h.interlaceMethod == 1 ? (c(0, 0, 8, 8), c(4, 0, 8, 8), c(0, 4, 4, 8), c(2, 0, 4, 4), c(0, 2, 2, 4), c(1, 0, 2, 2), c(0, 1, 1, 2)) : c(0, 0, 1, 1), o;
  }, n.prototype.decodePalette = function() {
    var a, s, o, f, h, c, p, v, d;
    for (o = this.palette, c = this.transparency.indexed || [], h = new Uint8Array((c.length || 0) + o.length), f = 0, a = 0, s = p = 0, v = o.length; p < v; s = p += 3) h[f++] = o[s], h[f++] = o[s + 1], h[f++] = o[s + 2], h[f++] = (d = c[a++]) != null ? d : 255;
    return h;
  }, n.prototype.copyToImageData = function(a, s) {
    var o, f, h, c, p, v, d, w, x, S, A;
    if (f = this.colors, x = null, o = this.hasAlphaChannel, this.palette.length && (x = (A = this._decodedPalette) != null ? A : this._decodedPalette = this.decodePalette(), f = 4, o = true), w = (h = a.data || a).length, p = x || s, c = v = 0, f === 1) for (; c < w; ) d = x ? 4 * s[c / 4] : v, S = p[d++], h[c++] = S, h[c++] = S, h[c++] = S, h[c++] = o ? p[d++] : 255, v = d;
    else for (; c < w; ) d = x ? 4 * s[c / 4] : v, h[c++] = p[d++], h[c++] = p[d++], h[c++] = p[d++], h[c++] = o ? p[d++] : 255, v = d;
  }, n.prototype.decode = function() {
    var a;
    return a = new Uint8Array(this.width * this.height * 4), this.copyToImageData(a, this.decodePixels()), a;
  };
  var i = function() {
    if (Object.prototype.toString.call(dt) === "[object Window]") {
      try {
        e = dt.document.createElement("canvas"), t = e.getContext("2d");
      } catch {
        return false;
      }
      return true;
    }
    return false;
  };
  return i(), r6 = function(a) {
    var s;
    if (i() === true) return t.width = a.width, t.height = a.height, t.clearRect(0, 0, a.width, a.height), t.putImageData(a, 0, 0), (s = new Image()).src = e.toDataURL(), s;
    throw new Error("This method requires a Browser with Canvas-capability.");
  }, n.prototype.decodeFrames = function(a) {
    var s, o, f, h, c, p, v, d;
    if (this.animation) {
      for (d = [], o = c = 0, p = (v = this.animation.frames).length; c < p; o = ++c) s = v[o], f = a.createImageData(s.width, s.height), h = this.decodePixels(new Uint8Array(s.data)), this.copyToImageData(f, h), s.imageData = f, d.push(s.image = r6(f));
      return d;
    }
  }, n.prototype.renderFrame = function(a, s) {
    var o, f, h;
    return o = (f = this.animation.frames)[s], h = f[s - 1], s === 0 && a.clearRect(0, 0, this.width, this.height), (h != null ? h.disposeOp : void 0) === 1 ? a.clearRect(h.xOffset, h.yOffset, h.width, h.height) : (h != null ? h.disposeOp : void 0) === 2 && a.putImageData(h.imageData, h.xOffset, h.yOffset), o.blendOp === 0 && a.clearRect(o.xOffset, o.yOffset, o.width, o.height), a.drawImage(o.image, o.xOffset, o.yOffset);
  }, n.prototype.animate = function(a) {
    var s, o, f, h, c, p, v = this;
    return o = 0, p = this.animation, h = p.numFrames, f = p.frames, c = p.numPlays, (s = function() {
      var d, w;
      if (d = o++ % h, w = f[d], v.renderFrame(a, d), h > 1 && o / h < c) return v.animation._timeout = setTimeout(s, w.delay);
    })();
  }, n.prototype.stopAnimation = function() {
    var a;
    return clearTimeout((a = this.animation) != null ? a._timeout : void 0);
  }, n.prototype.render = function(a) {
    var s, o;
    return a._png && a._png.stopAnimation(), a._png = this, a.width = this.width, a.height = this.height, s = a.getContext("2d"), this.animation ? (this.decodeFrames(s), this.animate(s)) : (o = s.createImageData(this.width, this.height), this.copyToImageData(o, this.decodePixels()), s.putImageData(o, 0, 0));
  }, n;
}();
function _3(r6) {
  var e = 0;
  if (r6[e++] !== 71 || r6[e++] !== 73 || r6[e++] !== 70 || r6[e++] !== 56 || (r6[e++] + 1 & 253) != 56 || r6[e++] !== 97) throw new Error("Invalid GIF 87a/89a header.");
  var t = r6[e++] | r6[e++] << 8, n = r6[e++] | r6[e++] << 8, i = r6[e++], a = i >> 7, s = 1 << (7 & i) + 1;
  r6[e++], r6[e++];
  var o = null, f = null;
  a && (o = e, f = s, e += 3 * s);
  var h = true, c = [], p = 0, v = null, d = 0, w = null;
  for (this.width = t, this.height = n; h && e < r6.length; ) switch (r6[e++]) {
    case 33:
      switch (r6[e++]) {
        case 255:
          if (r6[e] !== 11 || r6[e + 1] == 78 && r6[e + 2] == 69 && r6[e + 3] == 84 && r6[e + 4] == 83 && r6[e + 5] == 67 && r6[e + 6] == 65 && r6[e + 7] == 80 && r6[e + 8] == 69 && r6[e + 9] == 50 && r6[e + 10] == 46 && r6[e + 11] == 48 && r6[e + 12] == 3 && r6[e + 13] == 1 && r6[e + 16] == 0) e += 14, w = r6[e++] | r6[e++] << 8, e++;
          else for (e += 12; ; ) {
            if (!((F = r6[e++]) >= 0)) throw Error("Invalid block size");
            if (F === 0) break;
            e += F;
          }
          break;
        case 249:
          if (r6[e++] !== 4 || r6[e + 4] !== 0) throw new Error("Invalid graphics extension block.");
          var x = r6[e++];
          p = r6[e++] | r6[e++] << 8, v = r6[e++], !(1 & x) && (v = null), d = x >> 2 & 7, e++;
          break;
        case 254:
          for (; ; ) {
            if (!((F = r6[e++]) >= 0)) throw Error("Invalid block size");
            if (F === 0) break;
            e += F;
          }
          break;
        default:
          throw new Error("Unknown graphic control label: 0x" + r6[e - 1].toString(16));
      }
      break;
    case 44:
      var S = r6[e++] | r6[e++] << 8, A = r6[e++] | r6[e++] << 8, b = r6[e++] | r6[e++] << 8, O = r6[e++] | r6[e++] << 8, q = r6[e++], te = q >> 6 & 1, le = 1 << (7 & q) + 1, j = o, M = f, H = false;
      q >> 7 && (H = true, j = e, M = le, e += 3 * le);
      var ee = e;
      for (e++; ; ) {
        var F;
        if (!((F = r6[e++]) >= 0)) throw Error("Invalid block size");
        if (F === 0) break;
        e += F;
      }
      c.push({
        x: S,
        y: A,
        width: b,
        height: O,
        has_local_palette: H,
        palette_offset: j,
        palette_size: M,
        data_offset: ee,
        data_length: e - ee,
        transparent_index: v,
        interlaced: !!te,
        delay: p,
        disposal: d
      });
      break;
    case 59:
      h = false;
      break;
    default:
      throw new Error("Unknown gif block: 0x" + r6[e - 1].toString(16));
  }
  this.numFrames = function() {
    return c.length;
  }, this.loopCount = function() {
    return w;
  }, this.frameInfo = function(P) {
    if (P < 0 || P >= c.length) throw new Error("Frame index out of range.");
    return c[P];
  }, this.decodeAndBlitFrameBGRA = function(P, Y) {
    var Q = this.frameInfo(P), ce = Q.width * Q.height, we = new Uint8Array(ce);
    Bc(r6, Q.data_offset, we, ce);
    var Se = Q.palette_offset, de = Q.transparent_index;
    de === null && (de = 256);
    var Ae = Q.width, be = t - Ae, ze = Ae, y = 4 * (Q.y * t + Q.x), L = 4 * ((Q.y + Q.height) * t + Q.x), N = y, C = 4 * be;
    Q.interlaced === true && (C += 4 * t * 7);
    for (var z = 8, re = 0, se = we.length; re < se; ++re) {
      var ie = we[re];
      if (ze === 0 && (ze = Ae, (N += C) >= L && (C = 4 * be + 4 * t * (z - 1), N = y + (Ae + be) * (z << 1), z >>= 1)), ie === de) N += 4;
      else {
        var ve = r6[Se + 3 * ie], Ce = r6[Se + 3 * ie + 1], Oe = r6[Se + 3 * ie + 2];
        Y[N++] = Oe, Y[N++] = Ce, Y[N++] = ve, Y[N++] = 255;
      }
      --ze;
    }
  }, this.decodeAndBlitFrameRGBA = function(P, Y) {
    var Q = this.frameInfo(P), ce = Q.width * Q.height, we = new Uint8Array(ce);
    Bc(r6, Q.data_offset, we, ce);
    var Se = Q.palette_offset, de = Q.transparent_index;
    de === null && (de = 256);
    var Ae = Q.width, be = t - Ae, ze = Ae, y = 4 * (Q.y * t + Q.x), L = 4 * ((Q.y + Q.height) * t + Q.x), N = y, C = 4 * be;
    Q.interlaced === true && (C += 4 * t * 7);
    for (var z = 8, re = 0, se = we.length; re < se; ++re) {
      var ie = we[re];
      if (ze === 0 && (ze = Ae, (N += C) >= L && (C = 4 * be + 4 * t * (z - 1), N = y + (Ae + be) * (z << 1), z >>= 1)), ie === de) N += 4;
      else {
        var ve = r6[Se + 3 * ie], Ce = r6[Se + 3 * ie + 1], Oe = r6[Se + 3 * ie + 2];
        Y[N++] = ve, Y[N++] = Ce, Y[N++] = Oe, Y[N++] = 255;
      }
      --ze;
    }
  };
}
function Bc(r6, e, t, n) {
  for (var i = r6[e++], a = 1 << i, s = a + 1, o = s + 1, f = i + 1, h = (1 << f) - 1, c = 0, p = 0, v = 0, d = r6[e++], w = new Int32Array(4096), x = null; ; ) {
    for (; c < 16 && d !== 0; ) p |= r6[e++] << c, c += 8, d === 1 ? d = r6[e++] : --d;
    if (c < f) break;
    var S = p & h;
    if (p >>= f, c -= f, S !== a) {
      if (S === s) break;
      for (var A = S < o ? S : x, b = 0, O = A; O > a; ) O = w[O] >> 8, ++b;
      var q = O;
      if (v + b + (A !== S ? 1 : 0) > n) return void Kt.log("Warning, gif stream longer than expected.");
      t[v++] = q;
      var te = v += b;
      for (A !== S && (t[v++] = q), O = A; b--; ) O = w[O], t[--te] = 255 & O, O >>= 8;
      x !== null && o < 4096 && (w[o++] = x << 8 | q, o >= h + 1 && f < 12 && (++f, h = h << 1 | 1)), x = S;
    } else o = s + 1, h = (1 << (f = i + 1)) - 1, x = null;
  }
  return v !== n && Kt.log("Warning, gif stream shorter than expected."), t;
}
function ul(r6) {
  var e, t, n, i, a, s = Math.floor, o = new Array(64), f = new Array(64), h = new Array(64), c = new Array(64), p = new Array(65535), v = new Array(65535), d = new Array(64), w = new Array(64), x = [], S = 0, A = 7, b = new Array(64), O = new Array(64), q = new Array(64), te = new Array(256), le = new Array(2048), j = [0, 1, 5, 6, 14, 15, 27, 28, 2, 4, 7, 13, 16, 26, 29, 42, 3, 8, 12, 17, 25, 30, 41, 43, 9, 11, 18, 24, 31, 40, 44, 53, 10, 19, 23, 32, 39, 45, 52, 54, 20, 22, 33, 38, 46, 51, 55, 60, 21, 34, 37, 47, 50, 56, 59, 61, 35, 36, 48, 49, 57, 58, 62, 63], M = [0, 0, 1, 5, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0], H = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11], ee = [0, 0, 2, 1, 3, 3, 2, 4, 3, 5, 5, 4, 4, 0, 0, 1, 125], F = [1, 2, 3, 0, 4, 17, 5, 18, 33, 49, 65, 6, 19, 81, 97, 7, 34, 113, 20, 50, 129, 145, 161, 8, 35, 66, 177, 193, 21, 82, 209, 240, 36, 51, 98, 114, 130, 9, 10, 22, 23, 24, 25, 26, 37, 38, 39, 40, 41, 42, 52, 53, 54, 55, 56, 57, 58, 67, 68, 69, 70, 71, 72, 73, 74, 83, 84, 85, 86, 87, 88, 89, 90, 99, 100, 101, 102, 103, 104, 105, 106, 115, 116, 117, 118, 119, 120, 121, 122, 131, 132, 133, 134, 135, 136, 137, 138, 146, 147, 148, 149, 150, 151, 152, 153, 154, 162, 163, 164, 165, 166, 167, 168, 169, 170, 178, 179, 180, 181, 182, 183, 184, 185, 186, 194, 195, 196, 197, 198, 199, 200, 201, 202, 210, 211, 212, 213, 214, 215, 216, 217, 218, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250], P = [0, 0, 3, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0], Y = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11], Q = [0, 0, 2, 1, 2, 4, 4, 3, 4, 7, 5, 4, 4, 0, 1, 2, 119], ce = [0, 1, 2, 3, 17, 4, 5, 33, 49, 6, 18, 65, 81, 7, 97, 113, 19, 34, 50, 129, 8, 20, 66, 145, 161, 177, 193, 9, 35, 51, 82, 240, 21, 98, 114, 209, 10, 22, 36, 52, 225, 37, 241, 23, 24, 25, 26, 38, 39, 40, 41, 42, 53, 54, 55, 56, 57, 58, 67, 68, 69, 70, 71, 72, 73, 74, 83, 84, 85, 86, 87, 88, 89, 90, 99, 100, 101, 102, 103, 104, 105, 106, 115, 116, 117, 118, 119, 120, 121, 122, 130, 131, 132, 133, 134, 135, 136, 137, 138, 146, 147, 148, 149, 150, 151, 152, 153, 154, 162, 163, 164, 165, 166, 167, 168, 169, 170, 178, 179, 180, 181, 182, 183, 184, 185, 186, 194, 195, 196, 197, 198, 199, 200, 201, 202, 210, 211, 212, 213, 214, 215, 216, 217, 218, 226, 227, 228, 229, 230, 231, 232, 233, 234, 242, 243, 244, 245, 246, 247, 248, 249, 250];
  function we(y, L) {
    for (var N = 0, C = 0, z = new Array(), re = 1; re <= 16; re++) {
      for (var se = 1; se <= y[re]; se++) z[L[C]] = [], z[L[C]][0] = N, z[L[C]][1] = re, C++, N++;
      N *= 2;
    }
    return z;
  }
  function Se(y) {
    for (var L = y[0], N = y[1] - 1; N >= 0; ) L & 1 << N && (S |= 1 << A), N--, --A < 0 && (S == 255 ? (de(255), de(0)) : de(S), A = 7, S = 0);
  }
  function de(y) {
    x.push(y);
  }
  function Ae(y) {
    de(y >> 8 & 255), de(255 & y);
  }
  function be(y, L, N, C, z) {
    for (var re, se = z[0], ie = z[240], ve = function(Be, We) {
      var $e, Je, st, ot, gt, _t, Tt, Et, ct, At, Qe = 0;
      for (ct = 0; ct < 8; ++ct) {
        $e = Be[Qe], Je = Be[Qe + 1], st = Be[Qe + 2], ot = Be[Qe + 3], gt = Be[Qe + 4], _t = Be[Qe + 5], Tt = Be[Qe + 6];
        var br = $e + (Et = Be[Qe + 7]), Ft = $e - Et, sn = Je + Tt, Rt = Je - Tt, Jt = st + _t, Cn = st - _t, Ct = ot + gt, oi = ot - gt, er = br + Ct, mn = br - Ct, Wn = sn + Jt, Yt = sn - Jt;
        Be[Qe] = er + Wn, Be[Qe + 4] = er - Wn;
        var vt = 0.707106781 * (Yt + mn);
        Be[Qe + 2] = mn + vt, Be[Qe + 6] = mn - vt;
        var kt = 0.382683433 * ((er = oi + Cn) - (Yt = Rt + Ft)), _i = 0.5411961 * er + kt, Tr = 1.306562965 * Yt + kt, Pn = 0.707106781 * (Wn = Cn + Rt), kn = Ft + Pn, lt = Ft - Pn;
        Be[Qe + 5] = lt + _i, Be[Qe + 3] = lt - _i, Be[Qe + 1] = kn + Tr, Be[Qe + 7] = kn - Tr, Qe += 8;
      }
      for (Qe = 0, ct = 0; ct < 8; ++ct) {
        $e = Be[Qe], Je = Be[Qe + 8], st = Be[Qe + 16], ot = Be[Qe + 24], gt = Be[Qe + 32], _t = Be[Qe + 40], Tt = Be[Qe + 48];
        var xn = $e + (Et = Be[Qe + 56]), on = $e - Et, Wr = Je + Tt, hr = Je - Tt, ir = st + _t, D = st - _t, X = ot + gt, U = ot - gt, W = xn + X, G = xn - X, K = Wr + ir, ge = Wr - ir;
        Be[Qe] = W + K, Be[Qe + 32] = W - K;
        var Ee = 0.707106781 * (ge + G);
        Be[Qe + 16] = G + Ee, Be[Qe + 48] = G - Ee;
        var pe = 0.382683433 * ((W = U + D) - (ge = hr + on)), ye = 0.5411961 * W + pe, _e = 1.306562965 * ge + pe, Ue = 0.707106781 * (K = D + hr), Ve = on + Ue, tt = on - Ue;
        Be[Qe + 40] = tt + ye, Be[Qe + 24] = tt - ye, Be[Qe + 8] = Ve + _e, Be[Qe + 56] = Ve - _e, Qe++;
      }
      for (ct = 0; ct < 64; ++ct) At = Be[ct] * We[ct], d[ct] = At > 0 ? At + 0.5 | 0 : At - 0.5 | 0;
      return d;
    }(y, L), Ce = 0; Ce < 64; ++Ce) w[j[Ce]] = ve[Ce];
    var Oe = w[0] - N;
    N = w[0], Oe == 0 ? Se(C[0]) : (Se(C[v[re = 32767 + Oe]]), Se(p[re]));
    for (var qe = 63; qe > 0 && w[qe] == 0; ) qe--;
    if (qe == 0) return Se(se), N;
    for (var Ye, Te = 1; Te <= qe; ) {
      for (var Z = Te; w[Te] == 0 && Te <= qe; ) ++Te;
      var Ie = Te - Z;
      if (Ie >= 16) {
        Ye = Ie >> 4;
        for (var rt = 1; rt <= Ye; ++rt) Se(ie);
        Ie &= 15;
      }
      re = 32767 + w[Te], Se(z[(Ie << 4) + v[re]]), Se(p[re]), Te++;
    }
    return qe != 63 && Se(se), N;
  }
  function ze(y) {
    y = Math.min(Math.max(y, 1), 100), a != y && (function(L) {
      for (var N = [16, 11, 10, 16, 24, 40, 51, 61, 12, 12, 14, 19, 26, 58, 60, 55, 14, 13, 16, 24, 40, 57, 69, 56, 14, 17, 22, 29, 51, 87, 80, 62, 18, 22, 37, 56, 68, 109, 103, 77, 24, 35, 55, 64, 81, 104, 113, 92, 49, 64, 78, 87, 103, 121, 120, 101, 72, 92, 95, 98, 112, 100, 103, 99], C = 0; C < 64; C++) {
        var z = s((N[C] * L + 50) / 100);
        z = Math.min(Math.max(z, 1), 255), o[j[C]] = z;
      }
      for (var re = [17, 18, 24, 47, 99, 99, 99, 99, 18, 21, 26, 66, 99, 99, 99, 99, 24, 26, 56, 99, 99, 99, 99, 99, 47, 66, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99], se = 0; se < 64; se++) {
        var ie = s((re[se] * L + 50) / 100);
        ie = Math.min(Math.max(ie, 1), 255), f[j[se]] = ie;
      }
      for (var ve = [1, 1.387039845, 1.306562965, 1.175875602, 1, 0.785694958, 0.5411961, 0.275899379], Ce = 0, Oe = 0; Oe < 8; Oe++) for (var qe = 0; qe < 8; qe++) h[Ce] = 1 / (o[j[Ce]] * ve[Oe] * ve[qe] * 8), c[Ce] = 1 / (f[j[Ce]] * ve[Oe] * ve[qe] * 8), Ce++;
    }(y < 50 ? Math.floor(5e3 / y) : Math.floor(200 - 2 * y)), a = y);
  }
  this.encode = function(y, L) {
    L && ze(L), x = new Array(), S = 0, A = 7, Ae(65496), Ae(65504), Ae(16), de(74), de(70), de(73), de(70), de(0), de(1), de(1), de(0), Ae(1), Ae(1), de(0), de(0), function() {
      Ae(65499), Ae(132), de(0);
      for (var Je = 0; Je < 64; Je++) de(o[Je]);
      de(1);
      for (var st = 0; st < 64; st++) de(f[st]);
    }(), function(Je, st) {
      Ae(65472), Ae(17), de(8), Ae(st), Ae(Je), de(3), de(1), de(17), de(0), de(2), de(17), de(1), de(3), de(17), de(1);
    }(y.width, y.height), function() {
      Ae(65476), Ae(418), de(0);
      for (var Je = 0; Je < 16; Je++) de(M[Je + 1]);
      for (var st = 0; st <= 11; st++) de(H[st]);
      de(16);
      for (var ot = 0; ot < 16; ot++) de(ee[ot + 1]);
      for (var gt = 0; gt <= 161; gt++) de(F[gt]);
      de(1);
      for (var _t = 0; _t < 16; _t++) de(P[_t + 1]);
      for (var Tt = 0; Tt <= 11; Tt++) de(Y[Tt]);
      de(17);
      for (var Et = 0; Et < 16; Et++) de(Q[Et + 1]);
      for (var ct = 0; ct <= 161; ct++) de(ce[ct]);
    }(), Ae(65498), Ae(12), de(3), de(1), de(0), de(2), de(17), de(3), de(17), de(0), de(63), de(0);
    var N = 0, C = 0, z = 0;
    S = 0, A = 7, this.encode.displayName = "_encode_";
    for (var re, se, ie, ve, Ce, Oe, qe, Ye, Te, Z = y.data, Ie = y.width, rt = y.height, Be = 4 * Ie, We = 0; We < rt; ) {
      for (re = 0; re < Be; ) {
        for (Ce = Be * We + re, qe = -1, Ye = 0, Te = 0; Te < 64; Te++) Oe = Ce + (Ye = Te >> 3) * Be + (qe = 4 * (7 & Te)), We + Ye >= rt && (Oe -= Be * (We + 1 + Ye - rt)), re + qe >= Be && (Oe -= re + qe - Be + 4), se = Z[Oe++], ie = Z[Oe++], ve = Z[Oe++], b[Te] = (le[se] + le[ie + 256 >> 0] + le[ve + 512 >> 0] >> 16) - 128, O[Te] = (le[se + 768 >> 0] + le[ie + 1024 >> 0] + le[ve + 1280 >> 0] >> 16) - 128, q[Te] = (le[se + 1280 >> 0] + le[ie + 1536 >> 0] + le[ve + 1792 >> 0] >> 16) - 128;
        N = be(b, h, N, e, n), C = be(O, c, C, t, i), z = be(q, c, z, t, i), re += 32;
      }
      We += 8;
    }
    if (A >= 0) {
      var $e = [];
      $e[1] = A + 1, $e[0] = (1 << A + 1) - 1, Se($e);
    }
    return Ae(65497), new Uint8Array(x);
  }, r6 = r6 || 50, function() {
    for (var y = String.fromCharCode, L = 0; L < 256; L++) te[L] = y(L);
  }(), e = we(M, H), t = we(P, Y), n = we(ee, F), i = we(Q, ce), function() {
    for (var y = 1, L = 2, N = 1; N <= 15; N++) {
      for (var C = y; C < L; C++) v[32767 + C] = N, p[32767 + C] = [], p[32767 + C][1] = N, p[32767 + C][0] = C;
      for (var z = -(L - 1); z <= -y; z++) v[32767 + z] = N, p[32767 + z] = [], p[32767 + z][1] = N, p[32767 + z][0] = L - 1 + z;
      y <<= 1, L <<= 1;
    }
  }(), function() {
    for (var y = 0; y < 256; y++) le[y] = 19595 * y, le[y + 256 >> 0] = 38470 * y, le[y + 512 >> 0] = 7471 * y + 32768, le[y + 768 >> 0] = -11059 * y, le[y + 1024 >> 0] = -21709 * y, le[y + 1280 >> 0] = 32768 * y + 8421375, le[y + 1536 >> 0] = -27439 * y, le[y + 1792 >> 0] = -5329 * y;
  }(), ze(r6);
}
function ei(r6, e) {
  if (this.pos = 0, this.buffer = r6, this.datav = new DataView(r6.buffer), this.is_with_alpha = !!e, this.bottom_up = true, this.flag = String.fromCharCode(this.buffer[0]) + String.fromCharCode(this.buffer[1]), this.pos += 2, ["BM", "BA", "CI", "CP", "IC", "PT"].indexOf(this.flag) === -1) throw new Error("Invalid BMP File");
  this.parseHeader(), this.parseBGR();
}
function jc(r6) {
  function e(M) {
    if (!M) throw Error("assert :P");
  }
  function t(M, H, ee) {
    for (var F = 0; 4 > F; F++) if (M[H + F] != ee.charCodeAt(F)) return true;
    return false;
  }
  function n(M, H, ee, F, P) {
    for (var Y = 0; Y < P; Y++) M[H + Y] = ee[F + Y];
  }
  function i(M, H, ee, F) {
    for (var P = 0; P < F; P++) M[H + P] = ee;
  }
  function a(M) {
    return new Int32Array(M);
  }
  function s(M, H) {
    for (var ee = [], F = 0; F < M; F++) ee.push(new H());
    return ee;
  }
  function o(M, H) {
    var ee = [];
    return function F(P, Y, Q) {
      for (var ce = Q[Y], we = 0; we < ce && (P.push(Q.length > Y + 1 ? [] : new H()), !(Q.length < Y + 1)); we++) F(P[we], Y + 1, Q);
    }(ee, 0, M), ee;
  }
  var f = function() {
    var M = this;
    function H(l, u) {
      for (var m = 1 << u - 1 >>> 0; l & m; ) m >>>= 1;
      return m ? (l & m - 1) + m : l;
    }
    function ee(l, u, m, _, T) {
      e(!(_ % m));
      do
        l[u + (_ -= m)] = T;
      while (0 < _);
    }
    function F(l, u, m, _, T) {
      if (e(2328 >= T), 512 >= T) var k = a(512);
      else if ((k = a(T)) == null) return 0;
      return function(I, R, B, V, ae, me) {
        var xe, he, De = R, Ne = 1 << B, oe = a(16), fe = a(16);
        for (e(ae != 0), e(V != null), e(I != null), e(0 < B), he = 0; he < ae; ++he) {
          if (15 < V[he]) return 0;
          ++oe[V[he]];
        }
        if (oe[0] == ae) return 0;
        for (fe[1] = 0, xe = 1; 15 > xe; ++xe) {
          if (oe[xe] > 1 << xe) return 0;
          fe[xe + 1] = fe[xe] + oe[xe];
        }
        for (he = 0; he < ae; ++he) xe = V[he], 0 < V[he] && (me[fe[xe]++] = he);
        if (fe[15] == 1) return (V = new P()).g = 0, V.value = me[0], ee(I, De, 1, Ne, V), Ne;
        var Pe, Me = -1, ke = Ne - 1, it = 0, Ke = 1, ht = 1, Ze = 1 << B;
        for (he = 0, xe = 1, ae = 2; xe <= B; ++xe, ae <<= 1) {
          if (Ke += ht <<= 1, 0 > (ht -= oe[xe])) return 0;
          for (; 0 < oe[xe]; --oe[xe]) (V = new P()).g = xe, V.value = me[he++], ee(I, De + it, ae, Ze, V), it = H(it, xe);
        }
        for (xe = B + 1, ae = 2; 15 >= xe; ++xe, ae <<= 1) {
          if (Ke += ht <<= 1, 0 > (ht -= oe[xe])) return 0;
          for (; 0 < oe[xe]; --oe[xe]) {
            if (V = new P(), (it & ke) != Me) {
              for (De += Ze, Pe = 1 << (Me = xe) - B; 15 > Me && !(0 >= (Pe -= oe[Me])); ) ++Me, Pe <<= 1;
              Ne += Ze = 1 << (Pe = Me - B), I[R + (Me = it & ke)].g = Pe + B, I[R + Me].value = De - R - Me;
            }
            V.g = xe - B, V.value = me[he++], ee(I, De + (it >> B), ae, Ze, V), it = H(it, xe);
          }
        }
        return Ke != 2 * fe[15] - 1 ? 0 : Ne;
      }(l, u, m, _, T, k);
    }
    function P() {
      this.value = this.g = 0;
    }
    function Y() {
      this.value = this.g = 0;
    }
    function Q() {
      this.G = s(5, P), this.H = a(5), this.jc = this.Qb = this.qb = this.nd = 0, this.pd = s(Ir, Y);
    }
    function ce(l, u, m, _) {
      e(l != null), e(u != null), e(2147483648 > _), l.Ca = 254, l.I = 0, l.b = -8, l.Ka = 0, l.oa = u, l.pa = m, l.Jd = u, l.Yc = m + _, l.Zc = 4 <= _ ? m + _ - 4 + 1 : m, re(l);
    }
    function we(l, u) {
      for (var m = 0; 0 < u--; ) m |= ie(l, 128) << u;
      return m;
    }
    function Se(l, u) {
      var m = we(l, u);
      return se(l) ? -m : m;
    }
    function de(l, u, m, _) {
      var T, k = 0;
      for (e(l != null), e(u != null), e(4294967288 > _), l.Sb = _, l.Ra = 0, l.u = 0, l.h = 0, 4 < _ && (_ = 4), T = 0; T < _; ++T) k += u[m + T] << 8 * T;
      l.Ra = k, l.bb = _, l.oa = u, l.pa = m;
    }
    function Ae(l) {
      for (; 8 <= l.u && l.bb < l.Sb; ) l.Ra >>>= 8, l.Ra += l.oa[l.pa + l.bb] << Za - 8 >>> 0, ++l.bb, l.u -= 8;
      N(l) && (l.h = 1, l.u = 0);
    }
    function be(l, u) {
      if (e(0 <= u), !l.h && u <= Ja) {
        var m = L(l) & Ka[u];
        return l.u += u, Ae(l), m;
      }
      return l.h = 1, l.u = 0;
    }
    function ze() {
      this.b = this.Ca = this.I = 0, this.oa = [], this.pa = 0, this.Jd = [], this.Yc = 0, this.Zc = [], this.Ka = 0;
    }
    function y() {
      this.Ra = 0, this.oa = [], this.h = this.u = this.bb = this.Sb = this.pa = 0;
    }
    function L(l) {
      return l.Ra >>> (l.u & Za - 1) >>> 0;
    }
    function N(l) {
      return e(l.bb <= l.Sb), l.h || l.bb == l.Sb && l.u > Za;
    }
    function C(l, u) {
      l.u = u, l.h = N(l);
    }
    function z(l) {
      l.u >= $s && (e(l.u >= $s), Ae(l));
    }
    function re(l) {
      e(l != null && l.oa != null), l.pa < l.Zc ? (l.I = (l.oa[l.pa++] | l.I << 8) >>> 0, l.b += 8) : (e(l != null && l.oa != null), l.pa < l.Yc ? (l.b += 8, l.I = l.oa[l.pa++] | l.I << 8) : l.Ka ? l.b = 0 : (l.I <<= 8, l.b += 8, l.Ka = 1));
    }
    function se(l) {
      return we(l, 1);
    }
    function ie(l, u) {
      var m = l.Ca;
      0 > l.b && re(l);
      var _ = l.b, T = m * u >>> 8, k = (l.I >>> _ > T) + 0;
      for (k ? (m -= T, l.I -= T + 1 << _ >>> 0) : m = T + 1, _ = m, T = 0; 256 <= _; ) T += 8, _ >>= 8;
      return _ = 7 ^ T + ln[_], l.b -= _, l.Ca = (m << _) - 1, k;
    }
    function ve(l, u, m) {
      l[u + 0] = m >> 24 & 255, l[u + 1] = m >> 16 & 255, l[u + 2] = m >> 8 & 255, l[u + 3] = m >> 0 & 255;
    }
    function Ce(l, u) {
      return l[u + 0] << 0 | l[u + 1] << 8;
    }
    function Oe(l, u) {
      return Ce(l, u) | l[u + 2] << 16;
    }
    function qe(l, u) {
      return Ce(l, u) | Ce(l, u + 2) << 16;
    }
    function Ye(l, u) {
      var m = 1 << u;
      return e(l != null), e(0 < u), l.X = a(m), l.X == null ? 0 : (l.Mb = 32 - u, l.Xa = u, 1);
    }
    function Te(l, u) {
      e(l != null), e(u != null), e(l.Xa == u.Xa), n(u.X, 0, l.X, 0, 1 << u.Xa);
    }
    function Z() {
      this.X = [], this.Xa = this.Mb = 0;
    }
    function Ie(l, u, m, _) {
      e(m != null), e(_ != null);
      var T = m[0], k = _[0];
      return T == 0 && (T = (l * k + u / 2) / u), k == 0 && (k = (u * T + l / 2) / l), 0 >= T || 0 >= k ? 0 : (m[0] = T, _[0] = k, 1);
    }
    function rt(l, u) {
      return l + (1 << u) - 1 >>> u;
    }
    function Be(l, u) {
      return ((4278255360 & l) + (4278255360 & u) >>> 0 & 4278255360) + ((16711935 & l) + (16711935 & u) >>> 0 & 16711935) >>> 0;
    }
    function We(l, u) {
      M[u] = function(m, _, T, k, I, R, B) {
        var V;
        for (V = 0; V < I; ++V) {
          var ae = M[l](R[B + V - 1], T, k + V);
          R[B + V] = Be(m[_ + V], ae);
        }
      };
    }
    function $e() {
      this.ud = this.hd = this.jd = 0;
    }
    function Je(l, u) {
      return ((4278124286 & (l ^ u)) >>> 1) + (l & u) >>> 0;
    }
    function st(l) {
      return 0 <= l && 256 > l ? l : 0 > l ? 0 : 255 < l ? 255 : void 0;
    }
    function ot(l, u) {
      return st(l + (l - u + 0.5 >> 1));
    }
    function gt(l, u, m) {
      return Math.abs(u - m) - Math.abs(l - m);
    }
    function _t(l, u, m, _, T, k, I) {
      for (_ = k[I - 1], m = 0; m < T; ++m) k[I + m] = _ = Be(l[u + m], _);
    }
    function Tt(l, u, m, _, T) {
      var k;
      for (k = 0; k < m; ++k) {
        var I = l[u + k], R = I >> 8 & 255, B = 16711935 & (B = (B = 16711935 & I) + ((R << 16) + R));
        _[T + k] = (4278255360 & I) + B >>> 0;
      }
    }
    function Et(l, u) {
      u.jd = l >> 0 & 255, u.hd = l >> 8 & 255, u.ud = l >> 16 & 255;
    }
    function ct(l, u, m, _, T, k) {
      var I;
      for (I = 0; I < _; ++I) {
        var R = u[m + I], B = R >>> 8, V = R, ae = 255 & (ae = (ae = R >>> 16) + ((l.jd << 24 >> 24) * (B << 24 >> 24) >>> 5));
        V = 255 & (V = (V = V + ((l.hd << 24 >> 24) * (B << 24 >> 24) >>> 5)) + ((l.ud << 24 >> 24) * (ae << 24 >> 24) >>> 5)), T[k + I] = (4278255360 & R) + (ae << 16) + V;
      }
    }
    function At(l, u, m, _, T) {
      M[u] = function(k, I, R, B, V, ae, me, xe, he) {
        for (B = me; B < xe; ++B) for (me = 0; me < he; ++me) V[ae++] = T(R[_(k[I++])]);
      }, M[l] = function(k, I, R, B, V, ae, me) {
        var xe = 8 >> k.b, he = k.Ea, De = k.K[0], Ne = k.w;
        if (8 > xe) for (k = (1 << k.b) - 1, Ne = (1 << xe) - 1; I < R; ++I) {
          var oe, fe = 0;
          for (oe = 0; oe < he; ++oe) oe & k || (fe = _(B[V++])), ae[me++] = T(De[fe & Ne]), fe >>= xe;
        }
        else M["VP8LMapColor" + m](B, V, De, Ne, ae, me, I, R, he);
      };
    }
    function Qe(l, u, m, _, T) {
      for (m = u + m; u < m; ) {
        var k = l[u++];
        _[T++] = k >> 16 & 255, _[T++] = k >> 8 & 255, _[T++] = k >> 0 & 255;
      }
    }
    function br(l, u, m, _, T) {
      for (m = u + m; u < m; ) {
        var k = l[u++];
        _[T++] = k >> 16 & 255, _[T++] = k >> 8 & 255, _[T++] = k >> 0 & 255, _[T++] = k >> 24 & 255;
      }
    }
    function Ft(l, u, m, _, T) {
      for (m = u + m; u < m; ) {
        var k = (I = l[u++]) >> 16 & 240 | I >> 12 & 15, I = I >> 0 & 240 | I >> 28 & 15;
        _[T++] = k, _[T++] = I;
      }
    }
    function sn(l, u, m, _, T) {
      for (m = u + m; u < m; ) {
        var k = (I = l[u++]) >> 16 & 248 | I >> 13 & 7, I = I >> 5 & 224 | I >> 3 & 31;
        _[T++] = k, _[T++] = I;
      }
    }
    function Rt(l, u, m, _, T) {
      for (m = u + m; u < m; ) {
        var k = l[u++];
        _[T++] = k >> 0 & 255, _[T++] = k >> 8 & 255, _[T++] = k >> 16 & 255;
      }
    }
    function Jt(l, u, m, _, T, k) {
      if (k == 0) for (m = u + m; u < m; ) ve(_, ((k = l[u++])[0] >> 24 | k[1] >> 8 & 65280 | k[2] << 8 & 16711680 | k[3] << 24) >>> 0), T += 32;
      else n(_, T, l, u, m);
    }
    function Cn(l, u) {
      M[u][0] = M[l + "0"], M[u][1] = M[l + "1"], M[u][2] = M[l + "2"], M[u][3] = M[l + "3"], M[u][4] = M[l + "4"], M[u][5] = M[l + "5"], M[u][6] = M[l + "6"], M[u][7] = M[l + "7"], M[u][8] = M[l + "8"], M[u][9] = M[l + "9"], M[u][10] = M[l + "10"], M[u][11] = M[l + "11"], M[u][12] = M[l + "12"], M[u][13] = M[l + "13"], M[u][14] = M[l + "0"], M[u][15] = M[l + "0"];
    }
    function Ct(l) {
      return l == If || l == Rf || l == o0 || l == Mf;
    }
    function oi() {
      this.eb = [], this.size = this.A = this.fb = 0;
    }
    function er() {
      this.y = [], this.f = [], this.ea = [], this.F = [], this.Tc = this.Ed = this.Cd = this.Fd = this.lb = this.Db = this.Ab = this.fa = this.J = this.W = this.N = this.O = 0;
    }
    function mn() {
      this.Rd = this.height = this.width = this.S = 0, this.f = {}, this.f.RGBA = new oi(), this.f.kb = new er(), this.sd = null;
    }
    function Wn() {
      this.width = [0], this.height = [0], this.Pd = [0], this.Qd = [0], this.format = [0];
    }
    function Yt() {
      this.Id = this.fd = this.Md = this.hb = this.ib = this.da = this.bd = this.cd = this.j = this.v = this.Da = this.Sd = this.ob = 0;
    }
    function vt(l) {
      return alert("todo:WebPSamplerProcessPlane"), l.T;
    }
    function kt(l, u) {
      var m = l.T, _ = u.ba.f.RGBA, T = _.eb, k = _.fb + l.ka * _.A, I = Bn[u.ba.S], R = l.y, B = l.O, V = l.f, ae = l.N, me = l.ea, xe = l.W, he = u.cc, De = u.dc, Ne = u.Mc, oe = u.Nc, fe = l.ka, Pe = l.ka + l.T, Me = l.U, ke = Me + 1 >> 1;
      for (fe == 0 ? I(R, B, null, null, V, ae, me, xe, V, ae, me, xe, T, k, null, null, Me) : (I(u.ec, u.fc, R, B, he, De, Ne, oe, V, ae, me, xe, T, k - _.A, T, k, Me), ++m); fe + 2 < Pe; fe += 2) he = V, De = ae, Ne = me, oe = xe, ae += l.Rc, xe += l.Rc, k += 2 * _.A, I(R, (B += 2 * l.fa) - l.fa, R, B, he, De, Ne, oe, V, ae, me, xe, T, k - _.A, T, k, Me);
      return B += l.fa, l.j + Pe < l.o ? (n(u.ec, u.fc, R, B, Me), n(u.cc, u.dc, V, ae, ke), n(u.Mc, u.Nc, me, xe, ke), m--) : 1 & Pe || I(R, B, null, null, V, ae, me, xe, V, ae, me, xe, T, k + _.A, null, null, Me), m;
    }
    function _i(l, u, m) {
      var _ = l.F, T = [l.J];
      if (_ != null) {
        var k = l.U, I = u.ba.S, R = I == s0 || I == o0;
        u = u.ba.f.RGBA;
        var B = [0], V = l.ka;
        B[0] = l.T, l.Kb && (V == 0 ? --B[0] : (--V, T[0] -= l.width), l.j + l.ka + l.T == l.o && (B[0] = l.o - l.j - V));
        var ae = u.eb;
        V = u.fb + V * u.A, l = Qt(_, T[0], l.width, k, B, ae, V + (R ? 0 : 3), u.A), e(m == B), l && Ct(I) && Rn(ae, V, R, k, B, u.A);
      }
      return 0;
    }
    function Tr(l) {
      var u = l.ma, m = u.ba.S, _ = 11 > m, T = m == i0 || m == a0 || m == s0 || m == Of || m == 12 || Ct(m);
      if (u.memory = null, u.Ib = null, u.Jb = null, u.Nd = null, !Xs(u.Oa, l, T ? 11 : 12)) return 0;
      if (T && Ct(m) && je(), l.da) alert("todo:use_scaling");
      else {
        if (_) {
          if (u.Ib = vt, l.Kb) {
            if (m = l.U + 1 >> 1, u.memory = a(l.U + 2 * m), u.memory == null) return 0;
            u.ec = u.memory, u.fc = 0, u.cc = u.ec, u.dc = u.fc + l.U, u.Mc = u.cc, u.Nc = u.dc + m, u.Ib = kt, je();
          }
        } else alert("todo:EmitYUV");
        T && (u.Jb = _i, _ && ue());
      }
      if (_ && !gh) {
        for (l = 0; 256 > l; ++l) L2[l] = 89858 * (l - 128) + l0 >> f0, k2[l] = -22014 * (l - 128) + l0, P2[l] = -45773 * (l - 128), C2[l] = 113618 * (l - 128) + l0 >> f0;
        for (l = ro; l < Uf; ++l) u = 76283 * (l - 16) + l0 >> f0, D2[l - ro] = yn(u, 255), O2[l - ro] = yn(u + 8 >> 4, 15);
        gh = 1;
      }
      return 1;
    }
    function Pn(l) {
      var u = l.ma, m = l.U, _ = l.T;
      return e(!(1 & l.ka)), 0 >= m || 0 >= _ ? 0 : (m = u.Ib(l, u), u.Jb != null && u.Jb(l, u, m), u.Dc += m, 1);
    }
    function kn(l) {
      l.ma.memory = null;
    }
    function lt(l, u, m, _) {
      return be(l, 8) != 47 ? 0 : (u[0] = be(l, 14) + 1, m[0] = be(l, 14) + 1, _[0] = be(l, 1), be(l, 3) != 0 ? 0 : !l.h);
    }
    function xn(l, u) {
      if (4 > l) return l + 1;
      var m = l - 2 >> 1;
      return (2 + (1 & l) << m) + be(u, m) + 1;
    }
    function on(l, u) {
      return 120 < u ? u - 120 : 1 <= (m = ((m = g2[u - 1]) >> 4) * l + (8 - (15 & m))) ? m : 1;
      var m;
    }
    function Wr(l, u, m) {
      var _ = L(m), T = l[u += 255 & _].g - 8;
      return 0 < T && (C(m, m.u + 8), _ = L(m), u += l[u].value, u += _ & (1 << T) - 1), C(m, m.u + l[u].g), l[u].value;
    }
    function hr(l, u, m) {
      return m.g += l.g, m.value += l.value << u >>> 0, e(8 >= m.g), l.g;
    }
    function ir(l, u, m) {
      var _ = l.xc;
      return e((u = _ == 0 ? 0 : l.vc[l.md * (m >> _) + (u >> _)]) < l.Wb), l.Ya[u];
    }
    function D(l, u, m, _) {
      var T = l.ab, k = l.c * u, I = l.C;
      u = I + u;
      var R = m, B = _;
      for (_ = l.Ta, m = l.Ua; 0 < T--; ) {
        var V = l.gc[T], ae = I, me = u, xe = R, he = B, De = (B = _, R = m, V.Ea);
        switch (e(ae < me), e(me <= V.nc), V.hc) {
          case 2:
            Jo(xe, he, (me - ae) * De, B, R);
            break;
          case 0:
            var Ne = ae, oe = me, fe = B, Pe = R, Me = (Ze = V).Ea;
            Ne == 0 && (kf(xe, he, null, null, 1, fe, Pe), _t(xe, he + 1, 0, 0, Me - 1, fe, Pe + 1), he += Me, Pe += Me, ++Ne);
            for (var ke = 1 << Ze.b, it = ke - 1, Ke = rt(Me, Ze.b), ht = Ze.K, Ze = Ze.w + (Ne >> Ze.b) * Ke; Ne < oe; ) {
              var Ot = ht, Bt = Ze, Pt = 1;
              for (Ks(xe, he, fe, Pe - Me, 1, fe, Pe); Pt < Me; ) {
                var Nt = (Pt & ~it) + ke;
                Nt > Me && (Nt = Me), (0, Gi[Ot[Bt++] >> 8 & 15])(xe, he + +Pt, fe, Pe + Pt - Me, Nt - Pt, fe, Pe + Pt), Pt = Nt;
              }
              he += Me, Pe += Me, ++Ne & it || (Ze += Ke);
            }
            me != V.nc && n(B, R - De, B, R + (me - ae - 1) * De, De);
            break;
          case 1:
            for (De = xe, oe = he, Me = (xe = V.Ea) - (Pe = xe & ~(fe = (he = 1 << V.b) - 1)), Ne = rt(xe, V.b), ke = V.K, V = V.w + (ae >> V.b) * Ne; ae < me; ) {
              for (it = ke, Ke = V, ht = new $e(), Ze = oe + Pe, Ot = oe + xe; oe < Ze; ) Et(it[Ke++], ht), wa(ht, De, oe, he, B, R), oe += he, R += he;
              oe < Ot && (Et(it[Ke++], ht), wa(ht, De, oe, Me, B, R), oe += Me, R += Me), ++ae & fe || (V += Ne);
            }
            break;
          case 3:
            if (xe == B && he == R && 0 < V.b) {
              for (oe = B, xe = De = R + (me - ae) * De - (Pe = (me - ae) * rt(V.Ea, V.b)), he = B, fe = R, Ne = [], Pe = (Me = Pe) - 1; 0 <= Pe; --Pe) Ne[Pe] = he[fe + Pe];
              for (Pe = Me - 1; 0 <= Pe; --Pe) oe[xe + Pe] = Ne[Pe];
              Dn(V, ae, me, B, De, B, R);
            } else Dn(V, ae, me, xe, he, B, R);
        }
        R = _, B = m;
      }
      B != m && n(_, m, R, B, k);
    }
    function X(l, u) {
      var m = l.V, _ = l.Ba + l.c * l.C, T = u - l.C;
      if (e(u <= l.l.o), e(16 >= T), 0 < T) {
        var k = l.l, I = l.Ta, R = l.Ua, B = k.width;
        if (D(l, T, m, _), T = R = [R], e((m = l.C) < (_ = u)), e(k.v < k.va), _ > k.o && (_ = k.o), m < k.j) {
          var V = k.j - m;
          m = k.j, T[0] += V * B;
        }
        if (m >= _ ? m = 0 : (T[0] += 4 * k.v, k.ka = m - k.j, k.U = k.va - k.v, k.T = _ - m, m = 1), m) {
          if (R = R[0], 11 > (m = l.ca).S) {
            var ae = m.f.RGBA, me = (_ = m.S, T = k.U, k = k.T, V = ae.eb, ae.A), xe = k;
            for (ae = ae.fb + l.Ma * ae.A; 0 < xe--; ) {
              var he = I, De = R, Ne = T, oe = V, fe = ae;
              switch (_) {
                case n0:
                  hn(he, De, Ne, oe, fe);
                  break;
                case i0:
                  Qr(he, De, Ne, oe, fe);
                  break;
                case If:
                  Qr(he, De, Ne, oe, fe), Rn(oe, fe, 0, Ne, 1, 0);
                  break;
                case ah:
                  Ei(he, De, Ne, oe, fe);
                  break;
                case a0:
                  Jt(he, De, Ne, oe, fe, 1);
                  break;
                case Rf:
                  Jt(he, De, Ne, oe, fe, 1), Rn(oe, fe, 0, Ne, 1, 0);
                  break;
                case s0:
                  Jt(he, De, Ne, oe, fe, 0);
                  break;
                case o0:
                  Jt(he, De, Ne, oe, fe, 0), Rn(oe, fe, 1, Ne, 1, 0);
                  break;
                case Of:
                  Xi(he, De, Ne, oe, fe);
                  break;
                case Mf:
                  Xi(he, De, Ne, oe, fe), Zt(oe, fe, Ne, 1, 0);
                  break;
                case sh:
                  Ti(he, De, Ne, oe, fe);
                  break;
                default:
                  e(0);
              }
              R += B, ae += me;
            }
            l.Ma += k;
          } else alert("todo:EmitRescaledRowsYUVA");
          e(l.Ma <= m.height);
        }
      }
      l.C = u, e(l.C <= l.i);
    }
    function U(l) {
      var u;
      if (0 < l.ua) return 0;
      for (u = 0; u < l.Wb; ++u) {
        var m = l.Ya[u].G, _ = l.Ya[u].H;
        if (0 < m[1][_[1] + 0].g || 0 < m[2][_[2] + 0].g || 0 < m[3][_[3] + 0].g) return 0;
      }
      return 1;
    }
    function W(l, u, m, _, T, k) {
      if (l.Z != 0) {
        var I = l.qd, R = l.rd;
        for (e(Ji[l.Z] != null); u < m; ++u) Ji[l.Z](I, R, _, T, _, T, k), I = _, R = T, T += k;
        l.qd = I, l.rd = R;
      }
    }
    function G(l, u) {
      var m = l.l.ma, _ = m.Z == 0 || m.Z == 1 ? l.l.j : l.C;
      if (_ = l.C < _ ? _ : l.C, e(u <= l.l.o), u > _) {
        var T = l.l.width, k = m.ca, I = m.tb + T * _, R = l.V, B = l.Ba + l.c * _, V = l.gc;
        e(l.ab == 1), e(V[0].hc == 3), Zo(V[0], _, u, R, B, k, I), W(m, _, u, k, I, T);
      }
      l.C = l.Ma = u;
    }
    function K(l, u, m, _, T, k, I) {
      var R = l.$ / _, B = l.$ % _, V = l.m, ae = l.s, me = m + l.$, xe = me;
      T = m + _ * T;
      var he = m + _ * k, De = 280 + ae.ua, Ne = l.Pb ? R : 16777216, oe = 0 < ae.ua ? ae.Wa : null, fe = ae.wc, Pe = me < he ? ir(ae, B, R) : null;
      e(l.C < k), e(he <= T);
      var Me = false;
      e: for (; ; ) {
        for (; Me || me < he; ) {
          var ke = 0;
          if (R >= Ne) {
            var it = me - m;
            e((Ne = l).Pb), Ne.wd = Ne.m, Ne.xd = it, 0 < Ne.s.ua && Te(Ne.s.Wa, Ne.s.vb), Ne = R + m2;
          }
          if (B & fe || (Pe = ir(ae, B, R)), e(Pe != null), Pe.Qb && (u[me] = Pe.qb, Me = true), !Me) if (z(V), Pe.jc) {
            ke = V, it = u;
            var Ke = me, ht = Pe.pd[L(ke) & Ir - 1];
            e(Pe.jc), 256 > ht.g ? (C(ke, ke.u + ht.g), it[Ke] = ht.value, ke = 0) : (C(ke, ke.u + ht.g - 256), e(256 <= ht.value), ke = ht.value), ke == 0 && (Me = true);
          } else ke = Wr(Pe.G[0], Pe.H[0], V);
          if (V.h) break;
          if (Me || 256 > ke) {
            if (!Me) if (Pe.nd) u[me] = (Pe.qb | ke << 8) >>> 0;
            else {
              if (z(V), Me = Wr(Pe.G[1], Pe.H[1], V), z(V), it = Wr(Pe.G[2], Pe.H[2], V), Ke = Wr(Pe.G[3], Pe.H[3], V), V.h) break;
              u[me] = (Ke << 24 | Me << 16 | ke << 8 | it) >>> 0;
            }
            if (Me = false, ++me, ++B >= _ && (B = 0, ++R, I != null && R <= k && !(R % 16) && I(l, R), oe != null)) for (; xe < me; ) ke = u[xe++], oe.X[(506832829 * ke & 4294967295) >>> oe.Mb] = ke;
          } else if (280 > ke) {
            if (ke = xn(ke - 256, V), it = Wr(Pe.G[4], Pe.H[4], V), z(V), it = on(_, it = xn(it, V)), V.h) break;
            if (me - m < it || T - me < ke) break e;
            for (Ke = 0; Ke < ke; ++Ke) u[me + Ke] = u[me + Ke - it];
            for (me += ke, B += ke; B >= _; ) B -= _, ++R, I != null && R <= k && !(R % 16) && I(l, R);
            if (e(me <= T), B & fe && (Pe = ir(ae, B, R)), oe != null) for (; xe < me; ) ke = u[xe++], oe.X[(506832829 * ke & 4294967295) >>> oe.Mb] = ke;
          } else {
            if (!(ke < De)) break e;
            for (Me = ke - 280, e(oe != null); xe < me; ) ke = u[xe++], oe.X[(506832829 * ke & 4294967295) >>> oe.Mb] = ke;
            ke = me, e(!(Me >>> (it = oe).Xa)), u[ke] = it.X[Me], Me = true;
          }
          Me || e(V.h == N(V));
        }
        if (l.Pb && V.h && me < T) e(l.m.h), l.a = 5, l.m = l.wd, l.$ = l.xd, 0 < l.s.ua && Te(l.s.vb, l.s.Wa);
        else {
          if (V.h) break e;
          I != null && I(l, R > k ? k : R), l.a = 0, l.$ = me - m;
        }
        return 1;
      }
      return l.a = 3, 0;
    }
    function ge(l) {
      e(l != null), l.vc = null, l.yc = null, l.Ya = null;
      var u = l.Wa;
      u != null && (u.X = null), l.vb = null, e(l != null);
    }
    function Ee() {
      var l = new Pf();
      return l == null ? null : (l.a = 0, l.xb = lh, Cn("Predictor", "VP8LPredictors"), Cn("Predictor", "VP8LPredictors_C"), Cn("PredictorAdd", "VP8LPredictorsAdd"), Cn("PredictorAdd", "VP8LPredictorsAdd_C"), Jo = Tt, wa = ct, hn = Qe, Qr = br, Xi = Ft, Ti = sn, Ei = Rt, M.VP8LMapColor32b = Qa, M.VP8LMapColor8b = Qo, l);
    }
    function pe(l, u, m, _, T) {
      var k = 1, I = [l], R = [u], B = _.m, V = _.s, ae = null, me = 0;
      e: for (; ; ) {
        if (m) for (; k && be(B, 1); ) {
          var xe = I, he = R, De = _, Ne = 1, oe = De.m, fe = De.gc[De.ab], Pe = be(oe, 2);
          if (De.Oc & 1 << Pe) k = 0;
          else {
            switch (De.Oc |= 1 << Pe, fe.hc = Pe, fe.Ea = xe[0], fe.nc = he[0], fe.K = [null], ++De.ab, e(4 >= De.ab), Pe) {
              case 0:
              case 1:
                fe.b = be(oe, 3) + 2, Ne = pe(rt(fe.Ea, fe.b), rt(fe.nc, fe.b), 0, De, fe.K), fe.K = fe.K[0];
                break;
              case 3:
                var Me, ke = be(oe, 8) + 1, it = 16 < ke ? 0 : 4 < ke ? 1 : 2 < ke ? 2 : 3;
                if (xe[0] = rt(fe.Ea, it), fe.b = it, Me = Ne = pe(ke, 1, 0, De, fe.K)) {
                  var Ke, ht = ke, Ze = fe, Ot = 1 << (8 >> Ze.b), Bt = a(Ot);
                  if (Bt == null) Me = 0;
                  else {
                    var Pt = Ze.K[0], Nt = Ze.w;
                    for (Bt[0] = Ze.K[0][0], Ke = 1; Ke < 1 * ht; ++Ke) Bt[Ke] = Be(Pt[Nt + Ke], Bt[Ke - 1]);
                    for (; Ke < 4 * Ot; ++Ke) Bt[Ke] = 0;
                    Ze.K[0] = null, Ze.K[0] = Bt, Me = 1;
                  }
                }
                Ne = Me;
                break;
              case 2:
                break;
              default:
                e(0);
            }
            k = Ne;
          }
        }
        if (I = I[0], R = R[0], k && be(B, 1) && !(k = 1 <= (me = be(B, 4)) && 11 >= me)) {
          _.a = 3;
          break e;
        }
        var $t;
        if ($t = k) t: {
          var Gt, St, wr, cn = _, yr = I, un = R, jt = me, Sn = m, An = cn.m, Lr = cn.s, Rr = [null], tn = 1, jn = 0, di = v2[jt];
          r: for (; ; ) {
            if (Sn && be(An, 1)) {
              var Cr = be(An, 3) + 2, Ci = rt(yr, Cr), ba = rt(un, Cr), is = Ci * ba;
              if (!pe(Ci, ba, 0, cn, Rr)) break r;
              for (Rr = Rr[0], Lr.xc = Cr, Gt = 0; Gt < is; ++Gt) {
                var Zi = Rr[Gt] >> 8 & 65535;
                Rr[Gt] = Zi, Zi >= tn && (tn = Zi + 1);
              }
            }
            if (An.h) break r;
            for (St = 0; 5 > St; ++St) {
              var sr = oh[St];
              !St && 0 < jt && (sr += 1 << jt), jn < sr && (jn = sr);
            }
            var qf = s(tn * di, P), xh = tn, wh = s(xh, Q);
            if (wh == null) var c0 = null;
            else e(65536 >= xh), c0 = wh;
            var no = a(jn);
            if (c0 == null || no == null || qf == null) {
              cn.a = 1;
              break r;
            }
            var u0 = qf;
            for (Gt = wr = 0; Gt < tn; ++Gt) {
              var Kn = c0[Gt], as = Kn.G, ss = Kn.H, yh = 0, d0 = 1, _h = 0;
              for (St = 0; 5 > St; ++St) {
                sr = oh[St], as[St] = u0, ss[St] = wr, !St && 0 < jt && (sr += 1 << jt);
                i: {
                  var p0, Hf = sr, g0 = cn, io = no, M2 = u0, B2 = wr, Wf = 0, Qi = g0.m, j2 = be(Qi, 1);
                  if (i(io, 0, 0, Hf), j2) {
                    var U2 = be(Qi, 1) + 1, q2 = be(Qi, 1), Sh = be(Qi, q2 == 0 ? 1 : 8);
                    io[Sh] = 1, U2 == 2 && (io[Sh = be(Qi, 8)] = 1);
                    var v0 = 1;
                  } else {
                    var Ah = a(19), bh = be(Qi, 4) + 4;
                    if (19 < bh) {
                      g0.a = 3;
                      var m0 = 0;
                      break i;
                    }
                    for (p0 = 0; p0 < bh; ++p0) Ah[p2[p0]] = be(Qi, 3);
                    var zf = void 0, ao = void 0, Th = g0, H2 = Ah, x0 = Hf, Eh = io, Vf = 0, ea = Th.m, Nh = 8, Fh = s(128, P);
                    n: for (; F(Fh, 0, 7, H2, 19); ) {
                      if (be(ea, 1)) {
                        var W2 = 2 + 2 * be(ea, 3);
                        if ((zf = 2 + be(ea, W2)) > x0) break n;
                      } else zf = x0;
                      for (ao = 0; ao < x0 && zf--; ) {
                        z(ea);
                        var Lh = Fh[0 + (127 & L(ea))];
                        C(ea, ea.u + Lh.g);
                        var os = Lh.value;
                        if (16 > os) Eh[ao++] = os, os != 0 && (Nh = os);
                        else {
                          var z2 = os == 16, Ch = os - 16, V2 = u2[Ch], Ph = be(ea, c2[Ch]) + V2;
                          if (ao + Ph > x0) break n;
                          for (var G2 = z2 ? Nh : 0; 0 < Ph--; ) Eh[ao++] = G2;
                        }
                      }
                      Vf = 1;
                      break n;
                    }
                    Vf || (Th.a = 3), v0 = Vf;
                  }
                  (v0 = v0 && !Qi.h) && (Wf = F(M2, B2, 8, io, Hf)), v0 && Wf != 0 ? m0 = Wf : (g0.a = 3, m0 = 0);
                }
                if (m0 == 0) break r;
                if (d0 && d2[St] == 1 && (d0 = u0[wr].g == 0), yh += u0[wr].g, wr += m0, 3 >= St) {
                  var so, Gf = no[0];
                  for (so = 1; so < sr; ++so) no[so] > Gf && (Gf = no[so]);
                  _h += Gf;
                }
              }
              if (Kn.nd = d0, Kn.Qb = 0, d0 && (Kn.qb = (as[3][ss[3] + 0].value << 24 | as[1][ss[1] + 0].value << 16 | as[2][ss[2] + 0].value) >>> 0, yh == 0 && 256 > as[0][ss[0] + 0].value && (Kn.Qb = 1, Kn.qb += as[0][ss[0] + 0].value << 8)), Kn.jc = !Kn.Qb && 6 > _h, Kn.jc) {
                var w0, Pi = Kn;
                for (w0 = 0; w0 < Ir; ++w0) {
                  var ta = w0, ra = Pi.pd[ta], y0 = Pi.G[0][Pi.H[0] + ta];
                  256 <= y0.value ? (ra.g = y0.g + 256, ra.value = y0.value) : (ra.g = 0, ra.value = 0, ta >>= hr(y0, 8, ra), ta >>= hr(Pi.G[1][Pi.H[1] + ta], 16, ra), ta >>= hr(Pi.G[2][Pi.H[2] + ta], 0, ra), hr(Pi.G[3][Pi.H[3] + ta], 24, ra));
                }
              }
            }
            Lr.vc = Rr, Lr.Wb = tn, Lr.Ya = c0, Lr.yc = qf, $t = 1;
            break t;
          }
          $t = 0;
        }
        if (!(k = $t)) {
          _.a = 3;
          break e;
        }
        if (0 < me) {
          if (V.ua = 1 << me, !Ye(V.Wa, me)) {
            _.a = 1, k = 0;
            break e;
          }
        } else V.ua = 0;
        var Xf = _, kh = I, X2 = R, Yf = Xf.s, $f = Yf.xc;
        if (Xf.c = kh, Xf.i = X2, Yf.md = rt(kh, $f), Yf.wc = $f == 0 ? -1 : (1 << $f) - 1, m) {
          _.xb = b2;
          break e;
        }
        if ((ae = a(I * R)) == null) {
          _.a = 1, k = 0;
          break e;
        }
        k = (k = K(_, ae, 0, I, R, R, null)) && !B.h;
        break e;
      }
      return k ? (T != null ? T[0] = ae : (e(ae == null), e(m)), _.$ = 0, m || ge(V)) : ge(V), k;
    }
    function ye(l, u) {
      var m = l.c * l.i, _ = m + u + 16 * u;
      return e(l.c <= u), l.V = a(_), l.V == null ? (l.Ta = null, l.Ua = 0, l.a = 1, 0) : (l.Ta = l.V, l.Ua = l.Ba + m + u, 1);
    }
    function _e(l, u) {
      var m = l.C, _ = u - m, T = l.V, k = l.Ba + l.c * m;
      for (e(u <= l.l.o); 0 < _; ) {
        var I = 16 < _ ? 16 : _, R = l.l.ma, B = l.l.width, V = B * I, ae = R.ca, me = R.tb + B * m, xe = l.Ta, he = l.Ua;
        D(l, I, T, k), dr(xe, he, ae, me, V), W(R, m, m + I, ae, me, B), _ -= I, T += I * l.c, m += I;
      }
      e(m == u), l.C = l.Ma = u;
    }
    function Ue() {
      this.ub = this.yd = this.td = this.Rb = 0;
    }
    function Ve() {
      this.Kd = this.Ld = this.Ud = this.Td = this.i = this.c = 0;
    }
    function tt() {
      this.Fb = this.Bb = this.Cb = 0, this.Zb = a(4), this.Lb = a(4);
    }
    function He() {
      this.Yb = function() {
        var l = [];
        return function u(m, _, T) {
          for (var k = T[_], I = 0; I < k && (m.push(T.length > _ + 1 ? [] : 0), !(T.length < _ + 1)); I++) u(m[I], _ + 1, T);
        }(l, 0, [3, 11]), l;
      }();
    }
    function et() {
      this.jb = a(3), this.Wc = o([4, 8], He), this.Xc = o([4, 17], He);
    }
    function pt() {
      this.Pc = this.wb = this.Tb = this.zd = 0, this.vd = new a(4), this.od = new a(4);
    }
    function Mt() {
      this.ld = this.La = this.dd = this.tc = 0;
    }
    function Vt() {
      this.Na = this.la = 0;
    }
    function mr() {
      this.Sc = [0, 0], this.Eb = [0, 0], this.Qc = [0, 0], this.ia = this.lc = 0;
    }
    function zn() {
      this.ad = a(384), this.Za = 0, this.Ob = a(16), this.$b = this.Ad = this.ia = this.Gc = this.Hc = this.Dd = 0;
    }
    function Si() {
      this.uc = this.M = this.Nb = 0, this.wa = Array(new Mt()), this.Y = 0, this.ya = Array(new zn()), this.aa = 0, this.l = new li();
    }
    function fi() {
      this.y = a(16), this.f = a(8), this.ea = a(8);
    }
    function Vn() {
      this.cb = this.a = 0, this.sc = "", this.m = new ze(), this.Od = new Ue(), this.Kc = new Ve(), this.ed = new pt(), this.Qa = new tt(), this.Ic = this.$c = this.Aa = 0, this.D = new Si(), this.Xb = this.Va = this.Hb = this.zb = this.yb = this.Ub = this.za = 0, this.Jc = s(8, ze), this.ia = 0, this.pb = s(4, mr), this.Pa = new et(), this.Bd = this.kc = 0, this.Ac = [], this.Bc = 0, this.zc = [0, 0, 0, 0], this.Gd = Array(new fi()), this.Hd = 0, this.rb = Array(new Vt()), this.sb = 0, this.wa = Array(new Mt()), this.Y = 0, this.oc = [], this.pc = 0, this.sa = [], this.ta = 0, this.qa = [], this.ra = 0, this.Ha = [], this.B = this.R = this.Ia = 0, this.Ec = [], this.M = this.ja = this.Vb = this.Fc = 0, this.ya = Array(new zn()), this.L = this.aa = 0, this.gd = o([4, 2], Mt), this.ga = null, this.Fa = [], this.Cc = this.qc = this.P = 0, this.Gb = [], this.Uc = 0, this.mb = [], this.nb = 0, this.rc = [], this.Ga = this.Vc = 0;
    }
    function li() {
      this.T = this.U = this.ka = this.height = this.width = 0, this.y = [], this.f = [], this.ea = [], this.Rc = this.fa = this.W = this.N = this.O = 0, this.ma = "void", this.put = "VP8IoPutHook", this.ac = "VP8IoSetupHook", this.bc = "VP8IoTeardownHook", this.ha = this.Kb = 0, this.data = [], this.hb = this.ib = this.da = this.o = this.j = this.va = this.v = this.Da = this.ob = this.w = 0, this.F = [], this.J = 0;
    }
    function wn() {
      var l = new Vn();
      return l != null && (l.a = 0, l.sc = "OK", l.cb = 0, l.Xb = 0, to || (to = Ro)), l;
    }
    function cr(l, u, m) {
      return l.a == 0 && (l.a = u, l.sc = m, l.cb = 0), 0;
    }
    function Oo(l, u, m) {
      return 3 <= m && l[u + 0] == 157 && l[u + 1] == 1 && l[u + 2] == 42;
    }
    function Io(l, u) {
      if (l == null) return 0;
      if (l.a = 0, l.sc = "OK", u == null) return cr(l, 2, "null VP8Io passed to VP8GetHeaders()");
      var m = u.data, _ = u.w, T = u.ha;
      if (4 > T) return cr(l, 7, "Truncated header.");
      var k = m[_ + 0] | m[_ + 1] << 8 | m[_ + 2] << 16, I = l.Od;
      if (I.Rb = !(1 & k), I.td = k >> 1 & 7, I.yd = k >> 4 & 1, I.ub = k >> 5, 3 < I.td) return cr(l, 3, "Incorrect keyframe parameters.");
      if (!I.yd) return cr(l, 4, "Frame not displayable.");
      _ += 3, T -= 3;
      var R = l.Kc;
      if (I.Rb) {
        if (7 > T) return cr(l, 7, "cannot parse picture header");
        if (!Oo(m, _, T)) return cr(l, 3, "Bad code word");
        R.c = 16383 & (m[_ + 4] << 8 | m[_ + 3]), R.Td = m[_ + 4] >> 6, R.i = 16383 & (m[_ + 6] << 8 | m[_ + 5]), R.Ud = m[_ + 6] >> 6, _ += 7, T -= 7, l.za = R.c + 15 >> 4, l.Ub = R.i + 15 >> 4, u.width = R.c, u.height = R.i, u.Da = 0, u.j = 0, u.v = 0, u.va = u.width, u.o = u.height, u.da = 0, u.ib = u.width, u.hb = u.height, u.U = u.width, u.T = u.height, i((k = l.Pa).jb, 0, 255, k.jb.length), e((k = l.Qa) != null), k.Cb = 0, k.Bb = 0, k.Fb = 1, i(k.Zb, 0, 0, k.Zb.length), i(k.Lb, 0, 0, k.Lb);
      }
      if (I.ub > T) return cr(l, 7, "bad partition length");
      ce(k = l.m, m, _, I.ub), _ += I.ub, T -= I.ub, I.Rb && (R.Ld = se(k), R.Kd = se(k)), R = l.Qa;
      var B, V = l.Pa;
      if (e(k != null), e(R != null), R.Cb = se(k), R.Cb) {
        if (R.Bb = se(k), se(k)) {
          for (R.Fb = se(k), B = 0; 4 > B; ++B) R.Zb[B] = se(k) ? Se(k, 7) : 0;
          for (B = 0; 4 > B; ++B) R.Lb[B] = se(k) ? Se(k, 6) : 0;
        }
        if (R.Bb) for (B = 0; 3 > B; ++B) V.jb[B] = se(k) ? we(k, 8) : 255;
      } else R.Bb = 0;
      if (k.Ka) return cr(l, 3, "cannot parse segment header");
      if ((R = l.ed).zd = se(k), R.Tb = we(k, 6), R.wb = we(k, 3), R.Pc = se(k), R.Pc && se(k)) {
        for (V = 0; 4 > V; ++V) se(k) && (R.vd[V] = Se(k, 6));
        for (V = 0; 4 > V; ++V) se(k) && (R.od[V] = Se(k, 6));
      }
      if (l.L = R.Tb == 0 ? 0 : R.zd ? 1 : 2, k.Ka) return cr(l, 3, "cannot parse filter header");
      var ae = T;
      if (T = B = _, _ = B + ae, R = ae, l.Xb = (1 << we(l.m, 2)) - 1, ae < 3 * (V = l.Xb)) m = 7;
      else {
        for (B += 3 * V, R -= 3 * V, ae = 0; ae < V; ++ae) {
          var me = m[T + 0] | m[T + 1] << 8 | m[T + 2] << 16;
          me > R && (me = R), ce(l.Jc[+ae], m, B, me), B += me, R -= me, T += 3;
        }
        ce(l.Jc[+V], m, B, R), m = B < _ ? 0 : 5;
      }
      if (m != 0) return cr(l, m, "cannot parse partitions");
      for (m = we(B = l.m, 7), T = se(B) ? Se(B, 4) : 0, _ = se(B) ? Se(B, 4) : 0, R = se(B) ? Se(B, 4) : 0, V = se(B) ? Se(B, 4) : 0, B = se(B) ? Se(B, 4) : 0, ae = l.Qa, me = 0; 4 > me; ++me) {
        if (ae.Cb) {
          var xe = ae.Zb[me];
          ae.Fb || (xe += m);
        } else {
          if (0 < me) {
            l.pb[me] = l.pb[0];
            continue;
          }
          xe = m;
        }
        var he = l.pb[me];
        he.Sc[0] = Bf[yn(xe + T, 127)], he.Sc[1] = jf[yn(xe + 0, 127)], he.Eb[0] = 2 * Bf[yn(xe + _, 127)], he.Eb[1] = 101581 * jf[yn(xe + R, 127)] >> 16, 8 > he.Eb[1] && (he.Eb[1] = 8), he.Qc[0] = Bf[yn(xe + V, 117)], he.Qc[1] = jf[yn(xe + B, 127)], he.lc = xe + B;
      }
      if (!I.Rb) return cr(l, 4, "Not a key frame.");
      for (se(k), I = l.Pa, m = 0; 4 > m; ++m) {
        for (T = 0; 8 > T; ++T) for (_ = 0; 3 > _; ++_) for (R = 0; 11 > R; ++R) V = ie(k, S2[m][T][_][R]) ? we(k, 8) : y2[m][T][_][R], I.Wc[m][T].Yb[_][R] = V;
        for (T = 0; 17 > T; ++T) I.Xc[m][T] = I.Wc[m][A2[T]];
      }
      return l.kc = se(k), l.kc && (l.Bd = we(k, 8)), l.cb = 1;
    }
    function Ro(l, u, m, _, T, k, I) {
      var R = u[T].Yb[m];
      for (m = 0; 16 > T; ++T) {
        if (!ie(l, R[m + 0])) return T;
        for (; !ie(l, R[m + 1]); ) if (R = u[++T].Yb[0], m = 0, T == 16) return 16;
        var B = u[T + 1].Yb;
        if (ie(l, R[m + 2])) {
          var V = l, ae = 0;
          if (ie(V, (xe = R)[(me = m) + 3])) {
            if (ie(V, xe[me + 6])) {
              for (R = 0, me = 2 * (ae = ie(V, xe[me + 8])) + (xe = ie(V, xe[me + 9 + ae])), ae = 0, xe = x2[me]; xe[R]; ++R) ae += ae + ie(V, xe[R]);
              ae += 3 + (8 << me);
            } else ie(V, xe[me + 7]) ? (ae = 7 + 2 * ie(V, 165), ae += ie(V, 145)) : ae = 5 + ie(V, 159);
          } else ae = ie(V, xe[me + 4]) ? 3 + ie(V, xe[me + 5]) : 2;
          R = B[2];
        } else ae = 1, R = B[1];
        B = I + w2[T], 0 > (V = l).b && re(V);
        var me, xe = V.b, he = (me = V.Ca >> 1) - (V.I >> xe) >> 31;
        --V.b, V.Ca += he, V.Ca |= 1, V.I -= (me + 1 & he) << xe, k[B] = ((ae ^ he) - he) * _[(0 < T) + 0];
      }
      return 16;
    }
    function ks(l) {
      var u = l.rb[l.sb - 1];
      u.la = 0, u.Na = 0, i(l.zc, 0, 0, l.zc.length), l.ja = 0;
    }
    function pf(l, u) {
      if (l == null) return 0;
      if (u == null) return cr(l, 2, "NULL VP8Io parameter in VP8Decode().");
      if (!l.cb && !Io(l, u)) return 0;
      if (e(l.cb), u.ac == null || u.ac(u)) {
        u.ob && (l.L = 0);
        var m = h0[l.L];
        if (l.L == 2 ? (l.yb = 0, l.zb = 0) : (l.yb = u.v - m >> 4, l.zb = u.j - m >> 4, 0 > l.yb && (l.yb = 0), 0 > l.zb && (l.zb = 0)), l.Va = u.o + 15 + m >> 4, l.Hb = u.va + 15 + m >> 4, l.Hb > l.za && (l.Hb = l.za), l.Va > l.Ub && (l.Va = l.Ub), 0 < l.L) {
          var _ = l.ed;
          for (m = 0; 4 > m; ++m) {
            var T;
            if (l.Qa.Cb) {
              var k = l.Qa.Lb[m];
              l.Qa.Fb || (k += _.Tb);
            } else k = _.Tb;
            for (T = 0; 1 >= T; ++T) {
              var I = l.gd[m][T], R = k;
              if (_.Pc && (R += _.vd[0], T && (R += _.od[0])), 0 < (R = 0 > R ? 0 : 63 < R ? 63 : R)) {
                var B = R;
                0 < _.wb && (B = 4 < _.wb ? B >> 2 : B >> 1) > 9 - _.wb && (B = 9 - _.wb), 1 > B && (B = 1), I.dd = B, I.tc = 2 * R + B, I.ld = 40 <= R ? 2 : 15 <= R ? 1 : 0;
              } else I.tc = 0;
              I.La = T;
            }
          }
        }
        m = 0;
      } else cr(l, 6, "Frame setup failed"), m = l.a;
      if (m = m == 0) {
        if (m) {
          l.$c = 0, 0 < l.Aa || (l.Ic = R2);
          e: {
            m = l.Ic, _ = 4 * (B = l.za);
            var V = 32 * B, ae = B + 1, me = 0 < l.L ? B * (0 < l.Aa ? 2 : 1) : 0, xe = (l.Aa == 2 ? 2 : 1) * B;
            if ((I = _ + 832 + (T = 3 * (16 * m + h0[l.L]) / 2 * V) + (k = l.Fa != null && 0 < l.Fa.length ? l.Kc.c * l.Kc.i : 0)) != I) m = 0;
            else {
              if (I > l.Vb) {
                if (l.Vb = 0, l.Ec = a(I), l.Fc = 0, l.Ec == null) {
                  m = cr(l, 1, "no memory during frame initialization.");
                  break e;
                }
                l.Vb = I;
              }
              I = l.Ec, R = l.Fc, l.Ac = I, l.Bc = R, R += _, l.Gd = s(V, fi), l.Hd = 0, l.rb = s(ae + 1, Vt), l.sb = 1, l.wa = me ? s(me, Mt) : null, l.Y = 0, l.D.Nb = 0, l.D.wa = l.wa, l.D.Y = l.Y, 0 < l.Aa && (l.D.Y += B), e(true), l.oc = I, l.pc = R, R += 832, l.ya = s(xe, zn), l.aa = 0, l.D.ya = l.ya, l.D.aa = l.aa, l.Aa == 2 && (l.D.aa += B), l.R = 16 * B, l.B = 8 * B, B = (V = h0[l.L]) * l.R, V = V / 2 * l.B, l.sa = I, l.ta = R + B, l.qa = l.sa, l.ra = l.ta + 16 * m * l.R + V, l.Ha = l.qa, l.Ia = l.ra + 8 * m * l.B + V, l.$c = 0, R += T, l.mb = k ? I : null, l.nb = k ? R : null, e(R + k <= l.Fc + l.Vb), ks(l), i(l.Ac, l.Bc, 0, _), m = 1;
            }
          }
          if (m) {
            if (u.ka = 0, u.y = l.sa, u.O = l.ta, u.f = l.qa, u.N = l.ra, u.ea = l.Ha, u.Vd = l.Ia, u.fa = l.R, u.Rc = l.B, u.F = null, u.J = 0, !t0) {
              for (m = -255; 255 >= m; ++m) Er[255 + m] = 0 > m ? -m : m;
              for (m = -1020; 1020 >= m; ++m) Fi[1020 + m] = -128 > m ? -128 : 127 < m ? 127 : m;
              for (m = -112; 112 >= m; ++m) eo[112 + m] = -16 > m ? -16 : 15 < m ? 15 : m;
              for (m = -255; 510 >= m; ++m) ns[255 + m] = 0 > m ? 0 : 255 < m ? 255 : m;
              t0 = 1;
            }
            es = mf, Ni = gf, Js = Bo, en = vf, On = jo, ur = Mo, ts = Bs, e0 = ma, Zs = Cf, ya = js, _a = Lf, Yi = Va, Sa = Us, rs = Yo, Aa = Xo, $i = ci, Qs = bi, In = Ff, $n[0] = hi, $n[1] = xf, $n[2] = Sf, $n[3] = Af, $n[4] = Ho, $n[5] = Wa, $n[6] = Wo, $n[7] = Is, $n[8] = Tf, $n[9] = bf, Ki[0] = Uo, Ki[1] = yf, Ki[2] = Ai, Ki[3] = qa, Ki[4] = zr, Ki[5] = _f, Ki[6] = qo, Li[0] = Wi, Li[1] = wf, Li[2] = Ef, Li[3] = Rs, Li[4] = va, Li[5] = Nf, Li[6] = Ms, m = 1;
          } else m = 0;
        }
        m && (m = function(he, De) {
          for (he.M = 0; he.M < he.Va; ++he.M) {
            var Ne, oe = he.Jc[he.M & he.Xb], fe = he.m, Pe = he;
            for (Ne = 0; Ne < Pe.za; ++Ne) {
              var Me = fe, ke = Pe, it = ke.Ac, Ke = ke.Bc + 4 * Ne, ht = ke.zc, Ze = ke.ya[ke.aa + Ne];
              if (ke.Qa.Bb ? Ze.$b = ie(Me, ke.Pa.jb[0]) ? 2 + ie(Me, ke.Pa.jb[2]) : ie(Me, ke.Pa.jb[1]) : Ze.$b = 0, ke.kc && (Ze.Ad = ie(Me, ke.Bd)), Ze.Za = !ie(Me, 145) + 0, Ze.Za) {
                var Ot = Ze.Ob, Bt = 0;
                for (ke = 0; 4 > ke; ++ke) {
                  var Pt, Nt = ht[0 + ke];
                  for (Pt = 0; 4 > Pt; ++Pt) {
                    Nt = _2[it[Ke + Pt]][Nt];
                    for (var $t = fh[ie(Me, Nt[0])]; 0 < $t; ) $t = fh[2 * $t + ie(Me, Nt[$t])];
                    Nt = -$t, it[Ke + Pt] = Nt;
                  }
                  n(Ot, Bt, it, Ke, 4), Bt += 4, ht[0 + ke] = Nt;
                }
              } else Nt = ie(Me, 156) ? ie(Me, 128) ? 1 : 3 : ie(Me, 163) ? 2 : 0, Ze.Ob[0] = Nt, i(it, Ke, Nt, 4), i(ht, 0, Nt, 4);
              Ze.Dd = ie(Me, 142) ? ie(Me, 114) ? ie(Me, 183) ? 1 : 3 : 2 : 0;
            }
            if (Pe.m.Ka) return cr(he, 7, "Premature end-of-partition0 encountered.");
            for (; he.ja < he.za; ++he.ja) {
              if (Pe = oe, Me = (fe = he).rb[fe.sb - 1], it = fe.rb[fe.sb + fe.ja], Ne = fe.ya[fe.aa + fe.ja], Ke = fe.kc ? Ne.Ad : 0) Me.la = it.la = 0, Ne.Za || (Me.Na = it.Na = 0), Ne.Hc = 0, Ne.Gc = 0, Ne.ia = 0;
              else {
                var Gt, St;
                if (Me = it, it = Pe, Ke = fe.Pa.Xc, ht = fe.ya[fe.aa + fe.ja], Ze = fe.pb[ht.$b], ke = ht.ad, Ot = 0, Bt = fe.rb[fe.sb - 1], Nt = Pt = 0, i(ke, Ot, 0, 384), ht.Za) var wr = 0, cn = Ke[3];
                else {
                  $t = a(16);
                  var yr = Me.Na + Bt.Na;
                  if (yr = to(it, Ke[1], yr, Ze.Eb, 0, $t, 0), Me.Na = Bt.Na = (0 < yr) + 0, 1 < yr) es($t, 0, ke, Ot);
                  else {
                    var un = $t[0] + 3 >> 3;
                    for ($t = 0; 256 > $t; $t += 16) ke[Ot + $t] = un;
                  }
                  wr = 1, cn = Ke[0];
                }
                var jt = 15 & Me.la, Sn = 15 & Bt.la;
                for ($t = 0; 4 > $t; ++$t) {
                  var An = 1 & Sn;
                  for (un = St = 0; 4 > un; ++un) jt = jt >> 1 | (An = (yr = to(it, cn, yr = An + (1 & jt), Ze.Sc, wr, ke, Ot)) > wr) << 7, St = St << 2 | (3 < yr ? 3 : 1 < yr ? 2 : ke[Ot + 0] != 0), Ot += 16;
                  jt >>= 4, Sn = Sn >> 1 | An << 7, Pt = (Pt << 8 | St) >>> 0;
                }
                for (cn = jt, wr = Sn >> 4, Gt = 0; 4 > Gt; Gt += 2) {
                  for (St = 0, jt = Me.la >> 4 + Gt, Sn = Bt.la >> 4 + Gt, $t = 0; 2 > $t; ++$t) {
                    for (An = 1 & Sn, un = 0; 2 > un; ++un) yr = An + (1 & jt), jt = jt >> 1 | (An = 0 < (yr = to(it, Ke[2], yr, Ze.Qc, 0, ke, Ot))) << 3, St = St << 2 | (3 < yr ? 3 : 1 < yr ? 2 : ke[Ot + 0] != 0), Ot += 16;
                    jt >>= 2, Sn = Sn >> 1 | An << 5;
                  }
                  Nt |= St << 4 * Gt, cn |= jt << 4 << Gt, wr |= (240 & Sn) << Gt;
                }
                Me.la = cn, Bt.la = wr, ht.Hc = Pt, ht.Gc = Nt, ht.ia = 43690 & Nt ? 0 : Ze.ia, Ke = !(Pt | Nt);
              }
              if (0 < fe.L && (fe.wa[fe.Y + fe.ja] = fe.gd[Ne.$b][Ne.Za], fe.wa[fe.Y + fe.ja].La |= !Ke), Pe.Ka) return cr(he, 7, "Premature end-of-file encountered.");
            }
            if (ks(he), fe = De, Pe = 1, Ne = (oe = he).D, Me = 0 < oe.L && oe.M >= oe.zb && oe.M <= oe.Va, oe.Aa == 0) e: {
              if (Ne.M = oe.M, Ne.uc = Me, Gs(oe, Ne), Pe = 1, Ne = (St = oe.D).Nb, Me = (Nt = h0[oe.L]) * oe.R, it = Nt / 2 * oe.B, $t = 16 * Ne * oe.R, un = 8 * Ne * oe.B, Ke = oe.sa, ht = oe.ta - Me + $t, Ze = oe.qa, ke = oe.ra - it + un, Ot = oe.Ha, Bt = oe.Ia - it + un, Sn = (jt = St.M) == 0, Pt = jt >= oe.Va - 1, oe.Aa == 2 && Gs(oe, St), St.uc) for (An = (yr = oe).D.M, e(yr.D.uc), St = yr.yb; St < yr.Hb; ++St) {
                wr = St, cn = An;
                var Lr = (Rr = (sr = yr).D).Nb;
                Gt = sr.R;
                var Rr = Rr.wa[Rr.Y + wr], tn = sr.sa, jn = sr.ta + 16 * Lr * Gt + 16 * wr, di = Rr.dd, Cr = Rr.tc;
                if (Cr != 0) if (e(3 <= Cr), sr.L == 1) 0 < wr && $i(tn, jn, Gt, Cr + 4), Rr.La && In(tn, jn, Gt, Cr), 0 < cn && Aa(tn, jn, Gt, Cr + 4), Rr.La && Qs(tn, jn, Gt, Cr);
                else {
                  var Ci = sr.B, ba = sr.qa, is = sr.ra + 8 * Lr * Ci + 8 * wr, Zi = sr.Ha, sr = sr.Ia + 8 * Lr * Ci + 8 * wr;
                  Lr = Rr.ld, 0 < wr && (e0(tn, jn, Gt, Cr + 4, di, Lr), ya(ba, is, Zi, sr, Ci, Cr + 4, di, Lr)), Rr.La && (Yi(tn, jn, Gt, Cr, di, Lr), rs(ba, is, Zi, sr, Ci, Cr, di, Lr)), 0 < cn && (ts(tn, jn, Gt, Cr + 4, di, Lr), Zs(ba, is, Zi, sr, Ci, Cr + 4, di, Lr)), Rr.La && (_a(tn, jn, Gt, Cr, di, Lr), Sa(ba, is, Zi, sr, Ci, Cr, di, Lr));
                }
              }
              if (oe.ia && alert("todo:DitherRow"), fe.put != null) {
                if (St = 16 * jt, jt = 16 * (jt + 1), Sn ? (fe.y = oe.sa, fe.O = oe.ta + $t, fe.f = oe.qa, fe.N = oe.ra + un, fe.ea = oe.Ha, fe.W = oe.Ia + un) : (St -= Nt, fe.y = Ke, fe.O = ht, fe.f = Ze, fe.N = ke, fe.ea = Ot, fe.W = Bt), Pt || (jt -= Nt), jt > fe.o && (jt = fe.o), fe.F = null, fe.J = null, oe.Fa != null && 0 < oe.Fa.length && St < jt && (fe.J = zs(oe, fe, St, jt - St), fe.F = oe.mb, fe.F == null && fe.F.length == 0)) {
                  Pe = cr(oe, 3, "Could not decode alpha data.");
                  break e;
                }
                St < fe.j && (Nt = fe.j - St, St = fe.j, e(!(1 & Nt)), fe.O += oe.R * Nt, fe.N += oe.B * (Nt >> 1), fe.W += oe.B * (Nt >> 1), fe.F != null && (fe.J += fe.width * Nt)), St < jt && (fe.O += fe.v, fe.N += fe.v >> 1, fe.W += fe.v >> 1, fe.F != null && (fe.J += fe.v), fe.ka = St - fe.j, fe.U = fe.va - fe.v, fe.T = jt - St, Pe = fe.put(fe));
              }
              Ne + 1 != oe.Ic || Pt || (n(oe.sa, oe.ta - Me, Ke, ht + 16 * oe.R, Me), n(oe.qa, oe.ra - it, Ze, ke + 8 * oe.B, it), n(oe.Ha, oe.Ia - it, Ot, Bt + 8 * oe.B, it));
            }
            if (!Pe) return cr(he, 6, "Output aborted.");
          }
          return 1;
        }(l, u)), u.bc != null && u.bc(u), m &= 1;
      }
      return m ? (l.cb = 0, m) : 0;
    }
    function Gn(l, u, m, _, T) {
      T = l[u + m + 32 * _] + (T >> 3), l[u + m + 32 * _] = -256 & T ? 0 > T ? 0 : 255 : T;
    }
    function Ua(l, u, m, _, T, k) {
      Gn(l, u, 0, m, _ + T), Gn(l, u, 1, m, _ + k), Gn(l, u, 2, m, _ - k), Gn(l, u, 3, m, _ - T);
    }
    function fn(l) {
      return (20091 * l >> 16) + l;
    }
    function Ds(l, u, m, _) {
      var T, k = 0, I = a(16);
      for (T = 0; 4 > T; ++T) {
        var R = l[u + 0] + l[u + 8], B = l[u + 0] - l[u + 8], V = (35468 * l[u + 4] >> 16) - fn(l[u + 12]), ae = fn(l[u + 4]) + (35468 * l[u + 12] >> 16);
        I[k + 0] = R + ae, I[k + 1] = B + V, I[k + 2] = B - V, I[k + 3] = R - ae, k += 4, u++;
      }
      for (T = k = 0; 4 > T; ++T) R = (l = I[k + 0] + 4) + I[k + 8], B = l - I[k + 8], V = (35468 * I[k + 4] >> 16) - fn(I[k + 12]), Gn(m, _, 0, 0, R + (ae = fn(I[k + 4]) + (35468 * I[k + 12] >> 16))), Gn(m, _, 1, 0, B + V), Gn(m, _, 2, 0, B - V), Gn(m, _, 3, 0, R - ae), k++, _ += 32;
    }
    function Mo(l, u, m, _) {
      var T = l[u + 0] + 4, k = 35468 * l[u + 4] >> 16, I = fn(l[u + 4]), R = 35468 * l[u + 1] >> 16;
      Ua(m, _, 0, T + I, l = fn(l[u + 1]), R), Ua(m, _, 1, T + k, l, R), Ua(m, _, 2, T - k, l, R), Ua(m, _, 3, T - I, l, R);
    }
    function gf(l, u, m, _, T) {
      Ds(l, u, m, _), T && Ds(l, u + 16, m, _ + 4);
    }
    function Bo(l, u, m, _) {
      Ni(l, u + 0, m, _, 1), Ni(l, u + 32, m, _ + 128, 1);
    }
    function vf(l, u, m, _) {
      var T;
      for (l = l[u + 0] + 4, T = 0; 4 > T; ++T) for (u = 0; 4 > u; ++u) Gn(m, _, u, T, l);
    }
    function jo(l, u, m, _) {
      l[u + 0] && en(l, u + 0, m, _), l[u + 16] && en(l, u + 16, m, _ + 4), l[u + 32] && en(l, u + 32, m, _ + 128), l[u + 48] && en(l, u + 48, m, _ + 128 + 4);
    }
    function mf(l, u, m, _) {
      var T, k = a(16);
      for (T = 0; 4 > T; ++T) {
        var I = l[u + 0 + T] + l[u + 12 + T], R = l[u + 4 + T] + l[u + 8 + T], B = l[u + 4 + T] - l[u + 8 + T], V = l[u + 0 + T] - l[u + 12 + T];
        k[0 + T] = I + R, k[8 + T] = I - R, k[4 + T] = V + B, k[12 + T] = V - B;
      }
      for (T = 0; 4 > T; ++T) I = (l = k[0 + 4 * T] + 3) + k[3 + 4 * T], R = k[1 + 4 * T] + k[2 + 4 * T], B = k[1 + 4 * T] - k[2 + 4 * T], V = l - k[3 + 4 * T], m[_ + 0] = I + R >> 3, m[_ + 16] = V + B >> 3, m[_ + 32] = I - R >> 3, m[_ + 48] = V - B >> 3, _ += 64;
    }
    function Os(l, u, m) {
      var _, T = u - 32, k = _n, I = 255 - l[T - 1];
      for (_ = 0; _ < m; ++_) {
        var R, B = k, V = I + l[u - 1];
        for (R = 0; R < m; ++R) l[u + R] = B[V + l[T + R]];
        u += 32;
      }
    }
    function xf(l, u) {
      Os(l, u, 4);
    }
    function wf(l, u) {
      Os(l, u, 8);
    }
    function yf(l, u) {
      Os(l, u, 16);
    }
    function Ai(l, u) {
      var m;
      for (m = 0; 16 > m; ++m) n(l, u + 32 * m, l, u - 32, 16);
    }
    function qa(l, u) {
      var m;
      for (m = 16; 0 < m; --m) i(l, u, l[u - 1], 16), u += 32;
    }
    function Ha(l, u, m) {
      var _;
      for (_ = 0; 16 > _; ++_) i(u, m + 32 * _, l, 16);
    }
    function Uo(l, u) {
      var m, _ = 16;
      for (m = 0; 16 > m; ++m) _ += l[u - 1 + 32 * m] + l[u + m - 32];
      Ha(_ >> 5, l, u);
    }
    function zr(l, u) {
      var m, _ = 8;
      for (m = 0; 16 > m; ++m) _ += l[u - 1 + 32 * m];
      Ha(_ >> 4, l, u);
    }
    function _f(l, u) {
      var m, _ = 8;
      for (m = 0; 16 > m; ++m) _ += l[u + m - 32];
      Ha(_ >> 4, l, u);
    }
    function qo(l, u) {
      Ha(128, l, u);
    }
    function mt(l, u, m) {
      return l + 2 * u + m + 2 >> 2;
    }
    function Sf(l, u) {
      var m, _ = u - 32;
      for (_ = new Uint8Array([mt(l[_ - 1], l[_ + 0], l[_ + 1]), mt(l[_ + 0], l[_ + 1], l[_ + 2]), mt(l[_ + 1], l[_ + 2], l[_ + 3]), mt(l[_ + 2], l[_ + 3], l[_ + 4])]), m = 0; 4 > m; ++m) n(l, u + 32 * m, _, 0, _.length);
    }
    function Af(l, u) {
      var m = l[u - 1], _ = l[u - 1 + 32], T = l[u - 1 + 64], k = l[u - 1 + 96];
      ve(l, u + 0, 16843009 * mt(l[u - 1 - 32], m, _)), ve(l, u + 32, 16843009 * mt(m, _, T)), ve(l, u + 64, 16843009 * mt(_, T, k)), ve(l, u + 96, 16843009 * mt(T, k, k));
    }
    function hi(l, u) {
      var m, _ = 4;
      for (m = 0; 4 > m; ++m) _ += l[u + m - 32] + l[u - 1 + 32 * m];
      for (_ >>= 3, m = 0; 4 > m; ++m) i(l, u + 32 * m, _, 4);
    }
    function Ho(l, u) {
      var m = l[u - 1 + 0], _ = l[u - 1 + 32], T = l[u - 1 + 64], k = l[u - 1 - 32], I = l[u + 0 - 32], R = l[u + 1 - 32], B = l[u + 2 - 32], V = l[u + 3 - 32];
      l[u + 0 + 96] = mt(_, T, l[u - 1 + 96]), l[u + 1 + 96] = l[u + 0 + 64] = mt(m, _, T), l[u + 2 + 96] = l[u + 1 + 64] = l[u + 0 + 32] = mt(k, m, _), l[u + 3 + 96] = l[u + 2 + 64] = l[u + 1 + 32] = l[u + 0 + 0] = mt(I, k, m), l[u + 3 + 64] = l[u + 2 + 32] = l[u + 1 + 0] = mt(R, I, k), l[u + 3 + 32] = l[u + 2 + 0] = mt(B, R, I), l[u + 3 + 0] = mt(V, B, R);
    }
    function Wo(l, u) {
      var m = l[u + 1 - 32], _ = l[u + 2 - 32], T = l[u + 3 - 32], k = l[u + 4 - 32], I = l[u + 5 - 32], R = l[u + 6 - 32], B = l[u + 7 - 32];
      l[u + 0 + 0] = mt(l[u + 0 - 32], m, _), l[u + 1 + 0] = l[u + 0 + 32] = mt(m, _, T), l[u + 2 + 0] = l[u + 1 + 32] = l[u + 0 + 64] = mt(_, T, k), l[u + 3 + 0] = l[u + 2 + 32] = l[u + 1 + 64] = l[u + 0 + 96] = mt(T, k, I), l[u + 3 + 32] = l[u + 2 + 64] = l[u + 1 + 96] = mt(k, I, R), l[u + 3 + 64] = l[u + 2 + 96] = mt(I, R, B), l[u + 3 + 96] = mt(R, B, B);
    }
    function Wa(l, u) {
      var m = l[u - 1 + 0], _ = l[u - 1 + 32], T = l[u - 1 + 64], k = l[u - 1 - 32], I = l[u + 0 - 32], R = l[u + 1 - 32], B = l[u + 2 - 32], V = l[u + 3 - 32];
      l[u + 0 + 0] = l[u + 1 + 64] = k + I + 1 >> 1, l[u + 1 + 0] = l[u + 2 + 64] = I + R + 1 >> 1, l[u + 2 + 0] = l[u + 3 + 64] = R + B + 1 >> 1, l[u + 3 + 0] = B + V + 1 >> 1, l[u + 0 + 96] = mt(T, _, m), l[u + 0 + 64] = mt(_, m, k), l[u + 0 + 32] = l[u + 1 + 96] = mt(m, k, I), l[u + 1 + 32] = l[u + 2 + 96] = mt(k, I, R), l[u + 2 + 32] = l[u + 3 + 96] = mt(I, R, B), l[u + 3 + 32] = mt(R, B, V);
    }
    function Is(l, u) {
      var m = l[u + 0 - 32], _ = l[u + 1 - 32], T = l[u + 2 - 32], k = l[u + 3 - 32], I = l[u + 4 - 32], R = l[u + 5 - 32], B = l[u + 6 - 32], V = l[u + 7 - 32];
      l[u + 0 + 0] = m + _ + 1 >> 1, l[u + 1 + 0] = l[u + 0 + 64] = _ + T + 1 >> 1, l[u + 2 + 0] = l[u + 1 + 64] = T + k + 1 >> 1, l[u + 3 + 0] = l[u + 2 + 64] = k + I + 1 >> 1, l[u + 0 + 32] = mt(m, _, T), l[u + 1 + 32] = l[u + 0 + 96] = mt(_, T, k), l[u + 2 + 32] = l[u + 1 + 96] = mt(T, k, I), l[u + 3 + 32] = l[u + 2 + 96] = mt(k, I, R), l[u + 3 + 64] = mt(I, R, B), l[u + 3 + 96] = mt(R, B, V);
    }
    function bf(l, u) {
      var m = l[u - 1 + 0], _ = l[u - 1 + 32], T = l[u - 1 + 64], k = l[u - 1 + 96];
      l[u + 0 + 0] = m + _ + 1 >> 1, l[u + 2 + 0] = l[u + 0 + 32] = _ + T + 1 >> 1, l[u + 2 + 32] = l[u + 0 + 64] = T + k + 1 >> 1, l[u + 1 + 0] = mt(m, _, T), l[u + 3 + 0] = l[u + 1 + 32] = mt(_, T, k), l[u + 3 + 32] = l[u + 1 + 64] = mt(T, k, k), l[u + 3 + 64] = l[u + 2 + 64] = l[u + 0 + 96] = l[u + 1 + 96] = l[u + 2 + 96] = l[u + 3 + 96] = k;
    }
    function Tf(l, u) {
      var m = l[u - 1 + 0], _ = l[u - 1 + 32], T = l[u - 1 + 64], k = l[u - 1 + 96], I = l[u - 1 - 32], R = l[u + 0 - 32], B = l[u + 1 - 32], V = l[u + 2 - 32];
      l[u + 0 + 0] = l[u + 2 + 32] = m + I + 1 >> 1, l[u + 0 + 32] = l[u + 2 + 64] = _ + m + 1 >> 1, l[u + 0 + 64] = l[u + 2 + 96] = T + _ + 1 >> 1, l[u + 0 + 96] = k + T + 1 >> 1, l[u + 3 + 0] = mt(R, B, V), l[u + 2 + 0] = mt(I, R, B), l[u + 1 + 0] = l[u + 3 + 32] = mt(m, I, R), l[u + 1 + 32] = l[u + 3 + 64] = mt(_, m, I), l[u + 1 + 64] = l[u + 3 + 96] = mt(T, _, m), l[u + 1 + 96] = mt(k, T, _);
    }
    function Ef(l, u) {
      var m;
      for (m = 0; 8 > m; ++m) n(l, u + 32 * m, l, u - 32, 8);
    }
    function Rs(l, u) {
      var m;
      for (m = 0; 8 > m; ++m) i(l, u, l[u - 1], 8), u += 32;
    }
    function ga(l, u, m) {
      var _;
      for (_ = 0; 8 > _; ++_) i(u, m + 32 * _, l, 8);
    }
    function Wi(l, u) {
      var m, _ = 8;
      for (m = 0; 8 > m; ++m) _ += l[u + m - 32] + l[u - 1 + 32 * m];
      ga(_ >> 4, l, u);
    }
    function Nf(l, u) {
      var m, _ = 4;
      for (m = 0; 8 > m; ++m) _ += l[u + m - 32];
      ga(_ >> 3, l, u);
    }
    function va(l, u) {
      var m, _ = 4;
      for (m = 0; 8 > m; ++m) _ += l[u - 1 + 32 * m];
      ga(_ >> 3, l, u);
    }
    function Ms(l, u) {
      ga(128, l, u);
    }
    function za(l, u, m) {
      var _ = l[u - m], T = l[u + 0], k = 3 * (T - _) + Df[1020 + l[u - 2 * m] - l[u + m]], I = r0[112 + (k + 4 >> 3)];
      l[u - m] = _n[255 + _ + r0[112 + (k + 3 >> 3)]], l[u + 0] = _n[255 + T - I];
    }
    function zo(l, u, m, _) {
      var T = l[u + 0], k = l[u + m];
      return Mn[255 + l[u - 2 * m] - l[u - m]] > _ || Mn[255 + k - T] > _;
    }
    function Vo(l, u, m, _) {
      return 4 * Mn[255 + l[u - m] - l[u + 0]] + Mn[255 + l[u - 2 * m] - l[u + m]] <= _;
    }
    function Go(l, u, m, _, T) {
      var k = l[u - 3 * m], I = l[u - 2 * m], R = l[u - m], B = l[u + 0], V = l[u + m], ae = l[u + 2 * m], me = l[u + 3 * m];
      return 4 * Mn[255 + R - B] + Mn[255 + I - V] > _ ? 0 : Mn[255 + l[u - 4 * m] - k] <= T && Mn[255 + k - I] <= T && Mn[255 + I - R] <= T && Mn[255 + me - ae] <= T && Mn[255 + ae - V] <= T && Mn[255 + V - B] <= T;
    }
    function Xo(l, u, m, _) {
      var T = 2 * _ + 1;
      for (_ = 0; 16 > _; ++_) Vo(l, u + _, m, T) && za(l, u + _, m);
    }
    function ci(l, u, m, _) {
      var T = 2 * _ + 1;
      for (_ = 0; 16 > _; ++_) Vo(l, u + _ * m, 1, T) && za(l, u + _ * m, 1);
    }
    function bi(l, u, m, _) {
      var T;
      for (T = 3; 0 < T; --T) Xo(l, u += 4 * m, m, _);
    }
    function Ff(l, u, m, _) {
      var T;
      for (T = 3; 0 < T; --T) ci(l, u += 4, m, _);
    }
    function zi(l, u, m, _, T, k, I, R) {
      for (k = 2 * k + 1; 0 < T--; ) {
        if (Go(l, u, m, k, I)) if (zo(l, u, m, R)) za(l, u, m);
        else {
          var B = l, V = u, ae = m, me = B[V - 2 * ae], xe = B[V - ae], he = B[V + 0], De = B[V + ae], Ne = B[V + 2 * ae], oe = 27 * (Pe = Df[1020 + 3 * (he - xe) + Df[1020 + me - De]]) + 63 >> 7, fe = 18 * Pe + 63 >> 7, Pe = 9 * Pe + 63 >> 7;
          B[V - 3 * ae] = _n[255 + B[V - 3 * ae] + Pe], B[V - 2 * ae] = _n[255 + me + fe], B[V - ae] = _n[255 + xe + oe], B[V + 0] = _n[255 + he - oe], B[V + ae] = _n[255 + De - fe], B[V + 2 * ae] = _n[255 + Ne - Pe];
        }
        u += _;
      }
    }
    function Xn(l, u, m, _, T, k, I, R) {
      for (k = 2 * k + 1; 0 < T--; ) {
        if (Go(l, u, m, k, I)) if (zo(l, u, m, R)) za(l, u, m);
        else {
          var B = l, V = u, ae = m, me = B[V - ae], xe = B[V + 0], he = B[V + ae], De = r0[112 + ((Ne = 3 * (xe - me)) + 4 >> 3)], Ne = r0[112 + (Ne + 3 >> 3)], oe = De + 1 >> 1;
          B[V - 2 * ae] = _n[255 + B[V - 2 * ae] + oe], B[V - ae] = _n[255 + me + Ne], B[V + 0] = _n[255 + xe - De], B[V + ae] = _n[255 + he - oe];
        }
        u += _;
      }
    }
    function Bs(l, u, m, _, T, k) {
      zi(l, u, m, 1, 16, _, T, k);
    }
    function ma(l, u, m, _, T, k) {
      zi(l, u, 1, m, 16, _, T, k);
    }
    function Lf(l, u, m, _, T, k) {
      var I;
      for (I = 3; 0 < I; --I) Xn(l, u += 4 * m, m, 1, 16, _, T, k);
    }
    function Va(l, u, m, _, T, k) {
      var I;
      for (I = 3; 0 < I; --I) Xn(l, u += 4, 1, m, 16, _, T, k);
    }
    function Cf(l, u, m, _, T, k, I, R) {
      zi(l, u, T, 1, 8, k, I, R), zi(m, _, T, 1, 8, k, I, R);
    }
    function js(l, u, m, _, T, k, I, R) {
      zi(l, u, 1, T, 8, k, I, R), zi(m, _, 1, T, 8, k, I, R);
    }
    function Us(l, u, m, _, T, k, I, R) {
      Xn(l, u + 4 * T, T, 1, 8, k, I, R), Xn(m, _ + 4 * T, T, 1, 8, k, I, R);
    }
    function Yo(l, u, m, _, T, k, I, R) {
      Xn(l, u + 4, 1, T, 8, k, I, R), Xn(m, _ + 4, 1, T, 8, k, I, R);
    }
    function Ga() {
      this.ba = new mn(), this.ec = [], this.cc = [], this.Mc = [], this.Dc = this.Nc = this.dc = this.fc = 0, this.Oa = new Yt(), this.memory = 0, this.Ib = "OutputFunc", this.Jb = "OutputAlphaFunc", this.Nd = "OutputRowFunc";
    }
    function qs() {
      this.data = [], this.offset = this.kd = this.ha = this.w = 0, this.na = [], this.xa = this.gb = this.Ja = this.Sa = this.P = 0;
    }
    function Hs() {
      this.nc = this.Ea = this.b = this.hc = 0, this.K = [], this.w = 0;
    }
    function $o() {
      this.ua = 0, this.Wa = new Z(), this.vb = new Z(), this.md = this.xc = this.wc = 0, this.vc = [], this.Wb = 0, this.Ya = new Q(), this.yc = new P();
    }
    function Pf() {
      this.xb = this.a = 0, this.l = new li(), this.ca = new mn(), this.V = [], this.Ba = 0, this.Ta = [], this.Ua = 0, this.m = new y(), this.Pb = 0, this.wd = new y(), this.Ma = this.$ = this.C = this.i = this.c = this.xd = 0, this.s = new $o(), this.ab = 0, this.gc = s(4, Hs), this.Oc = 0;
    }
    function Xa() {
      this.Lc = this.Z = this.$a = this.i = this.c = 0, this.l = new li(), this.ic = 0, this.ca = [], this.tb = 0, this.qd = null, this.rd = 0;
    }
    function xa(l, u, m, _, T, k, I) {
      for (l = l == null ? 0 : l[u + 0], u = 0; u < I; ++u) T[k + u] = l + m[_ + u] & 255, l = T[k + u];
    }
    function Ws(l, u, m, _, T, k, I) {
      var R;
      if (l == null) xa(null, null, m, _, T, k, I);
      else for (R = 0; R < I; ++R) T[k + R] = l[u + R] + m[_ + R] & 255;
    }
    function Vi(l, u, m, _, T, k, I) {
      if (l == null) xa(null, null, m, _, T, k, I);
      else {
        var R, B = l[u + 0], V = B, ae = B;
        for (R = 0; R < I; ++R) V = ae + (B = l[u + R]) - V, ae = m[_ + R] + (-256 & V ? 0 > V ? 0 : 255 : V) & 255, V = B, T[k + R] = ae;
      }
    }
    function zs(l, u, m, _) {
      var T = u.width, k = u.o;
      if (e(l != null && u != null), 0 > m || 0 >= _ || m + _ > k) return null;
      if (!l.Cc) {
        if (l.ga == null) {
          var I;
          if (l.ga = new Xa(), (I = l.ga == null) || (I = u.width * u.o, e(l.Gb.length == 0), l.Gb = a(I), l.Uc = 0, l.Gb == null ? I = 0 : (l.mb = l.Gb, l.nb = l.Uc, l.rc = null, I = 1), I = !I), !I) {
            I = l.ga;
            var R = l.Fa, B = l.P, V = l.qc, ae = l.mb, me = l.nb, xe = B + 1, he = V - 1, De = I.l;
            if (e(R != null && ae != null && u != null), Ji[0] = null, Ji[1] = xa, Ji[2] = Ws, Ji[3] = Vi, I.ca = ae, I.tb = me, I.c = u.width, I.i = u.height, e(0 < I.c && 0 < I.i), 1 >= V) u = 0;
            else if (I.$a = R[B + 0] >> 0 & 3, I.Z = R[B + 0] >> 2 & 3, I.Lc = R[B + 0] >> 4 & 3, B = R[B + 0] >> 6 & 3, 0 > I.$a || 1 < I.$a || 4 <= I.Z || 1 < I.Lc || B) u = 0;
            else if (De.put = Pn, De.ac = Tr, De.bc = kn, De.ma = I, De.width = u.width, De.height = u.height, De.Da = u.Da, De.v = u.v, De.va = u.va, De.j = u.j, De.o = u.o, I.$a) e: {
              e(I.$a == 1), u = Ee();
              t: for (; ; ) {
                if (u == null) {
                  u = 0;
                  break e;
                }
                if (e(I != null), I.mc = u, u.c = I.c, u.i = I.i, u.l = I.l, u.l.ma = I, u.l.width = I.c, u.l.height = I.i, u.a = 0, de(u.m, R, xe, he), !pe(I.c, I.i, 1, u, null) || (u.ab == 1 && u.gc[0].hc == 3 && U(u.s) ? (I.ic = 1, R = u.c * u.i, u.Ta = null, u.Ua = 0, u.V = a(R), u.Ba = 0, u.V == null ? (u.a = 1, u = 0) : u = 1) : (I.ic = 0, u = ye(u, I.c)), !u)) break t;
                u = 1;
                break e;
              }
              I.mc = null, u = 0;
            }
            else u = he >= I.c * I.i;
            I = !u;
          }
          if (I) return null;
          l.ga.Lc != 1 ? l.Ga = 0 : _ = k - m;
        }
        e(l.ga != null), e(m + _ <= k);
        e: {
          if (u = (R = l.ga).c, k = R.l.o, R.$a == 0) {
            if (xe = l.rc, he = l.Vc, De = l.Fa, B = l.P + 1 + m * u, V = l.mb, ae = l.nb + m * u, e(B <= l.P + l.qc), R.Z != 0) for (e(Ji[R.Z] != null), I = 0; I < _; ++I) Ji[R.Z](xe, he, De, B, V, ae, u), xe = V, he = ae, ae += u, B += u;
            else for (I = 0; I < _; ++I) n(V, ae, De, B, u), xe = V, he = ae, ae += u, B += u;
            l.rc = xe, l.Vc = he;
          } else {
            if (e(R.mc != null), u = m + _, e((I = R.mc) != null), e(u <= I.i), I.C >= u) u = 1;
            else if (R.ic || ue(), R.ic) {
              R = I.V, xe = I.Ba, he = I.c;
              var Ne = I.i, oe = (De = 1, B = I.$ / he, V = I.$ % he, ae = I.m, me = I.s, I.$), fe = he * Ne, Pe = he * u, Me = me.wc, ke = oe < Pe ? ir(me, V, B) : null;
              e(oe <= fe), e(u <= Ne), e(U(me));
              t: for (; ; ) {
                for (; !ae.h && oe < Pe; ) {
                  if (V & Me || (ke = ir(me, V, B)), e(ke != null), z(ae), 256 > (Ne = Wr(ke.G[0], ke.H[0], ae))) R[xe + oe] = Ne, ++oe, ++V >= he && (V = 0, ++B <= u && !(B % 16) && G(I, B));
                  else {
                    if (!(280 > Ne)) {
                      De = 0;
                      break t;
                    }
                    Ne = xn(Ne - 256, ae);
                    var it, Ke = Wr(ke.G[4], ke.H[4], ae);
                    if (z(ae), !(oe >= (Ke = on(he, Ke = xn(Ke, ae))) && fe - oe >= Ne)) {
                      De = 0;
                      break t;
                    }
                    for (it = 0; it < Ne; ++it) R[xe + oe + it] = R[xe + oe + it - Ke];
                    for (oe += Ne, V += Ne; V >= he; ) V -= he, ++B <= u && !(B % 16) && G(I, B);
                    oe < Pe && V & Me && (ke = ir(me, V, B));
                  }
                  e(ae.h == N(ae));
                }
                G(I, B > u ? u : B);
                break t;
              }
              !De || ae.h && oe < fe ? (De = 0, I.a = ae.h ? 5 : 3) : I.$ = oe, u = De;
            } else u = K(I, I.V, I.Ba, I.c, I.i, u, _e);
            if (!u) {
              _ = 0;
              break e;
            }
          }
          m + _ >= k && (l.Cc = 1), _ = 1;
        }
        if (!_) return null;
        if (l.Cc && ((_ = l.ga) != null && (_.mc = null), l.ga = null, 0 < l.Ga)) return alert("todo:WebPDequantizeLevels"), null;
      }
      return l.nb + m * T;
    }
    function g(l, u, m, _, T, k) {
      for (; 0 < T--; ) {
        var I, R = l, B = u + (m ? 1 : 0), V = l, ae = u + (m ? 0 : 3);
        for (I = 0; I < _; ++I) {
          var me = V[ae + 4 * I];
          me != 255 && (me *= 32897, R[B + 4 * I + 0] = R[B + 4 * I + 0] * me >> 23, R[B + 4 * I + 1] = R[B + 4 * I + 1] * me >> 23, R[B + 4 * I + 2] = R[B + 4 * I + 2] * me >> 23);
        }
        u += k;
      }
    }
    function E(l, u, m, _, T) {
      for (; 0 < _--; ) {
        var k;
        for (k = 0; k < m; ++k) {
          var I = l[u + 2 * k + 0], R = 15 & (V = l[u + 2 * k + 1]), B = 4369 * R, V = (240 & V | V >> 4) * B >> 16;
          l[u + 2 * k + 0] = (240 & I | I >> 4) * B >> 16 & 240 | (15 & I | I << 4) * B >> 16 >> 4 & 15, l[u + 2 * k + 1] = 240 & V | R;
        }
        u += T;
      }
    }
    function J(l, u, m, _, T, k, I, R) {
      var B, V, ae = 255;
      for (V = 0; V < T; ++V) {
        for (B = 0; B < _; ++B) {
          var me = l[u + B];
          k[I + 4 * B] = me, ae &= me;
        }
        u += m, I += R;
      }
      return ae != 255;
    }
    function ne(l, u, m, _, T) {
      var k;
      for (k = 0; k < T; ++k) m[_ + k] = l[u + k] >> 8;
    }
    function ue() {
      Rn = g, Zt = E, Qt = J, dr = ne;
    }
    function Fe(l, u, m) {
      M[l] = function(_, T, k, I, R, B, V, ae, me, xe, he, De, Ne, oe, fe, Pe, Me) {
        var ke, it = Me - 1 >> 1, Ke = R[B + 0] | V[ae + 0] << 16, ht = me[xe + 0] | he[De + 0] << 16;
        e(_ != null);
        var Ze = 3 * Ke + ht + 131074 >> 2;
        for (u(_[T + 0], 255 & Ze, Ze >> 16, Ne, oe), k != null && (Ze = 3 * ht + Ke + 131074 >> 2, u(k[I + 0], 255 & Ze, Ze >> 16, fe, Pe)), ke = 1; ke <= it; ++ke) {
          var Ot = R[B + ke] | V[ae + ke] << 16, Bt = me[xe + ke] | he[De + ke] << 16, Pt = Ke + Ot + ht + Bt + 524296, Nt = Pt + 2 * (Ot + ht) >> 3;
          Ze = Nt + Ke >> 1, Ke = (Pt = Pt + 2 * (Ke + Bt) >> 3) + Ot >> 1, u(_[T + 2 * ke - 1], 255 & Ze, Ze >> 16, Ne, oe + (2 * ke - 1) * m), u(_[T + 2 * ke - 0], 255 & Ke, Ke >> 16, Ne, oe + (2 * ke - 0) * m), k != null && (Ze = Pt + ht >> 1, Ke = Nt + Bt >> 1, u(k[I + 2 * ke - 1], 255 & Ze, Ze >> 16, fe, Pe + (2 * ke - 1) * m), u(k[I + 2 * ke + 0], 255 & Ke, Ke >> 16, fe, Pe + (2 * ke + 0) * m)), Ke = Ot, ht = Bt;
        }
        1 & Me || (Ze = 3 * Ke + ht + 131074 >> 2, u(_[T + Me - 1], 255 & Ze, Ze >> 16, Ne, oe + (Me - 1) * m), k != null && (Ze = 3 * ht + Ke + 131074 >> 2, u(k[I + Me - 1], 255 & Ze, Ze >> 16, fe, Pe + (Me - 1) * m)));
      };
    }
    function je() {
      Bn[n0] = T2, Bn[i0] = hh, Bn[ah] = E2, Bn[a0] = ch, Bn[s0] = uh, Bn[Of] = dh, Bn[sh] = N2, Bn[If] = hh, Bn[Rf] = ch, Bn[o0] = uh, Bn[Mf] = dh;
    }
    function nt(l) {
      return l & ~F2 ? 0 > l ? 0 : 255 : l >> ph;
    }
    function ft(l, u) {
      return nt((19077 * l >> 8) + (26149 * u >> 8) - 14234);
    }
    function yt(l, u, m) {
      return nt((19077 * l >> 8) - (6419 * u >> 8) - (13320 * m >> 8) + 8708);
    }
    function xt(l, u) {
      return nt((19077 * l >> 8) + (33050 * u >> 8) - 17685);
    }
    function Lt(l, u, m, _, T) {
      _[T + 0] = ft(l, m), _[T + 1] = yt(l, u, m), _[T + 2] = xt(l, u);
    }
    function nr(l, u, m, _, T) {
      _[T + 0] = xt(l, u), _[T + 1] = yt(l, u, m), _[T + 2] = ft(l, m);
    }
    function ar(l, u, m, _, T) {
      var k = yt(l, u, m);
      u = k << 3 & 224 | xt(l, u) >> 3, _[T + 0] = 248 & ft(l, m) | k >> 5, _[T + 1] = u;
    }
    function xr(l, u, m, _, T) {
      var k = 240 & xt(l, u) | 15;
      _[T + 0] = 240 & ft(l, m) | yt(l, u, m) >> 4, _[T + 1] = k;
    }
    function Vr(l, u, m, _, T) {
      _[T + 0] = 255, Lt(l, u, m, _, T + 1);
    }
    function Fr(l, u, m, _, T) {
      nr(l, u, m, _, T), _[T + 3] = 255;
    }
    function Yn(l, u, m, _, T) {
      Lt(l, u, m, _, T), _[T + 3] = 255;
    }
    function yn(l, u) {
      return 0 > l ? 0 : l > u ? u : l;
    }
    function ui(l, u, m) {
      M[l] = function(_, T, k, I, R, B, V, ae, me) {
        for (var xe = ae + (-2 & me) * m; ae != xe; ) u(_[T + 0], k[I + 0], R[B + 0], V, ae), u(_[T + 1], k[I + 0], R[B + 0], V, ae + m), T += 2, ++I, ++B, ae += 2 * m;
        1 & me && u(_[T + 0], k[I + 0], R[B + 0], V, ae);
      };
    }
    function Ko(l, u, m) {
      return m == 0 ? l == 0 ? u == 0 ? 6 : 5 : u == 0 ? 4 : 0 : m;
    }
    function Vs(l, u, m, _, T) {
      switch (l >>> 30) {
        case 3:
          Ni(u, m, _, T, 0);
          break;
        case 2:
          ur(u, m, _, T);
          break;
        case 1:
          en(u, m, _, T);
      }
    }
    function Gs(l, u) {
      var m, _, T = u.M, k = u.Nb, I = l.oc, R = l.pc + 40, B = l.oc, V = l.pc + 584, ae = l.oc, me = l.pc + 600;
      for (m = 0; 16 > m; ++m) I[R + 32 * m - 1] = 129;
      for (m = 0; 8 > m; ++m) B[V + 32 * m - 1] = 129, ae[me + 32 * m - 1] = 129;
      for (0 < T ? I[R - 1 - 32] = B[V - 1 - 32] = ae[me - 1 - 32] = 129 : (i(I, R - 32 - 1, 127, 21), i(B, V - 32 - 1, 127, 9), i(ae, me - 32 - 1, 127, 9)), _ = 0; _ < l.za; ++_) {
        var xe = u.ya[u.aa + _];
        if (0 < _) {
          for (m = -1; 16 > m; ++m) n(I, R + 32 * m - 4, I, R + 32 * m + 12, 4);
          for (m = -1; 8 > m; ++m) n(B, V + 32 * m - 4, B, V + 32 * m + 4, 4), n(ae, me + 32 * m - 4, ae, me + 32 * m + 4, 4);
        }
        var he = l.Gd, De = l.Hd + _, Ne = xe.ad, oe = xe.Hc;
        if (0 < T && (n(I, R - 32, he[De].y, 0, 16), n(B, V - 32, he[De].f, 0, 8), n(ae, me - 32, he[De].ea, 0, 8)), xe.Za) {
          var fe = I, Pe = R - 32 + 16;
          for (0 < T && (_ >= l.za - 1 ? i(fe, Pe, he[De].y[15], 4) : n(fe, Pe, he[De + 1].y, 0, 4)), m = 0; 4 > m; m++) fe[Pe + 128 + m] = fe[Pe + 256 + m] = fe[Pe + 384 + m] = fe[Pe + 0 + m];
          for (m = 0; 16 > m; ++m, oe <<= 2) fe = I, Pe = R + vh[m], $n[xe.Ob[m]](fe, Pe), Vs(oe, Ne, 16 * +m, fe, Pe);
        } else if (fe = Ko(_, T, xe.Ob[0]), Ki[fe](I, R), oe != 0) for (m = 0; 16 > m; ++m, oe <<= 2) Vs(oe, Ne, 16 * +m, I, R + vh[m]);
        for (m = xe.Gc, fe = Ko(_, T, xe.Dd), Li[fe](B, V), Li[fe](ae, me), oe = Ne, fe = B, Pe = V, 255 & (xe = m >> 0) && (170 & xe ? Js(oe, 256, fe, Pe) : On(oe, 256, fe, Pe)), xe = ae, oe = me, 255 & (m >>= 8) && (170 & m ? Js(Ne, 320, xe, oe) : On(Ne, 320, xe, oe)), T < l.Ub - 1 && (n(he[De].y, 0, I, R + 480, 16), n(he[De].f, 0, B, V + 224, 8), n(he[De].ea, 0, ae, me + 224, 8)), m = 8 * k * l.B, he = l.sa, De = l.ta + 16 * _ + 16 * k * l.R, Ne = l.qa, xe = l.ra + 8 * _ + m, oe = l.Ha, fe = l.Ia + 8 * _ + m, m = 0; 16 > m; ++m) n(he, De + m * l.R, I, R + 32 * m, 16);
        for (m = 0; 8 > m; ++m) n(Ne, xe + m * l.B, B, V + 32 * m, 8), n(oe, fe + m * l.B, ae, me + 32 * m, 8);
      }
    }
    function Ya(l, u, m, _, T, k, I, R, B) {
      var V = [0], ae = [0], me = 0, xe = B != null ? B.kd : 0, he = B ?? new qs();
      if (l == null || 12 > m) return 7;
      he.data = l, he.w = u, he.ha = m, u = [u], m = [m], he.gb = [he.gb];
      e: {
        var De = u, Ne = m, oe = he.gb;
        if (e(l != null), e(Ne != null), e(oe != null), oe[0] = 0, 12 <= Ne[0] && !t(l, De[0], "RIFF")) {
          if (t(l, De[0] + 8, "WEBP")) {
            oe = 3;
            break e;
          }
          var fe = qe(l, De[0] + 4);
          if (12 > fe || 4294967286 < fe) {
            oe = 3;
            break e;
          }
          if (xe && fe > Ne[0] - 8) {
            oe = 7;
            break e;
          }
          oe[0] = fe, De[0] += 12, Ne[0] -= 12;
        }
        oe = 0;
      }
      if (oe != 0) return oe;
      for (fe = 0 < he.gb[0], m = m[0]; ; ) {
        e: {
          var Pe = l;
          Ne = u, oe = m;
          var Me = V, ke = ae, it = De = [0];
          if ((Ze = me = [me])[0] = 0, 8 > oe[0]) oe = 7;
          else {
            if (!t(Pe, Ne[0], "VP8X")) {
              if (qe(Pe, Ne[0] + 4) != 10) {
                oe = 3;
                break e;
              }
              if (18 > oe[0]) {
                oe = 7;
                break e;
              }
              var Ke = qe(Pe, Ne[0] + 8), ht = 1 + Oe(Pe, Ne[0] + 12);
              if (2147483648 <= ht * (Pe = 1 + Oe(Pe, Ne[0] + 15))) {
                oe = 3;
                break e;
              }
              it != null && (it[0] = Ke), Me != null && (Me[0] = ht), ke != null && (ke[0] = Pe), Ne[0] += 18, oe[0] -= 18, Ze[0] = 1;
            }
            oe = 0;
          }
        }
        if (me = me[0], De = De[0], oe != 0) return oe;
        if (Ne = !!(2 & De), !fe && me) return 3;
        if (k != null && (k[0] = !!(16 & De)), I != null && (I[0] = Ne), R != null && (R[0] = 0), I = V[0], De = ae[0], me && Ne && B == null) {
          oe = 0;
          break;
        }
        if (4 > m) {
          oe = 7;
          break;
        }
        if (fe && me || !fe && !me && !t(l, u[0], "ALPH")) {
          m = [m], he.na = [he.na], he.P = [he.P], he.Sa = [he.Sa];
          e: {
            Ke = l, oe = u, fe = m;
            var Ze = he.gb;
            Me = he.na, ke = he.P, it = he.Sa, ht = 22, e(Ke != null), e(fe != null), Pe = oe[0];
            var Ot = fe[0];
            for (e(Me != null), e(it != null), Me[0] = null, ke[0] = null, it[0] = 0; ; ) {
              if (oe[0] = Pe, fe[0] = Ot, 8 > Ot) {
                oe = 7;
                break e;
              }
              var Bt = qe(Ke, Pe + 4);
              if (4294967286 < Bt) {
                oe = 3;
                break e;
              }
              var Pt = 8 + Bt + 1 & -2;
              if (ht += Pt, 0 < Ze && ht > Ze) {
                oe = 3;
                break e;
              }
              if (!t(Ke, Pe, "VP8 ") || !t(Ke, Pe, "VP8L")) {
                oe = 0;
                break e;
              }
              if (Ot[0] < Pt) {
                oe = 7;
                break e;
              }
              t(Ke, Pe, "ALPH") || (Me[0] = Ke, ke[0] = Pe + 8, it[0] = Bt), Pe += Pt, Ot -= Pt;
            }
          }
          if (m = m[0], he.na = he.na[0], he.P = he.P[0], he.Sa = he.Sa[0], oe != 0) break;
        }
        m = [m], he.Ja = [he.Ja], he.xa = [he.xa];
        e: if (Ze = l, oe = u, fe = m, Me = he.gb[0], ke = he.Ja, it = he.xa, Ke = oe[0], Pe = !t(Ze, Ke, "VP8 "), ht = !t(Ze, Ke, "VP8L"), e(Ze != null), e(fe != null), e(ke != null), e(it != null), 8 > fe[0]) oe = 7;
        else {
          if (Pe || ht) {
            if (Ze = qe(Ze, Ke + 4), 12 <= Me && Ze > Me - 12) {
              oe = 3;
              break e;
            }
            if (xe && Ze > fe[0] - 8) {
              oe = 7;
              break e;
            }
            ke[0] = Ze, oe[0] += 8, fe[0] -= 8, it[0] = ht;
          } else it[0] = 5 <= fe[0] && Ze[Ke + 0] == 47 && !(Ze[Ke + 4] >> 5), ke[0] = fe[0];
          oe = 0;
        }
        if (m = m[0], he.Ja = he.Ja[0], he.xa = he.xa[0], u = u[0], oe != 0) break;
        if (4294967286 < he.Ja) return 3;
        if (R == null || Ne || (R[0] = he.xa ? 2 : 1), I = [I], De = [De], he.xa) {
          if (5 > m) {
            oe = 7;
            break;
          }
          R = I, xe = De, Ne = k, l == null || 5 > m ? l = 0 : 5 <= m && l[u + 0] == 47 && !(l[u + 4] >> 5) ? (fe = [0], Ze = [0], Me = [0], de(ke = new y(), l, u, m), lt(ke, fe, Ze, Me) ? (R != null && (R[0] = fe[0]), xe != null && (xe[0] = Ze[0]), Ne != null && (Ne[0] = Me[0]), l = 1) : l = 0) : l = 0;
        } else {
          if (10 > m) {
            oe = 7;
            break;
          }
          R = De, l == null || 10 > m || !Oo(l, u + 3, m - 3) ? l = 0 : (xe = l[u + 0] | l[u + 1] << 8 | l[u + 2] << 16, Ne = 16383 & (l[u + 7] << 8 | l[u + 6]), l = 16383 & (l[u + 9] << 8 | l[u + 8]), 1 & xe || 3 < (xe >> 1 & 7) || !(xe >> 4 & 1) || xe >> 5 >= he.Ja || !Ne || !l ? l = 0 : (I && (I[0] = Ne), R && (R[0] = l), l = 1));
        }
        if (!l || (I = I[0], De = De[0], me && (V[0] != I || ae[0] != De))) return 3;
        B != null && (B[0] = he, B.offset = u - B.w, e(4294967286 > u - B.w), e(B.offset == B.ha - m));
        break;
      }
      return oe == 0 || oe == 7 && me && B == null ? (k != null && (k[0] |= he.na != null && 0 < he.na.length), _ != null && (_[0] = I), T != null && (T[0] = De), 0) : oe;
    }
    function Xs(l, u, m) {
      var _ = u.width, T = u.height, k = 0, I = 0, R = _, B = T;
      if (u.Da = l != null && 0 < l.Da, u.Da && (R = l.cd, B = l.bd, k = l.v, I = l.j, 11 > m || (k &= -2, I &= -2), 0 > k || 0 > I || 0 >= R || 0 >= B || k + R > _ || I + B > T)) return 0;
      if (u.v = k, u.j = I, u.va = k + R, u.o = I + B, u.U = R, u.T = B, u.da = l != null && 0 < l.da, u.da) {
        if (!Ie(R, B, m = [l.ib], k = [l.hb])) return 0;
        u.ib = m[0], u.hb = k[0];
      }
      return u.ob = l != null && l.ob, u.Kb = l == null || !l.Sd, u.da && (u.ob = u.ib < 3 * _ / 4 && u.hb < 3 * T / 4, u.Kb = 0), 1;
    }
    function Ys(l) {
      if (l == null) return 2;
      if (11 > l.S) {
        var u = l.f.RGBA;
        u.fb += (l.height - 1) * u.A, u.A = -u.A;
      } else u = l.f.kb, l = l.height, u.O += (l - 1) * u.fa, u.fa = -u.fa, u.N += (l - 1 >> 1) * u.Ab, u.Ab = -u.Ab, u.W += (l - 1 >> 1) * u.Db, u.Db = -u.Db, u.F != null && (u.J += (l - 1) * u.lb, u.lb = -u.lb);
      return 0;
    }
    function $a(l, u, m, _) {
      if (_ == null || 0 >= l || 0 >= u) return 2;
      if (m != null) {
        if (m.Da) {
          var T = m.cd, k = m.bd, I = -2 & m.v, R = -2 & m.j;
          if (0 > I || 0 > R || 0 >= T || 0 >= k || I + T > l || R + k > u) return 2;
          l = T, u = k;
        }
        if (m.da) {
          if (!Ie(l, u, T = [m.ib], k = [m.hb])) return 2;
          l = T[0], u = k[0];
        }
      }
      _.width = l, _.height = u;
      e: {
        var B = _.width, V = _.height;
        if (l = _.S, 0 >= B || 0 >= V || !(l >= n0 && 13 > l)) l = 2;
        else {
          if (0 >= _.Rd && _.sd == null) {
            I = k = T = u = 0;
            var ae = (R = B * mh[l]) * V;
            if (11 > l || (k = (V + 1) / 2 * (u = (B + 1) / 2), l == 12 && (I = (T = B) * V)), (V = a(ae + 2 * k + I)) == null) {
              l = 1;
              break e;
            }
            _.sd = V, 11 > l ? ((B = _.f.RGBA).eb = V, B.fb = 0, B.A = R, B.size = ae) : ((B = _.f.kb).y = V, B.O = 0, B.fa = R, B.Fd = ae, B.f = V, B.N = 0 + ae, B.Ab = u, B.Cd = k, B.ea = V, B.W = 0 + ae + k, B.Db = u, B.Ed = k, l == 12 && (B.F = V, B.J = 0 + ae + 2 * k), B.Tc = I, B.lb = T);
          }
          if (u = 1, T = _.S, k = _.width, I = _.height, T >= n0 && 13 > T) {
            if (11 > T) l = _.f.RGBA, u &= (R = Math.abs(l.A)) * (I - 1) + k <= l.size, u &= R >= k * mh[T], u &= l.eb != null;
            else {
              l = _.f.kb, R = (k + 1) / 2, ae = (I + 1) / 2, B = Math.abs(l.fa), V = Math.abs(l.Ab);
              var me = Math.abs(l.Db), xe = Math.abs(l.lb), he = xe * (I - 1) + k;
              u &= B * (I - 1) + k <= l.Fd, u &= V * (ae - 1) + R <= l.Cd, u = (u &= me * (ae - 1) + R <= l.Ed) & B >= k & V >= R & me >= R, u &= l.y != null, u &= l.f != null, u &= l.ea != null, T == 12 && (u &= xe >= k, u &= he <= l.Tc, u &= l.F != null);
            }
          } else u = 0;
          l = u ? 0 : 2;
        }
      }
      return l != 0 || m != null && m.fd && (l = Ys(_)), l;
    }
    var Ir = 64, Ka = [0, 1, 3, 7, 15, 31, 63, 127, 255, 511, 1023, 2047, 4095, 8191, 16383, 32767, 65535, 131071, 262143, 524287, 1048575, 2097151, 4194303, 8388607, 16777215], Ja = 24, Za = 32, $s = 8, ln = [0, 0, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7];
    We("Predictor0", "PredictorAdd0"), M.Predictor0 = function() {
      return 4278190080;
    }, M.Predictor1 = function(l) {
      return l;
    }, M.Predictor2 = function(l, u, m) {
      return u[m + 0];
    }, M.Predictor3 = function(l, u, m) {
      return u[m + 1];
    }, M.Predictor4 = function(l, u, m) {
      return u[m - 1];
    }, M.Predictor5 = function(l, u, m) {
      return Je(Je(l, u[m + 1]), u[m + 0]);
    }, M.Predictor6 = function(l, u, m) {
      return Je(l, u[m - 1]);
    }, M.Predictor7 = function(l, u, m) {
      return Je(l, u[m + 0]);
    }, M.Predictor8 = function(l, u, m) {
      return Je(u[m - 1], u[m + 0]);
    }, M.Predictor9 = function(l, u, m) {
      return Je(u[m + 0], u[m + 1]);
    }, M.Predictor10 = function(l, u, m) {
      return Je(Je(l, u[m - 1]), Je(u[m + 0], u[m + 1]));
    }, M.Predictor11 = function(l, u, m) {
      var _ = u[m + 0];
      return 0 >= gt(_ >> 24 & 255, l >> 24 & 255, (u = u[m - 1]) >> 24 & 255) + gt(_ >> 16 & 255, l >> 16 & 255, u >> 16 & 255) + gt(_ >> 8 & 255, l >> 8 & 255, u >> 8 & 255) + gt(255 & _, 255 & l, 255 & u) ? _ : l;
    }, M.Predictor12 = function(l, u, m) {
      var _ = u[m + 0];
      return (st((l >> 24 & 255) + (_ >> 24 & 255) - ((u = u[m - 1]) >> 24 & 255)) << 24 | st((l >> 16 & 255) + (_ >> 16 & 255) - (u >> 16 & 255)) << 16 | st((l >> 8 & 255) + (_ >> 8 & 255) - (u >> 8 & 255)) << 8 | st((255 & l) + (255 & _) - (255 & u))) >>> 0;
    }, M.Predictor13 = function(l, u, m) {
      var _ = u[m - 1];
      return (ot((l = Je(l, u[m + 0])) >> 24 & 255, _ >> 24 & 255) << 24 | ot(l >> 16 & 255, _ >> 16 & 255) << 16 | ot(l >> 8 & 255, _ >> 8 & 255) << 8 | ot(l >> 0 & 255, _ >> 0 & 255)) >>> 0;
    };
    var kf = M.PredictorAdd0;
    M.PredictorAdd1 = _t, We("Predictor2", "PredictorAdd2"), We("Predictor3", "PredictorAdd3"), We("Predictor4", "PredictorAdd4"), We("Predictor5", "PredictorAdd5"), We("Predictor6", "PredictorAdd6"), We("Predictor7", "PredictorAdd7"), We("Predictor8", "PredictorAdd8"), We("Predictor9", "PredictorAdd9"), We("Predictor10", "PredictorAdd10"), We("Predictor11", "PredictorAdd11"), We("Predictor12", "PredictorAdd12"), We("Predictor13", "PredictorAdd13");
    var Ks = M.PredictorAdd2;
    At("ColorIndexInverseTransform", "MapARGB", "32b", function(l) {
      return l >> 8 & 255;
    }, function(l) {
      return l;
    }), At("VP8LColorIndexInverseTransformAlpha", "MapAlpha", "8b", function(l) {
      return l;
    }, function(l) {
      return l >> 8 & 255;
    });
    var Jo, Dn = M.ColorIndexInverseTransform, Qa = M.MapARGB, Zo = M.VP8LColorIndexInverseTransformAlpha, Qo = M.MapAlpha, Gi = M.VP8LPredictorsAdd = [];
    Gi.length = 16, (M.VP8LPredictors = []).length = 16, (M.VP8LPredictorsAdd_C = []).length = 16, (M.VP8LPredictors_C = []).length = 16;
    var wa, hn, Qr, Xi, Ti, Ei, es, Ni, ur, Js, en, On, ts, e0, Zs, ya, _a, Yi, Sa, rs, Aa, $i, Qs, In, Rn, Zt, Qt, dr, Er = a(511), Fi = a(2041), eo = a(225), ns = a(767), t0 = 0, Df = Fi, r0 = eo, _n = ns, Mn = Er, n0 = 0, i0 = 1, ah = 2, a0 = 3, s0 = 4, Of = 5, sh = 6, If = 7, Rf = 8, o0 = 9, Mf = 10, c2 = [2, 3, 7], u2 = [3, 3, 11], oh = [280, 256, 256, 256, 40], d2 = [0, 1, 1, 1, 0], p2 = [17, 18, 0, 1, 2, 3, 4, 5, 16, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15], g2 = [24, 7, 23, 25, 40, 6, 39, 41, 22, 26, 38, 42, 56, 5, 55, 57, 21, 27, 54, 58, 37, 43, 72, 4, 71, 73, 20, 28, 53, 59, 70, 74, 36, 44, 88, 69, 75, 52, 60, 3, 87, 89, 19, 29, 86, 90, 35, 45, 68, 76, 85, 91, 51, 61, 104, 2, 103, 105, 18, 30, 102, 106, 34, 46, 84, 92, 67, 77, 101, 107, 50, 62, 120, 1, 119, 121, 83, 93, 17, 31, 100, 108, 66, 78, 118, 122, 33, 47, 117, 123, 49, 63, 99, 109, 82, 94, 0, 116, 124, 65, 79, 16, 32, 98, 110, 48, 115, 125, 81, 95, 64, 114, 126, 97, 111, 80, 113, 127, 96, 112], v2 = [2954, 2956, 2958, 2962, 2970, 2986, 3018, 3082, 3212, 3468, 3980, 5004], m2 = 8, Bf = [4, 5, 6, 7, 8, 9, 10, 10, 11, 12, 13, 14, 15, 16, 17, 17, 18, 19, 20, 20, 21, 21, 22, 22, 23, 23, 24, 25, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 91, 93, 95, 96, 98, 100, 101, 102, 104, 106, 108, 110, 112, 114, 116, 118, 122, 124, 126, 128, 130, 132, 134, 136, 138, 140, 143, 145, 148, 151, 154, 157], jf = [4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 60, 62, 64, 66, 68, 70, 72, 74, 76, 78, 80, 82, 84, 86, 88, 90, 92, 94, 96, 98, 100, 102, 104, 106, 108, 110, 112, 114, 116, 119, 122, 125, 128, 131, 134, 137, 140, 143, 146, 149, 152, 155, 158, 161, 164, 167, 170, 173, 177, 181, 185, 189, 193, 197, 201, 205, 209, 213, 217, 221, 225, 229, 234, 239, 245, 249, 254, 259, 264, 269, 274, 279, 284], to = null, x2 = [[173, 148, 140, 0], [176, 155, 140, 135, 0], [180, 157, 141, 134, 130, 0], [254, 254, 243, 230, 196, 177, 153, 140, 133, 130, 129, 0]], w2 = [0, 1, 4, 8, 5, 2, 3, 6, 9, 12, 13, 10, 7, 11, 14, 15], fh = [-0, 1, -1, 2, -2, 3, 4, 6, -3, 5, -4, -5, -6, 7, -7, 8, -8, -9], y2 = [[[[128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128], [128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128], [128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128]], [[253, 136, 254, 255, 228, 219, 128, 128, 128, 128, 128], [189, 129, 242, 255, 227, 213, 255, 219, 128, 128, 128], [106, 126, 227, 252, 214, 209, 255, 255, 128, 128, 128]], [[1, 98, 248, 255, 236, 226, 255, 255, 128, 128, 128], [181, 133, 238, 254, 221, 234, 255, 154, 128, 128, 128], [78, 134, 202, 247, 198, 180, 255, 219, 128, 128, 128]], [[1, 185, 249, 255, 243, 255, 128, 128, 128, 128, 128], [184, 150, 247, 255, 236, 224, 128, 128, 128, 128, 128], [77, 110, 216, 255, 236, 230, 128, 128, 128, 128, 128]], [[1, 101, 251, 255, 241, 255, 128, 128, 128, 128, 128], [170, 139, 241, 252, 236, 209, 255, 255, 128, 128, 128], [37, 116, 196, 243, 228, 255, 255, 255, 128, 128, 128]], [[1, 204, 254, 255, 245, 255, 128, 128, 128, 128, 128], [207, 160, 250, 255, 238, 128, 128, 128, 128, 128, 128], [102, 103, 231, 255, 211, 171, 128, 128, 128, 128, 128]], [[1, 152, 252, 255, 240, 255, 128, 128, 128, 128, 128], [177, 135, 243, 255, 234, 225, 128, 128, 128, 128, 128], [80, 129, 211, 255, 194, 224, 128, 128, 128, 128, 128]], [[1, 1, 255, 128, 128, 128, 128, 128, 128, 128, 128], [246, 1, 255, 128, 128, 128, 128, 128, 128, 128, 128], [255, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128]]], [[[198, 35, 237, 223, 193, 187, 162, 160, 145, 155, 62], [131, 45, 198, 221, 172, 176, 220, 157, 252, 221, 1], [68, 47, 146, 208, 149, 167, 221, 162, 255, 223, 128]], [[1, 149, 241, 255, 221, 224, 255, 255, 128, 128, 128], [184, 141, 234, 253, 222, 220, 255, 199, 128, 128, 128], [81, 99, 181, 242, 176, 190, 249, 202, 255, 255, 128]], [[1, 129, 232, 253, 214, 197, 242, 196, 255, 255, 128], [99, 121, 210, 250, 201, 198, 255, 202, 128, 128, 128], [23, 91, 163, 242, 170, 187, 247, 210, 255, 255, 128]], [[1, 200, 246, 255, 234, 255, 128, 128, 128, 128, 128], [109, 178, 241, 255, 231, 245, 255, 255, 128, 128, 128], [44, 130, 201, 253, 205, 192, 255, 255, 128, 128, 128]], [[1, 132, 239, 251, 219, 209, 255, 165, 128, 128, 128], [94, 136, 225, 251, 218, 190, 255, 255, 128, 128, 128], [22, 100, 174, 245, 186, 161, 255, 199, 128, 128, 128]], [[1, 182, 249, 255, 232, 235, 128, 128, 128, 128, 128], [124, 143, 241, 255, 227, 234, 128, 128, 128, 128, 128], [35, 77, 181, 251, 193, 211, 255, 205, 128, 128, 128]], [[1, 157, 247, 255, 236, 231, 255, 255, 128, 128, 128], [121, 141, 235, 255, 225, 227, 255, 255, 128, 128, 128], [45, 99, 188, 251, 195, 217, 255, 224, 128, 128, 128]], [[1, 1, 251, 255, 213, 255, 128, 128, 128, 128, 128], [203, 1, 248, 255, 255, 128, 128, 128, 128, 128, 128], [137, 1, 177, 255, 224, 255, 128, 128, 128, 128, 128]]], [[[253, 9, 248, 251, 207, 208, 255, 192, 128, 128, 128], [175, 13, 224, 243, 193, 185, 249, 198, 255, 255, 128], [73, 17, 171, 221, 161, 179, 236, 167, 255, 234, 128]], [[1, 95, 247, 253, 212, 183, 255, 255, 128, 128, 128], [239, 90, 244, 250, 211, 209, 255, 255, 128, 128, 128], [155, 77, 195, 248, 188, 195, 255, 255, 128, 128, 128]], [[1, 24, 239, 251, 218, 219, 255, 205, 128, 128, 128], [201, 51, 219, 255, 196, 186, 128, 128, 128, 128, 128], [69, 46, 190, 239, 201, 218, 255, 228, 128, 128, 128]], [[1, 191, 251, 255, 255, 128, 128, 128, 128, 128, 128], [223, 165, 249, 255, 213, 255, 128, 128, 128, 128, 128], [141, 124, 248, 255, 255, 128, 128, 128, 128, 128, 128]], [[1, 16, 248, 255, 255, 128, 128, 128, 128, 128, 128], [190, 36, 230, 255, 236, 255, 128, 128, 128, 128, 128], [149, 1, 255, 128, 128, 128, 128, 128, 128, 128, 128]], [[1, 226, 255, 128, 128, 128, 128, 128, 128, 128, 128], [247, 192, 255, 128, 128, 128, 128, 128, 128, 128, 128], [240, 128, 255, 128, 128, 128, 128, 128, 128, 128, 128]], [[1, 134, 252, 255, 255, 128, 128, 128, 128, 128, 128], [213, 62, 250, 255, 255, 128, 128, 128, 128, 128, 128], [55, 93, 255, 128, 128, 128, 128, 128, 128, 128, 128]], [[128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128], [128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128], [128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128]]], [[[202, 24, 213, 235, 186, 191, 220, 160, 240, 175, 255], [126, 38, 182, 232, 169, 184, 228, 174, 255, 187, 128], [61, 46, 138, 219, 151, 178, 240, 170, 255, 216, 128]], [[1, 112, 230, 250, 199, 191, 247, 159, 255, 255, 128], [166, 109, 228, 252, 211, 215, 255, 174, 128, 128, 128], [39, 77, 162, 232, 172, 180, 245, 178, 255, 255, 128]], [[1, 52, 220, 246, 198, 199, 249, 220, 255, 255, 128], [124, 74, 191, 243, 183, 193, 250, 221, 255, 255, 128], [24, 71, 130, 219, 154, 170, 243, 182, 255, 255, 128]], [[1, 182, 225, 249, 219, 240, 255, 224, 128, 128, 128], [149, 150, 226, 252, 216, 205, 255, 171, 128, 128, 128], [28, 108, 170, 242, 183, 194, 254, 223, 255, 255, 128]], [[1, 81, 230, 252, 204, 203, 255, 192, 128, 128, 128], [123, 102, 209, 247, 188, 196, 255, 233, 128, 128, 128], [20, 95, 153, 243, 164, 173, 255, 203, 128, 128, 128]], [[1, 222, 248, 255, 216, 213, 128, 128, 128, 128, 128], [168, 175, 246, 252, 235, 205, 255, 255, 128, 128, 128], [47, 116, 215, 255, 211, 212, 255, 255, 128, 128, 128]], [[1, 121, 236, 253, 212, 214, 255, 255, 128, 128, 128], [141, 84, 213, 252, 201, 202, 255, 219, 128, 128, 128], [42, 80, 160, 240, 162, 185, 255, 205, 128, 128, 128]], [[1, 1, 255, 128, 128, 128, 128, 128, 128, 128, 128], [244, 1, 255, 128, 128, 128, 128, 128, 128, 128, 128], [238, 1, 255, 128, 128, 128, 128, 128, 128, 128, 128]]]], _2 = [[[231, 120, 48, 89, 115, 113, 120, 152, 112], [152, 179, 64, 126, 170, 118, 46, 70, 95], [175, 69, 143, 80, 85, 82, 72, 155, 103], [56, 58, 10, 171, 218, 189, 17, 13, 152], [114, 26, 17, 163, 44, 195, 21, 10, 173], [121, 24, 80, 195, 26, 62, 44, 64, 85], [144, 71, 10, 38, 171, 213, 144, 34, 26], [170, 46, 55, 19, 136, 160, 33, 206, 71], [63, 20, 8, 114, 114, 208, 12, 9, 226], [81, 40, 11, 96, 182, 84, 29, 16, 36]], [[134, 183, 89, 137, 98, 101, 106, 165, 148], [72, 187, 100, 130, 157, 111, 32, 75, 80], [66, 102, 167, 99, 74, 62, 40, 234, 128], [41, 53, 9, 178, 241, 141, 26, 8, 107], [74, 43, 26, 146, 73, 166, 49, 23, 157], [65, 38, 105, 160, 51, 52, 31, 115, 128], [104, 79, 12, 27, 217, 255, 87, 17, 7], [87, 68, 71, 44, 114, 51, 15, 186, 23], [47, 41, 14, 110, 182, 183, 21, 17, 194], [66, 45, 25, 102, 197, 189, 23, 18, 22]], [[88, 88, 147, 150, 42, 46, 45, 196, 205], [43, 97, 183, 117, 85, 38, 35, 179, 61], [39, 53, 200, 87, 26, 21, 43, 232, 171], [56, 34, 51, 104, 114, 102, 29, 93, 77], [39, 28, 85, 171, 58, 165, 90, 98, 64], [34, 22, 116, 206, 23, 34, 43, 166, 73], [107, 54, 32, 26, 51, 1, 81, 43, 31], [68, 25, 106, 22, 64, 171, 36, 225, 114], [34, 19, 21, 102, 132, 188, 16, 76, 124], [62, 18, 78, 95, 85, 57, 50, 48, 51]], [[193, 101, 35, 159, 215, 111, 89, 46, 111], [60, 148, 31, 172, 219, 228, 21, 18, 111], [112, 113, 77, 85, 179, 255, 38, 120, 114], [40, 42, 1, 196, 245, 209, 10, 25, 109], [88, 43, 29, 140, 166, 213, 37, 43, 154], [61, 63, 30, 155, 67, 45, 68, 1, 209], [100, 80, 8, 43, 154, 1, 51, 26, 71], [142, 78, 78, 16, 255, 128, 34, 197, 171], [41, 40, 5, 102, 211, 183, 4, 1, 221], [51, 50, 17, 168, 209, 192, 23, 25, 82]], [[138, 31, 36, 171, 27, 166, 38, 44, 229], [67, 87, 58, 169, 82, 115, 26, 59, 179], [63, 59, 90, 180, 59, 166, 93, 73, 154], [40, 40, 21, 116, 143, 209, 34, 39, 175], [47, 15, 16, 183, 34, 223, 49, 45, 183], [46, 17, 33, 183, 6, 98, 15, 32, 183], [57, 46, 22, 24, 128, 1, 54, 17, 37], [65, 32, 73, 115, 28, 128, 23, 128, 205], [40, 3, 9, 115, 51, 192, 18, 6, 223], [87, 37, 9, 115, 59, 77, 64, 21, 47]], [[104, 55, 44, 218, 9, 54, 53, 130, 226], [64, 90, 70, 205, 40, 41, 23, 26, 57], [54, 57, 112, 184, 5, 41, 38, 166, 213], [30, 34, 26, 133, 152, 116, 10, 32, 134], [39, 19, 53, 221, 26, 114, 32, 73, 255], [31, 9, 65, 234, 2, 15, 1, 118, 73], [75, 32, 12, 51, 192, 255, 160, 43, 51], [88, 31, 35, 67, 102, 85, 55, 186, 85], [56, 21, 23, 111, 59, 205, 45, 37, 192], [55, 38, 70, 124, 73, 102, 1, 34, 98]], [[125, 98, 42, 88, 104, 85, 117, 175, 82], [95, 84, 53, 89, 128, 100, 113, 101, 45], [75, 79, 123, 47, 51, 128, 81, 171, 1], [57, 17, 5, 71, 102, 57, 53, 41, 49], [38, 33, 13, 121, 57, 73, 26, 1, 85], [41, 10, 67, 138, 77, 110, 90, 47, 114], [115, 21, 2, 10, 102, 255, 166, 23, 6], [101, 29, 16, 10, 85, 128, 101, 196, 26], [57, 18, 10, 102, 102, 213, 34, 20, 43], [117, 20, 15, 36, 163, 128, 68, 1, 26]], [[102, 61, 71, 37, 34, 53, 31, 243, 192], [69, 60, 71, 38, 73, 119, 28, 222, 37], [68, 45, 128, 34, 1, 47, 11, 245, 171], [62, 17, 19, 70, 146, 85, 55, 62, 70], [37, 43, 37, 154, 100, 163, 85, 160, 1], [63, 9, 92, 136, 28, 64, 32, 201, 85], [75, 15, 9, 9, 64, 255, 184, 119, 16], [86, 6, 28, 5, 64, 255, 25, 248, 1], [56, 8, 17, 132, 137, 255, 55, 116, 128], [58, 15, 20, 82, 135, 57, 26, 121, 40]], [[164, 50, 31, 137, 154, 133, 25, 35, 218], [51, 103, 44, 131, 131, 123, 31, 6, 158], [86, 40, 64, 135, 148, 224, 45, 183, 128], [22, 26, 17, 131, 240, 154, 14, 1, 209], [45, 16, 21, 91, 64, 222, 7, 1, 197], [56, 21, 39, 155, 60, 138, 23, 102, 213], [83, 12, 13, 54, 192, 255, 68, 47, 28], [85, 26, 85, 85, 128, 128, 32, 146, 171], [18, 11, 7, 63, 144, 171, 4, 4, 246], [35, 27, 10, 146, 174, 171, 12, 26, 128]], [[190, 80, 35, 99, 180, 80, 126, 54, 45], [85, 126, 47, 87, 176, 51, 41, 20, 32], [101, 75, 128, 139, 118, 146, 116, 128, 85], [56, 41, 15, 176, 236, 85, 37, 9, 62], [71, 30, 17, 119, 118, 255, 17, 18, 138], [101, 38, 60, 138, 55, 70, 43, 26, 142], [146, 36, 19, 30, 171, 255, 97, 27, 20], [138, 45, 61, 62, 219, 1, 81, 188, 64], [32, 41, 20, 117, 151, 142, 20, 21, 163], [112, 19, 12, 61, 195, 128, 48, 4, 24]]], S2 = [[[[255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[176, 246, 255, 255, 255, 255, 255, 255, 255, 255, 255], [223, 241, 252, 255, 255, 255, 255, 255, 255, 255, 255], [249, 253, 253, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 244, 252, 255, 255, 255, 255, 255, 255, 255, 255], [234, 254, 254, 255, 255, 255, 255, 255, 255, 255, 255], [253, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 246, 254, 255, 255, 255, 255, 255, 255, 255, 255], [239, 253, 254, 255, 255, 255, 255, 255, 255, 255, 255], [254, 255, 254, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 248, 254, 255, 255, 255, 255, 255, 255, 255, 255], [251, 255, 254, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 253, 254, 255, 255, 255, 255, 255, 255, 255, 255], [251, 254, 254, 255, 255, 255, 255, 255, 255, 255, 255], [254, 255, 254, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 254, 253, 255, 254, 255, 255, 255, 255, 255, 255], [250, 255, 254, 255, 254, 255, 255, 255, 255, 255, 255], [254, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]]], [[[217, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [225, 252, 241, 253, 255, 255, 254, 255, 255, 255, 255], [234, 250, 241, 250, 253, 255, 253, 254, 255, 255, 255]], [[255, 254, 255, 255, 255, 255, 255, 255, 255, 255, 255], [223, 254, 254, 255, 255, 255, 255, 255, 255, 255, 255], [238, 253, 254, 254, 255, 255, 255, 255, 255, 255, 255]], [[255, 248, 254, 255, 255, 255, 255, 255, 255, 255, 255], [249, 254, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 253, 255, 255, 255, 255, 255, 255, 255, 255, 255], [247, 254, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 253, 254, 255, 255, 255, 255, 255, 255, 255, 255], [252, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 254, 254, 255, 255, 255, 255, 255, 255, 255, 255], [253, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 254, 253, 255, 255, 255, 255, 255, 255, 255, 255], [250, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [254, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]]], [[[186, 251, 250, 255, 255, 255, 255, 255, 255, 255, 255], [234, 251, 244, 254, 255, 255, 255, 255, 255, 255, 255], [251, 251, 243, 253, 254, 255, 254, 255, 255, 255, 255]], [[255, 253, 254, 255, 255, 255, 255, 255, 255, 255, 255], [236, 253, 254, 255, 255, 255, 255, 255, 255, 255, 255], [251, 253, 253, 254, 254, 255, 255, 255, 255, 255, 255]], [[255, 254, 254, 255, 255, 255, 255, 255, 255, 255, 255], [254, 254, 254, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 254, 255, 255, 255, 255, 255, 255, 255, 255, 255], [254, 254, 255, 255, 255, 255, 255, 255, 255, 255, 255], [254, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [254, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]]], [[[248, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [250, 254, 252, 254, 255, 255, 255, 255, 255, 255, 255], [248, 254, 249, 253, 255, 255, 255, 255, 255, 255, 255]], [[255, 253, 253, 255, 255, 255, 255, 255, 255, 255, 255], [246, 253, 253, 255, 255, 255, 255, 255, 255, 255, 255], [252, 254, 251, 254, 254, 255, 255, 255, 255, 255, 255]], [[255, 254, 252, 255, 255, 255, 255, 255, 255, 255, 255], [248, 254, 253, 255, 255, 255, 255, 255, 255, 255, 255], [253, 255, 254, 254, 255, 255, 255, 255, 255, 255, 255]], [[255, 251, 254, 255, 255, 255, 255, 255, 255, 255, 255], [245, 251, 254, 255, 255, 255, 255, 255, 255, 255, 255], [253, 253, 254, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 251, 253, 255, 255, 255, 255, 255, 255, 255, 255], [252, 253, 254, 255, 255, 255, 255, 255, 255, 255, 255], [255, 254, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 252, 255, 255, 255, 255, 255, 255, 255, 255, 255], [249, 255, 254, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 254, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 255, 253, 255, 255, 255, 255, 255, 255, 255, 255], [250, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [254, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]]]], A2 = [0, 1, 2, 3, 6, 4, 5, 6, 6, 6, 6, 6, 6, 6, 6, 7, 0], Ki = [], $n = [], Li = [], b2 = 1, lh = 2, Ji = [], Bn = [];
    Fe("UpsampleRgbLinePair", Lt, 3), Fe("UpsampleBgrLinePair", nr, 3), Fe("UpsampleRgbaLinePair", Yn, 4), Fe("UpsampleBgraLinePair", Fr, 4), Fe("UpsampleArgbLinePair", Vr, 4), Fe("UpsampleRgba4444LinePair", xr, 2), Fe("UpsampleRgb565LinePair", ar, 2);
    var T2 = M.UpsampleRgbLinePair, E2 = M.UpsampleBgrLinePair, hh = M.UpsampleRgbaLinePair, ch = M.UpsampleBgraLinePair, uh = M.UpsampleArgbLinePair, dh = M.UpsampleRgba4444LinePair, N2 = M.UpsampleRgb565LinePair, f0 = 16, l0 = 1 << f0 - 1, ro = -227, Uf = 482, ph = 6, F2 = (256 << ph) - 1, gh = 0, L2 = a(256), C2 = a(256), P2 = a(256), k2 = a(256), D2 = a(Uf - ro), O2 = a(Uf - ro);
    ui("YuvToRgbRow", Lt, 3), ui("YuvToBgrRow", nr, 3), ui("YuvToRgbaRow", Yn, 4), ui("YuvToBgraRow", Fr, 4), ui("YuvToArgbRow", Vr, 4), ui("YuvToRgba4444Row", xr, 2), ui("YuvToRgb565Row", ar, 2);
    var vh = [0, 4, 8, 12, 128, 132, 136, 140, 256, 260, 264, 268, 384, 388, 392, 396], h0 = [0, 2, 8], I2 = [8, 7, 6, 4, 4, 2, 2, 2, 1, 1, 1, 1], R2 = 1;
    this.WebPDecodeRGBA = function(l, u, m, _, T) {
      var k = i0, I = new Ga(), R = new mn();
      I.ba = R, R.S = k, R.width = [R.width], R.height = [R.height];
      var B = R.width, V = R.height, ae = new Wn();
      if (ae == null || l == null) var me = 2;
      else e(ae != null), me = Ya(l, u, m, ae.width, ae.height, ae.Pd, ae.Qd, ae.format, null);
      if (me != 0 ? B = 0 : (B != null && (B[0] = ae.width[0]), V != null && (V[0] = ae.height[0]), B = 1), B) {
        R.width = R.width[0], R.height = R.height[0], _ != null && (_[0] = R.width), T != null && (T[0] = R.height);
        e: {
          if (_ = new li(), (T = new qs()).data = l, T.w = u, T.ha = m, T.kd = 1, u = [0], e(T != null), ((l = Ya(T.data, T.w, T.ha, null, null, null, u, null, T)) == 0 || l == 7) && u[0] && (l = 4), (u = l) == 0) {
            if (e(I != null), _.data = T.data, _.w = T.w + T.offset, _.ha = T.ha - T.offset, _.put = Pn, _.ac = Tr, _.bc = kn, _.ma = I, T.xa) {
              if ((l = Ee()) == null) {
                I = 1;
                break e;
              }
              if (function(xe, he) {
                var De = [0], Ne = [0], oe = [0];
                t: for (; ; ) {
                  if (xe == null) return 0;
                  if (he == null) return xe.a = 2, 0;
                  if (xe.l = he, xe.a = 0, de(xe.m, he.data, he.w, he.ha), !lt(xe.m, De, Ne, oe)) {
                    xe.a = 3;
                    break t;
                  }
                  if (xe.xb = lh, he.width = De[0], he.height = Ne[0], !pe(De[0], Ne[0], 1, xe, null)) break t;
                  return 1;
                }
                return e(xe.a != 0), 0;
              }(l, _)) {
                if (_ = (u = $a(_.width, _.height, I.Oa, I.ba)) == 0) {
                  t: {
                    _ = l;
                    r: for (; ; ) {
                      if (_ == null) {
                        _ = 0;
                        break t;
                      }
                      if (e(_.s.yc != null), e(_.s.Ya != null), e(0 < _.s.Wb), e((m = _.l) != null), e((T = m.ma) != null), _.xb != 0) {
                        if (_.ca = T.ba, _.tb = T.tb, e(_.ca != null), !Xs(T.Oa, m, a0)) {
                          _.a = 2;
                          break r;
                        }
                        if (!ye(_, m.width) || m.da) break r;
                        if ((m.da || Ct(_.ca.S)) && ue(), 11 > _.ca.S || (alert("todo:WebPInitConvertARGBToYUV"), _.ca.f.kb.F != null && ue()), _.Pb && 0 < _.s.ua && _.s.vb.X == null && !Ye(_.s.vb, _.s.Wa.Xa)) {
                          _.a = 1;
                          break r;
                        }
                        _.xb = 0;
                      }
                      if (!K(_, _.V, _.Ba, _.c, _.i, m.o, X)) break r;
                      T.Dc = _.Ma, _ = 1;
                      break t;
                    }
                    e(_.a != 0), _ = 0;
                  }
                  _ = !_;
                }
                _ && (u = l.a);
              } else u = l.a;
            } else {
              if ((l = new wn()) == null) {
                I = 1;
                break e;
              }
              if (l.Fa = T.na, l.P = T.P, l.qc = T.Sa, Io(l, _)) {
                if ((u = $a(_.width, _.height, I.Oa, I.ba)) == 0) {
                  if (l.Aa = 0, m = I.Oa, e((T = l) != null), m != null) {
                    if (0 < (B = 0 > (B = m.Md) ? 0 : 100 < B ? 255 : 255 * B / 100)) {
                      for (V = ae = 0; 4 > V; ++V) 12 > (me = T.pb[V]).lc && (me.ia = B * I2[0 > me.lc ? 0 : me.lc] >> 3), ae |= me.ia;
                      ae && (alert("todo:VP8InitRandom"), T.ia = 1);
                    }
                    T.Ga = m.Id, 100 < T.Ga ? T.Ga = 100 : 0 > T.Ga && (T.Ga = 0);
                  }
                  pf(l, _) || (u = l.a);
                }
              } else u = l.a;
            }
            u == 0 && I.Oa != null && I.Oa.fd && (u = Ys(I.ba));
          }
          I = u;
        }
        k = I != 0 ? null : 11 > k ? R.f.RGBA.eb : R.f.kb.y;
      } else k = null;
      return k;
    };
    var mh = [3, 4, 3, 4, 4, 2, 2, 4, 4, 4, 2, 1, 1];
  };
  function h(M, H) {
    for (var ee = "", F = 0; F < 4; F++) ee += String.fromCharCode(M[H++]);
    return ee;
  }
  function c(M, H) {
    return (M[H + 0] << 0 | M[H + 1] << 8 | M[H + 2] << 16) >>> 0;
  }
  function p(M, H) {
    return (M[H + 0] << 0 | M[H + 1] << 8 | M[H + 2] << 16 | M[H + 3] << 24) >>> 0;
  }
  new f();
  var v = [0], d = [0], w = [], x = new f(), S = r6, A = function(M, H) {
    var ee = {}, F = 0, P = false, Y = 0, Q = 0;
    if (ee.frames = [], !/** @license
    * Copyright (c) 2017 Dominik Homberger
    Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:
    The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
    https://webpjs.appspot.com
    WebPRiffParser dominikhlbg@gmail.com
    */
    function(L, N, C, z) {
      for (var re = 0; re < z; re++) if (L[N + re] != C.charCodeAt(re)) return true;
      return false;
    }(M, H, "RIFF", 4)) {
      for (p(M, H += 4), H += 8; H < M.length; ) {
        var ce = h(M, H), we = p(M, H += 4);
        H += 4;
        var Se = we + (1 & we);
        switch (ce) {
          case "VP8 ":
          case "VP8L":
            ee.frames[F] === void 0 && (ee.frames[F] = {}), (be = ee.frames[F]).src_off = P ? Q : H - 8, be.src_size = Y + we + 8, F++, P && (P = false, Y = 0, Q = 0);
            break;
          case "VP8X":
            (be = ee.header = {}).feature_flags = M[H];
            var de = H + 4;
            be.canvas_width = 1 + c(M, de), de += 3, be.canvas_height = 1 + c(M, de), de += 3;
            break;
          case "ALPH":
            P = true, Y = Se + 8, Q = H - 8;
            break;
          case "ANIM":
            (be = ee.header).bgcolor = p(M, H), de = H + 4, be.loop_count = (ze = M)[(y = de) + 0] << 0 | ze[y + 1] << 8, de += 2;
            break;
          case "ANMF":
            var Ae, be;
            (be = ee.frames[F] = {}).offset_x = 2 * c(M, H), H += 3, be.offset_y = 2 * c(M, H), H += 3, be.width = 1 + c(M, H), H += 3, be.height = 1 + c(M, H), H += 3, be.duration = c(M, H), H += 3, Ae = M[H++], be.dispose = 1 & Ae, be.blend = Ae >> 1 & 1;
        }
        ce != "ANMF" && (H += Se);
      }
      var ze, y;
      return ee;
    }
  }(S, 0);
  A.response = S, A.rgbaoutput = true, A.dataurl = false;
  var b = A.header ? A.header : null, O = A.frames ? A.frames : null;
  if (b) {
    b.loop_counter = b.loop_count, v = [b.canvas_height], d = [b.canvas_width];
    for (var q = 0; q < O.length && O[q].blend != 0; q++) ;
  }
  var te = O[0], le = x.WebPDecodeRGBA(S, te.src_off, te.src_size, d, v);
  te.rgba = le, te.imgwidth = d[0], te.imgheight = v[0];
  for (var j = 0; j < d[0] * v[0] * 4; j++) w[j] = le[j];
  return this.width = d, this.height = v, this.data = w, this;
}
(function(r6) {
  var e = function() {
    return typeof Tl == "function";
  }, t = function(v, d, w, x) {
    var S = 4, A = s;
    switch (x) {
      case r6.image_compression.FAST:
        S = 1, A = a;
        break;
      case r6.image_compression.MEDIUM:
        S = 6, A = o;
        break;
      case r6.image_compression.SLOW:
        S = 9, A = f;
    }
    v = n(v, d, w, A);
    var b = Tl(v, {
      level: S
    });
    return r6.__addimage__.arrayBufferToBinaryString(b);
  }, n = function(v, d, w, x) {
    for (var S, A, b, O = v.length / d, q = new Uint8Array(v.length + O), te = c(), le = 0; le < O; le += 1) {
      if (b = le * d, S = v.subarray(b, b + d), x) q.set(x(S, w, A), b + le);
      else {
        for (var j, M = te.length, H = []; j < M; j += 1) H[j] = te[j](S, w, A);
        var ee = p(H.concat());
        q.set(H[ee], b + le);
      }
      A = S;
    }
    return q;
  }, i = function(v) {
    var d = Array.apply([], v);
    return d.unshift(0), d;
  }, a = function(v, d) {
    var w, x = [], S = v.length;
    x[0] = 1;
    for (var A = 0; A < S; A += 1) w = v[A - d] || 0, x[A + 1] = v[A] - w + 256 & 255;
    return x;
  }, s = function(v, d, w) {
    var x, S = [], A = v.length;
    S[0] = 2;
    for (var b = 0; b < A; b += 1) x = w && w[b] || 0, S[b + 1] = v[b] - x + 256 & 255;
    return S;
  }, o = function(v, d, w) {
    var x, S, A = [], b = v.length;
    A[0] = 3;
    for (var O = 0; O < b; O += 1) x = v[O - d] || 0, S = w && w[O] || 0, A[O + 1] = v[O] + 256 - (x + S >>> 1) & 255;
    return A;
  }, f = function(v, d, w) {
    var x, S, A, b, O = [], q = v.length;
    O[0] = 4;
    for (var te = 0; te < q; te += 1) x = v[te - d] || 0, S = w && w[te] || 0, A = w && w[te - d] || 0, b = h(x, S, A), O[te + 1] = v[te] - b + 256 & 255;
    return O;
  }, h = function(v, d, w) {
    if (v === d && d === w) return v;
    var x = Math.abs(d - w), S = Math.abs(v - w), A = Math.abs(v + d - w - w);
    return x <= S && x <= A ? v : S <= A ? d : w;
  }, c = function() {
    return [i, a, s, o, f];
  }, p = function(v) {
    var d = v.map(function(w) {
      return w.reduce(function(x, S) {
        return x + Math.abs(S);
      }, 0);
    });
    return d.indexOf(Math.min.apply(null, d));
  };
  r6.processPNG = function(v, d, w, x) {
    var S, A, b, O, q, te, le, j, M, H, ee, F, P, Y, Q, ce = this.decode.FLATE_DECODE, we = "";
    if (this.__addimage__.isArrayBuffer(v) && (v = new Uint8Array(v)), this.__addimage__.isArrayBufferView(v)) {
      if (v = (b = new y3(v)).imgData, A = b.bits, S = b.colorSpace, q = b.colors, [4, 6].indexOf(b.colorType) !== -1) {
        if (b.bits === 8) {
          M = (j = b.pixelBitlength == 32 ? new Uint32Array(b.decodePixels().buffer) : b.pixelBitlength == 16 ? new Uint16Array(b.decodePixels().buffer) : new Uint8Array(b.decodePixels().buffer)).length, ee = new Uint8Array(M * b.colors), H = new Uint8Array(M);
          var Se, de = b.pixelBitlength - b.bits;
          for (Y = 0, Q = 0; Y < M; Y++) {
            for (P = j[Y], Se = 0; Se < de; ) ee[Q++] = P >>> Se & 255, Se += b.bits;
            H[Y] = P >>> Se & 255;
          }
        }
        if (b.bits === 16) {
          M = (j = new Uint32Array(b.decodePixels().buffer)).length, ee = new Uint8Array(M * (32 / b.pixelBitlength) * b.colors), H = new Uint8Array(M * (32 / b.pixelBitlength)), F = b.colors > 1, Y = 0, Q = 0;
          for (var Ae = 0; Y < M; ) P = j[Y++], ee[Q++] = P >>> 0 & 255, F && (ee[Q++] = P >>> 16 & 255, P = j[Y++], ee[Q++] = P >>> 0 & 255), H[Ae++] = P >>> 16 & 255;
          A = 8;
        }
        x !== r6.image_compression.NONE && e() ? (v = t(ee, b.width * b.colors, b.colors, x), le = t(H, b.width, 1, x)) : (v = ee, le = H, ce = void 0);
      }
      if (b.colorType === 3 && (S = this.color_spaces.INDEXED, te = b.palette, b.transparency.indexed)) {
        var be = b.transparency.indexed, ze = 0;
        for (Y = 0, M = be.length; Y < M; ++Y) ze += be[Y];
        if ((ze /= 255) === M - 1 && be.indexOf(0) !== -1) O = [be.indexOf(0)];
        else if (ze !== M) {
          for (j = b.decodePixels(), H = new Uint8Array(j.length), Y = 0, M = j.length; Y < M; Y++) H[Y] = be[j[Y]];
          le = t(H, b.width, 1);
        }
      }
      var y = function(L) {
        var N;
        switch (L) {
          case r6.image_compression.FAST:
            N = 11;
            break;
          case r6.image_compression.MEDIUM:
            N = 13;
            break;
          case r6.image_compression.SLOW:
            N = 14;
            break;
          default:
            N = 12;
        }
        return N;
      }(x);
      return ce === this.decode.FLATE_DECODE && (we = "/Predictor " + y + " "), we += "/Colors " + q + " /BitsPerComponent " + A + " /Columns " + b.width, (this.__addimage__.isArrayBuffer(v) || this.__addimage__.isArrayBufferView(v)) && (v = this.__addimage__.arrayBufferToBinaryString(v)), (le && this.__addimage__.isArrayBuffer(le) || this.__addimage__.isArrayBufferView(le)) && (le = this.__addimage__.arrayBufferToBinaryString(le)), {
        alias: w,
        data: v,
        index: d,
        filter: ce,
        decodeParameters: we,
        transparency: O,
        palette: te,
        sMask: le,
        predictor: y,
        width: b.width,
        height: b.height,
        bitsPerComponent: A,
        colorSpace: S
      };
    }
  };
})(ut.API), function(r6) {
  r6.processGIF89A = function(e, t, n, i) {
    var a = new _3(e), s = a.width, o = a.height, f = [];
    a.decodeAndBlitFrameRGBA(0, f);
    var h = {
      data: f,
      width: s,
      height: o
    }, c = new ul(100).encode(h, 100);
    return r6.processJPEG.call(this, c, t, n, i);
  }, r6.processGIF87A = r6.processGIF89A;
}(ut.API), ei.prototype.parseHeader = function() {
  if (this.fileSize = this.datav.getUint32(this.pos, true), this.pos += 4, this.reserved = this.datav.getUint32(this.pos, true), this.pos += 4, this.offset = this.datav.getUint32(this.pos, true), this.pos += 4, this.headerSize = this.datav.getUint32(this.pos, true), this.pos += 4, this.width = this.datav.getUint32(this.pos, true), this.pos += 4, this.height = this.datav.getInt32(this.pos, true), this.pos += 4, this.planes = this.datav.getUint16(this.pos, true), this.pos += 2, this.bitPP = this.datav.getUint16(this.pos, true), this.pos += 2, this.compress = this.datav.getUint32(this.pos, true), this.pos += 4, this.rawSize = this.datav.getUint32(this.pos, true), this.pos += 4, this.hr = this.datav.getUint32(this.pos, true), this.pos += 4, this.vr = this.datav.getUint32(this.pos, true), this.pos += 4, this.colors = this.datav.getUint32(this.pos, true), this.pos += 4, this.importantColors = this.datav.getUint32(this.pos, true), this.pos += 4, this.bitPP === 16 && this.is_with_alpha && (this.bitPP = 15), this.bitPP < 15) {
    var r6 = this.colors === 0 ? 1 << this.bitPP : this.colors;
    this.palette = new Array(r6);
    for (var e = 0; e < r6; e++) {
      var t = this.datav.getUint8(this.pos++, true), n = this.datav.getUint8(this.pos++, true), i = this.datav.getUint8(this.pos++, true), a = this.datav.getUint8(this.pos++, true);
      this.palette[e] = {
        red: i,
        green: n,
        blue: t,
        quad: a
      };
    }
  }
  this.height < 0 && (this.height *= -1, this.bottom_up = false);
}, ei.prototype.parseBGR = function() {
  this.pos = this.offset;
  try {
    var r6 = "bit" + this.bitPP, e = this.width * this.height * 4;
    this.data = new Uint8Array(e), this[r6]();
  } catch (t) {
    Kt.log("bit decode error:" + t);
  }
}, ei.prototype.bit1 = function() {
  var r6, e = Math.ceil(this.width / 8), t = e % 4;
  for (r6 = this.height - 1; r6 >= 0; r6--) {
    for (var n = this.bottom_up ? r6 : this.height - 1 - r6, i = 0; i < e; i++) for (var a = this.datav.getUint8(this.pos++, true), s = n * this.width * 4 + 8 * i * 4, o = 0; o < 8 && 8 * i + o < this.width; o++) {
      var f = this.palette[a >> 7 - o & 1];
      this.data[s + 4 * o] = f.blue, this.data[s + 4 * o + 1] = f.green, this.data[s + 4 * o + 2] = f.red, this.data[s + 4 * o + 3] = 255;
    }
    t !== 0 && (this.pos += 4 - t);
  }
}, ei.prototype.bit4 = function() {
  for (var r6 = Math.ceil(this.width / 2), e = r6 % 4, t = this.height - 1; t >= 0; t--) {
    for (var n = this.bottom_up ? t : this.height - 1 - t, i = 0; i < r6; i++) {
      var a = this.datav.getUint8(this.pos++, true), s = n * this.width * 4 + 2 * i * 4, o = a >> 4, f = 15 & a, h = this.palette[o];
      if (this.data[s] = h.blue, this.data[s + 1] = h.green, this.data[s + 2] = h.red, this.data[s + 3] = 255, 2 * i + 1 >= this.width) break;
      h = this.palette[f], this.data[s + 4] = h.blue, this.data[s + 4 + 1] = h.green, this.data[s + 4 + 2] = h.red, this.data[s + 4 + 3] = 255;
    }
    e !== 0 && (this.pos += 4 - e);
  }
}, ei.prototype.bit8 = function() {
  for (var r6 = this.width % 4, e = this.height - 1; e >= 0; e--) {
    for (var t = this.bottom_up ? e : this.height - 1 - e, n = 0; n < this.width; n++) {
      var i = this.datav.getUint8(this.pos++, true), a = t * this.width * 4 + 4 * n;
      if (i < this.palette.length) {
        var s = this.palette[i];
        this.data[a] = s.red, this.data[a + 1] = s.green, this.data[a + 2] = s.blue, this.data[a + 3] = 255;
      } else this.data[a] = 255, this.data[a + 1] = 255, this.data[a + 2] = 255, this.data[a + 3] = 255;
    }
    r6 !== 0 && (this.pos += 4 - r6);
  }
}, ei.prototype.bit15 = function() {
  for (var r6 = this.width % 3, e = parseInt("11111", 2), t = this.height - 1; t >= 0; t--) {
    for (var n = this.bottom_up ? t : this.height - 1 - t, i = 0; i < this.width; i++) {
      var a = this.datav.getUint16(this.pos, true);
      this.pos += 2;
      var s = (a & e) / e * 255 | 0, o = (a >> 5 & e) / e * 255 | 0, f = (a >> 10 & e) / e * 255 | 0, h = a >> 15 ? 255 : 0, c = n * this.width * 4 + 4 * i;
      this.data[c] = f, this.data[c + 1] = o, this.data[c + 2] = s, this.data[c + 3] = h;
    }
    this.pos += r6;
  }
}, ei.prototype.bit16 = function() {
  for (var r6 = this.width % 3, e = parseInt("11111", 2), t = parseInt("111111", 2), n = this.height - 1; n >= 0; n--) {
    for (var i = this.bottom_up ? n : this.height - 1 - n, a = 0; a < this.width; a++) {
      var s = this.datav.getUint16(this.pos, true);
      this.pos += 2;
      var o = (s & e) / e * 255 | 0, f = (s >> 5 & t) / t * 255 | 0, h = (s >> 11) / e * 255 | 0, c = i * this.width * 4 + 4 * a;
      this.data[c] = h, this.data[c + 1] = f, this.data[c + 2] = o, this.data[c + 3] = 255;
    }
    this.pos += r6;
  }
}, ei.prototype.bit24 = function() {
  for (var r6 = this.height - 1; r6 >= 0; r6--) {
    for (var e = this.bottom_up ? r6 : this.height - 1 - r6, t = 0; t < this.width; t++) {
      var n = this.datav.getUint8(this.pos++, true), i = this.datav.getUint8(this.pos++, true), a = this.datav.getUint8(this.pos++, true), s = e * this.width * 4 + 4 * t;
      this.data[s] = a, this.data[s + 1] = i, this.data[s + 2] = n, this.data[s + 3] = 255;
    }
    this.pos += this.width % 4;
  }
}, ei.prototype.bit32 = function() {
  for (var r6 = this.height - 1; r6 >= 0; r6--) for (var e = this.bottom_up ? r6 : this.height - 1 - r6, t = 0; t < this.width; t++) {
    var n = this.datav.getUint8(this.pos++, true), i = this.datav.getUint8(this.pos++, true), a = this.datav.getUint8(this.pos++, true), s = this.datav.getUint8(this.pos++, true), o = e * this.width * 4 + 4 * t;
    this.data[o] = a, this.data[o + 1] = i, this.data[o + 2] = n, this.data[o + 3] = s;
  }
}, ei.prototype.getData = function() {
  return this.data;
}, /**
* @license
* Copyright (c) 2018 Aras Abbasi
*
* Licensed under the MIT License.
* http://opensource.org/licenses/mit-license
*/
function(r6) {
  r6.processBMP = function(e, t, n, i) {
    var a = new ei(e, false), s = a.width, o = a.height, f = {
      data: a.getData(),
      width: s,
      height: o
    }, h = new ul(100).encode(f, 100);
    return r6.processJPEG.call(this, h, t, n, i);
  };
}(ut.API), jc.prototype.getData = function() {
  return this.data;
}, /**
* @license
* Copyright (c) 2019 Aras Abbasi
*
* Licensed under the MIT License.
* http://opensource.org/licenses/mit-license
*/
function(r6) {
  r6.processWEBP = function(e, t, n, i) {
    var a = new jc(e), s = a.width, o = a.height, f = {
      data: a.getData(),
      width: s,
      height: o
    }, h = new ul(100).encode(f, 100);
    return r6.processJPEG.call(this, h, t, n, i);
  };
}(ut.API), ut.API.processRGBA = function(r6, e, t) {
  for (var n = r6.data, i = n.length, a = new Uint8Array(i / 4 * 3), s = new Uint8Array(i / 4), o = 0, f = 0, h = 0; h < i; h += 4) {
    var c = n[h], p = n[h + 1], v = n[h + 2], d = n[h + 3];
    a[o++] = c, a[o++] = p, a[o++] = v, s[f++] = d;
  }
  var w = this.__addimage__.arrayBufferToBinaryString(a);
  return {
    alpha: this.__addimage__.arrayBufferToBinaryString(s),
    data: w,
    index: e,
    alias: t,
    colorSpace: "DeviceRGB",
    bitsPerComponent: 8,
    width: r6.width,
    height: r6.height
  };
}, ut.API.setLanguage = function(r6) {
  return this.internal.languageSettings === void 0 && (this.internal.languageSettings = {}, this.internal.languageSettings.isSubscribed = false), {
    af: "Afrikaans",
    sq: "Albanian",
    ar: "Arabic (Standard)",
    "ar-DZ": "Arabic (Algeria)",
    "ar-BH": "Arabic (Bahrain)",
    "ar-EG": "Arabic (Egypt)",
    "ar-IQ": "Arabic (Iraq)",
    "ar-JO": "Arabic (Jordan)",
    "ar-KW": "Arabic (Kuwait)",
    "ar-LB": "Arabic (Lebanon)",
    "ar-LY": "Arabic (Libya)",
    "ar-MA": "Arabic (Morocco)",
    "ar-OM": "Arabic (Oman)",
    "ar-QA": "Arabic (Qatar)",
    "ar-SA": "Arabic (Saudi Arabia)",
    "ar-SY": "Arabic (Syria)",
    "ar-TN": "Arabic (Tunisia)",
    "ar-AE": "Arabic (U.A.E.)",
    "ar-YE": "Arabic (Yemen)",
    an: "Aragonese",
    hy: "Armenian",
    as: "Assamese",
    ast: "Asturian",
    az: "Azerbaijani",
    eu: "Basque",
    be: "Belarusian",
    bn: "Bengali",
    bs: "Bosnian",
    br: "Breton",
    bg: "Bulgarian",
    my: "Burmese",
    ca: "Catalan",
    ch: "Chamorro",
    ce: "Chechen",
    zh: "Chinese",
    "zh-HK": "Chinese (Hong Kong)",
    "zh-CN": "Chinese (PRC)",
    "zh-SG": "Chinese (Singapore)",
    "zh-TW": "Chinese (Taiwan)",
    cv: "Chuvash",
    co: "Corsican",
    cr: "Cree",
    hr: "Croatian",
    cs: "Czech",
    da: "Danish",
    nl: "Dutch (Standard)",
    "nl-BE": "Dutch (Belgian)",
    en: "English",
    "en-AU": "English (Australia)",
    "en-BZ": "English (Belize)",
    "en-CA": "English (Canada)",
    "en-IE": "English (Ireland)",
    "en-JM": "English (Jamaica)",
    "en-NZ": "English (New Zealand)",
    "en-PH": "English (Philippines)",
    "en-ZA": "English (South Africa)",
    "en-TT": "English (Trinidad & Tobago)",
    "en-GB": "English (United Kingdom)",
    "en-US": "English (United States)",
    "en-ZW": "English (Zimbabwe)",
    eo: "Esperanto",
    et: "Estonian",
    fo: "Faeroese",
    fj: "Fijian",
    fi: "Finnish",
    fr: "French (Standard)",
    "fr-BE": "French (Belgium)",
    "fr-CA": "French (Canada)",
    "fr-FR": "French (France)",
    "fr-LU": "French (Luxembourg)",
    "fr-MC": "French (Monaco)",
    "fr-CH": "French (Switzerland)",
    fy: "Frisian",
    fur: "Friulian",
    gd: "Gaelic (Scots)",
    "gd-IE": "Gaelic (Irish)",
    gl: "Galacian",
    ka: "Georgian",
    de: "German (Standard)",
    "de-AT": "German (Austria)",
    "de-DE": "German (Germany)",
    "de-LI": "German (Liechtenstein)",
    "de-LU": "German (Luxembourg)",
    "de-CH": "German (Switzerland)",
    el: "Greek",
    gu: "Gujurati",
    ht: "Haitian",
    he: "Hebrew",
    hi: "Hindi",
    hu: "Hungarian",
    is: "Icelandic",
    id: "Indonesian",
    iu: "Inuktitut",
    ga: "Irish",
    it: "Italian (Standard)",
    "it-CH": "Italian (Switzerland)",
    ja: "Japanese",
    kn: "Kannada",
    ks: "Kashmiri",
    kk: "Kazakh",
    km: "Khmer",
    ky: "Kirghiz",
    tlh: "Klingon",
    ko: "Korean",
    "ko-KP": "Korean (North Korea)",
    "ko-KR": "Korean (South Korea)",
    la: "Latin",
    lv: "Latvian",
    lt: "Lithuanian",
    lb: "Luxembourgish",
    mk: "North Macedonia",
    ms: "Malay",
    ml: "Malayalam",
    mt: "Maltese",
    mi: "Maori",
    mr: "Marathi",
    mo: "Moldavian",
    nv: "Navajo",
    ng: "Ndonga",
    ne: "Nepali",
    no: "Norwegian",
    nb: "Norwegian (Bokmal)",
    nn: "Norwegian (Nynorsk)",
    oc: "Occitan",
    or: "Oriya",
    om: "Oromo",
    fa: "Persian",
    "fa-IR": "Persian/Iran",
    pl: "Polish",
    pt: "Portuguese",
    "pt-BR": "Portuguese (Brazil)",
    pa: "Punjabi",
    "pa-IN": "Punjabi (India)",
    "pa-PK": "Punjabi (Pakistan)",
    qu: "Quechua",
    rm: "Rhaeto-Romanic",
    ro: "Romanian",
    "ro-MO": "Romanian (Moldavia)",
    ru: "Russian",
    "ru-MO": "Russian (Moldavia)",
    sz: "Sami (Lappish)",
    sg: "Sango",
    sa: "Sanskrit",
    sc: "Sardinian",
    sd: "Sindhi",
    si: "Singhalese",
    sr: "Serbian",
    sk: "Slovak",
    sl: "Slovenian",
    so: "Somani",
    sb: "Sorbian",
    es: "Spanish",
    "es-AR": "Spanish (Argentina)",
    "es-BO": "Spanish (Bolivia)",
    "es-CL": "Spanish (Chile)",
    "es-CO": "Spanish (Colombia)",
    "es-CR": "Spanish (Costa Rica)",
    "es-DO": "Spanish (Dominican Republic)",
    "es-EC": "Spanish (Ecuador)",
    "es-SV": "Spanish (El Salvador)",
    "es-GT": "Spanish (Guatemala)",
    "es-HN": "Spanish (Honduras)",
    "es-MX": "Spanish (Mexico)",
    "es-NI": "Spanish (Nicaragua)",
    "es-PA": "Spanish (Panama)",
    "es-PY": "Spanish (Paraguay)",
    "es-PE": "Spanish (Peru)",
    "es-PR": "Spanish (Puerto Rico)",
    "es-ES": "Spanish (Spain)",
    "es-UY": "Spanish (Uruguay)",
    "es-VE": "Spanish (Venezuela)",
    sx: "Sutu",
    sw: "Swahili",
    sv: "Swedish",
    "sv-FI": "Swedish (Finland)",
    "sv-SV": "Swedish (Sweden)",
    ta: "Tamil",
    tt: "Tatar",
    te: "Teluga",
    th: "Thai",
    tig: "Tigre",
    ts: "Tsonga",
    tn: "Tswana",
    tr: "Turkish",
    tk: "Turkmen",
    uk: "Ukrainian",
    hsb: "Upper Sorbian",
    ur: "Urdu",
    ve: "Venda",
    vi: "Vietnamese",
    vo: "Volapuk",
    wa: "Walloon",
    cy: "Welsh",
    xh: "Xhosa",
    ji: "Yiddish",
    zu: "Zulu"
  }[r6] !== void 0 && (this.internal.languageSettings.languageCode = r6, this.internal.languageSettings.isSubscribed === false && (this.internal.events.subscribe("putCatalog", function() {
    this.internal.write("/Lang (" + this.internal.languageSettings.languageCode + ")");
  }), this.internal.languageSettings.isSubscribed = true)), this;
}, us = ut.API, k0 = us.getCharWidthsArray = function(r6, e) {
  var t, n, i = (e = e || {}).font || this.internal.getFont(), a = e.fontSize || this.internal.getFontSize(), s = e.charSpace || this.internal.getCharSpace(), o = e.widths ? e.widths : i.metadata.Unicode.widths, f = o.fof ? o.fof : 1, h = e.kerning ? e.kerning : i.metadata.Unicode.kerning, c = h.fof ? h.fof : 1, p = e.doKerning !== false, v = 0, d = r6.length, w = 0, x = o[0] || f, S = [];
  for (t = 0; t < d; t++) n = r6.charCodeAt(t), typeof i.metadata.widthOfString == "function" ? S.push((i.metadata.widthOfGlyph(i.metadata.characterToGlyph(n)) + s * (1e3 / a) || 0) / 1e3) : (v = p && Wt(h[n]) === "object" && !isNaN(parseInt(h[n][w], 10)) ? h[n][w] / c : 0, S.push((o[n] || x) / f + v)), w = n;
  return S;
}, Ic = us.getStringUnitWidth = function(r6, e) {
  var t = (e = e || {}).fontSize || this.internal.getFontSize(), n = e.font || this.internal.getFont(), i = e.charSpace || this.internal.getCharSpace();
  return us.processArabic && (r6 = us.processArabic(r6)), typeof n.metadata.widthOfString == "function" ? n.metadata.widthOfString(r6, t, i) / t : k0.apply(this, arguments).reduce(function(a, s) {
    return a + s;
  }, 0);
}, Rc = function(r6, e, t, n) {
  for (var i = [], a = 0, s = r6.length, o = 0; a !== s && o + e[a] < t; ) o += e[a], a++;
  i.push(r6.slice(0, a));
  var f = a;
  for (o = 0; a !== s; ) o + e[a] > n && (i.push(r6.slice(f, a)), o = 0, f = a), o += e[a], a++;
  return f !== a && i.push(r6.slice(f, a)), i;
}, Mc = function(r6, e, t) {
  t || (t = {});
  var n, i, a, s, o, f, h, c = [], p = [c], v = t.textIndent || 0, d = 0, w = 0, x = r6.split(" "), S = k0.apply(this, [" ", t])[0];
  if (f = t.lineIndent === -1 ? x[0].length + 2 : t.lineIndent || 0) {
    var A = Array(f).join(" "), b = [];
    x.map(function(q) {
      (q = q.split(/\s*\n/)).length > 1 ? b = b.concat(q.map(function(te, le) {
        return (le && te.length ? `
` : "") + te;
      })) : b.push(q[0]);
    }), x = b, f = Ic.apply(this, [A, t]);
  }
  for (a = 0, s = x.length; a < s; a++) {
    var O = 0;
    if (n = x[a], f && n[0] == `
` && (n = n.substr(1), O = 1), v + d + (w = (i = k0.apply(this, [n, t])).reduce(function(q, te) {
      return q + te;
    }, 0)) > e || O) {
      if (w > e) {
        for (o = Rc.apply(this, [n, i, e - (v + d), e]), c.push(o.shift()), c = [o.pop()]; o.length; ) p.push([o.shift()]);
        w = i.slice(n.length - (c[0] ? c[0].length : 0)).reduce(function(q, te) {
          return q + te;
        }, 0);
      } else c = [n];
      p.push(c), v = w + f, d = S;
    } else c.push(n), v += d + w, d = S;
  }
  return h = f ? function(q, te) {
    return (te ? A : "") + q.join(" ");
  } : function(q) {
    return q.join(" ");
  }, p.map(h);
}, us.splitTextToSize = function(r6, e, t) {
  var n, i = (t = t || {}).fontSize || this.internal.getFontSize(), a = function(c) {
    if (c.widths && c.kerning) return {
      widths: c.widths,
      kerning: c.kerning
    };
    var p = this.internal.getFont(c.fontName, c.fontStyle);
    return p.metadata.Unicode ? {
      widths: p.metadata.Unicode.widths || {
        0: 1
      },
      kerning: p.metadata.Unicode.kerning || {}
    } : {
      font: p.metadata,
      fontSize: this.internal.getFontSize(),
      charSpace: this.internal.getCharSpace()
    };
  }.call(this, t);
  n = Array.isArray(r6) ? r6 : String(r6).split(/\r?\n/);
  var s = 1 * this.internal.scaleFactor * e / i;
  a.textIndent = t.textIndent ? 1 * t.textIndent * this.internal.scaleFactor / i : 0, a.lineIndent = t.lineIndent;
  var o, f, h = [];
  for (o = 0, f = n.length; o < f; o++) h = h.concat(Mc.apply(this, [n[o], s, a]));
  return h;
}, function(r6) {
  r6.__fontmetrics__ = r6.__fontmetrics__ || {};
  for (var e = "klmnopqrstuvwxyz", t = {}, n = {}, i = 0; i < e.length; i++) t[e[i]] = "0123456789abcdef"[i], n["0123456789abcdef"[i]] = e[i];
  var a = function(p) {
    return "0x" + parseInt(p, 10).toString(16);
  }, s = r6.__fontmetrics__.compress = function(p) {
    var v, d, w, x, S = ["{"];
    for (var A in p) {
      if (v = p[A], isNaN(parseInt(A, 10)) ? d = "'" + A + "'" : (A = parseInt(A, 10), d = (d = a(A).slice(2)).slice(0, -1) + n[d.slice(-1)]), typeof v == "number") v < 0 ? (w = a(v).slice(3), x = "-") : (w = a(v).slice(2), x = ""), w = x + w.slice(0, -1) + n[w.slice(-1)];
      else {
        if (Wt(v) !== "object") throw new Error("Don't know what to do with value type " + Wt(v) + ".");
        w = s(v);
      }
      S.push(d + w);
    }
    return S.push("}"), S.join("");
  }, o = r6.__fontmetrics__.uncompress = function(p) {
    if (typeof p != "string") throw new Error("Invalid argument passed to uncompress.");
    for (var v, d, w, x, S = {}, A = 1, b = S, O = [], q = "", te = "", le = p.length - 1, j = 1; j < le; j += 1) (x = p[j]) == "'" ? v ? (w = v.join(""), v = void 0) : v = [] : v ? v.push(x) : x == "{" ? (O.push([b, w]), b = {}, w = void 0) : x == "}" ? ((d = O.pop())[0][d[1]] = b, w = void 0, b = d[0]) : x == "-" ? A = -1 : w === void 0 ? t.hasOwnProperty(x) ? (q += t[x], w = parseInt(q, 16) * A, A = 1, q = "") : q += x : t.hasOwnProperty(x) ? (te += t[x], b[w] = parseInt(te, 16) * A, A = 1, w = void 0, te = "") : te += x;
    return S;
  }, f = {
    codePages: ["WinAnsiEncoding"],
    WinAnsiEncoding: o("{19m8n201n9q201o9r201s9l201t9m201u8m201w9n201x9o201y8o202k8q202l8r202m9p202q8p20aw8k203k8t203t8v203u9v2cq8s212m9t15m8w15n9w2dw9s16k8u16l9u17s9z17x8y17y9y}")
  }, h = {
    Unicode: {
      Courier: f,
      "Courier-Bold": f,
      "Courier-BoldOblique": f,
      "Courier-Oblique": f,
      Helvetica: f,
      "Helvetica-Bold": f,
      "Helvetica-BoldOblique": f,
      "Helvetica-Oblique": f,
      "Times-Roman": f,
      "Times-Bold": f,
      "Times-BoldItalic": f,
      "Times-Italic": f
    }
  }, c = {
    Unicode: {
      "Courier-Oblique": o("{'widths'{k3w'fof'6o}'kerning'{'fof'-6o}}"),
      "Times-BoldItalic": o("{'widths'{k3o2q4ycx2r201n3m201o6o201s2l201t2l201u2l201w3m201x3m201y3m2k1t2l2r202m2n2n3m2o3m2p5n202q6o2r1w2s2l2t2l2u3m2v3t2w1t2x2l2y1t2z1w3k3m3l3m3m3m3n3m3o3m3p3m3q3m3r3m3s3m203t2l203u2l3v2l3w3t3x3t3y3t3z3m4k5n4l4m4m4m4n4m4o4s4p4m4q4m4r4s4s4y4t2r4u3m4v4m4w3x4x5t4y4s4z4s5k3x5l4s5m4m5n3r5o3x5p4s5q4m5r5t5s4m5t3x5u3x5v2l5w1w5x2l5y3t5z3m6k2l6l3m6m3m6n2w6o3m6p2w6q2l6r3m6s3r6t1w6u1w6v3m6w1w6x4y6y3r6z3m7k3m7l3m7m2r7n2r7o1w7p3r7q2w7r4m7s3m7t2w7u2r7v2n7w1q7x2n7y3t202l3mcl4mal2ram3man3mao3map3mar3mas2lat4uau1uav3maw3way4uaz2lbk2sbl3t'fof'6obo2lbp3tbq3mbr1tbs2lbu1ybv3mbz3mck4m202k3mcm4mcn4mco4mcp4mcq5ycr4mcs4mct4mcu4mcv4mcw2r2m3rcy2rcz2rdl4sdm4sdn4sdo4sdp4sdq4sds4sdt4sdu4sdv4sdw4sdz3mek3mel3mem3men3meo3mep3meq4ser2wes2wet2weu2wev2wew1wex1wey1wez1wfl3rfm3mfn3mfo3mfp3mfq3mfr3tfs3mft3rfu3rfv3rfw3rfz2w203k6o212m6o2dw2l2cq2l3t3m3u2l17s3x19m3m}'kerning'{cl{4qu5kt5qt5rs17ss5ts}201s{201ss}201t{cks4lscmscnscoscpscls2wu2yu201ts}201x{2wu2yu}2k{201ts}2w{4qx5kx5ou5qx5rs17su5tu}2x{17su5tu5ou}2y{4qx5kx5ou5qx5rs17ss5ts}'fof'-6ofn{17sw5tw5ou5qw5rs}7t{cksclscmscnscoscps4ls}3u{17su5tu5os5qs}3v{17su5tu5os5qs}7p{17su5tu}ck{4qu5kt5qt5rs17ss5ts}4l{4qu5kt5qt5rs17ss5ts}cm{4qu5kt5qt5rs17ss5ts}cn{4qu5kt5qt5rs17ss5ts}co{4qu5kt5qt5rs17ss5ts}cp{4qu5kt5qt5rs17ss5ts}6l{4qu5ou5qw5rt17su5tu}5q{ckuclucmucnucoucpu4lu}5r{ckuclucmucnucoucpu4lu}7q{cksclscmscnscoscps4ls}6p{4qu5ou5qw5rt17sw5tw}ek{4qu5ou5qw5rt17su5tu}el{4qu5ou5qw5rt17su5tu}em{4qu5ou5qw5rt17su5tu}en{4qu5ou5qw5rt17su5tu}eo{4qu5ou5qw5rt17su5tu}ep{4qu5ou5qw5rt17su5tu}es{17ss5ts5qs4qu}et{4qu5ou5qw5rt17sw5tw}eu{4qu5ou5qw5rt17ss5ts}ev{17ss5ts5qs4qu}6z{17sw5tw5ou5qw5rs}fm{17sw5tw5ou5qw5rs}7n{201ts}fo{17sw5tw5ou5qw5rs}fp{17sw5tw5ou5qw5rs}fq{17sw5tw5ou5qw5rs}7r{cksclscmscnscoscps4ls}fs{17sw5tw5ou5qw5rs}ft{17su5tu}fu{17su5tu}fv{17su5tu}fw{17su5tu}fz{cksclscmscnscoscps4ls}}}"),
      "Helvetica-Bold": o("{'widths'{k3s2q4scx1w201n3r201o6o201s1w201t1w201u1w201w3m201x3m201y3m2k1w2l2l202m2n2n3r2o3r2p5t202q6o2r1s2s2l2t2l2u2r2v3u2w1w2x2l2y1w2z1w3k3r3l3r3m3r3n3r3o3r3p3r3q3r3r3r3s3r203t2l203u2l3v2l3w3u3x3u3y3u3z3x4k6l4l4s4m4s4n4s4o4s4p4m4q3x4r4y4s4s4t1w4u3r4v4s4w3x4x5n4y4s4z4y5k4m5l4y5m4s5n4m5o3x5p4s5q4m5r5y5s4m5t4m5u3x5v2l5w1w5x2l5y3u5z3r6k2l6l3r6m3x6n3r6o3x6p3r6q2l6r3x6s3x6t1w6u1w6v3r6w1w6x5t6y3x6z3x7k3x7l3x7m2r7n3r7o2l7p3x7q3r7r4y7s3r7t3r7u3m7v2r7w1w7x2r7y3u202l3rcl4sal2lam3ran3rao3rap3rar3ras2lat4tau2pav3raw3uay4taz2lbk2sbl3u'fof'6obo2lbp3xbq3rbr1wbs2lbu2obv3rbz3xck4s202k3rcm4scn4sco4scp4scq6ocr4scs4mct4mcu4mcv4mcw1w2m2zcy1wcz1wdl4sdm4ydn4ydo4ydp4ydq4yds4ydt4sdu4sdv4sdw4sdz3xek3rel3rem3ren3reo3rep3req5ter3res3ret3reu3rev3rew1wex1wey1wez1wfl3xfm3xfn3xfo3xfp3xfq3xfr3ufs3xft3xfu3xfv3xfw3xfz3r203k6o212m6o2dw2l2cq2l3t3r3u2l17s4m19m3r}'kerning'{cl{4qs5ku5ot5qs17sv5tv}201t{2ww4wy2yw}201w{2ks}201x{2ww4wy2yw}2k{201ts201xs}2w{7qs4qu5kw5os5qw5rs17su5tu7tsfzs}2x{5ow5qs}2y{7qs4qu5kw5os5qw5rs17su5tu7tsfzs}'fof'-6o7p{17su5tu5ot}ck{4qs5ku5ot5qs17sv5tv}4l{4qs5ku5ot5qs17sv5tv}cm{4qs5ku5ot5qs17sv5tv}cn{4qs5ku5ot5qs17sv5tv}co{4qs5ku5ot5qs17sv5tv}cp{4qs5ku5ot5qs17sv5tv}6l{17st5tt5os}17s{2kwclvcmvcnvcovcpv4lv4wwckv}5o{2kucltcmtcntcotcpt4lt4wtckt}5q{2ksclscmscnscoscps4ls4wvcks}5r{2ks4ws}5t{2kwclvcmvcnvcovcpv4lv4wwckv}eo{17st5tt5os}fu{17su5tu5ot}6p{17ss5ts}ek{17st5tt5os}el{17st5tt5os}em{17st5tt5os}en{17st5tt5os}6o{201ts}ep{17st5tt5os}es{17ss5ts}et{17ss5ts}eu{17ss5ts}ev{17ss5ts}6z{17su5tu5os5qt}fm{17su5tu5os5qt}fn{17su5tu5os5qt}fo{17su5tu5os5qt}fp{17su5tu5os5qt}fq{17su5tu5os5qt}fs{17su5tu5os5qt}ft{17su5tu5ot}7m{5os}fv{17su5tu5ot}fw{17su5tu5ot}}}"),
      Courier: o("{'widths'{k3w'fof'6o}'kerning'{'fof'-6o}}"),
      "Courier-BoldOblique": o("{'widths'{k3w'fof'6o}'kerning'{'fof'-6o}}"),
      "Times-Bold": o("{'widths'{k3q2q5ncx2r201n3m201o6o201s2l201t2l201u2l201w3m201x3m201y3m2k1t2l2l202m2n2n3m2o3m2p6o202q6o2r1w2s2l2t2l2u3m2v3t2w1t2x2l2y1t2z1w3k3m3l3m3m3m3n3m3o3m3p3m3q3m3r3m3s3m203t2l203u2l3v2l3w3t3x3t3y3t3z3m4k5x4l4s4m4m4n4s4o4s4p4m4q3x4r4y4s4y4t2r4u3m4v4y4w4m4x5y4y4s4z4y5k3x5l4y5m4s5n3r5o4m5p4s5q4s5r6o5s4s5t4s5u4m5v2l5w1w5x2l5y3u5z3m6k2l6l3m6m3r6n2w6o3r6p2w6q2l6r3m6s3r6t1w6u2l6v3r6w1w6x5n6y3r6z3m7k3r7l3r7m2w7n2r7o2l7p3r7q3m7r4s7s3m7t3m7u2w7v2r7w1q7x2r7y3o202l3mcl4sal2lam3man3mao3map3mar3mas2lat4uau1yav3maw3tay4uaz2lbk2sbl3t'fof'6obo2lbp3rbr1tbs2lbu2lbv3mbz3mck4s202k3mcm4scn4sco4scp4scq6ocr4scs4mct4mcu4mcv4mcw2r2m3rcy2rcz2rdl4sdm4ydn4ydo4ydp4ydq4yds4ydt4sdu4sdv4sdw4sdz3rek3mel3mem3men3meo3mep3meq4ser2wes2wet2weu2wev2wew1wex1wey1wez1wfl3rfm3mfn3mfo3mfp3mfq3mfr3tfs3mft3rfu3rfv3rfw3rfz3m203k6o212m6o2dw2l2cq2l3t3m3u2l17s4s19m3m}'kerning'{cl{4qt5ks5ot5qy5rw17sv5tv}201t{cks4lscmscnscoscpscls4wv}2k{201ts}2w{4qu5ku7mu5os5qx5ru17su5tu}2x{17su5tu5ou5qs}2y{4qv5kv7mu5ot5qz5ru17su5tu}'fof'-6o7t{cksclscmscnscoscps4ls}3u{17su5tu5os5qu}3v{17su5tu5os5qu}fu{17su5tu5ou5qu}7p{17su5tu5ou5qu}ck{4qt5ks5ot5qy5rw17sv5tv}4l{4qt5ks5ot5qy5rw17sv5tv}cm{4qt5ks5ot5qy5rw17sv5tv}cn{4qt5ks5ot5qy5rw17sv5tv}co{4qt5ks5ot5qy5rw17sv5tv}cp{4qt5ks5ot5qy5rw17sv5tv}6l{17st5tt5ou5qu}17s{ckuclucmucnucoucpu4lu4wu}5o{ckuclucmucnucoucpu4lu4wu}5q{ckzclzcmzcnzcozcpz4lz4wu}5r{ckxclxcmxcnxcoxcpx4lx4wu}5t{ckuclucmucnucoucpu4lu4wu}7q{ckuclucmucnucoucpu4lu}6p{17sw5tw5ou5qu}ek{17st5tt5qu}el{17st5tt5ou5qu}em{17st5tt5qu}en{17st5tt5qu}eo{17st5tt5qu}ep{17st5tt5ou5qu}es{17ss5ts5qu}et{17sw5tw5ou5qu}eu{17sw5tw5ou5qu}ev{17ss5ts5qu}6z{17sw5tw5ou5qu5rs}fm{17sw5tw5ou5qu5rs}fn{17sw5tw5ou5qu5rs}fo{17sw5tw5ou5qu5rs}fp{17sw5tw5ou5qu5rs}fq{17sw5tw5ou5qu5rs}7r{cktcltcmtcntcotcpt4lt5os}fs{17sw5tw5ou5qu5rs}ft{17su5tu5ou5qu}7m{5os}fv{17su5tu5ou5qu}fw{17su5tu5ou5qu}fz{cksclscmscnscoscps4ls}}}"),
      Symbol: o("{'widths'{k3uaw4r19m3m2k1t2l2l202m2y2n3m2p5n202q6o3k3m2s2l2t2l2v3r2w1t3m3m2y1t2z1wbk2sbl3r'fof'6o3n3m3o3m3p3m3q3m3r3m3s3m3t3m3u1w3v1w3w3r3x3r3y3r3z2wbp3t3l3m5v2l5x2l5z3m2q4yfr3r7v3k7w1o7x3k}'kerning'{'fof'-6o}}"),
      Helvetica: o("{'widths'{k3p2q4mcx1w201n3r201o6o201s1q201t1q201u1q201w2l201x2l201y2l2k1w2l1w202m2n2n3r2o3r2p5t202q6o2r1n2s2l2t2l2u2r2v3u2w1w2x2l2y1w2z1w3k3r3l3r3m3r3n3r3o3r3p3r3q3r3r3r3s3r203t2l203u2l3v1w3w3u3x3u3y3u3z3r4k6p4l4m4m4m4n4s4o4s4p4m4q3x4r4y4s4s4t1w4u3m4v4m4w3r4x5n4y4s4z4y5k4m5l4y5m4s5n4m5o3x5p4s5q4m5r5y5s4m5t4m5u3x5v1w5w1w5x1w5y2z5z3r6k2l6l3r6m3r6n3m6o3r6p3r6q1w6r3r6s3r6t1q6u1q6v3m6w1q6x5n6y3r6z3r7k3r7l3r7m2l7n3m7o1w7p3r7q3m7r4s7s3m7t3m7u3m7v2l7w1u7x2l7y3u202l3rcl4mal2lam3ran3rao3rap3rar3ras2lat4tau2pav3raw3uay4taz2lbk2sbl3u'fof'6obo2lbp3rbr1wbs2lbu2obv3rbz3xck4m202k3rcm4mcn4mco4mcp4mcq6ocr4scs4mct4mcu4mcv4mcw1w2m2ncy1wcz1wdl4sdm4ydn4ydo4ydp4ydq4yds4ydt4sdu4sdv4sdw4sdz3xek3rel3rem3ren3reo3rep3req5ter3mes3ret3reu3rev3rew1wex1wey1wez1wfl3rfm3rfn3rfo3rfp3rfq3rfr3ufs3xft3rfu3rfv3rfw3rfz3m203k6o212m6o2dw2l2cq2l3t3r3u1w17s4m19m3r}'kerning'{5q{4wv}cl{4qs5kw5ow5qs17sv5tv}201t{2wu4w1k2yu}201x{2wu4wy2yu}17s{2ktclucmucnu4otcpu4lu4wycoucku}2w{7qs4qz5k1m17sy5ow5qx5rsfsu5ty7tufzu}2x{17sy5ty5oy5qs}2y{7qs4qz5k1m17sy5ow5qx5rsfsu5ty7tufzu}'fof'-6o7p{17sv5tv5ow}ck{4qs5kw5ow5qs17sv5tv}4l{4qs5kw5ow5qs17sv5tv}cm{4qs5kw5ow5qs17sv5tv}cn{4qs5kw5ow5qs17sv5tv}co{4qs5kw5ow5qs17sv5tv}cp{4qs5kw5ow5qs17sv5tv}6l{17sy5ty5ow}do{17st5tt}4z{17st5tt}7s{fst}dm{17st5tt}dn{17st5tt}5o{ckwclwcmwcnwcowcpw4lw4wv}dp{17st5tt}dq{17st5tt}7t{5ow}ds{17st5tt}5t{2ktclucmucnu4otcpu4lu4wycoucku}fu{17sv5tv5ow}6p{17sy5ty5ow5qs}ek{17sy5ty5ow}el{17sy5ty5ow}em{17sy5ty5ow}en{5ty}eo{17sy5ty5ow}ep{17sy5ty5ow}es{17sy5ty5qs}et{17sy5ty5ow5qs}eu{17sy5ty5ow5qs}ev{17sy5ty5ow5qs}6z{17sy5ty5ow5qs}fm{17sy5ty5ow5qs}fn{17sy5ty5ow5qs}fo{17sy5ty5ow5qs}fp{17sy5ty5qs}fq{17sy5ty5ow5qs}7r{5ow}fs{17sy5ty5ow5qs}ft{17sv5tv5ow}7m{5ow}fv{17sv5tv5ow}fw{17sv5tv5ow}}}"),
      "Helvetica-BoldOblique": o("{'widths'{k3s2q4scx1w201n3r201o6o201s1w201t1w201u1w201w3m201x3m201y3m2k1w2l2l202m2n2n3r2o3r2p5t202q6o2r1s2s2l2t2l2u2r2v3u2w1w2x2l2y1w2z1w3k3r3l3r3m3r3n3r3o3r3p3r3q3r3r3r3s3r203t2l203u2l3v2l3w3u3x3u3y3u3z3x4k6l4l4s4m4s4n4s4o4s4p4m4q3x4r4y4s4s4t1w4u3r4v4s4w3x4x5n4y4s4z4y5k4m5l4y5m4s5n4m5o3x5p4s5q4m5r5y5s4m5t4m5u3x5v2l5w1w5x2l5y3u5z3r6k2l6l3r6m3x6n3r6o3x6p3r6q2l6r3x6s3x6t1w6u1w6v3r6w1w6x5t6y3x6z3x7k3x7l3x7m2r7n3r7o2l7p3x7q3r7r4y7s3r7t3r7u3m7v2r7w1w7x2r7y3u202l3rcl4sal2lam3ran3rao3rap3rar3ras2lat4tau2pav3raw3uay4taz2lbk2sbl3u'fof'6obo2lbp3xbq3rbr1wbs2lbu2obv3rbz3xck4s202k3rcm4scn4sco4scp4scq6ocr4scs4mct4mcu4mcv4mcw1w2m2zcy1wcz1wdl4sdm4ydn4ydo4ydp4ydq4yds4ydt4sdu4sdv4sdw4sdz3xek3rel3rem3ren3reo3rep3req5ter3res3ret3reu3rev3rew1wex1wey1wez1wfl3xfm3xfn3xfo3xfp3xfq3xfr3ufs3xft3xfu3xfv3xfw3xfz3r203k6o212m6o2dw2l2cq2l3t3r3u2l17s4m19m3r}'kerning'{cl{4qs5ku5ot5qs17sv5tv}201t{2ww4wy2yw}201w{2ks}201x{2ww4wy2yw}2k{201ts201xs}2w{7qs4qu5kw5os5qw5rs17su5tu7tsfzs}2x{5ow5qs}2y{7qs4qu5kw5os5qw5rs17su5tu7tsfzs}'fof'-6o7p{17su5tu5ot}ck{4qs5ku5ot5qs17sv5tv}4l{4qs5ku5ot5qs17sv5tv}cm{4qs5ku5ot5qs17sv5tv}cn{4qs5ku5ot5qs17sv5tv}co{4qs5ku5ot5qs17sv5tv}cp{4qs5ku5ot5qs17sv5tv}6l{17st5tt5os}17s{2kwclvcmvcnvcovcpv4lv4wwckv}5o{2kucltcmtcntcotcpt4lt4wtckt}5q{2ksclscmscnscoscps4ls4wvcks}5r{2ks4ws}5t{2kwclvcmvcnvcovcpv4lv4wwckv}eo{17st5tt5os}fu{17su5tu5ot}6p{17ss5ts}ek{17st5tt5os}el{17st5tt5os}em{17st5tt5os}en{17st5tt5os}6o{201ts}ep{17st5tt5os}es{17ss5ts}et{17ss5ts}eu{17ss5ts}ev{17ss5ts}6z{17su5tu5os5qt}fm{17su5tu5os5qt}fn{17su5tu5os5qt}fo{17su5tu5os5qt}fp{17su5tu5os5qt}fq{17su5tu5os5qt}fs{17su5tu5os5qt}ft{17su5tu5ot}7m{5os}fv{17su5tu5ot}fw{17su5tu5ot}}}"),
      ZapfDingbats: o("{'widths'{k4u2k1w'fof'6o}'kerning'{'fof'-6o}}"),
      "Courier-Bold": o("{'widths'{k3w'fof'6o}'kerning'{'fof'-6o}}"),
      "Times-Italic": o("{'widths'{k3n2q4ycx2l201n3m201o5t201s2l201t2l201u2l201w3r201x3r201y3r2k1t2l2l202m2n2n3m2o3m2p5n202q5t2r1p2s2l2t2l2u3m2v4n2w1t2x2l2y1t2z1w3k3m3l3m3m3m3n3m3o3m3p3m3q3m3r3m3s3m203t2l203u2l3v2l3w4n3x4n3y4n3z3m4k5w4l3x4m3x4n4m4o4s4p3x4q3x4r4s4s4s4t2l4u2w4v4m4w3r4x5n4y4m4z4s5k3x5l4s5m3x5n3m5o3r5p4s5q3x5r5n5s3x5t3r5u3r5v2r5w1w5x2r5y2u5z3m6k2l6l3m6m3m6n2w6o3m6p2w6q1w6r3m6s3m6t1w6u1w6v2w6w1w6x4s6y3m6z3m7k3m7l3m7m2r7n2r7o1w7p3m7q2w7r4m7s2w7t2w7u2r7v2s7w1v7x2s7y3q202l3mcl3xal2ram3man3mao3map3mar3mas2lat4wau1vav3maw4nay4waz2lbk2sbl4n'fof'6obo2lbp3mbq3obr1tbs2lbu1zbv3mbz3mck3x202k3mcm3xcn3xco3xcp3xcq5tcr4mcs3xct3xcu3xcv3xcw2l2m2ucy2lcz2ldl4mdm4sdn4sdo4sdp4sdq4sds4sdt4sdu4sdv4sdw4sdz3mek3mel3mem3men3meo3mep3meq4mer2wes2wet2weu2wev2wew1wex1wey1wez1wfl3mfm3mfn3mfo3mfp3mfq3mfr4nfs3mft3mfu3mfv3mfw3mfz2w203k6o212m6m2dw2l2cq2l3t3m3u2l17s3r19m3m}'kerning'{cl{5kt4qw}201s{201sw}201t{201tw2wy2yy6q-t}201x{2wy2yy}2k{201tw}2w{7qs4qy7rs5ky7mw5os5qx5ru17su5tu}2x{17ss5ts5os}2y{7qs4qy7rs5ky7mw5os5qx5ru17su5tu}'fof'-6o6t{17ss5ts5qs}7t{5os}3v{5qs}7p{17su5tu5qs}ck{5kt4qw}4l{5kt4qw}cm{5kt4qw}cn{5kt4qw}co{5kt4qw}cp{5kt4qw}6l{4qs5ks5ou5qw5ru17su5tu}17s{2ks}5q{ckvclvcmvcnvcovcpv4lv}5r{ckuclucmucnucoucpu4lu}5t{2ks}6p{4qs5ks5ou5qw5ru17su5tu}ek{4qs5ks5ou5qw5ru17su5tu}el{4qs5ks5ou5qw5ru17su5tu}em{4qs5ks5ou5qw5ru17su5tu}en{4qs5ks5ou5qw5ru17su5tu}eo{4qs5ks5ou5qw5ru17su5tu}ep{4qs5ks5ou5qw5ru17su5tu}es{5ks5qs4qs}et{4qs5ks5ou5qw5ru17su5tu}eu{4qs5ks5qw5ru17su5tu}ev{5ks5qs4qs}ex{17ss5ts5qs}6z{4qv5ks5ou5qw5ru17su5tu}fm{4qv5ks5ou5qw5ru17su5tu}fn{4qv5ks5ou5qw5ru17su5tu}fo{4qv5ks5ou5qw5ru17su5tu}fp{4qv5ks5ou5qw5ru17su5tu}fq{4qv5ks5ou5qw5ru17su5tu}7r{5os}fs{4qv5ks5ou5qw5ru17su5tu}ft{17su5tu5qs}fu{17su5tu5qs}fv{17su5tu5qs}fw{17su5tu5qs}}}"),
      "Times-Roman": o("{'widths'{k3n2q4ycx2l201n3m201o6o201s2l201t2l201u2l201w2w201x2w201y2w2k1t2l2l202m2n2n3m2o3m2p5n202q6o2r1m2s2l2t2l2u3m2v3s2w1t2x2l2y1t2z1w3k3m3l3m3m3m3n3m3o3m3p3m3q3m3r3m3s3m203t2l203u2l3v1w3w3s3x3s3y3s3z2w4k5w4l4s4m4m4n4m4o4s4p3x4q3r4r4s4s4s4t2l4u2r4v4s4w3x4x5t4y4s4z4s5k3r5l4s5m4m5n3r5o3x5p4s5q4s5r5y5s4s5t4s5u3x5v2l5w1w5x2l5y2z5z3m6k2l6l2w6m3m6n2w6o3m6p2w6q2l6r3m6s3m6t1w6u1w6v3m6w1w6x4y6y3m6z3m7k3m7l3m7m2l7n2r7o1w7p3m7q3m7r4s7s3m7t3m7u2w7v3k7w1o7x3k7y3q202l3mcl4sal2lam3man3mao3map3mar3mas2lat4wau1vav3maw3say4waz2lbk2sbl3s'fof'6obo2lbp3mbq2xbr1tbs2lbu1zbv3mbz2wck4s202k3mcm4scn4sco4scp4scq5tcr4mcs3xct3xcu3xcv3xcw2l2m2tcy2lcz2ldl4sdm4sdn4sdo4sdp4sdq4sds4sdt4sdu4sdv4sdw4sdz3mek2wel2wem2wen2weo2wep2weq4mer2wes2wet2weu2wev2wew1wex1wey1wez1wfl3mfm3mfn3mfo3mfp3mfq3mfr3sfs3mft3mfu3mfv3mfw3mfz3m203k6o212m6m2dw2l2cq2l3t3m3u1w17s4s19m3m}'kerning'{cl{4qs5ku17sw5ou5qy5rw201ss5tw201ws}201s{201ss}201t{ckw4lwcmwcnwcowcpwclw4wu201ts}2k{201ts}2w{4qs5kw5os5qx5ru17sx5tx}2x{17sw5tw5ou5qu}2y{4qs5kw5os5qx5ru17sx5tx}'fof'-6o7t{ckuclucmucnucoucpu4lu5os5rs}3u{17su5tu5qs}3v{17su5tu5qs}7p{17sw5tw5qs}ck{4qs5ku17sw5ou5qy5rw201ss5tw201ws}4l{4qs5ku17sw5ou5qy5rw201ss5tw201ws}cm{4qs5ku17sw5ou5qy5rw201ss5tw201ws}cn{4qs5ku17sw5ou5qy5rw201ss5tw201ws}co{4qs5ku17sw5ou5qy5rw201ss5tw201ws}cp{4qs5ku17sw5ou5qy5rw201ss5tw201ws}6l{17su5tu5os5qw5rs}17s{2ktclvcmvcnvcovcpv4lv4wuckv}5o{ckwclwcmwcnwcowcpw4lw4wu}5q{ckyclycmycnycoycpy4ly4wu5ms}5r{cktcltcmtcntcotcpt4lt4ws}5t{2ktclvcmvcnvcovcpv4lv4wuckv}7q{cksclscmscnscoscps4ls}6p{17su5tu5qw5rs}ek{5qs5rs}el{17su5tu5os5qw5rs}em{17su5tu5os5qs5rs}en{17su5qs5rs}eo{5qs5rs}ep{17su5tu5os5qw5rs}es{5qs}et{17su5tu5qw5rs}eu{17su5tu5qs5rs}ev{5qs}6z{17sv5tv5os5qx5rs}fm{5os5qt5rs}fn{17sv5tv5os5qx5rs}fo{17sv5tv5os5qx5rs}fp{5os5qt5rs}fq{5os5qt5rs}7r{ckuclucmucnucoucpu4lu5os}fs{17sv5tv5os5qx5rs}ft{17ss5ts5qs}fu{17sw5tw5qs}fv{17sw5tw5qs}fw{17ss5ts5qs}fz{ckuclucmucnucoucpu4lu5os5rs}}}"),
      "Helvetica-Oblique": o("{'widths'{k3p2q4mcx1w201n3r201o6o201s1q201t1q201u1q201w2l201x2l201y2l2k1w2l1w202m2n2n3r2o3r2p5t202q6o2r1n2s2l2t2l2u2r2v3u2w1w2x2l2y1w2z1w3k3r3l3r3m3r3n3r3o3r3p3r3q3r3r3r3s3r203t2l203u2l3v1w3w3u3x3u3y3u3z3r4k6p4l4m4m4m4n4s4o4s4p4m4q3x4r4y4s4s4t1w4u3m4v4m4w3r4x5n4y4s4z4y5k4m5l4y5m4s5n4m5o3x5p4s5q4m5r5y5s4m5t4m5u3x5v1w5w1w5x1w5y2z5z3r6k2l6l3r6m3r6n3m6o3r6p3r6q1w6r3r6s3r6t1q6u1q6v3m6w1q6x5n6y3r6z3r7k3r7l3r7m2l7n3m7o1w7p3r7q3m7r4s7s3m7t3m7u3m7v2l7w1u7x2l7y3u202l3rcl4mal2lam3ran3rao3rap3rar3ras2lat4tau2pav3raw3uay4taz2lbk2sbl3u'fof'6obo2lbp3rbr1wbs2lbu2obv3rbz3xck4m202k3rcm4mcn4mco4mcp4mcq6ocr4scs4mct4mcu4mcv4mcw1w2m2ncy1wcz1wdl4sdm4ydn4ydo4ydp4ydq4yds4ydt4sdu4sdv4sdw4sdz3xek3rel3rem3ren3reo3rep3req5ter3mes3ret3reu3rev3rew1wex1wey1wez1wfl3rfm3rfn3rfo3rfp3rfq3rfr3ufs3xft3rfu3rfv3rfw3rfz3m203k6o212m6o2dw2l2cq2l3t3r3u1w17s4m19m3r}'kerning'{5q{4wv}cl{4qs5kw5ow5qs17sv5tv}201t{2wu4w1k2yu}201x{2wu4wy2yu}17s{2ktclucmucnu4otcpu4lu4wycoucku}2w{7qs4qz5k1m17sy5ow5qx5rsfsu5ty7tufzu}2x{17sy5ty5oy5qs}2y{7qs4qz5k1m17sy5ow5qx5rsfsu5ty7tufzu}'fof'-6o7p{17sv5tv5ow}ck{4qs5kw5ow5qs17sv5tv}4l{4qs5kw5ow5qs17sv5tv}cm{4qs5kw5ow5qs17sv5tv}cn{4qs5kw5ow5qs17sv5tv}co{4qs5kw5ow5qs17sv5tv}cp{4qs5kw5ow5qs17sv5tv}6l{17sy5ty5ow}do{17st5tt}4z{17st5tt}7s{fst}dm{17st5tt}dn{17st5tt}5o{ckwclwcmwcnwcowcpw4lw4wv}dp{17st5tt}dq{17st5tt}7t{5ow}ds{17st5tt}5t{2ktclucmucnu4otcpu4lu4wycoucku}fu{17sv5tv5ow}6p{17sy5ty5ow5qs}ek{17sy5ty5ow}el{17sy5ty5ow}em{17sy5ty5ow}en{5ty}eo{17sy5ty5ow}ep{17sy5ty5ow}es{17sy5ty5qs}et{17sy5ty5ow5qs}eu{17sy5ty5ow5qs}ev{17sy5ty5ow5qs}6z{17sy5ty5ow5qs}fm{17sy5ty5ow5qs}fn{17sy5ty5ow5qs}fo{17sy5ty5ow5qs}fp{17sy5ty5qs}fq{17sy5ty5ow5qs}7r{5ow}fs{17sy5ty5ow5qs}ft{17sv5tv5ow}7m{5ow}fv{17sv5tv5ow}fw{17sv5tv5ow}}}")
    }
  };
  r6.events.push(["addFont", function(p) {
    var v = p.font, d = c.Unicode[v.postScriptName];
    d && (v.metadata.Unicode = {}, v.metadata.Unicode.widths = d.widths, v.metadata.Unicode.kerning = d.kerning);
    var w = h.Unicode[v.postScriptName];
    w && (v.metadata.Unicode.encoding = w, v.encoding = w.codePages[0]);
  }]);
}(ut.API), /**
* @license
* Licensed under the MIT License.
* http://opensource.org/licenses/mit-license
*/
function(r6) {
  var e = function(t) {
    for (var n = t.length, i = new Uint8Array(n), a = 0; a < n; a++) i[a] = t.charCodeAt(a);
    return i;
  };
  r6.API.events.push(["addFont", function(t) {
    var n = void 0, i = t.font, a = t.instance;
    if (!i.isStandardFont) {
      if (a === void 0) throw new Error("Font does not exist in vFS, import fonts or remove declaration doc.addFont('" + i.postScriptName + "').");
      if (typeof (n = a.existsFileInVFS(i.postScriptName) === false ? a.loadFile(i.postScriptName) : a.getFileFromVFS(i.postScriptName)) != "string") throw new Error("Font is not stored as string-data in vFS, import fonts or remove declaration doc.addFont('" + i.postScriptName + "').");
      (function(s, o) {
        o = /^\x00\x01\x00\x00/.test(o) ? e(o) : e(wo(o)), s.metadata = r6.API.TTFFont.open(o), s.metadata.Unicode = s.metadata.Unicode || {
          encoding: {},
          kerning: {},
          widths: []
        }, s.metadata.glyIdsUsed = [0];
      })(i, n);
    }
  }]);
}(ut), /** @license
* Copyright (c) 2012 Willow Systems Corporation, https://github.com/willowsystems
*
* Permission is hereby granted, free of charge, to any person obtaining
* a copy of this software and associated documentation files (the
* "Software"), to deal in the Software without restriction, including
* without limitation the rights to use, copy, modify, merge, publish,
* distribute, sublicense, and/or sell copies of the Software, and to
* permit persons to whom the Software is furnished to do so, subject to
* the following conditions:
*
* The above copyright notice and this permission notice shall be
* included in all copies or substantial portions of the Software.
*
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
* EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
* MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
* NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
* LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
* OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
* WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
* ====================================================================
*/
function(r6) {
  function e() {
    return (dt.canvg ? Promise.resolve(dt.canvg) : import("./index.es-980ec5f7-65FC5NO6.js")).catch(function(t) {
      return Promise.reject(new Error("Could not load canvg: " + t));
    }).then(function(t) {
      return t.default ? t.default : t;
    });
  }
  ut.API.addSvgAsImage = function(t, n, i, a, s, o, f, h) {
    if (isNaN(n) || isNaN(i)) throw Kt.error("jsPDF.addSvgAsImage: Invalid coordinates", arguments), new Error("Invalid coordinates passed to jsPDF.addSvgAsImage");
    if (isNaN(a) || isNaN(s)) throw Kt.error("jsPDF.addSvgAsImage: Invalid measurements", arguments), new Error("Invalid measurements (width and/or height) passed to jsPDF.addSvgAsImage");
    var c = document.createElement("canvas");
    c.width = a, c.height = s;
    var p = c.getContext("2d");
    p.fillStyle = "#fff", p.fillRect(0, 0, c.width, c.height);
    var v = {
      ignoreMouse: true,
      ignoreAnimation: true,
      ignoreDimensions: true
    }, d = this;
    return e().then(function(w) {
      return w.fromString(p, t, v);
    }, function() {
      return Promise.reject(new Error("Could not load canvg."));
    }).then(function(w) {
      return w.render(v);
    }).then(function() {
      d.addImage(c.toDataURL("image/jpeg", 1), n, i, a, s, f, h);
    });
  };
}(), ut.API.putTotalPages = function(r6) {
  var e, t = 0;
  parseInt(this.internal.getFont().id.substr(1), 10) < 15 ? (e = new RegExp(r6, "g"), t = this.internal.getNumberOfPages()) : (e = new RegExp(this.pdfEscape16(r6, this.internal.getFont()), "g"), t = this.pdfEscape16(this.internal.getNumberOfPages() + "", this.internal.getFont()));
  for (var n = 1; n <= this.internal.getNumberOfPages(); n++) for (var i = 0; i < this.internal.pages[n].length; i++) this.internal.pages[n][i] = this.internal.pages[n][i].replace(e, t);
  return this;
}, ut.API.viewerPreferences = function(r6, e) {
  var t;
  r6 = r6 || {}, e = e || false;
  var n, i, a, s = {
    HideToolbar: {
      defaultValue: false,
      value: false,
      type: "boolean",
      explicitSet: false,
      valueSet: [true, false],
      pdfVersion: 1.3
    },
    HideMenubar: {
      defaultValue: false,
      value: false,
      type: "boolean",
      explicitSet: false,
      valueSet: [true, false],
      pdfVersion: 1.3
    },
    HideWindowUI: {
      defaultValue: false,
      value: false,
      type: "boolean",
      explicitSet: false,
      valueSet: [true, false],
      pdfVersion: 1.3
    },
    FitWindow: {
      defaultValue: false,
      value: false,
      type: "boolean",
      explicitSet: false,
      valueSet: [true, false],
      pdfVersion: 1.3
    },
    CenterWindow: {
      defaultValue: false,
      value: false,
      type: "boolean",
      explicitSet: false,
      valueSet: [true, false],
      pdfVersion: 1.3
    },
    DisplayDocTitle: {
      defaultValue: false,
      value: false,
      type: "boolean",
      explicitSet: false,
      valueSet: [true, false],
      pdfVersion: 1.4
    },
    NonFullScreenPageMode: {
      defaultValue: "UseNone",
      value: "UseNone",
      type: "name",
      explicitSet: false,
      valueSet: ["UseNone", "UseOutlines", "UseThumbs", "UseOC"],
      pdfVersion: 1.3
    },
    Direction: {
      defaultValue: "L2R",
      value: "L2R",
      type: "name",
      explicitSet: false,
      valueSet: ["L2R", "R2L"],
      pdfVersion: 1.3
    },
    ViewArea: {
      defaultValue: "CropBox",
      value: "CropBox",
      type: "name",
      explicitSet: false,
      valueSet: ["MediaBox", "CropBox", "TrimBox", "BleedBox", "ArtBox"],
      pdfVersion: 1.4
    },
    ViewClip: {
      defaultValue: "CropBox",
      value: "CropBox",
      type: "name",
      explicitSet: false,
      valueSet: ["MediaBox", "CropBox", "TrimBox", "BleedBox", "ArtBox"],
      pdfVersion: 1.4
    },
    PrintArea: {
      defaultValue: "CropBox",
      value: "CropBox",
      type: "name",
      explicitSet: false,
      valueSet: ["MediaBox", "CropBox", "TrimBox", "BleedBox", "ArtBox"],
      pdfVersion: 1.4
    },
    PrintClip: {
      defaultValue: "CropBox",
      value: "CropBox",
      type: "name",
      explicitSet: false,
      valueSet: ["MediaBox", "CropBox", "TrimBox", "BleedBox", "ArtBox"],
      pdfVersion: 1.4
    },
    PrintScaling: {
      defaultValue: "AppDefault",
      value: "AppDefault",
      type: "name",
      explicitSet: false,
      valueSet: ["AppDefault", "None"],
      pdfVersion: 1.6
    },
    Duplex: {
      defaultValue: "",
      value: "none",
      type: "name",
      explicitSet: false,
      valueSet: ["Simplex", "DuplexFlipShortEdge", "DuplexFlipLongEdge", "none"],
      pdfVersion: 1.7
    },
    PickTrayByPDFSize: {
      defaultValue: false,
      value: false,
      type: "boolean",
      explicitSet: false,
      valueSet: [true, false],
      pdfVersion: 1.7
    },
    PrintPageRange: {
      defaultValue: "",
      value: "",
      type: "array",
      explicitSet: false,
      valueSet: null,
      pdfVersion: 1.7
    },
    NumCopies: {
      defaultValue: 1,
      value: 1,
      type: "integer",
      explicitSet: false,
      valueSet: null,
      pdfVersion: 1.7
    }
  }, o = Object.keys(s), f = [], h = 0, c = 0, p = 0;
  function v(w, x) {
    var S, A = false;
    for (S = 0; S < w.length; S += 1) w[S] === x && (A = true);
    return A;
  }
  if (this.internal.viewerpreferences === void 0 && (this.internal.viewerpreferences = {}, this.internal.viewerpreferences.configuration = JSON.parse(JSON.stringify(s)), this.internal.viewerpreferences.isSubscribed = false), t = this.internal.viewerpreferences.configuration, r6 === "reset" || e === true) {
    var d = o.length;
    for (p = 0; p < d; p += 1) t[o[p]].value = t[o[p]].defaultValue, t[o[p]].explicitSet = false;
  }
  if (Wt(r6) === "object") {
    for (i in r6) if (a = r6[i], v(o, i) && a !== void 0) {
      if (t[i].type === "boolean" && typeof a == "boolean") t[i].value = a;
      else if (t[i].type === "name" && v(t[i].valueSet, a)) t[i].value = a;
      else if (t[i].type === "integer" && Number.isInteger(a)) t[i].value = a;
      else if (t[i].type === "array") {
        for (h = 0; h < a.length; h += 1) if (n = true, a[h].length === 1 && typeof a[h][0] == "number") f.push(String(a[h] - 1));
        else if (a[h].length > 1) {
          for (c = 0; c < a[h].length; c += 1) typeof a[h][c] != "number" && (n = false);
          n === true && f.push([a[h][0] - 1, a[h][1] - 1].join(" "));
        }
        t[i].value = "[" + f.join(" ") + "]";
      } else t[i].value = t[i].defaultValue;
      t[i].explicitSet = true;
    }
  }
  return this.internal.viewerpreferences.isSubscribed === false && (this.internal.events.subscribe("putCatalog", function() {
    var w, x = [];
    for (w in t) t[w].explicitSet === true && (t[w].type === "name" ? x.push("/" + w + " /" + t[w].value) : x.push("/" + w + " " + t[w].value));
    x.length !== 0 && this.internal.write(`/ViewerPreferences
<<
` + x.join(`
`) + `
>>`);
  }), this.internal.viewerpreferences.isSubscribed = true), this.internal.viewerpreferences.configuration = t, this;
}, /** ====================================================================
* @license
* jsPDF XMP metadata plugin
* Copyright (c) 2016 Jussi Utunen, u-jussi@suomi24.fi
*
* Permission is hereby granted, free of charge, to any person obtaining
* a copy of this software and associated documentation files (the
* "Software"), to deal in the Software without restriction, including
* without limitation the rights to use, copy, modify, merge, publish,
* distribute, sublicense, and/or sell copies of the Software, and to
* permit persons to whom the Software is furnished to do so, subject to
* the following conditions:
*
* The above copyright notice and this permission notice shall be
* included in all copies or substantial portions of the Software.
*
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
* EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
* MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
* NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
* LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
* OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
* WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
* ====================================================================
*/
function(r6) {
  var e = function() {
    var n = '<rdf:RDF xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"><rdf:Description rdf:about="" xmlns:jspdf="' + this.internal.__metadata__.namespaceuri + '"><jspdf:metadata>', i = unescape(encodeURIComponent('<x:xmpmeta xmlns:x="adobe:ns:meta/">')), a = unescape(encodeURIComponent(n)), s = unescape(encodeURIComponent(this.internal.__metadata__.metadata)), o = unescape(encodeURIComponent("</jspdf:metadata></rdf:Description></rdf:RDF>")), f = unescape(encodeURIComponent("</x:xmpmeta>")), h = a.length + s.length + o.length + i.length + f.length;
    this.internal.__metadata__.metadata_object_number = this.internal.newObject(), this.internal.write("<< /Type /Metadata /Subtype /XML /Length " + h + " >>"), this.internal.write("stream"), this.internal.write(i + a + s + o + f), this.internal.write("endstream"), this.internal.write("endobj");
  }, t = function() {
    this.internal.__metadata__.metadata_object_number && this.internal.write("/Metadata " + this.internal.__metadata__.metadata_object_number + " 0 R");
  };
  r6.addMetadata = function(n, i) {
    return this.internal.__metadata__ === void 0 && (this.internal.__metadata__ = {
      metadata: n,
      namespaceuri: i || "http://jspdf.default.namespaceuri/"
    }, this.internal.events.subscribe("putCatalog", t), this.internal.events.subscribe("postPutResources", e)), this;
  };
}(ut.API), function(r6) {
  var e = r6.API, t = e.pdfEscape16 = function(a, s) {
    for (var o, f = s.metadata.Unicode.widths, h = ["", "0", "00", "000", "0000"], c = [""], p = 0, v = a.length; p < v; ++p) {
      if (o = s.metadata.characterToGlyph(a.charCodeAt(p)), s.metadata.glyIdsUsed.push(o), s.metadata.toUnicode[o] = a.charCodeAt(p), f.indexOf(o) == -1 && (f.push(o), f.push([parseInt(s.metadata.widthOfGlyph(o), 10)])), o == "0") return c.join("");
      o = o.toString(16), c.push(h[4 - o.length], o);
    }
    return c.join("");
  }, n = function(a) {
    var s, o, f, h, c, p, v;
    for (c = `/CIDInit /ProcSet findresource begin
12 dict begin
begincmap
/CIDSystemInfo <<
  /Registry (Adobe)
  /Ordering (UCS)
  /Supplement 0
>> def
/CMapName /Adobe-Identity-UCS def
/CMapType 2 def
1 begincodespacerange
<0000><ffff>
endcodespacerange`, f = [], p = 0, v = (o = Object.keys(a).sort(function(d, w) {
      return d - w;
    })).length; p < v; p++) s = o[p], f.length >= 100 && (c += `
` + f.length + ` beginbfchar
` + f.join(`
`) + `
endbfchar`, f = []), a[s] !== void 0 && a[s] !== null && typeof a[s].toString == "function" && (h = ("0000" + a[s].toString(16)).slice(-4), s = ("0000" + (+s).toString(16)).slice(-4), f.push("<" + s + "><" + h + ">"));
    return f.length && (c += `
` + f.length + ` beginbfchar
` + f.join(`
`) + `
endbfchar
`), c += `endcmap
CMapName currentdict /CMap defineresource pop
end
end`;
  };
  e.events.push(["putFont", function(a) {
    (function(s) {
      var o = s.font, f = s.out, h = s.newObject, c = s.putStream;
      if (o.metadata instanceof r6.API.TTFFont && o.encoding === "Identity-H") {
        for (var p = o.metadata.Unicode.widths, v = o.metadata.subset.encode(o.metadata.glyIdsUsed, 1), d = "", w = 0; w < v.length; w++) d += String.fromCharCode(v[w]);
        var x = h();
        c({
          data: d,
          addLength1: true,
          objectId: x
        }), f("endobj");
        var S = h();
        c({
          data: n(o.metadata.toUnicode),
          addLength1: true,
          objectId: S
        }), f("endobj");
        var A = h();
        f("<<"), f("/Type /FontDescriptor"), f("/FontName /" + gs(o.fontName)), f("/FontFile2 " + x + " 0 R"), f("/FontBBox " + r6.API.PDFObject.convert(o.metadata.bbox)), f("/Flags " + o.metadata.flags), f("/StemV " + o.metadata.stemV), f("/ItalicAngle " + o.metadata.italicAngle), f("/Ascent " + o.metadata.ascender), f("/Descent " + o.metadata.decender), f("/CapHeight " + o.metadata.capHeight), f(">>"), f("endobj");
        var b = h();
        f("<<"), f("/Type /Font"), f("/BaseFont /" + gs(o.fontName)), f("/FontDescriptor " + A + " 0 R"), f("/W " + r6.API.PDFObject.convert(p)), f("/CIDToGIDMap /Identity"), f("/DW 1000"), f("/Subtype /CIDFontType2"), f("/CIDSystemInfo"), f("<<"), f("/Supplement 0"), f("/Registry (Adobe)"), f("/Ordering (" + o.encoding + ")"), f(">>"), f(">>"), f("endobj"), o.objectNumber = h(), f("<<"), f("/Type /Font"), f("/Subtype /Type0"), f("/ToUnicode " + S + " 0 R"), f("/BaseFont /" + gs(o.fontName)), f("/Encoding /" + o.encoding), f("/DescendantFonts [" + b + " 0 R]"), f(">>"), f("endobj"), o.isAlreadyPutted = true;
      }
    })(a);
  }]), e.events.push(["putFont", function(a) {
    (function(s) {
      var o = s.font, f = s.out, h = s.newObject, c = s.putStream;
      if (o.metadata instanceof r6.API.TTFFont && o.encoding === "WinAnsiEncoding") {
        for (var p = o.metadata.rawData, v = "", d = 0; d < p.length; d++) v += String.fromCharCode(p[d]);
        var w = h();
        c({
          data: v,
          addLength1: true,
          objectId: w
        }), f("endobj");
        var x = h();
        c({
          data: n(o.metadata.toUnicode),
          addLength1: true,
          objectId: x
        }), f("endobj");
        var S = h();
        f("<<"), f("/Descent " + o.metadata.decender), f("/CapHeight " + o.metadata.capHeight), f("/StemV " + o.metadata.stemV), f("/Type /FontDescriptor"), f("/FontFile2 " + w + " 0 R"), f("/Flags 96"), f("/FontBBox " + r6.API.PDFObject.convert(o.metadata.bbox)), f("/FontName /" + gs(o.fontName)), f("/ItalicAngle " + o.metadata.italicAngle), f("/Ascent " + o.metadata.ascender), f(">>"), f("endobj"), o.objectNumber = h();
        for (var A = 0; A < o.metadata.hmtx.widths.length; A++) o.metadata.hmtx.widths[A] = parseInt(o.metadata.hmtx.widths[A] * (1e3 / o.metadata.head.unitsPerEm));
        f("<</Subtype/TrueType/Type/Font/ToUnicode " + x + " 0 R/BaseFont/" + gs(o.fontName) + "/FontDescriptor " + S + " 0 R/Encoding/" + o.encoding + " /FirstChar 29 /LastChar 255 /Widths " + r6.API.PDFObject.convert(o.metadata.hmtx.widths) + ">>"), f("endobj"), o.isAlreadyPutted = true;
      }
    })(a);
  }]);
  var i = function(a) {
    var s, o = a.text || "", f = a.x, h = a.y, c = a.options || {}, p = a.mutex || {}, v = p.pdfEscape, d = p.activeFontKey, w = p.fonts, x = d, S = "", A = 0, b = "", O = w[x].encoding;
    if (w[x].encoding !== "Identity-H") return {
      text: o,
      x: f,
      y: h,
      options: c,
      mutex: p
    };
    for (b = o, x = d, Array.isArray(o) && (b = o[0]), A = 0; A < b.length; A += 1) w[x].metadata.hasOwnProperty("cmap") && (s = w[x].metadata.cmap.unicode.codeMap[b[A].charCodeAt(0)]), s || b[A].charCodeAt(0) < 256 && w[x].metadata.hasOwnProperty("Unicode") ? S += b[A] : S += "";
    var q = "";
    return parseInt(x.slice(1)) < 14 || O === "WinAnsiEncoding" ? q = v(S, x).split("").map(function(te) {
      return te.charCodeAt(0).toString(16);
    }).join("") : O === "Identity-H" && (q = t(S, w[x])), p.isHex = true, {
      text: q,
      x: f,
      y: h,
      options: c,
      mutex: p
    };
  };
  e.events.push(["postProcessText", function(a) {
    var s = a.text || "", o = [], f = {
      text: s,
      x: a.x,
      y: a.y,
      options: a.options,
      mutex: a.mutex
    };
    if (Array.isArray(s)) {
      var h = 0;
      for (h = 0; h < s.length; h += 1) Array.isArray(s[h]) && s[h].length === 3 ? o.push([i(Object.assign({}, f, {
        text: s[h][0]
      })).text, s[h][1], s[h][2]]) : o.push(i(Object.assign({}, f, {
        text: s[h]
      })).text);
      a.text = o;
    } else a.text = i(Object.assign({}, f, {
      text: s
    })).text;
  }]);
}(ut), /**
* @license
* jsPDF virtual FileSystem functionality
*
* Licensed under the MIT License.
* http://opensource.org/licenses/mit-license
*/
function(r6) {
  var e = function() {
    return this.internal.vFS === void 0 && (this.internal.vFS = {}), true;
  };
  r6.existsFileInVFS = function(t) {
    return e.call(this), this.internal.vFS[t] !== void 0;
  }, r6.addFileToVFS = function(t, n) {
    return e.call(this), this.internal.vFS[t] = n, this;
  }, r6.getFileFromVFS = function(t) {
    return e.call(this), this.internal.vFS[t] !== void 0 ? this.internal.vFS[t] : null;
  };
}(ut.API), /**
* @license
* Unicode Bidi Engine based on the work of Alex Shensis (@asthensis)
* MIT License
*/
function(r6) {
  r6.__bidiEngine__ = r6.prototype.__bidiEngine__ = function(n) {
    var i, a, s, o, f, h, c, p = e, v = [[0, 3, 0, 1, 0, 0, 0], [0, 3, 0, 1, 2, 2, 0], [0, 3, 0, 17, 2, 0, 1], [0, 3, 5, 5, 4, 1, 0], [0, 3, 21, 21, 4, 0, 1], [0, 3, 5, 5, 4, 2, 0]], d = [[2, 0, 1, 1, 0, 1, 0], [2, 0, 1, 1, 0, 2, 0], [2, 0, 2, 1, 3, 2, 0], [2, 0, 2, 33, 3, 1, 1]], w = {
      L: 0,
      R: 1,
      EN: 2,
      AN: 3,
      N: 4,
      B: 5,
      S: 6
    }, x = {
      0: 0,
      5: 1,
      6: 2,
      7: 3,
      32: 4,
      251: 5,
      254: 6,
      255: 7
    }, S = ["(", ")", "(", "<", ">", "<", "[", "]", "[", "{", "}", "{", "«", "»", "«", "‹", "›", "‹", "⁅", "⁆", "⁅", "⁽", "⁾", "⁽", "₍", "₎", "₍", "≤", "≥", "≤", "〈", "〉", "〈", "﹙", "﹚", "﹙", "﹛", "﹜", "﹛", "﹝", "﹞", "﹝", "﹤", "﹥", "﹤"], A = new RegExp(/^([1-4|9]|1[0-9]|2[0-9]|3[0168]|4[04589]|5[012]|7[78]|159|16[0-9]|17[0-2]|21[569]|22[03489]|250)$/), b = false, O = 0;
    this.__bidiEngine__ = {};
    var q = function(F) {
      var P = F.charCodeAt(), Y = P >> 8, Q = x[Y];
      return Q !== void 0 ? p[256 * Q + (255 & P)] : Y === 252 || Y === 253 ? "AL" : A.test(Y) ? "L" : Y === 8 ? "R" : "N";
    }, te = function(F) {
      for (var P, Y = 0; Y < F.length; Y++) {
        if ((P = q(F.charAt(Y))) === "L") return false;
        if (P === "R") return true;
      }
      return false;
    }, le = function(F, P, Y, Q) {
      var ce, we, Se, de, Ae = P[Q];
      switch (Ae) {
        case "L":
        case "R":
          b = false;
          break;
        case "N":
        case "AN":
          break;
        case "EN":
          b && (Ae = "AN");
          break;
        case "AL":
          b = true, Ae = "R";
          break;
        case "WS":
          Ae = "N";
          break;
        case "CS":
          Q < 1 || Q + 1 >= P.length || (ce = Y[Q - 1]) !== "EN" && ce !== "AN" || (we = P[Q + 1]) !== "EN" && we !== "AN" ? Ae = "N" : b && (we = "AN"), Ae = we === ce ? we : "N";
          break;
        case "ES":
          Ae = (ce = Q > 0 ? Y[Q - 1] : "B") === "EN" && Q + 1 < P.length && P[Q + 1] === "EN" ? "EN" : "N";
          break;
        case "ET":
          if (Q > 0 && Y[Q - 1] === "EN") {
            Ae = "EN";
            break;
          }
          if (b) {
            Ae = "N";
            break;
          }
          for (Se = Q + 1, de = P.length; Se < de && P[Se] === "ET"; ) Se++;
          Ae = Se < de && P[Se] === "EN" ? "EN" : "N";
          break;
        case "NSM":
          if (s && !o) {
            for (de = P.length, Se = Q + 1; Se < de && P[Se] === "NSM"; ) Se++;
            if (Se < de) {
              var be = F[Q], ze = be >= 1425 && be <= 2303 || be === 64286;
              if (ce = P[Se], ze && (ce === "R" || ce === "AL")) {
                Ae = "R";
                break;
              }
            }
          }
          Ae = Q < 1 || (ce = P[Q - 1]) === "B" ? "N" : Y[Q - 1];
          break;
        case "B":
          b = false, i = true, Ae = O;
          break;
        case "S":
          a = true, Ae = "N";
          break;
        case "LRE":
        case "RLE":
        case "LRO":
        case "RLO":
        case "PDF":
          b = false;
          break;
        case "BN":
          Ae = "N";
      }
      return Ae;
    }, j = function(F, P, Y) {
      var Q = F.split("");
      return Y && M(Q, Y, {
        hiLevel: O
      }), Q.reverse(), P && P.reverse(), Q.join("");
    }, M = function(F, P, Y) {
      var Q, ce, we, Se, de, Ae = -1, be = F.length, ze = 0, y = [], L = O ? d : v, N = [];
      for (b = false, i = false, a = false, ce = 0; ce < be; ce++) N[ce] = q(F[ce]);
      for (we = 0; we < be; we++) {
        if (de = ze, y[we] = le(F, N, y, we), Q = 240 & (ze = L[de][w[y[we]]]), ze &= 15, P[we] = Se = L[ze][5], Q > 0) if (Q === 16) {
          for (ce = Ae; ce < we; ce++) P[ce] = 1;
          Ae = -1;
        } else Ae = -1;
        if (L[ze][6]) Ae === -1 && (Ae = we);
        else if (Ae > -1) {
          for (ce = Ae; ce < we; ce++) P[ce] = Se;
          Ae = -1;
        }
        N[we] === "B" && (P[we] = 0), Y.hiLevel |= Se;
      }
      a && function(C, z, re) {
        for (var se = 0; se < re; se++) if (C[se] === "S") {
          z[se] = O;
          for (var ie = se - 1; ie >= 0 && C[ie] === "WS"; ie--) z[ie] = O;
        }
      }(N, P, be);
    }, H = function(F, P, Y, Q, ce) {
      if (!(ce.hiLevel < F)) {
        if (F === 1 && O === 1 && !i) return P.reverse(), void (Y && Y.reverse());
        for (var we, Se, de, Ae, be = P.length, ze = 0; ze < be; ) {
          if (Q[ze] >= F) {
            for (de = ze + 1; de < be && Q[de] >= F; ) de++;
            for (Ae = ze, Se = de - 1; Ae < Se; Ae++, Se--) we = P[Ae], P[Ae] = P[Se], P[Se] = we, Y && (we = Y[Ae], Y[Ae] = Y[Se], Y[Se] = we);
            ze = de;
          }
          ze++;
        }
      }
    }, ee = function(F, P, Y) {
      var Q = F.split(""), ce = {
        hiLevel: O
      };
      return Y || (Y = []), M(Q, Y, ce), function(we, Se, de) {
        if (de.hiLevel !== 0 && c) for (var Ae, be = 0; be < we.length; be++) Se[be] === 1 && (Ae = S.indexOf(we[be])) >= 0 && (we[be] = S[Ae + 1]);
      }(Q, Y, ce), H(2, Q, P, Y, ce), H(1, Q, P, Y, ce), Q.join("");
    };
    return this.__bidiEngine__.doBidiReorder = function(F, P, Y) {
      if (function(ce, we) {
        if (we) for (var Se = 0; Se < ce.length; Se++) we[Se] = Se;
        o === void 0 && (o = te(ce)), h === void 0 && (h = te(ce));
      }(F, P), s || !f || h) {
        if (s && f && o ^ h) O = o ? 1 : 0, F = j(F, P, Y);
        else if (!s && f && h) O = o ? 1 : 0, F = ee(F, P, Y), F = j(F, P);
        else if (!s || o || f || h) {
          if (s && !f && o ^ h) F = j(F, P), o ? (O = 0, F = ee(F, P, Y)) : (O = 1, F = ee(F, P, Y), F = j(F, P));
          else if (s && o && !f && h) O = 1, F = ee(F, P, Y), F = j(F, P);
          else if (!s && !f && o ^ h) {
            var Q = c;
            o ? (O = 1, F = ee(F, P, Y), O = 0, c = false, F = ee(F, P, Y), c = Q) : (O = 0, F = ee(F, P, Y), F = j(F, P), O = 1, c = false, F = ee(F, P, Y), c = Q, F = j(F, P));
          }
        } else O = 0, F = ee(F, P, Y);
      } else O = o ? 1 : 0, F = ee(F, P, Y);
      return F;
    }, this.__bidiEngine__.setOptions = function(F) {
      F && (s = F.isInputVisual, f = F.isOutputVisual, o = F.isInputRtl, h = F.isOutputRtl, c = F.isSymmetricSwapping);
    }, this.__bidiEngine__.setOptions(n), this.__bidiEngine__;
  };
  var e = ["BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "S", "B", "S", "WS", "B", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "B", "B", "B", "S", "WS", "N", "N", "ET", "ET", "ET", "N", "N", "N", "N", "N", "ES", "CS", "ES", "CS", "CS", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "CS", "N", "N", "N", "N", "N", "N", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "N", "N", "N", "N", "N", "N", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "N", "N", "N", "N", "BN", "BN", "BN", "BN", "BN", "BN", "B", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "CS", "N", "ET", "ET", "ET", "ET", "N", "N", "N", "N", "L", "N", "N", "BN", "N", "N", "ET", "ET", "EN", "EN", "N", "L", "N", "N", "N", "EN", "L", "N", "N", "N", "N", "N", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "N", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "N", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "N", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "N", "N", "L", "L", "L", "L", "L", "L", "L", "N", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "N", "L", "N", "N", "N", "N", "N", "ET", "N", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "R", "NSM", "R", "NSM", "NSM", "R", "NSM", "NSM", "R", "NSM", "N", "N", "N", "N", "N", "N", "N", "N", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "N", "N", "N", "N", "N", "R", "R", "R", "R", "R", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "AN", "AN", "AN", "AN", "AN", "AN", "N", "N", "AL", "ET", "ET", "AL", "CS", "AL", "N", "N", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "AL", "AL", "N", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "AN", "AN", "AN", "AN", "AN", "AN", "AN", "AN", "AN", "AN", "ET", "AN", "AN", "AL", "AL", "AL", "NSM", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "AN", "N", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "AL", "AL", "NSM", "NSM", "N", "NSM", "NSM", "NSM", "NSM", "AL", "AL", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "N", "AL", "AL", "NSM", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "N", "N", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "AL", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "R", "R", "N", "N", "N", "N", "R", "N", "N", "N", "N", "N", "WS", "WS", "WS", "WS", "WS", "WS", "WS", "WS", "WS", "WS", "WS", "BN", "BN", "BN", "L", "R", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "WS", "B", "LRE", "RLE", "PDF", "LRO", "RLO", "CS", "ET", "ET", "ET", "ET", "ET", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "CS", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "WS", "BN", "BN", "BN", "BN", "BN", "N", "LRI", "RLI", "FSI", "PDI", "BN", "BN", "BN", "BN", "BN", "BN", "EN", "L", "N", "N", "EN", "EN", "EN", "EN", "EN", "EN", "ES", "ES", "N", "N", "N", "L", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "ES", "ES", "N", "N", "N", "N", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "N", "N", "N", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "L", "L", "L", "L", "L", "L", "L", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "L", "L", "L", "L", "L", "N", "N", "N", "N", "N", "R", "NSM", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "ES", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "N", "R", "R", "R", "R", "R", "N", "R", "N", "R", "R", "N", "R", "R", "N", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "CS", "N", "CS", "N", "N", "CS", "N", "N", "N", "N", "N", "N", "N", "N", "N", "ET", "N", "N", "ES", "ES", "N", "N", "N", "N", "N", "ET", "ET", "N", "N", "N", "N", "N", "AL", "AL", "AL", "AL", "AL", "N", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "N", "N", "BN", "N", "N", "N", "ET", "ET", "ET", "N", "N", "N", "N", "N", "ES", "CS", "ES", "CS", "CS", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "CS", "N", "N", "N", "N", "N", "N", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "N", "N", "N", "N", "N", "N", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "N", "N", "N", "L", "L", "L", "L", "L", "L", "N", "N", "L", "L", "L", "L", "L", "L", "N", "N", "L", "L", "L", "L", "L", "L", "N", "N", "L", "L", "L", "N", "N", "N", "ET", "ET", "N", "N", "N", "ET", "ET", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N"], t = new r6.__bidiEngine__({
    isInputVisual: true
  });
  r6.API.events.push(["postProcessText", function(n) {
    var i = n.text;
    n.x, n.y;
    var a = n.options || {};
    n.mutex, a.lang;
    var s = [];
    if (a.isInputVisual = typeof a.isInputVisual != "boolean" || a.isInputVisual, t.setOptions(a), Object.prototype.toString.call(i) === "[object Array]") {
      var o = 0;
      for (s = [], o = 0; o < i.length; o += 1) Object.prototype.toString.call(i[o]) === "[object Array]" ? s.push([t.doBidiReorder(i[o][0]), i[o][1], i[o][2]]) : s.push([t.doBidiReorder(i[o])]);
      n.text = s;
    } else n.text = t.doBidiReorder(i);
    t.setOptions({
      isInputVisual: true
    });
  }]);
}(ut), ut.API.TTFFont = function() {
  function r6(e) {
    var t;
    if (this.rawData = e, t = this.contents = new da(e), this.contents.pos = 4, t.readString(4) === "ttcf") throw new Error("TTCF not supported.");
    t.pos = 0, this.parse(), this.subset = new R3(this), this.registerTTF();
  }
  return r6.open = function(e) {
    return new r6(e);
  }, r6.prototype.parse = function() {
    return this.directory = new S3(this.contents), this.head = new b3(this), this.name = new L3(this), this.cmap = new Y1(this), this.toUnicode = {}, this.hhea = new T3(this), this.maxp = new C3(this), this.hmtx = new P3(this), this.post = new N3(this), this.os2 = new E3(this), this.loca = new I3(this), this.glyf = new k3(this), this.ascender = this.os2.exists && this.os2.ascender || this.hhea.ascender, this.decender = this.os2.exists && this.os2.decender || this.hhea.decender, this.lineGap = this.os2.exists && this.os2.lineGap || this.hhea.lineGap, this.bbox = [this.head.xMin, this.head.yMin, this.head.xMax, this.head.yMax];
  }, r6.prototype.registerTTF = function() {
    var e, t, n, i, a;
    if (this.scaleFactor = 1e3 / this.head.unitsPerEm, this.bbox = function() {
      var s, o, f, h;
      for (h = [], s = 0, o = (f = this.bbox).length; s < o; s++) e = f[s], h.push(Math.round(e * this.scaleFactor));
      return h;
    }.call(this), this.stemV = 0, this.post.exists ? (n = 255 & (i = this.post.italic_angle), 32768 & (t = i >> 16) && (t = -(1 + (65535 ^ t))), this.italicAngle = +(t + "." + n)) : this.italicAngle = 0, this.ascender = Math.round(this.ascender * this.scaleFactor), this.decender = Math.round(this.decender * this.scaleFactor), this.lineGap = Math.round(this.lineGap * this.scaleFactor), this.capHeight = this.os2.exists && this.os2.capHeight || this.ascender, this.xHeight = this.os2.exists && this.os2.xHeight || 0, this.familyClass = (this.os2.exists && this.os2.familyClass || 0) >> 8, this.isSerif = (a = this.familyClass) === 1 || a === 2 || a === 3 || a === 4 || a === 5 || a === 7, this.isScript = this.familyClass === 10, this.flags = 0, this.post.isFixedPitch && (this.flags |= 1), this.isSerif && (this.flags |= 2), this.isScript && (this.flags |= 8), this.italicAngle !== 0 && (this.flags |= 64), this.flags |= 32, !this.cmap.unicode) throw new Error("No unicode cmap for font");
  }, r6.prototype.characterToGlyph = function(e) {
    var t;
    return ((t = this.cmap.unicode) != null ? t.codeMap[e] : void 0) || 0;
  }, r6.prototype.widthOfGlyph = function(e) {
    var t;
    return t = 1e3 / this.head.unitsPerEm, this.hmtx.forGlyph(e).advance * t;
  }, r6.prototype.widthOfString = function(e, t, n) {
    var i, a, s, o;
    for (s = 0, a = 0, o = (e = "" + e).length; 0 <= o ? a < o : a > o; a = 0 <= o ? ++a : --a) i = e.charCodeAt(a), s += this.widthOfGlyph(this.characterToGlyph(i)) + n * (1e3 / t) || 0;
    return s * (t / 1e3);
  }, r6.prototype.lineHeight = function(e, t) {
    var n;
    return t == null && (t = false), n = t ? this.lineGap : 0, (this.ascender + n - this.decender) / 1e3 * e;
  }, r6;
}();
var si;
var da = function() {
  function r6(e) {
    this.data = e ?? [], this.pos = 0, this.length = this.data.length;
  }
  return r6.prototype.readByte = function() {
    return this.data[this.pos++];
  }, r6.prototype.writeByte = function(e) {
    return this.data[this.pos++] = e;
  }, r6.prototype.readUInt32 = function() {
    return 16777216 * this.readByte() + (this.readByte() << 16) + (this.readByte() << 8) + this.readByte();
  }, r6.prototype.writeUInt32 = function(e) {
    return this.writeByte(e >>> 24 & 255), this.writeByte(e >> 16 & 255), this.writeByte(e >> 8 & 255), this.writeByte(255 & e);
  }, r6.prototype.readInt32 = function() {
    var e;
    return (e = this.readUInt32()) >= 2147483648 ? e - 4294967296 : e;
  }, r6.prototype.writeInt32 = function(e) {
    return e < 0 && (e += 4294967296), this.writeUInt32(e);
  }, r6.prototype.readUInt16 = function() {
    return this.readByte() << 8 | this.readByte();
  }, r6.prototype.writeUInt16 = function(e) {
    return this.writeByte(e >> 8 & 255), this.writeByte(255 & e);
  }, r6.prototype.readInt16 = function() {
    var e;
    return (e = this.readUInt16()) >= 32768 ? e - 65536 : e;
  }, r6.prototype.writeInt16 = function(e) {
    return e < 0 && (e += 65536), this.writeUInt16(e);
  }, r6.prototype.readString = function(e) {
    var t, n;
    for (n = [], t = 0; 0 <= e ? t < e : t > e; t = 0 <= e ? ++t : --t) n[t] = String.fromCharCode(this.readByte());
    return n.join("");
  }, r6.prototype.writeString = function(e) {
    var t, n, i;
    for (i = [], t = 0, n = e.length; 0 <= n ? t < n : t > n; t = 0 <= n ? ++t : --t) i.push(this.writeByte(e.charCodeAt(t)));
    return i;
  }, r6.prototype.readShort = function() {
    return this.readInt16();
  }, r6.prototype.writeShort = function(e) {
    return this.writeInt16(e);
  }, r6.prototype.readLongLong = function() {
    var e, t, n, i, a, s, o, f;
    return e = this.readByte(), t = this.readByte(), n = this.readByte(), i = this.readByte(), a = this.readByte(), s = this.readByte(), o = this.readByte(), f = this.readByte(), 128 & e ? -1 * (72057594037927940 * (255 ^ e) + 281474976710656 * (255 ^ t) + 1099511627776 * (255 ^ n) + 4294967296 * (255 ^ i) + 16777216 * (255 ^ a) + 65536 * (255 ^ s) + 256 * (255 ^ o) + (255 ^ f) + 1) : 72057594037927940 * e + 281474976710656 * t + 1099511627776 * n + 4294967296 * i + 16777216 * a + 65536 * s + 256 * o + f;
  }, r6.prototype.writeLongLong = function(e) {
    var t, n;
    return t = Math.floor(e / 4294967296), n = 4294967295 & e, this.writeByte(t >> 24 & 255), this.writeByte(t >> 16 & 255), this.writeByte(t >> 8 & 255), this.writeByte(255 & t), this.writeByte(n >> 24 & 255), this.writeByte(n >> 16 & 255), this.writeByte(n >> 8 & 255), this.writeByte(255 & n);
  }, r6.prototype.readInt = function() {
    return this.readInt32();
  }, r6.prototype.writeInt = function(e) {
    return this.writeInt32(e);
  }, r6.prototype.read = function(e) {
    var t, n;
    for (t = [], n = 0; 0 <= e ? n < e : n > e; n = 0 <= e ? ++n : --n) t.push(this.readByte());
    return t;
  }, r6.prototype.write = function(e) {
    var t, n, i, a;
    for (a = [], n = 0, i = e.length; n < i; n++) t = e[n], a.push(this.writeByte(t));
    return a;
  }, r6;
}();
var S3 = function() {
  var r6;
  function e(t) {
    var n, i, a;
    for (this.scalarType = t.readInt(), this.tableCount = t.readShort(), this.searchRange = t.readShort(), this.entrySelector = t.readShort(), this.rangeShift = t.readShort(), this.tables = {}, i = 0, a = this.tableCount; 0 <= a ? i < a : i > a; i = 0 <= a ? ++i : --i) n = {
      tag: t.readString(4),
      checksum: t.readInt(),
      offset: t.readInt(),
      length: t.readInt()
    }, this.tables[n.tag] = n;
  }
  return e.prototype.encode = function(t) {
    var n, i, a, s, o, f, h, c, p, v, d, w, x;
    for (x in d = Object.keys(t).length, f = Math.log(2), p = 16 * Math.floor(Math.log(d) / f), s = Math.floor(p / f), c = 16 * d - p, (i = new da()).writeInt(this.scalarType), i.writeShort(d), i.writeShort(p), i.writeShort(s), i.writeShort(c), a = 16 * d, h = i.pos + a, o = null, w = [], t) for (v = t[x], i.writeString(x), i.writeInt(r6(v)), i.writeInt(h), i.writeInt(v.length), w = w.concat(v), x === "head" && (o = h), h += v.length; h % 4; ) w.push(0), h++;
    return i.write(w), n = 2981146554 - r6(i.data), i.pos = o + 8, i.writeUInt32(n), i.data;
  }, r6 = function(t) {
    var n, i, a, s;
    for (t = $1.call(t); t.length % 4; ) t.push(0);
    for (a = new da(t), i = 0, n = 0, s = t.length; n < s; n = n += 4) i += a.readUInt32();
    return 4294967295 & i;
  }, e;
}();
var A3 = {}.hasOwnProperty;
var yi = function(r6, e) {
  for (var t in e) A3.call(e, t) && (r6[t] = e[t]);
  function n() {
    this.constructor = r6;
  }
  return n.prototype = e.prototype, r6.prototype = new n(), r6.__super__ = e.prototype, r6;
};
si = function() {
  function r6(e) {
    var t;
    this.file = e, t = this.file.directory.tables[this.tag], this.exists = !!t, t && (this.offset = t.offset, this.length = t.length, this.parse(this.file.contents));
  }
  return r6.prototype.parse = function() {
  }, r6.prototype.encode = function() {
  }, r6.prototype.raw = function() {
    return this.exists ? (this.file.contents.pos = this.offset, this.file.contents.read(this.length)) : null;
  }, r6;
}();
var b3 = function(r6) {
  function e() {
    return e.__super__.constructor.apply(this, arguments);
  }
  return yi(e, si), e.prototype.tag = "head", e.prototype.parse = function(t) {
    return t.pos = this.offset, this.version = t.readInt(), this.revision = t.readInt(), this.checkSumAdjustment = t.readInt(), this.magicNumber = t.readInt(), this.flags = t.readShort(), this.unitsPerEm = t.readShort(), this.created = t.readLongLong(), this.modified = t.readLongLong(), this.xMin = t.readShort(), this.yMin = t.readShort(), this.xMax = t.readShort(), this.yMax = t.readShort(), this.macStyle = t.readShort(), this.lowestRecPPEM = t.readShort(), this.fontDirectionHint = t.readShort(), this.indexToLocFormat = t.readShort(), this.glyphDataFormat = t.readShort();
  }, e.prototype.encode = function(t) {
    var n;
    return (n = new da()).writeInt(this.version), n.writeInt(this.revision), n.writeInt(this.checkSumAdjustment), n.writeInt(this.magicNumber), n.writeShort(this.flags), n.writeShort(this.unitsPerEm), n.writeLongLong(this.created), n.writeLongLong(this.modified), n.writeShort(this.xMin), n.writeShort(this.yMin), n.writeShort(this.xMax), n.writeShort(this.yMax), n.writeShort(this.macStyle), n.writeShort(this.lowestRecPPEM), n.writeShort(this.fontDirectionHint), n.writeShort(t), n.writeShort(this.glyphDataFormat), n.data;
  }, e;
}();
var Uc = function() {
  function r6(e, t) {
    var n, i, a, s, o, f, h, c, p, v, d, w, x, S, A, b, O;
    switch (this.platformID = e.readUInt16(), this.encodingID = e.readShort(), this.offset = t + e.readInt(), p = e.pos, e.pos = this.offset, this.format = e.readUInt16(), this.length = e.readUInt16(), this.language = e.readUInt16(), this.isUnicode = this.platformID === 3 && this.encodingID === 1 && this.format === 4 || this.platformID === 0 && this.format === 4, this.codeMap = {}, this.format) {
      case 0:
        for (f = 0; f < 256; ++f) this.codeMap[f] = e.readByte();
        break;
      case 4:
        for (d = e.readUInt16(), v = d / 2, e.pos += 6, a = function() {
          var q, te;
          for (te = [], f = q = 0; 0 <= v ? q < v : q > v; f = 0 <= v ? ++q : --q) te.push(e.readUInt16());
          return te;
        }(), e.pos += 2, x = function() {
          var q, te;
          for (te = [], f = q = 0; 0 <= v ? q < v : q > v; f = 0 <= v ? ++q : --q) te.push(e.readUInt16());
          return te;
        }(), h = function() {
          var q, te;
          for (te = [], f = q = 0; 0 <= v ? q < v : q > v; f = 0 <= v ? ++q : --q) te.push(e.readUInt16());
          return te;
        }(), c = function() {
          var q, te;
          for (te = [], f = q = 0; 0 <= v ? q < v : q > v; f = 0 <= v ? ++q : --q) te.push(e.readUInt16());
          return te;
        }(), i = (this.length - e.pos + this.offset) / 2, o = function() {
          var q, te;
          for (te = [], f = q = 0; 0 <= i ? q < i : q > i; f = 0 <= i ? ++q : --q) te.push(e.readUInt16());
          return te;
        }(), f = A = 0, O = a.length; A < O; f = ++A) for (S = a[f], n = b = w = x[f]; w <= S ? b <= S : b >= S; n = w <= S ? ++b : --b) c[f] === 0 ? s = n + h[f] : (s = o[c[f] / 2 + (n - w) - (v - f)] || 0) !== 0 && (s += h[f]), this.codeMap[n] = 65535 & s;
    }
    e.pos = p;
  }
  return r6.encode = function(e, t) {
    var n, i, a, s, o, f, h, c, p, v, d, w, x, S, A, b, O, q, te, le, j, M, H, ee, F, P, Y, Q, ce, we, Se, de, Ae, be, ze, y, L, N, C, z, re, se, ie, ve, Ce, Oe;
    switch (Q = new da(), s = Object.keys(e).sort(function(qe, Ye) {
      return qe - Ye;
    }), t) {
      case "macroman":
        for (x = 0, S = function() {
          var qe = [];
          for (w = 0; w < 256; ++w) qe.push(0);
          return qe;
        }(), b = {
          0: 0
        }, a = {}, ce = 0, Ae = s.length; ce < Ae; ce++) b[ie = e[i = s[ce]]] == null && (b[ie] = ++x), a[i] = {
          old: e[i],
          new: b[e[i]]
        }, S[i] = b[e[i]];
        return Q.writeUInt16(1), Q.writeUInt16(0), Q.writeUInt32(12), Q.writeUInt16(0), Q.writeUInt16(262), Q.writeUInt16(0), Q.write(S), {
          charMap: a,
          subtable: Q.data,
          maxGlyphID: x + 1
        };
      case "unicode":
        for (P = [], p = [], O = 0, b = {}, n = {}, A = h = null, we = 0, be = s.length; we < be; we++) b[te = e[i = s[we]]] == null && (b[te] = ++O), n[i] = {
          old: te,
          new: b[te]
        }, o = b[te] - i, A != null && o === h || (A && p.push(A), P.push(i), h = o), A = i;
        for (A && p.push(A), p.push(65535), P.push(65535), ee = 2 * (H = P.length), M = 2 * Math.pow(Math.log(H) / Math.LN2, 2), v = Math.log(M / 2) / Math.LN2, j = 2 * H - M, f = [], le = [], d = [], w = Se = 0, ze = P.length; Se < ze; w = ++Se) {
          if (F = P[w], c = p[w], F === 65535) {
            f.push(0), le.push(0);
            break;
          }
          if (F - (Y = n[F].new) >= 32768) for (f.push(0), le.push(2 * (d.length + H - w)), i = de = F; F <= c ? de <= c : de >= c; i = F <= c ? ++de : --de) d.push(n[i].new);
          else f.push(Y - F), le.push(0);
        }
        for (Q.writeUInt16(3), Q.writeUInt16(1), Q.writeUInt32(12), Q.writeUInt16(4), Q.writeUInt16(16 + 8 * H + 2 * d.length), Q.writeUInt16(0), Q.writeUInt16(ee), Q.writeUInt16(M), Q.writeUInt16(v), Q.writeUInt16(j), re = 0, y = p.length; re < y; re++) i = p[re], Q.writeUInt16(i);
        for (Q.writeUInt16(0), se = 0, L = P.length; se < L; se++) i = P[se], Q.writeUInt16(i);
        for (ve = 0, N = f.length; ve < N; ve++) o = f[ve], Q.writeUInt16(o);
        for (Ce = 0, C = le.length; Ce < C; Ce++) q = le[Ce], Q.writeUInt16(q);
        for (Oe = 0, z = d.length; Oe < z; Oe++) x = d[Oe], Q.writeUInt16(x);
        return {
          charMap: n,
          subtable: Q.data,
          maxGlyphID: O + 1
        };
    }
  }, r6;
}();
var Y1 = function(r6) {
  function e() {
    return e.__super__.constructor.apply(this, arguments);
  }
  return yi(e, si), e.prototype.tag = "cmap", e.prototype.parse = function(t) {
    var n, i, a;
    for (t.pos = this.offset, this.version = t.readUInt16(), a = t.readUInt16(), this.tables = [], this.unicode = null, i = 0; 0 <= a ? i < a : i > a; i = 0 <= a ? ++i : --i) n = new Uc(t, this.offset), this.tables.push(n), n.isUnicode && this.unicode == null && (this.unicode = n);
    return true;
  }, e.encode = function(t, n) {
    var i, a;
    return n == null && (n = "macroman"), i = Uc.encode(t, n), (a = new da()).writeUInt16(0), a.writeUInt16(1), i.table = a.data.concat(i.subtable), i;
  }, e;
}();
var T3 = function(r6) {
  function e() {
    return e.__super__.constructor.apply(this, arguments);
  }
  return yi(e, si), e.prototype.tag = "hhea", e.prototype.parse = function(t) {
    return t.pos = this.offset, this.version = t.readInt(), this.ascender = t.readShort(), this.decender = t.readShort(), this.lineGap = t.readShort(), this.advanceWidthMax = t.readShort(), this.minLeftSideBearing = t.readShort(), this.minRightSideBearing = t.readShort(), this.xMaxExtent = t.readShort(), this.caretSlopeRise = t.readShort(), this.caretSlopeRun = t.readShort(), this.caretOffset = t.readShort(), t.pos += 8, this.metricDataFormat = t.readShort(), this.numberOfMetrics = t.readUInt16();
  }, e;
}();
var E3 = function(r6) {
  function e() {
    return e.__super__.constructor.apply(this, arguments);
  }
  return yi(e, si), e.prototype.tag = "OS/2", e.prototype.parse = function(t) {
    if (t.pos = this.offset, this.version = t.readUInt16(), this.averageCharWidth = t.readShort(), this.weightClass = t.readUInt16(), this.widthClass = t.readUInt16(), this.type = t.readShort(), this.ySubscriptXSize = t.readShort(), this.ySubscriptYSize = t.readShort(), this.ySubscriptXOffset = t.readShort(), this.ySubscriptYOffset = t.readShort(), this.ySuperscriptXSize = t.readShort(), this.ySuperscriptYSize = t.readShort(), this.ySuperscriptXOffset = t.readShort(), this.ySuperscriptYOffset = t.readShort(), this.yStrikeoutSize = t.readShort(), this.yStrikeoutPosition = t.readShort(), this.familyClass = t.readShort(), this.panose = function() {
      var n, i;
      for (i = [], n = 0; n < 10; ++n) i.push(t.readByte());
      return i;
    }(), this.charRange = function() {
      var n, i;
      for (i = [], n = 0; n < 4; ++n) i.push(t.readInt());
      return i;
    }(), this.vendorID = t.readString(4), this.selection = t.readShort(), this.firstCharIndex = t.readShort(), this.lastCharIndex = t.readShort(), this.version > 0 && (this.ascent = t.readShort(), this.descent = t.readShort(), this.lineGap = t.readShort(), this.winAscent = t.readShort(), this.winDescent = t.readShort(), this.codePageRange = function() {
      var n, i;
      for (i = [], n = 0; n < 2; n = ++n) i.push(t.readInt());
      return i;
    }(), this.version > 1)) return this.xHeight = t.readShort(), this.capHeight = t.readShort(), this.defaultChar = t.readShort(), this.breakChar = t.readShort(), this.maxContext = t.readShort();
  }, e;
}();
var N3 = function(r6) {
  function e() {
    return e.__super__.constructor.apply(this, arguments);
  }
  return yi(e, si), e.prototype.tag = "post", e.prototype.parse = function(t) {
    var n, i, a;
    switch (t.pos = this.offset, this.format = t.readInt(), this.italicAngle = t.readInt(), this.underlinePosition = t.readShort(), this.underlineThickness = t.readShort(), this.isFixedPitch = t.readInt(), this.minMemType42 = t.readInt(), this.maxMemType42 = t.readInt(), this.minMemType1 = t.readInt(), this.maxMemType1 = t.readInt(), this.format) {
      case 65536:
        break;
      case 131072:
        var s;
        for (i = t.readUInt16(), this.glyphNameIndex = [], s = 0; 0 <= i ? s < i : s > i; s = 0 <= i ? ++s : --s) this.glyphNameIndex.push(t.readUInt16());
        for (this.names = [], a = []; t.pos < this.offset + this.length; ) n = t.readByte(), a.push(this.names.push(t.readString(n)));
        return a;
      case 151552:
        return i = t.readUInt16(), this.offsets = t.read(i);
      case 196608:
        break;
      case 262144:
        return this.map = function() {
          var o, f, h;
          for (h = [], s = o = 0, f = this.file.maxp.numGlyphs; 0 <= f ? o < f : o > f; s = 0 <= f ? ++o : --o) h.push(t.readUInt32());
          return h;
        }.call(this);
    }
  }, e;
}();
var F3 = function(r6, e) {
  this.raw = r6, this.length = r6.length, this.platformID = e.platformID, this.encodingID = e.encodingID, this.languageID = e.languageID;
};
var L3 = function(r6) {
  function e() {
    return e.__super__.constructor.apply(this, arguments);
  }
  return yi(e, si), e.prototype.tag = "name", e.prototype.parse = function(t) {
    var n, i, a, s, o, f, h, c, p, v, d;
    for (t.pos = this.offset, t.readShort(), n = t.readShort(), f = t.readShort(), i = [], s = 0; 0 <= n ? s < n : s > n; s = 0 <= n ? ++s : --s) i.push({
      platformID: t.readShort(),
      encodingID: t.readShort(),
      languageID: t.readShort(),
      nameID: t.readShort(),
      length: t.readShort(),
      offset: this.offset + f + t.readShort()
    });
    for (h = {}, s = p = 0, v = i.length; p < v; s = ++p) a = i[s], t.pos = a.offset, c = t.readString(a.length), o = new F3(c, a), h[d = a.nameID] == null && (h[d] = []), h[a.nameID].push(o);
    this.strings = h, this.copyright = h[0], this.fontFamily = h[1], this.fontSubfamily = h[2], this.uniqueSubfamily = h[3], this.fontName = h[4], this.version = h[5];
    try {
      this.postscriptName = h[6][0].raw.replace(/[\x00-\x19\x80-\xff]/g, "");
    } catch {
      this.postscriptName = h[4][0].raw.replace(/[\x00-\x19\x80-\xff]/g, "");
    }
    return this.trademark = h[7], this.manufacturer = h[8], this.designer = h[9], this.description = h[10], this.vendorUrl = h[11], this.designerUrl = h[12], this.license = h[13], this.licenseUrl = h[14], this.preferredFamily = h[15], this.preferredSubfamily = h[17], this.compatibleFull = h[18], this.sampleText = h[19];
  }, e;
}();
var C3 = function(r6) {
  function e() {
    return e.__super__.constructor.apply(this, arguments);
  }
  return yi(e, si), e.prototype.tag = "maxp", e.prototype.parse = function(t) {
    return t.pos = this.offset, this.version = t.readInt(), this.numGlyphs = t.readUInt16(), this.maxPoints = t.readUInt16(), this.maxContours = t.readUInt16(), this.maxCompositePoints = t.readUInt16(), this.maxComponentContours = t.readUInt16(), this.maxZones = t.readUInt16(), this.maxTwilightPoints = t.readUInt16(), this.maxStorage = t.readUInt16(), this.maxFunctionDefs = t.readUInt16(), this.maxInstructionDefs = t.readUInt16(), this.maxStackElements = t.readUInt16(), this.maxSizeOfInstructions = t.readUInt16(), this.maxComponentElements = t.readUInt16(), this.maxComponentDepth = t.readUInt16();
  }, e;
}();
var P3 = function(r6) {
  function e() {
    return e.__super__.constructor.apply(this, arguments);
  }
  return yi(e, si), e.prototype.tag = "hmtx", e.prototype.parse = function(t) {
    var n, i, a, s, o, f, h;
    for (t.pos = this.offset, this.metrics = [], n = 0, f = this.file.hhea.numberOfMetrics; 0 <= f ? n < f : n > f; n = 0 <= f ? ++n : --n) this.metrics.push({
      advance: t.readUInt16(),
      lsb: t.readInt16()
    });
    for (a = this.file.maxp.numGlyphs - this.file.hhea.numberOfMetrics, this.leftSideBearings = function() {
      var c, p;
      for (p = [], n = c = 0; 0 <= a ? c < a : c > a; n = 0 <= a ? ++c : --c) p.push(t.readInt16());
      return p;
    }(), this.widths = function() {
      var c, p, v, d;
      for (d = [], c = 0, p = (v = this.metrics).length; c < p; c++) s = v[c], d.push(s.advance);
      return d;
    }.call(this), i = this.widths[this.widths.length - 1], h = [], n = o = 0; 0 <= a ? o < a : o > a; n = 0 <= a ? ++o : --o) h.push(this.widths.push(i));
    return h;
  }, e.prototype.forGlyph = function(t) {
    return t in this.metrics ? this.metrics[t] : {
      advance: this.metrics[this.metrics.length - 1].advance,
      lsb: this.leftSideBearings[t - this.metrics.length]
    };
  }, e;
}();
var $1 = [].slice;
var k3 = function(r6) {
  function e() {
    return e.__super__.constructor.apply(this, arguments);
  }
  return yi(e, si), e.prototype.tag = "glyf", e.prototype.parse = function() {
    return this.cache = {};
  }, e.prototype.glyphFor = function(t) {
    var n, i, a, s, o, f, h, c, p, v;
    return t in this.cache ? this.cache[t] : (s = this.file.loca, n = this.file.contents, i = s.indexOf(t), (a = s.lengthOf(t)) === 0 ? this.cache[t] = null : (n.pos = this.offset + i, o = (f = new da(n.read(a))).readShort(), c = f.readShort(), v = f.readShort(), h = f.readShort(), p = f.readShort(), this.cache[t] = o === -1 ? new O3(f, c, v, h, p) : new D3(f, o, c, v, h, p), this.cache[t]));
  }, e.prototype.encode = function(t, n, i) {
    var a, s, o, f, h;
    for (o = [], s = [], f = 0, h = n.length; f < h; f++) a = t[n[f]], s.push(o.length), a && (o = o.concat(a.encode(i)));
    return s.push(o.length), {
      table: o,
      offsets: s
    };
  }, e;
}();
var D3 = function() {
  function r6(e, t, n, i, a, s) {
    this.raw = e, this.numberOfContours = t, this.xMin = n, this.yMin = i, this.xMax = a, this.yMax = s, this.compound = false;
  }
  return r6.prototype.encode = function() {
    return this.raw.data;
  }, r6;
}();
var O3 = function() {
  function r6(e, t, n, i, a) {
    var s, o;
    for (this.raw = e, this.xMin = t, this.yMin = n, this.xMax = i, this.yMax = a, this.compound = true, this.glyphIDs = [], this.glyphOffsets = [], s = this.raw; o = s.readShort(), this.glyphOffsets.push(s.pos), this.glyphIDs.push(s.readUInt16()), 32 & o; ) s.pos += 1 & o ? 4 : 2, 128 & o ? s.pos += 8 : 64 & o ? s.pos += 4 : 8 & o && (s.pos += 2);
  }
  return r6.prototype.encode = function() {
    var e, t, n;
    for (t = new da($1.call(this.raw.data)), e = 0, n = this.glyphIDs.length; e < n; ++e) t.pos = this.glyphOffsets[e];
    return t.data;
  }, r6;
}();
var I3 = function(r6) {
  function e() {
    return e.__super__.constructor.apply(this, arguments);
  }
  return yi(e, si), e.prototype.tag = "loca", e.prototype.parse = function(t) {
    var n, i;
    return t.pos = this.offset, n = this.file.head.indexToLocFormat, this.offsets = n === 0 ? function() {
      var a, s;
      for (s = [], i = 0, a = this.length; i < a; i += 2) s.push(2 * t.readUInt16());
      return s;
    }.call(this) : function() {
      var a, s;
      for (s = [], i = 0, a = this.length; i < a; i += 4) s.push(t.readUInt32());
      return s;
    }.call(this);
  }, e.prototype.indexOf = function(t) {
    return this.offsets[t];
  }, e.prototype.lengthOf = function(t) {
    return this.offsets[t + 1] - this.offsets[t];
  }, e.prototype.encode = function(t, n) {
    for (var i = new Uint32Array(this.offsets.length), a = 0, s = 0, o = 0; o < i.length; ++o) if (i[o] = a, s < n.length && n[s] == o) {
      ++s, i[o] = a;
      var f = this.offsets[o], h = this.offsets[o + 1] - f;
      h > 0 && (a += h);
    }
    for (var c = new Array(4 * i.length), p = 0; p < i.length; ++p) c[4 * p + 3] = 255 & i[p], c[4 * p + 2] = (65280 & i[p]) >> 8, c[4 * p + 1] = (16711680 & i[p]) >> 16, c[4 * p] = (4278190080 & i[p]) >> 24;
    return c;
  }, e;
}();
var R3 = function() {
  function r6(e) {
    this.font = e, this.subset = {}, this.unicodes = {}, this.next = 33;
  }
  return r6.prototype.generateCmap = function() {
    var e, t, n, i, a;
    for (t in i = this.font.cmap.tables[0].codeMap, e = {}, a = this.subset) n = a[t], e[t] = i[n];
    return e;
  }, r6.prototype.glyphsFor = function(e) {
    var t, n, i, a, s, o, f;
    for (i = {}, s = 0, o = e.length; s < o; s++) i[a = e[s]] = this.font.glyf.glyphFor(a);
    for (a in t = [], i) (n = i[a]) != null && n.compound && t.push.apply(t, n.glyphIDs);
    if (t.length > 0) for (a in f = this.glyphsFor(t)) n = f[a], i[a] = n;
    return i;
  }, r6.prototype.encode = function(e, t) {
    var n, i, a, s, o, f, h, c, p, v, d, w, x, S, A;
    for (i in n = Y1.encode(this.generateCmap(), "unicode"), s = this.glyphsFor(e), d = {
      0: 0
    }, A = n.charMap) d[(f = A[i]).old] = f.new;
    for (w in v = n.maxGlyphID, s) w in d || (d[w] = v++);
    return c = function(b) {
      var O, q;
      for (O in q = {}, b) q[b[O]] = O;
      return q;
    }(d), p = Object.keys(c).sort(function(b, O) {
      return b - O;
    }), x = function() {
      var b, O, q;
      for (q = [], b = 0, O = p.length; b < O; b++) o = p[b], q.push(c[o]);
      return q;
    }(), a = this.font.glyf.encode(s, x, d), h = this.font.loca.encode(a.offsets, x), S = {
      cmap: this.font.cmap.raw(),
      glyf: a.table,
      loca: h,
      hmtx: this.font.hmtx.raw(),
      hhea: this.font.hhea.raw(),
      maxp: this.font.maxp.raw(),
      post: this.font.post.raw(),
      name: this.font.name.raw(),
      head: this.font.head.encode(t)
    }, this.font.os2.exists && (S["OS/2"] = this.font.os2.raw()), this.font.directory.encode(S);
  }, r6;
}();
ut.API.PDFObject = function() {
  var r6;
  function e() {
  }
  return r6 = function(t, n) {
    return (Array(n + 1).join("0") + t).slice(-n);
  }, e.convert = function(t) {
    var n, i, a, s;
    if (Array.isArray(t)) return "[" + function() {
      var o, f, h;
      for (h = [], o = 0, f = t.length; o < f; o++) n = t[o], h.push(e.convert(n));
      return h;
    }().join(" ") + "]";
    if (typeof t == "string") return "/" + t;
    if (t != null && t.isString) return "(" + t + ")";
    if (t instanceof Date) return "(D:" + r6(t.getUTCFullYear(), 4) + r6(t.getUTCMonth(), 2) + r6(t.getUTCDate(), 2) + r6(t.getUTCHours(), 2) + r6(t.getUTCMinutes(), 2) + r6(t.getUTCSeconds(), 2) + "Z)";
    if ({}.toString.call(t) === "[object Object]") {
      for (i in a = ["<<"], t) s = t[i], a.push("/" + i + " " + e.convert(s));
      return a.push(">>"), a.join(`
`);
    }
    return "" + t;
  }, e;
}();
function K1(r6, e, t, n, i) {
  n = n || {};
  var a = 1.15, s = i.internal.scaleFactor, o = i.internal.getFontSize() / s, f = i.getLineHeightFactor ? i.getLineHeightFactor() : a, h = o * f, c = /\r\n|\r|\n/g, p = "", v = 1;
  if ((n.valign === "middle" || n.valign === "bottom" || n.halign === "center" || n.halign === "right") && (p = typeof r6 == "string" ? r6.split(c) : r6, v = p.length || 1), t += o * (2 - a), n.valign === "middle" ? t -= v / 2 * h : n.valign === "bottom" && (t -= v * h), n.halign === "center" || n.halign === "right") {
    var d = o;
    if (n.halign === "center" && (d *= 0.5), p && v >= 1) {
      for (var w = 0; w < p.length; w++) i.text(p[w], e - i.getStringUnitWidth(p[w]) * d, t), t += h;
      return i;
    }
    e -= i.getStringUnitWidth(r6) * d;
  }
  return n.halign === "justify" ? i.text(r6, e, t, {
    maxWidth: n.maxWidth || 100,
    align: "justify"
  }) : i.text(r6, e, t), i;
}
var qc = {};
var Es = (
  /** @class */
  function() {
    function r6(e) {
      this.jsPDFDocument = e, this.userStyles = {
        // Black for versions of jspdf without getTextColor
        textColor: e.getTextColor ? this.jsPDFDocument.getTextColor() : 0,
        fontSize: e.internal.getFontSize(),
        fontStyle: e.internal.getFont().fontStyle,
        font: e.internal.getFont().fontName,
        // 0 for versions of jspdf without getLineWidth
        lineWidth: e.getLineWidth ? this.jsPDFDocument.getLineWidth() : 0,
        // Black for versions of jspdf without getDrawColor
        lineColor: e.getDrawColor ? this.jsPDFDocument.getDrawColor() : 0
      };
    }
    return r6.setDefaults = function(e, t) {
      t === void 0 && (t = null), t ? t.__autoTableDocumentDefaults = e : qc = e;
    }, r6.unifyColor = function(e) {
      return Array.isArray(e) ? e : typeof e == "number" ? [e, e, e] : typeof e == "string" ? [e] : null;
    }, r6.prototype.applyStyles = function(e, t) {
      var n, i, a;
      t === void 0 && (t = false), e.fontStyle && this.jsPDFDocument.setFontStyle && this.jsPDFDocument.setFontStyle(e.fontStyle);
      var s = this.jsPDFDocument.internal.getFont(), o = s.fontStyle, f = s.fontName;
      if (e.font && (f = e.font), e.fontStyle) {
        o = e.fontStyle;
        var h = this.getFontList()[f];
        h && h.indexOf(o) === -1 && this.jsPDFDocument.setFontStyle && (this.jsPDFDocument.setFontStyle(h[0]), o = h[0]);
      }
      if (this.jsPDFDocument.setFont(f, o), e.fontSize && this.jsPDFDocument.setFontSize(e.fontSize), !t) {
        var c = r6.unifyColor(e.fillColor);
        c && (n = this.jsPDFDocument).setFillColor.apply(n, c), c = r6.unifyColor(e.textColor), c && (i = this.jsPDFDocument).setTextColor.apply(i, c), c = r6.unifyColor(e.lineColor), c && (a = this.jsPDFDocument).setDrawColor.apply(a, c), typeof e.lineWidth == "number" && this.jsPDFDocument.setLineWidth(e.lineWidth);
      }
    }, r6.prototype.splitTextToSize = function(e, t, n) {
      return this.jsPDFDocument.splitTextToSize(e, t, n);
    }, r6.prototype.rect = function(e, t, n, i, a) {
      return this.jsPDFDocument.rect(e, t, n, i, a);
    }, r6.prototype.getLastAutoTable = function() {
      return this.jsPDFDocument.lastAutoTable || null;
    }, r6.prototype.getTextWidth = function(e) {
      return this.jsPDFDocument.getTextWidth(e);
    }, r6.prototype.getDocument = function() {
      return this.jsPDFDocument;
    }, r6.prototype.setPage = function(e) {
      this.jsPDFDocument.setPage(e);
    }, r6.prototype.addPage = function() {
      return this.jsPDFDocument.addPage();
    }, r6.prototype.getFontList = function() {
      return this.jsPDFDocument.getFontList();
    }, r6.prototype.getGlobalOptions = function() {
      return qc || {};
    }, r6.prototype.getDocumentOptions = function() {
      return this.jsPDFDocument.__autoTableDocumentDefaults || {};
    }, r6.prototype.pageSize = function() {
      var e = this.jsPDFDocument.internal.pageSize;
      return e.width == null && (e = {
        width: e.getWidth(),
        height: e.getHeight()
      }), e;
    }, r6.prototype.scaleFactor = function() {
      return this.jsPDFDocument.internal.scaleFactor;
    }, r6.prototype.getLineHeightFactor = function() {
      var e = this.jsPDFDocument;
      return e.getLineHeightFactor ? e.getLineHeightFactor() : 1.15;
    }, r6.prototype.getLineHeight = function(e) {
      return e / this.scaleFactor() * this.getLineHeightFactor();
    }, r6.prototype.pageNumber = function() {
      var e = this.jsPDFDocument.internal.getCurrentPageInfo();
      return e ? e.pageNumber : this.jsPDFDocument.internal.getNumberOfPages();
    }, r6;
  }()
);
var kl = function(r6, e) {
  return kl = Object.setPrototypeOf || {
    __proto__: []
  } instanceof Array && function(t, n) {
    t.__proto__ = n;
  } || function(t, n) {
    for (var i in n) Object.prototype.hasOwnProperty.call(n, i) && (t[i] = n[i]);
  }, kl(r6, e);
};
function J1(r6, e) {
  if (typeof e != "function" && e !== null) throw new TypeError("Class extends value " + String(e) + " is not a constructor or null");
  kl(r6, e);
  function t() {
    this.constructor = r6;
  }
  r6.prototype = e === null ? Object.create(e) : (t.prototype = e.prototype, new t());
}
var Z1 = (
  /** @class */
  function(r6) {
    J1(e, r6);
    function e(t) {
      var n = r6.call(this) || this;
      return n._element = t, n;
    }
    return e;
  }(Array)
);
function M3(r6) {
  return {
    font: "helvetica",
    // helvetica, times, courier
    fontStyle: "normal",
    // normal, bold, italic, bolditalic
    overflow: "linebreak",
    // linebreak, ellipsize, visible or hidden
    fillColor: false,
    // Either false for transparent, rbg array e.g. [255, 255, 255] or gray level e.g 200
    textColor: 20,
    halign: "left",
    // left, center, right, justify
    valign: "top",
    // top, middle, bottom
    fontSize: 10,
    cellPadding: 5 / r6,
    // number or {top,left,right,left,vertical,horizontal}
    lineColor: 200,
    lineWidth: 0,
    cellWidth: "auto",
    // 'auto'|'wrap'|number
    minCellHeight: 0,
    minCellWidth: 0
  };
}
function B3(r6) {
  var e = {
    striped: {
      table: {
        fillColor: 255,
        textColor: 80,
        fontStyle: "normal"
      },
      head: {
        textColor: 255,
        fillColor: [41, 128, 185],
        fontStyle: "bold"
      },
      body: {},
      foot: {
        textColor: 255,
        fillColor: [41, 128, 185],
        fontStyle: "bold"
      },
      alternateRow: {
        fillColor: 245
      }
    },
    grid: {
      table: {
        fillColor: 255,
        textColor: 80,
        fontStyle: "normal",
        lineWidth: 0.1
      },
      head: {
        textColor: 255,
        fillColor: [26, 188, 156],
        fontStyle: "bold",
        lineWidth: 0
      },
      body: {},
      foot: {
        textColor: 255,
        fillColor: [26, 188, 156],
        fontStyle: "bold",
        lineWidth: 0
      },
      alternateRow: {}
    },
    plain: {
      head: {
        fontStyle: "bold"
      },
      foot: {
        fontStyle: "bold"
      }
    }
  };
  return e[r6];
}
function Q0(r6, e, t) {
  t.applyStyles(e, true);
  var n = Array.isArray(r6) ? r6 : [r6], i = n.map(function(a) {
    return t.getTextWidth(a);
  }).reduce(function(a, s) {
    return Math.max(a, s);
  }, 0);
  return i;
}
function Q1(r6, e, t, n) {
  var i = e.settings.tableLineWidth, a = e.settings.tableLineColor;
  r6.applyStyles({
    lineWidth: i,
    lineColor: a
  });
  var s = e2(i, false);
  s && r6.rect(t.x, t.y, e.getWidth(r6.pageSize().width), n.y - t.y, s);
}
function e2(r6, e) {
  var t = r6 > 0, n = e || e === 0;
  return t && n ? "DF" : t ? "S" : n ? "F" : null;
}
function df(r6, e) {
  var t, n, i, a;
  if (r6 = r6 || e, Array.isArray(r6)) {
    if (r6.length >= 4) return {
      top: r6[0],
      right: r6[1],
      bottom: r6[2],
      left: r6[3]
    };
    if (r6.length === 3) return {
      top: r6[0],
      right: r6[1],
      bottom: r6[2],
      left: r6[1]
    };
    if (r6.length === 2) return {
      top: r6[0],
      right: r6[1],
      bottom: r6[0],
      left: r6[1]
    };
    r6.length === 1 ? r6 = r6[0] : r6 = e;
  }
  return typeof r6 == "object" ? (typeof r6.vertical == "number" && (r6.top = r6.vertical, r6.bottom = r6.vertical), typeof r6.horizontal == "number" && (r6.right = r6.horizontal, r6.left = r6.horizontal), {
    left: (t = r6.left) !== null && t !== void 0 ? t : e,
    top: (n = r6.top) !== null && n !== void 0 ? n : e,
    right: (i = r6.right) !== null && i !== void 0 ? i : e,
    bottom: (a = r6.bottom) !== null && a !== void 0 ? a : e
  }) : (typeof r6 != "number" && (r6 = e), {
    top: r6,
    right: r6,
    bottom: r6,
    left: r6
  });
}
function t2(r6, e) {
  var t = df(e.settings.margin, 0);
  return r6.pageSize().width - (t.left + t.right);
}
function j3(r6, e, t, n, i) {
  var a = {}, s = 1.3333333333333333, o = dl(e, function(O) {
    return i.getComputedStyle(O).backgroundColor;
  });
  o != null && (a.fillColor = o);
  var f = dl(e, function(O) {
    return i.getComputedStyle(O).color;
  });
  f != null && (a.textColor = f);
  var h = q3(n, t);
  h && (a.cellPadding = h);
  var c = "borderTopColor", p = s * t, v = n.borderTopWidth;
  if (n.borderBottomWidth === v && n.borderRightWidth === v && n.borderLeftWidth === v) {
    var d = (parseFloat(v) || 0) / p;
    d && (a.lineWidth = d);
  } else a.lineWidth = {
    top: (parseFloat(n.borderTopWidth) || 0) / p,
    right: (parseFloat(n.borderRightWidth) || 0) / p,
    bottom: (parseFloat(n.borderBottomWidth) || 0) / p,
    left: (parseFloat(n.borderLeftWidth) || 0) / p
  }, a.lineWidth.top || (a.lineWidth.right ? c = "borderRightColor" : a.lineWidth.bottom ? c = "borderBottomColor" : a.lineWidth.left && (c = "borderLeftColor"));
  var w = dl(e, function(O) {
    return i.getComputedStyle(O)[c];
  });
  w != null && (a.lineColor = w);
  var x = ["left", "right", "center", "justify"];
  x.indexOf(n.textAlign) !== -1 && (a.halign = n.textAlign), x = ["middle", "bottom", "top"], x.indexOf(n.verticalAlign) !== -1 && (a.valign = n.verticalAlign);
  var S = parseInt(n.fontSize || "");
  isNaN(S) || (a.fontSize = S / s);
  var A = U3(n);
  A && (a.fontStyle = A);
  var b = (n.fontFamily || "").toLowerCase();
  return r6.indexOf(b) !== -1 && (a.font = b), a;
}
function U3(r6) {
  var e = "";
  return (r6.fontWeight === "bold" || r6.fontWeight === "bolder" || parseInt(r6.fontWeight) >= 700) && (e = "bold"), (r6.fontStyle === "italic" || r6.fontStyle === "oblique") && (e += "italic"), e;
}
function dl(r6, e) {
  var t = r2(r6, e);
  if (!t) return null;
  var n = t.match(/^rgba?\((\d+),\s*(\d+),\s*(\d+)(?:,\s*(\d*\.?\d*))?\)$/);
  if (!n || !Array.isArray(n)) return null;
  var i = [parseInt(n[1]), parseInt(n[2]), parseInt(n[3])], a = parseInt(n[4]);
  return a === 0 || isNaN(i[0]) || isNaN(i[1]) || isNaN(i[2]) ? null : i;
}
function r2(r6, e) {
  var t = e(r6);
  return t === "rgba(0, 0, 0, 0)" || t === "transparent" || t === "initial" || t === "inherit" ? r6.parentElement == null ? null : r2(r6.parentElement, e) : t;
}
function q3(r6, e) {
  var t = [r6.paddingTop, r6.paddingRight, r6.paddingBottom, r6.paddingLeft], n = 96 / (72 / e), i = (parseInt(r6.lineHeight) - parseInt(r6.fontSize)) / e / 2, a = t.map(function(o) {
    return parseInt(o || "0") / n;
  }), s = df(a, 0);
  return i > s.top && (s.top = i), i > s.bottom && (s.bottom = i), s;
}
function n2(r6, e, t, n, i) {
  var a, s;
  n === void 0 && (n = false), i === void 0 && (i = false);
  var o;
  typeof e == "string" ? o = t.document.querySelector(e) : o = e;
  var f = Object.keys(r6.getFontList()), h = r6.scaleFactor(), c = [], p = [], v = [];
  if (!o) return console.error("Html table could not be found with input: ", e), {
    head: c,
    body: p,
    foot: v
  };
  for (var d = 0; d < o.rows.length; d++) {
    var w = o.rows[d], x = (s = (a = w == null ? void 0 : w.parentElement) === null || a === void 0 ? void 0 : a.tagName) === null || s === void 0 ? void 0 : s.toLowerCase(), S = H3(f, h, t, w, n, i);
    S && (x === "thead" ? c.push(S) : x === "tfoot" ? v.push(S) : p.push(S));
  }
  return {
    head: c,
    body: p,
    foot: v
  };
}
function H3(r6, e, t, n, i, a) {
  for (var s = new Z1(n), o = 0; o < n.cells.length; o++) {
    var f = n.cells[o], h = t.getComputedStyle(f);
    if (i || h.display !== "none") {
      var c = void 0;
      a && (c = j3(r6, f, e, h, t)), s.push({
        rowSpan: f.rowSpan,
        colSpan: f.colSpan,
        styles: c,
        _element: f,
        content: W3(f)
      });
    }
  }
  var p = t.getComputedStyle(n);
  if (s.length > 0 && (i || p.display !== "none")) return s;
}
function W3(r6) {
  var e = r6.cloneNode(true);
  return e.innerHTML = e.innerHTML.replace(/\n/g, "").replace(/ +/g, " "), e.innerHTML = e.innerHTML.split(/<br.*?>/).map(function(t) {
    return t.trim();
  }).join(`
`), e.innerText || e.textContent || "";
}
function z3(r6, e, t) {
  for (var n = 0, i = [r6, e, t]; n < i.length; n++) {
    var a = i[n];
    a && typeof a != "object" && console.error("The options parameter should be of type object, is: " + typeof a), a.startY && typeof a.startY != "number" && (console.error("Invalid value for startY option", a.startY), delete a.startY);
  }
}
function Oi(r6, e, t, n, i) {
  if (r6 == null) throw new TypeError("Cannot convert undefined or null to object");
  for (var a = Object(r6), s = 1; s < arguments.length; s++) {
    var o = arguments[s];
    if (o != null) for (var f in o) Object.prototype.hasOwnProperty.call(o, f) && (a[f] = o[f]);
  }
  return a;
}
function i2(r6, e) {
  var t = new Es(r6), n = t.getDocumentOptions(), i = t.getGlobalOptions();
  z3(i, n, e);
  var a = Oi({}, i, n, e), s;
  typeof window < "u" && (s = window);
  var o = V3(i, n, e), f = G3(i, n, e), h = X3(t, a), c = $3(t, a, s);
  return {
    id: e.tableId,
    content: c,
    hooks: f,
    styles: o,
    settings: h
  };
}
function V3(r6, e, t) {
  for (var n = {
    styles: {},
    headStyles: {},
    bodyStyles: {},
    footStyles: {},
    alternateRowStyles: {},
    columnStyles: {}
  }, i = function(f) {
    if (f === "columnStyles") {
      var h = r6[f], c = e[f], p = t[f];
      n.columnStyles = Oi({}, h, c, p);
    } else {
      var v = [r6, e, t], d = v.map(function(w) {
        return w[f] || {};
      });
      n[f] = Oi({}, d[0], d[1], d[2]);
    }
  }, a = 0, s = Object.keys(n); a < s.length; a++) {
    var o = s[a];
    i(o);
  }
  return n;
}
function G3(r6, e, t) {
  for (var n = [r6, e, t], i = {
    didParseCell: [],
    willDrawCell: [],
    didDrawCell: [],
    willDrawPage: [],
    didDrawPage: []
  }, a = 0, s = n; a < s.length; a++) {
    var o = s[a];
    o.didParseCell && i.didParseCell.push(o.didParseCell), o.willDrawCell && i.willDrawCell.push(o.willDrawCell), o.didDrawCell && i.didDrawCell.push(o.didDrawCell), o.willDrawPage && i.willDrawPage.push(o.willDrawPage), o.didDrawPage && i.didDrawPage.push(o.didDrawPage);
  }
  return i;
}
function X3(r6, e) {
  var t, n, i, a, s, o, f, h, c, p, v, d, w = df(e.margin, 40 / r6.scaleFactor()), x = (t = Y3(r6, e.startY)) !== null && t !== void 0 ? t : w.top, S;
  e.showFoot === true ? S = "everyPage" : e.showFoot === false ? S = "never" : S = (n = e.showFoot) !== null && n !== void 0 ? n : "everyPage";
  var A;
  e.showHead === true ? A = "everyPage" : e.showHead === false ? A = "never" : A = (i = e.showHead) !== null && i !== void 0 ? i : "everyPage";
  var b = (a = e.useCss) !== null && a !== void 0 ? a : false, O = e.theme || (b ? "plain" : "striped"), q = !!e.horizontalPageBreak, te = (s = e.horizontalPageBreakRepeat) !== null && s !== void 0 ? s : null;
  return {
    includeHiddenHtml: (o = e.includeHiddenHtml) !== null && o !== void 0 ? o : false,
    useCss: b,
    theme: O,
    startY: x,
    margin: w,
    pageBreak: (f = e.pageBreak) !== null && f !== void 0 ? f : "auto",
    rowPageBreak: (h = e.rowPageBreak) !== null && h !== void 0 ? h : "auto",
    tableWidth: (c = e.tableWidth) !== null && c !== void 0 ? c : "auto",
    showHead: A,
    showFoot: S,
    tableLineWidth: (p = e.tableLineWidth) !== null && p !== void 0 ? p : 0,
    tableLineColor: (v = e.tableLineColor) !== null && v !== void 0 ? v : 200,
    horizontalPageBreak: q,
    horizontalPageBreakRepeat: te,
    horizontalPageBreakBehaviour: (d = e.horizontalPageBreakBehaviour) !== null && d !== void 0 ? d : "afterAllRows"
  };
}
function Y3(r6, e) {
  var t = r6.getLastAutoTable(), n = r6.scaleFactor(), i = r6.pageNumber(), a = false;
  if (t && t.startPageNumber) {
    var s = t.startPageNumber + t.pageNumber - 1;
    a = s === i;
  }
  return typeof e == "number" ? e : (e == null || e === false) && a && (t == null ? void 0 : t.finalY) != null ? t.finalY + 20 / n : null;
}
function $3(r6, e, t) {
  var n = e.head || [], i = e.body || [], a = e.foot || [];
  if (e.html) {
    var s = e.includeHiddenHtml;
    if (t) {
      var o = n2(r6, e.html, t, s, e.useCss) || {};
      n = o.head || n, i = o.body || n, a = o.foot || n;
    } else console.error("Cannot parse html in non browser environment");
  }
  var f = e.columns || K3(n, i, a);
  return {
    columns: f,
    head: n,
    body: i,
    foot: a
  };
}
function K3(r6, e, t) {
  var n = r6[0] || e[0] || t[0] || [], i = [];
  return Object.keys(n).filter(function(a) {
    return a !== "_element";
  }).forEach(function(a) {
    var s = 1, o;
    Array.isArray(n) ? o = n[parseInt(a)] : o = n[a], typeof o == "object" && !Array.isArray(o) && (s = (o == null ? void 0 : o.colSpan) || 1);
    for (var f = 0; f < s; f++) {
      var h = void 0;
      Array.isArray(n) ? h = i.length : h = a + (f > 0 ? "_".concat(f) : "");
      var c = {
        dataKey: h
      };
      i.push(c);
    }
  }), i;
}
var Dl = (
  /** @class */
  /* @__PURE__ */ function() {
    function r6(e, t, n) {
      this.table = t, this.pageNumber = t.pageNumber, this.settings = t.settings, this.cursor = n, this.doc = e.getDocument();
    }
    return r6;
  }()
);
var J3 = (
  /** @class */
  function(r6) {
    J1(e, r6);
    function e(t, n, i, a, s, o) {
      var f = r6.call(this, t, n, o) || this;
      return f.cell = i, f.row = a, f.column = s, f.section = a.section, f;
    }
    return e;
  }(Dl)
);
var Z3 = (
  /** @class */
  function() {
    function r6(e, t) {
      this.pageNumber = 1, this.id = e.id, this.settings = e.settings, this.styles = e.styles, this.hooks = e.hooks, this.columns = t.columns, this.head = t.head, this.body = t.body, this.foot = t.foot;
    }
    return r6.prototype.getHeadHeight = function(e) {
      return this.head.reduce(function(t, n) {
        return t + n.getMaxCellHeight(e);
      }, 0);
    }, r6.prototype.getFootHeight = function(e) {
      return this.foot.reduce(function(t, n) {
        return t + n.getMaxCellHeight(e);
      }, 0);
    }, r6.prototype.allRows = function() {
      return this.head.concat(this.body).concat(this.foot);
    }, r6.prototype.callCellHooks = function(e, t, n, i, a, s) {
      for (var o = 0, f = t; o < f.length; o++) {
        var h = f[o], c = new J3(e, this, n, i, a, s), p = h(c) === false;
        if (n.text = Array.isArray(n.text) ? n.text : [n.text], p) return false;
      }
      return true;
    }, r6.prototype.callEndPageHooks = function(e, t) {
      e.applyStyles(e.userStyles);
      for (var n = 0, i = this.hooks.didDrawPage; n < i.length; n++) {
        var a = i[n];
        a(new Dl(e, this, t));
      }
    }, r6.prototype.callWillDrawPageHooks = function(e, t) {
      for (var n = 0, i = this.hooks.willDrawPage; n < i.length; n++) {
        var a = i[n];
        a(new Dl(e, this, t));
      }
    }, r6.prototype.getWidth = function(e) {
      if (typeof this.settings.tableWidth == "number") return this.settings.tableWidth;
      if (this.settings.tableWidth === "wrap") {
        var t = this.columns.reduce(function(i, a) {
          return i + a.wrappedWidth;
        }, 0);
        return t;
      } else {
        var n = this.settings.margin;
        return e - n.left - n.right;
      }
    }, r6;
  }()
);
var a2 = (
  /** @class */
  function() {
    function r6(e, t, n, i, a) {
      a === void 0 && (a = false), this.height = 0, this.raw = e, e instanceof Z1 && (this.raw = e._element, this.element = e._element), this.index = t, this.section = n, this.cells = i, this.spansMultiplePages = a;
    }
    return r6.prototype.getMaxCellHeight = function(e) {
      var t = this;
      return e.reduce(function(n, i) {
        var a;
        return Math.max(n, ((a = t.cells[i.index]) === null || a === void 0 ? void 0 : a.height) || 0);
      }, 0);
    }, r6.prototype.hasRowSpan = function(e) {
      var t = this;
      return e.filter(function(n) {
        var i = t.cells[n.index];
        return i ? i.rowSpan > 1 : false;
      }).length > 0;
    }, r6.prototype.canEntireRowFit = function(e, t) {
      return this.getMaxCellHeight(t) <= e;
    }, r6.prototype.getMinimumRowHeight = function(e, t) {
      var n = this;
      return e.reduce(function(i, a) {
        var s = n.cells[a.index];
        if (!s) return 0;
        var o = t.getLineHeight(s.styles.fontSize), f = s.padding("vertical"), h = f + o;
        return h > i ? h : i;
      }, 0);
    }, r6;
  }()
);
var s2 = (
  /** @class */
  function() {
    function r6(e, t, n) {
      var i;
      this.contentHeight = 0, this.contentWidth = 0, this.wrappedWidth = 0, this.minReadableWidth = 0, this.minWidth = 0, this.width = 0, this.height = 0, this.x = 0, this.y = 0, this.styles = t, this.section = n, this.raw = e;
      var a = e;
      e != null && typeof e == "object" && !Array.isArray(e) ? (this.rowSpan = e.rowSpan || 1, this.colSpan = e.colSpan || 1, a = (i = e.content) !== null && i !== void 0 ? i : e, e._element && (this.raw = e._element)) : (this.rowSpan = 1, this.colSpan = 1);
      var s = a != null ? "" + a : "", o = /\r\n|\r|\n/g;
      this.text = s.split(o);
    }
    return r6.prototype.getTextPos = function() {
      var e;
      if (this.styles.valign === "top") e = this.y + this.padding("top");
      else if (this.styles.valign === "bottom") e = this.y + this.height - this.padding("bottom");
      else {
        var t = this.height - this.padding("vertical");
        e = this.y + t / 2 + this.padding("top");
      }
      var n;
      if (this.styles.halign === "right") n = this.x + this.width - this.padding("right");
      else if (this.styles.halign === "center") {
        var i = this.width - this.padding("horizontal");
        n = this.x + i / 2 + this.padding("left");
      } else n = this.x + this.padding("left");
      return {
        x: n,
        y: e
      };
    }, r6.prototype.getContentHeight = function(e, t) {
      t === void 0 && (t = 1.15);
      var n = Array.isArray(this.text) ? this.text.length : 1, i = this.styles.fontSize / e * t, a = n * i + this.padding("vertical");
      return Math.max(a, this.styles.minCellHeight);
    }, r6.prototype.padding = function(e) {
      var t = df(this.styles.cellPadding, 0);
      return e === "vertical" ? t.top + t.bottom : e === "horizontal" ? t.left + t.right : t[e];
    }, r6;
  }()
);
var Q3 = (
  /** @class */
  function() {
    function r6(e, t, n) {
      this.wrappedWidth = 0, this.minReadableWidth = 0, this.minWidth = 0, this.width = 0, this.dataKey = e, this.raw = t, this.index = n;
    }
    return r6.prototype.getMaxCustomCellWidth = function(e) {
      for (var t = 0, n = 0, i = e.allRows(); n < i.length; n++) {
        var a = i[n], s = a.cells[this.index];
        s && typeof s.styles.cellWidth == "number" && (t = Math.max(t, s.styles.cellWidth));
      }
      return t;
    }, r6;
  }()
);
function ew(r6, e) {
  tw(r6, e);
  var t = [], n = 0;
  e.columns.forEach(function(a) {
    var s = a.getMaxCustomCellWidth(e);
    s ? a.width = s : (a.width = a.wrappedWidth, t.push(a)), n += a.width;
  });
  var i = e.getWidth(r6.pageSize().width) - n;
  i && (i = Ol(t, i, function(a) {
    return Math.max(a.minReadableWidth, a.minWidth);
  })), i && (i = Ol(t, i, function(a) {
    return a.minWidth;
  })), i = Math.abs(i), !e.settings.horizontalPageBreak && i > 0.1 / r6.scaleFactor() && (i = i < 1 ? i : Math.round(i), console.warn("Of the table content, ".concat(i, " units width could not fit page"))), nw(e), iw(e, r6), rw(e);
}
function tw(r6, e) {
  var t = r6.scaleFactor(), n = e.settings.horizontalPageBreak, i = t2(r6, e);
  e.allRows().forEach(function(a) {
    for (var s = 0, o = e.columns; s < o.length; s++) {
      var f = o[s], h = a.cells[f.index];
      if (h) {
        var c = e.hooks.didParseCell;
        e.callCellHooks(r6, c, h, a, f, null);
        var p = h.padding("horizontal");
        h.contentWidth = Q0(h.text, h.styles, r6) + p;
        var v = Q0(h.text.join(" ").split(/[^\S\u00A0]+/), h.styles, r6);
        if (h.minReadableWidth = v + h.padding("horizontal"), typeof h.styles.cellWidth == "number") h.minWidth = h.styles.cellWidth, h.wrappedWidth = h.styles.cellWidth;
        else if (h.styles.cellWidth === "wrap" || n === true) h.contentWidth > i ? (h.minWidth = i, h.wrappedWidth = i) : (h.minWidth = h.contentWidth, h.wrappedWidth = h.contentWidth);
        else {
          var d = 10 / t;
          h.minWidth = h.styles.minCellWidth || d, h.wrappedWidth = h.contentWidth, h.minWidth > h.wrappedWidth && (h.wrappedWidth = h.minWidth);
        }
      }
    }
  }), e.allRows().forEach(function(a) {
    for (var s = 0, o = e.columns; s < o.length; s++) {
      var f = o[s], h = a.cells[f.index];
      if (h && h.colSpan === 1) f.wrappedWidth = Math.max(f.wrappedWidth, h.wrappedWidth), f.minWidth = Math.max(f.minWidth, h.minWidth), f.minReadableWidth = Math.max(f.minReadableWidth, h.minReadableWidth);
      else {
        var c = e.styles.columnStyles[f.dataKey] || e.styles.columnStyles[f.index] || {}, p = c.cellWidth || c.minCellWidth;
        p && typeof p == "number" && (f.minWidth = p, f.wrappedWidth = p);
      }
      h && (h.colSpan > 1 && !f.minWidth && (f.minWidth = h.minWidth), h.colSpan > 1 && !f.wrappedWidth && (f.wrappedWidth = h.minWidth));
    }
  });
}
function Ol(r6, e, t) {
  for (var n = e, i = r6.reduce(function(d, w) {
    return d + w.wrappedWidth;
  }, 0), a = 0; a < r6.length; a++) {
    var s = r6[a], o = s.wrappedWidth / i, f = n * o, h = s.width + f, c = t(s), p = h < c ? c : h;
    e -= p - s.width, s.width = p;
  }
  if (e = Math.round(e * 1e10) / 1e10, e) {
    var v = r6.filter(function(d) {
      return e < 0 ? d.width > t(d) : true;
    });
    v.length && (e = Ol(v, e, t));
  }
  return e;
}
function rw(r6) {
  for (var e = {}, t = 1, n = r6.allRows(), i = 0; i < n.length; i++) for (var a = n[i], s = 0, o = r6.columns; s < o.length; s++) {
    var f = o[s], h = e[f.index];
    if (t > 1) t--, delete a.cells[f.index];
    else if (h) h.cell.height += a.height, t = h.cell.colSpan, delete a.cells[f.index], h.left--, h.left <= 1 && delete e[f.index];
    else {
      var c = a.cells[f.index];
      if (!c) continue;
      if (c.height = a.height, c.rowSpan > 1) {
        var p = n.length - i, v = c.rowSpan > p ? p : c.rowSpan;
        e[f.index] = {
          cell: c,
          left: v,
          row: a
        };
      }
    }
  }
}
function nw(r6) {
  for (var e = r6.allRows(), t = 0; t < e.length; t++) for (var n = e[t], i = null, a = 0, s = 0, o = 0; o < r6.columns.length; o++) {
    var f = r6.columns[o];
    if (s -= 1, s > 1 && r6.columns[o + 1]) a += f.width, delete n.cells[f.index];
    else if (i) {
      var h = i;
      delete n.cells[f.index], i = null, h.width = f.width + a;
    } else {
      var h = n.cells[f.index];
      if (!h) continue;
      if (s = h.colSpan, a = 0, h.colSpan > 1) {
        i = h, a += f.width;
        continue;
      }
      h.width = f.width + a;
    }
  }
}
function iw(r6, e) {
  for (var t = {
    count: 0,
    height: 0
  }, n = 0, i = r6.allRows(); n < i.length; n++) {
    for (var a = i[n], s = 0, o = r6.columns; s < o.length; s++) {
      var f = o[s], h = a.cells[f.index];
      if (h) {
        e.applyStyles(h.styles, true);
        var c = h.width - h.padding("horizontal");
        if (h.styles.overflow === "linebreak") h.text = e.splitTextToSize(h.text, c + 1 / e.scaleFactor(), {
          fontSize: h.styles.fontSize
        });
        else if (h.styles.overflow === "ellipsize") h.text = Hc(h.text, c, h.styles, e, "...");
        else if (h.styles.overflow === "hidden") h.text = Hc(h.text, c, h.styles, e, "");
        else if (typeof h.styles.overflow == "function") {
          var p = h.styles.overflow(h.text, c);
          typeof p == "string" ? h.text = [p] : h.text = p;
        }
        h.contentHeight = h.getContentHeight(e.scaleFactor(), e.getLineHeightFactor());
        var v = h.contentHeight / h.rowSpan;
        h.rowSpan > 1 && t.count * t.height < v * h.rowSpan ? t = {
          height: v,
          count: h.rowSpan
        } : t && t.count > 0 && t.height > v && (v = t.height), v > a.height && (a.height = v);
      }
    }
    t.count--;
  }
}
function Hc(r6, e, t, n, i) {
  return r6.map(function(a) {
    return aw(a, e, t, n, i);
  });
}
function aw(r6, e, t, n, i) {
  var a = 1e4 * n.scaleFactor();
  if (e = Math.ceil(e * a) / a, e >= Q0(r6, t, n)) return r6;
  for (; e < Q0(r6 + i, t, n) && !(r6.length <= 1); ) r6 = r6.substring(0, r6.length - 1);
  return r6.trim() + i;
}
function o2(r6, e) {
  var t = new Es(r6), n = sw(e, t.scaleFactor()), i = new Z3(e, n);
  return ew(t, i), t.applyStyles(t.userStyles), i;
}
function sw(r6, e) {
  var t = r6.content, n = fw(t.columns);
  if (t.head.length === 0) {
    var i = Wc(n, "head");
    i && t.head.push(i);
  }
  if (t.foot.length === 0) {
    var i = Wc(n, "foot");
    i && t.foot.push(i);
  }
  var a = r6.settings.theme, s = r6.styles;
  return {
    columns: n,
    head: pl("head", t.head, n, s, a, e),
    body: pl("body", t.body, n, s, a, e),
    foot: pl("foot", t.foot, n, s, a, e)
  };
}
function pl(r6, e, t, n, i, a) {
  var s = {}, o = e.map(function(f, h) {
    for (var c = 0, p = {}, v = 0, d = 0, w = 0, x = t; w < x.length; w++) {
      var S = x[w];
      if (s[S.index] == null || s[S.index].left === 0) {
        if (d === 0) {
          var A = void 0;
          Array.isArray(f) ? A = f[S.index - v - c] : A = f[S.dataKey];
          var b = {};
          typeof A == "object" && !Array.isArray(A) && (b = (A == null ? void 0 : A.styles) || {});
          var O = lw(r6, S, h, i, n, a, b), q = new s2(A, O, r6);
          p[S.dataKey] = q, p[S.index] = q, d = q.colSpan - 1, s[S.index] = {
            left: q.rowSpan - 1,
            times: d
          };
        } else d--, v++;
      } else s[S.index].left--, d = s[S.index].times, c++;
    }
    return new a2(f, h, r6, p);
  });
  return o;
}
function Wc(r6, e) {
  var t = {};
  return r6.forEach(function(n) {
    if (n.raw != null) {
      var i = ow(e, n.raw);
      i != null && (t[n.dataKey] = i);
    }
  }), Object.keys(t).length > 0 ? t : null;
}
function ow(r6, e) {
  if (r6 === "head") {
    if (typeof e == "object") return e.header || null;
    if (typeof e == "string" || typeof e == "number") return e;
  } else if (r6 === "foot" && typeof e == "object") return e.footer;
  return null;
}
function fw(r6) {
  return r6.map(function(e, t) {
    var n, i;
    return typeof e == "object" ? i = (n = e.dataKey) !== null && n !== void 0 ? n : t : i = t, new Q3(i, e, t);
  });
}
function lw(r6, e, t, n, i, a, s) {
  var o = B3(n), f;
  r6 === "head" ? f = i.headStyles : r6 === "body" ? f = i.bodyStyles : r6 === "foot" && (f = i.footStyles);
  var h = Oi({}, o.table, o[r6], i.styles, f), c = i.columnStyles[e.dataKey] || i.columnStyles[e.index] || {}, p = r6 === "body" ? c : {}, v = r6 === "body" && t % 2 === 0 ? Oi({}, o.alternateRow, i.alternateRowStyles) : {}, d = M3(a), w = Oi({}, d, h, v, p);
  return Oi(w, s);
}
function hw(r6, e, t) {
  var n;
  t === void 0 && (t = {});
  var i = t2(r6, e), a = /* @__PURE__ */ new Map(), s = [], o = [], f = [];
  Array.isArray(e.settings.horizontalPageBreakRepeat) ? f = e.settings.horizontalPageBreakRepeat : (typeof e.settings.horizontalPageBreakRepeat == "string" || typeof e.settings.horizontalPageBreakRepeat == "number") && (f = [e.settings.horizontalPageBreakRepeat]), f.forEach(function(v) {
    var d = e.columns.find(function(w) {
      return w.dataKey === v || w.index === v;
    });
    d && !a.has(d.index) && (a.set(d.index, true), s.push(d.index), o.push(e.columns[d.index]), i -= d.wrappedWidth);
  });
  for (var h = true, c = (n = t == null ? void 0 : t.start) !== null && n !== void 0 ? n : 0; c < e.columns.length; ) {
    if (a.has(c)) {
      c++;
      continue;
    }
    var p = e.columns[c].wrappedWidth;
    if (h || i >= p) h = false, s.push(c), o.push(e.columns[c]), i -= p;
    else break;
    c++;
  }
  return {
    colIndexes: s,
    columns: o,
    lastIndex: c - 1
  };
}
function cw(r6, e) {
  for (var t = [], n = 0; n < e.columns.length; n++) {
    var i = hw(r6, e, {
      start: n
    });
    i.columns.length && (t.push(i), n = i.lastIndex);
  }
  return t;
}
function f2(r6, e) {
  var t = e.settings, n = t.startY, i = t.margin, a = {
    x: i.left,
    y: n
  }, s = e.getHeadHeight(e.columns) + e.getFootHeight(e.columns), o = n + i.bottom + s;
  if (t.pageBreak === "avoid") {
    var f = e.body, h = f.reduce(function(v, d) {
      return v + d.height;
    }, 0);
    o += h;
  }
  var c = new Es(r6);
  (t.pageBreak === "always" || t.startY != null && o > c.pageSize().height) && (h2(c), a.y = i.top), e.callWillDrawPageHooks(c, a);
  var p = Oi({}, a);
  e.startPageNumber = c.pageNumber(), t.horizontalPageBreak ? uw(c, e, p, a) : (c.applyStyles(c.userStyles), (t.showHead === "firstPage" || t.showHead === "everyPage") && e.head.forEach(function(v) {
    return qi(c, e, v, a, e.columns);
  }), c.applyStyles(c.userStyles), e.body.forEach(function(v, d) {
    var w = d === e.body.length - 1;
    ef(c, e, v, w, p, a, e.columns);
  }), c.applyStyles(c.userStyles), (t.showFoot === "lastPage" || t.showFoot === "everyPage") && e.foot.forEach(function(v) {
    return qi(c, e, v, a, e.columns);
  })), Q1(c, e, p, a), e.callEndPageHooks(c, a), e.finalY = a.y, r6.lastAutoTable = e, c.applyStyles(c.userStyles);
}
function uw(r6, e, t, n) {
  var i = cw(r6, e), a = e.settings;
  if (a.horizontalPageBreakBehaviour === "afterAllRows") i.forEach(function(h, c) {
    r6.applyStyles(r6.userStyles), c > 0 ? yo(r6, e, t, n, h.columns, true) : zc(r6, e, n, h.columns), dw(r6, e, t, n, h.columns), gl(r6, e, n, h.columns);
  });
  else for (var s = -1, o = i[0], f = function() {
    var h = s;
    if (o) {
      r6.applyStyles(r6.userStyles);
      var c = o.columns;
      s >= 0 ? yo(r6, e, t, n, c, true) : zc(r6, e, n, c), h = Vc(r6, e, s + 1, n, c), gl(r6, e, n, c);
    }
    var p = h - s;
    i.slice(1).forEach(function(v) {
      r6.applyStyles(r6.userStyles), yo(r6, e, t, n, v.columns, true), Vc(r6, e, s + 1, n, v.columns, p), gl(r6, e, n, v.columns);
    }), s = h;
  }; s < e.body.length - 1; ) f();
}
function zc(r6, e, t, n) {
  var i = e.settings;
  r6.applyStyles(r6.userStyles), (i.showHead === "firstPage" || i.showHead === "everyPage") && e.head.forEach(function(a) {
    return qi(r6, e, a, t, n);
  });
}
function dw(r6, e, t, n, i) {
  r6.applyStyles(r6.userStyles), e.body.forEach(function(a, s) {
    var o = s === e.body.length - 1;
    ef(r6, e, a, o, t, n, i);
  });
}
function Vc(r6, e, t, n, i, a) {
  r6.applyStyles(r6.userStyles), a = a ?? e.body.length;
  var s = Math.min(t + a, e.body.length), o = -1;
  return e.body.slice(t, s).forEach(function(f, h) {
    var c = t + h === e.body.length - 1, p = l2(r6, e, c, n);
    f.canEntireRowFit(p, i) && (qi(r6, e, f, n, i), o = t + h);
  }), o;
}
function gl(r6, e, t, n) {
  var i = e.settings;
  r6.applyStyles(r6.userStyles), (i.showFoot === "lastPage" || i.showFoot === "everyPage") && e.foot.forEach(function(a) {
    return qi(r6, e, a, t, n);
  });
}
function pw(r6, e, t) {
  var n = t.getLineHeight(r6.styles.fontSize), i = r6.padding("vertical"), a = Math.floor((e - i) / n);
  return Math.max(0, a);
}
function gw(r6, e, t, n) {
  var i = {};
  r6.spansMultiplePages = true, r6.height = 0;
  for (var a = 0, s = 0, o = t.columns; s < o.length; s++) {
    var f = o[s], h = r6.cells[f.index];
    if (h) {
      Array.isArray(h.text) || (h.text = [h.text]);
      var c = new s2(h.raw, h.styles, h.section);
      c = Oi(c, h), c.text = [];
      var p = pw(h, e, n);
      h.text.length > p && (c.text = h.text.splice(p, h.text.length));
      var v = n.scaleFactor(), d = n.getLineHeightFactor();
      h.contentHeight = h.getContentHeight(v, d), h.contentHeight >= e && (h.contentHeight = e, c.styles.minCellHeight -= e), h.contentHeight > r6.height && (r6.height = h.contentHeight), c.contentHeight = c.getContentHeight(v, d), c.contentHeight > a && (a = c.contentHeight), i[f.index] = c;
    }
  }
  var w = new a2(r6.raw, -1, r6.section, i, true);
  w.height = a;
  for (var x = 0, S = t.columns; x < S.length; x++) {
    var f = S[x], c = w.cells[f.index];
    c && (c.height = w.height);
    var h = r6.cells[f.index];
    h && (h.height = r6.height);
  }
  return w;
}
function vw(r6, e, t, n) {
  var i = r6.pageSize().height, a = n.settings.margin, s = a.top + a.bottom, o = i - s;
  e.section === "body" && (o -= n.getHeadHeight(n.columns) + n.getFootHeight(n.columns));
  var f = e.getMinimumRowHeight(n.columns, r6), h = f < t;
  if (f > o) return console.error("Will not be able to print row ".concat(e.index, " correctly since it's minimum height is larger than page height")), true;
  if (!h) return false;
  var c = e.hasRowSpan(n.columns), p = e.getMaxCellHeight(n.columns) > o;
  return p ? (c && console.error("The content of row ".concat(e.index, " will not be drawn correctly since drawing rows with a height larger than the page height and has cells with rowspans is not supported.")), true) : !(c || n.settings.rowPageBreak === "avoid");
}
function ef(r6, e, t, n, i, a, s) {
  var o = l2(r6, e, n, a);
  if (t.canEntireRowFit(o, s)) qi(r6, e, t, a, s);
  else if (vw(r6, t, o, e)) {
    var f = gw(t, o, e, r6);
    qi(r6, e, t, a, s), yo(r6, e, i, a, s), ef(r6, e, f, n, i, a, s);
  } else yo(r6, e, i, a, s), ef(r6, e, t, n, i, a, s);
}
function qi(r6, e, t, n, i) {
  n.x = e.settings.margin.left;
  for (var a = 0, s = i; a < s.length; a++) {
    var o = s[a], f = t.cells[o.index];
    if (!f) {
      n.x += o.width;
      continue;
    }
    r6.applyStyles(f.styles), f.x = n.x, f.y = n.y;
    var h = e.callCellHooks(r6, e.hooks.willDrawCell, f, t, o, n);
    if (h === false) {
      n.x += o.width;
      continue;
    }
    mw(r6, f, n);
    var c = f.getTextPos();
    K1(f.text, c.x, c.y, {
      halign: f.styles.halign,
      valign: f.styles.valign,
      maxWidth: Math.ceil(f.width - f.padding("left") - f.padding("right"))
    }, r6.getDocument()), e.callCellHooks(r6, e.hooks.didDrawCell, f, t, o, n), n.x += o.width;
  }
  n.y += t.height;
}
function mw(r6, e, t) {
  var n = e.styles;
  if (r6.getDocument().setFillColor(r6.getDocument().getFillColor()), typeof n.lineWidth == "number") {
    var i = e2(n.lineWidth, n.fillColor);
    i && r6.rect(e.x, t.y, e.width, e.height, i);
  } else typeof n.lineWidth == "object" && (n.fillColor && r6.rect(e.x, t.y, e.width, e.height, "F"), xw(r6, e, t, n.lineWidth));
}
function xw(r6, e, t, n) {
  var i, a, s, o;
  n.top && (i = t.x, a = t.y, s = t.x + e.width, o = t.y, n.right && (s += 0.5 * n.right), n.left && (i -= 0.5 * n.left), f(n.top, i, a, s, o)), n.bottom && (i = t.x, a = t.y + e.height, s = t.x + e.width, o = t.y + e.height, n.right && (s += 0.5 * n.right), n.left && (i -= 0.5 * n.left), f(n.bottom, i, a, s, o)), n.left && (i = t.x, a = t.y, s = t.x, o = t.y + e.height, n.top && (a -= 0.5 * n.top), n.bottom && (o += 0.5 * n.bottom), f(n.left, i, a, s, o)), n.right && (i = t.x + e.width, a = t.y, s = t.x + e.width, o = t.y + e.height, n.top && (a -= 0.5 * n.top), n.bottom && (o += 0.5 * n.bottom), f(n.right, i, a, s, o));
  function f(h, c, p, v, d) {
    r6.getDocument().setLineWidth(h), r6.getDocument().line(c, p, v, d, "S");
  }
}
function l2(r6, e, t, n) {
  var i = e.settings.margin.bottom, a = e.settings.showFoot;
  return (a === "everyPage" || a === "lastPage" && t) && (i += e.getFootHeight(e.columns)), r6.pageSize().height - n.y - i;
}
function yo(r6, e, t, n, i, a) {
  i === void 0 && (i = []), a === void 0 && (a = false), r6.applyStyles(r6.userStyles), e.settings.showFoot === "everyPage" && !a && e.foot.forEach(function(o) {
    return qi(r6, e, o, n, i);
  }), e.callEndPageHooks(r6, n);
  var s = e.settings.margin;
  Q1(r6, e, t, n), h2(r6), e.pageNumber++, n.x = s.left, n.y = s.top, t.y = s.top, e.callWillDrawPageHooks(r6, n), e.settings.showHead === "everyPage" && (e.head.forEach(function(o) {
    return qi(r6, e, o, n, i);
  }), r6.applyStyles(r6.userStyles));
}
function h2(r6) {
  var e = r6.pageNumber();
  r6.setPage(e + 1);
  var t = r6.pageNumber();
  return t === e ? (r6.addPage(), true) : false;
}
function ww(r6) {
  r6.API.autoTable = function() {
    for (var e = [], t = 0; t < arguments.length; t++) e[t] = arguments[t];
    var n = e[0], i = i2(this, n), a = o2(this, i);
    return f2(this, a), this;
  }, r6.API.lastAutoTable = false, r6.API.autoTableText = function(e, t, n, i) {
    K1(e, t, n, i, this);
  }, r6.API.autoTableSetDefaults = function(e) {
    return Es.setDefaults(e, this), this;
  }, r6.autoTableSetDefaults = function(e, t) {
    Es.setDefaults(e, t);
  }, r6.API.autoTableHtmlToJson = function(e, t) {
    var n;
    if (t === void 0 && (t = false), typeof window > "u") return console.error("Cannot run autoTableHtmlToJson in non browser environment"), null;
    var i = new Es(this), a = n2(i, e, window, t, false), s = a.head, o = a.body, f = ((n = s[0]) === null || n === void 0 ? void 0 : n.map(function(h) {
      return h.content;
    })) || [];
    return {
      columns: f,
      rows: o,
      data: o
    };
  };
}
var vl;
function yw(r6, e) {
  var t = i2(r6, e), n = o2(r6, t);
  f2(r6, n);
}
try {
  if (typeof window < "u" && window) {
    Gc = window, Xc = Gc.jsPDF || ((vl = Gc.jspdf) === null || vl === void 0 ? void 0 : vl.jsPDF);
    Xc && ww(Xc);
  }
} catch (r6) {
  console.error("Could not apply autoTable plugin", r6);
}
var Gc;
var Xc;
var Ii = class _Ii {
  /**
   * Converts the pivot table data to HTML
   * @param {PivotTableState<T>} state - The current state of the pivot table
   * @returns {string} HTML string representation of the pivot table
   */
  static convertToHtml(e) {
    var d, w, x, S;
    const {
      rows: t,
      columns: n,
      selectedMeasures: i,
      formatting: a,
      groups: s,
      rawData: o
    } = e;
    if (o.length === 0 || !t.length || !n.length) return "<div>No data to display</div>";
    const f = [...new Set(o.map((A) => A[n[0].uniqueName]))], h = [...new Set(o.map((A) => A[t[0].uniqueName]))], c = (A, b) => A === 0 ? "$0.00" : !A && A !== 0 ? "" : b && b.type === "currency" ? new Intl.NumberFormat(b.locale, {
      style: "currency",
      currency: b.currency,
      minimumFractionDigits: b.decimals,
      maximumFractionDigits: b.decimals
    }).format(A) : b && b.type === "number" ? new Intl.NumberFormat(b.locale, {
      minimumFractionDigits: b.decimals,
      maximumFractionDigits: b.decimals
    }).format(A) : String(A), p = (A, b) => "";
    let v = `
  <div class="pivot-export">
    <style>
      .pivot-table {
        border-collapse: collapse;
        width: 100%;
        font-family: Arial, sans-serif;
      }
      .pivot-table th, .pivot-table td {
        border: 1px solid #ddd;
        padding: 8px;
        text-align: right;
      }
      .pivot-table th {
        background-color: #f2f2f2;
        font-weight: bold;
        text-align: center;
        position: relative;
      }
      .pivot-table .sort-icon::after {
        content: "↕";
        position: absolute;
        right: 4px;
        opacity: 0.5;
      }
      .pivot-table th.region-header {
        border-bottom: none;
      }
      .pivot-table th.measure-header {
        border-top: none;
      }
      .pivot-table .row-header {
        text-align: left;
        font-weight: bold;
        background-color: #f9f9f9;
      }
      .pivot-table .corner-header {
        background-color: #f2f2f2;
        border-bottom: 1px solid #ddd;
      }
      .pagination {
        margin-top: 15px;
        font-family: Arial, sans-serif;
      }
      .export-info {
        margin-top: 15px;
        font-size: 0.8em;
        color: #666;
        font-family: Arial, sans-serif;
      }
    </style>
    
    <table class="pivot-table">
      <thead>
        <tr>
          <th rowspan="2" class="corner-header">${((d = t[0]) == null ? void 0 : d.caption) || ((w = t[0]) == null ? void 0 : w.uniqueName) || ""} /<br>Region</th>`;
    return f.forEach((A) => {
      v += `<th colspan="${i.length}" class="region-header">${A}</th>`;
    }), v += `
        </tr>
        <tr>`, f.forEach((A) => {
      i.forEach((b) => {
        v += `<th class="measure-header sort-icon">${b.caption || b.uniqueName}</th>`;
      });
    }), v += `
        </tr>
      </thead>
      <tbody>`, h.forEach((A) => {
      v += `<tr>
      <td class="row-header">${A}</td>`, f.forEach((b) => {
        i.forEach((O) => {
          const q = o.filter((M) => M[t[0].uniqueName] === A && M[n[0].uniqueName] === b);
          let te = 0;
          if (q.length > 0) switch (O.aggregation) {
            case "sum":
              te = q.reduce((M, H) => M + (H[O.uniqueName] || 0), 0);
              break;
            case "avg":
              O != null && O.formula && typeof O.formula == "function" ? te = q.reduce((M, H) => {
                var ee;
                return M + (((ee = O.formula) == null ? void 0 : ee.call(O, H)) || 0);
              }, 0) / q.length : te = q.reduce((M, H) => M + (H[O.uniqueName] || 0), 0) / q.length;
              break;
            case "max":
              te = Math.max(...q.map((M) => M[O.uniqueName] || 0));
              break;
            case "min":
              te = Math.min(...q.map((M) => M[O.uniqueName] || 0));
              break;
            case "count":
              te = q.length;
              break;
            default:
              te = 0;
          }
          const le = p(te, O.uniqueName), j = c(te, a[O.uniqueName]);
          v += `<td${le}>${j}</td>`;
        });
      }), v += "</tr>";
    }), v += `
      </tbody>
    </table>
    
    <div class="pagination">
      Page ${((x = e.paginationConfig) == null ? void 0 : x.currentPage) || 1} of ${((S = e.paginationConfig) == null ? void 0 : S.totalPages) || 1}
    </div>
    
    <div class="export-info">
      <p>Generated: ${(/* @__PURE__ */ new Date()).toLocaleString()}</p>
    </div>
  </div>`, v;
  }
  /**
   * Exports the pivot table data to HTML and downloads the file
   * @param {PivotTableState<T>} state - The current state of the pivot table
   * @param {string} fileName - The name of the downloaded file (without extension)
   */
  static exportToHTML(e, t = "pivot-table") {
    var o;
    console.log("PivotExportService.exportToHTML called with fileName:", t), console.log("State rawData length:", ((o = e.rawData) == null ? void 0 : o.length) || 0);
    const n = _Ii.convertToHtml(e);
    console.log("HTML content length:", n.length);
    const i = `<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>${t}</title>
  <style>
    body { font-family: Arial, sans-serif; margin: 20px; }
    .pivot-export { max-width: 100%; overflow-x: auto; }
  </style>
</head>
<body>
  ${n}
</body>
</html>`;
    console.log("Full HTML length:", i.length);
    const a = "data:text/html;charset=utf-8," + encodeURIComponent(i);
    console.log("Data URL created, length:", a.length);
    const s = document.createElement("a");
    s.href = a, s.download = `${t}.html`, document.body.appendChild(s), console.log("Clicking download link..."), s.click(), document.body.removeChild(s), console.log("HTML export completed");
  }
  /**
   * Exports the pivot table data to PDF and downloads the file
   * @param {PivotTableState<T>} state - The current state of the pivot table
   * @param {string} fileName - The name of the downloaded file (without extension)
   */
  static exportToPDF(e, t = "pivot-table") {
    var s;
    console.log("PivotExportService.exportToPDF called with fileName:", t), console.log("State rawData length:", ((s = e.rawData) == null ? void 0 : s.length) || 0);
    const n = _Ii.convertToHtml(e);
    console.log("HTML content length for PDF:", n.length);
    const i = document.createElement("div");
    i.style.position = "absolute", i.style.left = "-9999px", i.innerHTML = n, document.body.appendChild(i);
    const a = i.querySelector("table");
    if (!a) {
      console.error("No table found in the generated HTML"), document.body.removeChild(i);
      return;
    }
    console.log("Table element found, proceeding with PDF generation");
    try {
      console.log("Creating jsPDF instance...");
      const o = new ut();
      o.setFontSize(16), o.text(t, o.internal.pageSize.getWidth() / 2, 15, {
        align: "center"
      }), yw(o, {
        html: a,
        startY: 25,
        styles: {
          fontSize: 10,
          cellPadding: 3,
          overflow: "linebreak"
        },
        headStyles: {
          fillColor: [66, 139, 202],
          textColor: 255,
          fontStyle: "bold"
        },
        columnStyles: {},
        margin: {
          top: 25,
          right: 15,
          bottom: 25,
          left: 15
        },
        didDrawPage: (f) => {
          o.setFontSize(10), o.text(`Page ${f.pageNumber}`, o.internal.pageSize.getWidth() - 20, o.internal.pageSize.getHeight() - 10);
        }
      }), o.save(`${t}.pdf`), document.body.removeChild(i);
    } catch (o) {
      console.error("Error exporting to PDF:", o), document.body.removeChild(i);
    }
  }
  /**
   * Exports the pivot table data to Excel and downloads the file
   * @param {PivotTableState<T>} state - The current state of the pivot table
   * @param {string} fileName - The name of the downloaded file (without extension)
   */
  static exportToExcel(e, t = "pivot-table") {
    var n;
    console.log("PivotExportService.exportToExcel called with fileName:", t), console.log("State rawData length:", ((n = e.rawData) == null ? void 0 : n.length) || 0);
    try {
      _Ii.generateExcel(e, t);
    } catch (i) {
      console.error("Error exporting to Excel:", i);
    }
  }
  /**
   * Generates an Excel file from the pivot table data
   * @param {PivotTableState<T>} state - The current state of the pivot table
   * @param {string} fileName - The name of the downloaded file (without extension)
   */
  static generateExcel(e, t) {
    var A, b, O;
    if (!e.data || e.data.length === 0) {
      console.log("No data to export!");
      return;
    }
    const n = e.rows || [], i = e.columns || [], a = e.measures || [], s = (A = n[0]) == null ? void 0 : A.uniqueName, o = (b = i[0]) == null ? void 0 : b.uniqueName;
    if (!s || !o) {
      console.log("Missing row or column dimension");
      return;
    }
    const f = [...new Set(e.data.map((q) => q[s]))], h = [...new Set(e.data.map((q) => q[o]))], c = [((O = n[0]) == null ? void 0 : O.caption) || "Dimension", ...h.flatMap((q) => a.map((te) => `${q} - ${te.caption || te.uniqueName}`))], p = f.map((q) => {
      const te = [q];
      return h.forEach((le) => {
        a.forEach((j) => {
          const M = e.data.filter((ee) => ee[s] === q && ee[o] === le);
          let H = 0;
          if (M.length > 0) switch (j.aggregation) {
            case "sum":
              H = M.reduce((ee, F) => ee + (F[j.uniqueName] || 0), 0);
              break;
            case "avg":
              j != null && j.formula && typeof j.formula == "function" && M.length > 0 ? H = M.reduce((ee, F) => {
                var P;
                return ee + (((P = j.formula) == null ? void 0 : P.call(j, F)) || 0);
              }, 0) / M.length : H = M.reduce((ee, F) => ee + (F[j.uniqueName] || 0), 0) / M.length;
              break;
            case "max":
              H = Math.max(...M.map((ee) => ee[j.uniqueName] || 0));
              break;
            case "min":
              H = Math.min(...M.map((ee) => ee[j.uniqueName] || 0));
              break;
            case "count":
              H = M.length;
              break;
            default:
              H = 0;
          }
          te.push(H);
        });
      }), te;
    });
    if (e.processedData && e.processedData.totals) {
      const q = ["Total"];
      h.forEach((te) => {
        a.forEach((le) => {
          const j = e.processedData.totals[le.uniqueName] || 0;
          q.push(j == null ? void 0 : j.toString());
        });
      }), p.push(q);
    }
    const v = [c, ...p], d = fo.aoa_to_sheet(v), w = fo.decode_range(d["!ref"] ?? "A1:A1"), x = [];
    for (let q = 0; q <= w.e.c; q++) x[q] = {
      wch: q === 0 ? 15 : 12
    };
    d["!cols"] = x;
    for (let q = 1; q <= p.length; q++) for (let te = 1; te <= h.length * a.length; te++) {
      const le = fo.encode_cell({
        r: q,
        c: te
      }), j = (te - 1) % a.length, M = a[j];
      if (M && M.format && d[le]) if (M.format.type === "currency") d[le].z = M.format.currency === "USD" ? '"$"#,##0.00' : `"${M.format.currency}"#,##0.00`;
      else if (M.format.type === "number" && M.format.decimals !== void 0) {
        const H = "#,##0" + (M.format.decimals > 0 ? "." + "0".repeat(M.format.decimals) : "");
        d[le].z = H;
      } else M.format.type === "percentage" && (d[le].z = "0.00%", typeof d[le].v == "number" && (d[le].v = d[le].v / 100));
    }
    const S = fo.book_new();
    fo.book_append_sheet(S, d, "Pivot Table"), N4(S, `${t}.xlsx`);
  }
  /**
   * Opens a print dialog with formatted pivot table content
   * @param {PivotTableState<T>} state - The current state of the pivot table
   * @param {string} title - Optional title for the printed page
   */
  static openPrintDialog(e) {
    const t = _Ii.convertToHtml(e), n = window.open("", "_blank");
    if (!n) {
      console.error("Failed to open print dialog");
      return;
    }
    n.document.write(t), n.document.close(), n.print();
  }
};
var _w = class {
  // Add cache for expensive calculations
  // private cache: Map<string, any> = new Map();
  constructor(e) {
    if (this.filterConfig = [], this.paginationConfig = {
      currentPage: 1,
      pageSize: 10,
      totalPages: 1
    }, this.listeners = /* @__PURE__ */ new Set(), !this.validateConfig(e)) throw new Error("Invalid pivot table configuration");
    this.config = __spreadProps(__spreadValues({}, e), {
      defaultAggregation: e.defaultAggregation || "sum",
      isResponsive: e.isResponsive ?? true
    }), this.state = this.initializeState(e), this.loadData();
  }
  validateConfig(e) {
    if (!e) return false;
    if (e.dataSource) {
      const {
        type: t,
        url: n,
        file: i
      } = e.dataSource;
      if (t === "remote" && !n || t === "file" && !i) return false;
    }
    return true;
  }
  initializeState(e) {
    return {
      data: e.data || [],
      dataHandlingMode: "processed",
      rawData: e.data || [],
      processedData: {
        headers: [],
        rows: [],
        totals: {}
      },
      rows: e.rows || [],
      columns: e.columns || [],
      measures: e.measures || [],
      sortConfig: [],
      rowSizes: this.initializeRowSizes(e.data || []),
      expandedRows: {},
      groupConfig: e.groupConfig || null,
      groups: [],
      selectedMeasures: e.measures || [],
      selectedDimensions: e.dimensions || [],
      selectedAggregation: e.defaultAggregation || "sum",
      formatting: e.formatting || {},
      columnWidths: {},
      isResponsive: e.isResponsive ?? true,
      rowGroups: [],
      columnGroups: [],
      filterConfig: [],
      paginationConfig: {
        currentPage: 1,
        pageSize: e.pageSize || 10,
        totalPages: 1
      }
    };
  }
  /**
   * Loads data from a file or URL.
   **/
  loadData() {
    return __async(this, null, function* () {
      if (this.config.dataSource) {
        const {
          type: e,
          url: t,
          file: n
        } = this.config.dataSource;
        e === "remote" && t ? this.state.rawData = yield this.fetchRemoteData(t) : e === "file" && n ? this.state.rawData = yield this.readFileData(n) : console.error("Invalid data source configuration");
      } else this.config.data && (this.state.rawData = this.config.data);
      this.state.rowSizes = this.initializeRowSizes(this.state.rawData), this.state.processedData = this.generateProcessedDataForDisplay(), this.state.groupConfig && this.applyGrouping();
    });
  }
  setDataHandlingMode(e) {
    this.state.dataHandlingMode = e, this.refreshData(), this._emit();
  }
  /**
   * Gets the current data handling mode
   * @returns {DataHandlingMode}
   * @public
   */
  getDataHandlingMode() {
    return this.state.dataHandlingMode;
  }
  /**
   * Updates the engine's data source and applies current filters
   * This method allows external components to update the data while preserving filtering
   * @param {T[]} newData - The new data to use as the source
   * @public
   */
  updateDataSource(e) {
    this.config.data = [...e], this.state.data = [...e], this.state.rawData = [...e], this.refreshData(), this._emit();
  }
  /**
   * Loads data from a file or URL.
   * @param {File | string} source - The file or URL to load data from.
   * @public
   * @returns {Promise<void>} A promise that resolves when the data is loaded.
   **/
  fetchRemoteData(e) {
    return __async(this, null, function* () {
      try {
        const t = yield fetch(e);
        if (!t.ok) throw new Error(`Failed to fetch data from ${e}`);
        return yield t.json();
      } catch (t) {
        return console.error("Error fetching remote data:", t), [];
      }
    });
  }
  /**
   *  Process the data to be displayed in the table.
   * @param {T[]} data - The data to process.
   * @returns {ProcessedData} The processed data including headers, rows, and totals.
   * @private
   **/
  readFileData(e) {
    return __async(this, null, function* () {
      return new Promise((t, n) => {
        const i = new FileReader();
        i.onload = (a) => {
          var s;
          try {
            const o = JSON.parse((s = a.target) == null ? void 0 : s.result);
            t(o);
          } catch (o) {
            n(o);
          }
        }, i.onerror = (a) => n(a), i.readAsText(e);
      });
    });
  }
  /**
   * Initializes row sizes for the pivot table.
   * @param {T[]} data - The data to initialize row sizes for.
   * @returns {RowSize[]} An array of row sizes.
   * @private
   */
  initializeRowSizes(e) {
    return e.map((t, n) => ({
      index: n,
      height: 40
    }));
  }
  /**
   * Processes the data for the pivot table.
   * @param {T[]} data - The data to process.
   * @returns {ProcessedData} The processed data including headers, rows, and totals.
   * @private
   */
  generateProcessedDataForDisplay() {
    let e = this.state.rawData;
    if (this.state.dataHandlingMode === "processed" && this.state.sortConfig.length > 0) {
      const t = this.state.sortConfig[0];
      this.state.groups.length > 0 ? e = this.state.groups.flatMap((n) => n.items) : e = this.sortData(this.state.rawData, t);
    }
    return {
      headers: this.generateHeaders(),
      rows: this.generateRows(e),
      totals: this.calculateTotals(e)
    };
  }
  /**
   * Generates headers for the pivot table.
   * @returns {string[]} An array of header strings.
   * @private
   */
  generateHeaders() {
    const e = this.state.dataHandlingMode === "raw", t = this.state.rows ? this.state.rows.map((i) => e ? i.uniqueName : i.caption || i.uniqueName) : [], n = this.state.columns ? this.state.columns.map((i) => e ? i.uniqueName : i.caption || i.uniqueName) : [];
    return [...t, ...n];
  }
  /**
   * Generates rows for the pivot table.
   * @param {T[]} data - The data to generate rows from.
   * @returns {any[][]} A 2D array representing the rows.
   * @private
   */
  /**
   * Generates rows for the pivot table with enhanced formatting.
   * @param {T[]} data - The data to generate rows from.
   * @returns {any[][]} A 2D array representing the rows.
   * @private
   */
  generateRows(e) {
    return !e || !this.state.rows || !this.state.columns ? [] : e.map((t) => [...this.state.rows.map((n) => t[n.uniqueName]), ...this.state.columns.map((n) => t[n.uniqueName]), ...this.state.measures.map((n) => {
      const i = this.calculateMeasureValue(t, n);
      return this.formatValue(i, n.uniqueName);
    })]);
  }
  /**
   * Calculates the value for a specific measure.
   * @param {T} item - The data item.
   * @param {MeasureConfig} measure - The measure configuration.
   * @returns {number} The calculated measure value.
   * @private
   */
  calculateMeasureValue(e, t) {
    return t.formula && typeof t.formula == "function" ? t.formula(e) : e[t.uniqueName] || 0;
  }
  /**
   * Calculates totals for each measure in the pivot table.
   * @param {T[]} data - The data to calculate totals from.
   * @returns {Record<string, number>} An object with measure names as keys and their totals as values.
   * @private
   */
  calculateTotals(e) {
    const t = {};
    return this.state.measures.forEach((n) => {
      const {
        uniqueName: i,
        aggregation: a
      } = n;
      let s = 0;
      a === "sum" ? s = e.reduce((o, f) => o + (f[i] || 0), 0) : a === "avg" ? s = e.reduce((o, f) => o + (f[i] || 0), 0) / e.length : a === "max" ? s = Math.max(...e.map((o) => o[i] || 0)) : a === "min" ? s = Math.min(...e.map((o) => o[i] || 0)) : a === "count" && (s = e.length), t[i] = s;
    }), t;
  }
  /**
   * Subscribe to state changes. Returns an unsubscribe function.
   */
  subscribe(e) {
    return this.listeners.add(e), e(this.getState()), () => this.listeners.delete(e);
  }
  /**
   * Emit state changes to all subscribers.
   */
  _emit() {
    this.listeners.forEach((e) => e(this.getState()));
  }
  /**
   * Sets the measures for the pivot table.
   * @param {MeasureConfig[]} measureFields - The measure configurations to set.
   * @public
   */
  setMeasures(e) {
    this.state.selectedMeasures = e, this.state.processedData = this.generateProcessedDataForDisplay(), this.updateAggregates(), this._emit();
  }
  /**
   * Sets the dimensions for the pivot table.
   * @param {Dimension[]} dimensionFields - The dimension configurations to set.
   * @public
   */
  setDimensions(e) {
    this.state.selectedDimensions = e, this.state.processedData = this.generateProcessedDataForDisplay(), this.updateAggregates(), this.refreshData(), this._emit();
  }
  /**
   * Sets the aggregation type for the pivot table.
   * @param {AggregationType} type - The aggregation type to set.
   * @public
   */
  setAggregation(e) {
    this.state.selectedAggregation = e, this.state.processedData = this.generateProcessedDataForDisplay(), this.updateAggregates(), this.refreshData(), this._emit();
  }
  /**
   * Sets the row groups for the pivot table.
   * @param {Group[]} rowGroups - The row groups to set.
   * @public
   */
  setRowGroups(e) {
    this.state.rowGroups = e, this.state.processedData = this.generateProcessedDataForDisplay(), this.updateAggregates(), this._emit();
  }
  /**
   * Sets the column groups for the pivot table.
   * @param {Group[]} columnGroups - The column groups to set.
   * @public
   */
  setColumnGroups(e) {
    this.state.columnGroups = e, this.state.processedData = this.generateProcessedDataForDisplay(), this.updateAggregates(), this._emit();
  }
  /**
   * Enhanced formatValue method with comprehensive formatting support
   * @param {any} value - The value to format.
   * @param {string} field - The field name to use for formatting.
   * @returns {string} The formatted value as a string.
   * @public
   */
  formatValue(e, t) {
    if (e == null || typeof e == "number" && isNaN(e)) {
      const i = this.getFieldFormat(t);
      return i && i.nullValue !== void 0 ? i.nullValue === null ? "" : String(i.nullValue) : "";
    }
    const n = this.getFieldFormat(t);
    if (!n) return String(e);
    try {
      return this.applyFormatting(e, n);
    } catch (i) {
      return console.error(`Error formatting value for field ${t}:`, i), String(e);
    }
  }
  /**
   * Get formatting configuration for a field
   * @param {string} field - The field name
   * @returns {EnhancedMeasureFormat | null} The format configuration
   * @private
   */
  getFieldFormat(e) {
    const t = this.state.measures.find((i) => i.uniqueName === e);
    if (t && t.format) return t.format;
    const n = this.state.formatting[e];
    return n || null;
  }
  /**
   * Apply comprehensive formatting to a value
   * @param {any} value - The value to format
   * @param {EnhancedMeasureFormat} format - The format configuration
   * @returns {string} The formatted value
   * @private
   */
  applyFormatting(e, t) {
    let n = parseFloat(e);
    if (isNaN(n)) return String(e);
    t.percent && (n = n * 100);
    const i = typeof t.decimals == "number" ? t.decimals : 2;
    let a;
    switch (t.type) {
      case "currency":
        a = this.formatCurrency(n, t, i);
        break;
      case "percentage":
        a = this.formatPercentage(n, t, i);
        break;
      case "date":
        a = this.formatDate(e, t);
        break;
      case "number":
      default:
        a = this.formatNumber(n, t, i);
        break;
    }
    return a = this.applyCustomSeparators(a, t), a;
  }
  /**
   * Format as currency
   * @param {number} num - The number to format
   * @param {EnhancedMeasureFormat} format - The format configuration
   * @param {number} decimals - Number of decimal places
   * @returns {string} The formatted currency value
   * @private
   */
  formatCurrency(e, t, n) {
    const i = t.currency || "USD", a = t.locale || "en-US";
    let s = new Intl.NumberFormat(a, {
      style: "currency",
      currency: i,
      minimumFractionDigits: n,
      maximumFractionDigits: n
    }).format(e);
    if (t.align === "right" || t.currencyAlign === "right") {
      const o = s.replace(/[\d.,\s]/g, "");
      s = s.replace(o, "").trim() + " " + o;
    } else t.align === "left" || t.currencyAlign;
    return s;
  }
  /**
   * Format as percentage
   * @param {number} num - The number to format
   * @param {EnhancedMeasureFormat} format - The format configuration
   * @param {number} decimals - Number of decimal places
   * @returns {string} The formatted percentage value
   * @private
   */
  formatPercentage(e, t, n) {
    const i = t.locale || "en-US";
    return new Intl.NumberFormat(i, {
      style: "percent",
      minimumFractionDigits: n,
      maximumFractionDigits: n
    }).format(e / 100);
  }
  /**
   * Format as number
   * @param {number} num - The number to format
   * @param {EnhancedMeasureFormat} format - The format configuration
   * @param {number} decimals - Number of decimal places
   * @returns {string} The formatted number value
   * @private
   */
  formatNumber(e, t, n) {
    const i = t.locale || "en-US";
    return new Intl.NumberFormat(i, {
      minimumFractionDigits: n,
      maximumFractionDigits: n
    }).format(e);
  }
  /**
   * Format as date
   * @param {any} value - The date value to format
   * @param {EnhancedMeasureFormat} format - The format configuration
   * @returns {string} The formatted date value
   * @private
   */
  formatDate(e, t) {
    const n = t.locale || "en-US";
    try {
      return new Date(e).toLocaleDateString(n, {
        dateStyle: "medium"
      });
    } catch {
      return String(e);
    }
  }
  /**
   * Apply custom thousand and decimal separators
   * @param {string} formattedValue - The pre-formatted value
   * @param {EnhancedMeasureFormat} format - The format configuration
   * @returns {string} The value with custom separators applied
   * @private
   */
  applyCustomSeparators(e, t) {
    let n = e;
    if (t.decimalSeparator && t.decimalSeparator !== ".") {
      const i = n.lastIndexOf(".");
      i !== -1 && (n = n.substring(0, i) + t.decimalSeparator + n.substring(i + 1));
    }
    return t.thousandSeparator !== void 0 && (t.thousandSeparator === "" ? n = n.replace(/,/g, "") : t.thousandSeparator !== "," && (n = n.replace(/,/g, t.thousandSeparator))), n;
  }
  /**
   * Calculate aggregated value for a cell intersection
   * @param {string} rowValue - The row value
   * @param {string} columnValue - The column value
   * @param {MeasureConfig} measure - The measure configuration
   * @param {string} rowFieldName - The row field name
   * @param {string} columnFieldName - The column field name
   * @returns {number} The calculated aggregated value
   * @public
   */
  calculateCellValue(e, t, n, i, a) {
    const s = this.state.rawData.filter((f) => f[i] === e && f[a] === t);
    if (s.length === 0) return 0;
    let o = 0;
    switch (n.aggregation) {
      case "sum":
        o = s.reduce((f, h) => f + (h[n.uniqueName] || 0), 0);
        break;
      case "avg":
        o = s.reduce((f, h) => f + (h[n.uniqueName] || 0), 0) / s.length;
        break;
      case "max":
        o = Math.max(...s.map((f) => f[n.uniqueName] || 0));
        break;
      case "min":
        o = Math.min(...s.map((f) => f[n.uniqueName] || 0));
        break;
      case "count":
        o = s.length;
        break;
      default:
        o = 0;
    }
    return o;
  }
  /**
   * Get text alignment for a field
   * @param {string} field - The field name
   * @returns {string} The text alignment ('left', 'right', 'center')
   * @public
   */
  getFieldAlignment(e) {
    const t = this.getFieldFormat(e);
    if (console.log(`getFieldAlignment for field: ${e}`, t), t && t.align) return console.log(`Returning alignment: ${t.align}`), t.align;
    if (t && t.type === "currency" && t.currencyAlign) return t.currencyAlign;
    const i = this.state.measures.find((a) => a.uniqueName === e) ? "right" : "left";
    return console.log(`Using default alignment: ${i}`), i;
  }
  /**
   * Update formatting configuration for a specific field
   * @param {string} field - The field name
   * @param {EnhancedMeasureFormat} format - The format configuration
   * @public
   */
  updateFieldFormatting(e, t) {
    const n = this.state.measures.find((i) => i.uniqueName === e);
    n && (n.format = t), this.state.formatting[e] = t, this.state.processedData = this.generateProcessedDataForDisplay(), this._emit();
  }
  /**
   * Sorts the pivot table data based on the specified field and direction.
   * @param {string} field - The field to sort by.
   * @param {'asc' | 'desc'} direction - The sort direction.
   * @public
   */
  sort(e, t) {
    const n = this.state.measures.find((a) => a.uniqueName === e), i = {
      field: e,
      direction: t,
      type: n ? "measure" : "dimension",
      aggregation: n == null ? void 0 : n.aggregation
    };
    this.state.sortConfig = [i], this.applySort();
  }
  applySort() {
    if (this.state.dataHandlingMode === "raw") {
      const e = this.sortData(this.state.rawData, this.state.sortConfig[0]);
      this.state.data = e, this.state.rawData = e, this.state.processedData = this.generateProcessedDataForDisplay(), this.updateAggregates();
    } else if (this.state.groups.length > 0) this.state.groups = this.sortGroups(this.state.groups, this.state.sortConfig[0]), this.state.processedData = this.generateProcessedDataForDisplay(), this.updateAggregates();
    else {
      const e = this.sortData(this.state.rawData, this.state.sortConfig[0]);
      this.state.data = e, this.state.rawData = e, this.state.processedData = this.generateProcessedDataForDisplay(), this.updateAggregates();
    }
    this._emit();
  }
  sortData(e, t) {
    return [...e].sort((n, i) => {
      let a = this.getFieldValue(n, t), s = this.getFieldValue(i, t);
      return typeof a == "string" && (a = a.toLowerCase()), typeof s == "string" && (s = s.toLowerCase()), a < s ? t.direction === "asc" ? -1 : 1 : a > s ? t.direction === "asc" ? 1 : -1 : 0;
    });
  }
  getFieldValue(e, t) {
    if (t.type === "measure") {
      const n = this.state.measures.find((i) => i.uniqueName === t.field);
      if (n && n.formula) return n.formula(e);
    }
    return e[t.field];
  }
  sortGroups(e, t) {
    return [...e].sort((n, i) => {
      var o, f, h, c, p, v;
      let a, s;
      if (t.type === "measure") a = n.aggregates[`${t.aggregation}_${t.field}`] || 0, s = i.aggregates[`${t.aggregation}_${t.field}`] || 0;
      else {
        const d = n.key ? n.key.split("|") : [], w = i.key ? i.key.split("|") : [], x = (f = (o = this.state.rows) == null ? void 0 : o[0]) == null ? void 0 : f.uniqueName, S = (c = (h = this.state.columns) == null ? void 0 : h[0]) == null ? void 0 : c.uniqueName;
        t.field === x ? (a = d[0] || "", s = w[0] || "") : t.field === S ? (a = d[1] || "", s = w[1] || "") : (a = ((p = n.items[0]) == null ? void 0 : p[t.field]) || "", s = ((v = i.items[0]) == null ? void 0 : v[t.field]) || ""), typeof a == "string" && (a = a.toLowerCase()), typeof s == "string" && (s = s.toLowerCase());
      }
      return a < s ? t.direction === "asc" ? -1 : 1 : a > s ? t.direction === "asc" ? 1 : -1 : 0;
    });
  }
  /**
   * Updates aggregates for all groups in the pivot table.
   * @private
   */
  updateAggregates() {
    const e = (t) => {
      this.state.measures.forEach((n) => {
        const i = `${this.state.selectedAggregation}_${n.uniqueName}`;
        if (n.formula && typeof n.formula == "function") {
          const a = t.items.map((s) => n.formula ? n.formula(s) : 0);
          t.aggregates[i] = Dh(a.map((s) => ({
            value: s
          })), "value", n.aggregation || this.state.selectedAggregation);
        } else t.aggregates[i] = Dh(t.items, n.uniqueName, n.aggregation || this.state.selectedAggregation);
      }), t.subgroups && t.subgroups.forEach(e);
    };
    this.state.groups.forEach(e);
  }
  /**
   * Applies grouping to the pivot table data.
   * @private
   */
  applyGrouping(e) {
    if (!this.state.groupConfig) return;
    const {
      rowFields: t,
      columnFields: n,
      grouper: i
    } = this.state.groupConfig;
    if (!t || !n || !i) {
      console.error("Invalid groupConfig:", this.state.groupConfig);
      return;
    }
    const a = e || this.config.data || [], s = __spreadProps(__spreadValues({}, this.config), {
      data: a
    }), {
      rawData: o,
      groups: f
    } = $2(s, this.state.sortConfig[0] || null, this.state.groupConfig);
    this.state.rawData = o, this.state.groups = f, this.updateAggregates(), this.state.processedData = this.generateProcessedDataForDisplay();
  }
  /**
   * Sets the group configuration for the pivot table.
   * @param {GroupConfig | null} groupConfig - The group configuration to set.
   * @public
   */
  setGroupConfig(e) {
    this.state.groupConfig = e, e ? this.applyGrouping() : (this.state.groups = [], this.state.processedData = this.generateProcessedDataForDisplay()), this._emit();
  }
  /**
   * Returns the grouped data.
   * @returns {Group[]} An array of grouped data.
   * @public
   */
  getGroupedData() {
    return this.state.groups;
  }
  /**
   * Returns the current state of the pivot table.
   * @returns {PivotTableState<T>} The current state of the pivot table.
   * @public
   */
  getState() {
    return __spreadValues({}, this.state);
  }
  /**
   * Resets the pivot table to its initial state.
   * @public
   */
  reset() {
    this.state = __spreadProps(__spreadValues({}, this.state), {
      rawData: this.config.data || [],
      processedData: this.generateProcessedDataForDisplay(),
      sortConfig: [],
      rowSizes: this.initializeRowSizes(this.config.data || []),
      expandedRows: {},
      groupConfig: this.config.groupConfig || null,
      groups: []
    }), this.state.groupConfig && this.applyGrouping(), this._emit();
  }
  /**
   * Resizes a specific row in the pivot table.
   * @param {number} index - The index of the row to resize.
   * @param {number} height - The new height for the row.
   * @public
   */
  resizeRow(e, t) {
    const n = this.state.rowSizes.findIndex((i) => i.index === e);
    n !== -1 && (this.state.rowSizes[n].height = Math.max(20, t), this._emit());
  }
  /**
   * Toggles the expansion state of a row.
   * @param {string} rowId - The ID of the row to toggle.
   * @public
   */
  toggleRowExpansion(e) {
    this.state.expandedRows[e] = !this.state.expandedRows[e], this._emit();
  }
  /**
   * Checks if a row is expanded.
   * @param {string} rowId - The ID of the row to check.
   * @returns {boolean} True if the row is expanded, false otherwise.
   * @public
   */
  isRowExpanded(e) {
    return !!this.state.expandedRows[e];
  }
  /**
   * Handles dragging a row to a new position.
   * This method now correctly operates on state.rowGroups.
   * @param {number} fromIndex - The original index of the row.
   * @param {number} toIndex - The new index for the row.
   * @public
   */
  dragRow(e, t) {
    if (!this.validateDragOperation(e, t, this.state.rowGroups.length)) return;
    const n = [...this.state.rowGroups], [i] = n.splice(e, 1);
    n.splice(t, 0, i), this.state.rowGroups = n, typeof this.config.onRowDragEnd == "function" && this.config.onRowDragEnd(e, t, this.state.rowGroups), this._emit();
  }
  /**
   * Handles dragging a column to a new position.
   * This method now correctly operates on state.columnGroups.
   * @param {number} fromIndex - The original index of the column.
   * @param {number} toIndex - The new index for the column.
   * @public
   */
  dragColumn(e, t) {
    if (this.validateDragOperation(e, t, this.state.columnGroups.length)) try {
      const n = [...this.state.columnGroups], [i] = n.splice(e, 1);
      if (n.splice(t, 0, i), this.state.columnGroups = n, typeof this.config.onColumnDragEnd == "function") {
        const a = n.map((s) => ({
          uniqueName: s.uniqueName ?? s.key ?? "",
          caption: s.caption ?? s.key ?? ""
        }));
        this.config.onColumnDragEnd(e, t, a);
      }
      this._emit();
    } catch (n) {
      console.error("Error during column drag operation:", n);
    }
  }
  // Ensure this validation method also prevents dragging to the same spot
  validateDragOperation(e, t, n) {
    if (e === t) return false;
    const i = e >= 0 && t >= 0 && e < n && t < n;
    return i || console.warn(`Invalid drag indices: from ${e} to ${t} with length ${n}`), i;
  }
  /**
   * Applies filters to the data
   * @param {FilterConfig[]} filters - Array of filter configurations
   * @public
   */
  applyFilters(e) {
    this.filterConfig = e, this.refreshData(), this._emit();
  }
  /**
   * Sets pagination configuration
   * @param {PaginationConfig} config - Pagination configuration
   * @public
   */
  setPagination(e) {
    this.paginationConfig = __spreadValues(__spreadValues({}, this.paginationConfig), e), this.refreshData(), this._emit();
  }
  /**
   * Returns the current pagination configuration
   * @returns {PaginationConfig}
   * @public
   */
  getPagination() {
    return this.paginationConfig;
  }
  /**
   * Refreshes data with current filters and pagination
   * @private
   */
  refreshData() {
    const e = this.getDataForCurrentMode();
    let t;
    this.state.dataHandlingMode === "processed" && this.hasAggregatedFilters() ? t = this.filterProcessedData(e) : t = this.filterData(e), this.paginationConfig.totalPages = Math.ceil(t.length / this.paginationConfig.pageSize), t = this.paginateData(t), this.state.dataHandlingMode === "raw" ? (this.state.data = t, this.state.rawData = t, this.state.processedData = this.generateProcessedDataForDisplay()) : (this.state.data = t, this.state.rawData = t, this.state.groupConfig && this.applyGrouping(t), this.state.processedData = this.generateProcessedDataForDisplay());
  }
  /**
   * Gets the appropriate data source based on the current data handling mode
   * @private
   */
  getDataForCurrentMode() {
    return [...this.config.data || []];
  }
  /**
   * Filters data based on filter configuration
   * @param {T[]} data - Data to filter
   * @private
   */
  filterData(e) {
    return this.filterConfig.length ? e.filter((t) => this.filterConfig.every((n) => {
      const i = t[n.field], a = typeof i == "number" ? Number(n.value) : n.value;
      switch (n.operator) {
        case "equals":
          return i === a;
        case "contains":
          return String(i).toLowerCase().includes(String(a).toLowerCase());
        case "greaterThan":
          return Number(i) > Number(a);
        case "lessThan":
          return Number(i) < Number(a);
        case "between":
          return i >= a[0] && i <= a[1];
        default:
          return true;
      }
    })) : e;
  }
  /**
   * Paginates data based on pagination configuration
   * @param {T[]} data - Data to paginate
   * @private
   */
  paginateData(e) {
    const {
      currentPage: t,
      pageSize: n
    } = this.paginationConfig, i = (t - 1) * n;
    return e.slice(i, i + n);
  }
  /**
   * Gets current pagination state
   * @returns {PaginationConfig} Current pagination configuration
   * @public
   */
  getPaginationState() {
    return __spreadValues({}, this.paginationConfig);
  }
  /**
   * Gets current filter state
   * @returns {FilterConfig[]} Current filter configuration
   * @public
   */
  getFilterState() {
    return [...this.filterConfig];
  }
  /**
   * Exports the pivot table data to HTML and downloads the file.
   * @param {string} fileName - The name of the downloaded file (without extension).
   * @public
   */
  exportToHTML(e = "pivot-table") {
    var t;
    console.log("PivotEngine.exportToHTML called with fileName:", e), console.log("PivotEngine state rawData length:", ((t = this.state.rawData) == null ? void 0 : t.length) || 0), Ii.exportToHTML(this.getState(), e);
  }
  /**
   * Exports the pivot table data to PDF and downloads the file.
   * @param {string} fileName - The name of the downloaded file (without extension).
   * @public
   */
  exportToPDF(e = "pivot-table") {
    var t;
    console.log("PivotEngine.exportToPDF called with fileName:", e), console.log("PivotEngine state rawData length:", ((t = this.state.rawData) == null ? void 0 : t.length) || 0), Ii.exportToPDF(this.getState(), e);
  }
  /**
   * Exports the pivot table data to Excel and downloads the file.
   * @param {string} fileName - The name of the downloaded file (without extension).
   * @public
   */
  exportToExcel(e = "pivot-table") {
    var t;
    console.log("PivotEngine.exportToExcel called with fileName:", e), console.log("PivotEngine state rawData length:", ((t = this.state.rawData) == null ? void 0 : t.length) || 0), Ii.exportToExcel(this.getState(), e);
  }
  /**
   * Opens a print dialog with the formatted pivot table.
   * @public
   */
  openPrintDialog() {
    Ii.openPrintDialog(this.getState());
  }
  // Add these methods to your PivotEngine class to fix drag functionality
  /**
   * Handles dragging a data row (product) to a new position
   * This method operates on the actual data items, not groups
   * @param {number} fromIndex - The original index of the product in unique products list
   * @param {number} toIndex - The new index for the product in unique products list
   * @public
   */
  dragDataRow(e, t) {
    const n = [...new Set(this.state.data.map((i) => i.product))].filter((i) => typeof i == "string");
    if (this.validateDragOperation(e, t, n.length)) try {
      const i = n[e], a = n[t];
      console.log(`Reordering products: ${i} -> ${a}`);
      const s = [...this.state.data], o = [...n], [f] = o.splice(e, 1);
      o.splice(t, 0, f), s.sort((h, c) => {
        const p = o.indexOf(h.product), v = o.indexOf(c.product);
        return p - v;
      }), this.state.data = s, this.state.rawData = s, this.state.processedData = this.generateProcessedDataForDisplay(), this.state.groups.length > 0 && this.updateAggregates(), typeof this.config.onRowDragEnd == "function" && this.config.onRowDragEnd(e, t, this.state.rowGroups);
    } catch (i) {
      console.error("Error during data row drag operation:", i);
    }
  }
  /**
   * Handles dragging a data column (region) to a new position
   * This method operates on the actual data structure, not groups
   * @param {number} fromIndex - The original index of the region
   * @param {number} toIndex - The new index for the region
   * @public
   */
  dragDataColumn(e, t) {
    const n = [...new Set(this.state.data.map((i) => i.region))].filter((i) => typeof i == "string");
    if (this.validateDragOperation(e, t, n.length)) try {
      const i = [...this.state.data], a = [...n], [s] = a.splice(e, 1);
      if (a.splice(t, 0, s), this.state.columns && this.state.columns.length > 0) {
        const o = [...this.state.columns];
        o.sort((f, h) => {
          const c = a.indexOf(f.uniqueName), p = a.indexOf(h.uniqueName);
          return c === -1 ? 1 : p === -1 ? -1 : c - p;
        }), this.state.columns = o;
      }
      if (this.state.data = i, this.state.rawData = i, this.state.processedData = this.generateProcessedDataForDisplay(), this.state.groups.length > 0 && this.updateAggregates(), typeof this.config.onColumnDragEnd == "function") {
        const o = a.map((f) => ({
          uniqueName: f,
          caption: f
        }));
        this.config.onColumnDragEnd(e, t, o);
      }
    } catch (i) {
      console.error("Error during data column drag operation:", i);
    }
  }
  /**
   * Alternative method: Reorder products by their names directly
   * This is more direct for your UI implementation
   * @param {string} fromProduct - Name of the product being moved
   * @param {string} toProduct - Name of the product to move before/after
   * @param {'before' | 'after'} position - Whether to place before or after target
   * @public
   */
  reorderProductsByName(e, t, n = "before") {
    try {
      const i = [...new Set(this.state.data.map((f) => f.product))], a = i.indexOf(e), s = i.indexOf(t);
      if (a === -1 || s === -1) {
        console.warn("Invalid product names for reordering:", {
          fromProduct: e,
          toProduct: t
        });
        return;
      }
      const o = n === "after" ? s + 1 : s;
      this.dragDataRow(a, o);
    } catch (i) {
      console.error("Error reordering products by name:", i);
    }
  }
  //swap logic
  // Also add a method to get the custom region order:
  getCustomRegionOrder() {
    return this.state.customRegionOrder || null;
  }
  // GENERIC CORE ENGINE METHODS - Works with any field names
  /**
   * Generic method to swap data rows based on the configured row field
   * Works with any field name (product, country, customer, etc.)
   */
  swapDataRows(e, t) {
    const n = this.state.rows && this.state.rows.length > 0 ? this.state.rows[0] : null;
    if (!n) {
      console.warn("No row field configured for swapping");
      return;
    }
    const i = n.uniqueName, a = this.state.customRowOrder;
    let s;
    if (a && a.fieldName === i && a.order ? s = [...a.order] : s = [...new Set((this.config.data || []).map((o) => o[i]))].filter((o) => typeof o == "string" && o !== null && o !== void 0), console.log(`Row swap validation: ${i} has ${s.length} unique values:`, s), e < 0 || t < 0 || e >= s.length || t >= s.length) {
      console.warn("Invalid indices for row swap operation:", {
        fromIndex: e,
        toIndex: t,
        totalRows: s.length,
        fieldName: i
      });
      return;
    }
    if (e !== t) try {
      const o = s[e], f = s[t], h = [...this.config.data || []], c = [...s];
      c[e] = f, c[t] = o, this.state.customRowOrder = {
        fieldName: i,
        order: c
      }, h.sort((p, v) => {
        const d = c.indexOf(p[i]), w = c.indexOf(v[i]);
        return d - w;
      }), this.config.data = h, this.state.rawData = h, this.state.data = h, this.state.processedData = this.generateProcessedDataForDisplay(), this.state.groups.length > 0 && this.updateAggregates(), typeof this.config.onRowDragEnd == "function" && this.config.onRowDragEnd(e, t, this.state.rowGroups), console.log(`Row swap completed successfully for field: ${i}`), this._emit();
    } catch (o) {
      console.error("Error during row swap operation:", o);
    }
  }
  /**
   * Generic method to swap data columns based on the configured column field
   * Works with any field name (region, category, department, etc.)
   */
  swapDataColumns(e, t) {
    const n = this.state.columns && this.state.columns.length > 0 ? this.state.columns[0] : null;
    if (!n) {
      console.warn("No column field configured for swapping");
      return;
    }
    const i = n.uniqueName, a = this.state.customColumnOrder;
    let s;
    if (a && a.fieldName === i && a.order ? s = [...a.order] : s = [...new Set((this.config.data || []).map((o) => o[i]))].filter((o) => typeof o == "string" && o !== null && o !== void 0), console.log(`Column swap validation: ${i} has ${s.length} unique values:`, s), e < 0 || t < 0 || e >= s.length || t >= s.length) {
      console.warn("Invalid indices for column swap operation:", {
        fromIndex: e,
        toIndex: t,
        totalColumns: s.length,
        fieldName: i
      });
      return;
    }
    if (e !== t) try {
      const o = s[e], f = s[t], h = [...s];
      if (h[e] = f, h[t] = o, this.state.columns && this.state.columns.length > 0) {
        const c = [...this.state.columns], p = c.findIndex((d) => d.uniqueName === o), v = c.findIndex((d) => d.uniqueName === f);
        p !== -1 && v !== -1 && ([c[p], c[v]] = [c[v], c[p]], this.state.columns = c, console.log("Updated column configurations"));
      }
      if (this.state.customColumnOrder = {
        fieldName: i,
        order: h
      }, this.state.processedData = this.generateProcessedDataForDisplay(), this.state.groups.length > 0 && this.updateAggregates(), typeof this.config.onColumnDragEnd == "function") {
        const c = h.map((p) => ({
          uniqueName: p,
          caption: p
        }));
        this.config.onColumnDragEnd(e, t, c);
      }
      console.log(`Column swap completed successfully for field: ${i}`), this._emit();
    } catch (o) {
      console.error("Error during column swap operation:", o);
    }
  }
  /**
   * Generic method to get unique values for any field
   * Uses the original config data, not the paginated state data
   * Utility method for UI components
   */
  getUniqueFieldValues(e) {
    const t = this.config.data || [];
    console.log(`Getting unique values for field: ${e} from ${t.length} total items`);
    const n = [...new Set(t.map((i) => i[e]))].filter((i) => typeof i == "string" && i !== null && i !== void 0);
    return console.log(`Found ${n.length} unique values for ${e}:`, n), n;
  }
  // Also add this method to get unique values in their current custom order:
  /**
   * Get unique field values respecting any custom order that has been set
   */
  getOrderedUniqueFieldValues(e, t = false) {
    const n = t ? "customRowOrder" : "customColumnOrder", i = this.state[n];
    return i && i.fieldName === e && i.order ? (console.log(`Using custom order for ${e}:`, i.order), i.order) : this.getUniqueFieldValues(e);
  }
  /**
   * Generic method to get the configured row field name
   */
  getRowFieldName() {
    return this.state.rows && this.state.rows.length > 0 ? this.state.rows[0].uniqueName : null;
  }
  /**
   * Generic method to get the configured column field name
   */
  getColumnFieldName() {
    return this.state.columns && this.state.columns.length > 0 ? this.state.columns[0].uniqueName : null;
  }
  /**
   * Generic method to set custom field order
   * Can be used by UI to store custom arrangements
   */
  setCustomFieldOrder(e, t, n = true) {
    const i = n ? "customRowOrder" : "customColumnOrder";
    this.state[i] = {
      fieldName: e,
      order: t
    }, this.state.processedData = this.generateProcessedDataForDisplay(), this._emit();
  }
  /**
   * Get ordered column values if custom order exists
   */
  getOrderedColumnValues() {
    const e = this.state.customColumnOrder;
    return e && e.order && e.order.length > 0 ? (console.log("Engine returning custom column order:", e.order), e.order) : (console.log("Engine has no custom column order"), null);
  }
  /**
   * Get ordered row values if custom order exists
   */
  getOrderedRowValues() {
    const e = this.state.customRowOrder;
    return e && e.order && e.order.length > 0 ? (console.log("Engine returning custom row order:", e.order), e.order) : (console.log("Engine has no custom row order"), null);
  }
  /**
   * Method to swap raw data rows by index
   * This works directly with the raw data array regardless of pivot configuration
   */
  swapRawDataRows(e, t) {
    if (!this.state.data || this.state.data.length === 0) {
      console.warn("No data available for raw row swap");
      return;
    }
    if (e < 0 || t < 0 || e >= this.state.data.length || t >= this.state.data.length) {
      console.warn("Invalid indices for raw row swap operation:", {
        fromIndex: e,
        toIndex: t,
        totalRows: this.state.data.length
      });
      return;
    }
    if (e !== t) try {
      const n = [...this.state.data], i = n[e];
      n[e] = n[t], n[t] = i, this.state.data = n, this.state.rawData = n, this.state.dataHandlingMode === "raw" ? this.state.processedData = this.generateProcessedDataForDisplay() : this.state.processedData = this.generateProcessedDataForDisplay(), this._emit();
    } catch (n) {
      console.error("Error during raw row swap operation:", n);
    }
  }
  /**
   * Checks if any of the current filters are for aggregated measures
   * @private
   */
  hasAggregatedFilters() {
    return this.filterConfig.some((e) => e.field.includes("_") && this.state.measures.some((t) => e.field === `${t.aggregation}_${t.uniqueName}`));
  }
  /**
   * Filters processed data based on aggregated values
   * @private
   */
  filterProcessedData(e) {
    this.state.groupConfig && this.applyGrouping(e);
    const t = this.filterConfig.filter((a) => a.field.includes("_") && this.state.measures.some((s) => a.field === `${s.aggregation}_${s.uniqueName}`)), n = this.filterConfig.filter((a) => !a.field.includes("_") || !this.state.measures.some((s) => a.field === `${s.aggregation}_${s.uniqueName}`));
    let i = e;
    return n.length > 0 && (i = i.filter((a) => n.every((s) => {
      const o = a[s.field], f = typeof o == "number" ? Number(s.value) : s.value;
      switch (s.operator) {
        case "equals":
          return o === f;
        case "contains":
          return String(o).toLowerCase().includes(String(f).toLowerCase());
        case "greaterThan":
          return Number(o) > Number(f);
        case "lessThan":
          return Number(o) < Number(f);
        case "between":
          return o >= f[0] && o <= f[1];
        default:
          return true;
      }
    }))), t.length > 0 && (this.state.groupConfig && this.applyGrouping(i), i = this.state.groups.filter((s) => t.every((o) => {
      const f = s.aggregates[o.field], h = typeof o.value == "string" ? Number(o.value) : o.value;
      switch (o.operator) {
        case "equals":
          return f === h;
        case "greaterThan":
          return f > h;
        case "lessThan":
          return f < h;
        case "between": {
          const c = Array.isArray(h) ? h : [h, h];
          return f >= Number(c[0]) && f <= Number(c[1]);
        }
        default:
          return true;
      }
    })).flatMap((s) => s.items)), i;
  }
};

export {
  Wt,
  _w
};
/*! Bundled license information:

@mindfiredigital/pivothead/dist/index-da0a407c.mjs:
  (*! xlsx.js (C) 2013-present SheetJS -- http://sheetjs.com *)
  (*! sheetjs (C) 2013-present SheetJS -- http://sheetjs.com *)
  (** @license
   *
   * jsPDF - PDF Document creation from JavaScript
   * Version 3.0.1 Built on 2025-03-17T14:19:36.873Z
   *                      CommitID 00000000
   *
   * Copyright (c) 2010-2021 James Hall <james@parall.ax>, https://github.com/MrRio/jsPDF
   *               2015-2021 yWorks GmbH, http://www.yworks.com
   *               2015-2021 Lukas Holländer <lukas.hollaender@yworks.com>, https://github.com/HackbrettXXX
   *               2016-2018 Aras Abbasi <aras.abbasi@gmail.com>
   *               2010 Aaron Spike, https://github.com/acspike
   *               2012 Willow Systems Corporation, https://github.com/willowsystems
   *               2012 Pablo Hess, https://github.com/pablohess
   *               2012 Florian Jenett, https://github.com/fjenett
   *               2013 Warren Weckesser, https://github.com/warrenweckesser
   *               2013 Youssef Beddad, https://github.com/lifof
   *               2013 Lee Driscoll, https://github.com/lsdriscoll
   *               2013 Stefan Slonevskiy, https://github.com/stefslon
   *               2013 Jeremy Morel, https://github.com/jmorel
   *               2013 Christoph Hartmann, https://github.com/chris-rock
   *               2014 Juan Pablo Gaviria, https://github.com/juanpgaviria
   *               2014 James Makes, https://github.com/dollaruw
   *               2014 Diego Casorran, https://github.com/diegocr
   *               2014 Steven Spungin, https://github.com/Flamenco
   *               2014 Kenneth Glassey, https://github.com/Gavvers
   *
   * Permission is hereby granted, free of charge, to any person obtaining
   * a copy of this software and associated documentation files (the
   * "Software"), to deal in the Software without restriction, including
   * without limitation the rights to use, copy, modify, merge, publish,
   * distribute, sublicense, and/or sell copies of the Software, and to
   * permit persons to whom the Software is furnished to do so, subject to
   * the following conditions:
   *
   * The above copyright notice and this permission notice shall be
   * included in all copies or substantial portions of the Software.
   *
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
   * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
   * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
   * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
   * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
   * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
   * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
   *
   * Contributor(s):
   *    siefkenj, ahwolf, rickygu, Midnith, saintclair, eaparango,
   *    kim3er, mfo, alnorth, Flamenco
   *)
  (**
   * A class to parse color values
   * @author Stoyan Stefanov <sstoo@gmail.com>
   * {@link   http://www.phpied.com/rgb-color-parser-in-javascript/}
   * @license Use it if you like it
   *)
  (**
   * @license
   * Joseph Myers does not specify a particular license for his work.
   *
   * Author: Joseph Myers
   * Accessed from: http://www.myersdaily.org/joseph/javascript/md5.js
   *
   * Modified by: Owen Leong
   *)
  (**
   * @license
   * FPDF is released under a permissive license: there is no usage restriction.
   * You may embed it freely in your application (commercial or not), with or
   * without modifications.
   *
   * Reference: http://www.fpdf.org/en/script/script37.php
   *)
  (**
   * @license
   * Licensed under the MIT License.
   * http://opensource.org/licenses/mit-license
   * Author: Owen Leong (@owenl131)
   * Date: 15 Oct 2020
   * References:
   * https://www.cs.cmu.edu/~dst/Adobe/Gallery/anon21jul01-pdf-encryption.txt
   * https://github.com/foliojs/pdfkit/blob/master/lib/security.js
   * http://www.fpdf.org/en/script/script37.php
   *)
  (**
   * @license
   *
   * Copyright (c) 2014 James Robb, https://github.com/jamesbrobb
   *
   * Permission is hereby granted, free of charge, to any person obtaining
   * a copy of this software and associated documentation files (the
   * "Software"), to deal in the Software without restriction, including
   * without limitation the rights to use, copy, modify, merge, publish,
   * distribute, sublicense, and/or sell copies of the Software, and to
   * permit persons to whom the Software is furnished to do so, subject to
   * the following conditions:
   *
   * The above copyright notice and this permission notice shall be
   * included in all copies or substantial portions of the Software.
   *
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
   * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
   * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
   * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
   * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
   * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
   * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
   * ====================================================================
   *)
  (**
   * @license
   * (c) Dean McNamee <dean@gmail.com>, 2013.
   *
   * https://github.com/deanm/omggif
   *
   * Permission is hereby granted, free of charge, to any person obtaining a copy
   * of this software and associated documentation files (the "Software"), to
   * deal in the Software without restriction, including without limitation the
   * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
   * sell copies of the Software, and to permit persons to whom the Software is
   * furnished to do so, subject to the following conditions:
   *
   * The above copyright notice and this permission notice shall be included in
   * all copies or substantial portions of the Software.
   *
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
   * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
   * IN THE SOFTWARE.
   *
   * omggif is a JavaScript implementation of a GIF 89a encoder and decoder,
   * including animation and compression.  It does not rely on any specific
   * underlying system, so should run in the browser, Node, or Plask.
   *)
  (**
   * @license
    Copyright (c) 2008, Adobe Systems Incorporated
    All rights reserved.
  
    Redistribution and use in source and binary forms, with or without 
    modification, are permitted provided that the following conditions are
    met:
  
    * Redistributions of source code must retain the above copyright notice, 
      this list of conditions and the following disclaimer.
    
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the 
      documentation and/or other materials provided with the distribution.
    
    * Neither the name of Adobe Systems Incorporated nor the names of its 
      contributors may be used to endorse or promote products derived from 
      this software without specific prior written permission.
  
    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
    IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
    THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
    PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR 
    CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
    EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
    PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
    PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
    LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
    NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
    SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  *)
  (**
   * @license
   * Copyright (c) 2017 Aras Abbasi
   *
   * Licensed under the MIT License.
   * http://opensource.org/licenses/mit-license
   *)
*/
//# sourceMappingURL=chunk-JBLJVEST.js.map



================================================
FILE: .angular/cache/18.2.20/angular-pivothead-example/vite/deps/chunk-LPUAGQXJ.js
================================================
import {
  __read,
  __spreadArray,
  argsOrArgArray,
  filter,
  not,
  raceWith
} from "./chunk-OVFEQSRS.js";

// node_modules/rxjs/dist/esm5/internal/operators/partition.js
function partition(predicate, thisArg) {
  return function(source) {
    return [filter(predicate, thisArg)(source), filter(not(predicate, thisArg))(source)];
  };
}

// node_modules/rxjs/dist/esm5/internal/operators/race.js
function race() {
  var args = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    args[_i] = arguments[_i];
  }
  return raceWith.apply(void 0, __spreadArray([], __read(argsOrArgArray(args))));
}

export {
  partition,
  race
};
//# sourceMappingURL=chunk-LPUAGQXJ.js.map



================================================
FILE: .angular/cache/18.2.20/angular-pivothead-example/vite/deps/chunk-OVFEQSRS.js
================================================
// node_modules/tslib/tslib.es6.js
var extendStatics = function(d, b) {
  extendStatics = Object.setPrototypeOf || {
    __proto__: []
  } instanceof Array && function(d2, b2) {
    d2.__proto__ = b2;
  } || function(d2, b2) {
    for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
  };
  return extendStatics(d, b);
};
function __extends(d, b) {
  if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
  extendStatics(d, b);
  function __() {
    this.constructor = d;
  }
  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}
function __decorate(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
}
function __awaiter(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
}
function __generator(thisArg, body) {
  var _ = {
    label: 0,
    sent: function() {
      if (t[0] & 1) throw t[1];
      return t[1];
    },
    trys: [],
    ops: []
  }, f, y, t, g;
  return g = {
    next: verb(0),
    "throw": verb(1),
    "return": verb(2)
  }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
    return this;
  }), g;
  function verb(n) {
    return function(v) {
      return step([n, v]);
    };
  }
  function step(op) {
    if (f) throw new TypeError("Generator is already executing.");
    while (_) try {
      if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
      if (y = 0, t) op = [op[0] & 2, t.value];
      switch (op[0]) {
        case 0:
        case 1:
          t = op;
          break;
        case 4:
          _.label++;
          return {
            value: op[1],
            done: false
          };
        case 5:
          _.label++;
          y = op[1];
          op = [0];
          continue;
        case 7:
          op = _.ops.pop();
          _.trys.pop();
          continue;
        default:
          if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
            _ = 0;
            continue;
          }
          if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
            _.label = op[1];
            break;
          }
          if (op[0] === 6 && _.label < t[1]) {
            _.label = t[1];
            t = op;
            break;
          }
          if (t && _.label < t[2]) {
            _.label = t[2];
            _.ops.push(op);
            break;
          }
          if (t[2]) _.ops.pop();
          _.trys.pop();
          continue;
      }
      op = body.call(thisArg, _);
    } catch (e) {
      op = [6, e];
      y = 0;
    } finally {
      f = t = 0;
    }
    if (op[0] & 5) throw op[1];
    return {
      value: op[0] ? op[1] : void 0,
      done: true
    };
  }
}
function __values(o) {
  var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
  if (m) return m.call(o);
  if (o && typeof o.length === "number") return {
    next: function() {
      if (o && i >= o.length) o = void 0;
      return {
        value: o && o[i++],
        done: !o
      };
    }
  };
  throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
}
function __read(o, n) {
  var m = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m) return o;
  var i = m.call(o), r, ar = [], e;
  try {
    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
  } catch (error) {
    e = {
      error
    };
  } finally {
    try {
      if (r && !r.done && (m = i["return"])) m.call(i);
    } finally {
      if (e) throw e.error;
    }
  }
  return ar;
}
function __spreadArray(to, from2, pack) {
  if (pack || arguments.length === 2) for (var i = 0, l = from2.length, ar; i < l; i++) {
    if (ar || !(i in from2)) {
      if (!ar) ar = Array.prototype.slice.call(from2, 0, i);
      ar[i] = from2[i];
    }
  }
  return to.concat(ar || from2);
}
function __await(v) {
  return this instanceof __await ? (this.v = v, this) : new __await(v);
}
function __asyncGenerator(thisArg, _arguments, generator) {
  if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
  var g = generator.apply(thisArg, _arguments || []), i, q = [];
  return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
    return this;
  }, i;
  function verb(n) {
    if (g[n]) i[n] = function(v) {
      return new Promise(function(a, b) {
        q.push([n, v, a, b]) > 1 || resume(n, v);
      });
    };
  }
  function resume(n, v) {
    try {
      step(g[n](v));
    } catch (e) {
      settle(q[0][3], e);
    }
  }
  function step(r) {
    r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);
  }
  function fulfill(value) {
    resume("next", value);
  }
  function reject(value) {
    resume("throw", value);
  }
  function settle(f, v) {
    if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]);
  }
}
function __asyncValues(o) {
  if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
  var m = o[Symbol.asyncIterator], i;
  return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
    return this;
  }, i);
  function verb(n) {
    i[n] = o[n] && function(v) {
      return new Promise(function(resolve, reject) {
        v = o[n](v), settle(resolve, reject, v.done, v.value);
      });
    };
  }
  function settle(resolve, reject, d, v) {
    Promise.resolve(v).then(function(v2) {
      resolve({
        value: v2,
        done: d
      });
    }, reject);
  }
}

// node_modules/rxjs/dist/esm5/internal/util/createErrorClass.js
function createErrorClass(createImpl) {
  var _super = function(instance) {
    Error.call(instance);
    instance.stack = new Error().stack;
  };
  var ctorFunc = createImpl(_super);
  ctorFunc.prototype = Object.create(Error.prototype);
  ctorFunc.prototype.constructor = ctorFunc;
  return ctorFunc;
}

// node_modules/rxjs/dist/esm5/internal/util/UnsubscriptionError.js
var UnsubscriptionError = createErrorClass(function(_super) {
  return function UnsubscriptionErrorImpl(errors) {
    _super(this);
    this.message = errors ? errors.length + " errors occurred during unsubscription:\n" + errors.map(function(err, i) {
      return i + 1 + ") " + err.toString();
    }).join("\n  ") : "";
    this.name = "UnsubscriptionError";
    this.errors = errors;
  };
});

// node_modules/rxjs/dist/esm5/internal/util/isFunction.js
function isFunction(value) {
  return typeof value === "function";
}

// node_modules/rxjs/dist/esm5/internal/util/arrRemove.js
function arrRemove(arr, item) {
  if (arr) {
    var index = arr.indexOf(item);
    0 <= index && arr.splice(index, 1);
  }
}

// node_modules/rxjs/dist/esm5/internal/Subscription.js
var Subscription = function() {
  function Subscription2(initialTeardown) {
    this.initialTeardown = initialTeardown;
    this.closed = false;
    this._parentage = null;
    this._finalizers = null;
  }
  Subscription2.prototype.unsubscribe = function() {
    var e_1, _a, e_2, _b;
    var errors;
    if (!this.closed) {
      this.closed = true;
      var _parentage = this._parentage;
      if (_parentage) {
        this._parentage = null;
        if (Array.isArray(_parentage)) {
          try {
            for (var _parentage_1 = __values(_parentage), _parentage_1_1 = _parentage_1.next(); !_parentage_1_1.done; _parentage_1_1 = _parentage_1.next()) {
              var parent_1 = _parentage_1_1.value;
              parent_1.remove(this);
            }
          } catch (e_1_1) {
            e_1 = {
              error: e_1_1
            };
          } finally {
            try {
              if (_parentage_1_1 && !_parentage_1_1.done && (_a = _parentage_1.return)) _a.call(_parentage_1);
            } finally {
              if (e_1) throw e_1.error;
            }
          }
        } else {
          _parentage.remove(this);
        }
      }
      var initialFinalizer = this.initialTeardown;
      if (isFunction(initialFinalizer)) {
        try {
          initialFinalizer();
        } catch (e) {
          errors = e instanceof UnsubscriptionError ? e.errors : [e];
        }
      }
      var _finalizers = this._finalizers;
      if (_finalizers) {
        this._finalizers = null;
        try {
          for (var _finalizers_1 = __values(_finalizers), _finalizers_1_1 = _finalizers_1.next(); !_finalizers_1_1.done; _finalizers_1_1 = _finalizers_1.next()) {
            var finalizer = _finalizers_1_1.value;
            try {
              execFinalizer(finalizer);
            } catch (err) {
              errors = errors !== null && errors !== void 0 ? errors : [];
              if (err instanceof UnsubscriptionError) {
                errors = __spreadArray(__spreadArray([], __read(errors)), __read(err.errors));
              } else {
                errors.push(err);
              }
            }
          }
        } catch (e_2_1) {
          e_2 = {
            error: e_2_1
          };
        } finally {
          try {
            if (_finalizers_1_1 && !_finalizers_1_1.done && (_b = _finalizers_1.return)) _b.call(_finalizers_1);
          } finally {
            if (e_2) throw e_2.error;
          }
        }
      }
      if (errors) {
        throw new UnsubscriptionError(errors);
      }
    }
  };
  Subscription2.prototype.add = function(teardown) {
    var _a;
    if (teardown && teardown !== this) {
      if (this.closed) {
        execFinalizer(teardown);
      } else {
        if (teardown instanceof Subscription2) {
          if (teardown.closed || teardown._hasParent(this)) {
            return;
          }
          teardown._addParent(this);
        }
        (this._finalizers = (_a = this._finalizers) !== null && _a !== void 0 ? _a : []).push(teardown);
      }
    }
  };
  Subscription2.prototype._hasParent = function(parent) {
    var _parentage = this._parentage;
    return _parentage === parent || Array.isArray(_parentage) && _parentage.includes(parent);
  };
  Subscription2.prototype._addParent = function(parent) {
    var _parentage = this._parentage;
    this._parentage = Array.isArray(_parentage) ? (_parentage.push(parent), _parentage) : _parentage ? [_parentage, parent] : parent;
  };
  Subscription2.prototype._removeParent = function(parent) {
    var _parentage = this._parentage;
    if (_parentage === parent) {
      this._parentage = null;
    } else if (Array.isArray(_parentage)) {
      arrRemove(_parentage, parent);
    }
  };
  Subscription2.prototype.remove = function(teardown) {
    var _finalizers = this._finalizers;
    _finalizers && arrRemove(_finalizers, teardown);
    if (teardown instanceof Subscription2) {
      teardown._removeParent(this);
    }
  };
  Subscription2.EMPTY = function() {
    var empty2 = new Subscription2();
    empty2.closed = true;
    return empty2;
  }();
  return Subscription2;
}();
var EMPTY_SUBSCRIPTION = Subscription.EMPTY;
function isSubscription(value) {
  return value instanceof Subscription || value && "closed" in value && isFunction(value.remove) && isFunction(value.add) && isFunction(value.unsubscribe);
}
function execFinalizer(finalizer) {
  if (isFunction(finalizer)) {
    finalizer();
  } else {
    finalizer.unsubscribe();
  }
}

// node_modules/rxjs/dist/esm5/internal/config.js
var config = {
  onUnhandledError: null,
  onStoppedNotification: null,
  Promise: void 0,
  useDeprecatedSynchronousErrorHandling: false,
  useDeprecatedNextContext: false
};

// node_modules/rxjs/dist/esm5/internal/util/noop.js
function noop() {
}

// node_modules/rxjs/dist/esm5/internal/scheduler/timeoutProvider.js
var timeoutProvider = {
  setTimeout: function(handler, timeout2) {
    var args = [];
    for (var _i = 2; _i < arguments.length; _i++) {
      args[_i - 2] = arguments[_i];
    }
    var delegate = timeoutProvider.delegate;
    if (delegate === null || delegate === void 0 ? void 0 : delegate.setTimeout) {
      return delegate.setTimeout.apply(delegate, __spreadArray([handler, timeout2], __read(args)));
    }
    return setTimeout.apply(void 0, __spreadArray([handler, timeout2], __read(args)));
  },
  clearTimeout: function(handle) {
    var delegate = timeoutProvider.delegate;
    return ((delegate === null || delegate === void 0 ? void 0 : delegate.clearTimeout) || clearTimeout)(handle);
  },
  delegate: void 0
};

// node_modules/rxjs/dist/esm5/internal/util/reportUnhandledError.js
function reportUnhandledError(err) {
  timeoutProvider.setTimeout(function() {
    var onUnhandledError = config.onUnhandledError;
    if (onUnhandledError) {
      onUnhandledError(err);
    } else {
      throw err;
    }
  });
}

// node_modules/rxjs/dist/esm5/internal/NotificationFactories.js
var COMPLETE_NOTIFICATION = function() {
  return createNotification("C", void 0, void 0);
}();
function errorNotification(error) {
  return createNotification("E", void 0, error);
}
function nextNotification(value) {
  return createNotification("N", value, void 0);
}
function createNotification(kind, value, error) {
  return {
    kind,
    value,
    error
  };
}

// node_modules/rxjs/dist/esm5/internal/util/errorContext.js
var context = null;
function errorContext(cb) {
  if (config.useDeprecatedSynchronousErrorHandling) {
    var isRoot = !context;
    if (isRoot) {
      context = {
        errorThrown: false,
        error: null
      };
    }
    cb();
    if (isRoot) {
      var _a = context, errorThrown = _a.errorThrown, error = _a.error;
      context = null;
      if (errorThrown) {
        throw error;
      }
    }
  } else {
    cb();
  }
}
function captureError(err) {
  if (config.useDeprecatedSynchronousErrorHandling && context) {
    context.errorThrown = true;
    context.error = err;
  }
}

// node_modules/rxjs/dist/esm5/internal/Subscriber.js
var Subscriber = function(_super) {
  __extends(Subscriber2, _super);
  function Subscriber2(destination) {
    var _this = _super.call(this) || this;
    _this.isStopped = false;
    if (destination) {
      _this.destination = destination;
      if (isSubscription(destination)) {
        destination.add(_this);
      }
    } else {
      _this.destination = EMPTY_OBSERVER;
    }
    return _this;
  }
  Subscriber2.create = function(next, error, complete) {
    return new SafeSubscriber(next, error, complete);
  };
  Subscriber2.prototype.next = function(value) {
    if (this.isStopped) {
      handleStoppedNotification(nextNotification(value), this);
    } else {
      this._next(value);
    }
  };
  Subscriber2.prototype.error = function(err) {
    if (this.isStopped) {
      handleStoppedNotification(errorNotification(err), this);
    } else {
      this.isStopped = true;
      this._error(err);
    }
  };
  Subscriber2.prototype.complete = function() {
    if (this.isStopped) {
      handleStoppedNotification(COMPLETE_NOTIFICATION, this);
    } else {
      this.isStopped = true;
      this._complete();
    }
  };
  Subscriber2.prototype.unsubscribe = function() {
    if (!this.closed) {
      this.isStopped = true;
      _super.prototype.unsubscribe.call(this);
      this.destination = null;
    }
  };
  Subscriber2.prototype._next = function(value) {
    this.destination.next(value);
  };
  Subscriber2.prototype._error = function(err) {
    try {
      this.destination.error(err);
    } finally {
      this.unsubscribe();
    }
  };
  Subscriber2.prototype._complete = function() {
    try {
      this.destination.complete();
    } finally {
      this.unsubscribe();
    }
  };
  return Subscriber2;
}(Subscription);
var _bind = Function.prototype.bind;
function bind(fn, thisArg) {
  return _bind.call(fn, thisArg);
}
var ConsumerObserver = function() {
  function ConsumerObserver2(partialObserver) {
    this.partialObserver = partialObserver;
  }
  ConsumerObserver2.prototype.next = function(value) {
    var partialObserver = this.partialObserver;
    if (partialObserver.next) {
      try {
        partialObserver.next(value);
      } catch (error) {
        handleUnhandledError(error);
      }
    }
  };
  ConsumerObserver2.prototype.error = function(err) {
    var partialObserver = this.partialObserver;
    if (partialObserver.error) {
      try {
        partialObserver.error(err);
      } catch (error) {
        handleUnhandledError(error);
      }
    } else {
      handleUnhandledError(err);
    }
  };
  ConsumerObserver2.prototype.complete = function() {
    var partialObserver = this.partialObserver;
    if (partialObserver.complete) {
      try {
        partialObserver.complete();
      } catch (error) {
        handleUnhandledError(error);
      }
    }
  };
  return ConsumerObserver2;
}();
var SafeSubscriber = function(_super) {
  __extends(SafeSubscriber2, _super);
  function SafeSubscriber2(observerOrNext, error, complete) {
    var _this = _super.call(this) || this;
    var partialObserver;
    if (isFunction(observerOrNext) || !observerOrNext) {
      partialObserver = {
        next: observerOrNext !== null && observerOrNext !== void 0 ? observerOrNext : void 0,
        error: error !== null && error !== void 0 ? error : void 0,
        complete: complete !== null && complete !== void 0 ? complete : void 0
      };
    } else {
      var context_1;
      if (_this && config.useDeprecatedNextContext) {
        context_1 = Object.create(observerOrNext);
        context_1.unsubscribe = function() {
          return _this.unsubscribe();
        };
        partialObserver = {
          next: observerOrNext.next && bind(observerOrNext.next, context_1),
          error: observerOrNext.error && bind(observerOrNext.error, context_1),
          complete: observerOrNext.complete && bind(observerOrNext.complete, context_1)
        };
      } else {
        partialObserver = observerOrNext;
      }
    }
    _this.destination = new ConsumerObserver(partialObserver);
    return _this;
  }
  return SafeSubscriber2;
}(Subscriber);
function handleUnhandledError(error) {
  if (config.useDeprecatedSynchronousErrorHandling) {
    captureError(error);
  } else {
    reportUnhandledError(error);
  }
}
function defaultErrorHandler(err) {
  throw err;
}
function handleStoppedNotification(notification, subscriber) {
  var onStoppedNotification = config.onStoppedNotification;
  onStoppedNotification && timeoutProvider.setTimeout(function() {
    return onStoppedNotification(notification, subscriber);
  });
}
var EMPTY_OBSERVER = {
  closed: true,
  next: noop,
  error: defaultErrorHandler,
  complete: noop
};

// node_modules/rxjs/dist/esm5/internal/symbol/observable.js
var observable = function() {
  return typeof Symbol === "function" && Symbol.observable || "@@observable";
}();

// node_modules/rxjs/dist/esm5/internal/util/identity.js
function identity(x) {
  return x;
}

// node_modules/rxjs/dist/esm5/internal/util/pipe.js
function pipe() {
  var fns = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    fns[_i] = arguments[_i];
  }
  return pipeFromArray(fns);
}
function pipeFromArray(fns) {
  if (fns.length === 0) {
    return identity;
  }
  if (fns.length === 1) {
    return fns[0];
  }
  return function piped(input) {
    return fns.reduce(function(prev, fn) {
      return fn(prev);
    }, input);
  };
}

// node_modules/rxjs/dist/esm5/internal/Observable.js
var Observable = function() {
  function Observable2(subscribe) {
    if (subscribe) {
      this._subscribe = subscribe;
    }
  }
  Observable2.prototype.lift = function(operator) {
    var observable2 = new Observable2();
    observable2.source = this;
    observable2.operator = operator;
    return observable2;
  };
  Observable2.prototype.subscribe = function(observerOrNext, error, complete) {
    var _this = this;
    var subscriber = isSubscriber(observerOrNext) ? observerOrNext : new SafeSubscriber(observerOrNext, error, complete);
    errorContext(function() {
      var _a = _this, operator = _a.operator, source = _a.source;
      subscriber.add(operator ? operator.call(subscriber, source) : source ? _this._subscribe(subscriber) : _this._trySubscribe(subscriber));
    });
    return subscriber;
  };
  Observable2.prototype._trySubscribe = function(sink) {
    try {
      return this._subscribe(sink);
    } catch (err) {
      sink.error(err);
    }
  };
  Observable2.prototype.forEach = function(next, promiseCtor) {
    var _this = this;
    promiseCtor = getPromiseCtor(promiseCtor);
    return new promiseCtor(function(resolve, reject) {
      var subscriber = new SafeSubscriber({
        next: function(value) {
          try {
            next(value);
          } catch (err) {
            reject(err);
            subscriber.unsubscribe();
          }
        },
        error: reject,
        complete: resolve
      });
      _this.subscribe(subscriber);
    });
  };
  Observable2.prototype._subscribe = function(subscriber) {
    var _a;
    return (_a = this.source) === null || _a === void 0 ? void 0 : _a.subscribe(subscriber);
  };
  Observable2.prototype[observable] = function() {
    return this;
  };
  Observable2.prototype.pipe = function() {
    var operations = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      operations[_i] = arguments[_i];
    }
    return pipeFromArray(operations)(this);
  };
  Observable2.prototype.toPromise = function(promiseCtor) {
    var _this = this;
    promiseCtor = getPromiseCtor(promiseCtor);
    return new promiseCtor(function(resolve, reject) {
      var value;
      _this.subscribe(function(x) {
        return value = x;
      }, function(err) {
        return reject(err);
      }, function() {
        return resolve(value);
      });
    });
  };
  Observable2.create = function(subscribe) {
    return new Observable2(subscribe);
  };
  return Observable2;
}();
function getPromiseCtor(promiseCtor) {
  var _a;
  return (_a = promiseCtor !== null && promiseCtor !== void 0 ? promiseCtor : config.Promise) !== null && _a !== void 0 ? _a : Promise;
}
function isObserver(value) {
  return value && isFunction(value.next) && isFunction(value.error) && isFunction(value.complete);
}
function isSubscriber(value) {
  return value && value instanceof Subscriber || isObserver(value) && isSubscription(value);
}

// node_modules/rxjs/dist/esm5/internal/util/lift.js
function hasLift(source) {
  return isFunction(source === null || source === void 0 ? void 0 : source.lift);
}
function operate(init) {
  return function(source) {
    if (hasLift(source)) {
      return source.lift(function(liftedSource) {
        try {
          return init(liftedSource, this);
        } catch (err) {
          this.error(err);
        }
      });
    }
    throw new TypeError("Unable to lift unknown Observable type");
  };
}

// node_modules/rxjs/dist/esm5/internal/operators/OperatorSubscriber.js
function createOperatorSubscriber(destination, onNext, onComplete, onError, onFinalize) {
  return new OperatorSubscriber(destination, onNext, onComplete, onError, onFinalize);
}
var OperatorSubscriber = function(_super) {
  __extends(OperatorSubscriber2, _super);
  function OperatorSubscriber2(destination, onNext, onComplete, onError, onFinalize, shouldUnsubscribe) {
    var _this = _super.call(this, destination) || this;
    _this.onFinalize = onFinalize;
    _this.shouldUnsubscribe = shouldUnsubscribe;
    _this._next = onNext ? function(value) {
      try {
        onNext(value);
      } catch (err) {
        destination.error(err);
      }
    } : _super.prototype._next;
    _this._error = onError ? function(err) {
      try {
        onError(err);
      } catch (err2) {
        destination.error(err2);
      } finally {
        this.unsubscribe();
      }
    } : _super.prototype._error;
    _this._complete = onComplete ? function() {
      try {
        onComplete();
      } catch (err) {
        destination.error(err);
      } finally {
        this.unsubscribe();
      }
    } : _super.prototype._complete;
    return _this;
  }
  OperatorSubscriber2.prototype.unsubscribe = function() {
    var _a;
    if (!this.shouldUnsubscribe || this.shouldUnsubscribe()) {
      var closed_1 = this.closed;
      _super.prototype.unsubscribe.call(this);
      !closed_1 && ((_a = this.onFinalize) === null || _a === void 0 ? void 0 : _a.call(this));
    }
  };
  return OperatorSubscriber2;
}(Subscriber);

// node_modules/rxjs/dist/esm5/internal/operators/refCount.js
function refCount() {
  return operate(function(source, subscriber) {
    var connection = null;
    source._refCount++;
    var refCounter = createOperatorSubscriber(subscriber, void 0, void 0, void 0, function() {
      if (!source || source._refCount <= 0 || 0 < --source._refCount) {
        connection = null;
        return;
      }
      var sharedConnection = source._connection;
      var conn = connection;
      connection = null;
      if (sharedConnection && (!conn || sharedConnection === conn)) {
        sharedConnection.unsubscribe();
      }
      subscriber.unsubscribe();
    });
    source.subscribe(refCounter);
    if (!refCounter.closed) {
      connection = source.connect();
    }
  });
}

// node_modules/rxjs/dist/esm5/internal/observable/ConnectableObservable.js
var ConnectableObservable = function(_super) {
  __extends(ConnectableObservable2, _super);
  function ConnectableObservable2(source, subjectFactory) {
    var _this = _super.call(this) || this;
    _this.source = source;
    _this.subjectFactory = subjectFactory;
    _this._subject = null;
    _this._refCount = 0;
    _this._connection = null;
    if (hasLift(source)) {
      _this.lift = source.lift;
    }
    return _this;
  }
  ConnectableObservable2.prototype._subscribe = function(subscriber) {
    return this.getSubject().subscribe(subscriber);
  };
  ConnectableObservable2.prototype.getSubject = function() {
    var subject = this._subject;
    if (!subject || subject.isStopped) {
      this._subject = this.subjectFactory();
    }
    return this._subject;
  };
  ConnectableObservable2.prototype._teardown = function() {
    this._refCount = 0;
    var _connection = this._connection;
    this._subject = this._connection = null;
    _connection === null || _connection === void 0 ? void 0 : _connection.unsubscribe();
  };
  ConnectableObservable2.prototype.connect = function() {
    var _this = this;
    var connection = this._connection;
    if (!connection) {
      connection = this._connection = new Subscription();
      var subject_1 = this.getSubject();
      connection.add(this.source.subscribe(createOperatorSubscriber(subject_1, void 0, function() {
        _this._teardown();
        subject_1.complete();
      }, function(err) {
        _this._teardown();
        subject_1.error(err);
      }, function() {
        return _this._teardown();
      })));
      if (connection.closed) {
        this._connection = null;
        connection = Subscription.EMPTY;
      }
    }
    return connection;
  };
  ConnectableObservable2.prototype.refCount = function() {
    return refCount()(this);
  };
  return ConnectableObservable2;
}(Observable);

// node_modules/rxjs/dist/esm5/internal/util/ObjectUnsubscribedError.js
var ObjectUnsubscribedError = createErrorClass(function(_super) {
  return function ObjectUnsubscribedErrorImpl() {
    _super(this);
    this.name = "ObjectUnsubscribedError";
    this.message = "object unsubscribed";
  };
});

// node_modules/rxjs/dist/esm5/internal/Subject.js
var Subject = function(_super) {
  __extends(Subject2, _super);
  function Subject2() {
    var _this = _super.call(this) || this;
    _this.closed = false;
    _this.currentObservers = null;
    _this.observers = [];
    _this.isStopped = false;
    _this.hasError = false;
    _this.thrownError = null;
    return _this;
  }
  Subject2.prototype.lift = function(operator) {
    var subject = new AnonymousSubject(this, this);
    subject.operator = operator;
    return subject;
  };
  Subject2.prototype._throwIfClosed = function() {
    if (this.closed) {
      throw new ObjectUnsubscribedError();
    }
  };
  Subject2.prototype.next = function(value) {
    var _this = this;
    errorContext(function() {
      var e_1, _a;
      _this._throwIfClosed();
      if (!_this.isStopped) {
        if (!_this.currentObservers) {
          _this.currentObservers = Array.from(_this.observers);
        }
        try {
          for (var _b = __values(_this.currentObservers), _c = _b.next(); !_c.done; _c = _b.next()) {
            var observer = _c.value;
            observer.next(value);
          }
        } catch (e_1_1) {
          e_1 = {
            error: e_1_1
          };
        } finally {
          try {
            if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
          } finally {
            if (e_1) throw e_1.error;
          }
        }
      }
    });
  };
  Subject2.prototype.error = function(err) {
    var _this = this;
    errorContext(function() {
      _this._throwIfClosed();
      if (!_this.isStopped) {
        _this.hasError = _this.isStopped = true;
        _this.thrownError = err;
        var observers = _this.observers;
        while (observers.length) {
          observers.shift().error(err);
        }
      }
    });
  };
  Subject2.prototype.complete = function() {
    var _this = this;
    errorContext(function() {
      _this._throwIfClosed();
      if (!_this.isStopped) {
        _this.isStopped = true;
        var observers = _this.observers;
        while (observers.length) {
          observers.shift().complete();
        }
      }
    });
  };
  Subject2.prototype.unsubscribe = function() {
    this.isStopped = this.closed = true;
    this.observers = this.currentObservers = null;
  };
  Object.defineProperty(Subject2.prototype, "observed", {
    get: function() {
      var _a;
      return ((_a = this.observers) === null || _a === void 0 ? void 0 : _a.length) > 0;
    },
    enumerable: false,
    configurable: true
  });
  Subject2.prototype._trySubscribe = function(subscriber) {
    this._throwIfClosed();
    return _super.prototype._trySubscribe.call(this, subscriber);
  };
  Subject2.prototype._subscribe = function(subscriber) {
    this._throwIfClosed();
    this._checkFinalizedStatuses(subscriber);
    return this._innerSubscribe(subscriber);
  };
  Subject2.prototype._innerSubscribe = function(subscriber) {
    var _this = this;
    var _a = this, hasError = _a.hasError, isStopped = _a.isStopped, observers = _a.observers;
    if (hasError || isStopped) {
      return EMPTY_SUBSCRIPTION;
    }
    this.currentObservers = null;
    observers.push(subscriber);
    return new Subscription(function() {
      _this.currentObservers = null;
      arrRemove(observers, subscriber);
    });
  };
  Subject2.prototype._checkFinalizedStatuses = function(subscriber) {
    var _a = this, hasError = _a.hasError, thrownError = _a.thrownError, isStopped = _a.isStopped;
    if (hasError) {
      subscriber.error(thrownError);
    } else if (isStopped) {
      subscriber.complete();
    }
  };
  Subject2.prototype.asObservable = function() {
    var observable2 = new Observable();
    observable2.source = this;
    return observable2;
  };
  Subject2.create = function(destination, source) {
    return new AnonymousSubject(destination, source);
  };
  return Subject2;
}(Observable);
var AnonymousSubject = function(_super) {
  __extends(AnonymousSubject2, _super);
  function AnonymousSubject2(destination, source) {
    var _this = _super.call(this) || this;
    _this.destination = destination;
    _this.source = source;
    return _this;
  }
  AnonymousSubject2.prototype.next = function(value) {
    var _a, _b;
    (_b = (_a = this.destination) === null || _a === void 0 ? void 0 : _a.next) === null || _b === void 0 ? void 0 : _b.call(_a, value);
  };
  AnonymousSubject2.prototype.error = function(err) {
    var _a, _b;
    (_b = (_a = this.destination) === null || _a === void 0 ? void 0 : _a.error) === null || _b === void 0 ? void 0 : _b.call(_a, err);
  };
  AnonymousSubject2.prototype.complete = function() {
    var _a, _b;
    (_b = (_a = this.destination) === null || _a === void 0 ? void 0 : _a.complete) === null || _b === void 0 ? void 0 : _b.call(_a);
  };
  AnonymousSubject2.prototype._subscribe = function(subscriber) {
    var _a, _b;
    return (_b = (_a = this.source) === null || _a === void 0 ? void 0 : _a.subscribe(subscriber)) !== null && _b !== void 0 ? _b : EMPTY_SUBSCRIPTION;
  };
  return AnonymousSubject2;
}(Subject);

// node_modules/rxjs/dist/esm5/internal/BehaviorSubject.js
var BehaviorSubject = function(_super) {
  __extends(BehaviorSubject2, _super);
  function BehaviorSubject2(_value) {
    var _this = _super.call(this) || this;
    _this._value = _value;
    return _this;
  }
  Object.defineProperty(BehaviorSubject2.prototype, "value", {
    get: function() {
      return this.getValue();
    },
    enumerable: false,
    configurable: true
  });
  BehaviorSubject2.prototype._subscribe = function(subscriber) {
    var subscription = _super.prototype._subscribe.call(this, subscriber);
    !subscription.closed && subscriber.next(this._value);
    return subscription;
  };
  BehaviorSubject2.prototype.getValue = function() {
    var _a = this, hasError = _a.hasError, thrownError = _a.thrownError, _value = _a._value;
    if (hasError) {
      throw thrownError;
    }
    this._throwIfClosed();
    return _value;
  };
  BehaviorSubject2.prototype.next = function(value) {
    _super.prototype.next.call(this, this._value = value);
  };
  return BehaviorSubject2;
}(Subject);

// node_modules/rxjs/dist/esm5/internal/scheduler/dateTimestampProvider.js
var dateTimestampProvider = {
  now: function() {
    return (dateTimestampProvider.delegate || Date).now();
  },
  delegate: void 0
};

// node_modules/rxjs/dist/esm5/internal/ReplaySubject.js
var ReplaySubject = function(_super) {
  __extends(ReplaySubject2, _super);
  function ReplaySubject2(_bufferSize, _windowTime, _timestampProvider) {
    if (_bufferSize === void 0) {
      _bufferSize = Infinity;
    }
    if (_windowTime === void 0) {
      _windowTime = Infinity;
    }
    if (_timestampProvider === void 0) {
      _timestampProvider = dateTimestampProvider;
    }
    var _this = _super.call(this) || this;
    _this._bufferSize = _bufferSize;
    _this._windowTime = _windowTime;
    _this._timestampProvider = _timestampProvider;
    _this._buffer = [];
    _this._infiniteTimeWindow = true;
    _this._infiniteTimeWindow = _windowTime === Infinity;
    _this._bufferSize = Math.max(1, _bufferSize);
    _this._windowTime = Math.max(1, _windowTime);
    return _this;
  }
  ReplaySubject2.prototype.next = function(value) {
    var _a = this, isStopped = _a.isStopped, _buffer = _a._buffer, _infiniteTimeWindow = _a._infiniteTimeWindow, _timestampProvider = _a._timestampProvider, _windowTime = _a._windowTime;
    if (!isStopped) {
      _buffer.push(value);
      !_infiniteTimeWindow && _buffer.push(_timestampProvider.now() + _windowTime);
    }
    this._trimBuffer();
    _super.prototype.next.call(this, value);
  };
  ReplaySubject2.prototype._subscribe = function(subscriber) {
    this._throwIfClosed();
    this._trimBuffer();
    var subscription = this._innerSubscribe(subscriber);
    var _a = this, _infiniteTimeWindow = _a._infiniteTimeWindow, _buffer = _a._buffer;
    var copy = _buffer.slice();
    for (var i = 0; i < copy.length && !subscriber.closed; i += _infiniteTimeWindow ? 1 : 2) {
      subscriber.next(copy[i]);
    }
    this._checkFinalizedStatuses(subscriber);
    return subscription;
  };
  ReplaySubject2.prototype._trimBuffer = function() {
    var _a = this, _bufferSize = _a._bufferSize, _timestampProvider = _a._timestampProvider, _buffer = _a._buffer, _infiniteTimeWindow = _a._infiniteTimeWindow;
    var adjustedBufferSize = (_infiniteTimeWindow ? 1 : 2) * _bufferSize;
    _bufferSize < Infinity && adjustedBufferSize < _buffer.length && _buffer.splice(0, _buffer.length - adjustedBufferSize);
    if (!_infiniteTimeWindow) {
      var now = _timestampProvider.now();
      var last3 = 0;
      for (var i = 1; i < _buffer.length && _buffer[i] <= now; i += 2) {
        last3 = i;
      }
      last3 && _buffer.splice(0, last3 + 1);
    }
  };
  return ReplaySubject2;
}(Subject);

// node_modules/rxjs/dist/esm5/internal/AsyncSubject.js
var AsyncSubject = function(_super) {
  __extends(AsyncSubject2, _super);
  function AsyncSubject2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this._value = null;
    _this._hasValue = false;
    _this._isComplete = false;
    return _this;
  }
  AsyncSubject2.prototype._checkFinalizedStatuses = function(subscriber) {
    var _a = this, hasError = _a.hasError, _hasValue = _a._hasValue, _value = _a._value, thrownError = _a.thrownError, isStopped = _a.isStopped, _isComplete = _a._isComplete;
    if (hasError) {
      subscriber.error(thrownError);
    } else if (isStopped || _isComplete) {
      _hasValue && subscriber.next(_value);
      subscriber.complete();
    }
  };
  AsyncSubject2.prototype.next = function(value) {
    if (!this.isStopped) {
      this._value = value;
      this._hasValue = true;
    }
  };
  AsyncSubject2.prototype.complete = function() {
    var _a = this, _hasValue = _a._hasValue, _value = _a._value, _isComplete = _a._isComplete;
    if (!_isComplete) {
      this._isComplete = true;
      _hasValue && _super.prototype.next.call(this, _value);
      _super.prototype.complete.call(this);
    }
  };
  return AsyncSubject2;
}(Subject);

// node_modules/rxjs/dist/esm5/internal/Scheduler.js
var Scheduler = function() {
  function Scheduler2(schedulerActionCtor, now) {
    if (now === void 0) {
      now = Scheduler2.now;
    }
    this.schedulerActionCtor = schedulerActionCtor;
    this.now = now;
  }
  Scheduler2.prototype.schedule = function(work, delay2, state) {
    if (delay2 === void 0) {
      delay2 = 0;
    }
    return new this.schedulerActionCtor(this, work).schedule(state, delay2);
  };
  Scheduler2.now = dateTimestampProvider.now;
  return Scheduler2;
}();

// node_modules/rxjs/dist/esm5/internal/scheduler/Action.js
var Action = function(_super) {
  __extends(Action2, _super);
  function Action2(scheduler, work) {
    return _super.call(this) || this;
  }
  Action2.prototype.schedule = function(state, delay2) {
    if (delay2 === void 0) {
      delay2 = 0;
    }
    return this;
  };
  return Action2;
}(Subscription);

// node_modules/rxjs/dist/esm5/internal/scheduler/intervalProvider.js
var intervalProvider = {
  setInterval: function(handler, timeout2) {
    var args = [];
    for (var _i = 2; _i < arguments.length; _i++) {
      args[_i - 2] = arguments[_i];
    }
    var delegate = intervalProvider.delegate;
    if (delegate === null || delegate === void 0 ? void 0 : delegate.setInterval) {
      return delegate.setInterval.apply(delegate, __spreadArray([handler, timeout2], __read(args)));
    }
    return setInterval.apply(void 0, __spreadArray([handler, timeout2], __read(args)));
  },
  clearInterval: function(handle) {
    var delegate = intervalProvider.delegate;
    return ((delegate === null || delegate === void 0 ? void 0 : delegate.clearInterval) || clearInterval)(handle);
  },
  delegate: void 0
};

// node_modules/rxjs/dist/esm5/internal/scheduler/AsyncAction.js
var AsyncAction = function(_super) {
  __extends(AsyncAction2, _super);
  function AsyncAction2(scheduler, work) {
    var _this = _super.call(this, scheduler, work) || this;
    _this.scheduler = scheduler;
    _this.work = work;
    _this.pending = false;
    return _this;
  }
  AsyncAction2.prototype.schedule = function(state, delay2) {
    var _a;
    if (delay2 === void 0) {
      delay2 = 0;
    }
    if (this.closed) {
      return this;
    }
    this.state = state;
    var id = this.id;
    var scheduler = this.scheduler;
    if (id != null) {
      this.id = this.recycleAsyncId(scheduler, id, delay2);
    }
    this.pending = true;
    this.delay = delay2;
    this.id = (_a = this.id) !== null && _a !== void 0 ? _a : this.requestAsyncId(scheduler, this.id, delay2);
    return this;
  };
  AsyncAction2.prototype.requestAsyncId = function(scheduler, _id, delay2) {
    if (delay2 === void 0) {
      delay2 = 0;
    }
    return intervalProvider.setInterval(scheduler.flush.bind(scheduler, this), delay2);
  };
  AsyncAction2.prototype.recycleAsyncId = function(_scheduler, id, delay2) {
    if (delay2 === void 0) {
      delay2 = 0;
    }
    if (delay2 != null && this.delay === delay2 && this.pending === false) {
      return id;
    }
    if (id != null) {
      intervalProvider.clearInterval(id);
    }
    return void 0;
  };
  AsyncAction2.prototype.execute = function(state, delay2) {
    if (this.closed) {
      return new Error("executing a cancelled action");
    }
    this.pending = false;
    var error = this._execute(state, delay2);
    if (error) {
      return error;
    } else if (this.pending === false && this.id != null) {
      this.id = this.recycleAsyncId(this.scheduler, this.id, null);
    }
  };
  AsyncAction2.prototype._execute = function(state, _delay) {
    var errored = false;
    var errorValue;
    try {
      this.work(state);
    } catch (e) {
      errored = true;
      errorValue = e ? e : new Error("Scheduled action threw falsy error");
    }
    if (errored) {
      this.unsubscribe();
      return errorValue;
    }
  };
  AsyncAction2.prototype.unsubscribe = function() {
    if (!this.closed) {
      var _a = this, id = _a.id, scheduler = _a.scheduler;
      var actions = scheduler.actions;
      this.work = this.state = this.scheduler = null;
      this.pending = false;
      arrRemove(actions, this);
      if (id != null) {
        this.id = this.recycleAsyncId(scheduler, id, null);
      }
      this.delay = null;
      _super.prototype.unsubscribe.call(this);
    }
  };
  return AsyncAction2;
}(Action);

// node_modules/rxjs/dist/esm5/internal/scheduler/AsyncScheduler.js
var AsyncScheduler = function(_super) {
  __extends(AsyncScheduler2, _super);
  function AsyncScheduler2(SchedulerAction, now) {
    if (now === void 0) {
      now = Scheduler.now;
    }
    var _this = _super.call(this, SchedulerAction, now) || this;
    _this.actions = [];
    _this._active = false;
    return _this;
  }
  AsyncScheduler2.prototype.flush = function(action) {
    var actions = this.actions;
    if (this._active) {
      actions.push(action);
      return;
    }
    var error;
    this._active = true;
    do {
      if (error = action.execute(action.state, action.delay)) {
        break;
      }
    } while (action = actions.shift());
    this._active = false;
    if (error) {
      while (action = actions.shift()) {
        action.unsubscribe();
      }
      throw error;
    }
  };
  return AsyncScheduler2;
}(Scheduler);

// node_modules/rxjs/dist/esm5/internal/scheduler/async.js
var asyncScheduler = new AsyncScheduler(AsyncAction);
var async = asyncScheduler;

// node_modules/rxjs/dist/esm5/internal/observable/empty.js
var EMPTY = new Observable(function(subscriber) {
  return subscriber.complete();
});
function empty(scheduler) {
  return scheduler ? emptyScheduled(scheduler) : EMPTY;
}
function emptyScheduled(scheduler) {
  return new Observable(function(subscriber) {
    return scheduler.schedule(function() {
      return subscriber.complete();
    });
  });
}

// node_modules/rxjs/dist/esm5/internal/util/executeSchedule.js
function executeSchedule(parentSubscription, scheduler, work, delay2, repeat2) {
  if (delay2 === void 0) {
    delay2 = 0;
  }
  if (repeat2 === void 0) {
    repeat2 = false;
  }
  var scheduleSubscription = scheduler.schedule(function() {
    work();
    if (repeat2) {
      parentSubscription.add(this.schedule(null, delay2));
    } else {
      this.unsubscribe();
    }
  }, delay2);
  parentSubscription.add(scheduleSubscription);
  if (!repeat2) {
    return scheduleSubscription;
  }
}

// node_modules/rxjs/dist/esm5/internal/operators/observeOn.js
function observeOn(scheduler, delay2) {
  if (delay2 === void 0) {
    delay2 = 0;
  }
  return operate(function(source, subscriber) {
    source.subscribe(createOperatorSubscriber(subscriber, function(value) {
      return executeSchedule(subscriber, scheduler, function() {
        return subscriber.next(value);
      }, delay2);
    }, function() {
      return executeSchedule(subscriber, scheduler, function() {
        return subscriber.complete();
      }, delay2);
    }, function(err) {
      return executeSchedule(subscriber, scheduler, function() {
        return subscriber.error(err);
      }, delay2);
    }));
  });
}

// node_modules/rxjs/dist/esm5/internal/operators/subscribeOn.js
function subscribeOn(scheduler, delay2) {
  if (delay2 === void 0) {
    delay2 = 0;
  }
  return operate(function(source, subscriber) {
    subscriber.add(scheduler.schedule(function() {
      return source.subscribe(subscriber);
    }, delay2));
  });
}

// node_modules/rxjs/dist/esm5/internal/util/isArrayLike.js
var isArrayLike = function(x) {
  return x && typeof x.length === "number" && typeof x !== "function";
};

// node_modules/rxjs/dist/esm5/internal/util/isPromise.js
function isPromise(value) {
  return isFunction(value === null || value === void 0 ? void 0 : value.then);
}

// node_modules/rxjs/dist/esm5/internal/util/isInteropObservable.js
function isInteropObservable(input) {
  return isFunction(input[observable]);
}

// node_modules/rxjs/dist/esm5/internal/util/isAsyncIterable.js
function isAsyncIterable(obj) {
  return Symbol.asyncIterator && isFunction(obj === null || obj === void 0 ? void 0 : obj[Symbol.asyncIterator]);
}

// node_modules/rxjs/dist/esm5/internal/util/throwUnobservableError.js
function createInvalidObservableTypeError(input) {
  return new TypeError("You provided " + (input !== null && typeof input === "object" ? "an invalid object" : "'" + input + "'") + " where a stream was expected. You can provide an Observable, Promise, ReadableStream, Array, AsyncIterable, or Iterable.");
}

// node_modules/rxjs/dist/esm5/internal/symbol/iterator.js
function getSymbolIterator() {
  if (typeof Symbol !== "function" || !Symbol.iterator) {
    return "@@iterator";
  }
  return Symbol.iterator;
}
var iterator = getSymbolIterator();

// node_modules/rxjs/dist/esm5/internal/util/isIterable.js
function isIterable(input) {
  return isFunction(input === null || input === void 0 ? void 0 : input[iterator]);
}

// node_modules/rxjs/dist/esm5/internal/util/isReadableStreamLike.js
function readableStreamLikeToAsyncGenerator(readableStream) {
  return __asyncGenerator(this, arguments, function readableStreamLikeToAsyncGenerator_1() {
    var reader, _a, value, done;
    return __generator(this, function(_b) {
      switch (_b.label) {
        case 0:
          reader = readableStream.getReader();
          _b.label = 1;
        case 1:
          _b.trys.push([1, , 9, 10]);
          _b.label = 2;
        case 2:
          if (false) return [3, 8];
          return [4, __await(reader.read())];
        case 3:
          _a = _b.sent(), value = _a.value, done = _a.done;
          if (!done) return [3, 5];
          return [4, __await(void 0)];
        case 4:
          return [2, _b.sent()];
        case 5:
          return [4, __await(value)];
        case 6:
          return [4, _b.sent()];
        case 7:
          _b.sent();
          return [3, 2];
        case 8:
          return [3, 10];
        case 9:
          reader.releaseLock();
          return [7];
        case 10:
          return [2];
      }
    });
  });
}
function isReadableStreamLike(obj) {
  return isFunction(obj === null || obj === void 0 ? void 0 : obj.getReader);
}

// node_modules/rxjs/dist/esm5/internal/observable/innerFrom.js
function innerFrom(input) {
  if (input instanceof Observable) {
    return input;
  }
  if (input != null) {
    if (isInteropObservable(input)) {
      return fromInteropObservable(input);
    }
    if (isArrayLike(input)) {
      return fromArrayLike(input);
    }
    if (isPromise(input)) {
      return fromPromise(input);
    }
    if (isAsyncIterable(input)) {
      return fromAsyncIterable(input);
    }
    if (isIterable(input)) {
      return fromIterable(input);
    }
    if (isReadableStreamLike(input)) {
      return fromReadableStreamLike(input);
    }
  }
  throw createInvalidObservableTypeError(input);
}
function fromInteropObservable(obj) {
  return new Observable(function(subscriber) {
    var obs = obj[observable]();
    if (isFunction(obs.subscribe)) {
      return obs.subscribe(subscriber);
    }
    throw new TypeError("Provided object does not correctly implement Symbol.observable");
  });
}
function fromArrayLike(array) {
  return new Observable(function(subscriber) {
    for (var i = 0; i < array.length && !subscriber.closed; i++) {
      subscriber.next(array[i]);
    }
    subscriber.complete();
  });
}
function fromPromise(promise) {
  return new Observable(function(subscriber) {
    promise.then(function(value) {
      if (!subscriber.closed) {
        subscriber.next(value);
        subscriber.complete();
      }
    }, function(err) {
      return subscriber.error(err);
    }).then(null, reportUnhandledError);
  });
}
function fromIterable(iterable) {
  return new Observable(function(subscriber) {
    var e_1, _a;
    try {
      for (var iterable_1 = __values(iterable), iterable_1_1 = iterable_1.next(); !iterable_1_1.done; iterable_1_1 = iterable_1.next()) {
        var value = iterable_1_1.value;
        subscriber.next(value);
        if (subscriber.closed) {
          return;
        }
      }
    } catch (e_1_1) {
      e_1 = {
        error: e_1_1
      };
    } finally {
      try {
        if (iterable_1_1 && !iterable_1_1.done && (_a = iterable_1.return)) _a.call(iterable_1);
      } finally {
        if (e_1) throw e_1.error;
      }
    }
    subscriber.complete();
  });
}
function fromAsyncIterable(asyncIterable) {
  return new Observable(function(subscriber) {
    process(asyncIterable, subscriber).catch(function(err) {
      return subscriber.error(err);
    });
  });
}
function fromReadableStreamLike(readableStream) {
  return fromAsyncIterable(readableStreamLikeToAsyncGenerator(readableStream));
}
function process(asyncIterable, subscriber) {
  var asyncIterable_1, asyncIterable_1_1;
  var e_2, _a;
  return __awaiter(this, void 0, void 0, function() {
    var value, e_2_1;
    return __generator(this, function(_b) {
      switch (_b.label) {
        case 0:
          _b.trys.push([0, 5, 6, 11]);
          asyncIterable_1 = __asyncValues(asyncIterable);
          _b.label = 1;
        case 1:
          return [4, asyncIterable_1.next()];
        case 2:
          if (!(asyncIterable_1_1 = _b.sent(), !asyncIterable_1_1.done)) return [3, 4];
          value = asyncIterable_1_1.value;
          subscriber.next(value);
          if (subscriber.closed) {
            return [2];
          }
          _b.label = 3;
        case 3:
          return [3, 1];
        case 4:
          return [3, 11];
        case 5:
          e_2_1 = _b.sent();
          e_2 = {
            error: e_2_1
          };
          return [3, 11];
        case 6:
          _b.trys.push([6, , 9, 10]);
          if (!(asyncIterable_1_1 && !asyncIterable_1_1.done && (_a = asyncIterable_1.return))) return [3, 8];
          return [4, _a.call(asyncIterable_1)];
        case 7:
          _b.sent();
          _b.label = 8;
        case 8:
          return [3, 10];
        case 9:
          if (e_2) throw e_2.error;
          return [7];
        case 10:
          return [7];
        case 11:
          subscriber.complete();
          return [2];
      }
    });
  });
}

// node_modules/rxjs/dist/esm5/internal/scheduled/scheduleObservable.js
function scheduleObservable(input, scheduler) {
  return innerFrom(input).pipe(subscribeOn(scheduler), observeOn(scheduler));
}

// node_modules/rxjs/dist/esm5/internal/scheduled/schedulePromise.js
function schedulePromise(input, scheduler) {
  return innerFrom(input).pipe(subscribeOn(scheduler), observeOn(scheduler));
}

// node_modules/rxjs/dist/esm5/internal/scheduled/scheduleArray.js
function scheduleArray(input, scheduler) {
  return new Observable(function(subscriber) {
    var i = 0;
    return scheduler.schedule(function() {
      if (i === input.length) {
        subscriber.complete();
      } else {
        subscriber.next(input[i++]);
        if (!subscriber.closed) {
          this.schedule();
        }
      }
    });
  });
}

// node_modules/rxjs/dist/esm5/internal/scheduled/scheduleIterable.js
function scheduleIterable(input, scheduler) {
  return new Observable(function(subscriber) {
    var iterator2;
    executeSchedule(subscriber, scheduler, function() {
      iterator2 = input[iterator]();
      executeSchedule(subscriber, scheduler, function() {
        var _a;
        var value;
        var done;
        try {
          _a = iterator2.next(), value = _a.value, done = _a.done;
        } catch (err) {
          subscriber.error(err);
          return;
        }
        if (done) {
          subscriber.complete();
        } else {
          subscriber.next(value);
        }
      }, 0, true);
    });
    return function() {
      return isFunction(iterator2 === null || iterator2 === void 0 ? void 0 : iterator2.return) && iterator2.return();
    };
  });
}

// node_modules/rxjs/dist/esm5/internal/scheduled/scheduleAsyncIterable.js
function scheduleAsyncIterable(input, scheduler) {
  if (!input) {
    throw new Error("Iterable cannot be null");
  }
  return new Observable(function(subscriber) {
    executeSchedule(subscriber, scheduler, function() {
      var iterator2 = input[Symbol.asyncIterator]();
      executeSchedule(subscriber, scheduler, function() {
        iterator2.next().then(function(result) {
          if (result.done) {
            subscriber.complete();
          } else {
            subscriber.next(result.value);
          }
        });
      }, 0, true);
    });
  });
}

// node_modules/rxjs/dist/esm5/internal/scheduled/scheduleReadableStreamLike.js
function scheduleReadableStreamLike(input, scheduler) {
  return scheduleAsyncIterable(readableStreamLikeToAsyncGenerator(input), scheduler);
}

// node_modules/rxjs/dist/esm5/internal/scheduled/scheduled.js
function scheduled(input, scheduler) {
  if (input != null) {
    if (isInteropObservable(input)) {
      return scheduleObservable(input, scheduler);
    }
    if (isArrayLike(input)) {
      return scheduleArray(input, scheduler);
    }
    if (isPromise(input)) {
      return schedulePromise(input, scheduler);
    }
    if (isAsyncIterable(input)) {
      return scheduleAsyncIterable(input, scheduler);
    }
    if (isIterable(input)) {
      return scheduleIterable(input, scheduler);
    }
    if (isReadableStreamLike(input)) {
      return scheduleReadableStreamLike(input, scheduler);
    }
  }
  throw createInvalidObservableTypeError(input);
}

// node_modules/rxjs/dist/esm5/internal/observable/from.js
function from(input, scheduler) {
  return scheduler ? scheduled(input, scheduler) : innerFrom(input);
}

// node_modules/rxjs/dist/esm5/internal/util/isScheduler.js
function isScheduler(value) {
  return value && isFunction(value.schedule);
}

// node_modules/rxjs/dist/esm5/internal/util/args.js
function last(arr) {
  return arr[arr.length - 1];
}
function popResultSelector(args) {
  return isFunction(last(args)) ? args.pop() : void 0;
}
function popScheduler(args) {
  return isScheduler(last(args)) ? args.pop() : void 0;
}
function popNumber(args, defaultValue) {
  return typeof last(args) === "number" ? args.pop() : defaultValue;
}

// node_modules/rxjs/dist/esm5/internal/observable/of.js
function of() {
  var args = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    args[_i] = arguments[_i];
  }
  var scheduler = popScheduler(args);
  return from(args, scheduler);
}

// node_modules/rxjs/dist/esm5/internal/observable/throwError.js
function throwError(errorOrErrorFactory, scheduler) {
  var errorFactory = isFunction(errorOrErrorFactory) ? errorOrErrorFactory : function() {
    return errorOrErrorFactory;
  };
  var init = function(subscriber) {
    return subscriber.error(errorFactory());
  };
  return new Observable(scheduler ? function(subscriber) {
    return scheduler.schedule(init, 0, subscriber);
  } : init);
}

// node_modules/rxjs/dist/esm5/internal/Notification.js
var NotificationKind;
(function(NotificationKind2) {
  NotificationKind2["NEXT"] = "N";
  NotificationKind2["ERROR"] = "E";
  NotificationKind2["COMPLETE"] = "C";
})(NotificationKind || (NotificationKind = {}));
var Notification = function() {
  function Notification2(kind, value, error) {
    this.kind = kind;
    this.value = value;
    this.error = error;
    this.hasValue = kind === "N";
  }
  Notification2.prototype.observe = function(observer) {
    return observeNotification(this, observer);
  };
  Notification2.prototype.do = function(nextHandler, errorHandler, completeHandler) {
    var _a = this, kind = _a.kind, value = _a.value, error = _a.error;
    return kind === "N" ? nextHandler === null || nextHandler === void 0 ? void 0 : nextHandler(value) : kind === "E" ? errorHandler === null || errorHandler === void 0 ? void 0 : errorHandler(error) : completeHandler === null || completeHandler === void 0 ? void 0 : completeHandler();
  };
  Notification2.prototype.accept = function(nextOrObserver, error, complete) {
    var _a;
    return isFunction((_a = nextOrObserver) === null || _a === void 0 ? void 0 : _a.next) ? this.observe(nextOrObserver) : this.do(nextOrObserver, error, complete);
  };
  Notification2.prototype.toObservable = function() {
    var _a = this, kind = _a.kind, value = _a.value, error = _a.error;
    var result = kind === "N" ? of(value) : kind === "E" ? throwError(function() {
      return error;
    }) : kind === "C" ? EMPTY : 0;
    if (!result) {
      throw new TypeError("Unexpected notification kind " + kind);
    }
    return result;
  };
  Notification2.createNext = function(value) {
    return new Notification2("N", value);
  };
  Notification2.createError = function(err) {
    return new Notification2("E", void 0, err);
  };
  Notification2.createComplete = function() {
    return Notification2.completeNotification;
  };
  Notification2.completeNotification = new Notification2("C");
  return Notification2;
}();
function observeNotification(notification, observer) {
  var _a, _b, _c;
  var _d = notification, kind = _d.kind, value = _d.value, error = _d.error;
  if (typeof kind !== "string") {
    throw new TypeError('Invalid notification, missing "kind"');
  }
  kind === "N" ? (_a = observer.next) === null || _a === void 0 ? void 0 : _a.call(observer, value) : kind === "E" ? (_b = observer.error) === null || _b === void 0 ? void 0 : _b.call(observer, error) : (_c = observer.complete) === null || _c === void 0 ? void 0 : _c.call(observer);
}

// node_modules/rxjs/dist/esm5/internal/util/EmptyError.js
var EmptyError = createErrorClass(function(_super) {
  return function EmptyErrorImpl() {
    _super(this);
    this.name = "EmptyError";
    this.message = "no elements in sequence";
  };
});

// node_modules/rxjs/dist/esm5/internal/util/ArgumentOutOfRangeError.js
var ArgumentOutOfRangeError = createErrorClass(function(_super) {
  return function ArgumentOutOfRangeErrorImpl() {
    _super(this);
    this.name = "ArgumentOutOfRangeError";
    this.message = "argument out of range";
  };
});

// node_modules/rxjs/dist/esm5/internal/util/NotFoundError.js
var NotFoundError = createErrorClass(function(_super) {
  return function NotFoundErrorImpl(message) {
    _super(this);
    this.name = "NotFoundError";
    this.message = message;
  };
});

// node_modules/rxjs/dist/esm5/internal/util/SequenceError.js
var SequenceError = createErrorClass(function(_super) {
  return function SequenceErrorImpl(message) {
    _super(this);
    this.name = "SequenceError";
    this.message = message;
  };
});

// node_modules/rxjs/dist/esm5/internal/util/isDate.js
function isValidDate(value) {
  return value instanceof Date && !isNaN(value);
}

// node_modules/rxjs/dist/esm5/internal/operators/timeout.js
var TimeoutError = createErrorClass(function(_super) {
  return function TimeoutErrorImpl(info) {
    if (info === void 0) {
      info = null;
    }
    _super(this);
    this.message = "Timeout has occurred";
    this.name = "TimeoutError";
    this.info = info;
  };
});
function timeout(config2, schedulerArg) {
  var _a = isValidDate(config2) ? {
    first: config2
  } : typeof config2 === "number" ? {
    each: config2
  } : config2, first2 = _a.first, each = _a.each, _b = _a.with, _with = _b === void 0 ? timeoutErrorFactory : _b, _c = _a.scheduler, scheduler = _c === void 0 ? schedulerArg !== null && schedulerArg !== void 0 ? schedulerArg : asyncScheduler : _c, _d = _a.meta, meta = _d === void 0 ? null : _d;
  if (first2 == null && each == null) {
    throw new TypeError("No timeout provided.");
  }
  return operate(function(source, subscriber) {
    var originalSourceSubscription;
    var timerSubscription;
    var lastValue = null;
    var seen = 0;
    var startTimer = function(delay2) {
      timerSubscription = executeSchedule(subscriber, scheduler, function() {
        try {
          originalSourceSubscription.unsubscribe();
          innerFrom(_with({
            meta,
            lastValue,
            seen
          })).subscribe(subscriber);
        } catch (err) {
          subscriber.error(err);
        }
      }, delay2);
    };
    originalSourceSubscription = source.subscribe(createOperatorSubscriber(subscriber, function(value) {
      timerSubscription === null || timerSubscription === void 0 ? void 0 : timerSubscription.unsubscribe();
      seen++;
      subscriber.next(lastValue = value);
      each > 0 && startTimer(each);
    }, void 0, void 0, function() {
      if (!(timerSubscription === null || timerSubscription === void 0 ? void 0 : timerSubscription.closed)) {
        timerSubscription === null || timerSubscription === void 0 ? void 0 : timerSubscription.unsubscribe();
      }
      lastValue = null;
    }));
    !seen && startTimer(first2 != null ? typeof first2 === "number" ? first2 : +first2 - scheduler.now() : each);
  });
}
function timeoutErrorFactory(info) {
  throw new TimeoutError(info);
}

// node_modules/rxjs/dist/esm5/internal/operators/map.js
function map(project, thisArg) {
  return operate(function(source, subscriber) {
    var index = 0;
    source.subscribe(createOperatorSubscriber(subscriber, function(value) {
      subscriber.next(project.call(thisArg, value, index++));
    }));
  });
}

// node_modules/rxjs/dist/esm5/internal/util/argsArgArrayOrObject.js
var isArray = Array.isArray;
var getPrototypeOf = Object.getPrototypeOf;
var objectProto = Object.prototype;
var getKeys = Object.keys;
function argsArgArrayOrObject(args) {
  if (args.length === 1) {
    var first_1 = args[0];
    if (isArray(first_1)) {
      return {
        args: first_1,
        keys: null
      };
    }
    if (isPOJO(first_1)) {
      var keys = getKeys(first_1);
      return {
        args: keys.map(function(key) {
          return first_1[key];
        }),
        keys
      };
    }
  }
  return {
    args,
    keys: null
  };
}
function isPOJO(obj) {
  return obj && typeof obj === "object" && getPrototypeOf(obj) === objectProto;
}

// node_modules/rxjs/dist/esm5/internal/util/mapOneOrManyArgs.js
var isArray2 = Array.isArray;
function callOrApply(fn, args) {
  return isArray2(args) ? fn.apply(void 0, __spreadArray([], __read(args))) : fn(args);
}
function mapOneOrManyArgs(fn) {
  return map(function(args) {
    return callOrApply(fn, args);
  });
}

// node_modules/rxjs/dist/esm5/internal/util/createObject.js
function createObject(keys, values) {
  return keys.reduce(function(result, key, i) {
    return result[key] = values[i], result;
  }, {});
}

// node_modules/rxjs/dist/esm5/internal/observable/combineLatest.js
function combineLatest() {
  var args = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    args[_i] = arguments[_i];
  }
  var scheduler = popScheduler(args);
  var resultSelector = popResultSelector(args);
  var _a = argsArgArrayOrObject(args), observables = _a.args, keys = _a.keys;
  if (observables.length === 0) {
    return from([], scheduler);
  }
  var result = new Observable(combineLatestInit(observables, scheduler, keys ? function(values) {
    return createObject(keys, values);
  } : identity));
  return resultSelector ? result.pipe(mapOneOrManyArgs(resultSelector)) : result;
}
function combineLatestInit(observables, scheduler, valueTransform) {
  if (valueTransform === void 0) {
    valueTransform = identity;
  }
  return function(subscriber) {
    maybeSchedule(scheduler, function() {
      var length = observables.length;
      var values = new Array(length);
      var active = length;
      var remainingFirstValues = length;
      var _loop_1 = function(i2) {
        maybeSchedule(scheduler, function() {
          var source = from(observables[i2], scheduler);
          var hasFirstValue = false;
          source.subscribe(createOperatorSubscriber(subscriber, function(value) {
            values[i2] = value;
            if (!hasFirstValue) {
              hasFirstValue = true;
              remainingFirstValues--;
            }
            if (!remainingFirstValues) {
              subscriber.next(valueTransform(values.slice()));
            }
          }, function() {
            if (!--active) {
              subscriber.complete();
            }
          }));
        }, subscriber);
      };
      for (var i = 0; i < length; i++) {
        _loop_1(i);
      }
    }, subscriber);
  };
}
function maybeSchedule(scheduler, execute, subscription) {
  if (scheduler) {
    executeSchedule(subscription, scheduler, execute);
  } else {
    execute();
  }
}

// node_modules/rxjs/dist/esm5/internal/operators/mergeInternals.js
function mergeInternals(source, subscriber, project, concurrent, onBeforeNext, expand2, innerSubScheduler, additionalFinalizer) {
  var buffer2 = [];
  var active = 0;
  var index = 0;
  var isComplete = false;
  var checkComplete = function() {
    if (isComplete && !buffer2.length && !active) {
      subscriber.complete();
    }
  };
  var outerNext = function(value) {
    return active < concurrent ? doInnerSub(value) : buffer2.push(value);
  };
  var doInnerSub = function(value) {
    expand2 && subscriber.next(value);
    active++;
    var innerComplete = false;
    innerFrom(project(value, index++)).subscribe(createOperatorSubscriber(subscriber, function(innerValue) {
      onBeforeNext === null || onBeforeNext === void 0 ? void 0 : onBeforeNext(innerValue);
      if (expand2) {
        outerNext(innerValue);
      } else {
        subscriber.next(innerValue);
      }
    }, function() {
      innerComplete = true;
    }, void 0, function() {
      if (innerComplete) {
        try {
          active--;
          var _loop_1 = function() {
            var bufferedValue = buffer2.shift();
            if (innerSubScheduler) {
              executeSchedule(subscriber, innerSubScheduler, function() {
                return doInnerSub(bufferedValue);
              });
            } else {
              doInnerSub(bufferedValue);
            }
          };
          while (buffer2.length && active < concurrent) {
            _loop_1();
          }
          checkComplete();
        } catch (err) {
          subscriber.error(err);
        }
      }
    }));
  };
  source.subscribe(createOperatorSubscriber(subscriber, outerNext, function() {
    isComplete = true;
    checkComplete();
  }));
  return function() {
    additionalFinalizer === null || additionalFinalizer === void 0 ? void 0 : additionalFinalizer();
  };
}

// node_modules/rxjs/dist/esm5/internal/operators/mergeMap.js
function mergeMap(project, resultSelector, concurrent) {
  if (concurrent === void 0) {
    concurrent = Infinity;
  }
  if (isFunction(resultSelector)) {
    return mergeMap(function(a, i) {
      return map(function(b, ii) {
        return resultSelector(a, b, i, ii);
      })(innerFrom(project(a, i)));
    }, concurrent);
  } else if (typeof resultSelector === "number") {
    concurrent = resultSelector;
  }
  return operate(function(source, subscriber) {
    return mergeInternals(source, subscriber, project, concurrent);
  });
}

// node_modules/rxjs/dist/esm5/internal/operators/mergeAll.js
function mergeAll(concurrent) {
  if (concurrent === void 0) {
    concurrent = Infinity;
  }
  return mergeMap(identity, concurrent);
}

// node_modules/rxjs/dist/esm5/internal/operators/concatAll.js
function concatAll() {
  return mergeAll(1);
}

// node_modules/rxjs/dist/esm5/internal/observable/concat.js
function concat() {
  var args = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    args[_i] = arguments[_i];
  }
  return concatAll()(from(args, popScheduler(args)));
}

// node_modules/rxjs/dist/esm5/internal/observable/timer.js
function timer(dueTime, intervalOrScheduler, scheduler) {
  if (dueTime === void 0) {
    dueTime = 0;
  }
  if (scheduler === void 0) {
    scheduler = async;
  }
  var intervalDuration = -1;
  if (intervalOrScheduler != null) {
    if (isScheduler(intervalOrScheduler)) {
      scheduler = intervalOrScheduler;
    } else {
      intervalDuration = intervalOrScheduler;
    }
  }
  return new Observable(function(subscriber) {
    var due = isValidDate(dueTime) ? +dueTime - scheduler.now() : dueTime;
    if (due < 0) {
      due = 0;
    }
    var n = 0;
    return scheduler.schedule(function() {
      if (!subscriber.closed) {
        subscriber.next(n++);
        if (0 <= intervalDuration) {
          this.schedule(void 0, intervalDuration);
        } else {
          subscriber.complete();
        }
      }
    }, due);
  });
}

// node_modules/rxjs/dist/esm5/internal/observable/interval.js
function interval(period, scheduler) {
  if (period === void 0) {
    period = 0;
  }
  if (scheduler === void 0) {
    scheduler = asyncScheduler;
  }
  if (period < 0) {
    period = 0;
  }
  return timer(period, period, scheduler);
}

// node_modules/rxjs/dist/esm5/internal/util/argsOrArgArray.js
var isArray3 = Array.isArray;
function argsOrArgArray(args) {
  return args.length === 1 && isArray3(args[0]) ? args[0] : args;
}

// node_modules/rxjs/dist/esm5/internal/observable/onErrorResumeNext.js
function onErrorResumeNext() {
  var sources = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    sources[_i] = arguments[_i];
  }
  var nextSources = argsOrArgArray(sources);
  return new Observable(function(subscriber) {
    var sourceIndex = 0;
    var subscribeNext = function() {
      if (sourceIndex < nextSources.length) {
        var nextSource = void 0;
        try {
          nextSource = innerFrom(nextSources[sourceIndex++]);
        } catch (err) {
          subscribeNext();
          return;
        }
        var innerSubscriber = new OperatorSubscriber(subscriber, void 0, noop, noop);
        nextSource.subscribe(innerSubscriber);
        innerSubscriber.add(subscribeNext);
      } else {
        subscriber.complete();
      }
    };
    subscribeNext();
  });
}

// node_modules/rxjs/dist/esm5/internal/operators/filter.js
function filter(predicate, thisArg) {
  return operate(function(source, subscriber) {
    var index = 0;
    source.subscribe(createOperatorSubscriber(subscriber, function(value) {
      return predicate.call(thisArg, value, index++) && subscriber.next(value);
    }));
  });
}

// node_modules/rxjs/dist/esm5/internal/observable/race.js
function race() {
  var sources = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    sources[_i] = arguments[_i];
  }
  sources = argsOrArgArray(sources);
  return sources.length === 1 ? innerFrom(sources[0]) : new Observable(raceInit(sources));
}
function raceInit(sources) {
  return function(subscriber) {
    var subscriptions = [];
    var _loop_1 = function(i2) {
      subscriptions.push(innerFrom(sources[i2]).subscribe(createOperatorSubscriber(subscriber, function(value) {
        if (subscriptions) {
          for (var s = 0; s < subscriptions.length; s++) {
            s !== i2 && subscriptions[s].unsubscribe();
          }
          subscriptions = null;
        }
        subscriber.next(value);
      })));
    };
    for (var i = 0; subscriptions && !subscriber.closed && i < sources.length; i++) {
      _loop_1(i);
    }
  };
}

// node_modules/rxjs/dist/esm5/internal/observable/zip.js
function zip() {
  var args = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    args[_i] = arguments[_i];
  }
  var resultSelector = popResultSelector(args);
  var sources = argsOrArgArray(args);
  return sources.length ? new Observable(function(subscriber) {
    var buffers = sources.map(function() {
      return [];
    });
    var completed = sources.map(function() {
      return false;
    });
    subscriber.add(function() {
      buffers = completed = null;
    });
    var _loop_1 = function(sourceIndex2) {
      innerFrom(sources[sourceIndex2]).subscribe(createOperatorSubscriber(subscriber, function(value) {
        buffers[sourceIndex2].push(value);
        if (buffers.every(function(buffer2) {
          return buffer2.length;
        })) {
          var result = buffers.map(function(buffer2) {
            return buffer2.shift();
          });
          subscriber.next(resultSelector ? resultSelector.apply(void 0, __spreadArray([], __read(result))) : result);
          if (buffers.some(function(buffer2, i) {
            return !buffer2.length && completed[i];
          })) {
            subscriber.complete();
          }
        }
      }, function() {
        completed[sourceIndex2] = true;
        !buffers[sourceIndex2].length && subscriber.complete();
      }));
    };
    for (var sourceIndex = 0; !subscriber.closed && sourceIndex < sources.length; sourceIndex++) {
      _loop_1(sourceIndex);
    }
    return function() {
      buffers = completed = null;
    };
  }) : EMPTY;
}

// node_modules/rxjs/dist/esm5/internal/operators/audit.js
function audit(durationSelector) {
  return operate(function(source, subscriber) {
    var hasValue = false;
    var lastValue = null;
    var durationSubscriber = null;
    var isComplete = false;
    var endDuration = function() {
      durationSubscriber === null || durationSubscriber === void 0 ? void 0 : durationSubscriber.unsubscribe();
      durationSubscriber = null;
      if (hasValue) {
        hasValue = false;
        var value = lastValue;
        lastValue = null;
        subscriber.next(value);
      }
      isComplete && subscriber.complete();
    };
    var cleanupDuration = function() {
      durationSubscriber = null;
      isComplete && subscriber.complete();
    };
    source.subscribe(createOperatorSubscriber(subscriber, function(value) {
      hasValue = true;
      lastValue = value;
      if (!durationSubscriber) {
        innerFrom(durationSelector(value)).subscribe(durationSubscriber = createOperatorSubscriber(subscriber, endDuration, cleanupDuration));
      }
    }, function() {
      isComplete = true;
      (!hasValue || !durationSubscriber || durationSubscriber.closed) && subscriber.complete();
    }));
  });
}

// node_modules/rxjs/dist/esm5/internal/operators/auditTime.js
function auditTime(duration, scheduler) {
  if (scheduler === void 0) {
    scheduler = asyncScheduler;
  }
  return audit(function() {
    return timer(duration, scheduler);
  });
}

// node_modules/rxjs/dist/esm5/internal/operators/buffer.js
function buffer(closingNotifier) {
  return operate(function(source, subscriber) {
    var currentBuffer = [];
    source.subscribe(createOperatorSubscriber(subscriber, function(value) {
      return currentBuffer.push(value);
    }, function() {
      subscriber.next(currentBuffer);
      subscriber.complete();
    }));
    innerFrom(closingNotifier).subscribe(createOperatorSubscriber(subscriber, function() {
      var b = currentBuffer;
      currentBuffer = [];
      subscriber.next(b);
    }, noop));
    return function() {
      currentBuffer = null;
    };
  });
}

// node_modules/rxjs/dist/esm5/internal/operators/bufferCount.js
function bufferCount(bufferSize, startBufferEvery) {
  if (startBufferEvery === void 0) {
    startBufferEvery = null;
  }
  startBufferEvery = startBufferEvery !== null && startBufferEvery !== void 0 ? startBufferEvery : bufferSize;
  return operate(function(source, subscriber) {
    var buffers = [];
    var count2 = 0;
    source.subscribe(createOperatorSubscriber(subscriber, function(value) {
      var e_1, _a, e_2, _b;
      var toEmit = null;
      if (count2++ % startBufferEvery === 0) {
        buffers.push([]);
      }
      try {
        for (var buffers_1 = __values(buffers), buffers_1_1 = buffers_1.next(); !buffers_1_1.done; buffers_1_1 = buffers_1.next()) {
          var buffer2 = buffers_1_1.value;
          buffer2.push(value);
          if (bufferSize <= buffer2.length) {
            toEmit = toEmit !== null && toEmit !== void 0 ? toEmit : [];
            toEmit.push(buffer2);
          }
        }
      } catch (e_1_1) {
        e_1 = {
          error: e_1_1
        };
      } finally {
        try {
          if (buffers_1_1 && !buffers_1_1.done && (_a = buffers_1.return)) _a.call(buffers_1);
        } finally {
          if (e_1) throw e_1.error;
        }
      }
      if (toEmit) {
        try {
          for (var toEmit_1 = __values(toEmit), toEmit_1_1 = toEmit_1.next(); !toEmit_1_1.done; toEmit_1_1 = toEmit_1.next()) {
            var buffer2 = toEmit_1_1.value;
            arrRemove(buffers, buffer2);
            subscriber.next(buffer2);
          }
        } catch (e_2_1) {
          e_2 = {
            error: e_2_1
          };
        } finally {
          try {
            if (toEmit_1_1 && !toEmit_1_1.done && (_b = toEmit_1.return)) _b.call(toEmit_1);
          } finally {
            if (e_2) throw e_2.error;
          }
        }
      }
    }, function() {
      var e_3, _a;
      try {
        for (var buffers_2 = __values(buffers), buffers_2_1 = buffers_2.next(); !buffers_2_1.done; buffers_2_1 = buffers_2.next()) {
          var buffer2 = buffers_2_1.value;
          subscriber.next(buffer2);
        }
      } catch (e_3_1) {
        e_3 = {
          error: e_3_1
        };
      } finally {
        try {
          if (buffers_2_1 && !buffers_2_1.done && (_a = buffers_2.return)) _a.call(buffers_2);
        } finally {
          if (e_3) throw e_3.error;
        }
      }
      subscriber.complete();
    }, void 0, function() {
      buffers = null;
    }));
  });
}

// node_modules/rxjs/dist/esm5/internal/operators/bufferTime.js
function bufferTime(bufferTimeSpan) {
  var _a, _b;
  var otherArgs = [];
  for (var _i = 1; _i < arguments.length; _i++) {
    otherArgs[_i - 1] = arguments[_i];
  }
  var scheduler = (_a = popScheduler(otherArgs)) !== null && _a !== void 0 ? _a : asyncScheduler;
  var bufferCreationInterval = (_b = otherArgs[0]) !== null && _b !== void 0 ? _b : null;
  var maxBufferSize = otherArgs[1] || Infinity;
  return operate(function(source, subscriber) {
    var bufferRecords = [];
    var restartOnEmit = false;
    var emit = function(record) {
      var buffer2 = record.buffer, subs = record.subs;
      subs.unsubscribe();
      arrRemove(bufferRecords, record);
      subscriber.next(buffer2);
      restartOnEmit && startBuffer();
    };
    var startBuffer = function() {
      if (bufferRecords) {
        var subs = new Subscription();
        subscriber.add(subs);
        var buffer2 = [];
        var record_1 = {
          buffer: buffer2,
          subs
        };
        bufferRecords.push(record_1);
        executeSchedule(subs, scheduler, function() {
          return emit(record_1);
        }, bufferTimeSpan);
      }
    };
    if (bufferCreationInterval !== null && bufferCreationInterval >= 0) {
      executeSchedule(subscriber, scheduler, startBuffer, bufferCreationInterval, true);
    } else {
      restartOnEmit = true;
    }
    startBuffer();
    var bufferTimeSubscriber = createOperatorSubscriber(subscriber, function(value) {
      var e_1, _a2;
      var recordsCopy = bufferRecords.slice();
      try {
        for (var recordsCopy_1 = __values(recordsCopy), recordsCopy_1_1 = recordsCopy_1.next(); !recordsCopy_1_1.done; recordsCopy_1_1 = recordsCopy_1.next()) {
          var record = recordsCopy_1_1.value;
          var buffer2 = record.buffer;
          buffer2.push(value);
          maxBufferSize <= buffer2.length && emit(record);
        }
      } catch (e_1_1) {
        e_1 = {
          error: e_1_1
        };
      } finally {
        try {
          if (recordsCopy_1_1 && !recordsCopy_1_1.done && (_a2 = recordsCopy_1.return)) _a2.call(recordsCopy_1);
        } finally {
          if (e_1) throw e_1.error;
        }
      }
    }, function() {
      while (bufferRecords === null || bufferRecords === void 0 ? void 0 : bufferRecords.length) {
        subscriber.next(bufferRecords.shift().buffer);
      }
      bufferTimeSubscriber === null || bufferTimeSubscriber === void 0 ? void 0 : bufferTimeSubscriber.unsubscribe();
      subscriber.complete();
      subscriber.unsubscribe();
    }, void 0, function() {
      return bufferRecords = null;
    });
    source.subscribe(bufferTimeSubscriber);
  });
}

// node_modules/rxjs/dist/esm5/internal/operators/bufferToggle.js
function bufferToggle(openings, closingSelector) {
  return operate(function(source, subscriber) {
    var buffers = [];
    innerFrom(openings).subscribe(createOperatorSubscriber(subscriber, function(openValue) {
      var buffer2 = [];
      buffers.push(buffer2);
      var closingSubscription = new Subscription();
      var emitBuffer = function() {
        arrRemove(buffers, buffer2);
        subscriber.next(buffer2);
        closingSubscription.unsubscribe();
      };
      closingSubscription.add(innerFrom(closingSelector(openValue)).subscribe(createOperatorSubscriber(subscriber, emitBuffer, noop)));
    }, noop));
    source.subscribe(createOperatorSubscriber(subscriber, function(value) {
      var e_1, _a;
      try {
        for (var buffers_1 = __values(buffers), buffers_1_1 = buffers_1.next(); !buffers_1_1.done; buffers_1_1 = buffers_1.next()) {
          var buffer2 = buffers_1_1.value;
          buffer2.push(value);
        }
      } catch (e_1_1) {
        e_1 = {
          error: e_1_1
        };
      } finally {
        try {
          if (buffers_1_1 && !buffers_1_1.done && (_a = buffers_1.return)) _a.call(buffers_1);
        } finally {
          if (e_1) throw e_1.error;
        }
      }
    }, function() {
      while (buffers.length > 0) {
        subscriber.next(buffers.shift());
      }
      subscriber.complete();
    }));
  });
}

// node_modules/rxjs/dist/esm5/internal/operators/bufferWhen.js
function bufferWhen(closingSelector) {
  return operate(function(source, subscriber) {
    var buffer2 = null;
    var closingSubscriber = null;
    var openBuffer = function() {
      closingSubscriber === null || closingSubscriber === void 0 ? void 0 : closingSubscriber.unsubscribe();
      var b = buffer2;
      buffer2 = [];
      b && subscriber.next(b);
      innerFrom(closingSelector()).subscribe(closingSubscriber = createOperatorSubscriber(subscriber, openBuffer, noop));
    };
    openBuffer();
    source.subscribe(createOperatorSubscriber(subscriber, function(value) {
      return buffer2 === null || buffer2 === void 0 ? void 0 : buffer2.push(value);
    }, function() {
      buffer2 && subscriber.next(buffer2);
      subscriber.complete();
    }, void 0, function() {
      return buffer2 = closingSubscriber = null;
    }));
  });
}

// node_modules/rxjs/dist/esm5/internal/operators/catchError.js
function catchError(selector) {
  return operate(function(source, subscriber) {
    var innerSub = null;
    var syncUnsub = false;
    var handledResult;
    innerSub = source.subscribe(createOperatorSubscriber(subscriber, void 0, void 0, function(err) {
      handledResult = innerFrom(selector(err, catchError(selector)(source)));
      if (innerSub) {
        innerSub.unsubscribe();
        innerSub = null;
        handledResult.subscribe(subscriber);
      } else {
        syncUnsub = true;
      }
    }));
    if (syncUnsub) {
      innerSub.unsubscribe();
      innerSub = null;
      handledResult.subscribe(subscriber);
    }
  });
}

// node_modules/rxjs/dist/esm5/internal/operators/scanInternals.js
function scanInternals(accumulator, seed, hasSeed, emitOnNext, emitBeforeComplete) {
  return function(source, subscriber) {
    var hasState = hasSeed;
    var state = seed;
    var index = 0;
    source.subscribe(createOperatorSubscriber(subscriber, function(value) {
      var i = index++;
      state = hasState ? accumulator(state, value, i) : (hasState = true, value);
      emitOnNext && subscriber.next(state);
    }, emitBeforeComplete && function() {
      hasState && subscriber.next(state);
      subscriber.complete();
    }));
  };
}

// node_modules/rxjs/dist/esm5/internal/operators/reduce.js
function reduce(accumulator, seed) {
  return operate(scanInternals(accumulator, seed, arguments.length >= 2, false, true));
}

// node_modules/rxjs/dist/esm5/internal/operators/toArray.js
var arrReducer = function(arr, value) {
  return arr.push(value), arr;
};
function toArray() {
  return operate(function(source, subscriber) {
    reduce(arrReducer, [])(source).subscribe(subscriber);
  });
}

// node_modules/rxjs/dist/esm5/internal/operators/joinAllInternals.js
function joinAllInternals(joinFn, project) {
  return pipe(toArray(), mergeMap(function(sources) {
    return joinFn(sources);
  }), project ? mapOneOrManyArgs(project) : identity);
}

// node_modules/rxjs/dist/esm5/internal/operators/combineLatestAll.js
function combineLatestAll(project) {
  return joinAllInternals(combineLatest, project);
}

// node_modules/rxjs/dist/esm5/internal/operators/combineAll.js
var combineAll = combineLatestAll;

// node_modules/rxjs/dist/esm5/internal/operators/combineLatest.js
function combineLatest2() {
  var args = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    args[_i] = arguments[_i];
  }
  var resultSelector = popResultSelector(args);
  return resultSelector ? pipe(combineLatest2.apply(void 0, __spreadArray([], __read(args))), mapOneOrManyArgs(resultSelector)) : operate(function(source, subscriber) {
    combineLatestInit(__spreadArray([source], __read(argsOrArgArray(args))))(subscriber);
  });
}

// node_modules/rxjs/dist/esm5/internal/operators/combineLatestWith.js
function combineLatestWith() {
  var otherSources = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    otherSources[_i] = arguments[_i];
  }
  return combineLatest2.apply(void 0, __spreadArray([], __read(otherSources)));
}

// node_modules/rxjs/dist/esm5/internal/operators/concatMap.js
function concatMap(project, resultSelector) {
  return isFunction(resultSelector) ? mergeMap(project, resultSelector, 1) : mergeMap(project, 1);
}

// node_modules/rxjs/dist/esm5/internal/operators/concatMapTo.js
function concatMapTo(innerObservable, resultSelector) {
  return isFunction(resultSelector) ? concatMap(function() {
    return innerObservable;
  }, resultSelector) : concatMap(function() {
    return innerObservable;
  });
}

// node_modules/rxjs/dist/esm5/internal/operators/concat.js
function concat2() {
  var args = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    args[_i] = arguments[_i];
  }
  var scheduler = popScheduler(args);
  return operate(function(source, subscriber) {
    concatAll()(from(__spreadArray([source], __read(args)), scheduler)).subscribe(subscriber);
  });
}

// node_modules/rxjs/dist/esm5/internal/operators/concatWith.js
function concatWith() {
  var otherSources = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    otherSources[_i] = arguments[_i];
  }
  return concat2.apply(void 0, __spreadArray([], __read(otherSources)));
}

// node_modules/rxjs/dist/esm5/internal/observable/fromSubscribable.js
function fromSubscribable(subscribable) {
  return new Observable(function(subscriber) {
    return subscribable.subscribe(subscriber);
  });
}

// node_modules/rxjs/dist/esm5/internal/operators/connect.js
var DEFAULT_CONFIG = {
  connector: function() {
    return new Subject();
  }
};
function connect(selector, config2) {
  if (config2 === void 0) {
    config2 = DEFAULT_CONFIG;
  }
  var connector = config2.connector;
  return operate(function(source, subscriber) {
    var subject = connector();
    innerFrom(selector(fromSubscribable(subject))).subscribe(subscriber);
    subscriber.add(source.subscribe(subject));
  });
}

// node_modules/rxjs/dist/esm5/internal/operators/count.js
function count(predicate) {
  return reduce(function(total, value, i) {
    return !predicate || predicate(value, i) ? total + 1 : total;
  }, 0);
}

// node_modules/rxjs/dist/esm5/internal/operators/debounce.js
function debounce(durationSelector) {
  return operate(function(source, subscriber) {
    var hasValue = false;
    var lastValue = null;
    var durationSubscriber = null;
    var emit = function() {
      durationSubscriber === null || durationSubscriber === void 0 ? void 0 : durationSubscriber.unsubscribe();
      durationSubscriber = null;
      if (hasValue) {
        hasValue = false;
        var value = lastValue;
        lastValue = null;
        subscriber.next(value);
      }
    };
    source.subscribe(createOperatorSubscriber(subscriber, function(value) {
      durationSubscriber === null || durationSubscriber === void 0 ? void 0 : durationSubscriber.unsubscribe();
      hasValue = true;
      lastValue = value;
      durationSubscriber = createOperatorSubscriber(subscriber, emit, noop);
      innerFrom(durationSelector(value)).subscribe(durationSubscriber);
    }, function() {
      emit();
      subscriber.complete();
    }, void 0, function() {
      lastValue = durationSubscriber = null;
    }));
  });
}

// node_modules/rxjs/dist/esm5/internal/operators/debounceTime.js
function debounceTime(dueTime, scheduler) {
  if (scheduler === void 0) {
    scheduler = asyncScheduler;
  }
  return operate(function(source, subscriber) {
    var activeTask = null;
    var lastValue = null;
    var lastTime = null;
    var emit = function() {
      if (activeTask) {
        activeTask.unsubscribe();
        activeTask = null;
        var value = lastValue;
        lastValue = null;
        subscriber.next(value);
      }
    };
    function emitWhenIdle() {
      var targetTime = lastTime + dueTime;
      var now = scheduler.now();
      if (now < targetTime) {
        activeTask = this.schedule(void 0, targetTime - now);
        subscriber.add(activeTask);
        return;
      }
      emit();
    }
    source.subscribe(createOperatorSubscriber(subscriber, function(value) {
      lastValue = value;
      lastTime = scheduler.now();
      if (!activeTask) {
        activeTask = scheduler.schedule(emitWhenIdle, dueTime);
        subscriber.add(activeTask);
      }
    }, function() {
      emit();
      subscriber.complete();
    }, void 0, function() {
      lastValue = activeTask = null;
    }));
  });
}

// node_modules/rxjs/dist/esm5/internal/operators/defaultIfEmpty.js
function defaultIfEmpty(defaultValue) {
  return operate(function(source, subscriber) {
    var hasValue = false;
    source.subscribe(createOperatorSubscriber(subscriber, function(value) {
      hasValue = true;
      subscriber.next(value);
    }, function() {
      if (!hasValue) {
        subscriber.next(defaultValue);
      }
      subscriber.complete();
    }));
  });
}

// node_modules/rxjs/dist/esm5/internal/operators/take.js
function take(count2) {
  return count2 <= 0 ? function() {
    return EMPTY;
  } : operate(function(source, subscriber) {
    var seen = 0;
    source.subscribe(createOperatorSubscriber(subscriber, function(value) {
      if (++seen <= count2) {
        subscriber.next(value);
        if (count2 <= seen) {
          subscriber.complete();
        }
      }
    }));
  });
}

// node_modules/rxjs/dist/esm5/internal/operators/ignoreElements.js
function ignoreElements() {
  return operate(function(source, subscriber) {
    source.subscribe(createOperatorSubscriber(subscriber, noop));
  });
}

// node_modules/rxjs/dist/esm5/internal/operators/mapTo.js
function mapTo(value) {
  return map(function() {
    return value;
  });
}

// node_modules/rxjs/dist/esm5/internal/operators/delayWhen.js
function delayWhen(delayDurationSelector, subscriptionDelay) {
  if (subscriptionDelay) {
    return function(source) {
      return concat(subscriptionDelay.pipe(take(1), ignoreElements()), source.pipe(delayWhen(delayDurationSelector)));
    };
  }
  return mergeMap(function(value, index) {
    return innerFrom(delayDurationSelector(value, index)).pipe(take(1), mapTo(value));
  });
}

// node_modules/rxjs/dist/esm5/internal/operators/delay.js
function delay(due, scheduler) {
  if (scheduler === void 0) {
    scheduler = asyncScheduler;
  }
  var duration = timer(due, scheduler);
  return delayWhen(function() {
    return duration;
  });
}

// node_modules/rxjs/dist/esm5/internal/operators/dematerialize.js
function dematerialize() {
  return operate(function(source, subscriber) {
    source.subscribe(createOperatorSubscriber(subscriber, function(notification) {
      return observeNotification(notification, subscriber);
    }));
  });
}

// node_modules/rxjs/dist/esm5/internal/operators/distinct.js
function distinct(keySelector, flushes) {
  return operate(function(source, subscriber) {
    var distinctKeys = /* @__PURE__ */ new Set();
    source.subscribe(createOperatorSubscriber(subscriber, function(value) {
      var key = keySelector ? keySelector(value) : value;
      if (!distinctKeys.has(key)) {
        distinctKeys.add(key);
        subscriber.next(value);
      }
    }));
    flushes && innerFrom(flushes).subscribe(createOperatorSubscriber(subscriber, function() {
      return distinctKeys.clear();
    }, noop));
  });
}

// node_modules/rxjs/dist/esm5/internal/operators/distinctUntilChanged.js
function distinctUntilChanged(comparator, keySelector) {
  if (keySelector === void 0) {
    keySelector = identity;
  }
  comparator = comparator !== null && comparator !== void 0 ? comparator : defaultCompare;
  return operate(function(source, subscriber) {
    var previousKey;
    var first2 = true;
    source.subscribe(createOperatorSubscriber(subscriber, function(value) {
      var currentKey = keySelector(value);
      if (first2 || !comparator(previousKey, currentKey)) {
        first2 = false;
        previousKey = currentKey;
        subscriber.next(value);
      }
    }));
  });
}
function defaultCompare(a, b) {
  return a === b;
}

// node_modules/rxjs/dist/esm5/internal/operators/distinctUntilKeyChanged.js
function distinctUntilKeyChanged(key, compare) {
  return distinctUntilChanged(function(x, y) {
    return compare ? compare(x[key], y[key]) : x[key] === y[key];
  });
}

// node_modules/rxjs/dist/esm5/internal/operators/throwIfEmpty.js
function throwIfEmpty(errorFactory) {
  if (errorFactory === void 0) {
    errorFactory = defaultErrorFactory;
  }
  return operate(function(source, subscriber) {
    var hasValue = false;
    source.subscribe(createOperatorSubscriber(subscriber, function(value) {
      hasValue = true;
      subscriber.next(value);
    }, function() {
      return hasValue ? subscriber.complete() : subscriber.error(errorFactory());
    }));
  });
}
function defaultErrorFactory() {
  return new EmptyError();
}

// node_modules/rxjs/dist/esm5/internal/operators/elementAt.js
function elementAt(index, defaultValue) {
  if (index < 0) {
    throw new ArgumentOutOfRangeError();
  }
  var hasDefaultValue = arguments.length >= 2;
  return function(source) {
    return source.pipe(filter(function(v, i) {
      return i === index;
    }), take(1), hasDefaultValue ? defaultIfEmpty(defaultValue) : throwIfEmpty(function() {
      return new ArgumentOutOfRangeError();
    }));
  };
}

// node_modules/rxjs/dist/esm5/internal/operators/endWith.js
function endWith() {
  var values = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    values[_i] = arguments[_i];
  }
  return function(source) {
    return concat(source, of.apply(void 0, __spreadArray([], __read(values))));
  };
}

// node_modules/rxjs/dist/esm5/internal/operators/every.js
function every(predicate, thisArg) {
  return operate(function(source, subscriber) {
    var index = 0;
    source.subscribe(createOperatorSubscriber(subscriber, function(value) {
      if (!predicate.call(thisArg, value, index++, source)) {
        subscriber.next(false);
        subscriber.complete();
      }
    }, function() {
      subscriber.next(true);
      subscriber.complete();
    }));
  });
}

// node_modules/rxjs/dist/esm5/internal/operators/exhaustMap.js
function exhaustMap(project, resultSelector) {
  if (resultSelector) {
    return function(source) {
      return source.pipe(exhaustMap(function(a, i) {
        return innerFrom(project(a, i)).pipe(map(function(b, ii) {
          return resultSelector(a, b, i, ii);
        }));
      }));
    };
  }
  return operate(function(source, subscriber) {
    var index = 0;
    var innerSub = null;
    var isComplete = false;
    source.subscribe(createOperatorSubscriber(subscriber, function(outerValue) {
      if (!innerSub) {
        innerSub = createOperatorSubscriber(subscriber, void 0, function() {
          innerSub = null;
          isComplete && subscriber.complete();
        });
        innerFrom(project(outerValue, index++)).subscribe(innerSub);
      }
    }, function() {
      isComplete = true;
      !innerSub && subscriber.complete();
    }));
  });
}

// node_modules/rxjs/dist/esm5/internal/operators/exhaustAll.js
function exhaustAll() {
  return exhaustMap(identity);
}

// node_modules/rxjs/dist/esm5/internal/operators/exhaust.js
var exhaust = exhaustAll;

// node_modules/rxjs/dist/esm5/internal/operators/expand.js
function expand(project, concurrent, scheduler) {
  if (concurrent === void 0) {
    concurrent = Infinity;
  }
  concurrent = (concurrent || 0) < 1 ? Infinity : concurrent;
  return operate(function(source, subscriber) {
    return mergeInternals(source, subscriber, project, concurrent, void 0, true, scheduler);
  });
}

// node_modules/rxjs/dist/esm5/internal/operators/finalize.js
function finalize(callback) {
  return operate(function(source, subscriber) {
    try {
      source.subscribe(subscriber);
    } finally {
      subscriber.add(callback);
    }
  });
}

// node_modules/rxjs/dist/esm5/internal/operators/find.js
function find(predicate, thisArg) {
  return operate(createFind(predicate, thisArg, "value"));
}
function createFind(predicate, thisArg, emit) {
  var findIndex2 = emit === "index";
  return function(source, subscriber) {
    var index = 0;
    source.subscribe(createOperatorSubscriber(subscriber, function(value) {
      var i = index++;
      if (predicate.call(thisArg, value, i, source)) {
        subscriber.next(findIndex2 ? i : value);
        subscriber.complete();
      }
    }, function() {
      subscriber.next(findIndex2 ? -1 : void 0);
      subscriber.complete();
    }));
  };
}

// node_modules/rxjs/dist/esm5/internal/operators/findIndex.js
function findIndex(predicate, thisArg) {
  return operate(createFind(predicate, thisArg, "index"));
}

// node_modules/rxjs/dist/esm5/internal/operators/first.js
function first(predicate, defaultValue) {
  var hasDefaultValue = arguments.length >= 2;
  return function(source) {
    return source.pipe(predicate ? filter(function(v, i) {
      return predicate(v, i, source);
    }) : identity, take(1), hasDefaultValue ? defaultIfEmpty(defaultValue) : throwIfEmpty(function() {
      return new EmptyError();
    }));
  };
}

// node_modules/rxjs/dist/esm5/internal/operators/groupBy.js
function groupBy(keySelector, elementOrOptions, duration, connector) {
  return operate(function(source, subscriber) {
    var element;
    if (!elementOrOptions || typeof elementOrOptions === "function") {
      element = elementOrOptions;
    } else {
      duration = elementOrOptions.duration, element = elementOrOptions.element, connector = elementOrOptions.connector;
    }
    var groups = /* @__PURE__ */ new Map();
    var notify = function(cb) {
      groups.forEach(cb);
      cb(subscriber);
    };
    var handleError = function(err) {
      return notify(function(consumer) {
        return consumer.error(err);
      });
    };
    var activeGroups = 0;
    var teardownAttempted = false;
    var groupBySourceSubscriber = new OperatorSubscriber(subscriber, function(value) {
      try {
        var key_1 = keySelector(value);
        var group_1 = groups.get(key_1);
        if (!group_1) {
          groups.set(key_1, group_1 = connector ? connector() : new Subject());
          var grouped = createGroupedObservable(key_1, group_1);
          subscriber.next(grouped);
          if (duration) {
            var durationSubscriber_1 = createOperatorSubscriber(group_1, function() {
              group_1.complete();
              durationSubscriber_1 === null || durationSubscriber_1 === void 0 ? void 0 : durationSubscriber_1.unsubscribe();
            }, void 0, void 0, function() {
              return groups.delete(key_1);
            });
            groupBySourceSubscriber.add(innerFrom(duration(grouped)).subscribe(durationSubscriber_1));
          }
        }
        group_1.next(element ? element(value) : value);
      } catch (err) {
        handleError(err);
      }
    }, function() {
      return notify(function(consumer) {
        return consumer.complete();
      });
    }, handleError, function() {
      return groups.clear();
    }, function() {
      teardownAttempted = true;
      return activeGroups === 0;
    });
    source.subscribe(groupBySourceSubscriber);
    function createGroupedObservable(key, groupSubject) {
      var result = new Observable(function(groupSubscriber) {
        activeGroups++;
        var innerSub = groupSubject.subscribe(groupSubscriber);
        return function() {
          innerSub.unsubscribe();
          --activeGroups === 0 && teardownAttempted && groupBySourceSubscriber.unsubscribe();
        };
      });
      result.key = key;
      return result;
    }
  });
}

// node_modules/rxjs/dist/esm5/internal/operators/isEmpty.js
function isEmpty() {
  return operate(function(source, subscriber) {
    source.subscribe(createOperatorSubscriber(subscriber, function() {
      subscriber.next(false);
      subscriber.complete();
    }, function() {
      subscriber.next(true);
      subscriber.complete();
    }));
  });
}

// node_modules/rxjs/dist/esm5/internal/operators/takeLast.js
function takeLast(count2) {
  return count2 <= 0 ? function() {
    return EMPTY;
  } : operate(function(source, subscriber) {
    var buffer2 = [];
    source.subscribe(createOperatorSubscriber(subscriber, function(value) {
      buffer2.push(value);
      count2 < buffer2.length && buffer2.shift();
    }, function() {
      var e_1, _a;
      try {
        for (var buffer_1 = __values(buffer2), buffer_1_1 = buffer_1.next(); !buffer_1_1.done; buffer_1_1 = buffer_1.next()) {
          var value = buffer_1_1.value;
          subscriber.next(value);
        }
      } catch (e_1_1) {
        e_1 = {
          error: e_1_1
        };
      } finally {
        try {
          if (buffer_1_1 && !buffer_1_1.done && (_a = buffer_1.return)) _a.call(buffer_1);
        } finally {
          if (e_1) throw e_1.error;
        }
      }
      subscriber.complete();
    }, void 0, function() {
      buffer2 = null;
    }));
  });
}

// node_modules/rxjs/dist/esm5/internal/operators/last.js
function last2(predicate, defaultValue) {
  var hasDefaultValue = arguments.length >= 2;
  return function(source) {
    return source.pipe(predicate ? filter(function(v, i) {
      return predicate(v, i, source);
    }) : identity, takeLast(1), hasDefaultValue ? defaultIfEmpty(defaultValue) : throwIfEmpty(function() {
      return new EmptyError();
    }));
  };
}

// node_modules/rxjs/dist/esm5/internal/operators/materialize.js
function materialize() {
  return operate(function(source, subscriber) {
    source.subscribe(createOperatorSubscriber(subscriber, function(value) {
      subscriber.next(Notification.createNext(value));
    }, function() {
      subscriber.next(Notification.createComplete());
      subscriber.complete();
    }, function(err) {
      subscriber.next(Notification.createError(err));
      subscriber.complete();
    }));
  });
}

// node_modules/rxjs/dist/esm5/internal/operators/max.js
function max(comparer) {
  return reduce(isFunction(comparer) ? function(x, y) {
    return comparer(x, y) > 0 ? x : y;
  } : function(x, y) {
    return x > y ? x : y;
  });
}

// node_modules/rxjs/dist/esm5/internal/operators/flatMap.js
var flatMap = mergeMap;

// node_modules/rxjs/dist/esm5/internal/operators/mergeMapTo.js
function mergeMapTo(innerObservable, resultSelector, concurrent) {
  if (concurrent === void 0) {
    concurrent = Infinity;
  }
  if (isFunction(resultSelector)) {
    return mergeMap(function() {
      return innerObservable;
    }, resultSelector, concurrent);
  }
  if (typeof resultSelector === "number") {
    concurrent = resultSelector;
  }
  return mergeMap(function() {
    return innerObservable;
  }, concurrent);
}

// node_modules/rxjs/dist/esm5/internal/operators/mergeScan.js
function mergeScan(accumulator, seed, concurrent) {
  if (concurrent === void 0) {
    concurrent = Infinity;
  }
  return operate(function(source, subscriber) {
    var state = seed;
    return mergeInternals(source, subscriber, function(value, index) {
      return accumulator(state, value, index);
    }, concurrent, function(value) {
      state = value;
    }, false, void 0, function() {
      return state = null;
    });
  });
}

// node_modules/rxjs/dist/esm5/internal/operators/merge.js
function merge() {
  var args = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    args[_i] = arguments[_i];
  }
  var scheduler = popScheduler(args);
  var concurrent = popNumber(args, Infinity);
  args = argsOrArgArray(args);
  return operate(function(source, subscriber) {
    mergeAll(concurrent)(from(__spreadArray([source], __read(args)), scheduler)).subscribe(subscriber);
  });
}

// node_modules/rxjs/dist/esm5/internal/operators/mergeWith.js
function mergeWith() {
  var otherSources = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    otherSources[_i] = arguments[_i];
  }
  return merge.apply(void 0, __spreadArray([], __read(otherSources)));
}

// node_modules/rxjs/dist/esm5/internal/operators/min.js
function min(comparer) {
  return reduce(isFunction(comparer) ? function(x, y) {
    return comparer(x, y) < 0 ? x : y;
  } : function(x, y) {
    return x < y ? x : y;
  });
}

// node_modules/rxjs/dist/esm5/internal/operators/multicast.js
function multicast(subjectOrSubjectFactory, selector) {
  var subjectFactory = isFunction(subjectOrSubjectFactory) ? subjectOrSubjectFactory : function() {
    return subjectOrSubjectFactory;
  };
  if (isFunction(selector)) {
    return connect(selector, {
      connector: subjectFactory
    });
  }
  return function(source) {
    return new ConnectableObservable(source, subjectFactory);
  };
}

// node_modules/rxjs/dist/esm5/internal/operators/onErrorResumeNextWith.js
function onErrorResumeNextWith() {
  var sources = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    sources[_i] = arguments[_i];
  }
  var nextSources = argsOrArgArray(sources);
  return function(source) {
    return onErrorResumeNext.apply(void 0, __spreadArray([source], __read(nextSources)));
  };
}
var onErrorResumeNext2 = onErrorResumeNextWith;

// node_modules/rxjs/dist/esm5/internal/operators/pairwise.js
function pairwise() {
  return operate(function(source, subscriber) {
    var prev;
    var hasPrev = false;
    source.subscribe(createOperatorSubscriber(subscriber, function(value) {
      var p = prev;
      prev = value;
      hasPrev && subscriber.next([p, value]);
      hasPrev = true;
    }));
  });
}

// node_modules/rxjs/dist/esm5/internal/operators/pluck.js
function pluck() {
  var properties = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    properties[_i] = arguments[_i];
  }
  var length = properties.length;
  if (length === 0) {
    throw new Error("list of properties cannot be empty.");
  }
  return map(function(x) {
    var currentProp = x;
    for (var i = 0; i < length; i++) {
      var p = currentProp === null || currentProp === void 0 ? void 0 : currentProp[properties[i]];
      if (typeof p !== "undefined") {
        currentProp = p;
      } else {
        return void 0;
      }
    }
    return currentProp;
  });
}

// node_modules/rxjs/dist/esm5/internal/operators/publish.js
function publish(selector) {
  return selector ? function(source) {
    return connect(selector)(source);
  } : function(source) {
    return multicast(new Subject())(source);
  };
}

// node_modules/rxjs/dist/esm5/internal/operators/publishBehavior.js
function publishBehavior(initialValue) {
  return function(source) {
    var subject = new BehaviorSubject(initialValue);
    return new ConnectableObservable(source, function() {
      return subject;
    });
  };
}

// node_modules/rxjs/dist/esm5/internal/operators/publishLast.js
function publishLast() {
  return function(source) {
    var subject = new AsyncSubject();
    return new ConnectableObservable(source, function() {
      return subject;
    });
  };
}

// node_modules/rxjs/dist/esm5/internal/operators/publishReplay.js
function publishReplay(bufferSize, windowTime2, selectorOrScheduler, timestampProvider) {
  if (selectorOrScheduler && !isFunction(selectorOrScheduler)) {
    timestampProvider = selectorOrScheduler;
  }
  var selector = isFunction(selectorOrScheduler) ? selectorOrScheduler : void 0;
  return function(source) {
    return multicast(new ReplaySubject(bufferSize, windowTime2, timestampProvider), selector)(source);
  };
}

// node_modules/rxjs/dist/esm5/internal/operators/raceWith.js
function raceWith() {
  var otherSources = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    otherSources[_i] = arguments[_i];
  }
  return !otherSources.length ? identity : operate(function(source, subscriber) {
    raceInit(__spreadArray([source], __read(otherSources)))(subscriber);
  });
}

// node_modules/rxjs/dist/esm5/internal/operators/repeat.js
function repeat(countOrConfig) {
  var _a;
  var count2 = Infinity;
  var delay2;
  if (countOrConfig != null) {
    if (typeof countOrConfig === "object") {
      _a = countOrConfig.count, count2 = _a === void 0 ? Infinity : _a, delay2 = countOrConfig.delay;
    } else {
      count2 = countOrConfig;
    }
  }
  return count2 <= 0 ? function() {
    return EMPTY;
  } : operate(function(source, subscriber) {
    var soFar = 0;
    var sourceSub;
    var resubscribe = function() {
      sourceSub === null || sourceSub === void 0 ? void 0 : sourceSub.unsubscribe();
      sourceSub = null;
      if (delay2 != null) {
        var notifier = typeof delay2 === "number" ? timer(delay2) : innerFrom(delay2(soFar));
        var notifierSubscriber_1 = createOperatorSubscriber(subscriber, function() {
          notifierSubscriber_1.unsubscribe();
          subscribeToSource();
        });
        notifier.subscribe(notifierSubscriber_1);
      } else {
        subscribeToSource();
      }
    };
    var subscribeToSource = function() {
      var syncUnsub = false;
      sourceSub = source.subscribe(createOperatorSubscriber(subscriber, void 0, function() {
        if (++soFar < count2) {
          if (sourceSub) {
            resubscribe();
          } else {
            syncUnsub = true;
          }
        } else {
          subscriber.complete();
        }
      }));
      if (syncUnsub) {
        resubscribe();
      }
    };
    subscribeToSource();
  });
}

// node_modules/rxjs/dist/esm5/internal/operators/repeatWhen.js
function repeatWhen(notifier) {
  return operate(function(source, subscriber) {
    var innerSub;
    var syncResub = false;
    var completions$;
    var isNotifierComplete = false;
    var isMainComplete = false;
    var checkComplete = function() {
      return isMainComplete && isNotifierComplete && (subscriber.complete(), true);
    };
    var getCompletionSubject = function() {
      if (!completions$) {
        completions$ = new Subject();
        innerFrom(notifier(completions$)).subscribe(createOperatorSubscriber(subscriber, function() {
          if (innerSub) {
            subscribeForRepeatWhen();
          } else {
            syncResub = true;
          }
        }, function() {
          isNotifierComplete = true;
          checkComplete();
        }));
      }
      return completions$;
    };
    var subscribeForRepeatWhen = function() {
      isMainComplete = false;
      innerSub = source.subscribe(createOperatorSubscriber(subscriber, void 0, function() {
        isMainComplete = true;
        !checkComplete() && getCompletionSubject().next();
      }));
      if (syncResub) {
        innerSub.unsubscribe();
        innerSub = null;
        syncResub = false;
        subscribeForRepeatWhen();
      }
    };
    subscribeForRepeatWhen();
  });
}

// node_modules/rxjs/dist/esm5/internal/operators/retry.js
function retry(configOrCount) {
  if (configOrCount === void 0) {
    configOrCount = Infinity;
  }
  var config2;
  if (configOrCount && typeof configOrCount === "object") {
    config2 = configOrCount;
  } else {
    config2 = {
      count: configOrCount
    };
  }
  var _a = config2.count, count2 = _a === void 0 ? Infinity : _a, delay2 = config2.delay, _b = config2.resetOnSuccess, resetOnSuccess = _b === void 0 ? false : _b;
  return count2 <= 0 ? identity : operate(function(source, subscriber) {
    var soFar = 0;
    var innerSub;
    var subscribeForRetry = function() {
      var syncUnsub = false;
      innerSub = source.subscribe(createOperatorSubscriber(subscriber, function(value) {
        if (resetOnSuccess) {
          soFar = 0;
        }
        subscriber.next(value);
      }, void 0, function(err) {
        if (soFar++ < count2) {
          var resub_1 = function() {
            if (innerSub) {
              innerSub.unsubscribe();
              innerSub = null;
              subscribeForRetry();
            } else {
              syncUnsub = true;
            }
          };
          if (delay2 != null) {
            var notifier = typeof delay2 === "number" ? timer(delay2) : innerFrom(delay2(err, soFar));
            var notifierSubscriber_1 = createOperatorSubscriber(subscriber, function() {
              notifierSubscriber_1.unsubscribe();
              resub_1();
            }, function() {
              subscriber.complete();
            });
            notifier.subscribe(notifierSubscriber_1);
          } else {
            resub_1();
          }
        } else {
          subscriber.error(err);
        }
      }));
      if (syncUnsub) {
        innerSub.unsubscribe();
        innerSub = null;
        subscribeForRetry();
      }
    };
    subscribeForRetry();
  });
}

// node_modules/rxjs/dist/esm5/internal/operators/retryWhen.js
function retryWhen(notifier) {
  return operate(function(source, subscriber) {
    var innerSub;
    var syncResub = false;
    var errors$;
    var subscribeForRetryWhen = function() {
      innerSub = source.subscribe(createOperatorSubscriber(subscriber, void 0, void 0, function(err) {
        if (!errors$) {
          errors$ = new Subject();
          innerFrom(notifier(errors$)).subscribe(createOperatorSubscriber(subscriber, function() {
            return innerSub ? subscribeForRetryWhen() : syncResub = true;
          }));
        }
        if (errors$) {
          errors$.next(err);
        }
      }));
      if (syncResub) {
        innerSub.unsubscribe();
        innerSub = null;
        syncResub = false;
        subscribeForRetryWhen();
      }
    };
    subscribeForRetryWhen();
  });
}

// node_modules/rxjs/dist/esm5/internal/operators/sample.js
function sample(notifier) {
  return operate(function(source, subscriber) {
    var hasValue = false;
    var lastValue = null;
    source.subscribe(createOperatorSubscriber(subscriber, function(value) {
      hasValue = true;
      lastValue = value;
    }));
    innerFrom(notifier).subscribe(createOperatorSubscriber(subscriber, function() {
      if (hasValue) {
        hasValue = false;
        var value = lastValue;
        lastValue = null;
        subscriber.next(value);
      }
    }, noop));
  });
}

// node_modules/rxjs/dist/esm5/internal/operators/sampleTime.js
function sampleTime(period, scheduler) {
  if (scheduler === void 0) {
    scheduler = asyncScheduler;
  }
  return sample(interval(period, scheduler));
}

// node_modules/rxjs/dist/esm5/internal/operators/scan.js
function scan(accumulator, seed) {
  return operate(scanInternals(accumulator, seed, arguments.length >= 2, true));
}

// node_modules/rxjs/dist/esm5/internal/operators/sequenceEqual.js
function sequenceEqual(compareTo, comparator) {
  if (comparator === void 0) {
    comparator = function(a, b) {
      return a === b;
    };
  }
  return operate(function(source, subscriber) {
    var aState = createState();
    var bState = createState();
    var emit = function(isEqual) {
      subscriber.next(isEqual);
      subscriber.complete();
    };
    var createSubscriber = function(selfState, otherState) {
      var sequenceEqualSubscriber = createOperatorSubscriber(subscriber, function(a) {
        var buffer2 = otherState.buffer, complete = otherState.complete;
        if (buffer2.length === 0) {
          complete ? emit(false) : selfState.buffer.push(a);
        } else {
          !comparator(a, buffer2.shift()) && emit(false);
        }
      }, function() {
        selfState.complete = true;
        var complete = otherState.complete, buffer2 = otherState.buffer;
        complete && emit(buffer2.length === 0);
        sequenceEqualSubscriber === null || sequenceEqualSubscriber === void 0 ? void 0 : sequenceEqualSubscriber.unsubscribe();
      });
      return sequenceEqualSubscriber;
    };
    source.subscribe(createSubscriber(aState, bState));
    innerFrom(compareTo).subscribe(createSubscriber(bState, aState));
  });
}
function createState() {
  return {
    buffer: [],
    complete: false
  };
}

// node_modules/rxjs/dist/esm5/internal/operators/share.js
function share(options) {
  if (options === void 0) {
    options = {};
  }
  var _a = options.connector, connector = _a === void 0 ? function() {
    return new Subject();
  } : _a, _b = options.resetOnError, resetOnError = _b === void 0 ? true : _b, _c = options.resetOnComplete, resetOnComplete = _c === void 0 ? true : _c, _d = options.resetOnRefCountZero, resetOnRefCountZero = _d === void 0 ? true : _d;
  return function(wrapperSource) {
    var connection;
    var resetConnection;
    var subject;
    var refCount2 = 0;
    var hasCompleted = false;
    var hasErrored = false;
    var cancelReset = function() {
      resetConnection === null || resetConnection === void 0 ? void 0 : resetConnection.unsubscribe();
      resetConnection = void 0;
    };
    var reset = function() {
      cancelReset();
      connection = subject = void 0;
      hasCompleted = hasErrored = false;
    };
    var resetAndUnsubscribe = function() {
      var conn = connection;
      reset();
      conn === null || conn === void 0 ? void 0 : conn.unsubscribe();
    };
    return operate(function(source, subscriber) {
      refCount2++;
      if (!hasErrored && !hasCompleted) {
        cancelReset();
      }
      var dest = subject = subject !== null && subject !== void 0 ? subject : connector();
      subscriber.add(function() {
        refCount2--;
        if (refCount2 === 0 && !hasErrored && !hasCompleted) {
          resetConnection = handleReset(resetAndUnsubscribe, resetOnRefCountZero);
        }
      });
      dest.subscribe(subscriber);
      if (!connection && refCount2 > 0) {
        connection = new SafeSubscriber({
          next: function(value) {
            return dest.next(value);
          },
          error: function(err) {
            hasErrored = true;
            cancelReset();
            resetConnection = handleReset(reset, resetOnError, err);
            dest.error(err);
          },
          complete: function() {
            hasCompleted = true;
            cancelReset();
            resetConnection = handleReset(reset, resetOnComplete);
            dest.complete();
          }
        });
        innerFrom(source).subscribe(connection);
      }
    })(wrapperSource);
  };
}
function handleReset(reset, on) {
  var args = [];
  for (var _i = 2; _i < arguments.length; _i++) {
    args[_i - 2] = arguments[_i];
  }
  if (on === true) {
    reset();
    return;
  }
  if (on === false) {
    return;
  }
  var onSubscriber = new SafeSubscriber({
    next: function() {
      onSubscriber.unsubscribe();
      reset();
    }
  });
  return innerFrom(on.apply(void 0, __spreadArray([], __read(args)))).subscribe(onSubscriber);
}

// node_modules/rxjs/dist/esm5/internal/operators/shareReplay.js
function shareReplay(configOrBufferSize, windowTime2, scheduler) {
  var _a, _b, _c;
  var bufferSize;
  var refCount2 = false;
  if (configOrBufferSize && typeof configOrBufferSize === "object") {
    _a = configOrBufferSize.bufferSize, bufferSize = _a === void 0 ? Infinity : _a, _b = configOrBufferSize.windowTime, windowTime2 = _b === void 0 ? Infinity : _b, _c = configOrBufferSize.refCount, refCount2 = _c === void 0 ? false : _c, scheduler = configOrBufferSize.scheduler;
  } else {
    bufferSize = configOrBufferSize !== null && configOrBufferSize !== void 0 ? configOrBufferSize : Infinity;
  }
  return share({
    connector: function() {
      return new ReplaySubject(bufferSize, windowTime2, scheduler);
    },
    resetOnError: true,
    resetOnComplete: false,
    resetOnRefCountZero: refCount2
  });
}

// node_modules/rxjs/dist/esm5/internal/operators/single.js
function single(predicate) {
  return operate(function(source, subscriber) {
    var hasValue = false;
    var singleValue;
    var seenValue = false;
    var index = 0;
    source.subscribe(createOperatorSubscriber(subscriber, function(value) {
      seenValue = true;
      if (!predicate || predicate(value, index++, source)) {
        hasValue && subscriber.error(new SequenceError("Too many matching values"));
        hasValue = true;
        singleValue = value;
      }
    }, function() {
      if (hasValue) {
        subscriber.next(singleValue);
        subscriber.complete();
      } else {
        subscriber.error(seenValue ? new NotFoundError("No matching values") : new EmptyError());
      }
    }));
  });
}

// node_modules/rxjs/dist/esm5/internal/operators/skip.js
function skip(count2) {
  return filter(function(_, index) {
    return count2 <= index;
  });
}

// node_modules/rxjs/dist/esm5/internal/operators/skipLast.js
function skipLast(skipCount) {
  return skipCount <= 0 ? identity : operate(function(source, subscriber) {
    var ring = new Array(skipCount);
    var seen = 0;
    source.subscribe(createOperatorSubscriber(subscriber, function(value) {
      var valueIndex = seen++;
      if (valueIndex < skipCount) {
        ring[valueIndex] = value;
      } else {
        var index = valueIndex % skipCount;
        var oldValue = ring[index];
        ring[index] = value;
        subscriber.next(oldValue);
      }
    }));
    return function() {
      ring = null;
    };
  });
}

// node_modules/rxjs/dist/esm5/internal/operators/skipUntil.js
function skipUntil(notifier) {
  return operate(function(source, subscriber) {
    var taking = false;
    var skipSubscriber = createOperatorSubscriber(subscriber, function() {
      skipSubscriber === null || skipSubscriber === void 0 ? void 0 : skipSubscriber.unsubscribe();
      taking = true;
    }, noop);
    innerFrom(notifier).subscribe(skipSubscriber);
    source.subscribe(createOperatorSubscriber(subscriber, function(value) {
      return taking && subscriber.next(value);
    }));
  });
}

// node_modules/rxjs/dist/esm5/internal/operators/skipWhile.js
function skipWhile(predicate) {
  return operate(function(source, subscriber) {
    var taking = false;
    var index = 0;
    source.subscribe(createOperatorSubscriber(subscriber, function(value) {
      return (taking || (taking = !predicate(value, index++))) && subscriber.next(value);
    }));
  });
}

// node_modules/rxjs/dist/esm5/internal/operators/startWith.js
function startWith() {
  var values = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    values[_i] = arguments[_i];
  }
  var scheduler = popScheduler(values);
  return operate(function(source, subscriber) {
    (scheduler ? concat(values, source, scheduler) : concat(values, source)).subscribe(subscriber);
  });
}

// node_modules/rxjs/dist/esm5/internal/operators/switchMap.js
function switchMap(project, resultSelector) {
  return operate(function(source, subscriber) {
    var innerSubscriber = null;
    var index = 0;
    var isComplete = false;
    var checkComplete = function() {
      return isComplete && !innerSubscriber && subscriber.complete();
    };
    source.subscribe(createOperatorSubscriber(subscriber, function(value) {
      innerSubscriber === null || innerSubscriber === void 0 ? void 0 : innerSubscriber.unsubscribe();
      var innerIndex = 0;
      var outerIndex = index++;
      innerFrom(project(value, outerIndex)).subscribe(innerSubscriber = createOperatorSubscriber(subscriber, function(innerValue) {
        return subscriber.next(resultSelector ? resultSelector(value, innerValue, outerIndex, innerIndex++) : innerValue);
      }, function() {
        innerSubscriber = null;
        checkComplete();
      }));
    }, function() {
      isComplete = true;
      checkComplete();
    }));
  });
}

// node_modules/rxjs/dist/esm5/internal/operators/switchAll.js
function switchAll() {
  return switchMap(identity);
}

// node_modules/rxjs/dist/esm5/internal/operators/switchMapTo.js
function switchMapTo(innerObservable, resultSelector) {
  return isFunction(resultSelector) ? switchMap(function() {
    return innerObservable;
  }, resultSelector) : switchMap(function() {
    return innerObservable;
  });
}

// node_modules/rxjs/dist/esm5/internal/operators/switchScan.js
function switchScan(accumulator, seed) {
  return operate(function(source, subscriber) {
    var state = seed;
    switchMap(function(value, index) {
      return accumulator(state, value, index);
    }, function(_, innerValue) {
      return state = innerValue, innerValue;
    })(source).subscribe(subscriber);
    return function() {
      state = null;
    };
  });
}

// node_modules/rxjs/dist/esm5/internal/operators/takeUntil.js
function takeUntil(notifier) {
  return operate(function(source, subscriber) {
    innerFrom(notifier).subscribe(createOperatorSubscriber(subscriber, function() {
      return subscriber.complete();
    }, noop));
    !subscriber.closed && source.subscribe(subscriber);
  });
}

// node_modules/rxjs/dist/esm5/internal/operators/takeWhile.js
function takeWhile(predicate, inclusive) {
  if (inclusive === void 0) {
    inclusive = false;
  }
  return operate(function(source, subscriber) {
    var index = 0;
    source.subscribe(createOperatorSubscriber(subscriber, function(value) {
      var result = predicate(value, index++);
      (result || inclusive) && subscriber.next(value);
      !result && subscriber.complete();
    }));
  });
}

// node_modules/rxjs/dist/esm5/internal/operators/tap.js
function tap(observerOrNext, error, complete) {
  var tapObserver = isFunction(observerOrNext) || error || complete ? {
    next: observerOrNext,
    error,
    complete
  } : observerOrNext;
  return tapObserver ? operate(function(source, subscriber) {
    var _a;
    (_a = tapObserver.subscribe) === null || _a === void 0 ? void 0 : _a.call(tapObserver);
    var isUnsub = true;
    source.subscribe(createOperatorSubscriber(subscriber, function(value) {
      var _a2;
      (_a2 = tapObserver.next) === null || _a2 === void 0 ? void 0 : _a2.call(tapObserver, value);
      subscriber.next(value);
    }, function() {
      var _a2;
      isUnsub = false;
      (_a2 = tapObserver.complete) === null || _a2 === void 0 ? void 0 : _a2.call(tapObserver);
      subscriber.complete();
    }, function(err) {
      var _a2;
      isUnsub = false;
      (_a2 = tapObserver.error) === null || _a2 === void 0 ? void 0 : _a2.call(tapObserver, err);
      subscriber.error(err);
    }, function() {
      var _a2, _b;
      if (isUnsub) {
        (_a2 = tapObserver.unsubscribe) === null || _a2 === void 0 ? void 0 : _a2.call(tapObserver);
      }
      (_b = tapObserver.finalize) === null || _b === void 0 ? void 0 : _b.call(tapObserver);
    }));
  }) : identity;
}

// node_modules/rxjs/dist/esm5/internal/operators/throttle.js
var defaultThrottleConfig = {
  leading: true,
  trailing: false
};
function throttle(durationSelector, config2) {
  if (config2 === void 0) {
    config2 = defaultThrottleConfig;
  }
  return operate(function(source, subscriber) {
    var leading = config2.leading, trailing = config2.trailing;
    var hasValue = false;
    var sendValue = null;
    var throttled = null;
    var isComplete = false;
    var endThrottling = function() {
      throttled === null || throttled === void 0 ? void 0 : throttled.unsubscribe();
      throttled = null;
      if (trailing) {
        send();
        isComplete && subscriber.complete();
      }
    };
    var cleanupThrottling = function() {
      throttled = null;
      isComplete && subscriber.complete();
    };
    var startThrottle = function(value) {
      return throttled = innerFrom(durationSelector(value)).subscribe(createOperatorSubscriber(subscriber, endThrottling, cleanupThrottling));
    };
    var send = function() {
      if (hasValue) {
        hasValue = false;
        var value = sendValue;
        sendValue = null;
        subscriber.next(value);
        !isComplete && startThrottle(value);
      }
    };
    source.subscribe(createOperatorSubscriber(subscriber, function(value) {
      hasValue = true;
      sendValue = value;
      !(throttled && !throttled.closed) && (leading ? send() : startThrottle(value));
    }, function() {
      isComplete = true;
      !(trailing && hasValue && throttled && !throttled.closed) && subscriber.complete();
    }));
  });
}

// node_modules/rxjs/dist/esm5/internal/operators/throttleTime.js
function throttleTime(duration, scheduler, config2) {
  if (scheduler === void 0) {
    scheduler = asyncScheduler;
  }
  if (config2 === void 0) {
    config2 = defaultThrottleConfig;
  }
  var duration$ = timer(duration, scheduler);
  return throttle(function() {
    return duration$;
  }, config2);
}

// node_modules/rxjs/dist/esm5/internal/operators/timeInterval.js
function timeInterval(scheduler) {
  if (scheduler === void 0) {
    scheduler = asyncScheduler;
  }
  return operate(function(source, subscriber) {
    var last3 = scheduler.now();
    source.subscribe(createOperatorSubscriber(subscriber, function(value) {
      var now = scheduler.now();
      var interval2 = now - last3;
      last3 = now;
      subscriber.next(new TimeInterval(value, interval2));
    }));
  });
}
var TimeInterval = /* @__PURE__ */ function() {
  function TimeInterval2(value, interval2) {
    this.value = value;
    this.interval = interval2;
  }
  return TimeInterval2;
}();

// node_modules/rxjs/dist/esm5/internal/operators/timeoutWith.js
function timeoutWith(due, withObservable, scheduler) {
  var first2;
  var each;
  var _with;
  scheduler = scheduler !== null && scheduler !== void 0 ? scheduler : async;
  if (isValidDate(due)) {
    first2 = due;
  } else if (typeof due === "number") {
    each = due;
  }
  if (withObservable) {
    _with = function() {
      return withObservable;
    };
  } else {
    throw new TypeError("No observable provided to switch to");
  }
  if (first2 == null && each == null) {
    throw new TypeError("No timeout provided.");
  }
  return timeout({
    first: first2,
    each,
    scheduler,
    with: _with
  });
}

// node_modules/rxjs/dist/esm5/internal/operators/timestamp.js
function timestamp(timestampProvider) {
  if (timestampProvider === void 0) {
    timestampProvider = dateTimestampProvider;
  }
  return map(function(value) {
    return {
      value,
      timestamp: timestampProvider.now()
    };
  });
}

// node_modules/rxjs/dist/esm5/internal/operators/window.js
function window(windowBoundaries) {
  return operate(function(source, subscriber) {
    var windowSubject = new Subject();
    subscriber.next(windowSubject.asObservable());
    var errorHandler = function(err) {
      windowSubject.error(err);
      subscriber.error(err);
    };
    source.subscribe(createOperatorSubscriber(subscriber, function(value) {
      return windowSubject === null || windowSubject === void 0 ? void 0 : windowSubject.next(value);
    }, function() {
      windowSubject.complete();
      subscriber.complete();
    }, errorHandler));
    innerFrom(windowBoundaries).subscribe(createOperatorSubscriber(subscriber, function() {
      windowSubject.complete();
      subscriber.next(windowSubject = new Subject());
    }, noop, errorHandler));
    return function() {
      windowSubject === null || windowSubject === void 0 ? void 0 : windowSubject.unsubscribe();
      windowSubject = null;
    };
  });
}

// node_modules/rxjs/dist/esm5/internal/operators/windowCount.js
function windowCount(windowSize, startWindowEvery) {
  if (startWindowEvery === void 0) {
    startWindowEvery = 0;
  }
  var startEvery = startWindowEvery > 0 ? startWindowEvery : windowSize;
  return operate(function(source, subscriber) {
    var windows = [new Subject()];
    var starts = [];
    var count2 = 0;
    subscriber.next(windows[0].asObservable());
    source.subscribe(createOperatorSubscriber(subscriber, function(value) {
      var e_1, _a;
      try {
        for (var windows_1 = __values(windows), windows_1_1 = windows_1.next(); !windows_1_1.done; windows_1_1 = windows_1.next()) {
          var window_1 = windows_1_1.value;
          window_1.next(value);
        }
      } catch (e_1_1) {
        e_1 = {
          error: e_1_1
        };
      } finally {
        try {
          if (windows_1_1 && !windows_1_1.done && (_a = windows_1.return)) _a.call(windows_1);
        } finally {
          if (e_1) throw e_1.error;
        }
      }
      var c = count2 - windowSize + 1;
      if (c >= 0 && c % startEvery === 0) {
        windows.shift().complete();
      }
      if (++count2 % startEvery === 0) {
        var window_2 = new Subject();
        windows.push(window_2);
        subscriber.next(window_2.asObservable());
      }
    }, function() {
      while (windows.length > 0) {
        windows.shift().complete();
      }
      subscriber.complete();
    }, function(err) {
      while (windows.length > 0) {
        windows.shift().error(err);
      }
      subscriber.error(err);
    }, function() {
      starts = null;
      windows = null;
    }));
  });
}

// node_modules/rxjs/dist/esm5/internal/operators/windowTime.js
function windowTime(windowTimeSpan) {
  var _a, _b;
  var otherArgs = [];
  for (var _i = 1; _i < arguments.length; _i++) {
    otherArgs[_i - 1] = arguments[_i];
  }
  var scheduler = (_a = popScheduler(otherArgs)) !== null && _a !== void 0 ? _a : asyncScheduler;
  var windowCreationInterval = (_b = otherArgs[0]) !== null && _b !== void 0 ? _b : null;
  var maxWindowSize = otherArgs[1] || Infinity;
  return operate(function(source, subscriber) {
    var windowRecords = [];
    var restartOnClose = false;
    var closeWindow = function(record) {
      var window2 = record.window, subs = record.subs;
      window2.complete();
      subs.unsubscribe();
      arrRemove(windowRecords, record);
      restartOnClose && startWindow();
    };
    var startWindow = function() {
      if (windowRecords) {
        var subs = new Subscription();
        subscriber.add(subs);
        var window_1 = new Subject();
        var record_1 = {
          window: window_1,
          subs,
          seen: 0
        };
        windowRecords.push(record_1);
        subscriber.next(window_1.asObservable());
        executeSchedule(subs, scheduler, function() {
          return closeWindow(record_1);
        }, windowTimeSpan);
      }
    };
    if (windowCreationInterval !== null && windowCreationInterval >= 0) {
      executeSchedule(subscriber, scheduler, startWindow, windowCreationInterval, true);
    } else {
      restartOnClose = true;
    }
    startWindow();
    var loop = function(cb) {
      return windowRecords.slice().forEach(cb);
    };
    var terminate = function(cb) {
      loop(function(_a2) {
        var window2 = _a2.window;
        return cb(window2);
      });
      cb(subscriber);
      subscriber.unsubscribe();
    };
    source.subscribe(createOperatorSubscriber(subscriber, function(value) {
      loop(function(record) {
        record.window.next(value);
        maxWindowSize <= ++record.seen && closeWindow(record);
      });
    }, function() {
      return terminate(function(consumer) {
        return consumer.complete();
      });
    }, function(err) {
      return terminate(function(consumer) {
        return consumer.error(err);
      });
    }));
    return function() {
      windowRecords = null;
    };
  });
}

// node_modules/rxjs/dist/esm5/internal/operators/windowToggle.js
function windowToggle(openings, closingSelector) {
  return operate(function(source, subscriber) {
    var windows = [];
    var handleError = function(err) {
      while (0 < windows.length) {
        windows.shift().error(err);
      }
      subscriber.error(err);
    };
    innerFrom(openings).subscribe(createOperatorSubscriber(subscriber, function(openValue) {
      var window2 = new Subject();
      windows.push(window2);
      var closingSubscription = new Subscription();
      var closeWindow = function() {
        arrRemove(windows, window2);
        window2.complete();
        closingSubscription.unsubscribe();
      };
      var closingNotifier;
      try {
        closingNotifier = innerFrom(closingSelector(openValue));
      } catch (err) {
        handleError(err);
        return;
      }
      subscriber.next(window2.asObservable());
      closingSubscription.add(closingNotifier.subscribe(createOperatorSubscriber(subscriber, closeWindow, noop, handleError)));
    }, noop));
    source.subscribe(createOperatorSubscriber(subscriber, function(value) {
      var e_1, _a;
      var windowsCopy = windows.slice();
      try {
        for (var windowsCopy_1 = __values(windowsCopy), windowsCopy_1_1 = windowsCopy_1.next(); !windowsCopy_1_1.done; windowsCopy_1_1 = windowsCopy_1.next()) {
          var window_1 = windowsCopy_1_1.value;
          window_1.next(value);
        }
      } catch (e_1_1) {
        e_1 = {
          error: e_1_1
        };
      } finally {
        try {
          if (windowsCopy_1_1 && !windowsCopy_1_1.done && (_a = windowsCopy_1.return)) _a.call(windowsCopy_1);
        } finally {
          if (e_1) throw e_1.error;
        }
      }
    }, function() {
      while (0 < windows.length) {
        windows.shift().complete();
      }
      subscriber.complete();
    }, handleError, function() {
      while (0 < windows.length) {
        windows.shift().unsubscribe();
      }
    }));
  });
}

// node_modules/rxjs/dist/esm5/internal/operators/windowWhen.js
function windowWhen(closingSelector) {
  return operate(function(source, subscriber) {
    var window2;
    var closingSubscriber;
    var handleError = function(err) {
      window2.error(err);
      subscriber.error(err);
    };
    var openWindow = function() {
      closingSubscriber === null || closingSubscriber === void 0 ? void 0 : closingSubscriber.unsubscribe();
      window2 === null || window2 === void 0 ? void 0 : window2.complete();
      window2 = new Subject();
      subscriber.next(window2.asObservable());
      var closingNotifier;
      try {
        closingNotifier = innerFrom(closingSelector());
      } catch (err) {
        handleError(err);
        return;
      }
      closingNotifier.subscribe(closingSubscriber = createOperatorSubscriber(subscriber, openWindow, openWindow, handleError));
    };
    openWindow();
    source.subscribe(createOperatorSubscriber(subscriber, function(value) {
      return window2.next(value);
    }, function() {
      window2.complete();
      subscriber.complete();
    }, handleError, function() {
      closingSubscriber === null || closingSubscriber === void 0 ? void 0 : closingSubscriber.unsubscribe();
      window2 = null;
    }));
  });
}

// node_modules/rxjs/dist/esm5/internal/operators/withLatestFrom.js
function withLatestFrom() {
  var inputs = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    inputs[_i] = arguments[_i];
  }
  var project = popResultSelector(inputs);
  return operate(function(source, subscriber) {
    var len = inputs.length;
    var otherValues = new Array(len);
    var hasValue = inputs.map(function() {
      return false;
    });
    var ready = false;
    var _loop_1 = function(i2) {
      innerFrom(inputs[i2]).subscribe(createOperatorSubscriber(subscriber, function(value) {
        otherValues[i2] = value;
        if (!ready && !hasValue[i2]) {
          hasValue[i2] = true;
          (ready = hasValue.every(identity)) && (hasValue = null);
        }
      }, noop));
    };
    for (var i = 0; i < len; i++) {
      _loop_1(i);
    }
    source.subscribe(createOperatorSubscriber(subscriber, function(value) {
      if (ready) {
        var values = __spreadArray([value], __read(otherValues));
        subscriber.next(project ? project.apply(void 0, __spreadArray([], __read(values))) : values);
      }
    }));
  });
}

// node_modules/rxjs/dist/esm5/internal/operators/zipAll.js
function zipAll(project) {
  return joinAllInternals(zip, project);
}

// node_modules/rxjs/dist/esm5/internal/operators/zip.js
function zip2() {
  var sources = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    sources[_i] = arguments[_i];
  }
  return operate(function(source, subscriber) {
    zip.apply(void 0, __spreadArray([source], __read(sources))).subscribe(subscriber);
  });
}

// node_modules/rxjs/dist/esm5/internal/operators/zipWith.js
function zipWith() {
  var otherInputs = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    otherInputs[_i] = arguments[_i];
  }
  return zip2.apply(void 0, __spreadArray([], __read(otherInputs)));
}

// node_modules/rxjs/dist/esm5/internal/util/not.js
function not(pred, thisArg) {
  return function(value, index) {
    return !pred.call(thisArg, value, index);
  };
}

export {
  __extends,
  __decorate,
  __generator,
  __read,
  __spreadArray,
  isFunction,
  UnsubscriptionError,
  Subscription,
  config,
  noop,
  Subscriber,
  SafeSubscriber,
  observable,
  identity,
  pipe,
  Observable,
  createOperatorSubscriber,
  refCount,
  ConnectableObservable,
  ObjectUnsubscribedError,
  Subject,
  BehaviorSubject,
  ReplaySubject,
  AsyncSubject,
  AsyncAction,
  Scheduler,
  AsyncScheduler,
  asyncScheduler,
  async,
  EMPTY,
  empty,
  isScheduler,
  popResultSelector,
  popScheduler,
  popNumber,
  isArrayLike,
  innerFrom,
  observeOn,
  subscribeOn,
  scheduleIterable,
  scheduled,
  from,
  of,
  throwError,
  NotificationKind,
  Notification,
  EmptyError,
  ArgumentOutOfRangeError,
  NotFoundError,
  SequenceError,
  TimeoutError,
  timeout,
  map,
  mapOneOrManyArgs,
  argsArgArrayOrObject,
  createObject,
  combineLatest,
  mergeMap,
  mergeAll,
  concatAll,
  concat,
  timer,
  interval,
  argsOrArgArray,
  onErrorResumeNext,
  not,
  filter,
  race,
  zip,
  audit,
  auditTime,
  buffer,
  bufferCount,
  bufferTime,
  bufferToggle,
  bufferWhen,
  catchError,
  reduce,
  toArray,
  combineLatestAll,
  combineAll,
  combineLatest2,
  combineLatestWith,
  concatMap,
  concatMapTo,
  concat2,
  concatWith,
  connect,
  count,
  debounce,
  debounceTime,
  defaultIfEmpty,
  take,
  ignoreElements,
  mapTo,
  delayWhen,
  delay,
  dematerialize,
  distinct,
  distinctUntilChanged,
  distinctUntilKeyChanged,
  throwIfEmpty,
  elementAt,
  endWith,
  every,
  exhaustMap,
  exhaustAll,
  exhaust,
  expand,
  finalize,
  find,
  findIndex,
  first,
  groupBy,
  isEmpty,
  takeLast,
  last2 as last,
  materialize,
  max,
  flatMap,
  mergeMapTo,
  mergeScan,
  merge,
  mergeWith,
  min,
  multicast,
  onErrorResumeNextWith,
  onErrorResumeNext2,
  pairwise,
  pluck,
  publish,
  publishBehavior,
  publishLast,
  publishReplay,
  raceWith,
  repeat,
  repeatWhen,
  retry,
  retryWhen,
  sample,
  sampleTime,
  scan,
  sequenceEqual,
  share,
  shareReplay,
  single,
  skip,
  skipLast,
  skipUntil,
  skipWhile,
  startWith,
  switchMap,
  switchAll,
  switchMapTo,
  switchScan,
  takeUntil,
  takeWhile,
  tap,
  throttle,
  throttleTime,
  timeInterval,
  timeoutWith,
  timestamp,
  window,
  windowCount,
  windowTime,
  windowToggle,
  windowWhen,
  withLatestFrom,
  zipAll,
  zip2,
  zipWith
};
/*! Bundled license information:

tslib/tslib.es6.js:
  (*! *****************************************************************************
  Copyright (c) Microsoft Corporation.
  
  Permission to use, copy, modify, and/or distribute this software for any
  purpose with or without fee is hereby granted.
  
  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
  REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
  AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
  INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
  LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
  OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
  PERFORMANCE OF THIS SOFTWARE.
  ***************************************************************************** *)
*/
//# sourceMappingURL=chunk-OVFEQSRS.js.map



================================================
FILE: .angular/cache/18.2.20/angular-pivothead-example/vite/deps/chunk-VKET2LIV.js
================================================
// node_modules/@angular/core/fesm2022/primitives/event-dispatch.mjs
var Attribute = {
  /**
   * The jsaction attribute defines a mapping of a DOM event to a
   * generic event (aka jsaction), to which the actual event handlers
   * that implement the behavior of the application are bound. The
   * value is a semicolon separated list of colon separated pairs of
   * an optional DOM event name and a jsaction name. If the optional
   * DOM event name is omitted, 'click' is assumed. The jsaction names
   * are dot separated pairs of a namespace and a simple jsaction
   * name.
   *
   * See grammar in README.md for expected syntax in the attribute value.
   */
  JSACTION: "jsaction"
};
var Property = {
  /**
   * The parsed value of the jsaction attribute is stored in this
   * property on the DOM node. The parsed value is an Object. The
   * property names of the object are the events; the values are the
   * names of the actions. This property is attached even on nodes
   * that don't have a jsaction attribute as an optimization, because
   * property lookup is faster than attribute access.
   */
  JSACTION: "__jsaction",
  /**
   * The owner property references an a logical owner for a DOM node. JSAction
   * will follow this reference instead of parentNode when traversing the DOM
   * to find jsaction attributes. This allows overlaying a logical structure
   * over a document where the DOM structure can't reflect that structure.
   */
  OWNER: "__owner"
};
var parseCache = {};
function get(element) {
  return element[Property.JSACTION];
}
function getDefaulted(element) {
  const cache = get(element) ?? {};
  set(element, cache);
  return cache;
}
function set(element, actionMap) {
  element[Property.JSACTION] = actionMap;
}
function getParsed(text) {
  return parseCache[text];
}
function setParsed(text, parsed) {
  parseCache[text] = parsed;
}
var EventType = {
  /**
   * Mouse middle click, introduced in Chrome 55 and not yet supported on
   * other browsers.
   */
  AUXCLICK: "auxclick",
  /**
   * The change event fired by browsers when the `value` attribute of input,
   * select, and textarea elements are changed.
   */
  CHANGE: "change",
  /**
   * The click event. In addEvent() refers to all click events, in the
   * jsaction attribute it refers to the unmodified click and Enter/Space
   * keypress events.  In the latter case, a jsaction click will be triggered,
   * for accessibility reasons.  See clickmod and clickonly, below.
   */
  CLICK: "click",
  /**
   * Specifies the jsaction for a modified click event (i.e. a mouse
   * click with the modifier key Cmd/Ctrl pressed). This event isn't
   * separately enabled in addEvent(), because in the DOM, it's just a
   * click event.
   */
  CLICKMOD: "clickmod",
  /**
   * Specifies the jsaction for a click-only event.  Click-only doesn't take
   * into account the case where an element with focus receives an Enter/Space
   * keypress.  This event isn't separately enabled in addEvent().
   */
  CLICKONLY: "clickonly",
  /**
   * The dblclick event.
   */
  DBLCLICK: "dblclick",
  /**
   * Focus doesn't bubble, but you can use it in addEvent() and
   * jsaction anyway. EventContract does the right thing under the
   * hood.
   */
  FOCUS: "focus",
  /**
   * This event only exists in IE. For addEvent() and jsaction, use
   * focus instead; EventContract does the right thing even though
   * focus doesn't bubble.
   */
  FOCUSIN: "focusin",
  /**
   * Analog to focus.
   */
  BLUR: "blur",
  /**
   * Analog to focusin.
   */
  FOCUSOUT: "focusout",
  /**
   * Submit doesn't bubble, so it cannot be used with event
   * contract. However, the browser helpfully fires a click event on
   * the submit button of a form (even if the form is not submitted by
   * a click on the submit button). So you should handle click on the
   * submit button instead.
   */
  SUBMIT: "submit",
  /**
   * The keydown event. In addEvent() and non-click jsaction it represents the
   * regular DOM keydown event. It represents click actions in non-Gecko
   * browsers.
   */
  KEYDOWN: "keydown",
  /**
   * The keypress event. In addEvent() and non-click jsaction it represents the
   * regular DOM keypress event. It represents click actions in Gecko browsers.
   */
  KEYPRESS: "keypress",
  /**
   * The keyup event. In addEvent() and non-click jsaction it represents the
   * regular DOM keyup event. It represents click actions in non-Gecko
   * browsers.
   */
  KEYUP: "keyup",
  /**
   * The mouseup event. Can either be used directly or used implicitly to
   * capture mouseup events. In addEvent(), it represents a regular DOM
   * mouseup event.
   */
  MOUSEUP: "mouseup",
  /**
   * The mousedown event. Can either be used directly or used implicitly to
   * capture mouseenter events. In addEvent(), it represents a regular DOM
   * mouseover event.
   */
  MOUSEDOWN: "mousedown",
  /**
   * The mouseover event. Can either be used directly or used implicitly to
   * capture mouseenter events. In addEvent(), it represents a regular DOM
   * mouseover event.
   */
  MOUSEOVER: "mouseover",
  /**
   * The mouseout event. Can either be used directly or used implicitly to
   * capture mouseover events. In addEvent(), it represents a regular DOM
   * mouseout event.
   */
  MOUSEOUT: "mouseout",
  /**
   * The mouseenter event. Does not bubble and fires individually on each
   * element being entered within a DOM tree.
   */
  MOUSEENTER: "mouseenter",
  /**
   * The mouseleave event. Does not bubble and fires individually on each
   * element being entered within a DOM tree.
   */
  MOUSELEAVE: "mouseleave",
  /**
   * The mousemove event.
   */
  MOUSEMOVE: "mousemove",
  /**
   * The pointerup event. Can either be used directly or used implicitly to
   * capture pointerup events. In addEvent(), it represents a regular DOM
   * pointerup event.
   */
  POINTERUP: "pointerup",
  /**
   * The pointerdown event. Can either be used directly or used implicitly to
   * capture pointerenter events. In addEvent(), it represents a regular DOM
   * mouseover event.
   */
  POINTERDOWN: "pointerdown",
  /**
   * The pointerover event. Can either be used directly or used implicitly to
   * capture pointerenter events. In addEvent(), it represents a regular DOM
   * pointerover event.
   */
  POINTEROVER: "pointerover",
  /**
   * The pointerout event. Can either be used directly or used implicitly to
   * capture pointerover events. In addEvent(), it represents a regular DOM
   * pointerout event.
   */
  POINTEROUT: "pointerout",
  /**
   * The pointerenter event. Does not bubble and fires individually on each
   * element being entered within a DOM tree.
   */
  POINTERENTER: "pointerenter",
  /**
   * The pointerleave event. Does not bubble and fires individually on each
   * element being entered within a DOM tree.
   */
  POINTERLEAVE: "pointerleave",
  /**
   * The pointermove event.
   */
  POINTERMOVE: "pointermove",
  /**
   * The pointercancel event.
   */
  POINTERCANCEL: "pointercancel",
  /**
   * The gotpointercapture event is fired when
   * Element.setPointerCapture(pointerId) is called on a mouse input, or
   * implicitly when a touch input begins.
   */
  GOTPOINTERCAPTURE: "gotpointercapture",
  /**
   * The lostpointercapture event is fired when
   * Element.releasePointerCapture(pointerId) is called, or implicitly after a
   * touch input ends.
   */
  LOSTPOINTERCAPTURE: "lostpointercapture",
  /**
   * The error event. The error event doesn't bubble, but you can use it in
   * addEvent() and jsaction anyway. EventContract does the right thing under
   * the hood (except in IE8 which does not use error events).
   */
  ERROR: "error",
  /**
   * The load event. The load event doesn't bubble, but you can use it in
   * addEvent() and jsaction anyway. EventContract does the right thing
   * under the hood.
   */
  LOAD: "load",
  /**
   * The unload event.
   */
  UNLOAD: "unload",
  /**
   * The touchstart event. Bubbles, will only ever fire in browsers with
   * touch support.
   */
  TOUCHSTART: "touchstart",
  /**
   * The touchend event. Bubbles, will only ever fire in browsers with
   * touch support.
   */
  TOUCHEND: "touchend",
  /**
   * The touchmove event. Bubbles, will only ever fire in browsers with
   * touch support.
   */
  TOUCHMOVE: "touchmove",
  /**
   * The input event.
   */
  INPUT: "input",
  /**
   * The scroll event.
   */
  SCROLL: "scroll",
  /**
   * The toggle event. The toggle event doesn't bubble, but you can use it in
   * addEvent() and jsaction anyway. EventContract does the right thing
   * under the hood.
   */
  TOGGLE: "toggle",
  /**
   * A custom event. The actual custom event type is declared as the 'type'
   * field in the event details. Supported in Firefox 6+, IE 9+, and all Chrome
   * versions.
   *
   * This is an internal name. Users should use jsaction's fireCustomEvent to
   * fire custom events instead of relying on this type to create them.
   */
  CUSTOM: "_custom"
};
var MOUSE_SPECIAL_EVENT_TYPES = [EventType.MOUSEENTER, EventType.MOUSELEAVE, "pointerenter", "pointerleave"];
var BUBBLE_EVENT_TYPES = [
  EventType.CLICK,
  EventType.DBLCLICK,
  EventType.FOCUSIN,
  EventType.FOCUSOUT,
  EventType.KEYDOWN,
  EventType.KEYUP,
  EventType.KEYPRESS,
  EventType.MOUSEOVER,
  EventType.MOUSEOUT,
  EventType.SUBMIT,
  EventType.TOUCHSTART,
  EventType.TOUCHEND,
  EventType.TOUCHMOVE,
  "touchcancel",
  "auxclick",
  "change",
  "compositionstart",
  "compositionupdate",
  "compositionend",
  "beforeinput",
  "input",
  "select",
  "copy",
  "cut",
  "paste",
  "mousedown",
  "mouseup",
  "wheel",
  "contextmenu",
  "dragover",
  "dragenter",
  "dragleave",
  "drop",
  "dragstart",
  "dragend",
  "pointerdown",
  "pointermove",
  "pointerup",
  "pointercancel",
  "pointerover",
  "pointerout",
  "gotpointercapture",
  "lostpointercapture",
  // Video events.
  "ended",
  "loadedmetadata",
  // Page visibility events.
  "pagehide",
  "pageshow",
  "visibilitychange",
  // Content visibility events.
  "beforematch"
];
var CAPTURE_EVENT_TYPES = [EventType.FOCUS, EventType.BLUR, EventType.ERROR, EventType.LOAD, EventType.TOGGLE];
var isCaptureEventType = (eventType) => CAPTURE_EVENT_TYPES.indexOf(eventType) >= 0;
var EARLY_EVENT_TYPES = BUBBLE_EVENT_TYPES.concat(CAPTURE_EVENT_TYPES);
var isEarlyEventType = (eventType) => EARLY_EVENT_TYPES.indexOf(eventType) >= 0;
var MAC_ENTER = 3;
var ENTER = 13;
var SPACE = 32;
var KeyCode = {
  MAC_ENTER,
  ENTER,
  SPACE
};
function getBrowserEventType(eventType) {
  if (eventType === EventType.MOUSEENTER) {
    return EventType.MOUSEOVER;
  } else if (eventType === EventType.MOUSELEAVE) {
    return EventType.MOUSEOUT;
  } else if (eventType === EventType.POINTERENTER) {
    return EventType.POINTEROVER;
  } else if (eventType === EventType.POINTERLEAVE) {
    return EventType.POINTEROUT;
  }
  return eventType;
}
function addEventListener(element, eventType, handler) {
  let capture = false;
  if (isCaptureEventType(eventType)) {
    capture = true;
  }
  element.addEventListener(eventType, handler, capture);
  return {
    eventType,
    handler,
    capture
  };
}
function removeEventListener(element, info) {
  if (element.removeEventListener) {
    element.removeEventListener(info.eventType, info.handler, info.capture);
  } else if (element.detachEvent) {
    element.detachEvent(`on${info.eventType}`, info.handler);
  }
}
function preventDefault(e) {
  e.preventDefault ? e.preventDefault() : e.returnValue = false;
}
var isMac = typeof navigator !== "undefined" && /Macintosh/.test(navigator.userAgent);
function isMiddleClick(e) {
  return (
    // `which` is an old DOM API.
    // tslint:disable-next-line:no-any
    e.which === 2 || // `which` is an old DOM API.
    // tslint:disable-next-line:no-any
    e.which == null && // `button` is an old DOM API.
    // tslint:disable-next-line:no-any
    e.button === 4
  );
}
function isModifiedClickEvent(e) {
  return (
    // `metaKey` is an old DOM API.
    // tslint:disable-next-line:no-any
    isMac && e.metaKey || // `ctrlKey` is an old DOM API.
    // tslint:disable-next-line:no-any
    !isMac && e.ctrlKey || isMiddleClick(e) || // `shiftKey` is an old DOM API.
    // tslint:disable-next-line:no-any
    e.shiftKey
  );
}
var isWebKit = typeof navigator !== "undefined" && !/Opera/.test(navigator.userAgent) && /WebKit/.test(navigator.userAgent);
var isIe = typeof navigator !== "undefined" && (/MSIE/.test(navigator.userAgent) || /Trident/.test(navigator.userAgent));
var isGecko = typeof navigator !== "undefined" && !/Opera|WebKit/.test(navigator.userAgent) && /Gecko/.test(navigator.product);
function isMouseSpecialEvent(e, type, element) {
  const related = e.relatedTarget;
  return (e.type === EventType.MOUSEOVER && type === EventType.MOUSEENTER || e.type === EventType.MOUSEOUT && type === EventType.MOUSELEAVE || e.type === EventType.POINTEROVER && type === EventType.POINTERENTER || e.type === EventType.POINTEROUT && type === EventType.POINTERLEAVE) && (!related || related !== element && !element.contains(related));
}
function createMouseSpecialEvent(e, target) {
  const copy = {};
  for (const property in e) {
    if (property === "srcElement" || property === "target") {
      continue;
    }
    const key = property;
    const value = e[key];
    if (typeof value === "function") {
      continue;
    }
    copy[key] = value;
  }
  if (e.type === EventType.MOUSEOVER) {
    copy["type"] = EventType.MOUSEENTER;
  } else if (e.type === EventType.MOUSEOUT) {
    copy["type"] = EventType.MOUSELEAVE;
  } else if (e.type === EventType.POINTEROVER) {
    copy["type"] = EventType.POINTERENTER;
  } else {
    copy["type"] = EventType.POINTERLEAVE;
  }
  copy["target"] = copy["srcElement"] = target;
  copy["bubbles"] = false;
  return copy;
}
var ACTION_KEY_TO_KEYCODE = {
  "Enter": KeyCode.ENTER,
  " ": KeyCode.SPACE
};
var IDENTIFIER_TO_KEY_TRIGGER_MAPPING = {
  "A": KeyCode.ENTER,
  "BUTTON": 0,
  "CHECKBOX": KeyCode.SPACE,
  "COMBOBOX": KeyCode.ENTER,
  "FILE": 0,
  "GRIDCELL": KeyCode.ENTER,
  "LINK": KeyCode.ENTER,
  "LISTBOX": KeyCode.ENTER,
  "MENU": 0,
  "MENUBAR": 0,
  "MENUITEM": 0,
  "MENUITEMCHECKBOX": 0,
  "MENUITEMRADIO": 0,
  "OPTION": 0,
  "RADIO": KeyCode.SPACE,
  "RADIOGROUP": KeyCode.SPACE,
  "RESET": 0,
  "SUBMIT": 0,
  "SWITCH": KeyCode.SPACE,
  "TAB": 0,
  "TREE": KeyCode.ENTER,
  "TREEITEM": KeyCode.ENTER
};
var isIos = typeof navigator !== "undefined" && /iPhone|iPad|iPod/.test(navigator.userAgent);
var EventContractContainer = class {
  /**
   * @param element The container Element.
   */
  constructor(element) {
    this.element = element;
    this.handlerInfos = [];
  }
  /**
   * Installs the provided installer on the element owned by this container,
   * and maintains a reference to resulting handler in order to remove it
   * later if desired.
   */
  addEventListener(eventType, getHandler) {
    if (isIos) {
      this.element.style.cursor = "pointer";
    }
    this.handlerInfos.push(addEventListener(this.element, eventType, getHandler(this.element)));
  }
  /**
   * Removes all the handlers installed on this container.
   */
  cleanUp() {
    for (let i = 0; i < this.handlerInfos.length; i++) {
      removeEventListener(this.element, this.handlerInfos[i]);
    }
    this.handlerInfos = [];
  }
};
var Char = {
  /**
   * The separator between the namespace and the action name in the
   * jsaction attribute value.
   */
  NAMESPACE_ACTION_SEPARATOR: ".",
  /**
   * The separator between the event name and action in the jsaction
   * attribute value.
   */
  EVENT_ACTION_SEPARATOR: ":"
};
function getEventType(eventInfo) {
  return eventInfo.eventType;
}
function setEventType(eventInfo, eventType) {
  eventInfo.eventType = eventType;
}
function getEvent(eventInfo) {
  return eventInfo.event;
}
function setEvent(eventInfo, event) {
  eventInfo.event = event;
}
function getTargetElement(eventInfo) {
  return eventInfo.targetElement;
}
function setTargetElement(eventInfo, targetElement) {
  eventInfo.targetElement = targetElement;
}
function getContainer(eventInfo) {
  return eventInfo.eic;
}
function setContainer(eventInfo, container) {
  eventInfo.eic = container;
}
function getTimestamp(eventInfo) {
  return eventInfo.timeStamp;
}
function setTimestamp(eventInfo, timestamp) {
  eventInfo.timeStamp = timestamp;
}
function getAction(eventInfo) {
  return eventInfo.eia;
}
function setAction(eventInfo, actionName, actionElement) {
  eventInfo.eia = [actionName, actionElement];
}
function unsetAction(eventInfo) {
  eventInfo.eia = void 0;
}
function getActionElement(actionInfo) {
  return actionInfo[1];
}
function getIsReplay(eventInfo) {
  return eventInfo.eirp;
}
function setIsReplay(eventInfo, replay) {
  eventInfo.eirp = replay;
}
function getResolved(eventInfo) {
  return eventInfo.eir;
}
function setResolved(eventInfo, resolved) {
  eventInfo.eir = resolved;
}
function cloneEventInfo(eventInfo) {
  return {
    eventType: eventInfo.eventType,
    event: eventInfo.event,
    targetElement: eventInfo.targetElement,
    eic: eventInfo.eic,
    eia: eventInfo.eia,
    timeStamp: eventInfo.timeStamp,
    eirp: eventInfo.eirp,
    eiack: eventInfo.eiack,
    eir: eventInfo.eir
  };
}
function createEventInfoFromParameters(eventType, event, targetElement, container, timestamp, action, isReplay, a11yClickKey) {
  return {
    eventType,
    event,
    targetElement,
    eic: container,
    timeStamp: timestamp,
    eia: action,
    eirp: isReplay,
    eiack: a11yClickKey
  };
}
var EventInfoWrapper = class _EventInfoWrapper {
  constructor(eventInfo) {
    this.eventInfo = eventInfo;
  }
  getEventType() {
    return getEventType(this.eventInfo);
  }
  setEventType(eventType) {
    setEventType(this.eventInfo, eventType);
  }
  getEvent() {
    return getEvent(this.eventInfo);
  }
  setEvent(event) {
    setEvent(this.eventInfo, event);
  }
  getTargetElement() {
    return getTargetElement(this.eventInfo);
  }
  setTargetElement(targetElement) {
    setTargetElement(this.eventInfo, targetElement);
  }
  getContainer() {
    return getContainer(this.eventInfo);
  }
  setContainer(container) {
    setContainer(this.eventInfo, container);
  }
  getTimestamp() {
    return getTimestamp(this.eventInfo);
  }
  setTimestamp(timestamp) {
    setTimestamp(this.eventInfo, timestamp);
  }
  getAction() {
    const action = getAction(this.eventInfo);
    if (!action) return void 0;
    return {
      name: action[0],
      element: action[1]
    };
  }
  setAction(action) {
    if (!action) {
      unsetAction(this.eventInfo);
      return;
    }
    setAction(this.eventInfo, action.name, action.element);
  }
  getIsReplay() {
    return getIsReplay(this.eventInfo);
  }
  setIsReplay(replay) {
    setIsReplay(this.eventInfo, replay);
  }
  getResolved() {
    return getResolved(this.eventInfo);
  }
  setResolved(resolved) {
    setResolved(this.eventInfo, resolved);
  }
  clone() {
    return new _EventInfoWrapper(cloneEventInfo(this.eventInfo));
  }
};
var EMPTY_ACTION_MAP = {};
var REGEXP_SEMICOLON = /\s*;\s*/;
var DEFAULT_EVENT_TYPE = EventType.CLICK;
var ActionResolver = class {
  constructor({
    syntheticMouseEventSupport = false,
    clickModSupport = true
  } = {}) {
    this.a11yClickSupport = false;
    this.clickModSupport = true;
    this.updateEventInfoForA11yClick = void 0;
    this.preventDefaultForA11yClick = void 0;
    this.populateClickOnlyAction = void 0;
    this.syntheticMouseEventSupport = syntheticMouseEventSupport;
    this.clickModSupport = clickModSupport;
  }
  resolveEventType(eventInfo) {
    if (this.clickModSupport && getEventType(eventInfo) === EventType.CLICK && isModifiedClickEvent(getEvent(eventInfo))) {
      setEventType(eventInfo, EventType.CLICKMOD);
    } else if (this.a11yClickSupport) {
      this.updateEventInfoForA11yClick(eventInfo);
    }
  }
  resolveAction(eventInfo) {
    if (getResolved(eventInfo)) {
      return;
    }
    this.populateAction(eventInfo, getTargetElement(eventInfo));
    setResolved(eventInfo, true);
  }
  resolveParentAction(eventInfo) {
    const action = getAction(eventInfo);
    const actionElement = action && getActionElement(action);
    unsetAction(eventInfo);
    const parentNode = actionElement && this.getParentNode(actionElement);
    if (!parentNode) {
      return;
    }
    this.populateAction(eventInfo, parentNode);
  }
  /**
   * Searches for a jsaction that the DOM event maps to and creates an
   * object containing event information used for dispatching by
   * jsaction.Dispatcher. This method populates the `action` and `actionElement`
   * fields of the EventInfo object passed in by finding the first
   * jsaction attribute above the target Node of the event, and below
   * the container Node, that specifies a jsaction for the event
   * type. If no such jsaction is found, then action is undefined.
   *
   * @param eventInfo `EventInfo` to set `action` and `actionElement` if an
   *    action is found on any `Element` in the path of the `Event`.
   */
  populateAction(eventInfo, currentTarget) {
    let actionElement = currentTarget;
    while (actionElement && actionElement !== getContainer(eventInfo)) {
      if (actionElement.nodeType === Node.ELEMENT_NODE) {
        this.populateActionOnElement(actionElement, eventInfo);
      }
      if (getAction(eventInfo)) {
        break;
      }
      actionElement = this.getParentNode(actionElement);
    }
    const action = getAction(eventInfo);
    if (!action) {
      return;
    }
    if (this.a11yClickSupport) {
      this.preventDefaultForA11yClick(eventInfo);
    }
    if (this.syntheticMouseEventSupport) {
      if (getEventType(eventInfo) === EventType.MOUSEENTER || getEventType(eventInfo) === EventType.MOUSELEAVE || getEventType(eventInfo) === EventType.POINTERENTER || getEventType(eventInfo) === EventType.POINTERLEAVE) {
        if (isMouseSpecialEvent(getEvent(eventInfo), getEventType(eventInfo), getActionElement(action))) {
          const copiedEvent = createMouseSpecialEvent(getEvent(eventInfo), getActionElement(action));
          setEvent(eventInfo, copiedEvent);
          setTargetElement(eventInfo, getActionElement(action));
        } else {
          unsetAction(eventInfo);
        }
      }
    }
  }
  /**
   * Walk to the parent node, unless the node has a different owner in
   * which case we walk to the owner. Attempt to walk to host of a
   * shadow root if needed.
   */
  getParentNode(element) {
    const owner = element[Property.OWNER];
    if (owner) {
      return owner;
    }
    const parentNode = element.parentNode;
    if (parentNode?.nodeName === "#document-fragment") {
      return parentNode?.host ?? null;
    }
    return parentNode;
  }
  /**
   * Accesses the jsaction map on a node and retrieves the name of the
   * action the given event is mapped to, if any. It parses the
   * attribute value and stores it in a property on the node for
   * subsequent retrieval without re-parsing and re-accessing the
   * attribute.
   *
   * @param actionElement The DOM node to retrieve the jsaction map from.
   * @param eventInfo `EventInfo` to set `action` and `actionElement` if an
   *    action is found on the `actionElement`.
   */
  populateActionOnElement(actionElement, eventInfo) {
    const actionMap = this.parseActions(actionElement);
    const actionName = actionMap[getEventType(eventInfo)];
    if (actionName !== void 0) {
      setAction(eventInfo, actionName, actionElement);
    }
    if (this.a11yClickSupport) {
      this.populateClickOnlyAction(actionElement, eventInfo, actionMap);
    }
  }
  /**
   * Parses and caches an element's jsaction element into a map.
   *
   * This is primarily for internal use.
   *
   * @param actionElement The DOM node to retrieve the jsaction map from.
   * @return Map from event to qualified name of the jsaction bound to it.
   */
  parseActions(actionElement) {
    let actionMap = get(actionElement);
    if (!actionMap) {
      const jsactionAttribute = actionElement.getAttribute(Attribute.JSACTION);
      if (!jsactionAttribute) {
        actionMap = EMPTY_ACTION_MAP;
        set(actionElement, actionMap);
      } else {
        actionMap = getParsed(jsactionAttribute);
        if (!actionMap) {
          actionMap = {};
          const values = jsactionAttribute.split(REGEXP_SEMICOLON);
          for (let idx = 0; idx < values.length; idx++) {
            const value = values[idx];
            if (!value) {
              continue;
            }
            const colon = value.indexOf(Char.EVENT_ACTION_SEPARATOR);
            const hasColon = colon !== -1;
            const type = hasColon ? value.substr(0, colon).trim() : DEFAULT_EVENT_TYPE;
            const action = hasColon ? value.substr(colon + 1).trim() : value;
            actionMap[type] = action;
          }
          setParsed(jsactionAttribute, actionMap);
        }
        set(actionElement, actionMap);
      }
    }
    return actionMap;
  }
  addA11yClickSupport(updateEventInfoForA11yClick, preventDefaultForA11yClick, populateClickOnlyAction) {
    this.a11yClickSupport = true;
    this.updateEventInfoForA11yClick = updateEventInfoForA11yClick;
    this.preventDefaultForA11yClick = preventDefaultForA11yClick;
    this.populateClickOnlyAction = populateClickOnlyAction;
  }
};
var Restriction;
(function(Restriction2) {
  Restriction2[Restriction2["I_AM_THE_JSACTION_FRAMEWORK"] = 0] = "I_AM_THE_JSACTION_FRAMEWORK";
})(Restriction || (Restriction = {}));
var Dispatcher = class {
  /**
   * Options are:
   *   - `eventReplayer`: When the event contract dispatches replay events
   *      to the Dispatcher, the Dispatcher collects them and in the next tick
   *      dispatches them to the `eventReplayer`. Defaults to dispatching to `dispatchDelegate`.
   * @param dispatchDelegate A function that should handle dispatching an `EventInfoWrapper` to handlers.
   */
  constructor(dispatchDelegate, {
    actionResolver,
    eventReplayer
  } = {}) {
    this.dispatchDelegate = dispatchDelegate;
    this.eventReplayScheduled = false;
    this.replayEventInfoWrappers = [];
    this.actionResolver = actionResolver;
    this.eventReplayer = eventReplayer;
  }
  /**
   * Receives an event or the event queue from the EventContract. The event
   * queue is copied and it attempts to replay.
   * If event info is passed in it looks for an action handler that can handle
   * the given event.  If there is no handler registered queues the event and
   * checks if a loader is registered for the given namespace. If so, calls it.
   *
   * Alternatively, if in global dispatch mode, calls all registered global
   * handlers for the appropriate event type.
   *
   * The three functionalities of this call are deliberately not split into
   * three methods (and then declared as an abstract interface), because the
   * interface is used by EventContract, which lives in a different jsbinary.
   * Therefore the interface between the three is defined entirely in terms that
   * are invariant under jscompiler processing (Function and Array, as opposed
   * to a custom type with method names).
   *
   * @param eventInfo The info for the event that triggered this call or the
   *     queue of events from EventContract.
   */
  dispatch(eventInfo) {
    const eventInfoWrapper = new EventInfoWrapper(eventInfo);
    this.actionResolver?.resolveEventType(eventInfo);
    this.actionResolver?.resolveAction(eventInfo);
    const action = eventInfoWrapper.getAction();
    if (action && shouldPreventDefaultBeforeDispatching(action.element, eventInfoWrapper)) {
      preventDefault(eventInfoWrapper.getEvent());
    }
    if (this.eventReplayer && eventInfoWrapper.getIsReplay()) {
      this.scheduleEventInfoWrapperReplay(eventInfoWrapper);
      return;
    }
    this.dispatchDelegate(eventInfoWrapper);
  }
  /**
   * Schedules an `EventInfoWrapper` for replay. The replaying will happen in its own
   * stack once the current flow cedes control. This is done to mimic
   * browser event handling.
   */
  scheduleEventInfoWrapperReplay(eventInfoWrapper) {
    this.replayEventInfoWrappers.push(eventInfoWrapper);
    if (this.eventReplayScheduled) {
      return;
    }
    this.eventReplayScheduled = true;
    Promise.resolve().then(() => {
      this.eventReplayScheduled = false;
      this.eventReplayer(this.replayEventInfoWrappers);
    });
  }
};
function shouldPreventDefaultBeforeDispatching(actionElement, eventInfoWrapper) {
  return actionElement.tagName === "A" && (eventInfoWrapper.getEventType() === EventType.CLICK || eventInfoWrapper.getEventType() === EventType.CLICKMOD);
}
var PROPAGATION_STOPPED_SYMBOL = Symbol.for("propagationStopped");
var EventPhase = {
  REPLAY: 101
};
var PREVENT_DEFAULT_ERROR_MESSAGE_DETAILS = " Because event replay occurs after browser dispatch, `preventDefault` would have no effect. You can check whether an event is being replayed by accessing the event phase: `event.eventPhase === EventPhase.REPLAY`.";
var PREVENT_DEFAULT_ERROR_MESSAGE = `\`preventDefault\` called during event replay.`;
var COMPOSED_PATH_ERROR_MESSAGE_DETAILS = " Because event replay occurs after browser dispatch, `composedPath()` will be empty. Iterate parent nodes from `event.target` or `event.currentTarget` if you need to check elements in the event path.";
var COMPOSED_PATH_ERROR_MESSAGE = `\`composedPath\` called during event replay.`;
var EventDispatcher = class {
  constructor(dispatchDelegate, clickModSupport = true) {
    this.dispatchDelegate = dispatchDelegate;
    this.clickModSupport = clickModSupport;
    this.actionResolver = new ActionResolver({
      clickModSupport
    });
    this.dispatcher = new Dispatcher((eventInfoWrapper) => {
      this.dispatchToDelegate(eventInfoWrapper);
    }, {
      actionResolver: this.actionResolver
    });
  }
  /**
   * The entrypoint for the `EventContract` dispatch.
   */
  dispatch(eventInfo) {
    this.dispatcher.dispatch(eventInfo);
  }
  /** Internal method that does basic disaptching. */
  dispatchToDelegate(eventInfoWrapper) {
    if (eventInfoWrapper.getIsReplay()) {
      prepareEventForReplay(eventInfoWrapper);
    }
    prepareEventForBubbling(eventInfoWrapper);
    while (eventInfoWrapper.getAction()) {
      prepareEventForDispatch(eventInfoWrapper);
      this.dispatchDelegate(eventInfoWrapper.getEvent(), eventInfoWrapper.getAction().name);
      if (propagationStopped(eventInfoWrapper)) {
        return;
      }
      this.actionResolver.resolveParentAction(eventInfoWrapper.eventInfo);
    }
  }
};
function prepareEventForBubbling(eventInfoWrapper) {
  const event = eventInfoWrapper.getEvent();
  const originalStopPropagation = eventInfoWrapper.getEvent().stopPropagation.bind(event);
  const stopPropagation = () => {
    event[PROPAGATION_STOPPED_SYMBOL] = true;
    originalStopPropagation();
  };
  patchEventInstance(event, "stopPropagation", stopPropagation);
  patchEventInstance(event, "stopImmediatePropagation", stopPropagation);
}
function propagationStopped(eventInfoWrapper) {
  const event = eventInfoWrapper.getEvent();
  return !!event[PROPAGATION_STOPPED_SYMBOL];
}
function prepareEventForReplay(eventInfoWrapper) {
  const event = eventInfoWrapper.getEvent();
  const target = eventInfoWrapper.getTargetElement();
  const originalPreventDefault = event.preventDefault.bind(event);
  patchEventInstance(event, "target", target);
  patchEventInstance(event, "eventPhase", EventPhase.REPLAY);
  patchEventInstance(event, "preventDefault", () => {
    originalPreventDefault();
    throw new Error(PREVENT_DEFAULT_ERROR_MESSAGE + (ngDevMode ? PREVENT_DEFAULT_ERROR_MESSAGE_DETAILS : ""));
  });
  patchEventInstance(event, "composedPath", () => {
    throw new Error(COMPOSED_PATH_ERROR_MESSAGE + (ngDevMode ? COMPOSED_PATH_ERROR_MESSAGE_DETAILS : ""));
  });
}
function prepareEventForDispatch(eventInfoWrapper) {
  const event = eventInfoWrapper.getEvent();
  const currentTarget = eventInfoWrapper.getAction()?.element;
  if (currentTarget) {
    patchEventInstance(event, "currentTarget", currentTarget, {
      // `currentTarget` is going to get reassigned every dispatch.
      configurable: true
    });
  }
}
function patchEventInstance(event, property, value, {
  configurable = false
} = {}) {
  Object.defineProperty(event, property, {
    value,
    configurable
  });
}
function registerDispatcher$1(eventContract, dispatcher) {
  eventContract.ecrd((eventInfo) => {
    dispatcher.dispatch(eventInfo);
  }, Restriction.I_AM_THE_JSACTION_FRAMEWORK);
}
function createEarlyJsactionData(container) {
  const q = [];
  const d = (eventInfo) => {
    q.push(eventInfo);
  };
  const h = (event) => {
    d(createEventInfoFromParameters(event.type, event, event.target, container, Date.now()));
  };
  return {
    c: container,
    q,
    et: [],
    etc: [],
    d,
    h
  };
}
function addEvents(earlyJsactionData, types, capture) {
  for (let i = 0; i < types.length; i++) {
    const eventType = types[i];
    const eventTypes = capture ? earlyJsactionData.etc : earlyJsactionData.et;
    eventTypes.push(eventType);
    earlyJsactionData.c.addEventListener(eventType, earlyJsactionData.h, capture);
  }
}
function getQueuedEventInfos(earlyJsactionData) {
  return earlyJsactionData?.q ?? [];
}
function registerDispatcher(earlyJsactionData, dispatcher) {
  if (!earlyJsactionData) {
    return;
  }
  earlyJsactionData.d = dispatcher;
}
function removeAllEventListeners(earlyJsactionData) {
  if (!earlyJsactionData) {
    return;
  }
  removeEventListeners(earlyJsactionData.c, earlyJsactionData.et, earlyJsactionData.h);
  removeEventListeners(earlyJsactionData.c, earlyJsactionData.etc, earlyJsactionData.h, true);
}
function removeEventListeners(container, eventTypes, earlyEventHandler, capture) {
  for (let i = 0; i < eventTypes.length; i++) {
    container.removeEventListener(
      eventTypes[i],
      earlyEventHandler,
      /* useCapture */
      capture
    );
  }
}
var MOUSE_SPECIAL_SUPPORT = false;
var EventContract = class _EventContract {
  static {
    this.MOUSE_SPECIAL_SUPPORT = MOUSE_SPECIAL_SUPPORT;
  }
  constructor(containerManager) {
    this.eventHandlers = {};
    this.browserEventTypeToExtraEventTypes = {};
    this.dispatcher = null;
    this.queuedEventInfos = [];
    this.containerManager = containerManager;
  }
  handleEvent(eventType, event, container) {
    const eventInfo = createEventInfoFromParameters(
      /* eventType= */
      eventType,
      /* event= */
      event,
      /* targetElement= */
      event.target,
      /* container= */
      container,
      /* timestamp= */
      Date.now()
    );
    this.handleEventInfo(eventInfo);
  }
  /**
   * Handle an `EventInfo`.
   */
  handleEventInfo(eventInfo) {
    if (!this.dispatcher) {
      setIsReplay(eventInfo, true);
      this.queuedEventInfos?.push(eventInfo);
      return;
    }
    this.dispatcher(eventInfo);
  }
  /**
   * Enables jsaction handlers to be called for the event type given by
   * name.
   *
   * If the event is already registered, this does nothing.
   *
   * @param prefixedEventType If supplied, this event is used in
   *     the actual browser event registration instead of the name that is
   *     exposed to jsaction. Use this if you e.g. want users to be able
   *     to subscribe to jsaction="transitionEnd:foo" while the underlying
   *     event is webkitTransitionEnd in one browser and mozTransitionEnd
   *     in another.
   */
  addEvent(eventType, prefixedEventType) {
    if (eventType in this.eventHandlers || !this.containerManager) {
      return;
    }
    if (!_EventContract.MOUSE_SPECIAL_SUPPORT && MOUSE_SPECIAL_EVENT_TYPES.indexOf(eventType) >= 0) {
      return;
    }
    const eventHandler = (eventType2, event, container) => {
      this.handleEvent(eventType2, event, container);
    };
    this.eventHandlers[eventType] = eventHandler;
    const browserEventType = getBrowserEventType(prefixedEventType || eventType);
    if (browserEventType !== eventType) {
      const eventTypes = this.browserEventTypeToExtraEventTypes[browserEventType] || [];
      eventTypes.push(eventType);
      this.browserEventTypeToExtraEventTypes[browserEventType] = eventTypes;
    }
    this.containerManager.addEventListener(browserEventType, (element) => {
      return (event) => {
        eventHandler(eventType, event, element);
      };
    });
  }
  /**
   * Gets the queued early events and replay them using the appropriate handler
   * in the provided event contract. Once all the events are replayed, it cleans
   * up the early contract.
   */
  replayEarlyEvents(earlyJsactionData = window._ejsa) {
    if (!earlyJsactionData) {
      return;
    }
    this.replayEarlyEventInfos(earlyJsactionData.q);
    removeAllEventListeners(earlyJsactionData);
    delete window._ejsa;
  }
  /**
   * Replays all the early `EventInfo` objects, dispatching them through the normal
   * `EventContract` flow.
   */
  replayEarlyEventInfos(earlyEventInfos) {
    for (let i = 0; i < earlyEventInfos.length; i++) {
      const earlyEventInfo = earlyEventInfos[i];
      const eventTypes = this.getEventTypesForBrowserEventType(earlyEventInfo.eventType);
      for (let j = 0; j < eventTypes.length; j++) {
        const eventInfo = cloneEventInfo(earlyEventInfo);
        setEventType(eventInfo, eventTypes[j]);
        this.handleEventInfo(eventInfo);
      }
    }
  }
  /**
   * Returns all JSAction event types that have been registered for a given
   * browser event type.
   */
  getEventTypesForBrowserEventType(browserEventType) {
    const eventTypes = [];
    if (this.eventHandlers[browserEventType]) {
      eventTypes.push(browserEventType);
    }
    if (this.browserEventTypeToExtraEventTypes[browserEventType]) {
      eventTypes.push(...this.browserEventTypeToExtraEventTypes[browserEventType]);
    }
    return eventTypes;
  }
  /**
   * Returns the event handler function for a given event type.
   */
  handler(eventType) {
    return this.eventHandlers[eventType];
  }
  /**
   * Cleans up the event contract. This resets all of the `EventContract`'s
   * internal state. Users are responsible for not using this `EventContract`
   * after it has been cleaned up.
   */
  cleanUp() {
    this.containerManager.cleanUp();
    this.containerManager = null;
    this.eventHandlers = {};
    this.browserEventTypeToExtraEventTypes = {};
    this.dispatcher = null;
    this.queuedEventInfos = [];
  }
  /**
   * Register a dispatcher function. Event info of each event mapped to
   * a jsaction is passed for handling to this callback. The queued
   * events are passed as well to the dispatcher for later replaying
   * once the dispatcher is registered. Clears the event queue to null.
   *
   * @param dispatcher The dispatcher function.
   * @param restriction
   */
  registerDispatcher(dispatcher, restriction) {
    this.ecrd(dispatcher, restriction);
  }
  /**
   * Unrenamed alias for registerDispatcher. Necessary for any codebases that
   * split the `EventContract` and `Dispatcher` code into different compilation
   * units.
   */
  ecrd(dispatcher, restriction) {
    this.dispatcher = dispatcher;
    if (this.queuedEventInfos?.length) {
      for (let i = 0; i < this.queuedEventInfos.length; i++) {
        this.handleEventInfo(this.queuedEventInfos[i]);
      }
      this.queuedEventInfos = null;
    }
  }
};
function bootstrapAppScopedEarlyEventContract(container, appId, bubbleEventTypes, captureEventTypes, dataContainer = window) {
  const earlyJsactionData = createEarlyJsactionData(container);
  if (!dataContainer._ejsas) {
    dataContainer._ejsas = {};
  }
  dataContainer._ejsas[appId] = earlyJsactionData;
  addEvents(earlyJsactionData, bubbleEventTypes);
  addEvents(
    earlyJsactionData,
    captureEventTypes,
    /* capture= */
    true
  );
}
function getAppScopedQueuedEventInfos(appId, dataContainer = window) {
  return getQueuedEventInfos(dataContainer._ejsas?.[appId]);
}
function registerAppScopedDispatcher(restriction, appId, dispatcher, dataContainer = window) {
  registerDispatcher(dataContainer._ejsas?.[appId], dispatcher);
}
function removeAllAppScopedEventListeners(appId, dataContainer = window) {
  removeAllEventListeners(dataContainer._ejsas?.[appId]);
}
function clearAppScopedEarlyEventContract(appId, dataContainer = window) {
  if (!dataContainer._ejsas) {
    return;
  }
  dataContainer._ejsas[appId] = void 0;
}

export {
  Attribute,
  getDefaulted,
  isCaptureEventType,
  isEarlyEventType,
  EventContractContainer,
  EventInfoWrapper,
  EventPhase,
  EventDispatcher,
  registerDispatcher$1,
  EventContract,
  bootstrapAppScopedEarlyEventContract,
  getAppScopedQueuedEventInfos,
  registerAppScopedDispatcher,
  removeAllAppScopedEventListeners,
  clearAppScopedEarlyEventContract
};
/*! Bundled license information:

@angular/core/fesm2022/primitives/event-dispatch.mjs:
  (**
   * @license Angular v18.2.0
   * (c) 2010-2024 Google LLC. https://angular.io/
   * License: MIT
   *)
*/
//# sourceMappingURL=chunk-VKET2LIV.js.map



================================================
FILE: .angular/cache/18.2.20/angular-pivothead-example/vite/deps/chunk-WDMUDEB6.js
================================================
var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b ||= {})
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var __objRest = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};

export {
  __spreadValues,
  __spreadProps,
  __objRest,
  __async
};
//# sourceMappingURL=chunk-WDMUDEB6.js.map



================================================
FILE: .angular/cache/18.2.20/angular-pivothead-example/vite/deps/html2canvas.esm-1a1724a1-JMHMFZKW.js
================================================
import "./chunk-WDMUDEB6.js";

// node_modules/@mindfiredigital/pivothead-angular/node_modules/@mindfiredigital/pivothead-web-component/node_modules/@mindfiredigital/pivothead/dist/html2canvas.esm-1a1724a1.mjs
var mr = function(e, A) {
  return mr = Object.setPrototypeOf || {
    __proto__: []
  } instanceof Array && function(t, r) {
    t.__proto__ = r;
  } || function(t, r) {
    for (var B in r) Object.prototype.hasOwnProperty.call(r, B) && (t[B] = r[B]);
  }, mr(e, A);
};
function tA(e, A) {
  if (typeof A != "function" && A !== null) throw new TypeError("Class extends value " + String(A) + " is not a constructor or null");
  mr(e, A);
  function t() {
    this.constructor = e;
  }
  e.prototype = A === null ? Object.create(A) : (t.prototype = A.prototype, new t());
}
var Lr = function() {
  return Lr = Object.assign || function(A) {
    for (var t, r = 1, B = arguments.length; r < B; r++) {
      t = arguments[r];
      for (var n in t) Object.prototype.hasOwnProperty.call(t, n) && (A[n] = t[n]);
    }
    return A;
  }, Lr.apply(this, arguments);
};
function P(e, A, t, r) {
  function B(n) {
    return n instanceof t ? n : new t(function(s) {
      s(n);
    });
  }
  return new (t || (t = Promise))(function(n, s) {
    function i(Q) {
      try {
        o(r.next(Q));
      } catch (g) {
        s(g);
      }
    }
    function a(Q) {
      try {
        o(r.throw(Q));
      } catch (g) {
        s(g);
      }
    }
    function o(Q) {
      Q.done ? n(Q.value) : B(Q.value).then(i, a);
    }
    o((r = r.apply(e, A || [])).next());
  });
}
function _(e, A) {
  var t = {
    label: 0,
    sent: function() {
      if (n[0] & 1) throw n[1];
      return n[1];
    },
    trys: [],
    ops: []
  }, r, B, n, s;
  return s = {
    next: i(0),
    throw: i(1),
    return: i(2)
  }, typeof Symbol == "function" && (s[Symbol.iterator] = function() {
    return this;
  }), s;
  function i(o) {
    return function(Q) {
      return a([o, Q]);
    };
  }
  function a(o) {
    if (r) throw new TypeError("Generator is already executing.");
    for (; t; ) try {
      if (r = 1, B && (n = o[0] & 2 ? B.return : o[0] ? B.throw || ((n = B.return) && n.call(B), 0) : B.next) && !(n = n.call(B, o[1])).done) return n;
      switch (B = 0, n && (o = [o[0] & 2, n.value]), o[0]) {
        case 0:
        case 1:
          n = o;
          break;
        case 4:
          return t.label++, {
            value: o[1],
            done: false
          };
        case 5:
          t.label++, B = o[1], o = [0];
          continue;
        case 7:
          o = t.ops.pop(), t.trys.pop();
          continue;
        default:
          if (n = t.trys, !(n = n.length > 0 && n[n.length - 1]) && (o[0] === 6 || o[0] === 2)) {
            t = 0;
            continue;
          }
          if (o[0] === 3 && (!n || o[1] > n[0] && o[1] < n[3])) {
            t.label = o[1];
            break;
          }
          if (o[0] === 6 && t.label < n[1]) {
            t.label = n[1], n = o;
            break;
          }
          if (n && t.label < n[2]) {
            t.label = n[2], t.ops.push(o);
            break;
          }
          n[2] && t.ops.pop(), t.trys.pop();
          continue;
      }
      o = A.call(e, t);
    } catch (Q) {
      o = [6, Q], B = 0;
    } finally {
      r = n = 0;
    }
    if (o[0] & 5) throw o[1];
    return {
      value: o[0] ? o[1] : void 0,
      done: true
    };
  }
}
function ue(e, A, t) {
  if (t || arguments.length === 2) for (var r = 0, B = A.length, n; r < B; r++) (n || !(r in A)) && (n || (n = Array.prototype.slice.call(A, 0, r)), n[r] = A[r]);
  return e.concat(n || A);
}
var cA = (
  /** @class */
  function() {
    function e(A, t, r, B) {
      this.left = A, this.top = t, this.width = r, this.height = B;
    }
    return e.prototype.add = function(A, t, r, B) {
      return new e(this.left + A, this.top + t, this.width + r, this.height + B);
    }, e.fromClientRect = function(A, t) {
      return new e(t.left + A.windowBounds.left, t.top + A.windowBounds.top, t.width, t.height);
    }, e.fromDOMRectList = function(A, t) {
      var r = Array.from(t).find(function(B) {
        return B.width !== 0;
      });
      return r ? new e(r.left + A.windowBounds.left, r.top + A.windowBounds.top, r.width, r.height) : e.EMPTY;
    }, e.EMPTY = new e(0, 0, 0, 0), e;
  }()
);
var ze = function(e, A) {
  return cA.fromClientRect(e, A.getBoundingClientRect());
};
var an = function(e) {
  var A = e.body, t = e.documentElement;
  if (!A || !t) throw new Error("Unable to get document size");
  var r = Math.max(Math.max(A.scrollWidth, t.scrollWidth), Math.max(A.offsetWidth, t.offsetWidth), Math.max(A.clientWidth, t.clientWidth)), B = Math.max(Math.max(A.scrollHeight, t.scrollHeight), Math.max(A.offsetHeight, t.offsetHeight), Math.max(A.clientHeight, t.clientHeight));
  return new cA(0, 0, r, B);
};
var $e = function(e) {
  for (var A = [], t = 0, r = e.length; t < r; ) {
    var B = e.charCodeAt(t++);
    if (B >= 55296 && B <= 56319 && t < r) {
      var n = e.charCodeAt(t++);
      (n & 64512) === 56320 ? A.push(((B & 1023) << 10) + (n & 1023) + 65536) : (A.push(B), t--);
    } else A.push(B);
  }
  return A;
};
var S = function() {
  for (var e = [], A = 0; A < arguments.length; A++) e[A] = arguments[A];
  if (String.fromCodePoint) return String.fromCodePoint.apply(String, e);
  var t = e.length;
  if (!t) return "";
  for (var r = [], B = -1, n = ""; ++B < t; ) {
    var s = e[B];
    s <= 65535 ? r.push(s) : (s -= 65536, r.push((s >> 10) + 55296, s % 1024 + 56320)), (B + 1 === t || r.length > 16384) && (n += String.fromCharCode.apply(String, r), r.length = 0);
  }
  return n;
};
var nt = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
var on = typeof Uint8Array > "u" ? [] : new Uint8Array(256);
for (le = 0; le < nt.length; le++) on[nt.charCodeAt(le)] = le;
var le;
var st = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
var zA = typeof Uint8Array > "u" ? [] : new Uint8Array(256);
for (fe = 0; fe < st.length; fe++) zA[st.charCodeAt(fe)] = fe;
var fe;
var Qn = function(e) {
  var A = e.length * 0.75, t = e.length, r, B = 0, n, s, i, a;
  e[e.length - 1] === "=" && (A--, e[e.length - 2] === "=" && A--);
  var o = typeof ArrayBuffer < "u" && typeof Uint8Array < "u" && typeof Uint8Array.prototype.slice < "u" ? new ArrayBuffer(A) : new Array(A), Q = Array.isArray(o) ? o : new Uint8Array(o);
  for (r = 0; r < t; r += 4) n = zA[e.charCodeAt(r)], s = zA[e.charCodeAt(r + 1)], i = zA[e.charCodeAt(r + 2)], a = zA[e.charCodeAt(r + 3)], Q[B++] = n << 2 | s >> 4, Q[B++] = (s & 15) << 4 | i >> 2, Q[B++] = (i & 3) << 6 | a & 63;
  return o;
};
var gn = function(e) {
  for (var A = e.length, t = [], r = 0; r < A; r += 2) t.push(e[r + 1] << 8 | e[r]);
  return t;
};
var wn = function(e) {
  for (var A = e.length, t = [], r = 0; r < A; r += 4) t.push(e[r + 3] << 24 | e[r + 2] << 16 | e[r + 1] << 8 | e[r]);
  return t;
};
var bA = 5;
var zr = 6 + 5;
var ir = 2;
var cn = zr - bA;
var BB = 65536 >> bA;
var Cn = 1 << bA;
var or = Cn - 1;
var un = 1024 >> bA;
var ln = BB + un;
var fn = ln;
var Un = 32;
var Fn = fn + Un;
var hn = 65536 >> zr;
var dn = 1 << cn;
var En = dn - 1;
var at = function(e, A, t) {
  return e.slice ? e.slice(A, t) : new Uint16Array(Array.prototype.slice.call(e, A, t));
};
var Hn = function(e, A, t) {
  return e.slice ? e.slice(A, t) : new Uint32Array(Array.prototype.slice.call(e, A, t));
};
var pn = function(e, A) {
  var t = Qn(e), r = Array.isArray(t) ? wn(t) : new Uint32Array(t), B = Array.isArray(t) ? gn(t) : new Uint16Array(t), n = 24, s = at(B, n / 2, r[4] / 2), i = r[5] === 2 ? at(B, (n + r[4]) / 2) : Hn(r, Math.ceil((n + r[4]) / 4));
  return new In(r[0], r[1], r[2], r[3], s, i);
};
var In = (
  /** @class */
  function() {
    function e(A, t, r, B, n, s) {
      this.initialValue = A, this.errorValue = t, this.highStart = r, this.highValueIndex = B, this.index = n, this.data = s;
    }
    return e.prototype.get = function(A) {
      var t;
      if (A >= 0) {
        if (A < 55296 || A > 56319 && A <= 65535) return t = this.index[A >> bA], t = (t << ir) + (A & or), this.data[t];
        if (A <= 65535) return t = this.index[BB + (A - 55296 >> bA)], t = (t << ir) + (A & or), this.data[t];
        if (A < this.highStart) return t = Fn - hn + (A >> zr), t = this.index[t], t += A >> bA & En, t = this.index[t], t = (t << ir) + (A & or), this.data[t];
        if (A <= 1114111) return this.data[this.highValueIndex];
      }
      return this.errorValue;
    }, e;
  }()
);
var it = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
var vn = typeof Uint8Array > "u" ? [] : new Uint8Array(256);
for (Ue = 0; Ue < it.length; Ue++) vn[it.charCodeAt(Ue)] = Ue;
var Ue;
var yn = "KwAAAAAAAAAACA4AUD0AADAgAAACAAAAAAAIABAAGABAAEgAUABYAGAAaABgAGgAYgBqAF8AZwBgAGgAcQB5AHUAfQCFAI0AlQCdAKIAqgCyALoAYABoAGAAaABgAGgAwgDKAGAAaADGAM4A0wDbAOEA6QDxAPkAAQEJAQ8BFwF1AH0AHAEkASwBNAE6AUIBQQFJAVEBWQFhAWgBcAF4ATAAgAGGAY4BlQGXAZ8BpwGvAbUBvQHFAc0B0wHbAeMB6wHxAfkBAQIJAvEBEQIZAiECKQIxAjgCQAJGAk4CVgJeAmQCbAJ0AnwCgQKJApECmQKgAqgCsAK4ArwCxAIwAMwC0wLbAjAA4wLrAvMC+AIAAwcDDwMwABcDHQMlAy0DNQN1AD0DQQNJA0kDSQNRA1EDVwNZA1kDdQB1AGEDdQBpA20DdQN1AHsDdQCBA4kDkQN1AHUAmQOhA3UAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AKYDrgN1AHUAtgO+A8YDzgPWAxcD3gPjA+sD8wN1AHUA+wMDBAkEdQANBBUEHQQlBCoEFwMyBDgEYABABBcDSARQBFgEYARoBDAAcAQzAXgEgASIBJAEdQCXBHUAnwSnBK4EtgS6BMIEyAR1AHUAdQB1AHUAdQCVANAEYABgAGAAYABgAGAAYABgANgEYADcBOQEYADsBPQE/AQEBQwFFAUcBSQFLAU0BWQEPAVEBUsFUwVbBWAAYgVgAGoFcgV6BYIFigWRBWAAmQWfBaYFYABgAGAAYABgAKoFYACxBbAFuQW6BcEFwQXHBcEFwQXPBdMF2wXjBeoF8gX6BQIGCgYSBhoGIgYqBjIGOgZgAD4GRgZMBmAAUwZaBmAAYABgAGAAYABgAGAAYABgAGAAYABgAGIGYABpBnAGYABgAGAAYABgAGAAYABgAGAAYAB4Bn8GhQZgAGAAYAB1AHcDFQSLBmAAYABgAJMGdQA9A3UAmwajBqsGqwaVALMGuwbDBjAAywbSBtIG1QbSBtIG0gbSBtIG0gbdBuMG6wbzBvsGAwcLBxMHAwcbByMHJwcsBywHMQcsB9IGOAdAB0gHTgfSBkgHVgfSBtIG0gbSBtIG0gbSBtIG0gbSBiwHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAdgAGAALAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAdbB2MHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsB2kH0gZwB64EdQB1AHUAdQB1AHUAdQB1AHUHfQdgAIUHjQd1AHUAlQedB2AAYAClB6sHYACzB7YHvgfGB3UAzgfWBzMB3gfmB1EB7gf1B/0HlQENAQUIDQh1ABUIHQglCBcDLQg1CD0IRQhNCEEDUwh1AHUAdQBbCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIcAh3CHoIMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwAIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIgggwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAALAcsBywHLAcsBywHLAcsBywHLAcsB4oILAcsB44I0gaWCJ4Ipgh1AHUAqgiyCHUAdQB1AHUAdQB1AHUAdQB1AHUAtwh8AXUAvwh1AMUIyQjRCNkI4AjoCHUAdQB1AO4I9gj+CAYJDgkTCS0HGwkjCYIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiAAIAAAAFAAYABgAGIAXwBgAHEAdQBFAJUAogCyAKAAYABgAEIA4ABGANMA4QDxAMEBDwE1AFwBLAE6AQEBUQF4QkhCmEKoQrhCgAHIQsAB0MLAAcABwAHAAeDC6ABoAHDCwMMAAcABwAHAAdDDGMMAAcAB6MM4wwjDWMNow3jDaABoAGgAaABoAGgAaABoAGgAaABoAGgAaABoAGgAaABoAGgAaABoAEjDqABWw6bDqABpg6gAaABoAHcDvwOPA+gAaABfA/8DvwO/A78DvwO/A78DvwO/A78DvwO/A78DvwO/A78DvwO/A78DvwO/A78DvwO/A78DvwO/A78DpcPAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcAB9cPKwkyCToJMAB1AHUAdQBCCUoJTQl1AFUJXAljCWcJawkwADAAMAAwAHMJdQB2CX4JdQCECYoJjgmWCXUAngkwAGAAYABxAHUApgn3A64JtAl1ALkJdQDACTAAMAAwADAAdQB1AHUAdQB1AHUAdQB1AHUAowYNBMUIMAAwADAAMADICcsJ0wnZCRUE4QkwAOkJ8An4CTAAMAB1AAAKvwh1AAgKDwoXCh8KdQAwACcKLgp1ADYKqAmICT4KRgowADAAdQB1AE4KMAB1AFYKdQBeCnUAZQowADAAMAAwADAAMAAwADAAMAAVBHUAbQowADAAdQC5CXUKMAAwAHwBxAijBogEMgF9CoQKiASMCpQKmgqIBKIKqgquCogEDQG2Cr4KxgrLCjAAMADTCtsKCgHjCusK8Qr5CgELMAAwADAAMAB1AIsECQsRC3UANAEZCzAAMAAwADAAMAB1ACELKQswAHUANAExCzkLdQBBC0kLMABRC1kLMAAwADAAMAAwADAAdQBhCzAAMAAwAGAAYABpC3ELdwt/CzAAMACHC4sLkwubC58Lpwt1AK4Ltgt1APsDMAAwADAAMAAwADAAMAAwAL4LwwvLC9IL1wvdCzAAMADlC+kL8Qv5C/8LSQswADAAMAAwADAAMAAwADAAMAAHDDAAMAAwADAAMAAODBYMHgx1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1ACYMMAAwADAAdQB1AHUALgx1AHUAdQB1AHUAdQA2DDAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwAHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AD4MdQBGDHUAdQB1AHUAdQB1AEkMdQB1AHUAdQB1AFAMMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwAHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQBYDHUAdQB1AF8MMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUA+wMVBGcMMAAwAHwBbwx1AHcMfwyHDI8MMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAYABgAJcMMAAwADAAdQB1AJ8MlQClDDAAMACtDCwHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsB7UMLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AA0EMAC9DDAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAsBywHLAcsBywHLAcsBywHLQcwAMEMyAwsBywHLAcsBywHLAcsBywHLAcsBywHzAwwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwAHUAdQB1ANQM2QzhDDAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMABgAGAAYABgAGAAYABgAOkMYADxDGAA+AwADQYNYABhCWAAYAAODTAAMAAwADAAFg1gAGAAHg37AzAAMAAwADAAYABgACYNYAAsDTQNPA1gAEMNPg1LDWAAYABgAGAAYABgAGAAYABgAGAAUg1aDYsGVglhDV0NcQBnDW0NdQ15DWAAYABgAGAAYABgAGAAYABgAGAAYABgAGAAYABgAGAAlQCBDZUAiA2PDZcNMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAnw2nDTAAMAAwADAAMAAwAHUArw23DTAAMAAwADAAMAAwADAAMAAwADAAMAB1AL8NMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAB1AHUAdQB1AHUAdQDHDTAAYABgAM8NMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAA1w11ANwNMAAwAD0B5A0wADAAMAAwADAAMADsDfQN/A0EDgwOFA4wABsOMAAwADAAMAAwADAAMAAwANIG0gbSBtIG0gbSBtIG0gYjDigOwQUuDsEFMw7SBjoO0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIGQg5KDlIOVg7SBtIGXg5lDm0OdQ7SBtIGfQ6EDooOjQ6UDtIGmg6hDtIG0gaoDqwO0ga0DrwO0gZgAGAAYADEDmAAYAAkBtIGzA5gANIOYADaDokO0gbSBt8O5w7SBu8O0gb1DvwO0gZgAGAAxA7SBtIG0gbSBtIGYABgAGAAYAAED2AAsAUMD9IG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIGFA8sBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAccD9IGLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHJA8sBywHLAcsBywHLAccDywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywPLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAc0D9IG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIGLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAccD9IG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIGFA8sBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHPA/SBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gYUD0QPlQCVAJUAMAAwADAAMACVAJUAlQCVAJUAlQCVAEwPMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAA//8EAAQABAAEAAQABAAEAAQABAANAAMAAQABAAIABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQACgATABcAHgAbABoAHgAXABYAEgAeABsAGAAPABgAHABLAEsASwBLAEsASwBLAEsASwBLABgAGAAeAB4AHgATAB4AUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQABYAGwASAB4AHgAeAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAWAA0AEQAeAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAAQABAAEAAQABAAFAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAJABYAGgAbABsAGwAeAB0AHQAeAE8AFwAeAA0AHgAeABoAGwBPAE8ADgBQAB0AHQAdAE8ATwAXAE8ATwBPABYAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAB0AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAdAFAAUABQAFAAUABQAFAAUAAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAFAAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAeAB4AHgAeAFAATwBAAE8ATwBPAEAATwBQAFAATwBQAB4AHgAeAB4AHgAeAB0AHQAdAB0AHgAdAB4ADgBQAFAAUABQAFAAHgAeAB4AHgAeAB4AHgBQAB4AUAAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4ABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAJAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAkACQAJAAkACQAJAAkABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAeAB4AHgAeAFAAHgAeAB4AKwArAFAAUABQAFAAGABQACsAKwArACsAHgAeAFAAHgBQAFAAUAArAFAAKwAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AKwAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4ABAAEAAQABAAEAAQABAAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAUAAeAB4AHgAeAB4AHgBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAYAA0AKwArAB4AHgAbACsABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQADQAEAB4ABAAEAB4ABAAEABMABAArACsAKwArACsAKwArACsAVgBWAFYAVgBWAFYAVgBWAFYAVgBWAFYAVgBWAFYAVgBWAFYAVgBWAFYAVgBWAFYAVgBWAFYAKwArACsAKwBWAFYAVgBWAB4AHgArACsAKwArACsAKwArACsAKwArACsAHgAeAB4AHgAeAB4AHgAeAB4AGgAaABoAGAAYAB4AHgAEAAQABAAEAAQABAAEAAQABAAEAAQAEwAEACsAEwATAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABABLAEsASwBLAEsASwBLAEsASwBLABoAGQAZAB4AUABQAAQAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQABMAUAAEAAQABAAEAAQABAAEAB4AHgAEAAQABAAEAAQABABQAFAABAAEAB4ABAAEAAQABABQAFAASwBLAEsASwBLAEsASwBLAEsASwBQAFAAUAAeAB4AUAAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AKwAeAFAABABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAEAAQABAAEAAQABAAEAAQABAAEAFAAKwArACsAKwArACsAKwArACsAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAEAAQABAAEAAQABAAEAAQAUABQAB4AHgAYABMAUAArACsABAAbABsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAFAABAAEAAQABAAEAFAABAAEAAQAUAAEAAQABAAEAAQAKwArAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAArACsAHgArAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArAFAAUABQAFAAUABQAFAAUABQAFAAKwArACsAKwArACsAKwArACsAKwArAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAB4ABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAQABAAEAFAABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQAUAAEAAQABAAEAAQABAAEAFAAUABQAFAAUABQAFAAUABQAFAABAAEAA0ADQBLAEsASwBLAEsASwBLAEsASwBLAB4AUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAArAFAAUABQAFAAUABQAFAAUAArACsAUABQACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAFAAUABQACsAUAArACsAKwBQAFAAUABQACsAKwAEAFAABAAEAAQABAAEAAQABAArACsABAAEACsAKwAEAAQABABQACsAKwArACsAKwArACsAKwAEACsAKwArACsAUABQACsAUABQAFAABAAEACsAKwBLAEsASwBLAEsASwBLAEsASwBLAFAAUAAaABoAUABQAFAAUABQAEwAHgAbAFAAHgAEACsAKwAEAAQABAArAFAAUABQAFAAUABQACsAKwArACsAUABQACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAFAAUABQACsAUABQACsAUABQACsAUABQACsAKwAEACsABAAEAAQABAAEACsAKwArACsABAAEACsAKwAEAAQABAArACsAKwAEACsAKwArACsAKwArACsAUABQAFAAUAArAFAAKwArACsAKwArACsAKwBLAEsASwBLAEsASwBLAEsASwBLAAQABABQAFAAUAAEAB4AKwArACsAKwArACsAKwArACsAKwAEAAQABAArAFAAUABQAFAAUABQAFAAUABQACsAUABQAFAAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAFAAUABQACsAUABQACsAUABQAFAAUABQACsAKwAEAFAABAAEAAQABAAEAAQABAAEACsABAAEAAQAKwAEAAQABAArACsAUAArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwBQAFAABAAEACsAKwBLAEsASwBLAEsASwBLAEsASwBLAB4AGwArACsAKwArACsAKwArAFAABAAEAAQABAAEAAQAKwAEAAQABAArAFAAUABQAFAAUABQAFAAUAArACsAUABQACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAQABAAEAAQABAArACsABAAEACsAKwAEAAQABAArACsAKwArACsAKwArAAQABAAEACsAKwArACsAUABQACsAUABQAFAABAAEACsAKwBLAEsASwBLAEsASwBLAEsASwBLAB4AUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwArAAQAUAArAFAAUABQAFAAUABQACsAKwArAFAAUABQACsAUABQAFAAUAArACsAKwBQAFAAKwBQACsAUABQACsAKwArAFAAUAArACsAKwBQAFAAUAArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArAAQABAAEAAQABAArACsAKwAEAAQABAArAAQABAAEAAQAKwArAFAAKwArACsAKwArACsABAArACsAKwArACsAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAUABQAFAAHgAeAB4AHgAeAB4AGwAeACsAKwArACsAKwAEAAQABAAEAAQAUABQAFAAUABQAFAAUABQACsAUABQAFAAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArACsAUAAEAAQABAAEAAQABAAEACsABAAEAAQAKwAEAAQABAAEACsAKwArACsAKwArACsABAAEACsAUABQAFAAKwArACsAKwArAFAAUAAEAAQAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsAKwAOAFAAUABQAFAAUABQAFAAHgBQAAQABAAEAA4AUABQAFAAUABQAFAAUABQACsAUABQAFAAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAFAAKwArAAQAUAAEAAQABAAEAAQABAAEACsABAAEAAQAKwAEAAQABAAEACsAKwArACsAKwArACsABAAEACsAKwArACsAKwArACsAUAArAFAAUAAEAAQAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwBQAFAAKwArACsAKwArACsAKwArACsAKwArACsAKwAEAAQABAAEAFAAUABQAFAAUABQAFAAUABQACsAUABQAFAAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAEAFAABAAEAAQABAAEAAQABAArAAQABAAEACsABAAEAAQABABQAB4AKwArACsAKwBQAFAAUAAEAFAAUABQAFAAUABQAFAAUABQAFAABAAEACsAKwBLAEsASwBLAEsASwBLAEsASwBLAFAAUABQAFAAUABQAFAAUABQABoAUABQAFAAUABQAFAAKwAEAAQABAArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArAFAAUABQAFAAUABQAFAAUABQACsAUAArACsAUABQAFAAUABQAFAAUAArACsAKwAEACsAKwArACsABAAEAAQABAAEAAQAKwAEACsABAAEAAQABAAEAAQABAAEACsAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArAAQABAAeACsAKwArACsAKwArACsAKwArACsAKwArAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXAAqAFwAXAAqACoAKgAqACoAKgAqACsAKwArACsAGwBcAFwAXABcAFwAXABcACoAKgAqACoAKgAqACoAKgAeAEsASwBLAEsASwBLAEsASwBLAEsADQANACsAKwArACsAKwBcAFwAKwBcACsAXABcAFwAXABcACsAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcACsAXAArAFwAXABcAFwAXABcAFwAXABcAFwAKgBcAFwAKgAqACoAKgAqACoAKgAqACoAXAArACsAXABcAFwAXABcACsAXAArACoAKgAqACoAKgAqACsAKwBLAEsASwBLAEsASwBLAEsASwBLACsAKwBcAFwAXABcAFAADgAOAA4ADgAeAA4ADgAJAA4ADgANAAkAEwATABMAEwATAAkAHgATAB4AHgAeAAQABAAeAB4AHgAeAB4AHgBLAEsASwBLAEsASwBLAEsASwBLAFAAUABQAFAAUABQAFAAUABQAFAADQAEAB4ABAAeAAQAFgARABYAEQAEAAQAUABQAFAAUABQAFAAUABQACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArACsAKwAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQADQAEAAQABAAEAAQADQAEAAQAUABQAFAAUABQAAQABAAEAAQABAAEAAQABAAEAAQABAArAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAArAA0ADQAeAB4AHgAeAB4AHgAEAB4AHgAeAB4AHgAeACsAHgAeAA4ADgANAA4AHgAeAB4AHgAeAAkACQArACsAKwArACsAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgBcAEsASwBLAEsASwBLAEsASwBLAEsADQANAB4AHgAeAB4AXABcAFwAXABcAFwAKgAqACoAKgBcAFwAXABcACoAKgAqAFwAKgAqACoAXABcACoAKgAqACoAKgAqACoAXABcAFwAKgAqACoAKgBcAFwAXABcAFwAXABcAFwAXABcAFwAXABcACoAKgAqACoAKgAqACoAKgAqACoAKgAqAFwAKgBLAEsASwBLAEsASwBLAEsASwBLACoAKgAqACoAKgAqAFAAUABQAFAAUABQACsAUAArACsAKwArACsAUAArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAHgBQAFAAUABQAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABZAFkAWQBZAFkAWQBZAFkAWQBZAFkAWQBZAFkAWQBZAFkAWQBZAFkAWQBZAFkAWQBZAFkAWQBZAFkAWQBZAFkAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFAAUABQAFAAUABQAFAAUABQACsAUABQAFAAUAArACsAUABQAFAAUABQAFAAUAArAFAAKwBQAFAAUABQACsAKwBQAFAAUABQAFAAUABQAFAAUAArAFAAUABQAFAAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArAFAAUABQAFAAKwArAFAAUABQAFAAUABQAFAAKwBQACsAUABQAFAAUAArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAUABQACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsABAAEAAQAHgANAB4AHgAeAB4AHgAeAB4AUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAHgAeAB4AHgAeAB4AHgAeAB4AHgArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwBQAFAAUABQAFAAUAArACsADQBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAHgAeAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAANAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAWABEAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAA0ADQANAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAAQABAAEACsAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAANAA0AKwArACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAEACsAKwArACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAUAArAAQABAArACsAKwArACsAKwArACsAKwArACsAKwBcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqAA0ADQAVAFwADQAeAA0AGwBcACoAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwAeAB4AEwATAA0ADQAOAB4AEwATAB4ABAAEAAQACQArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArAFAAUABQAFAAUAAEAAQAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAQAUAArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwAEAAQABAAEAAQABAAEAAQABAAEAAQABAArACsAKwArAAQABAAEAAQABAAEAAQABAAEAAQABAAEACsAKwArACsAHgArACsAKwATABMASwBLAEsASwBLAEsASwBLAEsASwBcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXAArACsAXABcAFwAXABcACsAKwArACsAKwArACsAKwArACsAKwBcAFwAXABcAFwAXABcAFwAXABcAFwAXAArACsAKwArAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcACsAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAXAArACsAKwAqACoAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAQABAAEAAQABAArACsAHgAeAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcACoAKgAqACoAKgAqACoAKgAqACoAKwAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKwArAAQASwBLAEsASwBLAEsASwBLAEsASwArACsAKwArACsAKwBLAEsASwBLAEsASwBLAEsASwBLACsAKwArACsAKwArACoAKgAqACoAKgAqACoAXAAqACoAKgAqACoAKgArACsABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsABAAEAAQABAAEAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAQABAAEAAQABABQAFAAUABQAFAAUABQACsAKwArACsASwBLAEsASwBLAEsASwBLAEsASwANAA0AHgANAA0ADQANAB4AHgAeAB4AHgAeAB4AHgAeAB4ABAAEAAQABAAEAAQABAAEAAQAHgAeAB4AHgAeAB4AHgAeAB4AKwArACsABAAEAAQAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAEAAQABAAEAAQABAAEAAQABAAEAAQABABQAFAASwBLAEsASwBLAEsASwBLAEsASwBQAFAAUABQAFAAUABQAFAABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEACsAKwArACsAKwArACsAKwAeAB4AHgAeAFAAUABQAFAABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEACsAKwArAA0ADQANAA0ADQBLAEsASwBLAEsASwBLAEsASwBLACsAKwArAFAAUABQAEsASwBLAEsASwBLAEsASwBLAEsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAA0ADQBQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwBQAFAAUAAeAB4AHgAeAB4AHgAeAB4AKwArACsAKwArACsAKwArAAQABAAEAB4ABAAEAAQABAAEAAQABAAEAAQABAAEAAQABABQAFAAUABQAAQAUABQAFAAUABQAFAABABQAFAABAAEAAQAUAArACsAKwArACsABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEACsABAAEAAQABAAEAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AKwArAFAAUABQAFAAUABQACsAKwBQAFAAUABQAFAAUABQAFAAKwBQACsAUAArAFAAKwAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeACsAKwAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgArAB4AHgAeAB4AHgAeAB4AHgBQAB4AHgAeAFAAUABQACsAHgAeAB4AHgAeAB4AHgAeAB4AHgBQAFAAUABQACsAKwAeAB4AHgAeAB4AHgArAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AKwArAFAAUABQACsAHgAeAB4AHgAeAB4AHgAOAB4AKwANAA0ADQANAA0ADQANAAkADQANAA0ACAAEAAsABAAEAA0ACQANAA0ADAAdAB0AHgAXABcAFgAXABcAFwAWABcAHQAdAB4AHgAUABQAFAANAAEAAQAEAAQABAAEAAQACQAaABoAGgAaABoAGgAaABoAHgAXABcAHQAVABUAHgAeAB4AHgAeAB4AGAAWABEAFQAVABUAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4ADQAeAA0ADQANAA0AHgANAA0ADQAHAB4AHgAeAB4AKwAEAAQABAAEAAQABAAEAAQABAAEAFAAUAArACsATwBQAFAAUABQAFAAHgAeAB4AFgARAE8AUABPAE8ATwBPAFAAUABQAFAAUAAeAB4AHgAWABEAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArABsAGwAbABsAGwAbABsAGgAbABsAGwAbABsAGwAbABsAGwAbABsAGwAbABsAGgAbABsAGwAbABoAGwAbABoAGwAbABsAGwAbABsAGwAbABsAGwAbABsAGwAbABsAGwAbAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQAHgAeAFAAGgAeAB0AHgBQAB4AGgAeAB4AHgAeAB4AHgAeAB4AHgBPAB4AUAAbAB4AHgBQAFAAUABQAFAAHgAeAB4AHQAdAB4AUAAeAFAAHgBQAB4AUABPAFAAUAAeAB4AHgAeAB4AHgAeAFAAUABQAFAAUAAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAFAAHgBQAFAAUABQAE8ATwBQAFAAUABQAFAATwBQAFAATwBQAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAFAAUABQAFAATwBPAE8ATwBPAE8ATwBPAE8ATwBQAFAAUABQAFAAUABQAFAAUAAeAB4AUABQAFAAUABPAB4AHgArACsAKwArAB0AHQAdAB0AHQAdAB0AHQAdAB0AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB0AHgAdAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAdAB4AHQAdAB4AHgAeAB0AHQAeAB4AHQAeAB4AHgAdAB4AHQAbABsAHgAdAB4AHgAeAB4AHQAeAB4AHQAdAB0AHQAeAB4AHQAeAB0AHgAdAB0AHQAdAB0AHQAeAB0AHgAeAB4AHgAeAB0AHQAdAB0AHgAeAB4AHgAdAB0AHgAeAB4AHgAeAB4AHgAeAB4AHgAdAB4AHgAeAB0AHgAeAB4AHgAeAB0AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAdAB0AHgAeAB0AHQAdAB0AHgAeAB0AHQAeAB4AHQAdAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB0AHQAeAB4AHQAdAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHQAeAB4AHgAdAB4AHgAeAB4AHgAeAB4AHQAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB0AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AFAAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeABYAEQAWABEAHgAeAB4AHgAeAB4AHQAeAB4AHgAeAB4AHgAeACUAJQAeAB4AHgAeAB4AHgAeAB4AHgAWABEAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AJQAlACUAJQAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAFAAHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHgAeAB4AHgAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAeAB4AHQAdAB0AHQAeAB4AHgAeAB4AHgAeAB4AHgAeAB0AHQAeAB0AHQAdAB0AHQAdAB0AHgAeAB4AHgAeAB4AHgAeAB0AHQAeAB4AHQAdAB4AHgAeAB4AHQAdAB4AHgAeAB4AHQAdAB0AHgAeAB0AHgAeAB0AHQAdAB0AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAdAB0AHQAdAB4AHgAeAB4AHgAeAB4AHgAeAB0AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAlACUAJQAlAB4AHQAdAB4AHgAdAB4AHgAeAB4AHQAdAB4AHgAeAB4AJQAlAB0AHQAlAB4AJQAlACUAIAAlACUAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAlACUAJQAeAB4AHgAeAB0AHgAdAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAdAB0AHgAdAB0AHQAeAB0AJQAdAB0AHgAdAB0AHgAdAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeACUAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHQAdAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAlACUAJQAlACUAJQAlACUAJQAlACUAJQAdAB0AHQAdACUAHgAlACUAJQAdACUAJQAdAB0AHQAlACUAHQAdACUAHQAdACUAJQAlAB4AHQAeAB4AHgAeAB0AHQAlAB0AHQAdAB0AHQAdACUAJQAlACUAJQAdACUAJQAgACUAHQAdACUAJQAlACUAJQAlACUAJQAeAB4AHgAlACUAIAAgACAAIAAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB0AHgAeAB4AFwAXABcAFwAXABcAHgATABMAJQAeAB4AHgAWABEAFgARABYAEQAWABEAFgARABYAEQAWABEATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeABYAEQAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAWABEAFgARABYAEQAWABEAFgARAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AFgARABYAEQAWABEAFgARABYAEQAWABEAFgARABYAEQAWABEAFgARABYAEQAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAWABEAFgARAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AFgARAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAdAB0AHQAdAB0AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgArACsAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AKwAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AUABQAFAAUAAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAEAAQABAAeAB4AKwArACsAKwArABMADQANAA0AUAATAA0AUABQAFAAUABQAFAAUABQACsAKwArACsAKwArACsAUAANACsAKwArACsAKwArACsAKwArACsAKwArACsAKwAEAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQACsAUABQAFAAUABQAFAAUAArAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAFAAUABQACsAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXAA0ADQANAA0ADQANAA0ADQAeAA0AFgANAB4AHgAXABcAHgAeABcAFwAWABEAFgARABYAEQAWABEADQANAA0ADQATAFAADQANAB4ADQANAB4AHgAeAB4AHgAMAAwADQANAA0AHgANAA0AFgANAA0ADQANAA0ADQANAA0AHgANAB4ADQANAB4AHgAeACsAKwArACsAKwArACsAKwArACsAKwArACsAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACsAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAKwArACsAKwArACsAKwArACsAKwArACsAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwAlACUAJQAlACUAJQAlACUAJQAlACUAJQArACsAKwArAA0AEQARACUAJQBHAFcAVwAWABEAFgARABYAEQAWABEAFgARACUAJQAWABEAFgARABYAEQAWABEAFQAWABEAEQAlAFcAVwBXAFcAVwBXAFcAVwBXAAQABAAEAAQABAAEACUAVwBXAFcAVwA2ACUAJQBXAFcAVwBHAEcAJQAlACUAKwBRAFcAUQBXAFEAVwBRAFcAUQBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFEAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBRAFcAUQBXAFEAVwBXAFcAVwBXAFcAUQBXAFcAVwBXAFcAVwBRAFEAKwArAAQABAAVABUARwBHAFcAFQBRAFcAUQBXAFEAVwBRAFcAUQBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFEAVwBRAFcAUQBXAFcAVwBXAFcAVwBRAFcAVwBXAFcAVwBXAFEAUQBXAFcAVwBXABUAUQBHAEcAVwArACsAKwArACsAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAKwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAKwAlACUAVwBXAFcAVwAlACUAJQAlACUAJQAlACUAJQAlACsAKwArACsAKwArACsAKwArACsAKwArAFEAUQBRAFEAUQBRAFEAUQBRAFEAUQBRAFEAUQBRAFEAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQArAFcAVwBXAFcAVwBXAFcAVwBXAFcAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQBPAE8ATwBPAE8ATwBPAE8AJQBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXACUAJQAlAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAEcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAKwArACsAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAADQATAA0AUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABLAEsASwBLAEsASwBLAEsASwBLAFAAUAArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAFAABAAEAAQABAAeAAQABAAEAAQABAAEAAQABAAEAAQAHgBQAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AUABQAAQABABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAQABAAeAA0ADQANAA0ADQArACsAKwArACsAKwArACsAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAFAAUABQAFAAUABQAFAAUABQAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AUAAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgBQAB4AHgAeAB4AHgAeAFAAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgArACsAHgAeAB4AHgAeAB4AHgAeAB4AKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwAeAB4AUABQAFAAUABQAFAAUABQAFAAUABQAAQAUABQAFAABABQAFAAUABQAAQAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAQABAAEAAQABAAeAB4AHgAeAAQAKwArACsAUABQAFAAUABQAFAAHgAeABoAHgArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAADgAOABMAEwArACsAKwArACsAKwArACsABAAEAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAQABAAEAAQABAAEACsAKwArACsAKwArACsAKwANAA0ASwBLAEsASwBLAEsASwBLAEsASwArACsAKwArACsAKwAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABABQAFAAUABQAFAAUAAeAB4AHgBQAA4AUABQAAQAUABQAFAAUABQAFAABAAEAAQABAAEAAQABAAEAA0ADQBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQAKwArACsAKwArACsAKwArACsAKwArAB4AWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYACsAKwArAAQAHgAeAB4AHgAeAB4ADQANAA0AHgAeAB4AHgArAFAASwBLAEsASwBLAEsASwBLAEsASwArACsAKwArAB4AHgBcAFwAXABcAFwAKgBcAFwAXABcAFwAXABcAFwAXABcAEsASwBLAEsASwBLAEsASwBLAEsAXABcAFwAXABcACsAUABQAFAAUABQAFAAUABQAFAABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEACsAKwArACsAKwArACsAKwArAFAAUABQAAQAUABQAFAAUABQAFAAUABQAAQABAArACsASwBLAEsASwBLAEsASwBLAEsASwArACsAHgANAA0ADQBcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAKgAqACoAXAAqACoAKgBcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXAAqAFwAKgAqACoAXABcACoAKgBcAFwAXABcAFwAKgAqAFwAKgBcACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAFwAXABcACoAKgBQAFAAUABQAFAAUABQAFAAUABQAFAABAAEAAQABAAEAA0ADQBQAFAAUAAEAAQAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUAArACsAUABQAFAAUABQAFAAKwArAFAAUABQAFAAUABQACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAFAAUABQACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAHgAeACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAAEAAQADQAEAAQAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsAVABVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBUAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVACsAKwArACsAKwArACsAKwArACsAKwArAFkAWQBZAFkAWQBZAFkAWQBZAFkAWQBZAFkAWQBZAFkAWQBZAFkAKwArACsAKwBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAKwArACsAKwAGAAYABgAGAAYABgAGAAYABgAGAAYABgAGAAYABgAGAAYABgAGAAYABgAGAAYABgAGAAYABgAGAAYABgAGAAYAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXACUAJQBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAJQAlACUAJQAlACUAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAKwArACsAKwArAFYABABWAFYAVgBWAFYAVgBWAFYAVgBWAB4AVgBWAFYAVgBWAFYAVgBWAFYAVgBWAFYAVgArAFYAVgBWAFYAVgArAFYAKwBWAFYAKwBWAFYAKwBWAFYAVgBWAFYAVgBWAFYAVgBWAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAEQAWAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUAAaAB4AKwArAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQAGAARABEAGAAYABMAEwAWABEAFAArACsAKwArACsAKwAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEACUAJQAlACUAJQAWABEAFgARABYAEQAWABEAFgARABYAEQAlACUAFgARACUAJQAlACUAJQAlACUAEQAlABEAKwAVABUAEwATACUAFgARABYAEQAWABEAJQAlACUAJQAlACUAJQAlACsAJQAbABoAJQArACsAKwArAFAAUABQAFAAUAArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArAAcAKwATACUAJQAbABoAJQAlABYAEQAlACUAEQAlABEAJQBXAFcAVwBXAFcAVwBXAFcAVwBXABUAFQAlACUAJQATACUAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXABYAJQARACUAJQAlAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwAWACUAEQAlABYAEQARABYAEQARABUAVwBRAFEAUQBRAFEAUQBRAFEAUQBRAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAEcARwArACsAVwBXAFcAVwBXAFcAKwArAFcAVwBXAFcAVwBXACsAKwBXAFcAVwBXAFcAVwArACsAVwBXAFcAKwArACsAGgAbACUAJQAlABsAGwArAB4AHgAeAB4AHgAeAB4AKwArACsAKwArACsAKwArACsAKwAEAAQABAAQAB0AKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsADQANAA0AKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArAB4AHgAeAB4AHgAeAB4AHgAeAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgBQAFAAHgAeAB4AKwAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAAQAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwAEAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAEAAQABAAEACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArAA0AUABQAFAAUAArACsAKwArAFAAUABQAFAAUABQAFAAUAANAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAKwArACsAKwArACsAKwAeACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAUABQAFAAUABQAFAAKwArAFAAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArAFAAUAArACsAKwBQACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwANAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAeAB4AUABQAFAAUABQAFAAUAArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArAFAAUAArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArAA0AUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAKwAeAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAUABQAFAAUABQAAQABAAEACsABAAEACsAKwArACsAKwAEAAQABAAEAFAAUABQAFAAKwBQAFAAUAArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArAAQABAAEACsAKwArACsABABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArAA0ADQANAA0ADQANAA0ADQAeACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAeAFAAUABQAFAAUABQAFAAUAAeAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAQABAArACsAKwArAFAAUABQAFAAUAANAA0ADQANAA0ADQAUACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArACsADQANAA0ADQANAA0ADQBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArAB4AHgAeAB4AKwArACsAKwArACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAKwArACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArAFAAUABQAFAAUABQAAQABAAEAAQAKwArACsAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUAArAAQABAANACsAKwBQAFAAKwArACsAKwArACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAAQABAAEAAQABAAEAAQABAAEAAQABABQAFAAUABQAB4AHgAeAB4AHgArACsAKwArACsAKwAEAAQABAAEAAQABAAEAA0ADQAeAB4AHgAeAB4AKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsABABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAQABAAEAAQABAAEAAQABAAEAAQABAAeAB4AHgANAA0ADQANACsAKwArACsAKwArACsAKwArACsAKwAeACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArACsAKwArACsAKwBLAEsASwBLAEsASwBLAEsASwBLACsAKwArACsAKwArAFAAUABQAFAAUABQAFAABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEACsASwBLAEsASwBLAEsASwBLAEsASwANAA0ADQANAFAABAAEAFAAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAeAA4AUAArACsAKwArACsAKwArACsAKwAEAFAAUABQAFAADQANAB4ADQAEAAQABAAEAB4ABAAEAEsASwBLAEsASwBLAEsASwBLAEsAUAAOAFAADQANAA0AKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAAEAAQABAAEAAQABAANAA0AHgANAA0AHgAEACsAUABQAFAAUABQAFAAUAArAFAAKwBQAFAAUABQACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAFAAUABQAFAAUABQAA0AKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAAEAAQABAAEAAQAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsABAAEAAQABAArAFAAUABQAFAAUABQAFAAUAArACsAUABQACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAFAAUABQACsAUABQACsAUABQAFAAUABQACsABAAEAFAABAAEAAQABAAEAAQABAArACsABAAEACsAKwAEAAQABAArACsAUAArACsAKwArACsAKwAEACsAKwArACsAKwBQAFAAUABQAFAABAAEACsAKwAEAAQABAAEAAQABAAEACsAKwArAAQABAAEAAQABAArACsAKwArACsAKwArACsAKwArACsABAAEAAQABAAEAAQABABQAFAAUABQAA0ADQANAA0AHgBLAEsASwBLAEsASwBLAEsASwBLAA0ADQArAB4ABABQAFAAUAArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwAEAAQABAAEAFAAUAAeAFAAKwArACsAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAEAAQABAAEAAQABAArACsABAAEAAQABAAEAAQABAAEAAQADgANAA0AEwATAB4AHgAeAA0ADQANAA0ADQANAA0ADQANAA0ADQANAA0ADQANAFAAUABQAFAABAAEACsAKwAEAA0ADQAeAFAAKwArACsAKwArACsAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAFAAKwArACsAKwArACsAKwBLAEsASwBLAEsASwBLAEsASwBLACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAKwArACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACsAKwArACsASwBLAEsASwBLAEsASwBLAEsASwBcAFwADQANAA0AKgBQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAeACsAKwArACsASwBLAEsASwBLAEsASwBLAEsASwBQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAKwArAFAAKwArAFAAUABQAFAAUABQAFAAUAArAFAAUAArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAEAAQABAAEAAQAKwAEAAQAKwArAAQABAAEAAQAUAAEAFAABAAEAA0ADQANACsAKwArACsAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAEAAQABAAEAAQABAArACsABAAEAAQABAAEAAQABABQAA4AUAAEACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAFAABAAEAAQABAAEAAQABAAEAAQABABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAAEAFAABAAEAAQABAAOAB4ADQANAA0ADQAOAB4ABAArACsAKwArACsAKwArACsAUAAEAAQABAAEAAQABAAEAAQABAAEAAQAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAA0ADQANAFAADgAOAA4ADQANACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUAArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAEAAQABAAEAAQABAAEACsABAAEAAQABAAEAAQABAAEAFAADQANAA0ADQANACsAKwArACsAKwArACsAKwArACsASwBLAEsASwBLAEsASwBLAEsASwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwAOABMAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAArAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQACsAUABQACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAArACsAKwAEACsABAAEACsABAAEAAQABAAEAAQABABQAAQAKwArACsAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsAUABQAFAAUABQAFAAKwBQAFAAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQAKwAEAAQAKwAEAAQABAAEAAQAUAArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAEAAQABAAeAB4AKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwBQACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAB4AHgAeAB4AHgAeAB4AHgAaABoAGgAaAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgArACsAKwArACsAKwArACsAKwArACsAKwArAA0AUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsADQANAA0ADQANACsAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAASABIAEgAQwBDAEMAUABQAFAAUABDAFAAUABQAEgAQwBIAEMAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAASABDAEMAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwAJAAkACQAJAAkACQAJABYAEQArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABIAEMAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwANAA0AKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArAAQABAAEAAQABAANACsAKwArACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAAEAA0ADQANAB4AHgAeAB4AHgAeAFAAUABQAFAADQAeACsAKwArACsAKwArACsAKwArACsASwBLAEsASwBLAEsASwBLAEsASwArAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAANAA0AHgAeACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAKwArACsAKwAEAFAABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQAKwArACsAKwArACsAKwAEAAQABAAEAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAARwBHABUARwAJACsAKwArACsAKwArACsAKwArACsAKwAEAAQAKwArACsAKwArACsAKwArACsAKwArACsAKwArAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXACsAKwArACsAKwArACsAKwBXAFcAVwBXAFcAVwBXAFcAVwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAUQBRAFEAKwArACsAKwArACsAKwArACsAKwArACsAKwBRAFEAUQBRACsAKwArACsAKwArACsAKwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUAArACsAHgAEAAQADQAEAAQABAAEACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgArACsAKwArACsAKwArACsAKwArAB4AHgAeAB4AHgAeAB4AKwArAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAAQABAAEAAQABAAeAB4AHgAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAB4AHgAEAAQABAAEAAQABAAEAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4ABAAEAAQABAAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4ABAAEAAQAHgArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAKwArACsAKwArACsAKwArAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgArACsAKwArACsAKwArACsAKwAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgArAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AKwBQAFAAKwArAFAAKwArAFAAUAArACsAUABQAFAAUAArAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeACsAUAArAFAAUABQAFAAUABQAFAAKwAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AKwBQAFAAUABQACsAKwBQAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAFAAUABQACsAHgAeAFAAUABQAFAAUAArAFAAKwArACsAUABQAFAAUABQAFAAUAArAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAHgBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgBQAFAAUABQAFAAUABQAFAAUABQAFAAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAB4AHgAeAB4AHgAeAB4AHgAeACsAKwBLAEsASwBLAEsASwBLAEsASwBLAEsASwBLAEsASwBLAEsASwBLAEsASwBLAEsASwBLAEsASwBLAEsASwBLAEsASwBLAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAeAB4AHgAeAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAeAB4AHgAeAB4AHgAeAB4ABAAeAB4AHgAeAB4AHgAeAB4AHgAeAAQAHgAeAA0ADQANAA0AHgArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwAEAAQABAAEAAQAKwAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAAQABAAEAAQABAAEAAQAKwAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQAKwArAAQABAAEAAQABAAEAAQAKwAEAAQAKwAEAAQABAAEAAQAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwAEAAQABAAEAAQABAAEAFAAUABQAFAAUABQAFAAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwBQAB4AKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArABsAUABQAFAAUABQACsAKwBQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAAEACsAKwArACsAKwArACsAKwArAB4AHgAeAB4ABAAEAAQABAAEAAQABABQACsAKwArACsASwBLAEsASwBLAEsASwBLAEsASwArACsAKwArABYAFgArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAGgBQAFAAUAAaAFAAUABQAFAAKwArACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAeAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwBQAFAAUABQACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAKwBQACsAKwBQACsAUABQAFAAUABQAFAAUABQAFAAUAArAFAAUABQAFAAKwBQACsAUAArACsAKwArACsAKwBQACsAKwArACsAUAArAFAAKwBQACsAUABQAFAAKwBQAFAAKwBQACsAKwBQACsAUAArAFAAKwBQACsAUAArAFAAUAArAFAAKwArAFAAUABQAFAAKwBQAFAAUABQAFAAUABQACsAUABQAFAAUAArAFAAUABQAFAAKwBQACsAUABQAFAAUABQAFAAUABQAFAAUAArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAUABQAFAAKwBQAFAAUABQAFAAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwAeAB4AKwArACsAKwArACsAKwArACsAKwArACsAKwArAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8AJQAlACUAHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHgAeAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB4AHgAeACUAJQAlAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQApACkAKQApACkAKQApACkAKQApACkAKQApACkAKQApACkAKQApACkAKQApACkAKQApACkAJQAlACUAJQAlACAAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAeAB4AJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlAB4AHgAlACUAJQAlACUAHgAlACUAJQAlACUAIAAgACAAJQAlACAAJQAlACAAIAAgACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACEAIQAhACEAIQAlACUAIAAgACUAJQAgACAAIAAgACAAIAAgACAAIAAgACAAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAJQAlACUAIAAlACUAJQAlACAAIAAgACUAIAAgACAAJQAlACUAJQAlACUAJQAgACUAIAAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAHgAlAB4AJQAeACUAJQAlACUAJQAgACUAJQAlACUAHgAlAB4AHgAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlAB4AHgAeAB4AHgAeAB4AJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAeAB4AHgAeAB4AHgAeAB4AHgAeACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACAAIAAlACUAJQAlACAAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACAAJQAlACUAJQAgACAAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAHgAeAB4AHgAeAB4AHgAeACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAeAB4AHgAeAB4AHgAlACUAJQAlACUAJQAlACAAIAAgACUAJQAlACAAIAAgACAAIAAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeABcAFwAXABUAFQAVAB4AHgAeAB4AJQAlACUAIAAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACAAIAAgACUAJQAlACUAJQAlACUAJQAlACAAJQAlACUAJQAlACUAJQAlACUAJQAlACAAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AJQAlACUAJQAlACUAJQAlACUAJQAlACUAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AJQAlACUAJQAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeACUAJQAlACUAJQAlACUAJQAeAB4AHgAeAB4AHgAeAB4AHgAeACUAJQAlACUAJQAlAB4AHgAeAB4AHgAeAB4AHgAlACUAJQAlACUAJQAlACUAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAgACUAJQAgACUAJQAlACUAJQAlACUAJQAgACAAIAAgACAAIAAgACAAJQAlACUAJQAlACUAIAAlACUAJQAlACUAJQAlACUAJQAgACAAIAAgACAAIAAgACAAIAAgACUAJQAgACAAIAAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAgACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACAAIAAlACAAIAAlACAAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAgACAAIAAlACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAJQAlAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AKwAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAKwArAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXACUAJQBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwAlACUAJQAlACUAJQAlACUAJQAlACUAVwBXACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAKwAEACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAA==";
var ot = 50;
var Kn = 1;
var nB = 2;
var sB = 3;
var mn = 4;
var Ln = 5;
var Qt = 7;
var aB = 8;
var gt = 9;
var FA = 10;
var Dr = 11;
var wt = 12;
var br = 13;
var Dn = 14;
var $A = 15;
var xr = 16;
var Fe = 17;
var WA = 18;
var bn = 19;
var ct = 20;
var Tr = 21;
var ZA = 22;
var Qr = 23;
var SA = 24;
var j = 25;
var Ae = 26;
var ee = 27;
var OA = 28;
var xn = 29;
var LA = 30;
var Tn = 31;
var he = 32;
var de = 33;
var Sr = 34;
var Or = 35;
var Mr = 36;
var Qe = 37;
var Gr = 38;
var Ge = 39;
var Re = 40;
var gr = 41;
var iB = 42;
var Sn = 43;
var On = [9001, 65288];
var oB = "!";
var I = "×";
var Ee = "÷";
var Rr = pn(yn);
var QA = [LA, Mr];
var Vr = [Kn, nB, sB, Ln];
var QB = [FA, aB];
var Ct = [ee, Ae];
var Mn = Vr.concat(QB);
var ut = [Gr, Ge, Re, Sr, Or];
var Gn = [$A, br];
var Rn = function(e, A) {
  A === void 0 && (A = "strict");
  var t = [], r = [], B = [];
  return e.forEach(function(n, s) {
    var i = Rr.get(n);
    if (i > ot ? (B.push(true), i -= ot) : B.push(false), ["normal", "auto", "loose"].indexOf(A) !== -1 && [8208, 8211, 12316, 12448].indexOf(n) !== -1) return r.push(s), t.push(xr);
    if (i === mn || i === Dr) {
      if (s === 0) return r.push(s), t.push(LA);
      var a = t[s - 1];
      return Mn.indexOf(a) === -1 ? (r.push(r[s - 1]), t.push(a)) : (r.push(s), t.push(LA));
    }
    if (r.push(s), i === Tn) return t.push(A === "strict" ? Tr : Qe);
    if (i === iB || i === xn) return t.push(LA);
    if (i === Sn) return n >= 131072 && n <= 196605 || n >= 196608 && n <= 262141 ? t.push(Qe) : t.push(LA);
    t.push(i);
  }), [r, t, B];
};
var wr = function(e, A, t, r) {
  var B = r[t];
  if (Array.isArray(e) ? e.indexOf(B) !== -1 : e === B) for (var n = t; n <= r.length; ) {
    n++;
    var s = r[n];
    if (s === A) return true;
    if (s !== FA) break;
  }
  if (B === FA) for (var n = t; n > 0; ) {
    n--;
    var i = r[n];
    if (Array.isArray(e) ? e.indexOf(i) !== -1 : e === i) for (var a = t; a <= r.length; ) {
      a++;
      var s = r[a];
      if (s === A) return true;
      if (s !== FA) break;
    }
    if (i !== FA) break;
  }
  return false;
};
var lt = function(e, A) {
  for (var t = e; t >= 0; ) {
    var r = A[t];
    if (r === FA) t--;
    else return r;
  }
  return 0;
};
var Vn = function(e, A, t, r, B) {
  if (t[r] === 0) return I;
  var n = r - 1;
  if (Array.isArray(B) && B[n] === true) return I;
  var s = n - 1, i = n + 1, a = A[n], o = s >= 0 ? A[s] : 0, Q = A[i];
  if (a === nB && Q === sB) return I;
  if (Vr.indexOf(a) !== -1) return oB;
  if (Vr.indexOf(Q) !== -1 || QB.indexOf(Q) !== -1) return I;
  if (lt(n, A) === aB) return Ee;
  if (Rr.get(e[n]) === Dr || (a === he || a === de) && Rr.get(e[i]) === Dr || a === Qt || Q === Qt || a === gt || [FA, br, $A].indexOf(a) === -1 && Q === gt || [Fe, WA, bn, SA, OA].indexOf(Q) !== -1 || lt(n, A) === ZA || wr(Qr, ZA, n, A) || wr([Fe, WA], Tr, n, A) || wr(wt, wt, n, A)) return I;
  if (a === FA) return Ee;
  if (a === Qr || Q === Qr) return I;
  if (Q === xr || a === xr) return Ee;
  if ([br, $A, Tr].indexOf(Q) !== -1 || a === Dn || o === Mr && Gn.indexOf(a) !== -1 || a === OA && Q === Mr || Q === ct || QA.indexOf(Q) !== -1 && a === j || QA.indexOf(a) !== -1 && Q === j || a === ee && [Qe, he, de].indexOf(Q) !== -1 || [Qe, he, de].indexOf(a) !== -1 && Q === Ae || QA.indexOf(a) !== -1 && Ct.indexOf(Q) !== -1 || Ct.indexOf(a) !== -1 && QA.indexOf(Q) !== -1 || // (PR | PO) × ( OP | HY )? NU
  [ee, Ae].indexOf(a) !== -1 && (Q === j || [ZA, $A].indexOf(Q) !== -1 && A[i + 1] === j) || // ( OP | HY ) × NU
  [ZA, $A].indexOf(a) !== -1 && Q === j || // NU ×	(NU | SY | IS)
  a === j && [j, OA, SA].indexOf(Q) !== -1) return I;
  if ([j, OA, SA, Fe, WA].indexOf(Q) !== -1) for (var g = n; g >= 0; ) {
    var w = A[g];
    if (w === j) return I;
    if ([OA, SA].indexOf(w) !== -1) g--;
    else break;
  }
  if ([ee, Ae].indexOf(Q) !== -1) for (var g = [Fe, WA].indexOf(a) !== -1 ? s : n; g >= 0; ) {
    var w = A[g];
    if (w === j) return I;
    if ([OA, SA].indexOf(w) !== -1) g--;
    else break;
  }
  if (Gr === a && [Gr, Ge, Sr, Or].indexOf(Q) !== -1 || [Ge, Sr].indexOf(a) !== -1 && [Ge, Re].indexOf(Q) !== -1 || [Re, Or].indexOf(a) !== -1 && Q === Re || ut.indexOf(a) !== -1 && [ct, Ae].indexOf(Q) !== -1 || ut.indexOf(Q) !== -1 && a === ee || QA.indexOf(a) !== -1 && QA.indexOf(Q) !== -1 || a === SA && QA.indexOf(Q) !== -1 || QA.concat(j).indexOf(a) !== -1 && Q === ZA && On.indexOf(e[i]) === -1 || QA.concat(j).indexOf(Q) !== -1 && a === WA) return I;
  if (a === gr && Q === gr) {
    for (var f = t[n], c = 1; f > 0 && (f--, A[f] === gr); ) c++;
    if (c % 2 !== 0) return I;
  }
  return a === he && Q === de ? I : Ee;
};
var Nn = function(e, A) {
  A || (A = {
    lineBreak: "normal",
    wordBreak: "normal"
  });
  var t = Rn(e, A.lineBreak), r = t[0], B = t[1], n = t[2];
  (A.wordBreak === "break-all" || A.wordBreak === "break-word") && (B = B.map(function(i) {
    return [j, LA, iB].indexOf(i) !== -1 ? Qe : i;
  }));
  var s = A.wordBreak === "keep-all" ? n.map(function(i, a) {
    return i && e[a] >= 19968 && e[a] <= 40959;
  }) : void 0;
  return [r, B, s];
};
var Xn = (
  /** @class */
  function() {
    function e(A, t, r, B) {
      this.codePoints = A, this.required = t === oB, this.start = r, this.end = B;
    }
    return e.prototype.slice = function() {
      return S.apply(void 0, this.codePoints.slice(this.start, this.end));
    }, e;
  }()
);
var _n = function(e, A) {
  var t = $e(e), r = Nn(t, A), B = r[0], n = r[1], s = r[2], i = t.length, a = 0, o = 0;
  return {
    next: function() {
      if (o >= i) return {
        done: true,
        value: null
      };
      for (var Q = I; o < i && (Q = Vn(t, n, B, ++o, s)) === I; ) ;
      if (Q !== I || o === i) {
        var g = new Xn(t, Q, a, o);
        return a = o, {
          value: g,
          done: false
        };
      }
      return {
        done: true,
        value: null
      };
    }
  };
};
var Jn = 1;
var Pn = 2;
var ce = 4;
var ft = 8;
var Xe = 10;
var Ut = 47;
var ne = 92;
var kn = 9;
var Yn = 32;
var He = 34;
var qA = 61;
var Wn = 35;
var Zn = 36;
var qn = 37;
var pe = 39;
var Ie = 40;
var jA = 41;
var jn = 95;
var Z = 45;
var zn = 33;
var $n = 60;
var As = 62;
var es = 64;
var rs = 91;
var ts = 93;
var Bs = 61;
var ns = 123;
var ve = 63;
var ss = 125;
var Ft = 124;
var as = 126;
var is = 128;
var ht = 65533;
var cr = 42;
var DA = 43;
var os = 44;
var Qs = 58;
var gs = 59;
var ge = 46;
var ws = 0;
var cs = 8;
var Cs = 11;
var us = 14;
var ls = 31;
var fs = 127;
var nA = -1;
var gB = 48;
var wB = 97;
var cB = 101;
var Us = 102;
var Fs = 117;
var hs = 122;
var CB = 65;
var uB = 69;
var lB = 70;
var ds = 85;
var Es = 90;
var J = function(e) {
  return e >= gB && e <= 57;
};
var Hs = function(e) {
  return e >= 55296 && e <= 57343;
};
var MA = function(e) {
  return J(e) || e >= CB && e <= lB || e >= wB && e <= Us;
};
var ps = function(e) {
  return e >= wB && e <= hs;
};
var Is = function(e) {
  return e >= CB && e <= Es;
};
var vs = function(e) {
  return ps(e) || Is(e);
};
var ys = function(e) {
  return e >= is;
};
var ye = function(e) {
  return e === Xe || e === kn || e === Yn;
};
var _e = function(e) {
  return vs(e) || ys(e) || e === jn;
};
var dt = function(e) {
  return _e(e) || J(e) || e === Z;
};
var Ks = function(e) {
  return e >= ws && e <= cs || e === Cs || e >= us && e <= ls || e === fs;
};
var UA = function(e, A) {
  return e !== ne ? false : A !== Xe;
};
var Ke = function(e, A, t) {
  return e === Z ? _e(A) || UA(A, t) : _e(e) ? true : !!(e === ne && UA(e, A));
};
var Cr = function(e, A, t) {
  return e === DA || e === Z ? J(A) ? true : A === ge && J(t) : J(e === ge ? A : e);
};
var ms = function(e) {
  var A = 0, t = 1;
  (e[A] === DA || e[A] === Z) && (e[A] === Z && (t = -1), A++);
  for (var r = []; J(e[A]); ) r.push(e[A++]);
  var B = r.length ? parseInt(S.apply(void 0, r), 10) : 0;
  e[A] === ge && A++;
  for (var n = []; J(e[A]); ) n.push(e[A++]);
  var s = n.length, i = s ? parseInt(S.apply(void 0, n), 10) : 0;
  (e[A] === uB || e[A] === cB) && A++;
  var a = 1;
  (e[A] === DA || e[A] === Z) && (e[A] === Z && (a = -1), A++);
  for (var o = []; J(e[A]); ) o.push(e[A++]);
  var Q = o.length ? parseInt(S.apply(void 0, o), 10) : 0;
  return t * (B + i * Math.pow(10, -s)) * Math.pow(10, a * Q);
};
var Ls = {
  type: 2
  /* LEFT_PARENTHESIS_TOKEN */
};
var Ds = {
  type: 3
  /* RIGHT_PARENTHESIS_TOKEN */
};
var bs = {
  type: 4
  /* COMMA_TOKEN */
};
var xs = {
  type: 13
  /* SUFFIX_MATCH_TOKEN */
};
var Ts = {
  type: 8
  /* PREFIX_MATCH_TOKEN */
};
var Ss = {
  type: 21
  /* COLUMN_TOKEN */
};
var Os = {
  type: 9
  /* DASH_MATCH_TOKEN */
};
var Ms = {
  type: 10
  /* INCLUDE_MATCH_TOKEN */
};
var Gs = {
  type: 11
  /* LEFT_CURLY_BRACKET_TOKEN */
};
var Rs = {
  type: 12
  /* RIGHT_CURLY_BRACKET_TOKEN */
};
var Vs = {
  type: 14
  /* SUBSTRING_MATCH_TOKEN */
};
var me = {
  type: 23
  /* BAD_URL_TOKEN */
};
var Ns = {
  type: 1
  /* BAD_STRING_TOKEN */
};
var Xs = {
  type: 25
  /* CDO_TOKEN */
};
var _s = {
  type: 24
  /* CDC_TOKEN */
};
var Js = {
  type: 26
  /* COLON_TOKEN */
};
var Ps = {
  type: 27
  /* SEMICOLON_TOKEN */
};
var ks = {
  type: 28
  /* LEFT_SQUARE_BRACKET_TOKEN */
};
var Ys = {
  type: 29
  /* RIGHT_SQUARE_BRACKET_TOKEN */
};
var Ws = {
  type: 31
  /* WHITESPACE_TOKEN */
};
var Nr = {
  type: 32
  /* EOF_TOKEN */
};
var fB = (
  /** @class */
  function() {
    function e() {
      this._value = [];
    }
    return e.prototype.write = function(A) {
      this._value = this._value.concat($e(A));
    }, e.prototype.read = function() {
      for (var A = [], t = this.consumeToken(); t !== Nr; ) A.push(t), t = this.consumeToken();
      return A;
    }, e.prototype.consumeToken = function() {
      var A = this.consumeCodePoint();
      switch (A) {
        case He:
          return this.consumeStringToken(He);
        case Wn:
          var t = this.peekCodePoint(0), r = this.peekCodePoint(1), B = this.peekCodePoint(2);
          if (dt(t) || UA(r, B)) {
            var n = Ke(t, r, B) ? Pn : Jn, s = this.consumeName();
            return {
              type: 5,
              value: s,
              flags: n
            };
          }
          break;
        case Zn:
          if (this.peekCodePoint(0) === qA) return this.consumeCodePoint(), xs;
          break;
        case pe:
          return this.consumeStringToken(pe);
        case Ie:
          return Ls;
        case jA:
          return Ds;
        case cr:
          if (this.peekCodePoint(0) === qA) return this.consumeCodePoint(), Vs;
          break;
        case DA:
          if (Cr(A, this.peekCodePoint(0), this.peekCodePoint(1))) return this.reconsumeCodePoint(A), this.consumeNumericToken();
          break;
        case os:
          return bs;
        case Z:
          var i = A, a = this.peekCodePoint(0), o = this.peekCodePoint(1);
          if (Cr(i, a, o)) return this.reconsumeCodePoint(A), this.consumeNumericToken();
          if (Ke(i, a, o)) return this.reconsumeCodePoint(A), this.consumeIdentLikeToken();
          if (a === Z && o === As) return this.consumeCodePoint(), this.consumeCodePoint(), _s;
          break;
        case ge:
          if (Cr(A, this.peekCodePoint(0), this.peekCodePoint(1))) return this.reconsumeCodePoint(A), this.consumeNumericToken();
          break;
        case Ut:
          if (this.peekCodePoint(0) === cr) for (this.consumeCodePoint(); ; ) {
            var Q = this.consumeCodePoint();
            if (Q === cr && (Q = this.consumeCodePoint(), Q === Ut)) return this.consumeToken();
            if (Q === nA) return this.consumeToken();
          }
          break;
        case Qs:
          return Js;
        case gs:
          return Ps;
        case $n:
          if (this.peekCodePoint(0) === zn && this.peekCodePoint(1) === Z && this.peekCodePoint(2) === Z) return this.consumeCodePoint(), this.consumeCodePoint(), Xs;
          break;
        case es:
          var g = this.peekCodePoint(0), w = this.peekCodePoint(1), f = this.peekCodePoint(2);
          if (Ke(g, w, f)) {
            var s = this.consumeName();
            return {
              type: 7,
              value: s
            };
          }
          break;
        case rs:
          return ks;
        case ne:
          if (UA(A, this.peekCodePoint(0))) return this.reconsumeCodePoint(A), this.consumeIdentLikeToken();
          break;
        case ts:
          return Ys;
        case Bs:
          if (this.peekCodePoint(0) === qA) return this.consumeCodePoint(), Ts;
          break;
        case ns:
          return Gs;
        case ss:
          return Rs;
        case Fs:
        case ds:
          var c = this.peekCodePoint(0), C = this.peekCodePoint(1);
          return c === DA && (MA(C) || C === ve) && (this.consumeCodePoint(), this.consumeUnicodeRangeToken()), this.reconsumeCodePoint(A), this.consumeIdentLikeToken();
        case Ft:
          if (this.peekCodePoint(0) === qA) return this.consumeCodePoint(), Os;
          if (this.peekCodePoint(0) === Ft) return this.consumeCodePoint(), Ss;
          break;
        case as:
          if (this.peekCodePoint(0) === qA) return this.consumeCodePoint(), Ms;
          break;
        case nA:
          return Nr;
      }
      return ye(A) ? (this.consumeWhiteSpace(), Ws) : J(A) ? (this.reconsumeCodePoint(A), this.consumeNumericToken()) : _e(A) ? (this.reconsumeCodePoint(A), this.consumeIdentLikeToken()) : {
        type: 6,
        value: S(A)
      };
    }, e.prototype.consumeCodePoint = function() {
      var A = this._value.shift();
      return typeof A > "u" ? -1 : A;
    }, e.prototype.reconsumeCodePoint = function(A) {
      this._value.unshift(A);
    }, e.prototype.peekCodePoint = function(A) {
      return A >= this._value.length ? -1 : this._value[A];
    }, e.prototype.consumeUnicodeRangeToken = function() {
      for (var A = [], t = this.consumeCodePoint(); MA(t) && A.length < 6; ) A.push(t), t = this.consumeCodePoint();
      for (var r = false; t === ve && A.length < 6; ) A.push(t), t = this.consumeCodePoint(), r = true;
      if (r) {
        var B = parseInt(S.apply(void 0, A.map(function(a) {
          return a === ve ? gB : a;
        })), 16), n = parseInt(S.apply(void 0, A.map(function(a) {
          return a === ve ? lB : a;
        })), 16);
        return {
          type: 30,
          start: B,
          end: n
        };
      }
      var s = parseInt(S.apply(void 0, A), 16);
      if (this.peekCodePoint(0) === Z && MA(this.peekCodePoint(1))) {
        this.consumeCodePoint(), t = this.consumeCodePoint();
        for (var i = []; MA(t) && i.length < 6; ) i.push(t), t = this.consumeCodePoint();
        var n = parseInt(S.apply(void 0, i), 16);
        return {
          type: 30,
          start: s,
          end: n
        };
      } else return {
        type: 30,
        start: s,
        end: s
      };
    }, e.prototype.consumeIdentLikeToken = function() {
      var A = this.consumeName();
      return A.toLowerCase() === "url" && this.peekCodePoint(0) === Ie ? (this.consumeCodePoint(), this.consumeUrlToken()) : this.peekCodePoint(0) === Ie ? (this.consumeCodePoint(), {
        type: 19,
        value: A
      }) : {
        type: 20,
        value: A
      };
    }, e.prototype.consumeUrlToken = function() {
      var A = [];
      if (this.consumeWhiteSpace(), this.peekCodePoint(0) === nA) return {
        type: 22,
        value: ""
      };
      var t = this.peekCodePoint(0);
      if (t === pe || t === He) {
        var r = this.consumeStringToken(this.consumeCodePoint());
        return r.type === 0 && (this.consumeWhiteSpace(), this.peekCodePoint(0) === nA || this.peekCodePoint(0) === jA) ? (this.consumeCodePoint(), {
          type: 22,
          value: r.value
        }) : (this.consumeBadUrlRemnants(), me);
      }
      for (; ; ) {
        var B = this.consumeCodePoint();
        if (B === nA || B === jA) return {
          type: 22,
          value: S.apply(void 0, A)
        };
        if (ye(B)) return this.consumeWhiteSpace(), this.peekCodePoint(0) === nA || this.peekCodePoint(0) === jA ? (this.consumeCodePoint(), {
          type: 22,
          value: S.apply(void 0, A)
        }) : (this.consumeBadUrlRemnants(), me);
        if (B === He || B === pe || B === Ie || Ks(B)) return this.consumeBadUrlRemnants(), me;
        if (B === ne) {
          if (UA(B, this.peekCodePoint(0))) A.push(this.consumeEscapedCodePoint());
          else return this.consumeBadUrlRemnants(), me;
        } else A.push(B);
      }
    }, e.prototype.consumeWhiteSpace = function() {
      for (; ye(this.peekCodePoint(0)); ) this.consumeCodePoint();
    }, e.prototype.consumeBadUrlRemnants = function() {
      for (; ; ) {
        var A = this.consumeCodePoint();
        if (A === jA || A === nA) return;
        UA(A, this.peekCodePoint(0)) && this.consumeEscapedCodePoint();
      }
    }, e.prototype.consumeStringSlice = function(A) {
      for (var t = 5e4, r = ""; A > 0; ) {
        var B = Math.min(t, A);
        r += S.apply(void 0, this._value.splice(0, B)), A -= B;
      }
      return this._value.shift(), r;
    }, e.prototype.consumeStringToken = function(A) {
      var t = "", r = 0;
      do {
        var B = this._value[r];
        if (B === nA || B === void 0 || B === A) return t += this.consumeStringSlice(r), {
          type: 0,
          value: t
        };
        if (B === Xe) return this._value.splice(0, r), Ns;
        if (B === ne) {
          var n = this._value[r + 1];
          n !== nA && n !== void 0 && (n === Xe ? (t += this.consumeStringSlice(r), r = -1, this._value.shift()) : UA(B, n) && (t += this.consumeStringSlice(r), t += S(this.consumeEscapedCodePoint()), r = -1));
        }
        r++;
      } while (true);
    }, e.prototype.consumeNumber = function() {
      var A = [], t = ce, r = this.peekCodePoint(0);
      for ((r === DA || r === Z) && A.push(this.consumeCodePoint()); J(this.peekCodePoint(0)); ) A.push(this.consumeCodePoint());
      r = this.peekCodePoint(0);
      var B = this.peekCodePoint(1);
      if (r === ge && J(B)) for (A.push(this.consumeCodePoint(), this.consumeCodePoint()), t = ft; J(this.peekCodePoint(0)); ) A.push(this.consumeCodePoint());
      r = this.peekCodePoint(0), B = this.peekCodePoint(1);
      var n = this.peekCodePoint(2);
      if ((r === uB || r === cB) && ((B === DA || B === Z) && J(n) || J(B))) for (A.push(this.consumeCodePoint(), this.consumeCodePoint()), t = ft; J(this.peekCodePoint(0)); ) A.push(this.consumeCodePoint());
      return [ms(A), t];
    }, e.prototype.consumeNumericToken = function() {
      var A = this.consumeNumber(), t = A[0], r = A[1], B = this.peekCodePoint(0), n = this.peekCodePoint(1), s = this.peekCodePoint(2);
      if (Ke(B, n, s)) {
        var i = this.consumeName();
        return {
          type: 15,
          number: t,
          flags: r,
          unit: i
        };
      }
      return B === qn ? (this.consumeCodePoint(), {
        type: 16,
        number: t,
        flags: r
      }) : {
        type: 17,
        number: t,
        flags: r
      };
    }, e.prototype.consumeEscapedCodePoint = function() {
      var A = this.consumeCodePoint();
      if (MA(A)) {
        for (var t = S(A); MA(this.peekCodePoint(0)) && t.length < 6; ) t += S(this.consumeCodePoint());
        ye(this.peekCodePoint(0)) && this.consumeCodePoint();
        var r = parseInt(t, 16);
        return r === 0 || Hs(r) || r > 1114111 ? ht : r;
      }
      return A === nA ? ht : A;
    }, e.prototype.consumeName = function() {
      for (var A = ""; ; ) {
        var t = this.consumeCodePoint();
        if (dt(t)) A += S(t);
        else if (UA(t, this.peekCodePoint(0))) A += S(this.consumeEscapedCodePoint());
        else return this.reconsumeCodePoint(t), A;
      }
    }, e;
  }()
);
var UB = (
  /** @class */
  function() {
    function e(A) {
      this._tokens = A;
    }
    return e.create = function(A) {
      var t = new fB();
      return t.write(A), new e(t.read());
    }, e.parseValue = function(A) {
      return e.create(A).parseComponentValue();
    }, e.parseValues = function(A) {
      return e.create(A).parseComponentValues();
    }, e.prototype.parseComponentValue = function() {
      for (var A = this.consumeToken(); A.type === 31; ) A = this.consumeToken();
      if (A.type === 32) throw new SyntaxError("Error parsing CSS component value, unexpected EOF");
      this.reconsumeToken(A);
      var t = this.consumeComponentValue();
      do
        A = this.consumeToken();
      while (A.type === 31);
      if (A.type === 32) return t;
      throw new SyntaxError("Error parsing CSS component value, multiple values found when expecting only one");
    }, e.prototype.parseComponentValues = function() {
      for (var A = []; ; ) {
        var t = this.consumeComponentValue();
        if (t.type === 32) return A;
        A.push(t), A.push();
      }
    }, e.prototype.consumeComponentValue = function() {
      var A = this.consumeToken();
      switch (A.type) {
        case 11:
        case 28:
        case 2:
          return this.consumeSimpleBlock(A.type);
        case 19:
          return this.consumeFunction(A);
      }
      return A;
    }, e.prototype.consumeSimpleBlock = function(A) {
      for (var t = {
        type: A,
        values: []
      }, r = this.consumeToken(); ; ) {
        if (r.type === 32 || qs(r, A)) return t;
        this.reconsumeToken(r), t.values.push(this.consumeComponentValue()), r = this.consumeToken();
      }
    }, e.prototype.consumeFunction = function(A) {
      for (var t = {
        name: A.value,
        values: [],
        type: 18
        /* FUNCTION */
      }; ; ) {
        var r = this.consumeToken();
        if (r.type === 32 || r.type === 3) return t;
        this.reconsumeToken(r), t.values.push(this.consumeComponentValue());
      }
    }, e.prototype.consumeToken = function() {
      var A = this._tokens.shift();
      return typeof A > "u" ? Nr : A;
    }, e.prototype.reconsumeToken = function(A) {
      this._tokens.unshift(A);
    }, e;
  }()
);
var Ce = function(e) {
  return e.type === 15;
};
var kA = function(e) {
  return e.type === 17;
};
var D = function(e) {
  return e.type === 20;
};
var Zs = function(e) {
  return e.type === 0;
};
var Xr = function(e, A) {
  return D(e) && e.value === A;
};
var FB = function(e) {
  return e.type !== 31;
};
var PA = function(e) {
  return e.type !== 31 && e.type !== 4;
};
var sA = function(e) {
  var A = [], t = [];
  return e.forEach(function(r) {
    if (r.type === 4) {
      if (t.length === 0) throw new Error("Error parsing function args, zero tokens for arg");
      A.push(t), t = [];
      return;
    }
    r.type !== 31 && t.push(r);
  }), t.length && A.push(t), A;
};
var qs = function(e, A) {
  return A === 11 && e.type === 12 || A === 28 && e.type === 29 ? true : A === 2 && e.type === 3;
};
var pA = function(e) {
  return e.type === 17 || e.type === 15;
};
var M = function(e) {
  return e.type === 16 || pA(e);
};
var hB = function(e) {
  return e.length > 1 ? [e[0], e[1]] : [e[0]];
};
var X = {
  type: 17,
  number: 0,
  flags: ce
};
var $r = {
  type: 16,
  number: 50,
  flags: ce
};
var hA = {
  type: 16,
  number: 100,
  flags: ce
};
var re = function(e, A, t) {
  var r = e[0], B = e[1];
  return [b(r, A), b(typeof B < "u" ? B : r, t)];
};
var b = function(e, A) {
  if (e.type === 16) return e.number / 100 * A;
  if (Ce(e)) switch (e.unit) {
    case "rem":
    case "em":
      return 16 * e.number;
    case "px":
    default:
      return e.number;
  }
  return e.number;
};
var dB = "deg";
var EB = "grad";
var HB = "rad";
var pB = "turn";
var Ar = {
  name: "angle",
  parse: function(e, A) {
    if (A.type === 15) switch (A.unit) {
      case dB:
        return Math.PI * A.number / 180;
      case EB:
        return Math.PI / 200 * A.number;
      case HB:
        return A.number;
      case pB:
        return Math.PI * 2 * A.number;
    }
    throw new Error("Unsupported angle type");
  }
};
var IB = function(e) {
  return e.type === 15 && (e.unit === dB || e.unit === EB || e.unit === HB || e.unit === pB);
};
var vB = function(e) {
  var A = e.filter(D).map(function(t) {
    return t.value;
  }).join(" ");
  switch (A) {
    case "to bottom right":
    case "to right bottom":
    case "left top":
    case "top left":
      return [X, X];
    case "to top":
    case "bottom":
      return AA(0);
    case "to bottom left":
    case "to left bottom":
    case "right top":
    case "top right":
      return [X, hA];
    case "to right":
    case "left":
      return AA(90);
    case "to top left":
    case "to left top":
    case "right bottom":
    case "bottom right":
      return [hA, hA];
    case "to bottom":
    case "top":
      return AA(180);
    case "to top right":
    case "to right top":
    case "left bottom":
    case "bottom left":
      return [hA, X];
    case "to left":
    case "right":
      return AA(270);
  }
  return 0;
};
var AA = function(e) {
  return Math.PI * e / 180;
};
var EA = {
  name: "color",
  parse: function(e, A) {
    if (A.type === 18) {
      var t = js[A.name];
      if (typeof t > "u") throw new Error('Attempting to parse an unsupported color function "' + A.name + '"');
      return t(e, A.values);
    }
    if (A.type === 5) {
      if (A.value.length === 3) {
        var r = A.value.substring(0, 1), B = A.value.substring(1, 2), n = A.value.substring(2, 3);
        return dA(parseInt(r + r, 16), parseInt(B + B, 16), parseInt(n + n, 16), 1);
      }
      if (A.value.length === 4) {
        var r = A.value.substring(0, 1), B = A.value.substring(1, 2), n = A.value.substring(2, 3), s = A.value.substring(3, 4);
        return dA(parseInt(r + r, 16), parseInt(B + B, 16), parseInt(n + n, 16), parseInt(s + s, 16) / 255);
      }
      if (A.value.length === 6) {
        var r = A.value.substring(0, 2), B = A.value.substring(2, 4), n = A.value.substring(4, 6);
        return dA(parseInt(r, 16), parseInt(B, 16), parseInt(n, 16), 1);
      }
      if (A.value.length === 8) {
        var r = A.value.substring(0, 2), B = A.value.substring(2, 4), n = A.value.substring(4, 6), s = A.value.substring(6, 8);
        return dA(parseInt(r, 16), parseInt(B, 16), parseInt(n, 16), parseInt(s, 16) / 255);
      }
    }
    if (A.type === 20) {
      var i = wA[A.value.toUpperCase()];
      if (typeof i < "u") return i;
    }
    return wA.TRANSPARENT;
  }
};
var HA = function(e) {
  return (255 & e) === 0;
};
var R = function(e) {
  var A = 255 & e, t = 255 & e >> 8, r = 255 & e >> 16, B = 255 & e >> 24;
  return A < 255 ? "rgba(" + B + "," + r + "," + t + "," + A / 255 + ")" : "rgb(" + B + "," + r + "," + t + ")";
};
var dA = function(e, A, t, r) {
  return (e << 24 | A << 16 | t << 8 | Math.round(r * 255) << 0) >>> 0;
};
var Et = function(e, A) {
  if (e.type === 17) return e.number;
  if (e.type === 16) {
    var t = A === 3 ? 1 : 255;
    return A === 3 ? e.number / 100 * t : Math.round(e.number / 100 * t);
  }
  return 0;
};
var Ht = function(e, A) {
  var t = A.filter(PA);
  if (t.length === 3) {
    var r = t.map(Et), B = r[0], n = r[1], s = r[2];
    return dA(B, n, s, 1);
  }
  if (t.length === 4) {
    var i = t.map(Et), B = i[0], n = i[1], s = i[2], a = i[3];
    return dA(B, n, s, a);
  }
  return 0;
};
function ur(e, A, t) {
  return t < 0 && (t += 1), t >= 1 && (t -= 1), t < 1 / 6 ? (A - e) * t * 6 + e : t < 1 / 2 ? A : t < 2 / 3 ? (A - e) * 6 * (2 / 3 - t) + e : e;
}
var pt = function(e, A) {
  var t = A.filter(PA), r = t[0], B = t[1], n = t[2], s = t[3], i = (r.type === 17 ? AA(r.number) : Ar.parse(e, r)) / (Math.PI * 2), a = M(B) ? B.number / 100 : 0, o = M(n) ? n.number / 100 : 0, Q = typeof s < "u" && M(s) ? b(s, 1) : 1;
  if (a === 0) return dA(o * 255, o * 255, o * 255, 1);
  var g = o <= 0.5 ? o * (a + 1) : o + a - o * a, w = o * 2 - g, f = ur(w, g, i + 1 / 3), c = ur(w, g, i), C = ur(w, g, i - 1 / 3);
  return dA(f * 255, c * 255, C * 255, Q);
};
var js = {
  hsl: pt,
  hsla: pt,
  rgb: Ht,
  rgba: Ht
};
var se = function(e, A) {
  return EA.parse(e, UB.create(A).parseComponentValue());
};
var wA = {
  ALICEBLUE: 4042850303,
  ANTIQUEWHITE: 4209760255,
  AQUA: 16777215,
  AQUAMARINE: 2147472639,
  AZURE: 4043309055,
  BEIGE: 4126530815,
  BISQUE: 4293182719,
  BLACK: 255,
  BLANCHEDALMOND: 4293643775,
  BLUE: 65535,
  BLUEVIOLET: 2318131967,
  BROWN: 2771004159,
  BURLYWOOD: 3736635391,
  CADETBLUE: 1604231423,
  CHARTREUSE: 2147418367,
  CHOCOLATE: 3530104575,
  CORAL: 4286533887,
  CORNFLOWERBLUE: 1687547391,
  CORNSILK: 4294499583,
  CRIMSON: 3692313855,
  CYAN: 16777215,
  DARKBLUE: 35839,
  DARKCYAN: 9145343,
  DARKGOLDENROD: 3095837695,
  DARKGRAY: 2846468607,
  DARKGREEN: 6553855,
  DARKGREY: 2846468607,
  DARKKHAKI: 3182914559,
  DARKMAGENTA: 2332068863,
  DARKOLIVEGREEN: 1433087999,
  DARKORANGE: 4287365375,
  DARKORCHID: 2570243327,
  DARKRED: 2332033279,
  DARKSALMON: 3918953215,
  DARKSEAGREEN: 2411499519,
  DARKSLATEBLUE: 1211993087,
  DARKSLATEGRAY: 793726975,
  DARKSLATEGREY: 793726975,
  DARKTURQUOISE: 13554175,
  DARKVIOLET: 2483082239,
  DEEPPINK: 4279538687,
  DEEPSKYBLUE: 12582911,
  DIMGRAY: 1768516095,
  DIMGREY: 1768516095,
  DODGERBLUE: 512819199,
  FIREBRICK: 2988581631,
  FLORALWHITE: 4294635775,
  FORESTGREEN: 579543807,
  FUCHSIA: 4278255615,
  GAINSBORO: 3705462015,
  GHOSTWHITE: 4177068031,
  GOLD: 4292280575,
  GOLDENROD: 3668254975,
  GRAY: 2155905279,
  GREEN: 8388863,
  GREENYELLOW: 2919182335,
  GREY: 2155905279,
  HONEYDEW: 4043305215,
  HOTPINK: 4285117695,
  INDIANRED: 3445382399,
  INDIGO: 1258324735,
  IVORY: 4294963455,
  KHAKI: 4041641215,
  LAVENDER: 3873897215,
  LAVENDERBLUSH: 4293981695,
  LAWNGREEN: 2096890111,
  LEMONCHIFFON: 4294626815,
  LIGHTBLUE: 2916673279,
  LIGHTCORAL: 4034953471,
  LIGHTCYAN: 3774873599,
  LIGHTGOLDENRODYELLOW: 4210742015,
  LIGHTGRAY: 3553874943,
  LIGHTGREEN: 2431553791,
  LIGHTGREY: 3553874943,
  LIGHTPINK: 4290167295,
  LIGHTSALMON: 4288707327,
  LIGHTSEAGREEN: 548580095,
  LIGHTSKYBLUE: 2278488831,
  LIGHTSLATEGRAY: 2005441023,
  LIGHTSLATEGREY: 2005441023,
  LIGHTSTEELBLUE: 2965692159,
  LIGHTYELLOW: 4294959359,
  LIME: 16711935,
  LIMEGREEN: 852308735,
  LINEN: 4210091775,
  MAGENTA: 4278255615,
  MAROON: 2147483903,
  MEDIUMAQUAMARINE: 1724754687,
  MEDIUMBLUE: 52735,
  MEDIUMORCHID: 3126187007,
  MEDIUMPURPLE: 2473647103,
  MEDIUMSEAGREEN: 1018393087,
  MEDIUMSLATEBLUE: 2070474495,
  MEDIUMSPRINGGREEN: 16423679,
  MEDIUMTURQUOISE: 1221709055,
  MEDIUMVIOLETRED: 3340076543,
  MIDNIGHTBLUE: 421097727,
  MINTCREAM: 4127193855,
  MISTYROSE: 4293190143,
  MOCCASIN: 4293178879,
  NAVAJOWHITE: 4292783615,
  NAVY: 33023,
  OLDLACE: 4260751103,
  OLIVE: 2155872511,
  OLIVEDRAB: 1804477439,
  ORANGE: 4289003775,
  ORANGERED: 4282712319,
  ORCHID: 3664828159,
  PALEGOLDENROD: 4008225535,
  PALEGREEN: 2566625535,
  PALETURQUOISE: 2951671551,
  PALEVIOLETRED: 3681588223,
  PAPAYAWHIP: 4293907967,
  PEACHPUFF: 4292524543,
  PERU: 3448061951,
  PINK: 4290825215,
  PLUM: 3718307327,
  POWDERBLUE: 2967529215,
  PURPLE: 2147516671,
  REBECCAPURPLE: 1714657791,
  RED: 4278190335,
  ROSYBROWN: 3163525119,
  ROYALBLUE: 1097458175,
  SADDLEBROWN: 2336560127,
  SALMON: 4202722047,
  SANDYBROWN: 4104413439,
  SEAGREEN: 780883967,
  SEASHELL: 4294307583,
  SIENNA: 2689740287,
  SILVER: 3233857791,
  SKYBLUE: 2278484991,
  SLATEBLUE: 1784335871,
  SLATEGRAY: 1887473919,
  SLATEGREY: 1887473919,
  SNOW: 4294638335,
  SPRINGGREEN: 16744447,
  STEELBLUE: 1182971135,
  TAN: 3535047935,
  TEAL: 8421631,
  THISTLE: 3636451583,
  TOMATO: 4284696575,
  TRANSPARENT: 0,
  TURQUOISE: 1088475391,
  VIOLET: 4001558271,
  WHEAT: 4125012991,
  WHITE: 4294967295,
  WHITESMOKE: 4126537215,
  YELLOW: 4294902015,
  YELLOWGREEN: 2597139199
};
var zs = {
  name: "background-clip",
  initialValue: "border-box",
  prefix: false,
  type: 1,
  parse: function(e, A) {
    return A.map(function(t) {
      if (D(t)) switch (t.value) {
        case "padding-box":
          return 1;
        case "content-box":
          return 2;
      }
      return 0;
    });
  }
};
var $s = {
  name: "background-color",
  initialValue: "transparent",
  prefix: false,
  type: 3,
  format: "color"
};
var er = function(e, A) {
  var t = EA.parse(e, A[0]), r = A[1];
  return r && M(r) ? {
    color: t,
    stop: r
  } : {
    color: t,
    stop: null
  };
};
var It = function(e, A) {
  var t = e[0], r = e[e.length - 1];
  t.stop === null && (t.stop = X), r.stop === null && (r.stop = hA);
  for (var B = [], n = 0, s = 0; s < e.length; s++) {
    var i = e[s].stop;
    if (i !== null) {
      var a = b(i, A);
      a > n ? B.push(a) : B.push(n), n = a;
    } else B.push(null);
  }
  for (var o = null, s = 0; s < B.length; s++) {
    var Q = B[s];
    if (Q === null) o === null && (o = s);
    else if (o !== null) {
      for (var g = s - o, w = B[o - 1], f = (Q - w) / (g + 1), c = 1; c <= g; c++) B[o + c - 1] = f * c;
      o = null;
    }
  }
  return e.map(function(C, H) {
    var h = C.color;
    return {
      color: h,
      stop: Math.max(Math.min(1, B[H] / A), 0)
    };
  });
};
var Aa = function(e, A, t) {
  var r = A / 2, B = t / 2, n = b(e[0], A) - r, s = B - b(e[1], t);
  return (Math.atan2(s, n) + Math.PI * 2) % (Math.PI * 2);
};
var ea = function(e, A, t) {
  var r = typeof e == "number" ? e : Aa(e, A, t), B = Math.abs(A * Math.sin(r)) + Math.abs(t * Math.cos(r)), n = A / 2, s = t / 2, i = B / 2, a = Math.sin(r - Math.PI / 2) * i, o = Math.cos(r - Math.PI / 2) * i;
  return [B, n - o, n + o, s - a, s + a];
};
var rA = function(e, A) {
  return Math.sqrt(e * e + A * A);
};
var vt = function(e, A, t, r, B) {
  var n = [[0, 0], [0, A], [e, 0], [e, A]];
  return n.reduce(function(s, i) {
    var a = i[0], o = i[1], Q = rA(t - a, r - o);
    return (B ? Q < s.optimumDistance : Q > s.optimumDistance) ? {
      optimumCorner: i,
      optimumDistance: Q
    } : s;
  }, {
    optimumDistance: B ? 1 / 0 : -1 / 0,
    optimumCorner: null
  }).optimumCorner;
};
var ra = function(e, A, t, r, B) {
  var n = 0, s = 0;
  switch (e.size) {
    case 0:
      e.shape === 0 ? n = s = Math.min(Math.abs(A), Math.abs(A - r), Math.abs(t), Math.abs(t - B)) : e.shape === 1 && (n = Math.min(Math.abs(A), Math.abs(A - r)), s = Math.min(Math.abs(t), Math.abs(t - B)));
      break;
    case 2:
      if (e.shape === 0) n = s = Math.min(rA(A, t), rA(A, t - B), rA(A - r, t), rA(A - r, t - B));
      else if (e.shape === 1) {
        var i = Math.min(Math.abs(t), Math.abs(t - B)) / Math.min(Math.abs(A), Math.abs(A - r)), a = vt(r, B, A, t, true), o = a[0], Q = a[1];
        n = rA(o - A, (Q - t) / i), s = i * n;
      }
      break;
    case 1:
      e.shape === 0 ? n = s = Math.max(Math.abs(A), Math.abs(A - r), Math.abs(t), Math.abs(t - B)) : e.shape === 1 && (n = Math.max(Math.abs(A), Math.abs(A - r)), s = Math.max(Math.abs(t), Math.abs(t - B)));
      break;
    case 3:
      if (e.shape === 0) n = s = Math.max(rA(A, t), rA(A, t - B), rA(A - r, t), rA(A - r, t - B));
      else if (e.shape === 1) {
        var i = Math.max(Math.abs(t), Math.abs(t - B)) / Math.max(Math.abs(A), Math.abs(A - r)), g = vt(r, B, A, t, false), o = g[0], Q = g[1];
        n = rA(o - A, (Q - t) / i), s = i * n;
      }
      break;
  }
  return Array.isArray(e.size) && (n = b(e.size[0], r), s = e.size.length === 2 ? b(e.size[1], B) : n), [n, s];
};
var ta = function(e, A) {
  var t = AA(180), r = [];
  return sA(A).forEach(function(B, n) {
    if (n === 0) {
      var s = B[0];
      if (s.type === 20 && s.value === "to") {
        t = vB(B);
        return;
      } else if (IB(s)) {
        t = Ar.parse(e, s);
        return;
      }
    }
    var i = er(e, B);
    r.push(i);
  }), {
    angle: t,
    stops: r,
    type: 1
    /* LINEAR_GRADIENT */
  };
};
var Le = function(e, A) {
  var t = AA(180), r = [];
  return sA(A).forEach(function(B, n) {
    if (n === 0) {
      var s = B[0];
      if (s.type === 20 && ["top", "left", "right", "bottom"].indexOf(s.value) !== -1) {
        t = vB(B);
        return;
      } else if (IB(s)) {
        t = (Ar.parse(e, s) + AA(270)) % AA(360);
        return;
      }
    }
    var i = er(e, B);
    r.push(i);
  }), {
    angle: t,
    stops: r,
    type: 1
    /* LINEAR_GRADIENT */
  };
};
var Ba = function(e, A) {
  var t = AA(180), r = [], B = 1, n = 0, s = 3, i = [];
  return sA(A).forEach(function(a, o) {
    var Q = a[0];
    if (o === 0) {
      if (D(Q) && Q.value === "linear") {
        B = 1;
        return;
      } else if (D(Q) && Q.value === "radial") {
        B = 2;
        return;
      }
    }
    if (Q.type === 18) {
      if (Q.name === "from") {
        var g = EA.parse(e, Q.values[0]);
        r.push({
          stop: X,
          color: g
        });
      } else if (Q.name === "to") {
        var g = EA.parse(e, Q.values[0]);
        r.push({
          stop: hA,
          color: g
        });
      } else if (Q.name === "color-stop") {
        var w = Q.values.filter(PA);
        if (w.length === 2) {
          var g = EA.parse(e, w[1]), f = w[0];
          kA(f) && r.push({
            stop: {
              type: 16,
              number: f.number * 100,
              flags: f.flags
            },
            color: g
          });
        }
      }
    }
  }), B === 1 ? {
    angle: (t + AA(180)) % AA(360),
    stops: r,
    type: B
  } : {
    size: s,
    shape: n,
    stops: r,
    position: i,
    type: B
  };
};
var yB = "closest-side";
var KB = "farthest-side";
var mB = "closest-corner";
var LB = "farthest-corner";
var DB = "circle";
var bB = "ellipse";
var xB = "cover";
var TB = "contain";
var na = function(e, A) {
  var t = 0, r = 3, B = [], n = [];
  return sA(A).forEach(function(s, i) {
    var a = true;
    if (i === 0) {
      var o = false;
      a = s.reduce(function(g, w) {
        if (o) {
          if (D(w)) switch (w.value) {
            case "center":
              return n.push($r), g;
            case "top":
            case "left":
              return n.push(X), g;
            case "right":
            case "bottom":
              return n.push(hA), g;
          }
          else (M(w) || pA(w)) && n.push(w);
        } else if (D(w)) switch (w.value) {
          case DB:
            return t = 0, false;
          case bB:
            return t = 1, false;
          case "at":
            return o = true, false;
          case yB:
            return r = 0, false;
          case xB:
          case KB:
            return r = 1, false;
          case TB:
          case mB:
            return r = 2, false;
          case LB:
            return r = 3, false;
        }
        else if (pA(w) || M(w)) return Array.isArray(r) || (r = []), r.push(w), false;
        return g;
      }, a);
    }
    if (a) {
      var Q = er(e, s);
      B.push(Q);
    }
  }), {
    size: r,
    shape: t,
    stops: B,
    position: n,
    type: 2
    /* RADIAL_GRADIENT */
  };
};
var De = function(e, A) {
  var t = 0, r = 3, B = [], n = [];
  return sA(A).forEach(function(s, i) {
    var a = true;
    if (i === 0 ? a = s.reduce(function(Q, g) {
      if (D(g)) switch (g.value) {
        case "center":
          return n.push($r), false;
        case "top":
        case "left":
          return n.push(X), false;
        case "right":
        case "bottom":
          return n.push(hA), false;
      }
      else if (M(g) || pA(g)) return n.push(g), false;
      return Q;
    }, a) : i === 1 && (a = s.reduce(function(Q, g) {
      if (D(g)) switch (g.value) {
        case DB:
          return t = 0, false;
        case bB:
          return t = 1, false;
        case TB:
        case yB:
          return r = 0, false;
        case KB:
          return r = 1, false;
        case mB:
          return r = 2, false;
        case xB:
        case LB:
          return r = 3, false;
      }
      else if (pA(g) || M(g)) return Array.isArray(r) || (r = []), r.push(g), false;
      return Q;
    }, a)), a) {
      var o = er(e, s);
      B.push(o);
    }
  }), {
    size: r,
    shape: t,
    stops: B,
    position: n,
    type: 2
    /* RADIAL_GRADIENT */
  };
};
var sa = function(e) {
  return e.type === 1;
};
var aa = function(e) {
  return e.type === 2;
};
var At = {
  name: "image",
  parse: function(e, A) {
    if (A.type === 22) {
      var t = {
        url: A.value,
        type: 0
        /* URL */
      };
      return e.cache.addImage(A.value), t;
    }
    if (A.type === 18) {
      var r = SB[A.name];
      if (typeof r > "u") throw new Error('Attempting to parse an unsupported image function "' + A.name + '"');
      return r(e, A.values);
    }
    throw new Error("Unsupported image type " + A.type);
  }
};
function ia(e) {
  return !(e.type === 20 && e.value === "none") && (e.type !== 18 || !!SB[e.name]);
}
var SB = {
  "linear-gradient": ta,
  "-moz-linear-gradient": Le,
  "-ms-linear-gradient": Le,
  "-o-linear-gradient": Le,
  "-webkit-linear-gradient": Le,
  "radial-gradient": na,
  "-moz-radial-gradient": De,
  "-ms-radial-gradient": De,
  "-o-radial-gradient": De,
  "-webkit-radial-gradient": De,
  "-webkit-gradient": Ba
};
var oa = {
  name: "background-image",
  initialValue: "none",
  type: 1,
  prefix: false,
  parse: function(e, A) {
    if (A.length === 0) return [];
    var t = A[0];
    return t.type === 20 && t.value === "none" ? [] : A.filter(function(r) {
      return PA(r) && ia(r);
    }).map(function(r) {
      return At.parse(e, r);
    });
  }
};
var Qa = {
  name: "background-origin",
  initialValue: "border-box",
  prefix: false,
  type: 1,
  parse: function(e, A) {
    return A.map(function(t) {
      if (D(t)) switch (t.value) {
        case "padding-box":
          return 1;
        case "content-box":
          return 2;
      }
      return 0;
    });
  }
};
var ga = {
  name: "background-position",
  initialValue: "0% 0%",
  type: 1,
  prefix: false,
  parse: function(e, A) {
    return sA(A).map(function(t) {
      return t.filter(M);
    }).map(hB);
  }
};
var wa = {
  name: "background-repeat",
  initialValue: "repeat",
  prefix: false,
  type: 1,
  parse: function(e, A) {
    return sA(A).map(function(t) {
      return t.filter(D).map(function(r) {
        return r.value;
      }).join(" ");
    }).map(ca);
  }
};
var ca = function(e) {
  switch (e) {
    case "no-repeat":
      return 1;
    case "repeat-x":
    case "repeat no-repeat":
      return 2;
    case "repeat-y":
    case "no-repeat repeat":
      return 3;
    case "repeat":
    default:
      return 0;
  }
};
var JA;
(function(e) {
  e.AUTO = "auto", e.CONTAIN = "contain", e.COVER = "cover";
})(JA || (JA = {}));
var Ca = {
  name: "background-size",
  initialValue: "0",
  prefix: false,
  type: 1,
  parse: function(e, A) {
    return sA(A).map(function(t) {
      return t.filter(ua);
    });
  }
};
var ua = function(e) {
  return D(e) || M(e);
};
var rr = function(e) {
  return {
    name: "border-" + e + "-color",
    initialValue: "transparent",
    prefix: false,
    type: 3,
    format: "color"
  };
};
var la = rr("top");
var fa = rr("right");
var Ua = rr("bottom");
var Fa = rr("left");
var tr = function(e) {
  return {
    name: "border-radius-" + e,
    initialValue: "0 0",
    prefix: false,
    type: 1,
    parse: function(A, t) {
      return hB(t.filter(M));
    }
  };
};
var ha = tr("top-left");
var da = tr("top-right");
var Ea = tr("bottom-right");
var Ha = tr("bottom-left");
var Br = function(e) {
  return {
    name: "border-" + e + "-style",
    initialValue: "solid",
    prefix: false,
    type: 2,
    parse: function(A, t) {
      switch (t) {
        case "none":
          return 0;
        case "dashed":
          return 2;
        case "dotted":
          return 3;
        case "double":
          return 4;
      }
      return 1;
    }
  };
};
var pa = Br("top");
var Ia = Br("right");
var va = Br("bottom");
var ya = Br("left");
var nr = function(e) {
  return {
    name: "border-" + e + "-width",
    initialValue: "0",
    type: 0,
    prefix: false,
    parse: function(A, t) {
      return Ce(t) ? t.number : 0;
    }
  };
};
var Ka = nr("top");
var ma = nr("right");
var La = nr("bottom");
var Da = nr("left");
var ba = {
  name: "color",
  initialValue: "transparent",
  prefix: false,
  type: 3,
  format: "color"
};
var xa = {
  name: "direction",
  initialValue: "ltr",
  prefix: false,
  type: 2,
  parse: function(e, A) {
    switch (A) {
      case "rtl":
        return 1;
      case "ltr":
      default:
        return 0;
    }
  }
};
var Ta = {
  name: "display",
  initialValue: "inline-block",
  prefix: false,
  type: 1,
  parse: function(e, A) {
    return A.filter(D).reduce(
      function(t, r) {
        return t | Sa(r.value);
      },
      0
      /* NONE */
    );
  }
};
var Sa = function(e) {
  switch (e) {
    case "block":
    case "-webkit-box":
      return 2;
    case "inline":
      return 4;
    case "run-in":
      return 8;
    case "flow":
      return 16;
    case "flow-root":
      return 32;
    case "table":
      return 64;
    case "flex":
    case "-webkit-flex":
      return 128;
    case "grid":
    case "-ms-grid":
      return 256;
    case "ruby":
      return 512;
    case "subgrid":
      return 1024;
    case "list-item":
      return 2048;
    case "table-row-group":
      return 4096;
    case "table-header-group":
      return 8192;
    case "table-footer-group":
      return 16384;
    case "table-row":
      return 32768;
    case "table-cell":
      return 65536;
    case "table-column-group":
      return 131072;
    case "table-column":
      return 262144;
    case "table-caption":
      return 524288;
    case "ruby-base":
      return 1048576;
    case "ruby-text":
      return 2097152;
    case "ruby-base-container":
      return 4194304;
    case "ruby-text-container":
      return 8388608;
    case "contents":
      return 16777216;
    case "inline-block":
      return 33554432;
    case "inline-list-item":
      return 67108864;
    case "inline-table":
      return 134217728;
    case "inline-flex":
      return 268435456;
    case "inline-grid":
      return 536870912;
  }
  return 0;
};
var Oa = {
  name: "float",
  initialValue: "none",
  prefix: false,
  type: 2,
  parse: function(e, A) {
    switch (A) {
      case "left":
        return 1;
      case "right":
        return 2;
      case "inline-start":
        return 3;
      case "inline-end":
        return 4;
    }
    return 0;
  }
};
var Ma = {
  name: "letter-spacing",
  initialValue: "0",
  prefix: false,
  type: 0,
  parse: function(e, A) {
    return A.type === 20 && A.value === "normal" ? 0 : A.type === 17 || A.type === 15 ? A.number : 0;
  }
};
var Je;
(function(e) {
  e.NORMAL = "normal", e.STRICT = "strict";
})(Je || (Je = {}));
var Ga = {
  name: "line-break",
  initialValue: "normal",
  prefix: false,
  type: 2,
  parse: function(e, A) {
    switch (A) {
      case "strict":
        return Je.STRICT;
      case "normal":
      default:
        return Je.NORMAL;
    }
  }
};
var Ra = {
  name: "line-height",
  initialValue: "normal",
  prefix: false,
  type: 4
  /* TOKEN_VALUE */
};
var yt = function(e, A) {
  return D(e) && e.value === "normal" ? 1.2 * A : e.type === 17 ? A * e.number : M(e) ? b(e, A) : A;
};
var Va = {
  name: "list-style-image",
  initialValue: "none",
  type: 0,
  prefix: false,
  parse: function(e, A) {
    return A.type === 20 && A.value === "none" ? null : At.parse(e, A);
  }
};
var Na = {
  name: "list-style-position",
  initialValue: "outside",
  prefix: false,
  type: 2,
  parse: function(e, A) {
    switch (A) {
      case "inside":
        return 0;
      case "outside":
      default:
        return 1;
    }
  }
};
var _r = {
  name: "list-style-type",
  initialValue: "none",
  prefix: false,
  type: 2,
  parse: function(e, A) {
    switch (A) {
      case "disc":
        return 0;
      case "circle":
        return 1;
      case "square":
        return 2;
      case "decimal":
        return 3;
      case "cjk-decimal":
        return 4;
      case "decimal-leading-zero":
        return 5;
      case "lower-roman":
        return 6;
      case "upper-roman":
        return 7;
      case "lower-greek":
        return 8;
      case "lower-alpha":
        return 9;
      case "upper-alpha":
        return 10;
      case "arabic-indic":
        return 11;
      case "armenian":
        return 12;
      case "bengali":
        return 13;
      case "cambodian":
        return 14;
      case "cjk-earthly-branch":
        return 15;
      case "cjk-heavenly-stem":
        return 16;
      case "cjk-ideographic":
        return 17;
      case "devanagari":
        return 18;
      case "ethiopic-numeric":
        return 19;
      case "georgian":
        return 20;
      case "gujarati":
        return 21;
      case "gurmukhi":
        return 22;
      case "hebrew":
        return 22;
      case "hiragana":
        return 23;
      case "hiragana-iroha":
        return 24;
      case "japanese-formal":
        return 25;
      case "japanese-informal":
        return 26;
      case "kannada":
        return 27;
      case "katakana":
        return 28;
      case "katakana-iroha":
        return 29;
      case "khmer":
        return 30;
      case "korean-hangul-formal":
        return 31;
      case "korean-hanja-formal":
        return 32;
      case "korean-hanja-informal":
        return 33;
      case "lao":
        return 34;
      case "lower-armenian":
        return 35;
      case "malayalam":
        return 36;
      case "mongolian":
        return 37;
      case "myanmar":
        return 38;
      case "oriya":
        return 39;
      case "persian":
        return 40;
      case "simp-chinese-formal":
        return 41;
      case "simp-chinese-informal":
        return 42;
      case "tamil":
        return 43;
      case "telugu":
        return 44;
      case "thai":
        return 45;
      case "tibetan":
        return 46;
      case "trad-chinese-formal":
        return 47;
      case "trad-chinese-informal":
        return 48;
      case "upper-armenian":
        return 49;
      case "disclosure-open":
        return 50;
      case "disclosure-closed":
        return 51;
      case "none":
      default:
        return -1;
    }
  }
};
var sr = function(e) {
  return {
    name: "margin-" + e,
    initialValue: "0",
    prefix: false,
    type: 4
    /* TOKEN_VALUE */
  };
};
var Xa = sr("top");
var _a = sr("right");
var Ja = sr("bottom");
var Pa = sr("left");
var ka = {
  name: "overflow",
  initialValue: "visible",
  prefix: false,
  type: 1,
  parse: function(e, A) {
    return A.filter(D).map(function(t) {
      switch (t.value) {
        case "hidden":
          return 1;
        case "scroll":
          return 2;
        case "clip":
          return 3;
        case "auto":
          return 4;
        case "visible":
        default:
          return 0;
      }
    });
  }
};
var Ya = {
  name: "overflow-wrap",
  initialValue: "normal",
  prefix: false,
  type: 2,
  parse: function(e, A) {
    switch (A) {
      case "break-word":
        return "break-word";
      case "normal":
      default:
        return "normal";
    }
  }
};
var ar = function(e) {
  return {
    name: "padding-" + e,
    initialValue: "0",
    prefix: false,
    type: 3,
    format: "length-percentage"
  };
};
var Wa = ar("top");
var Za = ar("right");
var qa = ar("bottom");
var ja = ar("left");
var za = {
  name: "text-align",
  initialValue: "left",
  prefix: false,
  type: 2,
  parse: function(e, A) {
    switch (A) {
      case "right":
        return 2;
      case "center":
      case "justify":
        return 1;
      case "left":
      default:
        return 0;
    }
  }
};
var $a = {
  name: "position",
  initialValue: "static",
  prefix: false,
  type: 2,
  parse: function(e, A) {
    switch (A) {
      case "relative":
        return 1;
      case "absolute":
        return 2;
      case "fixed":
        return 3;
      case "sticky":
        return 4;
    }
    return 0;
  }
};
var Ai = {
  name: "text-shadow",
  initialValue: "none",
  type: 1,
  prefix: false,
  parse: function(e, A) {
    return A.length === 1 && Xr(A[0], "none") ? [] : sA(A).map(function(t) {
      for (var r = {
        color: wA.TRANSPARENT,
        offsetX: X,
        offsetY: X,
        blur: X
      }, B = 0, n = 0; n < t.length; n++) {
        var s = t[n];
        pA(s) ? (B === 0 ? r.offsetX = s : B === 1 ? r.offsetY = s : r.blur = s, B++) : r.color = EA.parse(e, s);
      }
      return r;
    });
  }
};
var ei = {
  name: "text-transform",
  initialValue: "none",
  prefix: false,
  type: 2,
  parse: function(e, A) {
    switch (A) {
      case "uppercase":
        return 2;
      case "lowercase":
        return 1;
      case "capitalize":
        return 3;
    }
    return 0;
  }
};
var ri = {
  name: "transform",
  initialValue: "none",
  prefix: true,
  type: 0,
  parse: function(e, A) {
    if (A.type === 20 && A.value === "none") return null;
    if (A.type === 18) {
      var t = ni[A.name];
      if (typeof t > "u") throw new Error('Attempting to parse an unsupported transform function "' + A.name + '"');
      return t(A.values);
    }
    return null;
  }
};
var ti = function(e) {
  var A = e.filter(function(t) {
    return t.type === 17;
  }).map(function(t) {
    return t.number;
  });
  return A.length === 6 ? A : null;
};
var Bi = function(e) {
  var A = e.filter(function(a) {
    return a.type === 17;
  }).map(function(a) {
    return a.number;
  }), t = A[0], r = A[1];
  A[2], A[3];
  var B = A[4], n = A[5];
  A[6], A[7], A[8], A[9], A[10], A[11];
  var s = A[12], i = A[13];
  return A[14], A[15], A.length === 16 ? [t, r, B, n, s, i] : null;
};
var ni = {
  matrix: ti,
  matrix3d: Bi
};
var Kt = {
  type: 16,
  number: 50,
  flags: ce
};
var si = [Kt, Kt];
var ai = {
  name: "transform-origin",
  initialValue: "50% 50%",
  prefix: true,
  type: 1,
  parse: function(e, A) {
    var t = A.filter(M);
    return t.length !== 2 ? si : [t[0], t[1]];
  }
};
var ii = {
  name: "visible",
  initialValue: "none",
  prefix: false,
  type: 2,
  parse: function(e, A) {
    switch (A) {
      case "hidden":
        return 1;
      case "collapse":
        return 2;
      case "visible":
      default:
        return 0;
    }
  }
};
var ae;
(function(e) {
  e.NORMAL = "normal", e.BREAK_ALL = "break-all", e.KEEP_ALL = "keep-all";
})(ae || (ae = {}));
var oi = {
  name: "word-break",
  initialValue: "normal",
  prefix: false,
  type: 2,
  parse: function(e, A) {
    switch (A) {
      case "break-all":
        return ae.BREAK_ALL;
      case "keep-all":
        return ae.KEEP_ALL;
      case "normal":
      default:
        return ae.NORMAL;
    }
  }
};
var Qi = {
  name: "z-index",
  initialValue: "auto",
  prefix: false,
  type: 0,
  parse: function(e, A) {
    if (A.type === 20) return {
      auto: true,
      order: 0
    };
    if (kA(A)) return {
      auto: false,
      order: A.number
    };
    throw new Error("Invalid z-index number parsed");
  }
};
var OB = {
  name: "time",
  parse: function(e, A) {
    if (A.type === 15) switch (A.unit.toLowerCase()) {
      case "s":
        return 1e3 * A.number;
      case "ms":
        return A.number;
    }
    throw new Error("Unsupported time type");
  }
};
var gi = {
  name: "opacity",
  initialValue: "1",
  type: 0,
  prefix: false,
  parse: function(e, A) {
    return kA(A) ? A.number : 1;
  }
};
var wi = {
  name: "text-decoration-color",
  initialValue: "transparent",
  prefix: false,
  type: 3,
  format: "color"
};
var ci = {
  name: "text-decoration-line",
  initialValue: "none",
  prefix: false,
  type: 1,
  parse: function(e, A) {
    return A.filter(D).map(function(t) {
      switch (t.value) {
        case "underline":
          return 1;
        case "overline":
          return 2;
        case "line-through":
          return 3;
        case "none":
          return 4;
      }
      return 0;
    }).filter(function(t) {
      return t !== 0;
    });
  }
};
var Ci = {
  name: "font-family",
  initialValue: "",
  prefix: false,
  type: 1,
  parse: function(e, A) {
    var t = [], r = [];
    return A.forEach(function(B) {
      switch (B.type) {
        case 20:
        case 0:
          t.push(B.value);
          break;
        case 17:
          t.push(B.number.toString());
          break;
        case 4:
          r.push(t.join(" ")), t.length = 0;
          break;
      }
    }), t.length && r.push(t.join(" ")), r.map(function(B) {
      return B.indexOf(" ") === -1 ? B : "'" + B + "'";
    });
  }
};
var ui = {
  name: "font-size",
  initialValue: "0",
  prefix: false,
  type: 3,
  format: "length"
};
var li = {
  name: "font-weight",
  initialValue: "normal",
  type: 0,
  prefix: false,
  parse: function(e, A) {
    if (kA(A)) return A.number;
    if (D(A)) switch (A.value) {
      case "bold":
        return 700;
      case "normal":
      default:
        return 400;
    }
    return 400;
  }
};
var fi = {
  name: "font-variant",
  initialValue: "none",
  type: 1,
  prefix: false,
  parse: function(e, A) {
    return A.filter(D).map(function(t) {
      return t.value;
    });
  }
};
var Ui = {
  name: "font-style",
  initialValue: "normal",
  prefix: false,
  type: 2,
  parse: function(e, A) {
    switch (A) {
      case "oblique":
        return "oblique";
      case "italic":
        return "italic";
      case "normal":
      default:
        return "normal";
    }
  }
};
var G = function(e, A) {
  return (e & A) !== 0;
};
var Fi = {
  name: "content",
  initialValue: "none",
  type: 1,
  prefix: false,
  parse: function(e, A) {
    if (A.length === 0) return [];
    var t = A[0];
    return t.type === 20 && t.value === "none" ? [] : A;
  }
};
var hi = {
  name: "counter-increment",
  initialValue: "none",
  prefix: true,
  type: 1,
  parse: function(e, A) {
    if (A.length === 0) return null;
    var t = A[0];
    if (t.type === 20 && t.value === "none") return null;
    for (var r = [], B = A.filter(FB), n = 0; n < B.length; n++) {
      var s = B[n], i = B[n + 1];
      if (s.type === 20) {
        var a = i && kA(i) ? i.number : 1;
        r.push({
          counter: s.value,
          increment: a
        });
      }
    }
    return r;
  }
};
var di = {
  name: "counter-reset",
  initialValue: "none",
  prefix: true,
  type: 1,
  parse: function(e, A) {
    if (A.length === 0) return [];
    for (var t = [], r = A.filter(FB), B = 0; B < r.length; B++) {
      var n = r[B], s = r[B + 1];
      if (D(n) && n.value !== "none") {
        var i = s && kA(s) ? s.number : 0;
        t.push({
          counter: n.value,
          reset: i
        });
      }
    }
    return t;
  }
};
var Ei = {
  name: "duration",
  initialValue: "0s",
  prefix: false,
  type: 1,
  parse: function(e, A) {
    return A.filter(Ce).map(function(t) {
      return OB.parse(e, t);
    });
  }
};
var Hi = {
  name: "quotes",
  initialValue: "none",
  prefix: true,
  type: 1,
  parse: function(e, A) {
    if (A.length === 0) return null;
    var t = A[0];
    if (t.type === 20 && t.value === "none") return null;
    var r = [], B = A.filter(Zs);
    if (B.length % 2 !== 0) return null;
    for (var n = 0; n < B.length; n += 2) {
      var s = B[n].value, i = B[n + 1].value;
      r.push({
        open: s,
        close: i
      });
    }
    return r;
  }
};
var mt = function(e, A, t) {
  if (!e) return "";
  var r = e[Math.min(A, e.length - 1)];
  return r ? t ? r.open : r.close : "";
};
var pi = {
  name: "box-shadow",
  initialValue: "none",
  type: 1,
  prefix: false,
  parse: function(e, A) {
    return A.length === 1 && Xr(A[0], "none") ? [] : sA(A).map(function(t) {
      for (var r = {
        color: 255,
        offsetX: X,
        offsetY: X,
        blur: X,
        spread: X,
        inset: false
      }, B = 0, n = 0; n < t.length; n++) {
        var s = t[n];
        Xr(s, "inset") ? r.inset = true : pA(s) ? (B === 0 ? r.offsetX = s : B === 1 ? r.offsetY = s : B === 2 ? r.blur = s : r.spread = s, B++) : r.color = EA.parse(e, s);
      }
      return r;
    });
  }
};
var Ii = {
  name: "paint-order",
  initialValue: "normal",
  prefix: false,
  type: 1,
  parse: function(e, A) {
    var t = [
      0,
      1,
      2
      /* MARKERS */
    ], r = [];
    return A.filter(D).forEach(function(B) {
      switch (B.value) {
        case "stroke":
          r.push(
            1
            /* STROKE */
          );
          break;
        case "fill":
          r.push(
            0
            /* FILL */
          );
          break;
        case "markers":
          r.push(
            2
            /* MARKERS */
          );
          break;
      }
    }), t.forEach(function(B) {
      r.indexOf(B) === -1 && r.push(B);
    }), r;
  }
};
var vi = {
  name: "-webkit-text-stroke-color",
  initialValue: "currentcolor",
  prefix: false,
  type: 3,
  format: "color"
};
var yi = {
  name: "-webkit-text-stroke-width",
  initialValue: "0",
  type: 0,
  prefix: false,
  parse: function(e, A) {
    return Ce(A) ? A.number : 0;
  }
};
var Ki = (
  /** @class */
  function() {
    function e(A, t) {
      var r, B;
      this.animationDuration = U(A, Ei, t.animationDuration), this.backgroundClip = U(A, zs, t.backgroundClip), this.backgroundColor = U(A, $s, t.backgroundColor), this.backgroundImage = U(A, oa, t.backgroundImage), this.backgroundOrigin = U(A, Qa, t.backgroundOrigin), this.backgroundPosition = U(A, ga, t.backgroundPosition), this.backgroundRepeat = U(A, wa, t.backgroundRepeat), this.backgroundSize = U(A, Ca, t.backgroundSize), this.borderTopColor = U(A, la, t.borderTopColor), this.borderRightColor = U(A, fa, t.borderRightColor), this.borderBottomColor = U(A, Ua, t.borderBottomColor), this.borderLeftColor = U(A, Fa, t.borderLeftColor), this.borderTopLeftRadius = U(A, ha, t.borderTopLeftRadius), this.borderTopRightRadius = U(A, da, t.borderTopRightRadius), this.borderBottomRightRadius = U(A, Ea, t.borderBottomRightRadius), this.borderBottomLeftRadius = U(A, Ha, t.borderBottomLeftRadius), this.borderTopStyle = U(A, pa, t.borderTopStyle), this.borderRightStyle = U(A, Ia, t.borderRightStyle), this.borderBottomStyle = U(A, va, t.borderBottomStyle), this.borderLeftStyle = U(A, ya, t.borderLeftStyle), this.borderTopWidth = U(A, Ka, t.borderTopWidth), this.borderRightWidth = U(A, ma, t.borderRightWidth), this.borderBottomWidth = U(A, La, t.borderBottomWidth), this.borderLeftWidth = U(A, Da, t.borderLeftWidth), this.boxShadow = U(A, pi, t.boxShadow), this.color = U(A, ba, t.color), this.direction = U(A, xa, t.direction), this.display = U(A, Ta, t.display), this.float = U(A, Oa, t.cssFloat), this.fontFamily = U(A, Ci, t.fontFamily), this.fontSize = U(A, ui, t.fontSize), this.fontStyle = U(A, Ui, t.fontStyle), this.fontVariant = U(A, fi, t.fontVariant), this.fontWeight = U(A, li, t.fontWeight), this.letterSpacing = U(A, Ma, t.letterSpacing), this.lineBreak = U(A, Ga, t.lineBreak), this.lineHeight = U(A, Ra, t.lineHeight), this.listStyleImage = U(A, Va, t.listStyleImage), this.listStylePosition = U(A, Na, t.listStylePosition), this.listStyleType = U(A, _r, t.listStyleType), this.marginTop = U(A, Xa, t.marginTop), this.marginRight = U(A, _a, t.marginRight), this.marginBottom = U(A, Ja, t.marginBottom), this.marginLeft = U(A, Pa, t.marginLeft), this.opacity = U(A, gi, t.opacity);
      var n = U(A, ka, t.overflow);
      this.overflowX = n[0], this.overflowY = n[n.length > 1 ? 1 : 0], this.overflowWrap = U(A, Ya, t.overflowWrap), this.paddingTop = U(A, Wa, t.paddingTop), this.paddingRight = U(A, Za, t.paddingRight), this.paddingBottom = U(A, qa, t.paddingBottom), this.paddingLeft = U(A, ja, t.paddingLeft), this.paintOrder = U(A, Ii, t.paintOrder), this.position = U(A, $a, t.position), this.textAlign = U(A, za, t.textAlign), this.textDecorationColor = U(A, wi, (r = t.textDecorationColor) !== null && r !== void 0 ? r : t.color), this.textDecorationLine = U(A, ci, (B = t.textDecorationLine) !== null && B !== void 0 ? B : t.textDecoration), this.textShadow = U(A, Ai, t.textShadow), this.textTransform = U(A, ei, t.textTransform), this.transform = U(A, ri, t.transform), this.transformOrigin = U(A, ai, t.transformOrigin), this.visibility = U(A, ii, t.visibility), this.webkitTextStrokeColor = U(A, vi, t.webkitTextStrokeColor), this.webkitTextStrokeWidth = U(A, yi, t.webkitTextStrokeWidth), this.wordBreak = U(A, oi, t.wordBreak), this.zIndex = U(A, Qi, t.zIndex);
    }
    return e.prototype.isVisible = function() {
      return this.display > 0 && this.opacity > 0 && this.visibility === 0;
    }, e.prototype.isTransparent = function() {
      return HA(this.backgroundColor);
    }, e.prototype.isTransformed = function() {
      return this.transform !== null;
    }, e.prototype.isPositioned = function() {
      return this.position !== 0;
    }, e.prototype.isPositionedWithZIndex = function() {
      return this.isPositioned() && !this.zIndex.auto;
    }, e.prototype.isFloating = function() {
      return this.float !== 0;
    }, e.prototype.isInlineLevel = function() {
      return G(
        this.display,
        4
        /* INLINE */
      ) || G(
        this.display,
        33554432
        /* INLINE_BLOCK */
      ) || G(
        this.display,
        268435456
        /* INLINE_FLEX */
      ) || G(
        this.display,
        536870912
        /* INLINE_GRID */
      ) || G(
        this.display,
        67108864
        /* INLINE_LIST_ITEM */
      ) || G(
        this.display,
        134217728
        /* INLINE_TABLE */
      );
    }, e;
  }()
);
var mi = (
  /** @class */
  /* @__PURE__ */ function() {
    function e(A, t) {
      this.content = U(A, Fi, t.content), this.quotes = U(A, Hi, t.quotes);
    }
    return e;
  }()
);
var Lt = (
  /** @class */
  /* @__PURE__ */ function() {
    function e(A, t) {
      this.counterIncrement = U(A, hi, t.counterIncrement), this.counterReset = U(A, di, t.counterReset);
    }
    return e;
  }()
);
var U = function(e, A, t) {
  var r = new fB(), B = t !== null && typeof t < "u" ? t.toString() : A.initialValue;
  r.write(B);
  var n = new UB(r.read());
  switch (A.type) {
    case 2:
      var s = n.parseComponentValue();
      return A.parse(e, D(s) ? s.value : A.initialValue);
    case 0:
      return A.parse(e, n.parseComponentValue());
    case 1:
      return A.parse(e, n.parseComponentValues());
    case 4:
      return n.parseComponentValue();
    case 3:
      switch (A.format) {
        case "angle":
          return Ar.parse(e, n.parseComponentValue());
        case "color":
          return EA.parse(e, n.parseComponentValue());
        case "image":
          return At.parse(e, n.parseComponentValue());
        case "length":
          var i = n.parseComponentValue();
          return pA(i) ? i : X;
        case "length-percentage":
          var a = n.parseComponentValue();
          return M(a) ? a : X;
        case "time":
          return OB.parse(e, n.parseComponentValue());
      }
      break;
  }
};
var Li = "data-html2canvas-debug";
var Di = function(e) {
  var A = e.getAttribute(Li);
  switch (A) {
    case "all":
      return 1;
    case "clone":
      return 2;
    case "parse":
      return 3;
    case "render":
      return 4;
    default:
      return 0;
  }
};
var Jr = function(e, A) {
  var t = Di(e);
  return t === 1 || A === t;
};
var aA = (
  /** @class */
  /* @__PURE__ */ function() {
    function e(A, t) {
      if (this.context = A, this.textNodes = [], this.elements = [], this.flags = 0, Jr(
        t,
        3
        /* PARSE */
      )) debugger;
      this.styles = new Ki(A, window.getComputedStyle(t, null)), Yr(t) && (this.styles.animationDuration.some(function(r) {
        return r > 0;
      }) && (t.style.animationDuration = "0s"), this.styles.transform !== null && (t.style.transform = "none")), this.bounds = ze(this.context, t), Jr(
        t,
        4
        /* RENDER */
      ) && (this.flags |= 16);
    }
    return e;
  }()
);
var bi = "AAAAAAAAAAAAEA4AGBkAAFAaAAACAAAAAAAIABAAGAAwADgACAAQAAgAEAAIABAACAAQAAgAEAAIABAACAAQAAgAEAAIABAAQABIAEQATAAIABAACAAQAAgAEAAIABAAVABcAAgAEAAIABAACAAQAGAAaABwAHgAgACIAI4AlgAIABAAmwCjAKgAsAC2AL4AvQDFAMoA0gBPAVYBWgEIAAgACACMANoAYgFkAWwBdAF8AX0BhQGNAZUBlgGeAaMBlQGWAasBswF8AbsBwwF0AcsBYwHTAQgA2wG/AOMBdAF8AekB8QF0AfkB+wHiAHQBfAEIAAMC5gQIAAsCEgIIAAgAFgIeAggAIgIpAggAMQI5AkACygEIAAgASAJQAlgCYAIIAAgACAAKBQoFCgUTBRMFGQUrBSsFCAAIAAgACAAIAAgACAAIAAgACABdAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACABoAmgCrwGvAQgAbgJ2AggAHgEIAAgACADnAXsCCAAIAAgAgwIIAAgACAAIAAgACACKAggAkQKZAggAPADJAAgAoQKkAqwCsgK6AsICCADJAggA0AIIAAgACAAIANYC3gIIAAgACAAIAAgACABAAOYCCAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAkASoB+QIEAAgACAA8AEMCCABCBQgACABJBVAFCAAIAAgACAAIAAgACAAIAAgACABTBVoFCAAIAFoFCABfBWUFCAAIAAgACAAIAAgAbQUIAAgACAAIAAgACABzBXsFfQWFBYoFigWKBZEFigWKBYoFmAWfBaYFrgWxBbkFCAAIAAgACAAIAAgACAAIAAgACAAIAMEFCAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAMgFCADQBQgACAAIAAgACAAIAAgACAAIAAgACAAIAO4CCAAIAAgAiQAIAAgACABAAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAD0AggACAD8AggACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIANYFCAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAMDvwAIAAgAJAIIAAgACAAIAAgACAAIAAgACwMTAwgACAB9BOsEGwMjAwgAKwMyAwsFYgE3A/MEPwMIAEUDTQNRAwgAWQOsAGEDCAAIAAgACAAIAAgACABpAzQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFIQUoBSwFCAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACABtAwgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACABMAEwACAAIAAgACAAIABgACAAIAAgACAC/AAgACAAyAQgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACACAAIAAwAAgACAAIAAgACAAIAAgACAAIAAAARABIAAgACAAIABQASAAIAAgAIABwAEAAjgCIABsAqAC2AL0AigDQAtwC+IJIQqVAZUBWQqVAZUBlQGVAZUBlQGrC5UBlQGVAZUBlQGVAZUBlQGVAXsKlQGVAbAK6wsrDGUMpQzlDJUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAfAKAAuZA64AtwCJALoC6ADwAAgAuACgA/oEpgO6AqsD+AAIAAgAswMIAAgACAAIAIkAuwP5AfsBwwPLAwgACAAIAAgACADRA9kDCAAIAOED6QMIAAgACAAIAAgACADuA/YDCAAIAP4DyQAIAAgABgQIAAgAXQAOBAgACAAIAAgACAAIABMECAAIAAgACAAIAAgACAD8AAQBCAAIAAgAGgQiBCoECAExBAgAEAEIAAgACAAIAAgACAAIAAgACAAIAAgACAA4BAgACABABEYECAAIAAgATAQYAQgAVAQIAAgACAAIAAgACAAIAAgACAAIAFoECAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgAOQEIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAB+BAcACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAEABhgSMBAgACAAIAAgAlAQIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAwAEAAQABAADAAMAAwADAAQABAAEAAQABAAEAAQABHATAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgAdQMIAAgACAAIAAgACAAIAMkACAAIAAgAfQMIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACACFA4kDCAAIAAgACAAIAOcBCAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAIcDCAAIAAgACAAIAAgACAAIAAgACAAIAJEDCAAIAAgACADFAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACABgBAgAZgQIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgAbAQCBXIECAAIAHkECAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACABAAJwEQACjBKoEsgQIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAC6BMIECAAIAAgACAAIAAgACABmBAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgAxwQIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAGYECAAIAAgAzgQIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgAigWKBYoFigWKBYoFigWKBd0FXwUIAOIF6gXxBYoF3gT5BQAGCAaKBYoFigWKBYoFigWKBYoFigWKBYoFigXWBIoFigWKBYoFigWKBYoFigWKBYsFEAaKBYoFigWKBYoFigWKBRQGCACKBYoFigWKBQgACAAIANEECAAIABgGigUgBggAJgYIAC4GMwaKBYoF0wQ3Bj4GigWKBYoFigWKBYoFigWKBYoFigWKBYoFigUIAAgACAAIAAgACAAIAAgAigWKBYoFigWKBYoFigWKBYoFigWKBYoFigWKBYoFigWKBYoFigWKBYoFigWKBYoFigWKBYoFigWKBYoFigWLBf///////wQABAAEAAQABAAEAAQABAAEAAQAAwAEAAQAAgAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAAAAAAAAAAAAAAAAAAAAAAAAAOAAAAAAAAAAQADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUABQAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAAAUAAAAFAAUAAAAFAAUAAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAEAAQABAAEAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUABQAFAAUABQAFAAUABQAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUABQAFAAUAAQAAAAUABQAFAAUABQAFAAAAAAAFAAUAAAAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAUABQAFAAUABQAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAFAAAAAAAFAAUAAQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABwAFAAUABQAFAAAABwAHAAcAAAAHAAcABwAFAAEAAAAAAAAAAAAAAAAAAAAAAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHAAcABwAFAAUABQAFAAcABwAFAAUAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHAAAAAQABAAAAAAAAAAAAAAAFAAUABQAFAAAABwAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAHAAcABwAHAAcAAAAHAAcAAAAAAAUABQAHAAUAAQAHAAEABwAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUABQAFAAUABwABAAUABQAFAAUAAAAAAAAAAAAAAAEAAQABAAEAAQABAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABwAFAAUAAAAAAAAAAAAAAAAABQAFAAUABQAFAAUAAQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQABQANAAQABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQABAAEAAQABAAEAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAEAAQABAAEAAQABAAEAAQABAAEAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAQABAAEAAQABAAEAAQABAAAAAAAAAAAAAAAAAAAAAAABQAHAAUABQAFAAAAAAAAAAcABQAFAAUABQAFAAQABAAEAAQABAAEAAQABAAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUAAAAFAAUABQAFAAUAAAAFAAUABQAAAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAAAAAAAAAAAAUABQAFAAcAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAHAAUAAAAHAAcABwAFAAUABQAFAAUABQAFAAUABwAHAAcABwAFAAcABwAAAAUABQAFAAUABQAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABwAHAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAUABwAHAAUABQAFAAUAAAAAAAcABwAAAAAABwAHAAUAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAAABQAFAAcAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAAABwAHAAcABQAFAAAAAAAAAAAABQAFAAAAAAAFAAUABQAAAAAAAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAAAAAAAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAAABwAFAAUABQAFAAUAAAAFAAUABwAAAAcABwAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUAAAAFAAUABwAFAAUABQAFAAAAAAAHAAcAAAAAAAcABwAFAAAAAAAAAAAAAAAAAAAABQAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAcABwAAAAAAAAAHAAcABwAAAAcABwAHAAUAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAAAAAAAAAAAAAAAAAAABQAHAAcABwAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABwAHAAcABwAAAAUABQAFAAAABQAFAAUABQAAAAAAAAAAAAAAAAAAAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAcABQAHAAcABQAHAAcAAAAFAAcABwAAAAcABwAFAAUAAAAAAAAAAAAAAAAAAAAFAAUAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAcABwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAAAAUABwAAAAAAAAAAAAAAAAAAAAAAAAAAAAUAAAAAAAAAAAAFAAcABwAFAAUABQAAAAUAAAAHAAcABwAHAAcABwAHAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUAAAAHAAUABQAFAAUABQAFAAUAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAAABwAFAAUABQAFAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUABQAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAUAAAAFAAAAAAAAAAAABwAHAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABwAFAAUABQAFAAUAAAAFAAUAAAAAAAAAAAAAAAUABQAFAAUABQAFAAUABQAFAAUABQAAAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUABwAFAAUABQAFAAUABQAAAAUABQAHAAcABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHAAcABQAFAAAAAAAAAAAABQAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAcABQAFAAAAAAAAAAAAAAAAAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAHAAUABQAFAAUABQAFAAUABwAHAAcABwAHAAcABwAHAAUABwAHAAUABQAFAAUABQAFAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUABwAHAAcABwAFAAUABwAHAAcAAAAAAAAAAAAHAAcABQAHAAcABwAHAAcABwAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAcABwAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAcABQAHAAUABQAFAAUABQAFAAUAAAAFAAAABQAAAAAABQAFAAUABQAFAAUABQAFAAcABwAHAAcABwAHAAUABQAFAAUABQAFAAUABQAFAAUAAAAAAAUABQAFAAUABQAHAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUABQAFAAUABwAFAAcABwAHAAcABwAFAAcABwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHAAUABQAFAAUABwAHAAUABQAHAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAcABQAFAAcABwAHAAUABwAFAAUABQAHAAcAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABwAHAAcABwAHAAcABwAHAAUABQAFAAUABQAFAAUABQAHAAcABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUAAAAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAcABQAFAAUABQAFAAUABQAAAAAAAAAAAAUAAAAAAAAAAAAAAAAABQAAAAAABwAFAAUAAAAAAAAAAAAAAAAABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAAABQAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUABQAFAAUADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUAAAAFAAUABQAFAAUABQAFAAUABQAFAAAAAAAAAAAABQAAAAAAAAAFAAAAAAAAAAAABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABwAHAAUABQAHAAAAAAAAAAAABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAcABwAHAAcABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUAAAAAAAAAAAAAAAAABQAFAAUABQAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUABQAFAAUABQAFAAUABQAHAAcAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAcABwAFAAUABQAFAAcABwAFAAUABwAHAAAAAAAAAAAAAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUABQAFAAcABwAFAAUABwAHAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAAAAAAAAAAAAAAAAAAAAAAFAAcAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUAAAAFAAUABQAAAAAABQAFAAAAAAAAAAAAAAAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAcABQAFAAcABwAAAAAAAAAAAAAABwAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAcABwAFAAcABwAFAAcABwAAAAcABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUABQAAAAAAAAAAAAAAAAAFAAUABQAAAAUABQAAAAAAAAAAAAAABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAAAAAAAAAAAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAcABQAHAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAUABwAFAAUABQAFAAUABQAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABwAHAAcABQAFAAUABQAFAAUABQAFAAUABwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHAAcABwAFAAUABQAHAAcABQAHAAUABQAAAAAAAAAAAAAAAAAFAAAABwAHAAcABQAFAAUABQAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABwAHAAcABwAAAAAABwAHAAAAAAAHAAcABwAAAAAAAAAAAAAAAAAAAAAAAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAAABwAHAAAAAAAFAAUABQAFAAUABQAFAAAAAAAAAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHAAcABwAFAAUABQAFAAUABQAFAAUABwAHAAUABQAFAAcABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAHAAcABQAFAAUABQAFAAUABwAFAAcABwAFAAcABQAFAAcABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAHAAcABQAFAAUABQAAAAAABwAHAAcABwAFAAUABwAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAcABwAHAAUABQAFAAUABQAFAAUABQAHAAcABQAHAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABwAFAAcABwAFAAUABQAFAAUABQAHAAUAAAAAAAAAAAAAAAAAAAAAAAcABwAFAAUABQAFAAcABQAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHAAcABwAFAAUABQAFAAUABQAFAAUABQAHAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHAAcABwAFAAUABQAFAAAAAAAFAAUABwAHAAcABwAFAAAAAAAAAAcAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAUABQAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUABQAFAAUABwAHAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAcABQAFAAUABQAFAAUABQAAAAUABQAFAAUABQAFAAcABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAAAHAAUABQAFAAUABQAFAAUABwAFAAUABwAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUABQAFAAUAAAAAAAAABQAAAAUABQAAAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAHAAcABwAHAAcAAAAFAAUAAAAHAAcABQAHAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABwAHAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAAAAAAAAAAAAAAAAAAABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAcABwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAAAAUABQAFAAAAAAAFAAUABQAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAAAAAAAAAAABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUABQAAAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUABQAFAAUABQAAAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAAAAABQAFAAUABQAFAAUABQAAAAUABQAAAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAFAAUABQAFAAUADgAOAA4ADgAOAA4ADwAPAA8ADwAPAA8ADwAPAA8ADwAPAA8ADwAPAA8ADwAPAA8ADwAPAA8ADwAPAA8ADwAPAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAcABwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABwAHAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAAAAAAAAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAKAAoACgAKAAoACgAKAAoACgAKAAoACgAKAAoACgAKAAoACgAKAAoACgAKAAoACgAMAAwADAAMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkAAAAAAAAAAAAKAAoACgAKAAoACgAKAAoACgAKAAoACgAKAAoACgAKAAoACgAKAAoACgAKAAoACgAKAAoACgAKAAoACgAKAAoACgAAAAAAAAAAAAsADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwACwAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAAAAAADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAA4ADgAOAA4ADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA4ADgAAAAAAAAAAAAAAAAAAAAAADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAOAA4ADgAOAA4ADgAOAA4ADgAOAAAAAAAAAAAADgAOAA4AAAAAAAAAAAAAAAAAAAAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAOAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAAAAAAAAAAAAAAAAAAAAAAAAAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAOAA4ADgAAAA4ADgAOAA4ADgAOAAAADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4AAAAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4AAAAAAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAAAA4AAAAOAAAAAAAAAAAAAAAAAA4AAAAAAAAAAAAAAAAADgAAAAAAAAAAAAAAAAAAAAAAAAAAAA4ADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAAAAAADgAAAAAAAAAAAA4AAAAOAAAAAAAAAAAADgAOAA4AAAAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAA4ADgAOAA4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAA4ADgAAAAAAAAAAAAAAAAAAAAAAAAAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAA4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA4ADgAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAAAAAAAAAAAA4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAAAADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAA4ADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA4ADgAOAA4ADgAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA4ADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAAAAAADgAOAA4ADgAOAA4ADgAOAA4ADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAAAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA4AAAAAAA4ADgAOAA4ADgAOAA4ADgAOAAAADgAOAA4ADgAAAAAAAAAAAAAAAAAAAAAAAAAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4AAAAAAAAAAAAAAAAADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAA4ADgAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAOAA4ADgAOAA4ADgAOAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAOAA4ADgAOAA4AAAAAAAAAAAAAAAAAAAAAAA4ADgAOAA4ADgAOAA4ADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4AAAAOAA4ADgAOAA4ADgAAAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4AAAAAAAAAAAA=";
var Dt = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
var te = typeof Uint8Array > "u" ? [] : new Uint8Array(256);
for (be = 0; be < Dt.length; be++) te[Dt.charCodeAt(be)] = be;
var be;
var xi = function(e) {
  var A = e.length * 0.75, t = e.length, r, B = 0, n, s, i, a;
  e[e.length - 1] === "=" && (A--, e[e.length - 2] === "=" && A--);
  var o = typeof ArrayBuffer < "u" && typeof Uint8Array < "u" && typeof Uint8Array.prototype.slice < "u" ? new ArrayBuffer(A) : new Array(A), Q = Array.isArray(o) ? o : new Uint8Array(o);
  for (r = 0; r < t; r += 4) n = te[e.charCodeAt(r)], s = te[e.charCodeAt(r + 1)], i = te[e.charCodeAt(r + 2)], a = te[e.charCodeAt(r + 3)], Q[B++] = n << 2 | s >> 4, Q[B++] = (s & 15) << 4 | i >> 2, Q[B++] = (i & 3) << 6 | a & 63;
  return o;
};
var Ti = function(e) {
  for (var A = e.length, t = [], r = 0; r < A; r += 2) t.push(e[r + 1] << 8 | e[r]);
  return t;
};
var Si = function(e) {
  for (var A = e.length, t = [], r = 0; r < A; r += 4) t.push(e[r + 3] << 24 | e[r + 2] << 16 | e[r + 1] << 8 | e[r]);
  return t;
};
var xA = 5;
var et = 6 + 5;
var lr = 2;
var Oi = et - xA;
var MB = 65536 >> xA;
var Mi = 1 << xA;
var fr = Mi - 1;
var Gi = 1024 >> xA;
var Ri = MB + Gi;
var Vi = Ri;
var Ni = 32;
var Xi = Vi + Ni;
var _i = 65536 >> et;
var Ji = 1 << Oi;
var Pi = Ji - 1;
var bt = function(e, A, t) {
  return e.slice ? e.slice(A, t) : new Uint16Array(Array.prototype.slice.call(e, A, t));
};
var ki = function(e, A, t) {
  return e.slice ? e.slice(A, t) : new Uint32Array(Array.prototype.slice.call(e, A, t));
};
var Yi = function(e, A) {
  var t = xi(e), r = Array.isArray(t) ? Si(t) : new Uint32Array(t), B = Array.isArray(t) ? Ti(t) : new Uint16Array(t), n = 24, s = bt(B, n / 2, r[4] / 2), i = r[5] === 2 ? bt(B, (n + r[4]) / 2) : ki(r, Math.ceil((n + r[4]) / 4));
  return new Wi(r[0], r[1], r[2], r[3], s, i);
};
var Wi = (
  /** @class */
  function() {
    function e(A, t, r, B, n, s) {
      this.initialValue = A, this.errorValue = t, this.highStart = r, this.highValueIndex = B, this.index = n, this.data = s;
    }
    return e.prototype.get = function(A) {
      var t;
      if (A >= 0) {
        if (A < 55296 || A > 56319 && A <= 65535) return t = this.index[A >> xA], t = (t << lr) + (A & fr), this.data[t];
        if (A <= 65535) return t = this.index[MB + (A - 55296 >> xA)], t = (t << lr) + (A & fr), this.data[t];
        if (A < this.highStart) return t = Xi - _i + (A >> et), t = this.index[t], t += A >> xA & Pi, t = this.index[t], t = (t << lr) + (A & fr), this.data[t];
        if (A <= 1114111) return this.data[this.highValueIndex];
      }
      return this.errorValue;
    }, e;
  }()
);
var xt = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
var Zi = typeof Uint8Array > "u" ? [] : new Uint8Array(256);
for (xe = 0; xe < xt.length; xe++) Zi[xt.charCodeAt(xe)] = xe;
var xe;
var qi = 1;
var Ur = 2;
var Fr = 3;
var Tt = 4;
var St = 5;
var ji = 7;
var Ot = 8;
var hr = 9;
var dr = 10;
var Mt = 11;
var Gt = 12;
var Rt = 13;
var Vt = 14;
var Er = 15;
var zi = function(e) {
  for (var A = [], t = 0, r = e.length; t < r; ) {
    var B = e.charCodeAt(t++);
    if (B >= 55296 && B <= 56319 && t < r) {
      var n = e.charCodeAt(t++);
      (n & 64512) === 56320 ? A.push(((B & 1023) << 10) + (n & 1023) + 65536) : (A.push(B), t--);
    } else A.push(B);
  }
  return A;
};
var $i = function() {
  for (var e = [], A = 0; A < arguments.length; A++) e[A] = arguments[A];
  if (String.fromCodePoint) return String.fromCodePoint.apply(String, e);
  var t = e.length;
  if (!t) return "";
  for (var r = [], B = -1, n = ""; ++B < t; ) {
    var s = e[B];
    s <= 65535 ? r.push(s) : (s -= 65536, r.push((s >> 10) + 55296, s % 1024 + 56320)), (B + 1 === t || r.length > 16384) && (n += String.fromCharCode.apply(String, r), r.length = 0);
  }
  return n;
};
var Ao = Yi(bi);
var z = "×";
var Hr = "÷";
var eo = function(e) {
  return Ao.get(e);
};
var ro = function(e, A, t) {
  var r = t - 2, B = A[r], n = A[t - 1], s = A[t];
  if (n === Ur && s === Fr) return z;
  if (n === Ur || n === Fr || n === Tt || s === Ur || s === Fr || s === Tt) return Hr;
  if (n === Ot && [Ot, hr, Mt, Gt].indexOf(s) !== -1 || (n === Mt || n === hr) && (s === hr || s === dr) || (n === Gt || n === dr) && s === dr || s === Rt || s === St || s === ji || n === qi) return z;
  if (n === Rt && s === Vt) {
    for (; B === St; ) B = A[--r];
    if (B === Vt) return z;
  }
  if (n === Er && s === Er) {
    for (var i = 0; B === Er; ) i++, B = A[--r];
    if (i % 2 === 0) return z;
  }
  return Hr;
};
var to = function(e) {
  var A = zi(e), t = A.length, r = 0, B = 0, n = A.map(eo);
  return {
    next: function() {
      if (r >= t) return {
        done: true,
        value: null
      };
      for (var s = z; r < t && (s = ro(A, n, ++r)) === z; ) ;
      if (s !== z || r === t) {
        var i = $i.apply(null, A.slice(B, r));
        return B = r, {
          value: i,
          done: false
        };
      }
      return {
        done: true,
        value: null
      };
    }
  };
};
var Bo = function(e) {
  for (var A = to(e), t = [], r; !(r = A.next()).done; ) r.value && t.push(r.value.slice());
  return t;
};
var no = function(e) {
  var A = 123;
  if (e.createRange) {
    var t = e.createRange();
    if (t.getBoundingClientRect) {
      var r = e.createElement("boundtest");
      r.style.height = A + "px", r.style.display = "block", e.body.appendChild(r), t.selectNode(r);
      var B = t.getBoundingClientRect(), n = Math.round(B.height);
      if (e.body.removeChild(r), n === A) return true;
    }
  }
  return false;
};
var so = function(e) {
  var A = e.createElement("boundtest");
  A.style.width = "50px", A.style.display = "block", A.style.fontSize = "12px", A.style.letterSpacing = "0px", A.style.wordSpacing = "0px", e.body.appendChild(A);
  var t = e.createRange();
  A.innerHTML = typeof "".repeat == "function" ? "&#128104;".repeat(10) : "";
  var r = A.firstChild, B = $e(r.data).map(function(a) {
    return S(a);
  }), n = 0, s = {}, i = B.every(function(a, o) {
    t.setStart(r, n), t.setEnd(r, n + a.length);
    var Q = t.getBoundingClientRect();
    n += a.length;
    var g = Q.x > s.x || Q.y > s.y;
    return s = Q, o === 0 ? true : g;
  });
  return e.body.removeChild(A), i;
};
var ao = function() {
  return typeof new Image().crossOrigin < "u";
};
var io = function() {
  return typeof new XMLHttpRequest().responseType == "string";
};
var oo = function(e) {
  var A = new Image(), t = e.createElement("canvas"), r = t.getContext("2d");
  if (!r) return false;
  A.src = "data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg'></svg>";
  try {
    r.drawImage(A, 0, 0), t.toDataURL();
  } catch {
    return false;
  }
  return true;
};
var Nt = function(e) {
  return e[0] === 0 && e[1] === 255 && e[2] === 0 && e[3] === 255;
};
var Qo = function(e) {
  var A = e.createElement("canvas"), t = 100;
  A.width = t, A.height = t;
  var r = A.getContext("2d");
  if (!r) return Promise.reject(false);
  r.fillStyle = "rgb(0, 255, 0)", r.fillRect(0, 0, t, t);
  var B = new Image(), n = A.toDataURL();
  B.src = n;
  var s = Pr(t, t, 0, 0, B);
  return r.fillStyle = "red", r.fillRect(0, 0, t, t), Xt(s).then(function(i) {
    r.drawImage(i, 0, 0);
    var a = r.getImageData(0, 0, t, t).data;
    r.fillStyle = "red", r.fillRect(0, 0, t, t);
    var o = e.createElement("div");
    return o.style.backgroundImage = "url(" + n + ")", o.style.height = t + "px", Nt(a) ? Xt(Pr(t, t, 0, 0, o)) : Promise.reject(false);
  }).then(function(i) {
    return r.drawImage(i, 0, 0), Nt(r.getImageData(0, 0, t, t).data);
  }).catch(function() {
    return false;
  });
};
var Pr = function(e, A, t, r, B) {
  var n = "http://www.w3.org/2000/svg", s = document.createElementNS(n, "svg"), i = document.createElementNS(n, "foreignObject");
  return s.setAttributeNS(null, "width", e.toString()), s.setAttributeNS(null, "height", A.toString()), i.setAttributeNS(null, "width", "100%"), i.setAttributeNS(null, "height", "100%"), i.setAttributeNS(null, "x", t.toString()), i.setAttributeNS(null, "y", r.toString()), i.setAttributeNS(null, "externalResourcesRequired", "true"), s.appendChild(i), i.appendChild(B), s;
};
var Xt = function(e) {
  return new Promise(function(A, t) {
    var r = new Image();
    r.onload = function() {
      return A(r);
    }, r.onerror = t, r.src = "data:image/svg+xml;charset=utf-8," + encodeURIComponent(new XMLSerializer().serializeToString(e));
  });
};
var N = {
  get SUPPORT_RANGE_BOUNDS() {
    var e = no(document);
    return Object.defineProperty(N, "SUPPORT_RANGE_BOUNDS", {
      value: e
    }), e;
  },
  get SUPPORT_WORD_BREAKING() {
    var e = N.SUPPORT_RANGE_BOUNDS && so(document);
    return Object.defineProperty(N, "SUPPORT_WORD_BREAKING", {
      value: e
    }), e;
  },
  get SUPPORT_SVG_DRAWING() {
    var e = oo(document);
    return Object.defineProperty(N, "SUPPORT_SVG_DRAWING", {
      value: e
    }), e;
  },
  get SUPPORT_FOREIGNOBJECT_DRAWING() {
    var e = typeof Array.from == "function" && typeof window.fetch == "function" ? Qo(document) : Promise.resolve(false);
    return Object.defineProperty(N, "SUPPORT_FOREIGNOBJECT_DRAWING", {
      value: e
    }), e;
  },
  get SUPPORT_CORS_IMAGES() {
    var e = ao();
    return Object.defineProperty(N, "SUPPORT_CORS_IMAGES", {
      value: e
    }), e;
  },
  get SUPPORT_RESPONSE_TYPE() {
    var e = io();
    return Object.defineProperty(N, "SUPPORT_RESPONSE_TYPE", {
      value: e
    }), e;
  },
  get SUPPORT_CORS_XHR() {
    var e = "withCredentials" in new XMLHttpRequest();
    return Object.defineProperty(N, "SUPPORT_CORS_XHR", {
      value: e
    }), e;
  },
  get SUPPORT_NATIVE_TEXT_SEGMENTATION() {
    var e = !!(typeof Intl < "u" && Intl.Segmenter);
    return Object.defineProperty(N, "SUPPORT_NATIVE_TEXT_SEGMENTATION", {
      value: e
    }), e;
  }
};
var ie = (
  /** @class */
  /* @__PURE__ */ function() {
    function e(A, t) {
      this.text = A, this.bounds = t;
    }
    return e;
  }()
);
var go = function(e, A, t, r) {
  var B = Co(A, t), n = [], s = 0;
  return B.forEach(function(i) {
    if (t.textDecorationLine.length || i.trim().length > 0) {
      if (N.SUPPORT_RANGE_BOUNDS) {
        var a = _t(r, s, i.length).getClientRects();
        if (a.length > 1) {
          var o = rt(i), Q = 0;
          o.forEach(function(w) {
            n.push(new ie(w, cA.fromDOMRectList(e, _t(r, Q + s, w.length).getClientRects()))), Q += w.length;
          });
        } else n.push(new ie(i, cA.fromDOMRectList(e, a)));
      } else {
        var g = r.splitText(i.length);
        n.push(new ie(i, wo(e, r))), r = g;
      }
    } else N.SUPPORT_RANGE_BOUNDS || (r = r.splitText(i.length));
    s += i.length;
  }), n;
};
var wo = function(e, A) {
  var t = A.ownerDocument;
  if (t) {
    var r = t.createElement("html2canvaswrapper");
    r.appendChild(A.cloneNode(true));
    var B = A.parentNode;
    if (B) {
      B.replaceChild(r, A);
      var n = ze(e, r);
      return r.firstChild && B.replaceChild(r.firstChild, r), n;
    }
  }
  return cA.EMPTY;
};
var _t = function(e, A, t) {
  var r = e.ownerDocument;
  if (!r) throw new Error("Node has no owner document");
  var B = r.createRange();
  return B.setStart(e, A), B.setEnd(e, A + t), B;
};
var rt = function(e) {
  if (N.SUPPORT_NATIVE_TEXT_SEGMENTATION) {
    var A = new Intl.Segmenter(void 0, {
      granularity: "grapheme"
    });
    return Array.from(A.segment(e)).map(function(t) {
      return t.segment;
    });
  }
  return Bo(e);
};
var co = function(e, A) {
  if (N.SUPPORT_NATIVE_TEXT_SEGMENTATION) {
    var t = new Intl.Segmenter(void 0, {
      granularity: "word"
    });
    return Array.from(t.segment(e)).map(function(r) {
      return r.segment;
    });
  }
  return lo(e, A);
};
var Co = function(e, A) {
  return A.letterSpacing !== 0 ? rt(e) : co(e, A);
};
var uo = [32, 160, 4961, 65792, 65793, 4153, 4241];
var lo = function(e, A) {
  for (var t = _n(e, {
    lineBreak: A.lineBreak,
    wordBreak: A.overflowWrap === "break-word" ? "break-word" : A.wordBreak
  }), r = [], B, n = function() {
    if (B.value) {
      var s = B.value.slice(), i = $e(s), a = "";
      i.forEach(function(o) {
        uo.indexOf(o) === -1 ? a += S(o) : (a.length && r.push(a), r.push(S(o)), a = "");
      }), a.length && r.push(a);
    }
  }; !(B = t.next()).done; ) n();
  return r;
};
var fo = (
  /** @class */
  /* @__PURE__ */ function() {
    function e(A, t, r) {
      this.text = Uo(t.data, r.textTransform), this.textBounds = go(A, this.text, r, t);
    }
    return e;
  }()
);
var Uo = function(e, A) {
  switch (A) {
    case 1:
      return e.toLowerCase();
    case 3:
      return e.replace(Fo, ho);
    case 2:
      return e.toUpperCase();
    default:
      return e;
  }
};
var Fo = /(^|\s|:|-|\(|\))([a-z])/g;
var ho = function(e, A, t) {
  return e.length > 0 ? A + t.toUpperCase() : e;
};
var GB = (
  /** @class */
  function(e) {
    tA(A, e);
    function A(t, r) {
      var B = e.call(this, t, r) || this;
      return B.src = r.currentSrc || r.src, B.intrinsicWidth = r.naturalWidth, B.intrinsicHeight = r.naturalHeight, B.context.cache.addImage(B.src), B;
    }
    return A;
  }(aA)
);
var RB = (
  /** @class */
  function(e) {
    tA(A, e);
    function A(t, r) {
      var B = e.call(this, t, r) || this;
      return B.canvas = r, B.intrinsicWidth = r.width, B.intrinsicHeight = r.height, B;
    }
    return A;
  }(aA)
);
var VB = (
  /** @class */
  function(e) {
    tA(A, e);
    function A(t, r) {
      var B = e.call(this, t, r) || this, n = new XMLSerializer(), s = ze(t, r);
      return r.setAttribute("width", s.width + "px"), r.setAttribute("height", s.height + "px"), B.svg = "data:image/svg+xml," + encodeURIComponent(n.serializeToString(r)), B.intrinsicWidth = r.width.baseVal.value, B.intrinsicHeight = r.height.baseVal.value, B.context.cache.addImage(B.svg), B;
    }
    return A;
  }(aA)
);
var NB = (
  /** @class */
  function(e) {
    tA(A, e);
    function A(t, r) {
      var B = e.call(this, t, r) || this;
      return B.value = r.value, B;
    }
    return A;
  }(aA)
);
var kr = (
  /** @class */
  function(e) {
    tA(A, e);
    function A(t, r) {
      var B = e.call(this, t, r) || this;
      return B.start = r.start, B.reversed = typeof r.reversed == "boolean" && r.reversed === true, B;
    }
    return A;
  }(aA)
);
var Eo = [{
  type: 15,
  flags: 0,
  unit: "px",
  number: 3
}];
var Ho = [{
  type: 16,
  flags: 0,
  number: 50
}];
var po = function(e) {
  return e.width > e.height ? new cA(e.left + (e.width - e.height) / 2, e.top, e.height, e.height) : e.width < e.height ? new cA(e.left, e.top + (e.height - e.width) / 2, e.width, e.width) : e;
};
var Io = function(e) {
  var A = e.type === vo ? new Array(e.value.length + 1).join("•") : e.value;
  return A.length === 0 ? e.placeholder || "" : A;
};
var Pe = "checkbox";
var ke = "radio";
var vo = "password";
var Jt = 707406591;
var tt = (
  /** @class */
  function(e) {
    tA(A, e);
    function A(t, r) {
      var B = e.call(this, t, r) || this;
      switch (B.type = r.type.toLowerCase(), B.checked = r.checked, B.value = Io(r), (B.type === Pe || B.type === ke) && (B.styles.backgroundColor = 3739148031, B.styles.borderTopColor = B.styles.borderRightColor = B.styles.borderBottomColor = B.styles.borderLeftColor = 2779096575, B.styles.borderTopWidth = B.styles.borderRightWidth = B.styles.borderBottomWidth = B.styles.borderLeftWidth = 1, B.styles.borderTopStyle = B.styles.borderRightStyle = B.styles.borderBottomStyle = B.styles.borderLeftStyle = 1, B.styles.backgroundClip = [
        0
        /* BORDER_BOX */
      ], B.styles.backgroundOrigin = [
        0
        /* BORDER_BOX */
      ], B.bounds = po(B.bounds)), B.type) {
        case Pe:
          B.styles.borderTopRightRadius = B.styles.borderTopLeftRadius = B.styles.borderBottomRightRadius = B.styles.borderBottomLeftRadius = Eo;
          break;
        case ke:
          B.styles.borderTopRightRadius = B.styles.borderTopLeftRadius = B.styles.borderBottomRightRadius = B.styles.borderBottomLeftRadius = Ho;
          break;
      }
      return B;
    }
    return A;
  }(aA)
);
var XB = (
  /** @class */
  function(e) {
    tA(A, e);
    function A(t, r) {
      var B = e.call(this, t, r) || this, n = r.options[r.selectedIndex || 0];
      return B.value = n && n.text || "", B;
    }
    return A;
  }(aA)
);
var _B = (
  /** @class */
  function(e) {
    tA(A, e);
    function A(t, r) {
      var B = e.call(this, t, r) || this;
      return B.value = r.value, B;
    }
    return A;
  }(aA)
);
var JB = (
  /** @class */
  function(e) {
    tA(A, e);
    function A(t, r) {
      var B = e.call(this, t, r) || this;
      B.src = r.src, B.width = parseInt(r.width, 10) || 0, B.height = parseInt(r.height, 10) || 0, B.backgroundColor = B.styles.backgroundColor;
      try {
        if (r.contentWindow && r.contentWindow.document && r.contentWindow.document.documentElement) {
          B.tree = kB(t, r.contentWindow.document.documentElement);
          var n = r.contentWindow.document.documentElement ? se(t, getComputedStyle(r.contentWindow.document.documentElement).backgroundColor) : wA.TRANSPARENT, s = r.contentWindow.document.body ? se(t, getComputedStyle(r.contentWindow.document.body).backgroundColor) : wA.TRANSPARENT;
          B.backgroundColor = HA(n) ? HA(s) ? B.styles.backgroundColor : s : n;
        }
      } catch {
      }
      return B;
    }
    return A;
  }(aA)
);
var yo = ["OL", "UL", "MENU"];
var Ve = function(e, A, t, r) {
  for (var B = A.firstChild, n = void 0; B; B = n) if (n = B.nextSibling, YB(B) && B.data.trim().length > 0) t.textNodes.push(new fo(e, B, t.styles));
  else if (_A(B)) if (jB(B) && B.assignedNodes) B.assignedNodes().forEach(function(i) {
    return Ve(e, i, t, r);
  });
  else {
    var s = PB(e, B);
    s.styles.isVisible() && (Ko(B, s, r) ? s.flags |= 4 : mo(s.styles) && (s.flags |= 2), yo.indexOf(B.tagName) !== -1 && (s.flags |= 8), t.elements.push(s), B.slot, B.shadowRoot ? Ve(e, B.shadowRoot, s, r) : !Ye(B) && !WB(B) && !We(B) && Ve(e, B, s, r));
  }
};
var PB = function(e, A) {
  return Wr(A) ? new GB(e, A) : ZB(A) ? new RB(e, A) : WB(A) ? new VB(e, A) : Lo(A) ? new NB(e, A) : Do(A) ? new kr(e, A) : bo(A) ? new tt(e, A) : We(A) ? new XB(e, A) : Ye(A) ? new _B(e, A) : qB(A) ? new JB(e, A) : new aA(e, A);
};
var kB = function(e, A) {
  var t = PB(e, A);
  return t.flags |= 4, Ve(e, A, t, t), t;
};
var Ko = function(e, A, t) {
  return A.styles.isPositionedWithZIndex() || A.styles.opacity < 1 || A.styles.isTransformed() || Bt(e) && t.styles.isTransparent();
};
var mo = function(e) {
  return e.isPositioned() || e.isFloating();
};
var YB = function(e) {
  return e.nodeType === Node.TEXT_NODE;
};
var _A = function(e) {
  return e.nodeType === Node.ELEMENT_NODE;
};
var Yr = function(e) {
  return _A(e) && typeof e.style < "u" && !Ne(e);
};
var Ne = function(e) {
  return typeof e.className == "object";
};
var Lo = function(e) {
  return e.tagName === "LI";
};
var Do = function(e) {
  return e.tagName === "OL";
};
var bo = function(e) {
  return e.tagName === "INPUT";
};
var xo = function(e) {
  return e.tagName === "HTML";
};
var WB = function(e) {
  return e.tagName === "svg";
};
var Bt = function(e) {
  return e.tagName === "BODY";
};
var ZB = function(e) {
  return e.tagName === "CANVAS";
};
var Pt = function(e) {
  return e.tagName === "VIDEO";
};
var Wr = function(e) {
  return e.tagName === "IMG";
};
var qB = function(e) {
  return e.tagName === "IFRAME";
};
var kt = function(e) {
  return e.tagName === "STYLE";
};
var To = function(e) {
  return e.tagName === "SCRIPT";
};
var Ye = function(e) {
  return e.tagName === "TEXTAREA";
};
var We = function(e) {
  return e.tagName === "SELECT";
};
var jB = function(e) {
  return e.tagName === "SLOT";
};
var Yt = function(e) {
  return e.tagName.indexOf("-") > 0;
};
var So = (
  /** @class */
  function() {
    function e() {
      this.counters = {};
    }
    return e.prototype.getCounterValue = function(A) {
      var t = this.counters[A];
      return t && t.length ? t[t.length - 1] : 1;
    }, e.prototype.getCounterValues = function(A) {
      var t = this.counters[A];
      return t || [];
    }, e.prototype.pop = function(A) {
      var t = this;
      A.forEach(function(r) {
        return t.counters[r].pop();
      });
    }, e.prototype.parse = function(A) {
      var t = this, r = A.counterIncrement, B = A.counterReset, n = true;
      r !== null && r.forEach(function(i) {
        var a = t.counters[i.counter];
        a && i.increment !== 0 && (n = false, a.length || a.push(1), a[Math.max(0, a.length - 1)] += i.increment);
      });
      var s = [];
      return n && B.forEach(function(i) {
        var a = t.counters[i.counter];
        s.push(i.counter), a || (a = t.counters[i.counter] = []), a.push(i.reset);
      }), s;
    }, e;
  }()
);
var Wt = {
  integers: [1e3, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1],
  values: ["M", "CM", "D", "CD", "C", "XC", "L", "XL", "X", "IX", "V", "IV", "I"]
};
var Zt = {
  integers: [9e3, 8e3, 7e3, 6e3, 5e3, 4e3, 3e3, 2e3, 1e3, 900, 800, 700, 600, 500, 400, 300, 200, 100, 90, 80, 70, 60, 50, 40, 30, 20, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1],
  values: ["Ք", "Փ", "Ւ", "Ց", "Ր", "Տ", "Վ", "Ս", "Ռ", "Ջ", "Պ", "Չ", "Ո", "Շ", "Ն", "Յ", "Մ", "Ճ", "Ղ", "Ձ", "Հ", "Կ", "Ծ", "Խ", "Լ", "Ի", "Ժ", "Թ", "Ը", "Է", "Զ", "Ե", "Դ", "Գ", "Բ", "Ա"]
};
var Oo = {
  integers: [1e4, 9e3, 8e3, 7e3, 6e3, 5e3, 4e3, 3e3, 2e3, 1e3, 400, 300, 200, 100, 90, 80, 70, 60, 50, 40, 30, 20, 19, 18, 17, 16, 15, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1],
  values: ["י׳", "ט׳", "ח׳", "ז׳", "ו׳", "ה׳", "ד׳", "ג׳", "ב׳", "א׳", "ת", "ש", "ר", "ק", "צ", "פ", "ע", "ס", "נ", "מ", "ל", "כ", "יט", "יח", "יז", "טז", "טו", "י", "ט", "ח", "ז", "ו", "ה", "ד", "ג", "ב", "א"]
};
var Mo = {
  integers: [1e4, 9e3, 8e3, 7e3, 6e3, 5e3, 4e3, 3e3, 2e3, 1e3, 900, 800, 700, 600, 500, 400, 300, 200, 100, 90, 80, 70, 60, 50, 40, 30, 20, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1],
  values: ["ჵ", "ჰ", "ჯ", "ჴ", "ხ", "ჭ", "წ", "ძ", "ც", "ჩ", "შ", "ყ", "ღ", "ქ", "ფ", "ჳ", "ტ", "ს", "რ", "ჟ", "პ", "ო", "ჲ", "ნ", "მ", "ლ", "კ", "ი", "თ", "ჱ", "ზ", "ვ", "ე", "დ", "გ", "ბ", "ა"]
};
var GA = function(e, A, t, r, B, n) {
  return e < A || e > t ? we(e, B, n.length > 0) : r.integers.reduce(function(s, i, a) {
    for (; e >= i; ) e -= i, s += r.values[a];
    return s;
  }, "") + n;
};
var zB = function(e, A, t, r) {
  var B = "";
  do
    t || e--, B = r(e) + B, e /= A;
  while (e * A >= A);
  return B;
};
var T = function(e, A, t, r, B) {
  var n = t - A + 1;
  return (e < 0 ? "-" : "") + (zB(Math.abs(e), n, r, function(s) {
    return S(Math.floor(s % n) + A);
  }) + B);
};
var mA = function(e, A, t) {
  t === void 0 && (t = ". ");
  var r = A.length;
  return zB(Math.abs(e), r, false, function(B) {
    return A[Math.floor(B % r)];
  }) + t;
};
var NA = 1;
var lA = 2;
var fA = 4;
var Be = 8;
var gA = function(e, A, t, r, B, n) {
  if (e < -9999 || e > 9999) return we(e, 4, B.length > 0);
  var s = Math.abs(e), i = B;
  if (s === 0) return A[0] + i;
  for (var a = 0; s > 0 && a <= 4; a++) {
    var o = s % 10;
    o === 0 && G(n, NA) && i !== "" ? i = A[o] + i : o > 1 || o === 1 && a === 0 || o === 1 && a === 1 && G(n, lA) || o === 1 && a === 1 && G(n, fA) && e > 100 || o === 1 && a > 1 && G(n, Be) ? i = A[o] + (a > 0 ? t[a - 1] : "") + i : o === 1 && a > 0 && (i = t[a - 1] + i), s = Math.floor(s / 10);
  }
  return (e < 0 ? r : "") + i;
};
var qt = "十百千萬";
var jt = "拾佰仟萬";
var zt = "マイナス";
var pr = "마이너스";
var we = function(e, A, t) {
  var r = t ? ". " : "", B = t ? "、" : "", n = t ? ", " : "", s = t ? " " : "";
  switch (A) {
    case 0:
      return "•" + s;
    case 1:
      return "◦" + s;
    case 2:
      return "◾" + s;
    case 5:
      var i = T(e, 48, 57, true, r);
      return i.length < 4 ? "0" + i : i;
    case 4:
      return mA(e, "〇一二三四五六七八九", B);
    case 6:
      return GA(e, 1, 3999, Wt, 3, r).toLowerCase();
    case 7:
      return GA(e, 1, 3999, Wt, 3, r);
    case 8:
      return T(e, 945, 969, false, r);
    case 9:
      return T(e, 97, 122, false, r);
    case 10:
      return T(e, 65, 90, false, r);
    case 11:
      return T(e, 1632, 1641, true, r);
    case 12:
    case 49:
      return GA(e, 1, 9999, Zt, 3, r);
    case 35:
      return GA(e, 1, 9999, Zt, 3, r).toLowerCase();
    case 13:
      return T(e, 2534, 2543, true, r);
    case 14:
    case 30:
      return T(e, 6112, 6121, true, r);
    case 15:
      return mA(e, "子丑寅卯辰巳午未申酉戌亥", B);
    case 16:
      return mA(e, "甲乙丙丁戊己庚辛壬癸", B);
    case 17:
    case 48:
      return gA(e, "零一二三四五六七八九", qt, "負", B, lA | fA | Be);
    case 47:
      return gA(e, "零壹貳參肆伍陸柒捌玖", jt, "負", B, NA | lA | fA | Be);
    case 42:
      return gA(e, "零一二三四五六七八九", qt, "负", B, lA | fA | Be);
    case 41:
      return gA(e, "零壹贰叁肆伍陆柒捌玖", jt, "负", B, NA | lA | fA | Be);
    case 26:
      return gA(e, "〇一二三四五六七八九", "十百千万", zt, B, 0);
    case 25:
      return gA(e, "零壱弐参四伍六七八九", "拾百千万", zt, B, NA | lA | fA);
    case 31:
      return gA(e, "영일이삼사오육칠팔구", "십백천만", pr, n, NA | lA | fA);
    case 33:
      return gA(e, "零一二三四五六七八九", "十百千萬", pr, n, 0);
    case 32:
      return gA(e, "零壹貳參四五六七八九", "拾百千", pr, n, NA | lA | fA);
    case 18:
      return T(e, 2406, 2415, true, r);
    case 20:
      return GA(e, 1, 19999, Mo, 3, r);
    case 21:
      return T(e, 2790, 2799, true, r);
    case 22:
      return T(e, 2662, 2671, true, r);
    case 22:
      return GA(e, 1, 10999, Oo, 3, r);
    case 23:
      return mA(e, "あいうえおかきくけこさしすせそたちつてとなにぬねのはひふへほまみむめもやゆよらりるれろわゐゑをん");
    case 24:
      return mA(e, "いろはにほへとちりぬるをわかよたれそつねならむうゐのおくやまけふこえてあさきゆめみしゑひもせす");
    case 27:
      return T(e, 3302, 3311, true, r);
    case 28:
      return mA(e, "アイウエオカキクケコサシスセソタチツテトナニヌネノハヒフヘホマミムメモヤユヨラリルレロワヰヱヲン", B);
    case 29:
      return mA(e, "イロハニホヘトチリヌルヲワカヨタレソツネナラムウヰノオクヤマケフコエテアサキユメミシヱヒモセス", B);
    case 34:
      return T(e, 3792, 3801, true, r);
    case 37:
      return T(e, 6160, 6169, true, r);
    case 38:
      return T(e, 4160, 4169, true, r);
    case 39:
      return T(e, 2918, 2927, true, r);
    case 40:
      return T(e, 1776, 1785, true, r);
    case 43:
      return T(e, 3046, 3055, true, r);
    case 44:
      return T(e, 3174, 3183, true, r);
    case 45:
      return T(e, 3664, 3673, true, r);
    case 46:
      return T(e, 3872, 3881, true, r);
    case 3:
    default:
      return T(e, 48, 57, true, r);
  }
};
var $B = "data-html2canvas-ignore";
var $t = (
  /** @class */
  function() {
    function e(A, t, r) {
      if (this.context = A, this.options = r, this.scrolledElements = [], this.referenceElement = t, this.counters = new So(), this.quoteDepth = 0, !t.ownerDocument) throw new Error("Cloned element does not have an owner document");
      this.documentElement = this.cloneNode(t.ownerDocument.documentElement, false);
    }
    return e.prototype.toIFrame = function(A, t) {
      var r = this, B = Go(A, t);
      if (!B.contentWindow) return Promise.reject("Unable to find iframe window");
      var n = A.defaultView.pageXOffset, s = A.defaultView.pageYOffset, i = B.contentWindow, a = i.document, o = No(B).then(function() {
        return P(r, void 0, void 0, function() {
          var Q, g;
          return _(this, function(w) {
            switch (w.label) {
              case 0:
                return this.scrolledElements.forEach(Po), i && (i.scrollTo(t.left, t.top), /(iPad|iPhone|iPod)/g.test(navigator.userAgent) && (i.scrollY !== t.top || i.scrollX !== t.left) && (this.context.logger.warn("Unable to restore scroll position for cloned document"), this.context.windowBounds = this.context.windowBounds.add(i.scrollX - t.left, i.scrollY - t.top, 0, 0))), Q = this.options.onclone, g = this.clonedReferenceElement, typeof g > "u" ? [2, Promise.reject("Error finding the " + this.referenceElement.nodeName + " in the cloned document")] : a.fonts && a.fonts.ready ? [4, a.fonts.ready] : [3, 2];
              case 1:
                w.sent(), w.label = 2;
              case 2:
                return /(AppleWebKit)/g.test(navigator.userAgent) ? [4, Vo(a)] : [3, 4];
              case 3:
                w.sent(), w.label = 4;
              case 4:
                return typeof Q == "function" ? [2, Promise.resolve().then(function() {
                  return Q(a, g);
                }).then(function() {
                  return B;
                })] : [2, B];
            }
          });
        });
      });
      return a.open(), a.write(_o(document.doctype) + "<html></html>"), Jo(this.referenceElement.ownerDocument, n, s), a.replaceChild(a.adoptNode(this.documentElement), a.documentElement), a.close(), o;
    }, e.prototype.createElementClone = function(A) {
      if (Jr(
        A,
        2
        /* CLONE */
      )) debugger;
      if (ZB(A)) return this.createCanvasClone(A);
      if (Pt(A)) return this.createVideoClone(A);
      if (kt(A)) return this.createStyleClone(A);
      var t = A.cloneNode(false);
      return Wr(t) && (Wr(A) && A.currentSrc && A.currentSrc !== A.src && (t.src = A.currentSrc, t.srcset = ""), t.loading === "lazy" && (t.loading = "eager")), Yt(t) ? this.createCustomElementClone(t) : t;
    }, e.prototype.createCustomElementClone = function(A) {
      var t = document.createElement("html2canvascustomelement");
      return Ir(A.style, t), t;
    }, e.prototype.createStyleClone = function(A) {
      try {
        var t = A.sheet;
        if (t && t.cssRules) {
          var r = [].slice.call(t.cssRules, 0).reduce(function(n, s) {
            return s && typeof s.cssText == "string" ? n + s.cssText : n;
          }, ""), B = A.cloneNode(false);
          return B.textContent = r, B;
        }
      } catch (n) {
        if (this.context.logger.error("Unable to access cssRules property", n), n.name !== "SecurityError") throw n;
      }
      return A.cloneNode(false);
    }, e.prototype.createCanvasClone = function(A) {
      var t;
      if (this.options.inlineImages && A.ownerDocument) {
        var r = A.ownerDocument.createElement("img");
        try {
          return r.src = A.toDataURL(), r;
        } catch {
          this.context.logger.info("Unable to inline canvas contents, canvas is tainted", A);
        }
      }
      var B = A.cloneNode(false);
      try {
        B.width = A.width, B.height = A.height;
        var n = A.getContext("2d"), s = B.getContext("2d");
        if (s) if (!this.options.allowTaint && n) s.putImageData(n.getImageData(0, 0, A.width, A.height), 0, 0);
        else {
          var i = (t = A.getContext("webgl2")) !== null && t !== void 0 ? t : A.getContext("webgl");
          if (i) {
            var a = i.getContextAttributes();
            (a == null ? void 0 : a.preserveDrawingBuffer) === false && this.context.logger.warn("Unable to clone WebGL context as it has preserveDrawingBuffer=false", A);
          }
          s.drawImage(A, 0, 0);
        }
        return B;
      } catch {
        this.context.logger.info("Unable to clone canvas as it is tainted", A);
      }
      return B;
    }, e.prototype.createVideoClone = function(A) {
      var t = A.ownerDocument.createElement("canvas");
      t.width = A.offsetWidth, t.height = A.offsetHeight;
      var r = t.getContext("2d");
      try {
        return r && (r.drawImage(A, 0, 0, t.width, t.height), this.options.allowTaint || r.getImageData(0, 0, t.width, t.height)), t;
      } catch {
        this.context.logger.info("Unable to clone video as it is tainted", A);
      }
      var B = A.ownerDocument.createElement("canvas");
      return B.width = A.offsetWidth, B.height = A.offsetHeight, B;
    }, e.prototype.appendChildNode = function(A, t, r) {
      (!_A(t) || !To(t) && !t.hasAttribute($B) && (typeof this.options.ignoreElements != "function" || !this.options.ignoreElements(t))) && (!this.options.copyStyles || !_A(t) || !kt(t)) && A.appendChild(this.cloneNode(t, r));
    }, e.prototype.cloneChildNodes = function(A, t, r) {
      for (var B = this, n = A.shadowRoot ? A.shadowRoot.firstChild : A.firstChild; n; n = n.nextSibling) if (_A(n) && jB(n) && typeof n.assignedNodes == "function") {
        var s = n.assignedNodes();
        s.length && s.forEach(function(i) {
          return B.appendChildNode(t, i, r);
        });
      } else this.appendChildNode(t, n, r);
    }, e.prototype.cloneNode = function(A, t) {
      if (YB(A)) return document.createTextNode(A.data);
      if (!A.ownerDocument) return A.cloneNode(false);
      var r = A.ownerDocument.defaultView;
      if (r && _A(A) && (Yr(A) || Ne(A))) {
        var B = this.createElementClone(A);
        B.style.transitionProperty = "none";
        var n = r.getComputedStyle(A), s = r.getComputedStyle(A, ":before"), i = r.getComputedStyle(A, ":after");
        this.referenceElement === A && Yr(B) && (this.clonedReferenceElement = B), Bt(B) && Wo(B);
        var a = this.counters.parse(new Lt(this.context, n)), o = this.resolvePseudoContent(A, B, s, oe.BEFORE);
        Yt(A) && (t = true), Pt(A) || this.cloneChildNodes(A, B, t), o && B.insertBefore(o, B.firstChild);
        var Q = this.resolvePseudoContent(A, B, i, oe.AFTER);
        return Q && B.appendChild(Q), this.counters.pop(a), (n && (this.options.copyStyles || Ne(A)) && !qB(A) || t) && Ir(n, B), (A.scrollTop !== 0 || A.scrollLeft !== 0) && this.scrolledElements.push([B, A.scrollLeft, A.scrollTop]), (Ye(A) || We(A)) && (Ye(B) || We(B)) && (B.value = A.value), B;
      }
      return A.cloneNode(false);
    }, e.prototype.resolvePseudoContent = function(A, t, r, B) {
      var n = this;
      if (r) {
        var s = r.content, i = t.ownerDocument;
        if (!(!i || !s || s === "none" || s === "-moz-alt-content" || r.display === "none")) {
          this.counters.parse(new Lt(this.context, r));
          var a = new mi(this.context, r), o = i.createElement("html2canvaspseudoelement");
          Ir(r, o), a.content.forEach(function(g) {
            if (g.type === 0) o.appendChild(i.createTextNode(g.value));
            else if (g.type === 22) {
              var w = i.createElement("img");
              w.src = g.value, w.style.opacity = "1", o.appendChild(w);
            } else if (g.type === 18) {
              if (g.name === "attr") {
                var f = g.values.filter(D);
                f.length && o.appendChild(i.createTextNode(A.getAttribute(f[0].value) || ""));
              } else if (g.name === "counter") {
                var c = g.values.filter(PA), C = c[0], H = c[1];
                if (C && D(C)) {
                  var h = n.counters.getCounterValue(C.value), F = H && D(H) ? _r.parse(n.context, H.value) : 3;
                  o.appendChild(i.createTextNode(we(h, F, false)));
                }
              } else if (g.name === "counters") {
                var K = g.values.filter(PA), C = K[0], p = K[1], H = K[2];
                if (C && D(C)) {
                  var d = n.counters.getCounterValues(C.value), l = H && D(H) ? _r.parse(n.context, H.value) : 3, v = p && p.type === 0 ? p.value : "", y = d.map(function(k) {
                    return we(k, l, false);
                  }).join(v);
                  o.appendChild(i.createTextNode(y));
                }
              }
            } else if (g.type === 20) switch (g.value) {
              case "open-quote":
                o.appendChild(i.createTextNode(mt(a.quotes, n.quoteDepth++, true)));
                break;
              case "close-quote":
                o.appendChild(i.createTextNode(mt(a.quotes, --n.quoteDepth, false)));
                break;
              default:
                o.appendChild(i.createTextNode(g.value));
            }
          }), o.className = Zr + " " + qr;
          var Q = B === oe.BEFORE ? " " + Zr : " " + qr;
          return Ne(t) ? t.className.baseValue += Q : t.className += Q, o;
        }
      }
    }, e.destroy = function(A) {
      return A.parentNode ? (A.parentNode.removeChild(A), true) : false;
    }, e;
  }()
);
var oe;
(function(e) {
  e[e.BEFORE = 0] = "BEFORE", e[e.AFTER = 1] = "AFTER";
})(oe || (oe = {}));
var Go = function(e, A) {
  var t = e.createElement("iframe");
  return t.className = "html2canvas-container", t.style.visibility = "hidden", t.style.position = "fixed", t.style.left = "-10000px", t.style.top = "0px", t.style.border = "0", t.width = A.width.toString(), t.height = A.height.toString(), t.scrolling = "no", t.setAttribute($B, "true"), e.body.appendChild(t), t;
};
var Ro = function(e) {
  return new Promise(function(A) {
    if (e.complete) {
      A();
      return;
    }
    if (!e.src) {
      A();
      return;
    }
    e.onload = A, e.onerror = A;
  });
};
var Vo = function(e) {
  return Promise.all([].slice.call(e.images, 0).map(Ro));
};
var No = function(e) {
  return new Promise(function(A, t) {
    var r = e.contentWindow;
    if (!r) return t("No window assigned for iframe");
    var B = r.document;
    r.onload = e.onload = function() {
      r.onload = e.onload = null;
      var n = setInterval(function() {
        B.body.childNodes.length > 0 && B.readyState === "complete" && (clearInterval(n), A(e));
      }, 50);
    };
  });
};
var Xo = [
  "all",
  "d",
  "content"
  // Safari shows pseudoelements if content is set
];
var Ir = function(e, A) {
  for (var t = e.length - 1; t >= 0; t--) {
    var r = e.item(t);
    Xo.indexOf(r) === -1 && A.style.setProperty(r, e.getPropertyValue(r));
  }
  return A;
};
var _o = function(e) {
  var A = "";
  return e && (A += "<!DOCTYPE ", e.name && (A += e.name), e.internalSubset && (A += e.internalSubset), e.publicId && (A += '"' + e.publicId + '"'), e.systemId && (A += '"' + e.systemId + '"'), A += ">"), A;
};
var Jo = function(e, A, t) {
  e && e.defaultView && (A !== e.defaultView.pageXOffset || t !== e.defaultView.pageYOffset) && e.defaultView.scrollTo(A, t);
};
var Po = function(e) {
  var A = e[0], t = e[1], r = e[2];
  A.scrollLeft = t, A.scrollTop = r;
};
var ko = ":before";
var Yo = ":after";
var Zr = "___html2canvas___pseudoelement_before";
var qr = "___html2canvas___pseudoelement_after";
var AB = `{
    content: "" !important;
    display: none !important;
}`;
var Wo = function(e) {
  Zo(e, "." + Zr + ko + AB + `
         .` + qr + Yo + AB);
};
var Zo = function(e, A) {
  var t = e.ownerDocument;
  if (t) {
    var r = t.createElement("style");
    r.textContent = A, e.appendChild(r);
  }
};
var An = (
  /** @class */
  function() {
    function e() {
    }
    return e.getOrigin = function(A) {
      var t = e._link;
      return t ? (t.href = A, t.href = t.href, t.protocol + t.hostname + t.port) : "about:blank";
    }, e.isSameOrigin = function(A) {
      return e.getOrigin(A) === e._origin;
    }, e.setContext = function(A) {
      e._link = A.document.createElement("a"), e._origin = e.getOrigin(A.location.href);
    }, e._origin = "about:blank", e;
  }()
);
var qo = (
  /** @class */
  function() {
    function e(A, t) {
      this.context = A, this._options = t, this._cache = {};
    }
    return e.prototype.addImage = function(A) {
      var t = Promise.resolve();
      return this.has(A) || (yr(A) || AQ(A)) && (this._cache[A] = this.loadImage(A)).catch(function() {
      }), t;
    }, e.prototype.match = function(A) {
      return this._cache[A];
    }, e.prototype.loadImage = function(A) {
      return P(this, void 0, void 0, function() {
        var t, r, B, n, s = this;
        return _(this, function(i) {
          switch (i.label) {
            case 0:
              return t = An.isSameOrigin(A), r = !vr(A) && this._options.useCORS === true && N.SUPPORT_CORS_IMAGES && !t, B = !vr(A) && !t && !yr(A) && typeof this._options.proxy == "string" && N.SUPPORT_CORS_XHR && !r, !t && this._options.allowTaint === false && !vr(A) && !yr(A) && !B && !r ? [
                2
                /*return*/
              ] : (n = A, B ? [4, this.proxy(n)] : [3, 2]);
            case 1:
              n = i.sent(), i.label = 2;
            case 2:
              return this.context.logger.debug("Added image " + A.substring(0, 256)), [4, new Promise(function(a, o) {
                var Q = new Image();
                Q.onload = function() {
                  return a(Q);
                }, Q.onerror = o, (eQ(n) || r) && (Q.crossOrigin = "anonymous"), Q.src = n, Q.complete === true && setTimeout(function() {
                  return a(Q);
                }, 500), s._options.imageTimeout > 0 && setTimeout(function() {
                  return o("Timed out (" + s._options.imageTimeout + "ms) loading image");
                }, s._options.imageTimeout);
              })];
            case 3:
              return [2, i.sent()];
          }
        });
      });
    }, e.prototype.has = function(A) {
      return typeof this._cache[A] < "u";
    }, e.prototype.keys = function() {
      return Promise.resolve(Object.keys(this._cache));
    }, e.prototype.proxy = function(A) {
      var t = this, r = this._options.proxy;
      if (!r) throw new Error("No proxy defined");
      var B = A.substring(0, 256);
      return new Promise(function(n, s) {
        var i = N.SUPPORT_RESPONSE_TYPE ? "blob" : "text", a = new XMLHttpRequest();
        a.onload = function() {
          if (a.status === 200) {
            if (i === "text") n(a.response);
            else {
              var g = new FileReader();
              g.addEventListener("load", function() {
                return n(g.result);
              }, false), g.addEventListener("error", function(w) {
                return s(w);
              }, false), g.readAsDataURL(a.response);
            }
          } else s("Failed to proxy resource " + B + " with status code " + a.status);
        }, a.onerror = s;
        var o = r.indexOf("?") > -1 ? "&" : "?";
        if (a.open("GET", "" + r + o + "url=" + encodeURIComponent(A) + "&responseType=" + i), i !== "text" && a instanceof XMLHttpRequest && (a.responseType = i), t._options.imageTimeout) {
          var Q = t._options.imageTimeout;
          a.timeout = Q, a.ontimeout = function() {
            return s("Timed out (" + Q + "ms) proxying " + B);
          };
        }
        a.send();
      });
    }, e;
  }()
);
var jo = /^data:image\/svg\+xml/i;
var zo = /^data:image\/.*;base64,/i;
var $o = /^data:image\/.*/i;
var AQ = function(e) {
  return N.SUPPORT_SVG_DRAWING || !rQ(e);
};
var vr = function(e) {
  return $o.test(e);
};
var eQ = function(e) {
  return zo.test(e);
};
var yr = function(e) {
  return e.substr(0, 4) === "blob";
};
var rQ = function(e) {
  return e.substr(-3).toLowerCase() === "svg" || jo.test(e);
};
var u = (
  /** @class */
  function() {
    function e(A, t) {
      this.type = 0, this.x = A, this.y = t;
    }
    return e.prototype.add = function(A, t) {
      return new e(this.x + A, this.y + t);
    }, e;
  }()
);
var RA = function(e, A, t) {
  return new u(e.x + (A.x - e.x) * t, e.y + (A.y - e.y) * t);
};
var Te = (
  /** @class */
  function() {
    function e(A, t, r, B) {
      this.type = 1, this.start = A, this.startControl = t, this.endControl = r, this.end = B;
    }
    return e.prototype.subdivide = function(A, t) {
      var r = RA(this.start, this.startControl, A), B = RA(this.startControl, this.endControl, A), n = RA(this.endControl, this.end, A), s = RA(r, B, A), i = RA(B, n, A), a = RA(s, i, A);
      return t ? new e(this.start, r, s, a) : new e(a, i, n, this.end);
    }, e.prototype.add = function(A, t) {
      return new e(this.start.add(A, t), this.startControl.add(A, t), this.endControl.add(A, t), this.end.add(A, t));
    }, e.prototype.reverse = function() {
      return new e(this.end, this.endControl, this.startControl, this.start);
    }, e;
  }()
);
var $ = function(e) {
  return e.type === 1;
};
var tQ = (
  /** @class */
  /* @__PURE__ */ function() {
    function e(A) {
      var t = A.styles, r = A.bounds, B = re(t.borderTopLeftRadius, r.width, r.height), n = B[0], s = B[1], i = re(t.borderTopRightRadius, r.width, r.height), a = i[0], o = i[1], Q = re(t.borderBottomRightRadius, r.width, r.height), g = Q[0], w = Q[1], f = re(t.borderBottomLeftRadius, r.width, r.height), c = f[0], C = f[1], H = [];
      H.push((n + a) / r.width), H.push((c + g) / r.width), H.push((s + C) / r.height), H.push((o + w) / r.height);
      var h = Math.max.apply(Math, H);
      h > 1 && (n /= h, s /= h, a /= h, o /= h, g /= h, w /= h, c /= h, C /= h);
      var F = r.width - a, K = r.height - w, p = r.width - g, d = r.height - C, l = t.borderTopWidth, v = t.borderRightWidth, y = t.borderBottomWidth, E = t.borderLeftWidth, O = b(t.paddingTop, A.bounds.width), k = b(t.paddingRight, A.bounds.width), q = b(t.paddingBottom, A.bounds.width), L = b(t.paddingLeft, A.bounds.width);
      this.topLeftBorderDoubleOuterBox = n > 0 || s > 0 ? x(r.left + E / 3, r.top + l / 3, n - E / 3, s - l / 3, m.TOP_LEFT) : new u(r.left + E / 3, r.top + l / 3), this.topRightBorderDoubleOuterBox = n > 0 || s > 0 ? x(r.left + F, r.top + l / 3, a - v / 3, o - l / 3, m.TOP_RIGHT) : new u(r.left + r.width - v / 3, r.top + l / 3), this.bottomRightBorderDoubleOuterBox = g > 0 || w > 0 ? x(r.left + p, r.top + K, g - v / 3, w - y / 3, m.BOTTOM_RIGHT) : new u(r.left + r.width - v / 3, r.top + r.height - y / 3), this.bottomLeftBorderDoubleOuterBox = c > 0 || C > 0 ? x(r.left + E / 3, r.top + d, c - E / 3, C - y / 3, m.BOTTOM_LEFT) : new u(r.left + E / 3, r.top + r.height - y / 3), this.topLeftBorderDoubleInnerBox = n > 0 || s > 0 ? x(r.left + E * 2 / 3, r.top + l * 2 / 3, n - E * 2 / 3, s - l * 2 / 3, m.TOP_LEFT) : new u(r.left + E * 2 / 3, r.top + l * 2 / 3), this.topRightBorderDoubleInnerBox = n > 0 || s > 0 ? x(r.left + F, r.top + l * 2 / 3, a - v * 2 / 3, o - l * 2 / 3, m.TOP_RIGHT) : new u(r.left + r.width - v * 2 / 3, r.top + l * 2 / 3), this.bottomRightBorderDoubleInnerBox = g > 0 || w > 0 ? x(r.left + p, r.top + K, g - v * 2 / 3, w - y * 2 / 3, m.BOTTOM_RIGHT) : new u(r.left + r.width - v * 2 / 3, r.top + r.height - y * 2 / 3), this.bottomLeftBorderDoubleInnerBox = c > 0 || C > 0 ? x(r.left + E * 2 / 3, r.top + d, c - E * 2 / 3, C - y * 2 / 3, m.BOTTOM_LEFT) : new u(r.left + E * 2 / 3, r.top + r.height - y * 2 / 3), this.topLeftBorderStroke = n > 0 || s > 0 ? x(r.left + E / 2, r.top + l / 2, n - E / 2, s - l / 2, m.TOP_LEFT) : new u(r.left + E / 2, r.top + l / 2), this.topRightBorderStroke = n > 0 || s > 0 ? x(r.left + F, r.top + l / 2, a - v / 2, o - l / 2, m.TOP_RIGHT) : new u(r.left + r.width - v / 2, r.top + l / 2), this.bottomRightBorderStroke = g > 0 || w > 0 ? x(r.left + p, r.top + K, g - v / 2, w - y / 2, m.BOTTOM_RIGHT) : new u(r.left + r.width - v / 2, r.top + r.height - y / 2), this.bottomLeftBorderStroke = c > 0 || C > 0 ? x(r.left + E / 2, r.top + d, c - E / 2, C - y / 2, m.BOTTOM_LEFT) : new u(r.left + E / 2, r.top + r.height - y / 2), this.topLeftBorderBox = n > 0 || s > 0 ? x(r.left, r.top, n, s, m.TOP_LEFT) : new u(r.left, r.top), this.topRightBorderBox = a > 0 || o > 0 ? x(r.left + F, r.top, a, o, m.TOP_RIGHT) : new u(r.left + r.width, r.top), this.bottomRightBorderBox = g > 0 || w > 0 ? x(r.left + p, r.top + K, g, w, m.BOTTOM_RIGHT) : new u(r.left + r.width, r.top + r.height), this.bottomLeftBorderBox = c > 0 || C > 0 ? x(r.left, r.top + d, c, C, m.BOTTOM_LEFT) : new u(r.left, r.top + r.height), this.topLeftPaddingBox = n > 0 || s > 0 ? x(r.left + E, r.top + l, Math.max(0, n - E), Math.max(0, s - l), m.TOP_LEFT) : new u(r.left + E, r.top + l), this.topRightPaddingBox = a > 0 || o > 0 ? x(r.left + Math.min(F, r.width - v), r.top + l, F > r.width + v ? 0 : Math.max(0, a - v), Math.max(0, o - l), m.TOP_RIGHT) : new u(r.left + r.width - v, r.top + l), this.bottomRightPaddingBox = g > 0 || w > 0 ? x(r.left + Math.min(p, r.width - E), r.top + Math.min(K, r.height - y), Math.max(0, g - v), Math.max(0, w - y), m.BOTTOM_RIGHT) : new u(r.left + r.width - v, r.top + r.height - y), this.bottomLeftPaddingBox = c > 0 || C > 0 ? x(r.left + E, r.top + Math.min(d, r.height - y), Math.max(0, c - E), Math.max(0, C - y), m.BOTTOM_LEFT) : new u(r.left + E, r.top + r.height - y), this.topLeftContentBox = n > 0 || s > 0 ? x(r.left + E + L, r.top + l + O, Math.max(0, n - (E + L)), Math.max(0, s - (l + O)), m.TOP_LEFT) : new u(r.left + E + L, r.top + l + O), this.topRightContentBox = a > 0 || o > 0 ? x(r.left + Math.min(F, r.width + E + L), r.top + l + O, F > r.width + E + L ? 0 : a - E + L, o - (l + O), m.TOP_RIGHT) : new u(r.left + r.width - (v + k), r.top + l + O), this.bottomRightContentBox = g > 0 || w > 0 ? x(r.left + Math.min(p, r.width - (E + L)), r.top + Math.min(K, r.height + l + O), Math.max(0, g - (v + k)), w - (y + q), m.BOTTOM_RIGHT) : new u(r.left + r.width - (v + k), r.top + r.height - (y + q)), this.bottomLeftContentBox = c > 0 || C > 0 ? x(r.left + E + L, r.top + d, Math.max(0, c - (E + L)), C - (y + q), m.BOTTOM_LEFT) : new u(r.left + E + L, r.top + r.height - (y + q));
    }
    return e;
  }()
);
var m;
(function(e) {
  e[e.TOP_LEFT = 0] = "TOP_LEFT", e[e.TOP_RIGHT = 1] = "TOP_RIGHT", e[e.BOTTOM_RIGHT = 2] = "BOTTOM_RIGHT", e[e.BOTTOM_LEFT = 3] = "BOTTOM_LEFT";
})(m || (m = {}));
var x = function(e, A, t, r, B) {
  var n = 4 * ((Math.sqrt(2) - 1) / 3), s = t * n, i = r * n, a = e + t, o = A + r;
  switch (B) {
    case m.TOP_LEFT:
      return new Te(new u(e, o), new u(e, o - i), new u(a - s, A), new u(a, A));
    case m.TOP_RIGHT:
      return new Te(new u(e, A), new u(e + s, A), new u(a, o - i), new u(a, o));
    case m.BOTTOM_RIGHT:
      return new Te(new u(a, A), new u(a, A + i), new u(e + s, o), new u(e, o));
    case m.BOTTOM_LEFT:
    default:
      return new Te(new u(a, o), new u(a - s, o), new u(e, A + i), new u(e, A));
  }
};
var Ze = function(e) {
  return [e.topLeftBorderBox, e.topRightBorderBox, e.bottomRightBorderBox, e.bottomLeftBorderBox];
};
var BQ = function(e) {
  return [e.topLeftContentBox, e.topRightContentBox, e.bottomRightContentBox, e.bottomLeftContentBox];
};
var qe = function(e) {
  return [e.topLeftPaddingBox, e.topRightPaddingBox, e.bottomRightPaddingBox, e.bottomLeftPaddingBox];
};
var nQ = (
  /** @class */
  /* @__PURE__ */ function() {
    function e(A, t, r) {
      this.offsetX = A, this.offsetY = t, this.matrix = r, this.type = 0, this.target = 6;
    }
    return e;
  }()
);
var Se = (
  /** @class */
  /* @__PURE__ */ function() {
    function e(A, t) {
      this.path = A, this.target = t, this.type = 1;
    }
    return e;
  }()
);
var sQ = (
  /** @class */
  /* @__PURE__ */ function() {
    function e(A) {
      this.opacity = A, this.type = 2, this.target = 6;
    }
    return e;
  }()
);
var aQ = function(e) {
  return e.type === 0;
};
var en = function(e) {
  return e.type === 1;
};
var iQ = function(e) {
  return e.type === 2;
};
var eB = function(e, A) {
  return e.length === A.length ? e.some(function(t, r) {
    return t === A[r];
  }) : false;
};
var oQ = function(e, A, t, r, B) {
  return e.map(function(n, s) {
    switch (s) {
      case 0:
        return n.add(A, t);
      case 1:
        return n.add(A + r, t);
      case 2:
        return n.add(A + r, t + B);
      case 3:
        return n.add(A, t + B);
    }
    return n;
  });
};
var rn = (
  /** @class */
  /* @__PURE__ */ function() {
    function e(A) {
      this.element = A, this.inlineLevel = [], this.nonInlineLevel = [], this.negativeZIndex = [], this.zeroOrAutoZIndexOrTransformedOrOpacity = [], this.positiveZIndex = [], this.nonPositionedFloats = [], this.nonPositionedInlineLevel = [];
    }
    return e;
  }()
);
var tn = (
  /** @class */
  function() {
    function e(A, t) {
      if (this.container = A, this.parent = t, this.effects = [], this.curves = new tQ(this.container), this.container.styles.opacity < 1 && this.effects.push(new sQ(this.container.styles.opacity)), this.container.styles.transform !== null) {
        var r = this.container.bounds.left + this.container.styles.transformOrigin[0].number, B = this.container.bounds.top + this.container.styles.transformOrigin[1].number, n = this.container.styles.transform;
        this.effects.push(new nQ(r, B, n));
      }
      if (this.container.styles.overflowX !== 0) {
        var s = Ze(this.curves), i = qe(this.curves);
        eB(s, i) ? this.effects.push(new Se(
          s,
          6
          /* CONTENT */
        )) : (this.effects.push(new Se(
          s,
          2
          /* BACKGROUND_BORDERS */
        )), this.effects.push(new Se(
          i,
          4
          /* CONTENT */
        )));
      }
    }
    return e.prototype.getEffects = function(A) {
      for (var t = [
        2,
        3
        /* FIXED */
      ].indexOf(this.container.styles.position) === -1, r = this.parent, B = this.effects.slice(0); r; ) {
        var n = r.effects.filter(function(a) {
          return !en(a);
        });
        if (t || r.container.styles.position !== 0 || !r.parent) {
          if (B.unshift.apply(B, n), t = [
            2,
            3
            /* FIXED */
          ].indexOf(r.container.styles.position) === -1, r.container.styles.overflowX !== 0) {
            var s = Ze(r.curves), i = qe(r.curves);
            eB(s, i) || B.unshift(new Se(
              i,
              6
              /* CONTENT */
            ));
          }
        } else B.unshift.apply(B, n);
        r = r.parent;
      }
      return B.filter(function(a) {
        return G(a.target, A);
      });
    }, e;
  }()
);
var jr = function(e, A, t, r) {
  e.container.elements.forEach(function(B) {
    var n = G(
      B.flags,
      4
      /* CREATES_REAL_STACKING_CONTEXT */
    ), s = G(
      B.flags,
      2
      /* CREATES_STACKING_CONTEXT */
    ), i = new tn(B, e);
    G(
      B.styles.display,
      2048
      /* LIST_ITEM */
    ) && r.push(i);
    var a = G(
      B.flags,
      8
      /* IS_LIST_OWNER */
    ) ? [] : r;
    if (n || s) {
      var o = n || B.styles.isPositioned() ? t : A, Q = new rn(i);
      if (B.styles.isPositioned() || B.styles.opacity < 1 || B.styles.isTransformed()) {
        var g = B.styles.zIndex.order;
        if (g < 0) {
          var w = 0;
          o.negativeZIndex.some(function(c, C) {
            return g > c.element.container.styles.zIndex.order ? (w = C, false) : w > 0;
          }), o.negativeZIndex.splice(w, 0, Q);
        } else if (g > 0) {
          var f = 0;
          o.positiveZIndex.some(function(c, C) {
            return g >= c.element.container.styles.zIndex.order ? (f = C + 1, false) : f > 0;
          }), o.positiveZIndex.splice(f, 0, Q);
        } else o.zeroOrAutoZIndexOrTransformedOrOpacity.push(Q);
      } else B.styles.isFloating() ? o.nonPositionedFloats.push(Q) : o.nonPositionedInlineLevel.push(Q);
      jr(i, Q, n ? Q : t, a);
    } else B.styles.isInlineLevel() ? A.inlineLevel.push(i) : A.nonInlineLevel.push(i), jr(i, A, t, a);
    G(
      B.flags,
      8
      /* IS_LIST_OWNER */
    ) && Bn(B, a);
  });
};
var Bn = function(e, A) {
  for (var t = e instanceof kr ? e.start : 1, r = e instanceof kr ? e.reversed : false, B = 0; B < A.length; B++) {
    var n = A[B];
    n.container instanceof NB && typeof n.container.value == "number" && n.container.value !== 0 && (t = n.container.value), n.listValue = we(t, n.container.styles.listStyleType, true), t += r ? -1 : 1;
  }
};
var QQ = function(e) {
  var A = new tn(e, null), t = new rn(A), r = [];
  return jr(A, t, t, r), Bn(A.container, r), t;
};
var rB = function(e, A) {
  switch (A) {
    case 0:
      return eA(e.topLeftBorderBox, e.topLeftPaddingBox, e.topRightBorderBox, e.topRightPaddingBox);
    case 1:
      return eA(e.topRightBorderBox, e.topRightPaddingBox, e.bottomRightBorderBox, e.bottomRightPaddingBox);
    case 2:
      return eA(e.bottomRightBorderBox, e.bottomRightPaddingBox, e.bottomLeftBorderBox, e.bottomLeftPaddingBox);
    case 3:
    default:
      return eA(e.bottomLeftBorderBox, e.bottomLeftPaddingBox, e.topLeftBorderBox, e.topLeftPaddingBox);
  }
};
var gQ = function(e, A) {
  switch (A) {
    case 0:
      return eA(e.topLeftBorderBox, e.topLeftBorderDoubleOuterBox, e.topRightBorderBox, e.topRightBorderDoubleOuterBox);
    case 1:
      return eA(e.topRightBorderBox, e.topRightBorderDoubleOuterBox, e.bottomRightBorderBox, e.bottomRightBorderDoubleOuterBox);
    case 2:
      return eA(e.bottomRightBorderBox, e.bottomRightBorderDoubleOuterBox, e.bottomLeftBorderBox, e.bottomLeftBorderDoubleOuterBox);
    case 3:
    default:
      return eA(e.bottomLeftBorderBox, e.bottomLeftBorderDoubleOuterBox, e.topLeftBorderBox, e.topLeftBorderDoubleOuterBox);
  }
};
var wQ = function(e, A) {
  switch (A) {
    case 0:
      return eA(e.topLeftBorderDoubleInnerBox, e.topLeftPaddingBox, e.topRightBorderDoubleInnerBox, e.topRightPaddingBox);
    case 1:
      return eA(e.topRightBorderDoubleInnerBox, e.topRightPaddingBox, e.bottomRightBorderDoubleInnerBox, e.bottomRightPaddingBox);
    case 2:
      return eA(e.bottomRightBorderDoubleInnerBox, e.bottomRightPaddingBox, e.bottomLeftBorderDoubleInnerBox, e.bottomLeftPaddingBox);
    case 3:
    default:
      return eA(e.bottomLeftBorderDoubleInnerBox, e.bottomLeftPaddingBox, e.topLeftBorderDoubleInnerBox, e.topLeftPaddingBox);
  }
};
var cQ = function(e, A) {
  switch (A) {
    case 0:
      return Oe(e.topLeftBorderStroke, e.topRightBorderStroke);
    case 1:
      return Oe(e.topRightBorderStroke, e.bottomRightBorderStroke);
    case 2:
      return Oe(e.bottomRightBorderStroke, e.bottomLeftBorderStroke);
    case 3:
    default:
      return Oe(e.bottomLeftBorderStroke, e.topLeftBorderStroke);
  }
};
var Oe = function(e, A) {
  var t = [];
  return $(e) ? t.push(e.subdivide(0.5, false)) : t.push(e), $(A) ? t.push(A.subdivide(0.5, true)) : t.push(A), t;
};
var eA = function(e, A, t, r) {
  var B = [];
  return $(e) ? B.push(e.subdivide(0.5, false)) : B.push(e), $(t) ? B.push(t.subdivide(0.5, true)) : B.push(t), $(r) ? B.push(r.subdivide(0.5, true).reverse()) : B.push(r), $(A) ? B.push(A.subdivide(0.5, false).reverse()) : B.push(A), B;
};
var nn = function(e) {
  var A = e.bounds, t = e.styles;
  return A.add(t.borderLeftWidth, t.borderTopWidth, -(t.borderRightWidth + t.borderLeftWidth), -(t.borderTopWidth + t.borderBottomWidth));
};
var je = function(e) {
  var A = e.styles, t = e.bounds, r = b(A.paddingLeft, t.width), B = b(A.paddingRight, t.width), n = b(A.paddingTop, t.width), s = b(A.paddingBottom, t.width);
  return t.add(r + A.borderLeftWidth, n + A.borderTopWidth, -(A.borderRightWidth + A.borderLeftWidth + r + B), -(A.borderTopWidth + A.borderBottomWidth + n + s));
};
var CQ = function(e, A) {
  return e === 0 ? A.bounds : e === 2 ? je(A) : nn(A);
};
var uQ = function(e, A) {
  return e === 0 ? A.bounds : e === 2 ? je(A) : nn(A);
};
var Kr = function(e, A, t) {
  var r = CQ(XA(e.styles.backgroundOrigin, A), e), B = uQ(XA(e.styles.backgroundClip, A), e), n = lQ(XA(e.styles.backgroundSize, A), t, r), s = n[0], i = n[1], a = re(XA(e.styles.backgroundPosition, A), r.width - s, r.height - i), o = fQ(XA(e.styles.backgroundRepeat, A), a, n, r, B), Q = Math.round(r.left + a[0]), g = Math.round(r.top + a[1]);
  return [o, Q, g, s, i];
};
var VA = function(e) {
  return D(e) && e.value === JA.AUTO;
};
var Me = function(e) {
  return typeof e == "number";
};
var lQ = function(e, A, t) {
  var r = A[0], B = A[1], n = A[2], s = e[0], i = e[1];
  if (!s) return [0, 0];
  if (M(s) && i && M(i)) return [b(s, t.width), b(i, t.height)];
  var a = Me(n);
  if (D(s) && (s.value === JA.CONTAIN || s.value === JA.COVER)) {
    if (Me(n)) {
      var o = t.width / t.height;
      return o < n != (s.value === JA.COVER) ? [t.width, t.width / n] : [t.height * n, t.height];
    }
    return [t.width, t.height];
  }
  var Q = Me(r), g = Me(B), w = Q || g;
  if (VA(s) && (!i || VA(i))) {
    if (Q && g) return [r, B];
    if (!a && !w) return [t.width, t.height];
    if (w && a) {
      var f = Q ? r : B * n, c = g ? B : r / n;
      return [f, c];
    }
    var C = Q ? r : t.width, H = g ? B : t.height;
    return [C, H];
  }
  if (a) {
    var h = 0, F = 0;
    return M(s) ? h = b(s, t.width) : M(i) && (F = b(i, t.height)), VA(s) ? h = F * n : (!i || VA(i)) && (F = h / n), [h, F];
  }
  var K = null, p = null;
  if (M(s) ? K = b(s, t.width) : i && M(i) && (p = b(i, t.height)), K !== null && (!i || VA(i)) && (p = Q && g ? K / r * B : t.height), p !== null && VA(s) && (K = Q && g ? p / B * r : t.width), K !== null && p !== null) return [K, p];
  throw new Error("Unable to calculate background-size for element");
};
var XA = function(e, A) {
  var t = e[A];
  return typeof t > "u" ? e[0] : t;
};
var fQ = function(e, A, t, r, B) {
  var n = A[0], s = A[1], i = t[0], a = t[1];
  switch (e) {
    case 2:
      return [new u(Math.round(r.left), Math.round(r.top + s)), new u(Math.round(r.left + r.width), Math.round(r.top + s)), new u(Math.round(r.left + r.width), Math.round(a + r.top + s)), new u(Math.round(r.left), Math.round(a + r.top + s))];
    case 3:
      return [new u(Math.round(r.left + n), Math.round(r.top)), new u(Math.round(r.left + n + i), Math.round(r.top)), new u(Math.round(r.left + n + i), Math.round(r.height + r.top)), new u(Math.round(r.left + n), Math.round(r.height + r.top))];
    case 1:
      return [new u(Math.round(r.left + n), Math.round(r.top + s)), new u(Math.round(r.left + n + i), Math.round(r.top + s)), new u(Math.round(r.left + n + i), Math.round(r.top + s + a)), new u(Math.round(r.left + n), Math.round(r.top + s + a))];
    default:
      return [new u(Math.round(B.left), Math.round(B.top)), new u(Math.round(B.left + B.width), Math.round(B.top)), new u(Math.round(B.left + B.width), Math.round(B.height + B.top)), new u(Math.round(B.left), Math.round(B.height + B.top))];
  }
};
var UQ = "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7";
var tB = "Hidden Text";
var FQ = (
  /** @class */
  function() {
    function e(A) {
      this._data = {}, this._document = A;
    }
    return e.prototype.parseMetrics = function(A, t) {
      var r = this._document.createElement("div"), B = this._document.createElement("img"), n = this._document.createElement("span"), s = this._document.body;
      r.style.visibility = "hidden", r.style.fontFamily = A, r.style.fontSize = t, r.style.margin = "0", r.style.padding = "0", r.style.whiteSpace = "nowrap", s.appendChild(r), B.src = UQ, B.width = 1, B.height = 1, B.style.margin = "0", B.style.padding = "0", B.style.verticalAlign = "baseline", n.style.fontFamily = A, n.style.fontSize = t, n.style.margin = "0", n.style.padding = "0", n.appendChild(this._document.createTextNode(tB)), r.appendChild(n), r.appendChild(B);
      var i = B.offsetTop - n.offsetTop + 2;
      r.removeChild(n), r.appendChild(this._document.createTextNode(tB)), r.style.lineHeight = "normal", B.style.verticalAlign = "super";
      var a = B.offsetTop - r.offsetTop + 2;
      return s.removeChild(r), {
        baseline: i,
        middle: a
      };
    }, e.prototype.getMetrics = function(A, t) {
      var r = A + " " + t;
      return typeof this._data[r] > "u" && (this._data[r] = this.parseMetrics(A, t)), this._data[r];
    }, e;
  }()
);
var sn = (
  /** @class */
  /* @__PURE__ */ function() {
    function e(A, t) {
      this.context = A, this.options = t;
    }
    return e;
  }()
);
var hQ = 1e4;
var dQ = (
  /** @class */
  function(e) {
    tA(A, e);
    function A(t, r) {
      var B = e.call(this, t, r) || this;
      return B._activeEffects = [], B.canvas = r.canvas ? r.canvas : document.createElement("canvas"), B.ctx = B.canvas.getContext("2d"), r.canvas || (B.canvas.width = Math.floor(r.width * r.scale), B.canvas.height = Math.floor(r.height * r.scale), B.canvas.style.width = r.width + "px", B.canvas.style.height = r.height + "px"), B.fontMetrics = new FQ(document), B.ctx.scale(B.options.scale, B.options.scale), B.ctx.translate(-r.x, -r.y), B.ctx.textBaseline = "bottom", B._activeEffects = [], B.context.logger.debug("Canvas renderer initialized (" + r.width + "x" + r.height + ") with scale " + r.scale), B;
    }
    return A.prototype.applyEffects = function(t) {
      for (var r = this; this._activeEffects.length; ) this.popEffect();
      t.forEach(function(B) {
        return r.applyEffect(B);
      });
    }, A.prototype.applyEffect = function(t) {
      this.ctx.save(), iQ(t) && (this.ctx.globalAlpha = t.opacity), aQ(t) && (this.ctx.translate(t.offsetX, t.offsetY), this.ctx.transform(t.matrix[0], t.matrix[1], t.matrix[2], t.matrix[3], t.matrix[4], t.matrix[5]), this.ctx.translate(-t.offsetX, -t.offsetY)), en(t) && (this.path(t.path), this.ctx.clip()), this._activeEffects.push(t);
    }, A.prototype.popEffect = function() {
      this._activeEffects.pop(), this.ctx.restore();
    }, A.prototype.renderStack = function(t) {
      return P(this, void 0, void 0, function() {
        var r;
        return _(this, function(B) {
          switch (B.label) {
            case 0:
              return r = t.element.container.styles, r.isVisible() ? [4, this.renderStackContent(t)] : [3, 2];
            case 1:
              B.sent(), B.label = 2;
            case 2:
              return [
                2
                /*return*/
              ];
          }
        });
      });
    }, A.prototype.renderNode = function(t) {
      return P(this, void 0, void 0, function() {
        return _(this, function(r) {
          switch (r.label) {
            case 0:
              if (G(
                t.container.flags,
                16
                /* DEBUG_RENDER */
              )) debugger;
              return t.container.styles.isVisible() ? [4, this.renderNodeBackgroundAndBorders(t)] : [3, 3];
            case 1:
              return r.sent(), [4, this.renderNodeContent(t)];
            case 2:
              r.sent(), r.label = 3;
            case 3:
              return [
                2
                /*return*/
              ];
          }
        });
      });
    }, A.prototype.renderTextWithLetterSpacing = function(t, r, B) {
      var n = this;
      if (r === 0) this.ctx.fillText(t.text, t.bounds.left, t.bounds.top + B);
      else {
        var s = rt(t.text);
        s.reduce(function(i, a) {
          return n.ctx.fillText(a, i, t.bounds.top + B), i + n.ctx.measureText(a).width;
        }, t.bounds.left);
      }
    }, A.prototype.createFontStyle = function(t) {
      var r = t.fontVariant.filter(function(s) {
        return s === "normal" || s === "small-caps";
      }).join(""), B = vQ(t.fontFamily).join(", "), n = Ce(t.fontSize) ? "" + t.fontSize.number + t.fontSize.unit : t.fontSize.number + "px";
      return [[t.fontStyle, r, t.fontWeight, n, B].join(" "), B, n];
    }, A.prototype.renderTextNode = function(t, r) {
      return P(this, void 0, void 0, function() {
        var B, n, s, i, a, o, Q, g, w = this;
        return _(this, function(f) {
          return B = this.createFontStyle(r), n = B[0], s = B[1], i = B[2], this.ctx.font = n, this.ctx.direction = r.direction === 1 ? "rtl" : "ltr", this.ctx.textAlign = "left", this.ctx.textBaseline = "alphabetic", a = this.fontMetrics.getMetrics(s, i), o = a.baseline, Q = a.middle, g = r.paintOrder, t.textBounds.forEach(function(c) {
            g.forEach(function(C) {
              switch (C) {
                case 0:
                  w.ctx.fillStyle = R(r.color), w.renderTextWithLetterSpacing(c, r.letterSpacing, o);
                  var H = r.textShadow;
                  H.length && c.text.trim().length && (H.slice(0).reverse().forEach(function(h) {
                    w.ctx.shadowColor = R(h.color), w.ctx.shadowOffsetX = h.offsetX.number * w.options.scale, w.ctx.shadowOffsetY = h.offsetY.number * w.options.scale, w.ctx.shadowBlur = h.blur.number, w.renderTextWithLetterSpacing(c, r.letterSpacing, o);
                  }), w.ctx.shadowColor = "", w.ctx.shadowOffsetX = 0, w.ctx.shadowOffsetY = 0, w.ctx.shadowBlur = 0), r.textDecorationLine.length && (w.ctx.fillStyle = R(r.textDecorationColor || r.color), r.textDecorationLine.forEach(function(h) {
                    switch (h) {
                      case 1:
                        w.ctx.fillRect(c.bounds.left, Math.round(c.bounds.top + o), c.bounds.width, 1);
                        break;
                      case 2:
                        w.ctx.fillRect(c.bounds.left, Math.round(c.bounds.top), c.bounds.width, 1);
                        break;
                      case 3:
                        w.ctx.fillRect(c.bounds.left, Math.ceil(c.bounds.top + Q), c.bounds.width, 1);
                        break;
                    }
                  }));
                  break;
                case 1:
                  r.webkitTextStrokeWidth && c.text.trim().length && (w.ctx.strokeStyle = R(r.webkitTextStrokeColor), w.ctx.lineWidth = r.webkitTextStrokeWidth, w.ctx.lineJoin = window.chrome ? "miter" : "round", w.ctx.strokeText(c.text, c.bounds.left, c.bounds.top + o)), w.ctx.strokeStyle = "", w.ctx.lineWidth = 0, w.ctx.lineJoin = "miter";
                  break;
              }
            });
          }), [
            2
            /*return*/
          ];
        });
      });
    }, A.prototype.renderReplacedElement = function(t, r, B) {
      if (B && t.intrinsicWidth > 0 && t.intrinsicHeight > 0) {
        var n = je(t), s = qe(r);
        this.path(s), this.ctx.save(), this.ctx.clip(), this.ctx.drawImage(B, 0, 0, t.intrinsicWidth, t.intrinsicHeight, n.left, n.top, n.width, n.height), this.ctx.restore();
      }
    }, A.prototype.renderNodeContent = function(t) {
      return P(this, void 0, void 0, function() {
        var r, B, n, s, i, a, F, F, o, Q, g, w, p, f, c, d, C, H, h, F, K, p, d;
        return _(this, function(l) {
          switch (l.label) {
            case 0:
              this.applyEffects(t.getEffects(
                4
                /* CONTENT */
              )), r = t.container, B = t.curves, n = r.styles, s = 0, i = r.textNodes, l.label = 1;
            case 1:
              return s < i.length ? (a = i[s], [4, this.renderTextNode(a, n)]) : [3, 4];
            case 2:
              l.sent(), l.label = 3;
            case 3:
              return s++, [3, 1];
            case 4:
              if (!(r instanceof GB)) return [3, 8];
              l.label = 5;
            case 5:
              return l.trys.push([5, 7, , 8]), [4, this.context.cache.match(r.src)];
            case 6:
              return F = l.sent(), this.renderReplacedElement(r, B, F), [3, 8];
            case 7:
              return l.sent(), this.context.logger.error("Error loading image " + r.src), [3, 8];
            case 8:
              if (r instanceof RB && this.renderReplacedElement(r, B, r.canvas), !(r instanceof VB)) return [3, 12];
              l.label = 9;
            case 9:
              return l.trys.push([9, 11, , 12]), [4, this.context.cache.match(r.svg)];
            case 10:
              return F = l.sent(), this.renderReplacedElement(r, B, F), [3, 12];
            case 11:
              return l.sent(), this.context.logger.error("Error loading svg " + r.svg.substring(0, 255)), [3, 12];
            case 12:
              return r instanceof JB && r.tree ? (o = new A(this.context, {
                scale: this.options.scale,
                backgroundColor: r.backgroundColor,
                x: 0,
                y: 0,
                width: r.width,
                height: r.height
              }), [4, o.render(r.tree)]) : [3, 14];
            case 13:
              Q = l.sent(), r.width && r.height && this.ctx.drawImage(Q, 0, 0, r.width, r.height, r.bounds.left, r.bounds.top, r.bounds.width, r.bounds.height), l.label = 14;
            case 14:
              if (r instanceof tt && (g = Math.min(r.bounds.width, r.bounds.height), r.type === Pe ? r.checked && (this.ctx.save(), this.path([new u(r.bounds.left + g * 0.39363, r.bounds.top + g * 0.79), new u(r.bounds.left + g * 0.16, r.bounds.top + g * 0.5549), new u(r.bounds.left + g * 0.27347, r.bounds.top + g * 0.44071), new u(r.bounds.left + g * 0.39694, r.bounds.top + g * 0.5649), new u(r.bounds.left + g * 0.72983, r.bounds.top + g * 0.23), new u(r.bounds.left + g * 0.84, r.bounds.top + g * 0.34085), new u(r.bounds.left + g * 0.39363, r.bounds.top + g * 0.79)]), this.ctx.fillStyle = R(Jt), this.ctx.fill(), this.ctx.restore()) : r.type === ke && r.checked && (this.ctx.save(), this.ctx.beginPath(), this.ctx.arc(r.bounds.left + g / 2, r.bounds.top + g / 2, g / 4, 0, Math.PI * 2, true), this.ctx.fillStyle = R(Jt), this.ctx.fill(), this.ctx.restore())), EQ(r) && r.value.length) {
                switch (w = this.createFontStyle(n), p = w[0], f = w[1], c = this.fontMetrics.getMetrics(p, f).baseline, this.ctx.font = p, this.ctx.fillStyle = R(n.color), this.ctx.textBaseline = "alphabetic", this.ctx.textAlign = pQ(r.styles.textAlign), d = je(r), C = 0, r.styles.textAlign) {
                  case 1:
                    C += d.width / 2;
                    break;
                  case 2:
                    C += d.width;
                    break;
                }
                H = d.add(C, 0, 0, -d.height / 2 + 1), this.ctx.save(), this.path([new u(d.left, d.top), new u(d.left + d.width, d.top), new u(d.left + d.width, d.top + d.height), new u(d.left, d.top + d.height)]), this.ctx.clip(), this.renderTextWithLetterSpacing(new ie(r.value, H), n.letterSpacing, c), this.ctx.restore(), this.ctx.textBaseline = "alphabetic", this.ctx.textAlign = "left";
              }
              if (!G(
                r.styles.display,
                2048
                /* LIST_ITEM */
              )) return [3, 20];
              if (r.styles.listStyleImage === null) return [3, 19];
              if (h = r.styles.listStyleImage, h.type !== 0) return [3, 18];
              F = void 0, K = h.url, l.label = 15;
            case 15:
              return l.trys.push([15, 17, , 18]), [4, this.context.cache.match(K)];
            case 16:
              return F = l.sent(), this.ctx.drawImage(F, r.bounds.left - (F.width + 10), r.bounds.top), [3, 18];
            case 17:
              return l.sent(), this.context.logger.error("Error loading list-style-image " + K), [3, 18];
            case 18:
              return [3, 20];
            case 19:
              t.listValue && r.styles.listStyleType !== -1 && (p = this.createFontStyle(n)[0], this.ctx.font = p, this.ctx.fillStyle = R(n.color), this.ctx.textBaseline = "middle", this.ctx.textAlign = "right", d = new cA(r.bounds.left, r.bounds.top + b(r.styles.paddingTop, r.bounds.width), r.bounds.width, yt(n.lineHeight, n.fontSize.number) / 2 + 1), this.renderTextWithLetterSpacing(new ie(t.listValue, d), n.letterSpacing, yt(n.lineHeight, n.fontSize.number) / 2 + 2), this.ctx.textBaseline = "bottom", this.ctx.textAlign = "left"), l.label = 20;
            case 20:
              return [
                2
                /*return*/
              ];
          }
        });
      });
    }, A.prototype.renderStackContent = function(t) {
      return P(this, void 0, void 0, function() {
        var r, B, h, n, s, h, i, a, h, o, Q, h, g, w, h, f, c, h, C, H, h;
        return _(this, function(F) {
          switch (F.label) {
            case 0:
              if (G(
                t.element.container.flags,
                16
                /* DEBUG_RENDER */
              )) debugger;
              return [4, this.renderNodeBackgroundAndBorders(t.element)];
            case 1:
              F.sent(), r = 0, B = t.negativeZIndex, F.label = 2;
            case 2:
              return r < B.length ? (h = B[r], [4, this.renderStack(h)]) : [3, 5];
            case 3:
              F.sent(), F.label = 4;
            case 4:
              return r++, [3, 2];
            case 5:
              return [4, this.renderNodeContent(t.element)];
            case 6:
              F.sent(), n = 0, s = t.nonInlineLevel, F.label = 7;
            case 7:
              return n < s.length ? (h = s[n], [4, this.renderNode(h)]) : [3, 10];
            case 8:
              F.sent(), F.label = 9;
            case 9:
              return n++, [3, 7];
            case 10:
              i = 0, a = t.nonPositionedFloats, F.label = 11;
            case 11:
              return i < a.length ? (h = a[i], [4, this.renderStack(h)]) : [3, 14];
            case 12:
              F.sent(), F.label = 13;
            case 13:
              return i++, [3, 11];
            case 14:
              o = 0, Q = t.nonPositionedInlineLevel, F.label = 15;
            case 15:
              return o < Q.length ? (h = Q[o], [4, this.renderStack(h)]) : [3, 18];
            case 16:
              F.sent(), F.label = 17;
            case 17:
              return o++, [3, 15];
            case 18:
              g = 0, w = t.inlineLevel, F.label = 19;
            case 19:
              return g < w.length ? (h = w[g], [4, this.renderNode(h)]) : [3, 22];
            case 20:
              F.sent(), F.label = 21;
            case 21:
              return g++, [3, 19];
            case 22:
              f = 0, c = t.zeroOrAutoZIndexOrTransformedOrOpacity, F.label = 23;
            case 23:
              return f < c.length ? (h = c[f], [4, this.renderStack(h)]) : [3, 26];
            case 24:
              F.sent(), F.label = 25;
            case 25:
              return f++, [3, 23];
            case 26:
              C = 0, H = t.positiveZIndex, F.label = 27;
            case 27:
              return C < H.length ? (h = H[C], [4, this.renderStack(h)]) : [3, 30];
            case 28:
              F.sent(), F.label = 29;
            case 29:
              return C++, [3, 27];
            case 30:
              return [
                2
                /*return*/
              ];
          }
        });
      });
    }, A.prototype.mask = function(t) {
      this.ctx.beginPath(), this.ctx.moveTo(0, 0), this.ctx.lineTo(this.canvas.width, 0), this.ctx.lineTo(this.canvas.width, this.canvas.height), this.ctx.lineTo(0, this.canvas.height), this.ctx.lineTo(0, 0), this.formatPath(t.slice(0).reverse()), this.ctx.closePath();
    }, A.prototype.path = function(t) {
      this.ctx.beginPath(), this.formatPath(t), this.ctx.closePath();
    }, A.prototype.formatPath = function(t) {
      var r = this;
      t.forEach(function(B, n) {
        var s = $(B) ? B.start : B;
        n === 0 ? r.ctx.moveTo(s.x, s.y) : r.ctx.lineTo(s.x, s.y), $(B) && r.ctx.bezierCurveTo(B.startControl.x, B.startControl.y, B.endControl.x, B.endControl.y, B.end.x, B.end.y);
      });
    }, A.prototype.renderRepeat = function(t, r, B, n) {
      this.path(t), this.ctx.fillStyle = r, this.ctx.translate(B, n), this.ctx.fill(), this.ctx.translate(-B, -n);
    }, A.prototype.resizeImage = function(t, r, B) {
      var n;
      if (t.width === r && t.height === B) return t;
      var s = (n = this.canvas.ownerDocument) !== null && n !== void 0 ? n : document, i = s.createElement("canvas");
      i.width = Math.max(1, r), i.height = Math.max(1, B);
      var a = i.getContext("2d");
      return a.drawImage(t, 0, 0, t.width, t.height, 0, 0, r, B), i;
    }, A.prototype.renderBackgroundImage = function(t) {
      return P(this, void 0, void 0, function() {
        var r, B, n, s, i, a;
        return _(this, function(o) {
          switch (o.label) {
            case 0:
              r = t.styles.backgroundImage.length - 1, B = function(Q) {
                var g, w, f, O, Y, W, L, V, y, c, O, Y, W, L, V, C, H, h, F, K, p, d, l, v, y, E, O, k, q, L, V, CA, Y, W, IA, BA, uA, vA, yA, iA, KA, oA;
                return _(this, function(TA) {
                  switch (TA.label) {
                    case 0:
                      if (Q.type !== 0) return [3, 5];
                      g = void 0, w = Q.url, TA.label = 1;
                    case 1:
                      return TA.trys.push([1, 3, , 4]), [4, n.context.cache.match(w)];
                    case 2:
                      return g = TA.sent(), [3, 4];
                    case 3:
                      return TA.sent(), n.context.logger.error("Error loading background-image " + w), [3, 4];
                    case 4:
                      return g && (f = Kr(t, r, [g.width, g.height, g.width / g.height]), O = f[0], Y = f[1], W = f[2], L = f[3], V = f[4], y = n.ctx.createPattern(n.resizeImage(g, L, V), "repeat"), n.renderRepeat(O, y, Y, W)), [3, 6];
                    case 5:
                      sa(Q) ? (c = Kr(t, r, [null, null, null]), O = c[0], Y = c[1], W = c[2], L = c[3], V = c[4], C = ea(Q.angle, L, V), H = C[0], h = C[1], F = C[2], K = C[3], p = C[4], d = document.createElement("canvas"), d.width = L, d.height = V, l = d.getContext("2d"), v = l.createLinearGradient(h, K, F, p), It(Q.stops, H).forEach(function(YA) {
                        return v.addColorStop(YA.stop, R(YA.color));
                      }), l.fillStyle = v, l.fillRect(0, 0, L, V), L > 0 && V > 0 && (y = n.ctx.createPattern(d, "repeat"), n.renderRepeat(O, y, Y, W))) : aa(Q) && (E = Kr(t, r, [null, null, null]), O = E[0], k = E[1], q = E[2], L = E[3], V = E[4], CA = Q.position.length === 0 ? [$r] : Q.position, Y = b(CA[0], L), W = b(CA[CA.length - 1], V), IA = ra(Q, Y, W, L, V), BA = IA[0], uA = IA[1], BA > 0 && uA > 0 && (vA = n.ctx.createRadialGradient(k + Y, q + W, 0, k + Y, q + W, BA), It(Q.stops, BA * 2).forEach(function(YA) {
                        return vA.addColorStop(YA.stop, R(YA.color));
                      }), n.path(O), n.ctx.fillStyle = vA, BA !== uA ? (yA = t.bounds.left + 0.5 * t.bounds.width, iA = t.bounds.top + 0.5 * t.bounds.height, KA = uA / BA, oA = 1 / KA, n.ctx.save(), n.ctx.translate(yA, iA), n.ctx.transform(1, 0, 0, KA, 0, 0), n.ctx.translate(-yA, -iA), n.ctx.fillRect(k, oA * (q - iA) + iA, L, V * oA), n.ctx.restore()) : n.ctx.fill())), TA.label = 6;
                    case 6:
                      return r--, [
                        2
                        /*return*/
                      ];
                  }
                });
              }, n = this, s = 0, i = t.styles.backgroundImage.slice(0).reverse(), o.label = 1;
            case 1:
              return s < i.length ? (a = i[s], [5, B(a)]) : [3, 4];
            case 2:
              o.sent(), o.label = 3;
            case 3:
              return s++, [3, 1];
            case 4:
              return [
                2
                /*return*/
              ];
          }
        });
      });
    }, A.prototype.renderSolidBorder = function(t, r, B) {
      return P(this, void 0, void 0, function() {
        return _(this, function(n) {
          return this.path(rB(B, r)), this.ctx.fillStyle = R(t), this.ctx.fill(), [
            2
            /*return*/
          ];
        });
      });
    }, A.prototype.renderDoubleBorder = function(t, r, B, n) {
      return P(this, void 0, void 0, function() {
        var s, i;
        return _(this, function(a) {
          switch (a.label) {
            case 0:
              return r < 3 ? [4, this.renderSolidBorder(t, B, n)] : [3, 2];
            case 1:
              return a.sent(), [
                2
                /*return*/
              ];
            case 2:
              return s = gQ(n, B), this.path(s), this.ctx.fillStyle = R(t), this.ctx.fill(), i = wQ(n, B), this.path(i), this.ctx.fill(), [
                2
                /*return*/
              ];
          }
        });
      });
    }, A.prototype.renderNodeBackgroundAndBorders = function(t) {
      return P(this, void 0, void 0, function() {
        var r, B, n, s, i, a, o, Q, g = this;
        return _(this, function(w) {
          switch (w.label) {
            case 0:
              return this.applyEffects(t.getEffects(
                2
                /* BACKGROUND_BORDERS */
              )), r = t.container.styles, B = !HA(r.backgroundColor) || r.backgroundImage.length, n = [{
                style: r.borderTopStyle,
                color: r.borderTopColor,
                width: r.borderTopWidth
              }, {
                style: r.borderRightStyle,
                color: r.borderRightColor,
                width: r.borderRightWidth
              }, {
                style: r.borderBottomStyle,
                color: r.borderBottomColor,
                width: r.borderBottomWidth
              }, {
                style: r.borderLeftStyle,
                color: r.borderLeftColor,
                width: r.borderLeftWidth
              }], s = HQ(XA(r.backgroundClip, 0), t.curves), B || r.boxShadow.length ? (this.ctx.save(), this.path(s), this.ctx.clip(), HA(r.backgroundColor) || (this.ctx.fillStyle = R(r.backgroundColor), this.ctx.fill()), [4, this.renderBackgroundImage(t.container)]) : [3, 2];
            case 1:
              w.sent(), this.ctx.restore(), r.boxShadow.slice(0).reverse().forEach(function(f) {
                g.ctx.save();
                var c = Ze(t.curves), C = f.inset ? 0 : hQ, H = oQ(c, -C + (f.inset ? 1 : -1) * f.spread.number, (f.inset ? 1 : -1) * f.spread.number, f.spread.number * (f.inset ? -2 : 2), f.spread.number * (f.inset ? -2 : 2));
                f.inset ? (g.path(c), g.ctx.clip(), g.mask(H)) : (g.mask(c), g.ctx.clip(), g.path(H)), g.ctx.shadowOffsetX = f.offsetX.number + C, g.ctx.shadowOffsetY = f.offsetY.number, g.ctx.shadowColor = R(f.color), g.ctx.shadowBlur = f.blur.number, g.ctx.fillStyle = f.inset ? R(f.color) : "rgba(0,0,0,1)", g.ctx.fill(), g.ctx.restore();
              }), w.label = 2;
            case 2:
              i = 0, a = 0, o = n, w.label = 3;
            case 3:
              return a < o.length ? (Q = o[a], Q.style !== 0 && !HA(Q.color) && Q.width > 0 ? Q.style !== 2 ? [3, 5] : [4, this.renderDashedDottedBorder(
                Q.color,
                Q.width,
                i,
                t.curves,
                2
                /* DASHED */
              )] : [3, 11]) : [3, 13];
            case 4:
              return w.sent(), [3, 11];
            case 5:
              return Q.style !== 3 ? [3, 7] : [4, this.renderDashedDottedBorder(
                Q.color,
                Q.width,
                i,
                t.curves,
                3
                /* DOTTED */
              )];
            case 6:
              return w.sent(), [3, 11];
            case 7:
              return Q.style !== 4 ? [3, 9] : [4, this.renderDoubleBorder(Q.color, Q.width, i, t.curves)];
            case 8:
              return w.sent(), [3, 11];
            case 9:
              return [4, this.renderSolidBorder(Q.color, i, t.curves)];
            case 10:
              w.sent(), w.label = 11;
            case 11:
              i++, w.label = 12;
            case 12:
              return a++, [3, 3];
            case 13:
              return [
                2
                /*return*/
              ];
          }
        });
      });
    }, A.prototype.renderDashedDottedBorder = function(t, r, B, n, s) {
      return P(this, void 0, void 0, function() {
        var i, a, o, Q, g, w, f, c, C, H, h, F, K, p, d, l, d, l;
        return _(this, function(v) {
          return this.ctx.save(), i = cQ(n, B), a = rB(n, B), s === 2 && (this.path(a), this.ctx.clip()), $(a[0]) ? (o = a[0].start.x, Q = a[0].start.y) : (o = a[0].x, Q = a[0].y), $(a[1]) ? (g = a[1].end.x, w = a[1].end.y) : (g = a[1].x, w = a[1].y), B === 0 || B === 2 ? f = Math.abs(o - g) : f = Math.abs(Q - w), this.ctx.beginPath(), s === 3 ? this.formatPath(i) : this.formatPath(a.slice(0, 2)), c = r < 3 ? r * 3 : r * 2, C = r < 3 ? r * 2 : r, s === 3 && (c = r, C = r), H = true, f <= c * 2 ? H = false : f <= c * 2 + C ? (h = f / (2 * c + C), c *= h, C *= h) : (F = Math.floor((f + C) / (c + C)), K = (f - F * c) / (F - 1), p = (f - (F + 1) * c) / F, C = p <= 0 || Math.abs(C - K) < Math.abs(C - p) ? K : p), H && (s === 3 ? this.ctx.setLineDash([0, c + C]) : this.ctx.setLineDash([c, C])), s === 3 ? (this.ctx.lineCap = "round", this.ctx.lineWidth = r) : this.ctx.lineWidth = r * 2 + 1.1, this.ctx.strokeStyle = R(t), this.ctx.stroke(), this.ctx.setLineDash([]), s === 2 && ($(a[0]) && (d = a[3], l = a[0], this.ctx.beginPath(), this.formatPath([new u(d.end.x, d.end.y), new u(l.start.x, l.start.y)]), this.ctx.stroke()), $(a[1]) && (d = a[1], l = a[2], this.ctx.beginPath(), this.formatPath([new u(d.end.x, d.end.y), new u(l.start.x, l.start.y)]), this.ctx.stroke())), this.ctx.restore(), [
            2
            /*return*/
          ];
        });
      });
    }, A.prototype.render = function(t) {
      return P(this, void 0, void 0, function() {
        var r;
        return _(this, function(B) {
          switch (B.label) {
            case 0:
              return this.options.backgroundColor && (this.ctx.fillStyle = R(this.options.backgroundColor), this.ctx.fillRect(this.options.x, this.options.y, this.options.width, this.options.height)), r = QQ(t), [4, this.renderStack(r)];
            case 1:
              return B.sent(), this.applyEffects([]), [2, this.canvas];
          }
        });
      });
    }, A;
  }(sn)
);
var EQ = function(e) {
  return e instanceof _B || e instanceof XB ? true : e instanceof tt && e.type !== ke && e.type !== Pe;
};
var HQ = function(e, A) {
  switch (e) {
    case 0:
      return Ze(A);
    case 2:
      return BQ(A);
    case 1:
    default:
      return qe(A);
  }
};
var pQ = function(e) {
  switch (e) {
    case 1:
      return "center";
    case 2:
      return "right";
    case 0:
    default:
      return "left";
  }
};
var IQ = ["-apple-system", "system-ui"];
var vQ = function(e) {
  return /iPhone OS 15_(0|1)/.test(window.navigator.userAgent) ? e.filter(function(A) {
    return IQ.indexOf(A) === -1;
  }) : e;
};
var yQ = (
  /** @class */
  function(e) {
    tA(A, e);
    function A(t, r) {
      var B = e.call(this, t, r) || this;
      return B.canvas = r.canvas ? r.canvas : document.createElement("canvas"), B.ctx = B.canvas.getContext("2d"), B.options = r, B.canvas.width = Math.floor(r.width * r.scale), B.canvas.height = Math.floor(r.height * r.scale), B.canvas.style.width = r.width + "px", B.canvas.style.height = r.height + "px", B.ctx.scale(B.options.scale, B.options.scale), B.ctx.translate(-r.x, -r.y), B.context.logger.debug("EXPERIMENTAL ForeignObject renderer initialized (" + r.width + "x" + r.height + " at " + r.x + "," + r.y + ") with scale " + r.scale), B;
    }
    return A.prototype.render = function(t) {
      return P(this, void 0, void 0, function() {
        var r, B;
        return _(this, function(n) {
          switch (n.label) {
            case 0:
              return r = Pr(this.options.width * this.options.scale, this.options.height * this.options.scale, this.options.scale, this.options.scale, t), [4, KQ(r)];
            case 1:
              return B = n.sent(), this.options.backgroundColor && (this.ctx.fillStyle = R(this.options.backgroundColor), this.ctx.fillRect(0, 0, this.options.width * this.options.scale, this.options.height * this.options.scale)), this.ctx.drawImage(B, -this.options.x * this.options.scale, -this.options.y * this.options.scale), [2, this.canvas];
          }
        });
      });
    }, A;
  }(sn)
);
var KQ = function(e) {
  return new Promise(function(A, t) {
    var r = new Image();
    r.onload = function() {
      A(r);
    }, r.onerror = t, r.src = "data:image/svg+xml;charset=utf-8," + encodeURIComponent(new XMLSerializer().serializeToString(e));
  });
};
var mQ = (
  /** @class */
  function() {
    function e(A) {
      var t = A.id, r = A.enabled;
      this.id = t, this.enabled = r, this.start = Date.now();
    }
    return e.prototype.debug = function() {
      for (var A = [], t = 0; t < arguments.length; t++) A[t] = arguments[t];
      this.enabled && (typeof window < "u" && window.console && typeof console.debug == "function" ? console.debug.apply(console, ue([this.id, this.getTime() + "ms"], A)) : this.info.apply(this, A));
    }, e.prototype.getTime = function() {
      return Date.now() - this.start;
    }, e.prototype.info = function() {
      for (var A = [], t = 0; t < arguments.length; t++) A[t] = arguments[t];
      this.enabled && typeof window < "u" && window.console && typeof console.info == "function" && console.info.apply(console, ue([this.id, this.getTime() + "ms"], A));
    }, e.prototype.warn = function() {
      for (var A = [], t = 0; t < arguments.length; t++) A[t] = arguments[t];
      this.enabled && (typeof window < "u" && window.console && typeof console.warn == "function" ? console.warn.apply(console, ue([this.id, this.getTime() + "ms"], A)) : this.info.apply(this, A));
    }, e.prototype.error = function() {
      for (var A = [], t = 0; t < arguments.length; t++) A[t] = arguments[t];
      this.enabled && (typeof window < "u" && window.console && typeof console.error == "function" ? console.error.apply(console, ue([this.id, this.getTime() + "ms"], A)) : this.info.apply(this, A));
    }, e.instances = {}, e;
  }()
);
var LQ = (
  /** @class */
  function() {
    function e(A, t) {
      var r;
      this.windowBounds = t, this.instanceName = "#" + e.instanceCount++, this.logger = new mQ({
        id: this.instanceName,
        enabled: A.logging
      }), this.cache = (r = A.cache) !== null && r !== void 0 ? r : new qo(this, A);
    }
    return e.instanceCount = 1, e;
  }()
);
var xQ = function(e, A) {
  return A === void 0 && (A = {}), DQ(e, A);
};
typeof window < "u" && An.setContext(window);
var DQ = function(e, A) {
  return P(void 0, void 0, void 0, function() {
    var t, r, B, n, s, i, a, o, Q, g, w, f, c, C, H, h, F, K, p, d, v, l, v, y, E, O, k, q, L, V, CA, Y, W, IA, BA, uA, vA, yA, iA, KA;
    return _(this, function(oA) {
      switch (oA.label) {
        case 0:
          if (!e || typeof e != "object") return [2, Promise.reject("Invalid element provided as first argument")];
          if (t = e.ownerDocument, !t) throw new Error("Element is not attached to a Document");
          if (r = t.defaultView, !r) throw new Error("Document is not attached to a Window");
          return B = {
            allowTaint: (y = A.allowTaint) !== null && y !== void 0 ? y : false,
            imageTimeout: (E = A.imageTimeout) !== null && E !== void 0 ? E : 15e3,
            proxy: A.proxy,
            useCORS: (O = A.useCORS) !== null && O !== void 0 ? O : false
          }, n = Lr({
            logging: (k = A.logging) !== null && k !== void 0 ? k : true,
            cache: A.cache
          }, B), s = {
            windowWidth: (q = A.windowWidth) !== null && q !== void 0 ? q : r.innerWidth,
            windowHeight: (L = A.windowHeight) !== null && L !== void 0 ? L : r.innerHeight,
            scrollX: (V = A.scrollX) !== null && V !== void 0 ? V : r.pageXOffset,
            scrollY: (CA = A.scrollY) !== null && CA !== void 0 ? CA : r.pageYOffset
          }, i = new cA(s.scrollX, s.scrollY, s.windowWidth, s.windowHeight), a = new LQ(n, i), o = (Y = A.foreignObjectRendering) !== null && Y !== void 0 ? Y : false, Q = {
            allowTaint: (W = A.allowTaint) !== null && W !== void 0 ? W : false,
            onclone: A.onclone,
            ignoreElements: A.ignoreElements,
            inlineImages: o,
            copyStyles: o
          }, a.logger.debug("Starting document clone with size " + i.width + "x" + i.height + " scrolled to " + -i.left + "," + -i.top), g = new $t(a, e, Q), w = g.clonedReferenceElement, w ? [4, g.toIFrame(t, i)] : [2, Promise.reject("Unable to find element in cloned iframe")];
        case 1:
          return f = oA.sent(), c = Bt(w) || xo(w) ? an(w.ownerDocument) : ze(a, w), C = c.width, H = c.height, h = c.left, F = c.top, K = bQ(a, w, A.backgroundColor), p = {
            canvas: A.canvas,
            backgroundColor: K,
            scale: (BA = (IA = A.scale) !== null && IA !== void 0 ? IA : r.devicePixelRatio) !== null && BA !== void 0 ? BA : 1,
            x: ((uA = A.x) !== null && uA !== void 0 ? uA : 0) + h,
            y: ((vA = A.y) !== null && vA !== void 0 ? vA : 0) + F,
            width: (yA = A.width) !== null && yA !== void 0 ? yA : Math.ceil(C),
            height: (iA = A.height) !== null && iA !== void 0 ? iA : Math.ceil(H)
          }, o ? (a.logger.debug("Document cloned, using foreign object rendering"), v = new yQ(a, p), [4, v.render(w)]) : [3, 3];
        case 2:
          return d = oA.sent(), [3, 5];
        case 3:
          return a.logger.debug("Document cloned, element located at " + h + "," + F + " with size " + C + "x" + H + " using computed rendering"), a.logger.debug("Starting DOM parsing"), l = kB(a, w), K === l.styles.backgroundColor && (l.styles.backgroundColor = wA.TRANSPARENT), a.logger.debug("Starting renderer for element at " + p.x + "," + p.y + " with size " + p.width + "x" + p.height), v = new dQ(a, p), [4, v.render(l)];
        case 4:
          d = oA.sent(), oA.label = 5;
        case 5:
          return (!((KA = A.removeContainer) !== null && KA !== void 0) || KA) && ($t.destroy(f) || a.logger.error("Cannot detach cloned iframe as it is not in the DOM anymore")), a.logger.debug("Finished rendering"), [2, d];
      }
    });
  });
};
var bQ = function(e, A, t) {
  var r = A.ownerDocument, B = r.documentElement ? se(e, getComputedStyle(r.documentElement).backgroundColor) : wA.TRANSPARENT, n = r.body ? se(e, getComputedStyle(r.body).backgroundColor) : wA.TRANSPARENT, s = typeof t == "string" ? se(e, t) : t === null ? wA.TRANSPARENT : 4294967295;
  return A === r.documentElement ? HA(B) ? HA(n) ? s : n : B : s;
};
export {
  xQ as default
};
/*! Bundled license information:

@mindfiredigital/pivothead/dist/html2canvas.esm-1a1724a1.mjs:
  (*!
   * html2canvas 1.4.1 <https://html2canvas.hertzen.com>
   * Copyright (c) 2022 Niklas von Hertzen <https://hertzen.com>
   * Released under MIT License
   *)
  (*! *****************************************************************************
  Copyright (c) Microsoft Corporation.
  
  Permission to use, copy, modify, and/or distribute this software for any
  purpose with or without fee is hereby granted.
  
  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
  REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
  AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
  INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
  LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
  OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
  PERFORMANCE OF THIS SOFTWARE.
  ***************************************************************************** *)
*/
//# sourceMappingURL=html2canvas.esm-1a1724a1-JMHMFZKW.js.map



================================================
FILE: .angular/cache/18.2.20/angular-pivothead-example/vite/deps/index.es-980ec5f7-65FC5NO6.js
================================================
import {
  Wt
} from "./chunk-JBLJVEST.js";
import "./chunk-WDMUDEB6.js";

// node_modules/@mindfiredigital/pivothead-angular/node_modules/@mindfiredigital/pivothead-web-component/node_modules/@mindfiredigital/pivothead/dist/index.es-980ec5f7.mjs
var Qe = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function Lo(a3) {
  return a3 && a3.__esModule && Object.prototype.hasOwnProperty.call(a3, "default") ? a3.default : a3;
}
var ht = function(a3) {
  return a3 && a3.Math === Math && a3;
};
var _ = (
  // eslint-disable-next-line es/no-global-this -- safe
  ht(typeof globalThis == "object" && globalThis) || ht(typeof window == "object" && window) || // eslint-disable-next-line no-restricted-globals -- safe
  ht(typeof self == "object" && self) || ht(typeof Qe == "object" && Qe) || ht(typeof Qe == "object" && Qe) || // eslint-disable-next-line no-new-func -- fallback
  /* @__PURE__ */ function() {
    return this;
  }() || Function("return this")()
);
var Et = {};
var D = function(a3) {
  try {
    return !!a3();
  } catch {
    return true;
  }
};
var Pl = D;
var he = !Pl(function() {
  return Object.defineProperty({}, 1, {
    get: function() {
      return 7;
    }
  })[1] !== 7;
});
var Rl = D;
var br = !Rl(function() {
  var a3 = function() {
  }.bind();
  return typeof a3 != "function" || a3.hasOwnProperty("prototype");
});
var Nl = br;
var Ft = Function.prototype.call;
var Y = Nl ? Ft.bind(Ft) : function() {
  return Ft.apply(Ft, arguments);
};
var ko = {};
var Bo = {}.propertyIsEnumerable;
var jo = Object.getOwnPropertyDescriptor;
var Il = jo && !Bo.call({
  1: 2
}, 1);
ko.f = Il ? function(e) {
  var t = jo(this, e);
  return !!t && t.enumerable;
} : Bo;
var Oi = function(a3, e) {
  return {
    enumerable: !(a3 & 1),
    configurable: !(a3 & 2),
    writable: !(a3 & 4),
    value: e
  };
};
var Fo = br;
var Uo = Function.prototype;
var Ya = Uo.call;
var Ml = Fo && Uo.bind.bind(Ya, Ya);
var L = Fo ? Ml : function(a3) {
  return function() {
    return Ya.apply(a3, arguments);
  };
};
var Go = L;
var _l = Go({}.toString);
var Vl = Go("".slice);
var je = function(a3) {
  return Vl(_l(a3), 8, -1);
};
var Dl = L;
var Ll = D;
var kl = je;
var Zr = Object;
var Bl = Dl("".split);
var zo = Ll(function() {
  return !Zr("z").propertyIsEnumerable(0);
}) ? function(a3) {
  return kl(a3) === "String" ? Bl(a3, "") : Zr(a3);
} : Zr;
var xr = function(a3) {
  return a3 == null;
};
var jl = xr;
var Fl = TypeError;
var ve = function(a3) {
  if (jl(a3)) throw new Fl("Can't call method on " + a3);
  return a3;
};
var Ul = zo;
var Gl = ve;
var $t = function(a3) {
  return Ul(Gl(a3));
};
var Jr = typeof document == "object" && document.all;
var B = typeof Jr > "u" && Jr !== void 0 ? function(a3) {
  return typeof a3 == "function" || a3 === Jr;
} : function(a3) {
  return typeof a3 == "function";
};
var zl = B;
var ae = function(a3) {
  return typeof a3 == "object" ? a3 !== null : zl(a3);
};
var ea = _;
var Hl = B;
var Yl = function(a3) {
  return Hl(a3) ? a3 : void 0;
};
var Fe = function(a3, e) {
  return arguments.length < 2 ? Yl(ea[a3]) : ea[a3] && ea[a3][e];
};
var Xl = L;
var Tr = Xl({}.isPrototypeOf);
var Wl = _;
var yn = Wl.navigator;
var mn = yn && yn.userAgent;
var wt = mn ? String(mn) : "";
var Ho = _;
var ta = wt;
var bn = Ho.process;
var xn = Ho.Deno;
var Tn = bn && bn.versions || xn && xn.version;
var On = Tn && Tn.v8;
var le;
var cr;
On && (le = On.split("."), cr = le[0] > 0 && le[0] < 4 ? 1 : +(le[0] + le[1]));
!cr && ta && (le = ta.match(/Edge\/(\d+)/), (!le || le[1] >= 74) && (le = ta.match(/Chrome\/(\d+)/), le && (cr = +le[1])));
var Si = cr;
var Sn = Si;
var ql = D;
var Ql = _;
var Kl = Ql.String;
var Yo = !!Object.getOwnPropertySymbols && !ql(function() {
  var a3 = Symbol("symbol detection");
  return !Kl(a3) || !(Object(a3) instanceof Symbol) || // Chrome 38-40 symbols are not inherited from DOM collections prototypes to instances
  !Symbol.sham && Sn && Sn < 41;
});
var Zl = Yo;
var Xo = Zl && !Symbol.sham && typeof Symbol.iterator == "symbol";
var Jl = Fe;
var eh = B;
var th = Tr;
var rh = Xo;
var ah = Object;
var Wo = rh ? function(a3) {
  return typeof a3 == "symbol";
} : function(a3) {
  var e = Jl("Symbol");
  return eh(e) && th(e.prototype, ah(a3));
};
var ih = String;
var Or = function(a3) {
  try {
    return ih(a3);
  } catch {
    return "Object";
  }
};
var nh = B;
var sh = Or;
var oh = TypeError;
var Te = function(a3) {
  if (nh(a3)) return a3;
  throw new oh(sh(a3) + " is not a function");
};
var uh = Te;
var lh = xr;
var st = function(a3, e) {
  var t = a3[e];
  return lh(t) ? void 0 : uh(t);
};
var ra = Y;
var aa = B;
var ia = ae;
var hh = TypeError;
var vh = function(a3, e) {
  var t, r;
  if (e === "string" && aa(t = a3.toString) && !ia(r = ra(t, a3)) || aa(t = a3.valueOf) && !ia(r = ra(t, a3)) || e !== "string" && aa(t = a3.toString) && !ia(r = ra(t, a3))) return r;
  throw new hh("Can't convert object to primitive value");
};
var qo = {
  exports: {}
};
var En = _;
var fh = Object.defineProperty;
var Ei = function(a3, e) {
  try {
    fh(En, a3, {
      value: e,
      configurable: true,
      writable: true
    });
  } catch {
    En[a3] = e;
  }
  return e;
};
var ch = _;
var gh = Ei;
var $n = "__core-js_shared__";
var wn = qo.exports = ch[$n] || gh($n, {});
(wn.versions || (wn.versions = [])).push({
  version: "3.45.1",
  mode: "global",
  copyright: "© 2014-2025 Denis Pushkarev (zloirock.ru)",
  license: "https://github.com/zloirock/core-js/blob/v3.45.1/LICENSE",
  source: "https://github.com/zloirock/core-js"
});
var $i = qo.exports;
var Cn = $i;
var wi = function(a3, e) {
  return Cn[a3] || (Cn[a3] = e || {});
};
var dh = ve;
var ph = Object;
var Sr = function(a3) {
  return ph(dh(a3));
};
var yh = L;
var mh = Sr;
var bh = yh({}.hasOwnProperty);
var fe = Object.hasOwn || function(e, t) {
  return bh(mh(e), t);
};
var xh = L;
var Th = 0;
var Oh = Math.random();
var Sh = xh(1.1.toString);
var Qo = function(a3) {
  return "Symbol(" + (a3 === void 0 ? "" : a3) + ")_" + Sh(++Th + Oh, 36);
};
var Eh = _;
var $h = wi;
var An = fe;
var wh = Qo;
var Ch = Yo;
var Ah = Xo;
var Ke = Eh.Symbol;
var na = $h("wks");
var Ph = Ah ? Ke.for || Ke : Ke && Ke.withoutSetter || wh;
var z = function(a3) {
  return An(na, a3) || (na[a3] = Ch && An(Ke, a3) ? Ke[a3] : Ph("Symbol." + a3)), na[a3];
};
var Rh = Y;
var Pn = ae;
var Rn = Wo;
var Nh = st;
var Ih = vh;
var Mh = z;
var _h = TypeError;
var Vh = Mh("toPrimitive");
var Dh = function(a3, e) {
  if (!Pn(a3) || Rn(a3)) return a3;
  var t = Nh(a3, Vh), r;
  if (t) {
    if (e === void 0 && (e = "default"), r = Rh(t, a3, e), !Pn(r) || Rn(r)) return r;
    throw new _h("Can't convert object to primitive value");
  }
  return e === void 0 && (e = "number"), Ih(a3, e);
};
var Lh = Dh;
var kh = Wo;
var Ko = function(a3) {
  var e = Lh(a3, "string");
  return kh(e) ? e : e + "";
};
var Bh = _;
var Nn = ae;
var Xa = Bh.document;
var jh = Nn(Xa) && Nn(Xa.createElement);
var Er = function(a3) {
  return jh ? Xa.createElement(a3) : {};
};
var Fh = he;
var Uh = D;
var Gh = Er;
var Zo = !Fh && !Uh(function() {
  return Object.defineProperty(Gh("div"), "a", {
    get: function() {
      return 7;
    }
  }).a !== 7;
});
var zh = he;
var Hh = Y;
var Yh = ko;
var Xh = Oi;
var Wh = $t;
var qh = Ko;
var Qh = fe;
var Kh = Zo;
var In = Object.getOwnPropertyDescriptor;
Et.f = zh ? In : function(e, t) {
  if (e = Wh(e), t = qh(t), Kh) try {
    return In(e, t);
  } catch {
  }
  if (Qh(e, t)) return Xh(!Hh(Yh.f, e, t), e[t]);
};
var Oe = {};
var Zh = he;
var Jh = D;
var Jo = Zh && Jh(function() {
  return Object.defineProperty(function() {
  }, "prototype", {
    value: 42,
    writable: false
  }).prototype !== 42;
});
var ev = ae;
var tv = String;
var rv = TypeError;
var J = function(a3) {
  if (ev(a3)) return a3;
  throw new rv(tv(a3) + " is not an object");
};
var av = he;
var iv = Zo;
var nv = Jo;
var Ut = J;
var Mn = Ko;
var sv = TypeError;
var sa = Object.defineProperty;
var ov = Object.getOwnPropertyDescriptor;
var oa = "enumerable";
var ua = "configurable";
var la = "writable";
Oe.f = av ? nv ? function(e, t, r) {
  if (Ut(e), t = Mn(t), Ut(r), typeof e == "function" && t === "prototype" && "value" in r && la in r && !r[la]) {
    var i = ov(e, t);
    i && i[la] && (e[t] = r.value, r = {
      configurable: ua in r ? r[ua] : i[ua],
      enumerable: oa in r ? r[oa] : i[oa],
      writable: false
    });
  }
  return sa(e, t, r);
} : sa : function(e, t, r) {
  if (Ut(e), t = Mn(t), Ut(r), iv) try {
    return sa(e, t, r);
  } catch {
  }
  if ("get" in r || "set" in r) throw new sv("Accessors not supported");
  return "value" in r && (e[t] = r.value), e;
};
var uv = he;
var lv = Oe;
var hv = Oi;
var Ct = uv ? function(a3, e, t) {
  return lv.f(a3, e, hv(1, t));
} : function(a3, e, t) {
  return a3[e] = t, a3;
};
var eu = {
  exports: {}
};
var Wa = he;
var vv = fe;
var tu = Function.prototype;
var fv = Wa && Object.getOwnPropertyDescriptor;
var Ci = vv(tu, "name");
var cv = Ci && function() {
}.name === "something";
var gv = Ci && (!Wa || Wa && fv(tu, "name").configurable);
var $r = {
  EXISTS: Ci,
  PROPER: cv,
  CONFIGURABLE: gv
};
var dv = L;
var pv = B;
var qa = $i;
var yv = dv(Function.toString);
pv(qa.inspectSource) || (qa.inspectSource = function(a3) {
  return yv(a3);
});
var Ai = qa.inspectSource;
var mv = _;
var bv = B;
var _n = mv.WeakMap;
var xv = bv(_n) && /native code/.test(String(_n));
var Tv = wi;
var Ov = Qo;
var Vn = Tv("keys");
var Pi = function(a3) {
  return Vn[a3] || (Vn[a3] = Ov(a3));
};
var Ri = {};
var Sv = xv;
var ru = _;
var Ev = ae;
var $v = Ct;
var ha = fe;
var va = $i;
var wv = Pi;
var Cv = Ri;
var Dn = "Object already initialized";
var Qa = ru.TypeError;
var Av = ru.WeakMap;
var gr;
var Tt;
var dr;
var Pv = function(a3) {
  return dr(a3) ? Tt(a3) : gr(a3, {});
};
var Rv = function(a3) {
  return function(e) {
    var t;
    if (!Ev(e) || (t = Tt(e)).type !== a3) throw new Qa("Incompatible receiver, " + a3 + " required");
    return t;
  };
};
if (Sv || va.state) {
  de = va.state || (va.state = new Av());
  de.get = de.get, de.has = de.has, de.set = de.set, gr = function(a3, e) {
    if (de.has(a3)) throw new Qa(Dn);
    return e.facade = a3, de.set(a3, e), e;
  }, Tt = function(a3) {
    return de.get(a3) || {};
  }, dr = function(a3) {
    return de.has(a3);
  };
} else {
  Ye = wv("state");
  Cv[Ye] = true, gr = function(a3, e) {
    if (ha(a3, Ye)) throw new Qa(Dn);
    return e.facade = a3, $v(a3, Ye, e), e;
  }, Tt = function(a3) {
    return ha(a3, Ye) ? a3[Ye] : {};
  }, dr = function(a3) {
    return ha(a3, Ye);
  };
}
var de;
var Ye;
var wr = {
  set: gr,
  get: Tt,
  has: dr,
  enforce: Pv,
  getterFor: Rv
};
var Ni = L;
var Nv = D;
var Iv = B;
var Gt = fe;
var Ka = he;
var Mv = $r.CONFIGURABLE;
var _v = Ai;
var au = wr;
var Vv = au.enforce;
var Dv = au.get;
var Ln = String;
var or = Object.defineProperty;
var Lv = Ni("".slice);
var kv = Ni("".replace);
var Bv = Ni([].join);
var jv = Ka && !Nv(function() {
  return or(function() {
  }, "length", {
    value: 8
  }).length !== 8;
});
var Fv = String(String).split("String");
var Uv = eu.exports = function(a3, e, t) {
  Lv(Ln(e), 0, 7) === "Symbol(" && (e = "[" + kv(Ln(e), /^Symbol\(([^)]*)\).*$/, "$1") + "]"), t && t.getter && (e = "get " + e), t && t.setter && (e = "set " + e), (!Gt(a3, "name") || Mv && a3.name !== e) && (Ka ? or(a3, "name", {
    value: e,
    configurable: true
  }) : a3.name = e), jv && t && Gt(t, "arity") && a3.length !== t.arity && or(a3, "length", {
    value: t.arity
  });
  try {
    t && Gt(t, "constructor") && t.constructor ? Ka && or(a3, "prototype", {
      writable: false
    }) : a3.prototype && (a3.prototype = void 0);
  } catch {
  }
  var r = Vv(a3);
  return Gt(r, "source") || (r.source = Bv(Fv, typeof e == "string" ? e : "")), a3;
};
Function.prototype.toString = Uv(function() {
  return Iv(this) && Dv(this).source || _v(this);
}, "toString");
var iu = eu.exports;
var Gv = B;
var zv = Oe;
var Hv = iu;
var Yv = Ei;
var Ue = function(a3, e, t, r) {
  r || (r = {});
  var i = r.enumerable, n = r.name !== void 0 ? r.name : e;
  if (Gv(t) && Hv(t, n, r), r.global) i ? a3[e] = t : Yv(e, t);
  else {
    try {
      r.unsafe ? a3[e] && (i = true) : delete a3[e];
    } catch {
    }
    i ? a3[e] = t : zv.f(a3, e, {
      value: t,
      enumerable: false,
      configurable: !r.nonConfigurable,
      writable: !r.nonWritable
    });
  }
  return a3;
};
var nu = {};
var Xv = Math.ceil;
var Wv = Math.floor;
var qv = Math.trunc || function(e) {
  var t = +e;
  return (t > 0 ? Wv : Xv)(t);
};
var Qv = qv;
var Cr = function(a3) {
  var e = +a3;
  return e !== e || e === 0 ? 0 : Qv(e);
};
var Kv = Cr;
var Zv = Math.max;
var Jv = Math.min;
var ef = function(a3, e) {
  var t = Kv(a3);
  return t < 0 ? Zv(t + e, 0) : Jv(t, e);
};
var tf = Cr;
var rf = Math.min;
var ot = function(a3) {
  var e = tf(a3);
  return e > 0 ? rf(e, 9007199254740991) : 0;
};
var af = ot;
var Ii = function(a3) {
  return af(a3.length);
};
var nf = $t;
var sf = ef;
var of = Ii;
var kn = function(a3) {
  return function(e, t, r) {
    var i = nf(e), n = of(i);
    if (n === 0) return !a3 && -1;
    var o = sf(r, n), s;
    if (a3 && t !== t) {
      for (; n > o; ) if (s = i[o++], s !== s) return true;
    } else for (; n > o; o++) if ((a3 || o in i) && i[o] === t) return a3 || o || 0;
    return !a3 && -1;
  };
};
var su = {
  // `Array.prototype.includes` method
  // https://tc39.es/ecma262/#sec-array.prototype.includes
  includes: kn(true),
  // `Array.prototype.indexOf` method
  // https://tc39.es/ecma262/#sec-array.prototype.indexof
  indexOf: kn(false)
};
var uf = L;
var fa = fe;
var lf = $t;
var hf = su.indexOf;
var vf = Ri;
var Bn = uf([].push);
var ou = function(a3, e) {
  var t = lf(a3), r = 0, i = [], n;
  for (n in t) !fa(vf, n) && fa(t, n) && Bn(i, n);
  for (; e.length > r; ) fa(t, n = e[r++]) && (~hf(i, n) || Bn(i, n));
  return i;
};
var Mi = ["constructor", "hasOwnProperty", "isPrototypeOf", "propertyIsEnumerable", "toLocaleString", "toString", "valueOf"];
var ff = ou;
var cf = Mi;
var gf = cf.concat("length", "prototype");
nu.f = Object.getOwnPropertyNames || function(e) {
  return ff(e, gf);
};
var uu = {};
uu.f = Object.getOwnPropertySymbols;
var df = Fe;
var pf = L;
var yf = nu;
var mf = uu;
var bf = J;
var xf = pf([].concat);
var Tf = df("Reflect", "ownKeys") || function(e) {
  var t = yf.f(bf(e)), r = mf.f;
  return r ? xf(t, r(e)) : t;
};
var jn = fe;
var Of = Tf;
var Sf = Et;
var Ef = Oe;
var $f = function(a3, e, t) {
  for (var r = Of(e), i = Ef.f, n = Sf.f, o = 0; o < r.length; o++) {
    var s = r[o];
    !jn(a3, s) && !(t && jn(t, s)) && i(a3, s, n(e, s));
  }
};
var wf = D;
var Cf = B;
var Af = /#|\.prototype\./;
var At = function(a3, e) {
  var t = Rf[Pf(a3)];
  return t === If ? true : t === Nf ? false : Cf(e) ? wf(e) : !!e;
};
var Pf = At.normalize = function(a3) {
  return String(a3).replace(Af, ".").toLowerCase();
};
var Rf = At.data = {};
var Nf = At.NATIVE = "N";
var If = At.POLYFILL = "P";
var lu = At;
var zt = _;
var Mf = Et.f;
var _f = Ct;
var Vf = Ue;
var Df = Ei;
var Lf = $f;
var kf = lu;
var ee = function(a3, e) {
  var t = a3.target, r = a3.global, i = a3.stat, n, o, s, u, l, h;
  if (r ? o = zt : i ? o = zt[t] || Df(t, {}) : o = zt[t] && zt[t].prototype, o) for (s in e) {
    if (l = e[s], a3.dontCallGetSet ? (h = Mf(o, s), u = h && h.value) : u = o[s], n = kf(r ? s : t + (i ? "." : "#") + s, a3.forced), !n && u !== void 0) {
      if (typeof l == typeof u) continue;
      Lf(l, u);
    }
    (a3.sham || u && u.sham) && _f(l, "sham", true), Vf(o, s, l, a3);
  }
};
var vt = _;
var Bf = wt;
var jf = je;
var Ht = function(a3) {
  return Bf.slice(0, a3.length) === a3;
};
var hu = function() {
  return Ht("Bun/") ? "BUN" : Ht("Cloudflare-Workers") ? "CLOUDFLARE" : Ht("Deno/") ? "DENO" : Ht("Node.js/") ? "NODE" : vt.Bun && typeof Bun.version == "string" ? "BUN" : vt.Deno && typeof Deno.version == "object" ? "DENO" : jf(vt.process) === "process" ? "NODE" : vt.window && vt.document ? "BROWSER" : "REST";
}();
var Ff = hu;
var Ar = Ff === "NODE";
var Uf = _;
var Gf = Uf;
var zf = L;
var Hf = Te;
var Yf = function(a3, e, t) {
  try {
    return zf(Hf(Object.getOwnPropertyDescriptor(a3, e)[t]));
  } catch {
  }
};
var Xf = ae;
var Wf = function(a3) {
  return Xf(a3) || a3 === null;
};
var qf = Wf;
var Qf = String;
var Kf = TypeError;
var Zf = function(a3) {
  if (qf(a3)) return a3;
  throw new Kf("Can't set " + Qf(a3) + " as a prototype");
};
var Jf = Yf;
var ec = ae;
var tc = ve;
var rc = Zf;
var vu = Object.setPrototypeOf || ("__proto__" in {} ? function() {
  var a3 = false, e = {}, t;
  try {
    t = Jf(Object.prototype, "__proto__", "set"), t(e, []), a3 = e instanceof Array;
  } catch {
  }
  return function(i, n) {
    return tc(i), rc(n), ec(i) && (a3 ? t(i, n) : i.__proto__ = n), i;
  };
}() : void 0);
var ac = Oe.f;
var ic = fe;
var nc = z;
var Fn = nc("toStringTag");
var Pr = function(a3, e, t) {
  a3 && !t && (a3 = a3.prototype), a3 && !ic(a3, Fn) && ac(a3, Fn, {
    configurable: true,
    value: e
  });
};
var Un = iu;
var sc = Oe;
var oc = function(a3, e, t) {
  return t.get && Un(t.get, e, {
    getter: true
  }), t.set && Un(t.set, e, {
    setter: true
  }), sc.f(a3, e, t);
};
var uc = Fe;
var lc = oc;
var hc = z;
var vc = he;
var Gn = hc("species");
var fc = function(a3) {
  var e = uc(a3);
  vc && e && !e[Gn] && lc(e, Gn, {
    configurable: true,
    get: function() {
      return this;
    }
  });
};
var cc = Tr;
var gc = TypeError;
var dc = function(a3, e) {
  if (cc(e, a3)) return a3;
  throw new gc("Incorrect invocation");
};
var pc = z;
var yc = pc("toStringTag");
var fu = {};
fu[yc] = "z";
var mc = String(fu) === "[object z]";
var bc = mc;
var xc = B;
var ur = je;
var Tc = z;
var Oc = Tc("toStringTag");
var Sc = Object;
var Ec = ur(/* @__PURE__ */ function() {
  return arguments;
}()) === "Arguments";
var $c = function(a3, e) {
  try {
    return a3[e];
  } catch {
  }
};
var _i = bc ? ur : function(a3) {
  var e, t, r;
  return a3 === void 0 ? "Undefined" : a3 === null ? "Null" : typeof (t = $c(e = Sc(a3), Oc)) == "string" ? t : Ec ? ur(e) : (r = ur(e)) === "Object" && xc(e.callee) ? "Arguments" : r;
};
var wc = L;
var Cc = D;
var cu = B;
var Ac = _i;
var Pc = Fe;
var Rc = Ai;
var gu = function() {
};
var du = Pc("Reflect", "construct");
var Vi = /^\s*(?:class|function)\b/;
var Nc = wc(Vi.exec);
var Ic = !Vi.test(gu);
var ft = function(e) {
  if (!cu(e)) return false;
  try {
    return du(gu, [], e), true;
  } catch {
    return false;
  }
};
var pu = function(e) {
  if (!cu(e)) return false;
  switch (Ac(e)) {
    case "AsyncFunction":
    case "GeneratorFunction":
    case "AsyncGeneratorFunction":
      return false;
  }
  try {
    return Ic || !!Nc(Vi, Rc(e));
  } catch {
    return true;
  }
};
pu.sham = true;
var Mc = !du || Cc(function() {
  var a3;
  return ft(ft.call) || !ft(Object) || !ft(function() {
    a3 = true;
  }) || a3;
}) ? pu : ft;
var _c = Mc;
var Vc = Or;
var Dc = TypeError;
var Lc = function(a3) {
  if (_c(a3)) return a3;
  throw new Dc(Vc(a3) + " is not a constructor");
};
var zn = J;
var kc = Lc;
var Bc = xr;
var jc = z;
var Fc = jc("species");
var yu = function(a3, e) {
  var t = zn(a3).constructor, r;
  return t === void 0 || Bc(r = zn(t)[Fc]) ? e : kc(r);
};
var Uc = br;
var mu = Function.prototype;
var Hn = mu.apply;
var Yn = mu.call;
var bu = typeof Reflect == "object" && Reflect.apply || (Uc ? Yn.bind(Hn) : function() {
  return Yn.apply(Hn, arguments);
});
var Gc = je;
var zc = L;
var Rr = function(a3) {
  if (Gc(a3) === "Function") return zc(a3);
};
var Xn = Rr;
var Hc = Te;
var Yc = br;
var Xc = Xn(Xn.bind);
var Di = function(a3, e) {
  return Hc(a3), e === void 0 ? a3 : Yc ? Xc(a3, e) : function() {
    return a3.apply(e, arguments);
  };
};
var Wc = Fe;
var xu = Wc("document", "documentElement");
var qc = L;
var Qc = qc([].slice);
var Kc = TypeError;
var Zc = function(a3, e) {
  if (a3 < e) throw new Kc("Not enough arguments");
  return a3;
};
var Jc = wt;
var Tu = /(?:ipad|iphone|ipod).*applewebkit/i.test(Jc);
var ie = _;
var eg = bu;
var tg = Di;
var Wn = B;
var rg = fe;
var Ou = D;
var qn = xu;
var ag = Qc;
var Qn = Er;
var ig = Zc;
var ng = Tu;
var sg = Ar;
var Za = ie.setImmediate;
var Ja = ie.clearImmediate;
var og = ie.process;
var ca = ie.Dispatch;
var ug = ie.Function;
var Kn = ie.MessageChannel;
var lg = ie.String;
var ga = 0;
var bt = {};
var Zn = "onreadystatechange";
var Ot;
var Ie;
var da;
var pa;
Ou(function() {
  Ot = ie.location;
});
var Li = function(a3) {
  if (rg(bt, a3)) {
    var e = bt[a3];
    delete bt[a3], e();
  }
};
var ya = function(a3) {
  return function() {
    Li(a3);
  };
};
var Jn = function(a3) {
  Li(a3.data);
};
var es = function(a3) {
  ie.postMessage(lg(a3), Ot.protocol + "//" + Ot.host);
};
(!Za || !Ja) && (Za = function(e) {
  ig(arguments.length, 1);
  var t = Wn(e) ? e : ug(e), r = ag(arguments, 1);
  return bt[++ga] = function() {
    eg(t, void 0, r);
  }, Ie(ga), ga;
}, Ja = function(e) {
  delete bt[e];
}, sg ? Ie = function(a3) {
  og.nextTick(ya(a3));
} : ca && ca.now ? Ie = function(a3) {
  ca.now(ya(a3));
} : Kn && !ng ? (da = new Kn(), pa = da.port2, da.port1.onmessage = Jn, Ie = tg(pa.postMessage, pa)) : ie.addEventListener && Wn(ie.postMessage) && !ie.importScripts && Ot && Ot.protocol !== "file:" && !Ou(es) ? (Ie = es, ie.addEventListener("message", Jn, false)) : Zn in Qn("script") ? Ie = function(a3) {
  qn.appendChild(Qn("script"))[Zn] = function() {
    qn.removeChild(this), Li(a3);
  };
} : Ie = function(a3) {
  setTimeout(ya(a3), 0);
});
var Su = {
  set: Za,
  clear: Ja
};
var ts = _;
var hg = he;
var vg = Object.getOwnPropertyDescriptor;
var fg = function(a3) {
  if (!hg) return ts[a3];
  var e = vg(ts, a3);
  return e && e.value;
};
var Eu = function() {
  this.head = null, this.tail = null;
};
Eu.prototype = {
  add: function(a3) {
    var e = {
      item: a3,
      next: null
    }, t = this.tail;
    t ? t.next = e : this.head = e, this.tail = e;
  },
  get: function() {
    var a3 = this.head;
    if (a3) {
      var e = this.head = a3.next;
      return e === null && (this.tail = null), a3.item;
    }
  }
};
var $u = Eu;
var cg = wt;
var gg = /ipad|iphone|ipod/i.test(cg) && typeof Pebble < "u";
var dg = wt;
var pg = /web0s(?!.*chrome)/i.test(dg);
var at = _;
var yg = fg;
var rs = Di;
var ma = Su.set;
var mg = $u;
var bg = Tu;
var xg = gg;
var Tg = pg;
var ba = Ar;
var as = at.MutationObserver || at.WebKitMutationObserver;
var is = at.document;
var ns = at.process;
var Yt = at.Promise;
var ei = yg("queueMicrotask");
var Xe;
var xa;
var Ta;
var Xt;
var ss;
if (!ei) {
  Wt2 = new mg(), qt = function() {
    var a3, e;
    for (ba && (a3 = ns.domain) && a3.exit(); e = Wt2.get(); ) try {
      e();
    } catch (t) {
      throw Wt2.head && Xe(), t;
    }
    a3 && a3.enter();
  };
  !bg && !ba && !Tg && as && is ? (xa = true, Ta = is.createTextNode(""), new as(qt).observe(Ta, {
    characterData: true
  }), Xe = function() {
    Ta.data = xa = !xa;
  }) : !xg && Yt && Yt.resolve ? (Xt = Yt.resolve(void 0), Xt.constructor = Yt, ss = rs(Xt.then, Xt), Xe = function() {
    ss(qt);
  }) : ba ? Xe = function() {
    ns.nextTick(qt);
  } : (ma = rs(ma, at), Xe = function() {
    ma(qt);
  }), ei = function(a3) {
    Wt2.head || Xe(), Wt2.add(a3);
  };
}
var Wt2;
var qt;
var Og = ei;
var Sg = function(a3, e) {
  try {
    arguments.length === 1 ? console.error(a3) : console.error(a3, e);
  } catch {
  }
};
var ki = function(a3) {
  try {
    return {
      error: false,
      value: a3()
    };
  } catch (e) {
    return {
      error: true,
      value: e
    };
  }
};
var Eg = _;
var Nr = Eg.Promise;
var $g = _;
var xt = Nr;
var wg = B;
var Cg = lu;
var Ag = Ai;
var Pg = z;
var os = hu;
var Oa = Si;
xt && xt.prototype;
var Rg = Pg("species");
var ti = false;
var wu = wg($g.PromiseRejectionEvent);
var Ng = Cg("Promise", function() {
  var a3 = Ag(xt), e = a3 !== String(xt);
  if (!e && Oa === 66) return true;
  if (!Oa || Oa < 51 || !/native code/.test(a3)) {
    var t = new xt(function(n) {
      n(1);
    }), r = function(n) {
      n(function() {
      }, function() {
      });
    }, i = t.constructor = {};
    if (i[Rg] = r, ti = t.then(function() {
    }) instanceof r, !ti) return true;
  }
  return !e && (os === "BROWSER" || os === "DENO") && !wu;
});
var Pt = {
  CONSTRUCTOR: Ng,
  REJECTION_EVENT: wu,
  SUBCLASSING: ti
};
var ut = {};
var us = Te;
var Ig = TypeError;
var Mg = function(a3) {
  var e, t;
  this.promise = new a3(function(r, i) {
    if (e !== void 0 || t !== void 0) throw new Ig("Bad Promise constructor");
    e = r, t = i;
  }), this.resolve = us(e), this.reject = us(t);
};
ut.f = function(a3) {
  return new Mg(a3);
};
var _g = ee;
var pr = Ar;
var we = _;
var Vg = Gf;
var it = Y;
var ls = Ue;
var hs = vu;
var Dg = Pr;
var Lg = fc;
var kg = Te;
var lr = B;
var Bg = ae;
var jg = dc;
var Fg = yu;
var Cu = Su.set;
var Bi = Og;
var Ug = Sg;
var Gg = ki;
var zg = $u;
var Au = wr;
var yr = Nr;
var ji = Pt;
var Pu = ut;
var Ir = "Promise";
var Ru = ji.CONSTRUCTOR;
var Hg = ji.REJECTION_EVENT;
var Yg = ji.SUBCLASSING;
var Sa = Au.getterFor(Ir);
var Xg = Au.set;
var qe = yr && yr.prototype;
var Le = yr;
var Qt = qe;
var Nu = we.TypeError;
var ri = we.document;
var Fi = we.process;
var ai = Pu.f;
var Wg = ai;
var qg = !!(ri && ri.createEvent && we.dispatchEvent);
var Iu = "unhandledrejection";
var Qg = "rejectionhandled";
var vs = 0;
var Mu = 1;
var Kg = 2;
var Ui = 1;
var _u = 2;
var Kt;
var fs;
var Vu;
var cs;
var Du = function(a3) {
  var e;
  return Bg(a3) && lr(e = a3.then) ? e : false;
};
var Lu = function(a3, e) {
  var t = e.value, r = e.state === Mu, i = r ? a3.ok : a3.fail, n = a3.resolve, o = a3.reject, s = a3.domain, u, l, h;
  try {
    i ? (r || (e.rejection === _u && Jg(e), e.rejection = Ui), i === true ? u = t : (s && s.enter(), u = i(t), s && (s.exit(), h = true)), u === a3.promise ? o(new Nu("Promise-chain cycle")) : (l = Du(u)) ? it(l, u, n, o) : n(u)) : o(t);
  } catch (f) {
    s && !h && s.exit(), o(f);
  }
};
var ku = function(a3, e) {
  a3.notified || (a3.notified = true, Bi(function() {
    for (var t = a3.reactions, r; r = t.get(); ) Lu(r, a3);
    a3.notified = false, e && !a3.rejection && Zg(a3);
  }));
};
var Bu = function(a3, e, t) {
  var r, i;
  qg ? (r = ri.createEvent("Event"), r.promise = e, r.reason = t, r.initEvent(a3, false, true), we.dispatchEvent(r)) : r = {
    promise: e,
    reason: t
  }, !Hg && (i = we["on" + a3]) ? i(r) : a3 === Iu && Ug("Unhandled promise rejection", t);
};
var Zg = function(a3) {
  it(Cu, we, function() {
    var e = a3.facade, t = a3.value, r = gs(a3), i;
    if (r && (i = Gg(function() {
      pr ? Fi.emit("unhandledRejection", t, e) : Bu(Iu, e, t);
    }), a3.rejection = pr || gs(a3) ? _u : Ui, i.error)) throw i.value;
  });
};
var gs = function(a3) {
  return a3.rejection !== Ui && !a3.parent;
};
var Jg = function(a3) {
  it(Cu, we, function() {
    var e = a3.facade;
    pr ? Fi.emit("rejectionHandled", e) : Bu(Qg, e, a3.value);
  });
};
var Ze = function(a3, e, t) {
  return function(r) {
    a3(e, r, t);
  };
};
var et = function(a3, e, t) {
  a3.done || (a3.done = true, t && (a3 = t), a3.value = e, a3.state = Kg, ku(a3, true));
};
var ii = function(a3, e, t) {
  if (!a3.done) {
    a3.done = true, t && (a3 = t);
    try {
      if (a3.facade === e) throw new Nu("Promise can't be resolved itself");
      var r = Du(e);
      r ? Bi(function() {
        var i = {
          done: false
        };
        try {
          it(r, e, Ze(ii, i, a3), Ze(et, i, a3));
        } catch (n) {
          et(i, n, a3);
        }
      }) : (a3.value = e, a3.state = Mu, ku(a3, false));
    } catch (i) {
      et({
        done: false
      }, i, a3);
    }
  }
};
if (Ru && (Le = function(e) {
  jg(this, Qt), kg(e), it(Kt, this);
  var t = Sa(this);
  try {
    e(Ze(ii, t), Ze(et, t));
  } catch (r) {
    et(t, r);
  }
}, Qt = Le.prototype, Kt = function(e) {
  Xg(this, {
    type: Ir,
    done: false,
    notified: false,
    parent: false,
    reactions: new zg(),
    rejection: false,
    state: vs,
    value: null
  });
}, Kt.prototype = ls(Qt, "then", function(e, t) {
  var r = Sa(this), i = ai(Fg(this, Le));
  return r.parent = true, i.ok = lr(e) ? e : true, i.fail = lr(t) && t, i.domain = pr ? Fi.domain : void 0, r.state === vs ? r.reactions.add(i) : Bi(function() {
    Lu(i, r);
  }), i.promise;
}), fs = function() {
  var a3 = new Kt(), e = Sa(a3);
  this.promise = a3, this.resolve = Ze(ii, e), this.reject = Ze(et, e);
}, Pu.f = ai = function(a3) {
  return a3 === Le || a3 === Vu ? new fs(a3) : Wg(a3);
}, lr(yr) && qe !== Object.prototype)) {
  cs = qe.then, Yg || ls(qe, "then", function(e, t) {
    var r = this;
    return new Le(function(i, n) {
      it(cs, r, i, n);
    }).then(e, t);
  }, {
    unsafe: true
  });
  try {
    delete qe.constructor;
  } catch {
  }
  hs && hs(qe, Qt);
}
_g({
  global: true,
  constructor: true,
  wrap: true,
  forced: Ru
}, {
  Promise: Le
});
Vu = Vg.Promise;
Dg(Le, Ir, false);
Lg(Ir);
var Rt = {};
var ed = z;
var td = Rt;
var rd = ed("iterator");
var ad = Array.prototype;
var id = function(a3) {
  return a3 !== void 0 && (td.Array === a3 || ad[rd] === a3);
};
var nd = _i;
var ds = st;
var sd = xr;
var od = Rt;
var ud = z;
var ld = ud("iterator");
var ju = function(a3) {
  if (!sd(a3)) return ds(a3, ld) || ds(a3, "@@iterator") || od[nd(a3)];
};
var hd = Y;
var vd = Te;
var fd = J;
var cd = Or;
var gd = ju;
var dd = TypeError;
var pd = function(a3, e) {
  var t = arguments.length < 2 ? gd(a3) : e;
  if (vd(t)) return fd(hd(t, a3));
  throw new dd(cd(a3) + " is not iterable");
};
var yd = Y;
var ps = J;
var md = st;
var bd = function(a3, e, t) {
  var r, i;
  ps(a3);
  try {
    if (r = md(a3, "return"), !r) {
      if (e === "throw") throw t;
      return t;
    }
    r = yd(r, a3);
  } catch (n) {
    i = true, r = n;
  }
  if (e === "throw") throw t;
  if (i) throw r;
  return ps(r), t;
};
var xd = Di;
var Td = Y;
var Od = J;
var Sd = Or;
var Ed = id;
var $d = Ii;
var ys = Tr;
var wd = pd;
var Cd = ju;
var ms = bd;
var Ad = TypeError;
var hr = function(a3, e) {
  this.stopped = a3, this.result = e;
};
var bs = hr.prototype;
var Fu = function(a3, e, t) {
  var r = t && t.that, i = !!(t && t.AS_ENTRIES), n = !!(t && t.IS_RECORD), o = !!(t && t.IS_ITERATOR), s = !!(t && t.INTERRUPTED), u = xd(e, r), l, h, f, c, v, g, d, p = function(x) {
    return l && ms(l, "normal"), new hr(true, x);
  }, y = function(x) {
    return i ? (Od(x), s ? u(x[0], x[1], p) : u(x[0], x[1])) : s ? u(x, p) : u(x);
  };
  if (n) l = a3.iterator;
  else if (o) l = a3;
  else {
    if (h = Cd(a3), !h) throw new Ad(Sd(a3) + " is not iterable");
    if (Ed(h)) {
      for (f = 0, c = $d(a3); c > f; f++) if (v = y(a3[f]), v && ys(bs, v)) return v;
      return new hr(false);
    }
    l = wd(a3, h);
  }
  for (g = n ? a3.next : l.next; !(d = Td(g, l)).done; ) {
    try {
      v = y(d.value);
    } catch (x) {
      ms(l, "throw", x);
    }
    if (typeof v == "object" && v && ys(bs, v)) return v;
  }
  return new hr(false);
};
var Pd = z;
var Uu = Pd("iterator");
var Gu = false;
try {
  Rd = 0, xs = {
    next: function() {
      return {
        done: !!Rd++
      };
    },
    return: function() {
      Gu = true;
    }
  };
  xs[Uu] = function() {
    return this;
  }, Array.from(xs, function() {
    throw 2;
  });
} catch {
}
var Rd;
var xs;
var Nd = function(a3, e) {
  try {
    if (!e && !Gu) return false;
  } catch {
    return false;
  }
  var t = false;
  try {
    var r = {};
    r[Uu] = function() {
      return {
        next: function() {
          return {
            done: t = true
          };
        }
      };
    }, a3(r);
  } catch {
  }
  return t;
};
var Id = Nr;
var Md = Nd;
var _d = Pt.CONSTRUCTOR;
var zu = _d || !Md(function(a3) {
  Id.all(a3).then(void 0, function() {
  });
});
var Vd = ee;
var Dd = Y;
var Ld = Te;
var kd = ut;
var Bd = ki;
var jd = Fu;
var Fd = zu;
Vd({
  target: "Promise",
  stat: true,
  forced: Fd
}, {
  all: function(e) {
    var t = this, r = kd.f(t), i = r.resolve, n = r.reject, o = Bd(function() {
      var s = Ld(t.resolve), u = [], l = 0, h = 1;
      jd(e, function(f) {
        var c = l++, v = false;
        h++, Dd(s, t, f).then(function(g) {
          v || (v = true, u[c] = g, --h || i(u));
        }, n);
      }), --h || i(u);
    });
    return o.error && n(o.value), r.promise;
  }
});
var Ud = ee;
var Gd = Pt.CONSTRUCTOR;
var ni = Nr;
var zd = Fe;
var Hd = B;
var Yd = Ue;
var Ts = ni && ni.prototype;
Ud({
  target: "Promise",
  proto: true,
  forced: Gd,
  real: true
}, {
  catch: function(a3) {
    return this.then(void 0, a3);
  }
});
if (Hd(ni)) {
  Os = zd("Promise").prototype.catch;
  Ts.catch !== Os && Yd(Ts, "catch", Os, {
    unsafe: true
  });
}
var Os;
var Xd = ee;
var Wd = Y;
var qd = Te;
var Qd = ut;
var Kd = ki;
var Zd = Fu;
var Jd = zu;
Xd({
  target: "Promise",
  stat: true,
  forced: Jd
}, {
  race: function(e) {
    var t = this, r = Qd.f(t), i = r.reject, n = Kd(function() {
      var o = qd(t.resolve);
      Zd(e, function(s) {
        Wd(o, t, s).then(r.resolve, i);
      });
    });
    return n.error && i(n.value), r.promise;
  }
});
var ep = ee;
var tp = ut;
var rp = Pt.CONSTRUCTOR;
ep({
  target: "Promise",
  stat: true,
  forced: rp
}, {
  reject: function(e) {
    var t = tp.f(this), r = t.reject;
    return r(e), t.promise;
  }
});
var ap = J;
var ip = ae;
var np = ut;
var sp = function(a3, e) {
  if (ap(a3), ip(e) && e.constructor === a3) return e;
  var t = np.f(a3), r = t.resolve;
  return r(e), t.promise;
};
var op = ee;
var up = Fe;
var lp = Pt.CONSTRUCTOR;
var hp = sp;
up("Promise");
op({
  target: "Promise",
  stat: true,
  forced: lp
}, {
  resolve: function(e) {
    return hp(this, e);
  }
});
function Ss(a3, e, t, r, i, n, o) {
  try {
    var s = a3[n](o), u = s.value;
  } catch (l) {
    return void t(l);
  }
  s.done ? e(u) : Promise.resolve(u).then(r, i);
}
function xe(a3) {
  return function() {
    var e = this, t = arguments;
    return new Promise(function(r, i) {
      var n = a3.apply(e, t);
      function o(u) {
        Ss(n, r, i, o, s, "next", u);
      }
      function s(u) {
        Ss(n, r, i, o, s, "throw", u);
      }
      o(void 0);
    });
  };
}
var vp = _i;
var fp = String;
var pe = function(a3) {
  if (vp(a3) === "Symbol") throw new TypeError("Cannot convert a Symbol value to a string");
  return fp(a3);
};
var cp = J;
var Hu = function() {
  var a3 = cp(this), e = "";
  return a3.hasIndices && (e += "d"), a3.global && (e += "g"), a3.ignoreCase && (e += "i"), a3.multiline && (e += "m"), a3.dotAll && (e += "s"), a3.unicode && (e += "u"), a3.unicodeSets && (e += "v"), a3.sticky && (e += "y"), e;
};
var Gi = D;
var gp = _;
var zi = gp.RegExp;
var Hi = Gi(function() {
  var a3 = zi("a", "y");
  return a3.lastIndex = 2, a3.exec("abcd") !== null;
});
var dp = Hi || Gi(function() {
  return !zi("a", "y").sticky;
});
var pp = Hi || Gi(function() {
  var a3 = zi("^r", "gy");
  return a3.lastIndex = 2, a3.exec("str") !== null;
});
var Yu = {
  BROKEN_CARET: pp,
  MISSED_STICKY: dp,
  UNSUPPORTED_Y: Hi
};
var Xu = {};
var yp = ou;
var mp = Mi;
var bp = Object.keys || function(e) {
  return yp(e, mp);
};
var xp = he;
var Tp = Jo;
var Op = Oe;
var Sp = J;
var Ep = $t;
var $p = bp;
Xu.f = xp && !Tp ? Object.defineProperties : function(e, t) {
  Sp(e);
  for (var r = Ep(t), i = $p(t), n = i.length, o = 0, s; n > o; ) Op.f(e, s = i[o++], r[s]);
  return e;
};
var wp = J;
var Cp = Xu;
var Es = Mi;
var Ap = Ri;
var Pp = xu;
var Rp = Er;
var Np = Pi;
var $s = ">";
var ws = "<";
var si = "prototype";
var oi = "script";
var Wu = Np("IE_PROTO");
var Ea = function() {
};
var qu = function(a3) {
  return ws + oi + $s + a3 + ws + "/" + oi + $s;
};
var Cs = function(a3) {
  a3.write(qu("")), a3.close();
  var e = a3.parentWindow.Object;
  return a3 = null, e;
};
var Ip = function() {
  var a3 = Rp("iframe"), e = "java" + oi + ":", t;
  return a3.style.display = "none", Pp.appendChild(a3), a3.src = String(e), t = a3.contentWindow.document, t.open(), t.write(qu("document.F=Object")), t.close(), t.F;
};
var Zt;
var vr = function() {
  try {
    Zt = new ActiveXObject("htmlfile");
  } catch {
  }
  vr = typeof document < "u" ? document.domain && Zt ? Cs(Zt) : Ip() : Cs(Zt);
  for (var a3 = Es.length; a3--; ) delete vr[si][Es[a3]];
  return vr();
};
Ap[Wu] = true;
var Yi = Object.create || function(e, t) {
  var r;
  return e !== null ? (Ea[si] = wp(e), r = new Ea(), Ea[si] = null, r[Wu] = e) : r = vr(), t === void 0 ? r : Cp.f(r, t);
};
var Mp = D;
var _p = _;
var Vp = _p.RegExp;
var Dp = Mp(function() {
  var a3 = Vp(".", "s");
  return !(a3.dotAll && a3.test(`
`) && a3.flags === "s");
});
var Lp = D;
var kp = _;
var Bp = kp.RegExp;
var jp = Lp(function() {
  var a3 = Bp("(?<a>b)", "g");
  return a3.exec("b").groups.a !== "b" || "b".replace(a3, "$<a>c") !== "bc";
});
var Je = Y;
var Mr = L;
var Fp = pe;
var Up = Hu;
var Gp = Yu;
var zp = wi;
var Hp = Yi;
var Yp = wr.get;
var Xp = Dp;
var Wp = jp;
var qp = zp("native-string-replace", String.prototype.replace);
var mr = RegExp.prototype.exec;
var ui = mr;
var Qp = Mr("".charAt);
var Kp = Mr("".indexOf);
var Zp = Mr("".replace);
var $a = Mr("".slice);
var li = function() {
  var a3 = /a/, e = /b*/g;
  return Je(mr, a3, "a"), Je(mr, e, "a"), a3.lastIndex !== 0 || e.lastIndex !== 0;
}();
var Qu = Gp.BROKEN_CARET;
var hi = /()??/.exec("")[1] !== void 0;
var Jp = li || hi || Qu || Xp || Wp;
Jp && (ui = function(e) {
  var t = this, r = Yp(t), i = Fp(e), n = r.raw, o, s, u, l, h, f, c;
  if (n) return n.lastIndex = t.lastIndex, o = Je(ui, n, i), t.lastIndex = n.lastIndex, o;
  var v = r.groups, g = Qu && t.sticky, d = Je(Up, t), p = t.source, y = 0, x = i;
  if (g && (d = Zp(d, "y", ""), Kp(d, "g") === -1 && (d += "g"), x = $a(i, t.lastIndex), t.lastIndex > 0 && (!t.multiline || t.multiline && Qp(i, t.lastIndex - 1) !== `
`) && (p = "(?: " + p + ")", x = " " + x, y++), s = new RegExp("^(?:" + p + ")", d)), hi && (s = new RegExp("^" + p + "$(?!\\s)", d)), li && (u = t.lastIndex), l = Je(mr, g ? s : t, x), g ? l ? (l.input = $a(l.input, y), l[0] = $a(l[0], y), l.index = t.lastIndex, t.lastIndex += l[0].length) : t.lastIndex = 0 : li && l && (t.lastIndex = t.global ? l.index + l[0].length : u), hi && l && l.length > 1 && Je(qp, l[0], s, function() {
    for (h = 1; h < arguments.length - 2; h++) arguments[h] === void 0 && (l[h] = void 0);
  }), l && v) for (l.groups = f = Hp(null), h = 0; h < v.length; h++) c = v[h], f[c[0]] = l[c[1]];
  return l;
});
var Xi = ui;
var ey = ee;
var As = Xi;
ey({
  target: "RegExp",
  proto: true,
  forced: /./.exec !== As
}, {
  exec: As
});
var Ps = Y;
var Rs = Ue;
var ty = Xi;
var Ns = D;
var Ku = z;
var ry = Ct;
var ay = Ku("species");
var wa = RegExp.prototype;
var Wi = function(a3, e, t, r) {
  var i = Ku(a3), n = !Ns(function() {
    var l = {};
    return l[i] = function() {
      return 7;
    }, ""[a3](l) !== 7;
  }), o = n && !Ns(function() {
    var l = false, h = /a/;
    return a3 === "split" && (h = {}, h.constructor = {}, h.constructor[ay] = function() {
      return h;
    }, h.flags = "", h[i] = /./[i]), h.exec = function() {
      return l = true, null;
    }, h[i](""), !l;
  });
  if (!n || !o || t) {
    var s = /./[i], u = e(i, ""[a3], function(l, h, f, c, v) {
      var g = h.exec;
      return g === ty || g === wa.exec ? n && !v ? {
        done: true,
        value: Ps(s, h, f, c)
      } : {
        done: true,
        value: Ps(l, f, h, c)
      } : {
        done: false
      };
    });
    Rs(String.prototype, a3, u[0]), Rs(wa, i, u[1]);
  }
  r && ry(wa[i], "sham", true);
};
var qi = L;
var iy = Cr;
var ny = pe;
var sy = ve;
var oy = qi("".charAt);
var Is = qi("".charCodeAt);
var uy = qi("".slice);
var Ms = function(a3) {
  return function(e, t) {
    var r = ny(sy(e)), i = iy(t), n = r.length, o, s;
    return i < 0 || i >= n ? a3 ? "" : void 0 : (o = Is(r, i), o < 55296 || o > 56319 || i + 1 === n || (s = Is(r, i + 1)) < 56320 || s > 57343 ? a3 ? oy(r, i) : o : a3 ? uy(r, i, i + 2) : (o - 55296 << 10) + (s - 56320) + 65536);
  };
};
var ly = {
  // `String.prototype.codePointAt` method
  // https://tc39.es/ecma262/#sec-string.prototype.codepointat
  codeAt: Ms(false),
  // `String.prototype.at` method
  // https://github.com/mathiasbynens/String.prototype.at
  charAt: Ms(true)
};
var hy = ly.charAt;
var Qi = function(a3, e, t) {
  return e + (t ? hy(a3, e).length : 1);
};
var vy = _;
var fy = D;
var _s = vy.RegExp;
var cy = !fy(function() {
  var a3 = true;
  try {
    _s(".", "d");
  } catch {
    a3 = false;
  }
  var e = {}, t = "", r = a3 ? "dgimsy" : "gimsy", i = function(u, l) {
    Object.defineProperty(e, u, {
      get: function() {
        return t += l, true;
      }
    });
  }, n = {
    dotAll: "s",
    global: "g",
    ignoreCase: "i",
    multiline: "m",
    sticky: "y"
  };
  a3 && (n.hasIndices = "d");
  for (var o in n) i(o, n[o]);
  var s = Object.getOwnPropertyDescriptor(_s.prototype, "flags").get.call(e);
  return s !== r || t !== r;
});
var gy = {
  correct: cy
};
var dy = Y;
var py = fe;
var yy = Tr;
var Vs = gy;
var my = Hu;
var by = RegExp.prototype;
var Ki = Vs.correct ? function(a3) {
  return a3.flags;
} : function(a3) {
  return !Vs.correct && yy(by, a3) && !py(a3, "flags") ? dy(my, a3) : a3.flags;
};
var Ds = Y;
var xy = J;
var Ty = B;
var Oy = je;
var Sy = Xi;
var Ey = TypeError;
var Zi = function(a3, e) {
  var t = a3.exec;
  if (Ty(t)) {
    var r = Ds(t, a3, e);
    return r !== null && xy(r), r;
  }
  if (Oy(a3) === "RegExp") return Ds(Sy, a3, e);
  throw new Ey("RegExp#exec called on incompatible receiver");
};
var $y = Y;
var wy = L;
var Cy = Wi;
var Ay = J;
var Py = ae;
var Ry = ot;
var Jt = pe;
var Ny = ve;
var Iy = st;
var My = Qi;
var _y = Ki;
var Ls = Zi;
var ks = wy("".indexOf);
Cy("match", function(a3, e, t) {
  return [
    // `String.prototype.match` method
    // https://tc39.es/ecma262/#sec-string.prototype.match
    function(i) {
      var n = Ny(this), o = Py(i) ? Iy(i, a3) : void 0;
      return o ? $y(o, i, n) : new RegExp(i)[a3](Jt(n));
    },
    // `RegExp.prototype[@@match]` method
    // https://tc39.es/ecma262/#sec-regexp.prototype-@@match
    function(r) {
      var i = Ay(this), n = Jt(r), o = t(e, i, n);
      if (o.done) return o.value;
      var s = Jt(_y(i));
      if (ks(s, "g") === -1) return Ls(i, n);
      var u = ks(s, "u") !== -1;
      i.lastIndex = 0;
      for (var l = [], h = 0, f; (f = Ls(i, n)) !== null; ) {
        var c = Jt(f[0]);
        l[h] = c, c === "" && (i.lastIndex = My(n, Ry(i.lastIndex), u)), h++;
      }
      return h === 0 ? null : l;
    }
  ];
});
var Ji = L;
var Vy = Sr;
var Dy = Math.floor;
var Ca = Ji("".charAt);
var Ly = Ji("".replace);
var Aa = Ji("".slice);
var ky = /\$([$&'`]|\d{1,2}|<[^>]*>)/g;
var By = /\$([$&'`]|\d{1,2})/g;
var jy = function(a3, e, t, r, i, n) {
  var o = t + a3.length, s = r.length, u = By;
  return i !== void 0 && (i = Vy(i), u = ky), Ly(n, u, function(l, h) {
    var f;
    switch (Ca(h, 0)) {
      case "$":
        return "$";
      case "&":
        return a3;
      case "`":
        return Aa(e, 0, t);
      case "'":
        return Aa(e, o);
      case "<":
        f = i[Aa(h, 1, -1)];
        break;
      default:
        var c = +h;
        if (c === 0) return l;
        if (c > s) {
          var v = Dy(c / 10);
          return v === 0 ? l : v <= s ? r[v - 1] === void 0 ? Ca(h, 1) : r[v - 1] + Ca(h, 1) : l;
        }
        f = r[c - 1];
    }
    return f === void 0 ? "" : f;
  });
};
var Fy = bu;
var Bs = Y;
var _r = L;
var Uy = Wi;
var Gy = D;
var zy = J;
var Hy = B;
var Yy = ae;
var Xy = Cr;
var Wy = ot;
var Me = pe;
var qy = ve;
var Qy = Qi;
var Ky = st;
var Zy = jy;
var Jy = Ki;
var em = Zi;
var tm = z;
var vi = tm("replace");
var rm = Math.max;
var am = Math.min;
var im = _r([].concat);
var Pa = _r([].push);
var er = _r("".indexOf);
var js = _r("".slice);
var nm = function(a3) {
  return a3 === void 0 ? a3 : String(a3);
};
var sm = function() {
  return "a".replace(/./, "$0") === "$0";
}();
var Fs = function() {
  return /./[vi] ? /./[vi]("a", "$0") === "" : false;
}();
var om = !Gy(function() {
  var a3 = /./;
  return a3.exec = function() {
    var e = [];
    return e.groups = {
      a: "7"
    }, e;
  }, "".replace(a3, "$<a>") !== "7";
});
Uy("replace", function(a3, e, t) {
  var r = Fs ? "$" : "$0";
  return [
    // `String.prototype.replace` method
    // https://tc39.es/ecma262/#sec-string.prototype.replace
    function(n, o) {
      var s = qy(this), u = Yy(n) ? Ky(n, vi) : void 0;
      return u ? Bs(u, n, s, o) : Bs(e, Me(s), n, o);
    },
    // `RegExp.prototype[@@replace]` method
    // https://tc39.es/ecma262/#sec-regexp.prototype-@@replace
    function(i, n) {
      var o = zy(this), s = Me(i);
      if (typeof n == "string" && er(n, r) === -1 && er(n, "$<") === -1) {
        var u = t(e, o, s, n);
        if (u.done) return u.value;
      }
      var l = Hy(n);
      l || (n = Me(n));
      var h = Me(Jy(o)), f = er(h, "g") !== -1, c;
      f && (c = er(h, "u") !== -1, o.lastIndex = 0);
      for (var v = [], g; g = em(o, s), !(g === null || (Pa(v, g), !f)); ) {
        var d = Me(g[0]);
        d === "" && (o.lastIndex = Qy(s, Wy(o.lastIndex), c));
      }
      for (var p = "", y = 0, x = 0; x < v.length; x++) {
        g = v[x];
        for (var b = Me(g[0]), T = rm(am(Xy(g.index), s.length), 0), $ = [], E, O = 1; O < g.length; O++) Pa($, nm(g[O]));
        var C = g.groups;
        if (l) {
          var P = im([b], $, T, s);
          C !== void 0 && Pa(P, C), E = Me(Fy(n, void 0, P));
        } else E = Zy(b, s, T, $, C, n);
        T >= y && (p += js(s, y, T) + E, y = T + b.length);
      }
      return p + js(s, y);
    }
  ];
}, !om || !sm || Fs);
var um = ae;
var lm = je;
var hm = z;
var vm = hm("match");
var fm = function(a3) {
  var e;
  return um(a3) && ((e = a3[vm]) !== void 0 ? !!e : lm(a3) === "RegExp");
};
var cm = fm;
var gm = TypeError;
var en = function(a3) {
  if (cm(a3)) throw new gm("The method doesn't accept regular expressions");
  return a3;
};
var dm = z;
var pm = dm("match");
var tn = function(a3) {
  var e = /./;
  try {
    "/./"[a3](e);
  } catch {
    try {
      return e[pm] = false, "/./"[a3](e);
    } catch {
    }
  }
  return false;
};
var ym = ee;
var mm = Rr;
var bm = Et.f;
var xm = ot;
var Us = pe;
var Tm = en;
var Om = ve;
var Sm = tn;
var Em = mm("".slice);
var $m = Math.min;
var Zu = Sm("startsWith");
var wm = !Zu && !!function() {
  var a3 = bm(String.prototype, "startsWith");
  return a3 && !a3.writable;
}();
ym({
  target: "String",
  proto: true,
  forced: !wm && !Zu
}, {
  startsWith: function(e) {
    var t = Us(Om(this));
    Tm(e);
    var r = xm($m(arguments.length > 1 ? arguments[1] : void 0, t.length)), i = Us(e);
    return Em(t, r, r + i.length) === i;
  }
});
var Cm = z;
var Am = Yi;
var Pm = Oe.f;
var fi = Cm("unscopables");
var ci = Array.prototype;
ci[fi] === void 0 && Pm(ci, fi, {
  configurable: true,
  value: Am(null)
});
var Rm = function(a3) {
  ci[fi][a3] = true;
};
var Nm = D;
var Im = !Nm(function() {
  function a3() {
  }
  return a3.prototype.constructor = null, Object.getPrototypeOf(new a3()) !== a3.prototype;
});
var Mm = fe;
var _m = B;
var Vm = Sr;
var Dm = Pi;
var Lm = Im;
var Gs = Dm("IE_PROTO");
var gi = Object;
var km = gi.prototype;
var Ju = Lm ? gi.getPrototypeOf : function(a3) {
  var e = Vm(a3);
  if (Mm(e, Gs)) return e[Gs];
  var t = e.constructor;
  return _m(t) && e instanceof t ? t.prototype : e instanceof gi ? km : null;
};
var Bm = D;
var jm = B;
var Fm = ae;
var zs = Ju;
var Um = Ue;
var Gm = z;
var di = Gm("iterator");
var el = false;
var ke;
var Ra;
var Na;
[].keys && (Na = [].keys(), "next" in Na ? (Ra = zs(zs(Na)), Ra !== Object.prototype && (ke = Ra)) : el = true);
var zm = !Fm(ke) || Bm(function() {
  var a3 = {};
  return ke[di].call(a3) !== a3;
});
zm && (ke = {});
jm(ke[di]) || Um(ke, di, function() {
  return this;
});
var tl = {
  IteratorPrototype: ke,
  BUGGY_SAFARI_ITERATORS: el
};
var Hm = tl.IteratorPrototype;
var Ym = Yi;
var Xm = Oi;
var Wm = Pr;
var qm = Rt;
var Qm = function() {
  return this;
};
var Km = function(a3, e, t, r) {
  var i = e + " Iterator";
  return a3.prototype = Ym(Hm, {
    next: Xm(+!r, t)
  }), Wm(a3, i, false), qm[i] = Qm, a3;
};
var Zm = ee;
var Jm = Y;
var rl = $r;
var e0 = B;
var t0 = Km;
var Hs = Ju;
var Ys = vu;
var r0 = Pr;
var a0 = Ct;
var Ia = Ue;
var i0 = z;
var n0 = Rt;
var al = tl;
var s0 = rl.PROPER;
var o0 = rl.CONFIGURABLE;
var Xs = al.IteratorPrototype;
var tr = al.BUGGY_SAFARI_ITERATORS;
var ct = i0("iterator");
var Ws = "keys";
var gt = "values";
var qs = "entries";
var u0 = function() {
  return this;
};
var l0 = function(a3, e, t, r, i, n, o) {
  t0(t, e, r);
  var s = function(y) {
    if (y === i && c) return c;
    if (!tr && y && y in h) return h[y];
    switch (y) {
      case Ws:
        return function() {
          return new t(this, y);
        };
      case gt:
        return function() {
          return new t(this, y);
        };
      case qs:
        return function() {
          return new t(this, y);
        };
    }
    return function() {
      return new t(this);
    };
  }, u = e + " Iterator", l = false, h = a3.prototype, f = h[ct] || h["@@iterator"] || i && h[i], c = !tr && f || s(i), v = e === "Array" && h.entries || f, g, d, p;
  if (v && (g = Hs(v.call(new a3())), g !== Object.prototype && g.next && (Hs(g) !== Xs && (Ys ? Ys(g, Xs) : e0(g[ct]) || Ia(g, ct, u0)), r0(g, u, true))), s0 && i === gt && f && f.name !== gt && (o0 ? a0(h, "name", gt) : (l = true, c = function() {
    return Jm(f, this);
  })), i) if (d = {
    values: s(gt),
    keys: n ? c : s(Ws),
    entries: s(qs)
  }, o) for (p in d) (tr || l || !(p in h)) && Ia(h, p, d[p]);
  else Zm({
    target: e,
    proto: true,
    forced: tr || l
  }, d);
  return h[ct] !== c && Ia(h, ct, c, {
    name: i
  }), n0[e] = c, d;
};
var h0 = function(a3, e) {
  return {
    value: a3,
    done: e
  };
};
var v0 = $t;
var rn = Rm;
var Qs = Rt;
var il = wr;
var f0 = Oe.f;
var c0 = l0;
var rr = h0;
var g0 = he;
var nl = "Array Iterator";
var d0 = il.set;
var p0 = il.getterFor(nl);
var y0 = c0(Array, "Array", function(a3, e) {
  d0(this, {
    type: nl,
    target: v0(a3),
    // target
    index: 0,
    // next index
    kind: e
    // kind
  });
}, function() {
  var a3 = p0(this), e = a3.target, t = a3.index++;
  if (!e || t >= e.length) return a3.target = null, rr(void 0, true);
  switch (a3.kind) {
    case "keys":
      return rr(t, false);
    case "values":
      return rr(e[t], false);
  }
  return rr([t, e[t]], false);
}, "values");
var Ks = Qs.Arguments = Qs.Array;
rn("keys");
rn("values");
rn("entries");
if (g0 && Ks.name !== "values") try {
  f0(Ks, "name", {
    value: "values"
  });
} catch {
}
var m0 = {
  CSSRuleList: 0,
  CSSStyleDeclaration: 0,
  CSSValueList: 0,
  ClientRectList: 0,
  DOMRectList: 0,
  DOMStringList: 0,
  DOMTokenList: 1,
  DataTransferItemList: 0,
  FileList: 0,
  HTMLAllCollection: 0,
  HTMLCollection: 0,
  HTMLFormElement: 0,
  HTMLSelectElement: 0,
  MediaList: 0,
  MimeTypeArray: 0,
  NamedNodeMap: 0,
  NodeList: 1,
  PaintRequestList: 0,
  Plugin: 0,
  PluginArray: 0,
  SVGLengthList: 0,
  SVGNumberList: 0,
  SVGPathSegList: 0,
  SVGPointList: 0,
  SVGStringList: 0,
  SVGTransformList: 0,
  SourceBufferList: 0,
  StyleSheetList: 0,
  TextTrackCueList: 0,
  TextTrackList: 0,
  TouchList: 0
};
var b0 = Er;
var Ma = b0("span").classList;
var Zs = Ma && Ma.constructor && Ma.constructor.prototype;
var x0 = Zs === Object.prototype ? void 0 : Zs;
var Js = _;
var sl = m0;
var T0 = x0;
var pt = y0;
var eo = Ct;
var O0 = Pr;
var S0 = z;
var _a = S0("iterator");
var Va = pt.values;
var ol = function(a3, e) {
  if (a3) {
    if (a3[_a] !== Va) try {
      eo(a3, _a, Va);
    } catch {
      a3[_a] = Va;
    }
    if (O0(a3, e, true), sl[e]) {
      for (var t in pt) if (a3[t] !== pt[t]) try {
        eo(a3, t, pt[t]);
      } catch {
        a3[t] = pt[t];
      }
    }
  }
};
for (Da in sl) ol(Js[Da] && Js[Da].prototype, Da);
var Da;
ol(T0, "DOMTokenList");
function E0(a3, e) {
  if (Wt(a3) != "object" || !a3) return a3;
  var t = a3[Symbol.toPrimitive];
  if (t !== void 0) {
    var r = t.call(a3, e || "default");
    if (Wt(r) != "object") return r;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (e === "string" ? String : Number)(a3);
}
function $0(a3) {
  var e = E0(a3, "string");
  return Wt(e) == "symbol" ? e : e + "";
}
function an(a3, e, t) {
  return (e = $0(e)) in a3 ? Object.defineProperty(a3, e, {
    value: t,
    enumerable: true,
    configurable: true,
    writable: true
  }) : a3[e] = t, a3;
}
var w0 = Te;
var C0 = Sr;
var A0 = zo;
var P0 = Ii;
var to = TypeError;
var ro = "Reduce of empty array with no initial value";
var ao = function(a3) {
  return function(e, t, r, i) {
    var n = C0(e), o = A0(n), s = P0(n);
    if (w0(t), s === 0 && r < 2) throw new to(ro);
    var u = a3 ? s - 1 : 0, l = a3 ? -1 : 1;
    if (r < 2) for (; ; ) {
      if (u in o) {
        i = o[u], u += l;
        break;
      }
      if (u += l, a3 ? u < 0 : s <= u) throw new to(ro);
    }
    for (; a3 ? u >= 0 : s > u; u += l) u in o && (i = t(i, o[u], u, n));
    return i;
  };
};
var R0 = {
  // `Array.prototype.reduce` method
  // https://tc39.es/ecma262/#sec-array.prototype.reduce
  left: ao(false),
  // `Array.prototype.reduceRight` method
  // https://tc39.es/ecma262/#sec-array.prototype.reduceright
  right: ao(true)
};
var N0 = D;
var ul = function(a3, e) {
  var t = [][a3];
  return !!t && N0(function() {
    t.call(null, e || function() {
      return 1;
    }, 1);
  });
};
var I0 = ee;
var M0 = R0.left;
var _0 = ul;
var io = Si;
var V0 = Ar;
var D0 = !V0 && io > 79 && io < 83;
var L0 = D0 || !_0("reduce");
I0({
  target: "Array",
  proto: true,
  forced: L0
}, {
  reduce: function(e) {
    var t = arguments.length;
    return M0(this, e, t, t > 1 ? arguments[1] : void 0);
  }
});
var k0 = ee;
var B0 = Rr;
var j0 = Et.f;
var F0 = ot;
var no = pe;
var U0 = en;
var G0 = ve;
var z0 = tn;
var H0 = B0("".slice);
var Y0 = Math.min;
var ll = z0("endsWith");
var X0 = !ll && !!function() {
  var a3 = j0(String.prototype, "endsWith");
  return a3 && !a3.writable;
}();
k0({
  target: "String",
  proto: true,
  forced: !X0 && !ll
}, {
  endsWith: function(e) {
    var t = no(G0(this));
    U0(e);
    var r = arguments.length > 1 ? arguments[1] : void 0, i = t.length, n = r === void 0 ? i : Y0(F0(r), i), o = no(e);
    return H0(t, n - o.length, n) === o;
  }
});
var La = Y;
var hl = L;
var W0 = Wi;
var q0 = J;
var Q0 = ae;
var K0 = ve;
var Z0 = yu;
var J0 = Qi;
var eb = ot;
var so = pe;
var tb = st;
var oo = Zi;
var rb = Yu;
var ab = D;
var We = rb.UNSUPPORTED_Y;
var ib = 4294967295;
var nb = Math.min;
var ka = hl([].push);
var Ba = hl("".slice);
var sb = !ab(function() {
  var a3 = /(?:)/, e = a3.exec;
  a3.exec = function() {
    return e.apply(this, arguments);
  };
  var t = "ab".split(a3);
  return t.length !== 2 || t[0] !== "a" || t[1] !== "b";
});
var uo = "abbc".split(/(b)*/)[1] === "c" || // eslint-disable-next-line regexp/no-empty-group -- required for testing
"test".split(/(?:)/, -1).length !== 4 || "ab".split(/(?:ab)*/).length !== 2 || ".".split(/(.?)(.?)/).length !== 4 || // eslint-disable-next-line regexp/no-empty-capturing-group, regexp/no-empty-group -- required for testing
".".split(/()()/).length > 1 || "".split(/.?/).length;
W0("split", function(a3, e, t) {
  var r = "0".split(void 0, 0).length ? function(i, n) {
    return i === void 0 && n === 0 ? [] : La(e, this, i, n);
  } : e;
  return [
    // `String.prototype.split` method
    // https://tc39.es/ecma262/#sec-string.prototype.split
    function(n, o) {
      var s = K0(this), u = Q0(n) ? tb(n, a3) : void 0;
      return u ? La(u, n, s, o) : La(r, so(s), n, o);
    },
    // `RegExp.prototype[@@split]` method
    // https://tc39.es/ecma262/#sec-regexp.prototype-@@split
    //
    // NOTE: This cannot be properly polyfilled in engines that don't support
    // the 'y' flag.
    function(i, n) {
      var o = q0(this), s = so(i);
      if (!uo) {
        var u = t(r, o, s, n, r !== e);
        if (u.done) return u.value;
      }
      var l = Z0(o, RegExp), h = o.unicode, f = (o.ignoreCase ? "i" : "") + (o.multiline ? "m" : "") + (o.unicode ? "u" : "") + (We ? "g" : "y"), c = new l(We ? "^(?:" + o.source + ")" : o, f), v = n === void 0 ? ib : n >>> 0;
      if (v === 0) return [];
      if (s.length === 0) return oo(c, s) === null ? [s] : [];
      for (var g = 0, d = 0, p = []; d < s.length; ) {
        c.lastIndex = We ? 0 : d;
        var y = oo(c, We ? Ba(s, d) : s), x;
        if (y === null || (x = nb(eb(c.lastIndex + (We ? d : 0)), s.length)) === g) d = J0(s, d, h);
        else {
          if (ka(p, Ba(s, g, d)), p.length === v) return p;
          for (var b = 1; b <= y.length - 1; b++) if (ka(p, y[b]), p.length === v) return p;
          d = g = x;
        }
      }
      return ka(p, Ba(s, g)), p;
    }
  ];
}, uo || !sb, We);
var Vr = {
  exports: {}
};
var yt = {
  exports: {}
};
(function() {
  var a3, e, t, r, i, n;
  typeof performance < "u" && performance !== null && performance.now ? yt.exports = function() {
    return performance.now();
  } : typeof process < "u" && process !== null && process.hrtime ? (yt.exports = function() {
    return (a3() - i) / 1e6;
  }, e = process.hrtime, a3 = function() {
    var o;
    return o = e(), o[0] * 1e9 + o[1];
  }, r = a3(), n = process.uptime() * 1e9, i = r - n) : Date.now ? (yt.exports = function() {
    return Date.now() - t;
  }, t = Date.now()) : (yt.exports = function() {
    return (/* @__PURE__ */ new Date()).getTime() - t;
  }, t = (/* @__PURE__ */ new Date()).getTime());
}).call(Qe);
var ob = yt.exports;
var ub = ob;
var be = typeof window > "u" ? Qe : window;
var ar = ["moz", "webkit"];
var tt = "AnimationFrame";
var nt = be["request" + tt];
var St = be["cancel" + tt] || be["cancelRequest" + tt];
for (dt = 0; !nt && dt < ar.length; dt++) nt = be[ar[dt] + "Request" + tt], St = be[ar[dt] + "Cancel" + tt] || be[ar[dt] + "CancelRequest" + tt];
var dt;
if (!nt || !St) {
  ja = 0, lo = 0, _e = [], lb = 1e3 / 60;
  nt = function(a3) {
    if (_e.length === 0) {
      var e = ub(), t = Math.max(0, lb - (e - ja));
      ja = t + e, setTimeout(function() {
        var r = _e.slice(0);
        _e.length = 0;
        for (var i = 0; i < r.length; i++) if (!r[i].cancelled) try {
          r[i].callback(ja);
        } catch (n) {
          setTimeout(function() {
            throw n;
          }, 0);
        }
      }, Math.round(t));
    }
    return _e.push({
      handle: ++lo,
      callback: a3,
      cancelled: false
    }), lo;
  }, St = function(a3) {
    for (var e = 0; e < _e.length; e++) _e[e].handle === a3 && (_e[e].cancelled = true);
  };
}
var ja;
var lo;
var _e;
var lb;
Vr.exports = function(a3) {
  return nt.call(be, a3);
};
Vr.exports.cancel = function() {
  St.apply(be, arguments);
};
Vr.exports.polyfill = function(a3) {
  a3 || (a3 = be), a3.requestAnimationFrame = nt, a3.cancelAnimationFrame = St;
};
var hb = Vr.exports;
var Fa = Lo(hb);
var vl = `	
\v\f\r                　\u2028\u2029\uFEFF`;
var vb = L;
var fb = ve;
var cb = pe;
var pi = vl;
var ho = vb("".replace);
var gb = RegExp("^[" + pi + "]+");
var db = RegExp("(^|[^" + pi + "])[" + pi + "]+$");
var Ua = function(a3) {
  return function(e) {
    var t = cb(fb(e));
    return a3 & 1 && (t = ho(t, gb, "")), a3 & 2 && (t = ho(t, db, "$1")), t;
  };
};
var pb = {
  // `String.prototype.{ trimLeft, trimStart }` methods
  // https://tc39.es/ecma262/#sec-string.prototype.trimstart
  start: Ua(1),
  // `String.prototype.{ trimRight, trimEnd }` methods
  // https://tc39.es/ecma262/#sec-string.prototype.trimend
  end: Ua(2),
  // `String.prototype.trim` method
  // https://tc39.es/ecma262/#sec-string.prototype.trim
  trim: Ua(3)
};
var yb = $r.PROPER;
var mb = D;
var vo = vl;
var fo = "​᠎";
var bb = function(a3) {
  return mb(function() {
    return !!vo[a3]() || fo[a3]() !== fo || yb && vo[a3].name !== a3;
  });
};
var xb = ee;
var Tb = pb.trim;
var Ob = bb;
xb({
  target: "String",
  proto: true,
  forced: Ob("trim")
}, {
  trim: function() {
    return Tb(this);
  }
});
var Sb = function(a3) {
  this.ok = false, this.alpha = 1, a3.charAt(0) == "#" && (a3 = a3.substr(1, 6)), a3 = a3.replace(/ /g, ""), a3 = a3.toLowerCase();
  var e = {
    aliceblue: "f0f8ff",
    antiquewhite: "faebd7",
    aqua: "00ffff",
    aquamarine: "7fffd4",
    azure: "f0ffff",
    beige: "f5f5dc",
    bisque: "ffe4c4",
    black: "000000",
    blanchedalmond: "ffebcd",
    blue: "0000ff",
    blueviolet: "8a2be2",
    brown: "a52a2a",
    burlywood: "deb887",
    cadetblue: "5f9ea0",
    chartreuse: "7fff00",
    chocolate: "d2691e",
    coral: "ff7f50",
    cornflowerblue: "6495ed",
    cornsilk: "fff8dc",
    crimson: "dc143c",
    cyan: "00ffff",
    darkblue: "00008b",
    darkcyan: "008b8b",
    darkgoldenrod: "b8860b",
    darkgray: "a9a9a9",
    darkgreen: "006400",
    darkkhaki: "bdb76b",
    darkmagenta: "8b008b",
    darkolivegreen: "556b2f",
    darkorange: "ff8c00",
    darkorchid: "9932cc",
    darkred: "8b0000",
    darksalmon: "e9967a",
    darkseagreen: "8fbc8f",
    darkslateblue: "483d8b",
    darkslategray: "2f4f4f",
    darkturquoise: "00ced1",
    darkviolet: "9400d3",
    deeppink: "ff1493",
    deepskyblue: "00bfff",
    dimgray: "696969",
    dodgerblue: "1e90ff",
    feldspar: "d19275",
    firebrick: "b22222",
    floralwhite: "fffaf0",
    forestgreen: "228b22",
    fuchsia: "ff00ff",
    gainsboro: "dcdcdc",
    ghostwhite: "f8f8ff",
    gold: "ffd700",
    goldenrod: "daa520",
    gray: "808080",
    green: "008000",
    greenyellow: "adff2f",
    honeydew: "f0fff0",
    hotpink: "ff69b4",
    indianred: "cd5c5c",
    indigo: "4b0082",
    ivory: "fffff0",
    khaki: "f0e68c",
    lavender: "e6e6fa",
    lavenderblush: "fff0f5",
    lawngreen: "7cfc00",
    lemonchiffon: "fffacd",
    lightblue: "add8e6",
    lightcoral: "f08080",
    lightcyan: "e0ffff",
    lightgoldenrodyellow: "fafad2",
    lightgrey: "d3d3d3",
    lightgreen: "90ee90",
    lightpink: "ffb6c1",
    lightsalmon: "ffa07a",
    lightseagreen: "20b2aa",
    lightskyblue: "87cefa",
    lightslateblue: "8470ff",
    lightslategray: "778899",
    lightsteelblue: "b0c4de",
    lightyellow: "ffffe0",
    lime: "00ff00",
    limegreen: "32cd32",
    linen: "faf0e6",
    magenta: "ff00ff",
    maroon: "800000",
    mediumaquamarine: "66cdaa",
    mediumblue: "0000cd",
    mediumorchid: "ba55d3",
    mediumpurple: "9370d8",
    mediumseagreen: "3cb371",
    mediumslateblue: "7b68ee",
    mediumspringgreen: "00fa9a",
    mediumturquoise: "48d1cc",
    mediumvioletred: "c71585",
    midnightblue: "191970",
    mintcream: "f5fffa",
    mistyrose: "ffe4e1",
    moccasin: "ffe4b5",
    navajowhite: "ffdead",
    navy: "000080",
    oldlace: "fdf5e6",
    olive: "808000",
    olivedrab: "6b8e23",
    orange: "ffa500",
    orangered: "ff4500",
    orchid: "da70d6",
    palegoldenrod: "eee8aa",
    palegreen: "98fb98",
    paleturquoise: "afeeee",
    palevioletred: "d87093",
    papayawhip: "ffefd5",
    peachpuff: "ffdab9",
    peru: "cd853f",
    pink: "ffc0cb",
    plum: "dda0dd",
    powderblue: "b0e0e6",
    purple: "800080",
    rebeccapurple: "663399",
    red: "ff0000",
    rosybrown: "bc8f8f",
    royalblue: "4169e1",
    saddlebrown: "8b4513",
    salmon: "fa8072",
    sandybrown: "f4a460",
    seagreen: "2e8b57",
    seashell: "fff5ee",
    sienna: "a0522d",
    silver: "c0c0c0",
    skyblue: "87ceeb",
    slateblue: "6a5acd",
    slategray: "708090",
    snow: "fffafa",
    springgreen: "00ff7f",
    steelblue: "4682b4",
    tan: "d2b48c",
    teal: "008080",
    thistle: "d8bfd8",
    tomato: "ff6347",
    turquoise: "40e0d0",
    violet: "ee82ee",
    violetred: "d02090",
    wheat: "f5deb3",
    white: "ffffff",
    whitesmoke: "f5f5f5",
    yellow: "ffff00",
    yellowgreen: "9acd32"
  };
  a3 = e[a3] || a3;
  for (var t = [{
    re: /^rgba\((\d{1,3}),\s*(\d{1,3}),\s*(\d{1,3}),\s*((?:\d?\.)?\d)\)$/,
    example: ["rgba(123, 234, 45, 0.8)", "rgba(255,234,245,1.0)"],
    process: function(u) {
      return [parseInt(u[1]), parseInt(u[2]), parseInt(u[3]), parseFloat(u[4])];
    }
  }, {
    re: /^rgb\((\d{1,3}),\s*(\d{1,3}),\s*(\d{1,3})\)$/,
    example: ["rgb(123, 234, 45)", "rgb(255,234,245)"],
    process: function(u) {
      return [parseInt(u[1]), parseInt(u[2]), parseInt(u[3])];
    }
  }, {
    re: /^([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/,
    example: ["#00ff00", "336699"],
    process: function(u) {
      return [parseInt(u[1], 16), parseInt(u[2], 16), parseInt(u[3], 16)];
    }
  }, {
    re: /^([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
    example: ["#fb0", "f0f"],
    process: function(u) {
      return [parseInt(u[1] + u[1], 16), parseInt(u[2] + u[2], 16), parseInt(u[3] + u[3], 16)];
    }
  }], r = 0; r < t.length; r++) {
    var i = t[r].re, n = t[r].process, o = i.exec(a3);
    if (o) {
      var s = n(o);
      this.r = s[0], this.g = s[1], this.b = s[2], s.length > 3 && (this.alpha = s[3]), this.ok = true;
    }
  }
  this.r = this.r < 0 || isNaN(this.r) ? 0 : this.r > 255 ? 255 : this.r, this.g = this.g < 0 || isNaN(this.g) ? 0 : this.g > 255 ? 255 : this.g, this.b = this.b < 0 || isNaN(this.b) ? 0 : this.b > 255 ? 255 : this.b, this.alpha = this.alpha < 0 ? 0 : this.alpha > 1 || isNaN(this.alpha) ? 1 : this.alpha, this.toRGB = function() {
    return "rgb(" + this.r + ", " + this.g + ", " + this.b + ")";
  }, this.toRGBA = function() {
    return "rgba(" + this.r + ", " + this.g + ", " + this.b + ", " + this.alpha + ")";
  }, this.toHex = function() {
    var u = this.r.toString(16), l = this.g.toString(16), h = this.b.toString(16);
    return u.length == 1 && (u = "0" + u), l.length == 1 && (l = "0" + l), h.length == 1 && (h = "0" + h), "#" + u + l + h;
  }, this.getHelpXML = function() {
    for (var u = new Array(), l = 0; l < t.length; l++) for (var h = t[l].example, f = 0; f < h.length; f++) u[u.length] = h[f];
    for (var c in e) u[u.length] = c;
    var v = document.createElement("ul");
    v.setAttribute("id", "rgbcolor-examples");
    for (var l = 0; l < u.length; l++) try {
      var g = document.createElement("li"), d = new RGBColor(u[l]), p = document.createElement("div");
      p.style.cssText = "margin: 3px; border: 1px solid black; background:" + d.toHex() + "; color:" + d.toHex(), p.appendChild(document.createTextNode("test"));
      var y = document.createTextNode(" " + u[l] + " -> " + d.toRGB() + " -> " + d.toHex());
      g.appendChild(p), g.appendChild(y), v.appendChild(g);
    } catch {
    }
    return v;
  };
};
var yi = Lo(Sb);
var Eb = ee;
var $b = Rr;
var wb = su.indexOf;
var Cb = ul;
var mi = $b([].indexOf);
var fl = !!mi && 1 / mi([1], 1, -0) < 0;
var Ab = fl || !Cb("indexOf");
Eb({
  target: "Array",
  proto: true,
  forced: Ab
}, {
  indexOf: function(e) {
    var t = arguments.length > 1 ? arguments[1] : void 0;
    return fl ? mi(this, e, t) || 0 : wb(this, e, t);
  }
});
var Pb = ee;
var Rb = L;
var Nb = en;
var Ib = ve;
var co = pe;
var Mb = tn;
var _b = Rb("".indexOf);
Pb({
  target: "String",
  proto: true,
  forced: !Mb("includes")
}, {
  includes: function(e) {
    return !!~_b(co(Ib(this)), co(Nb(e)), arguments.length > 1 ? arguments[1] : void 0);
  }
});
var Vb = je;
var Db = Array.isArray || function(e) {
  return Vb(e) === "Array";
};
var Lb = ee;
var kb = L;
var Bb = Db;
var jb = kb([].reverse);
var go = [1, 2];
Lb({
  target: "Array",
  proto: true,
  forced: String(go) === String(go.reverse())
}, {
  reverse: function() {
    return Bb(this) && (this.length = this.length), jb(this);
  }
});
var cl = function(a3, e) {
  return (cl = Object.setPrototypeOf || {
    __proto__: []
  } instanceof Array && function(t, r) {
    t.__proto__ = r;
  } || function(t, r) {
    for (var i in r) Object.prototype.hasOwnProperty.call(r, i) && (t[i] = r[i]);
  })(a3, e);
};
function gl(a3, e) {
  if (typeof e != "function" && e !== null) throw new TypeError("Class extends value " + String(e) + " is not a constructor or null");
  function t() {
    this.constructor = a3;
  }
  cl(a3, e), a3.prototype = e === null ? Object.create(e) : (t.prototype = e.prototype, new t());
}
function Fb(a3) {
  var e = "";
  Array.isArray(a3) || (a3 = [a3]);
  for (var t = 0; t < a3.length; t++) {
    var r = a3[t];
    if (r.type === m.CLOSE_PATH) e += "z";
    else if (r.type === m.HORIZ_LINE_TO) e += (r.relative ? "h" : "H") + r.x;
    else if (r.type === m.VERT_LINE_TO) e += (r.relative ? "v" : "V") + r.y;
    else if (r.type === m.MOVE_TO) e += (r.relative ? "m" : "M") + r.x + " " + r.y;
    else if (r.type === m.LINE_TO) e += (r.relative ? "l" : "L") + r.x + " " + r.y;
    else if (r.type === m.CURVE_TO) e += (r.relative ? "c" : "C") + r.x1 + " " + r.y1 + " " + r.x2 + " " + r.y2 + " " + r.x + " " + r.y;
    else if (r.type === m.SMOOTH_CURVE_TO) e += (r.relative ? "s" : "S") + r.x2 + " " + r.y2 + " " + r.x + " " + r.y;
    else if (r.type === m.QUAD_TO) e += (r.relative ? "q" : "Q") + r.x1 + " " + r.y1 + " " + r.x + " " + r.y;
    else if (r.type === m.SMOOTH_QUAD_TO) e += (r.relative ? "t" : "T") + r.x + " " + r.y;
    else {
      if (r.type !== m.ARC) throw new Error('Unexpected command type "' + r.type + '" at index ' + t + ".");
      e += (r.relative ? "a" : "A") + r.rX + " " + r.rY + " " + r.xRot + " " + +r.lArcFlag + " " + +r.sweepFlag + " " + r.x + " " + r.y;
    }
  }
  return e;
}
function bi(a3, e) {
  var t = a3[0], r = a3[1];
  return [t * Math.cos(e) - r * Math.sin(e), t * Math.sin(e) + r * Math.cos(e)];
}
function ue() {
  for (var a3 = [], e = 0; e < arguments.length; e++) a3[e] = arguments[e];
  for (var t = 0; t < a3.length; t++) if (typeof a3[t] != "number") throw new Error("assertNumbers arguments[" + t + "] is not a number. " + typeof a3[t] + " == typeof " + a3[t]);
  return true;
}
var Ee = Math.PI;
function Ga(a3, e, t) {
  a3.lArcFlag = a3.lArcFlag === 0 ? 0 : 1, a3.sweepFlag = a3.sweepFlag === 0 ? 0 : 1;
  var r = a3.rX, i = a3.rY, n = a3.x, o = a3.y;
  r = Math.abs(a3.rX), i = Math.abs(a3.rY);
  var s = bi([(e - n) / 2, (t - o) / 2], -a3.xRot / 180 * Ee), u = s[0], l = s[1], h = Math.pow(u, 2) / Math.pow(r, 2) + Math.pow(l, 2) / Math.pow(i, 2);
  1 < h && (r *= Math.sqrt(h), i *= Math.sqrt(h)), a3.rX = r, a3.rY = i;
  var f = Math.pow(r, 2) * Math.pow(l, 2) + Math.pow(i, 2) * Math.pow(u, 2), c = (a3.lArcFlag !== a3.sweepFlag ? 1 : -1) * Math.sqrt(Math.max(0, (Math.pow(r, 2) * Math.pow(i, 2) - f) / f)), v = r * l / i * c, g = -i * u / r * c, d = bi([v, g], a3.xRot / 180 * Ee);
  a3.cX = d[0] + (e + n) / 2, a3.cY = d[1] + (t + o) / 2, a3.phi1 = Math.atan2((l - g) / i, (u - v) / r), a3.phi2 = Math.atan2((-l - g) / i, (-u - v) / r), a3.sweepFlag === 0 && a3.phi2 > a3.phi1 && (a3.phi2 -= 2 * Ee), a3.sweepFlag === 1 && a3.phi2 < a3.phi1 && (a3.phi2 += 2 * Ee), a3.phi1 *= 180 / Ee, a3.phi2 *= 180 / Ee;
}
function po(a3, e, t) {
  ue(a3, e, t);
  var r = a3 * a3 + e * e - t * t;
  if (0 > r) return [];
  if (r === 0) return [[a3 * t / (a3 * a3 + e * e), e * t / (a3 * a3 + e * e)]];
  var i = Math.sqrt(r);
  return [[(a3 * t + e * i) / (a3 * a3 + e * e), (e * t - a3 * i) / (a3 * a3 + e * e)], [(a3 * t - e * i) / (a3 * a3 + e * e), (e * t + a3 * i) / (a3 * a3 + e * e)]];
}
var U;
var ye = Math.PI / 180;
function yo(a3, e, t) {
  return (1 - t) * a3 + t * e;
}
function mo(a3, e, t, r) {
  return a3 + Math.cos(r / 180 * Ee) * e + Math.sin(r / 180 * Ee) * t;
}
function bo(a3, e, t, r) {
  var i = 1e-6, n = e - a3, o = t - e, s = 3 * n + 3 * (r - t) - 6 * o, u = 6 * (o - n), l = 3 * n;
  return Math.abs(s) < i ? [-l / u] : function(h, f, c) {
    c === void 0 && (c = 1e-6);
    var v = h * h / 4 - f;
    if (v < -c) return [];
    if (v <= c) return [-h / 2];
    var g = Math.sqrt(v);
    return [-h / 2 - g, -h / 2 + g];
  }(u / s, l / s, i);
}
function xo(a3, e, t, r, i) {
  var n = 1 - i;
  return a3 * (n * n * n) + e * (3 * n * n * i) + t * (3 * n * i * i) + r * (i * i * i);
}
(function(a3) {
  function e() {
    return i(function(s, u, l) {
      return s.relative && (s.x1 !== void 0 && (s.x1 += u), s.y1 !== void 0 && (s.y1 += l), s.x2 !== void 0 && (s.x2 += u), s.y2 !== void 0 && (s.y2 += l), s.x !== void 0 && (s.x += u), s.y !== void 0 && (s.y += l), s.relative = false), s;
    });
  }
  function t() {
    var s = NaN, u = NaN, l = NaN, h = NaN;
    return i(function(f, c, v) {
      return f.type & m.SMOOTH_CURVE_TO && (f.type = m.CURVE_TO, s = isNaN(s) ? c : s, u = isNaN(u) ? v : u, f.x1 = f.relative ? c - s : 2 * c - s, f.y1 = f.relative ? v - u : 2 * v - u), f.type & m.CURVE_TO ? (s = f.relative ? c + f.x2 : f.x2, u = f.relative ? v + f.y2 : f.y2) : (s = NaN, u = NaN), f.type & m.SMOOTH_QUAD_TO && (f.type = m.QUAD_TO, l = isNaN(l) ? c : l, h = isNaN(h) ? v : h, f.x1 = f.relative ? c - l : 2 * c - l, f.y1 = f.relative ? v - h : 2 * v - h), f.type & m.QUAD_TO ? (l = f.relative ? c + f.x1 : f.x1, h = f.relative ? v + f.y1 : f.y1) : (l = NaN, h = NaN), f;
    });
  }
  function r() {
    var s = NaN, u = NaN;
    return i(function(l, h, f) {
      if (l.type & m.SMOOTH_QUAD_TO && (l.type = m.QUAD_TO, s = isNaN(s) ? h : s, u = isNaN(u) ? f : u, l.x1 = l.relative ? h - s : 2 * h - s, l.y1 = l.relative ? f - u : 2 * f - u), l.type & m.QUAD_TO) {
        s = l.relative ? h + l.x1 : l.x1, u = l.relative ? f + l.y1 : l.y1;
        var c = l.x1, v = l.y1;
        l.type = m.CURVE_TO, l.x1 = ((l.relative ? 0 : h) + 2 * c) / 3, l.y1 = ((l.relative ? 0 : f) + 2 * v) / 3, l.x2 = (l.x + 2 * c) / 3, l.y2 = (l.y + 2 * v) / 3;
      } else s = NaN, u = NaN;
      return l;
    });
  }
  function i(s) {
    var u = 0, l = 0, h = NaN, f = NaN;
    return function(c) {
      if (isNaN(h) && !(c.type & m.MOVE_TO)) throw new Error("path must start with moveto");
      var v = s(c, u, l, h, f);
      return c.type & m.CLOSE_PATH && (u = h, l = f), c.x !== void 0 && (u = c.relative ? u + c.x : c.x), c.y !== void 0 && (l = c.relative ? l + c.y : c.y), c.type & m.MOVE_TO && (h = u, f = l), v;
    };
  }
  function n(s, u, l, h, f, c) {
    return ue(s, u, l, h, f, c), i(function(v, g, d, p) {
      var y = v.x1, x = v.x2, b = v.relative && !isNaN(p), T = v.x !== void 0 ? v.x : b ? 0 : g, $ = v.y !== void 0 ? v.y : b ? 0 : d;
      function E(se) {
        return se * se;
      }
      v.type & m.HORIZ_LINE_TO && u !== 0 && (v.type = m.LINE_TO, v.y = v.relative ? 0 : d), v.type & m.VERT_LINE_TO && l !== 0 && (v.type = m.LINE_TO, v.x = v.relative ? 0 : g), v.x !== void 0 && (v.x = v.x * s + $ * l + (b ? 0 : f)), v.y !== void 0 && (v.y = T * u + v.y * h + (b ? 0 : c)), v.x1 !== void 0 && (v.x1 = v.x1 * s + v.y1 * l + (b ? 0 : f)), v.y1 !== void 0 && (v.y1 = y * u + v.y1 * h + (b ? 0 : c)), v.x2 !== void 0 && (v.x2 = v.x2 * s + v.y2 * l + (b ? 0 : f)), v.y2 !== void 0 && (v.y2 = x * u + v.y2 * h + (b ? 0 : c));
      var O = s * h - u * l;
      if (v.xRot !== void 0 && (s !== 1 || u !== 0 || l !== 0 || h !== 1)) if (O === 0) delete v.rX, delete v.rY, delete v.xRot, delete v.lArcFlag, delete v.sweepFlag, v.type = m.LINE_TO;
      else {
        var C = v.xRot * Math.PI / 180, P = Math.sin(C), V = Math.cos(C), j = 1 / E(v.rX), R = 1 / E(v.rY), X = E(V) * j + E(P) * R, W = 2 * P * V * (j - R), G = E(P) * j + E(V) * R, q = X * h * h - W * u * h + G * u * u, H = W * (s * h + u * l) - 2 * (X * l * h + G * s * u), Q = X * l * l - W * s * l + G * s * s, N = (Math.atan2(H, q - Q) + Math.PI) % Math.PI / 2, M = Math.sin(N), K = Math.cos(N);
        v.rX = Math.abs(O) / Math.sqrt(q * E(K) + H * M * K + Q * E(M)), v.rY = Math.abs(O) / Math.sqrt(q * E(M) - H * M * K + Q * E(K)), v.xRot = 180 * N / Math.PI;
      }
      return v.sweepFlag !== void 0 && 0 > O && (v.sweepFlag = +!v.sweepFlag), v;
    });
  }
  function o() {
    return function(s) {
      var u = {};
      for (var l in s) u[l] = s[l];
      return u;
    };
  }
  a3.ROUND = function(s) {
    function u(l) {
      return Math.round(l * s) / s;
    }
    return s === void 0 && (s = 1e13), ue(s), function(l) {
      return l.x1 !== void 0 && (l.x1 = u(l.x1)), l.y1 !== void 0 && (l.y1 = u(l.y1)), l.x2 !== void 0 && (l.x2 = u(l.x2)), l.y2 !== void 0 && (l.y2 = u(l.y2)), l.x !== void 0 && (l.x = u(l.x)), l.y !== void 0 && (l.y = u(l.y)), l.rX !== void 0 && (l.rX = u(l.rX)), l.rY !== void 0 && (l.rY = u(l.rY)), l;
    };
  }, a3.TO_ABS = e, a3.TO_REL = function() {
    return i(function(s, u, l) {
      return s.relative || (s.x1 !== void 0 && (s.x1 -= u), s.y1 !== void 0 && (s.y1 -= l), s.x2 !== void 0 && (s.x2 -= u), s.y2 !== void 0 && (s.y2 -= l), s.x !== void 0 && (s.x -= u), s.y !== void 0 && (s.y -= l), s.relative = true), s;
    });
  }, a3.NORMALIZE_HVZ = function(s, u, l) {
    return s === void 0 && (s = true), u === void 0 && (u = true), l === void 0 && (l = true), i(function(h, f, c, v, g) {
      if (isNaN(v) && !(h.type & m.MOVE_TO)) throw new Error("path must start with moveto");
      return u && h.type & m.HORIZ_LINE_TO && (h.type = m.LINE_TO, h.y = h.relative ? 0 : c), l && h.type & m.VERT_LINE_TO && (h.type = m.LINE_TO, h.x = h.relative ? 0 : f), s && h.type & m.CLOSE_PATH && (h.type = m.LINE_TO, h.x = h.relative ? v - f : v, h.y = h.relative ? g - c : g), h.type & m.ARC && (h.rX === 0 || h.rY === 0) && (h.type = m.LINE_TO, delete h.rX, delete h.rY, delete h.xRot, delete h.lArcFlag, delete h.sweepFlag), h;
    });
  }, a3.NORMALIZE_ST = t, a3.QT_TO_C = r, a3.INFO = i, a3.SANITIZE = function(s) {
    s === void 0 && (s = 0), ue(s);
    var u = NaN, l = NaN, h = NaN, f = NaN;
    return i(function(c, v, g, d, p) {
      var y = Math.abs, x = false, b = 0, T = 0;
      if (c.type & m.SMOOTH_CURVE_TO && (b = isNaN(u) ? 0 : v - u, T = isNaN(l) ? 0 : g - l), c.type & (m.CURVE_TO | m.SMOOTH_CURVE_TO) ? (u = c.relative ? v + c.x2 : c.x2, l = c.relative ? g + c.y2 : c.y2) : (u = NaN, l = NaN), c.type & m.SMOOTH_QUAD_TO ? (h = isNaN(h) ? v : 2 * v - h, f = isNaN(f) ? g : 2 * g - f) : c.type & m.QUAD_TO ? (h = c.relative ? v + c.x1 : c.x1, f = c.relative ? g + c.y1 : c.y2) : (h = NaN, f = NaN), c.type & m.LINE_COMMANDS || c.type & m.ARC && (c.rX === 0 || c.rY === 0 || !c.lArcFlag) || c.type & m.CURVE_TO || c.type & m.SMOOTH_CURVE_TO || c.type & m.QUAD_TO || c.type & m.SMOOTH_QUAD_TO) {
        var $ = c.x === void 0 ? 0 : c.relative ? c.x : c.x - v, E = c.y === void 0 ? 0 : c.relative ? c.y : c.y - g;
        b = isNaN(h) ? c.x1 === void 0 ? b : c.relative ? c.x : c.x1 - v : h - v, T = isNaN(f) ? c.y1 === void 0 ? T : c.relative ? c.y : c.y1 - g : f - g;
        var O = c.x2 === void 0 ? 0 : c.relative ? c.x : c.x2 - v, C = c.y2 === void 0 ? 0 : c.relative ? c.y : c.y2 - g;
        y($) <= s && y(E) <= s && y(b) <= s && y(T) <= s && y(O) <= s && y(C) <= s && (x = true);
      }
      return c.type & m.CLOSE_PATH && y(v - d) <= s && y(g - p) <= s && (x = true), x ? [] : c;
    });
  }, a3.MATRIX = n, a3.ROTATE = function(s, u, l) {
    u === void 0 && (u = 0), l === void 0 && (l = 0), ue(s, u, l);
    var h = Math.sin(s), f = Math.cos(s);
    return n(f, h, -h, f, u - u * f + l * h, l - u * h - l * f);
  }, a3.TRANSLATE = function(s, u) {
    return u === void 0 && (u = 0), ue(s, u), n(1, 0, 0, 1, s, u);
  }, a3.SCALE = function(s, u) {
    return u === void 0 && (u = s), ue(s, u), n(s, 0, 0, u, 0, 0);
  }, a3.SKEW_X = function(s) {
    return ue(s), n(1, 0, Math.atan(s), 1, 0, 0);
  }, a3.SKEW_Y = function(s) {
    return ue(s), n(1, Math.atan(s), 0, 1, 0, 0);
  }, a3.X_AXIS_SYMMETRY = function(s) {
    return s === void 0 && (s = 0), ue(s), n(-1, 0, 0, 1, s, 0);
  }, a3.Y_AXIS_SYMMETRY = function(s) {
    return s === void 0 && (s = 0), ue(s), n(1, 0, 0, -1, 0, s);
  }, a3.A_TO_C = function() {
    return i(function(s, u, l) {
      return m.ARC === s.type ? function(h, f, c) {
        var v, g, d, p;
        h.cX || Ga(h, f, c);
        for (var y = Math.min(h.phi1, h.phi2), x = Math.max(h.phi1, h.phi2) - y, b = Math.ceil(x / 90), T = new Array(b), $ = f, E = c, O = 0; O < b; O++) {
          var C = yo(h.phi1, h.phi2, O / b), P = yo(h.phi1, h.phi2, (O + 1) / b), V = P - C, j = 4 / 3 * Math.tan(V * ye / 4), R = [Math.cos(C * ye) - j * Math.sin(C * ye), Math.sin(C * ye) + j * Math.cos(C * ye)], X = R[0], W = R[1], G = [Math.cos(P * ye), Math.sin(P * ye)], q = G[0], H = G[1], Q = [q + j * Math.sin(P * ye), H - j * Math.cos(P * ye)], N = Q[0], M = Q[1];
          T[O] = {
            relative: h.relative,
            type: m.CURVE_TO
          };
          var K = function(se, ge) {
            var Se = bi([se * h.rX, ge * h.rY], h.xRot), ze = Se[0], It = Se[1];
            return [h.cX + ze, h.cY + It];
          };
          v = K(X, W), T[O].x1 = v[0], T[O].y1 = v[1], g = K(N, M), T[O].x2 = g[0], T[O].y2 = g[1], d = K(q, H), T[O].x = d[0], T[O].y = d[1], h.relative && (T[O].x1 -= $, T[O].y1 -= E, T[O].x2 -= $, T[O].y2 -= E, T[O].x -= $, T[O].y -= E), $ = (p = [T[O].x, T[O].y])[0], E = p[1];
        }
        return T;
      }(s, s.relative ? 0 : u, s.relative ? 0 : l) : s;
    });
  }, a3.ANNOTATE_ARCS = function() {
    return i(function(s, u, l) {
      return s.relative && (u = 0, l = 0), m.ARC === s.type && Ga(s, u, l), s;
    });
  }, a3.CLONE = o, a3.CALCULATE_BOUNDS = function() {
    var s = function(c) {
      var v = {};
      for (var g in c) v[g] = c[g];
      return v;
    }, u = e(), l = r(), h = t(), f = i(function(c, v, g) {
      var d = h(l(u(s(c))));
      function p(M) {
        M > f.maxX && (f.maxX = M), M < f.minX && (f.minX = M);
      }
      function y(M) {
        M > f.maxY && (f.maxY = M), M < f.minY && (f.minY = M);
      }
      if (d.type & m.DRAWING_COMMANDS && (p(v), y(g)), d.type & m.HORIZ_LINE_TO && p(d.x), d.type & m.VERT_LINE_TO && y(d.y), d.type & m.LINE_TO && (p(d.x), y(d.y)), d.type & m.CURVE_TO) {
        p(d.x), y(d.y);
        for (var x = 0, b = bo(v, d.x1, d.x2, d.x); x < b.length; x++) 0 < (N = b[x]) && 1 > N && p(xo(v, d.x1, d.x2, d.x, N));
        for (var T = 0, $ = bo(g, d.y1, d.y2, d.y); T < $.length; T++) 0 < (N = $[T]) && 1 > N && y(xo(g, d.y1, d.y2, d.y, N));
      }
      if (d.type & m.ARC) {
        p(d.x), y(d.y), Ga(d, v, g);
        for (var E = d.xRot / 180 * Math.PI, O = Math.cos(E) * d.rX, C = Math.sin(E) * d.rX, P = -Math.sin(E) * d.rY, V = Math.cos(E) * d.rY, j = d.phi1 < d.phi2 ? [d.phi1, d.phi2] : -180 > d.phi2 ? [d.phi2 + 360, d.phi1 + 360] : [d.phi2, d.phi1], R = j[0], X = j[1], W = function(M) {
          var K = M[0], se = M[1], ge = 180 * Math.atan2(se, K) / Math.PI;
          return ge < R ? ge + 360 : ge;
        }, G = 0, q = po(P, -O, 0).map(W); G < q.length; G++) (N = q[G]) > R && N < X && p(mo(d.cX, O, P, N));
        for (var H = 0, Q = po(V, -C, 0).map(W); H < Q.length; H++) {
          var N;
          (N = Q[H]) > R && N < X && y(mo(d.cY, C, V, N));
        }
      }
      return c;
    });
    return f.minX = 1 / 0, f.maxX = -1 / 0, f.minY = 1 / 0, f.maxY = -1 / 0, f;
  };
})(U || (U = {}));
var oe;
var dl = function() {
  function a3() {
  }
  return a3.prototype.round = function(e) {
    return this.transform(U.ROUND(e));
  }, a3.prototype.toAbs = function() {
    return this.transform(U.TO_ABS());
  }, a3.prototype.toRel = function() {
    return this.transform(U.TO_REL());
  }, a3.prototype.normalizeHVZ = function(e, t, r) {
    return this.transform(U.NORMALIZE_HVZ(e, t, r));
  }, a3.prototype.normalizeST = function() {
    return this.transform(U.NORMALIZE_ST());
  }, a3.prototype.qtToC = function() {
    return this.transform(U.QT_TO_C());
  }, a3.prototype.aToC = function() {
    return this.transform(U.A_TO_C());
  }, a3.prototype.sanitize = function(e) {
    return this.transform(U.SANITIZE(e));
  }, a3.prototype.translate = function(e, t) {
    return this.transform(U.TRANSLATE(e, t));
  }, a3.prototype.scale = function(e, t) {
    return this.transform(U.SCALE(e, t));
  }, a3.prototype.rotate = function(e, t, r) {
    return this.transform(U.ROTATE(e, t, r));
  }, a3.prototype.matrix = function(e, t, r, i, n, o) {
    return this.transform(U.MATRIX(e, t, r, i, n, o));
  }, a3.prototype.skewX = function(e) {
    return this.transform(U.SKEW_X(e));
  }, a3.prototype.skewY = function(e) {
    return this.transform(U.SKEW_Y(e));
  }, a3.prototype.xSymmetry = function(e) {
    return this.transform(U.X_AXIS_SYMMETRY(e));
  }, a3.prototype.ySymmetry = function(e) {
    return this.transform(U.Y_AXIS_SYMMETRY(e));
  }, a3.prototype.annotateArcs = function() {
    return this.transform(U.ANNOTATE_ARCS());
  }, a3;
}();
var Ub = function(a3) {
  return a3 === " " || a3 === "	" || a3 === "\r" || a3 === `
`;
};
var To = function(a3) {
  return "0".charCodeAt(0) <= a3.charCodeAt(0) && a3.charCodeAt(0) <= "9".charCodeAt(0);
};
var Gb = function(a3) {
  function e() {
    var t = a3.call(this) || this;
    return t.curNumber = "", t.curCommandType = -1, t.curCommandRelative = false, t.canParseCommandOrComma = true, t.curNumberHasExp = false, t.curNumberHasExpDigits = false, t.curNumberHasDecimal = false, t.curArgs = [], t;
  }
  return gl(e, a3), e.prototype.finish = function(t) {
    if (t === void 0 && (t = []), this.parse(" ", t), this.curArgs.length !== 0 || !this.canParseCommandOrComma) throw new SyntaxError("Unterminated command at the path end.");
    return t;
  }, e.prototype.parse = function(t, r) {
    var i = this;
    r === void 0 && (r = []);
    for (var n = function(f) {
      r.push(f), i.curArgs.length = 0, i.canParseCommandOrComma = true;
    }, o = 0; o < t.length; o++) {
      var s = t[o], u = !(this.curCommandType !== m.ARC || this.curArgs.length !== 3 && this.curArgs.length !== 4 || this.curNumber.length !== 1 || this.curNumber !== "0" && this.curNumber !== "1"), l = To(s) && (this.curNumber === "0" && s === "0" || u);
      if (!To(s) || l) {
        if (s !== "e" && s !== "E") {
          if (s !== "-" && s !== "+" || !this.curNumberHasExp || this.curNumberHasExpDigits) {
            if (s !== "." || this.curNumberHasExp || this.curNumberHasDecimal || u) {
              if (this.curNumber && this.curCommandType !== -1) {
                var h = Number(this.curNumber);
                if (isNaN(h)) throw new SyntaxError("Invalid number ending at " + o);
                if (this.curCommandType === m.ARC) {
                  if (this.curArgs.length === 0 || this.curArgs.length === 1) {
                    if (0 > h) throw new SyntaxError('Expected positive number, got "' + h + '" at index "' + o + '"');
                  } else if ((this.curArgs.length === 3 || this.curArgs.length === 4) && this.curNumber !== "0" && this.curNumber !== "1") throw new SyntaxError('Expected a flag, got "' + this.curNumber + '" at index "' + o + '"');
                }
                this.curArgs.push(h), this.curArgs.length === zb[this.curCommandType] && (m.HORIZ_LINE_TO === this.curCommandType ? n({
                  type: m.HORIZ_LINE_TO,
                  relative: this.curCommandRelative,
                  x: h
                }) : m.VERT_LINE_TO === this.curCommandType ? n({
                  type: m.VERT_LINE_TO,
                  relative: this.curCommandRelative,
                  y: h
                }) : this.curCommandType === m.MOVE_TO || this.curCommandType === m.LINE_TO || this.curCommandType === m.SMOOTH_QUAD_TO ? (n({
                  type: this.curCommandType,
                  relative: this.curCommandRelative,
                  x: this.curArgs[0],
                  y: this.curArgs[1]
                }), m.MOVE_TO === this.curCommandType && (this.curCommandType = m.LINE_TO)) : this.curCommandType === m.CURVE_TO ? n({
                  type: m.CURVE_TO,
                  relative: this.curCommandRelative,
                  x1: this.curArgs[0],
                  y1: this.curArgs[1],
                  x2: this.curArgs[2],
                  y2: this.curArgs[3],
                  x: this.curArgs[4],
                  y: this.curArgs[5]
                }) : this.curCommandType === m.SMOOTH_CURVE_TO ? n({
                  type: m.SMOOTH_CURVE_TO,
                  relative: this.curCommandRelative,
                  x2: this.curArgs[0],
                  y2: this.curArgs[1],
                  x: this.curArgs[2],
                  y: this.curArgs[3]
                }) : this.curCommandType === m.QUAD_TO ? n({
                  type: m.QUAD_TO,
                  relative: this.curCommandRelative,
                  x1: this.curArgs[0],
                  y1: this.curArgs[1],
                  x: this.curArgs[2],
                  y: this.curArgs[3]
                }) : this.curCommandType === m.ARC && n({
                  type: m.ARC,
                  relative: this.curCommandRelative,
                  rX: this.curArgs[0],
                  rY: this.curArgs[1],
                  xRot: this.curArgs[2],
                  lArcFlag: this.curArgs[3],
                  sweepFlag: this.curArgs[4],
                  x: this.curArgs[5],
                  y: this.curArgs[6]
                })), this.curNumber = "", this.curNumberHasExpDigits = false, this.curNumberHasExp = false, this.curNumberHasDecimal = false, this.canParseCommandOrComma = true;
              }
              if (!Ub(s)) if (s === "," && this.canParseCommandOrComma) this.canParseCommandOrComma = false;
              else if (s !== "+" && s !== "-" && s !== ".") {
                if (l) this.curNumber = s, this.curNumberHasDecimal = false;
                else {
                  if (this.curArgs.length !== 0) throw new SyntaxError("Unterminated command at index " + o + ".");
                  if (!this.canParseCommandOrComma) throw new SyntaxError('Unexpected character "' + s + '" at index ' + o + ". Command cannot follow comma");
                  if (this.canParseCommandOrComma = false, s !== "z" && s !== "Z") {
                    if (s === "h" || s === "H") this.curCommandType = m.HORIZ_LINE_TO, this.curCommandRelative = s === "h";
                    else if (s === "v" || s === "V") this.curCommandType = m.VERT_LINE_TO, this.curCommandRelative = s === "v";
                    else if (s === "m" || s === "M") this.curCommandType = m.MOVE_TO, this.curCommandRelative = s === "m";
                    else if (s === "l" || s === "L") this.curCommandType = m.LINE_TO, this.curCommandRelative = s === "l";
                    else if (s === "c" || s === "C") this.curCommandType = m.CURVE_TO, this.curCommandRelative = s === "c";
                    else if (s === "s" || s === "S") this.curCommandType = m.SMOOTH_CURVE_TO, this.curCommandRelative = s === "s";
                    else if (s === "q" || s === "Q") this.curCommandType = m.QUAD_TO, this.curCommandRelative = s === "q";
                    else if (s === "t" || s === "T") this.curCommandType = m.SMOOTH_QUAD_TO, this.curCommandRelative = s === "t";
                    else {
                      if (s !== "a" && s !== "A") throw new SyntaxError('Unexpected character "' + s + '" at index ' + o + ".");
                      this.curCommandType = m.ARC, this.curCommandRelative = s === "a";
                    }
                  } else r.push({
                    type: m.CLOSE_PATH
                  }), this.canParseCommandOrComma = true, this.curCommandType = -1;
                }
              } else this.curNumber = s, this.curNumberHasDecimal = s === ".";
            } else this.curNumber += s, this.curNumberHasDecimal = true;
          } else this.curNumber += s;
        } else this.curNumber += s, this.curNumberHasExp = true;
      } else this.curNumber += s, this.curNumberHasExpDigits = this.curNumberHasExp;
    }
    return r;
  }, e.prototype.transform = function(t) {
    return Object.create(this, {
      parse: {
        value: function(r, i) {
          i === void 0 && (i = []);
          for (var n = 0, o = Object.getPrototypeOf(this).parse.call(this, r); n < o.length; n++) {
            var s = o[n], u = t(s);
            Array.isArray(u) ? i.push.apply(i, u) : i.push(u);
          }
          return i;
        }
      }
    });
  }, e;
}(dl);
var m = function(a3) {
  function e(t) {
    var r = a3.call(this) || this;
    return r.commands = typeof t == "string" ? e.parse(t) : t, r;
  }
  return gl(e, a3), e.prototype.encode = function() {
    return e.encode(this.commands);
  }, e.prototype.getBounds = function() {
    var t = U.CALCULATE_BOUNDS();
    return this.transform(t), t;
  }, e.prototype.transform = function(t) {
    for (var r = [], i = 0, n = this.commands; i < n.length; i++) {
      var o = t(n[i]);
      Array.isArray(o) ? r.push.apply(r, o) : r.push(o);
    }
    return this.commands = r, this;
  }, e.encode = function(t) {
    return Fb(t);
  }, e.parse = function(t) {
    var r = new Gb(), i = [];
    return r.parse(t, i), r.finish(i), i;
  }, e.CLOSE_PATH = 1, e.MOVE_TO = 2, e.HORIZ_LINE_TO = 4, e.VERT_LINE_TO = 8, e.LINE_TO = 16, e.CURVE_TO = 32, e.SMOOTH_CURVE_TO = 64, e.QUAD_TO = 128, e.SMOOTH_QUAD_TO = 256, e.ARC = 512, e.LINE_COMMANDS = e.LINE_TO | e.HORIZ_LINE_TO | e.VERT_LINE_TO, e.DRAWING_COMMANDS = e.HORIZ_LINE_TO | e.VERT_LINE_TO | e.LINE_TO | e.CURVE_TO | e.SMOOTH_CURVE_TO | e.QUAD_TO | e.SMOOTH_QUAD_TO | e.ARC, e;
}(dl);
var zb = ((oe = {})[m.MOVE_TO] = 2, oe[m.LINE_TO] = 2, oe[m.HORIZ_LINE_TO] = 1, oe[m.VERT_LINE_TO] = 1, oe[m.CLOSE_PATH] = 0, oe[m.QUAD_TO] = 4, oe[m.SMOOTH_QUAD_TO] = 2, oe[m.CURVE_TO] = 6, oe[m.SMOOTH_CURVE_TO] = 4, oe[m.ARC] = 7, oe);
var Hb = $r.PROPER;
var Yb = Ue;
var Xb = J;
var Oo = pe;
var Wb = D;
var qb = Ki;
var nn = "toString";
var pl = RegExp.prototype;
var yl = pl[nn];
var Qb = Wb(function() {
  return yl.call({
    source: "a",
    flags: "b"
  }) !== "/a/b";
});
var Kb = Hb && yl.name !== nn;
(Qb || Kb) && Yb(pl, nn, function() {
  var e = Xb(this), t = Oo(e.source), r = Oo(qb(e));
  return "/" + t + "/" + r;
}, {
  unsafe: true
});
function fr(a3) {
  "@babel/helpers - typeof";
  return typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? fr = function(e) {
    return typeof e;
  } : fr = function(e) {
    return e && typeof Symbol == "function" && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e;
  }, fr(a3);
}
function Zb(a3, e) {
  if (!(a3 instanceof e)) throw new TypeError("Cannot call a class as a function");
}
var Jb = [512, 512, 456, 512, 328, 456, 335, 512, 405, 328, 271, 456, 388, 335, 292, 512, 454, 405, 364, 328, 298, 271, 496, 456, 420, 388, 360, 335, 312, 292, 273, 512, 482, 454, 428, 405, 383, 364, 345, 328, 312, 298, 284, 271, 259, 496, 475, 456, 437, 420, 404, 388, 374, 360, 347, 335, 323, 312, 302, 292, 282, 273, 265, 512, 497, 482, 468, 454, 441, 428, 417, 405, 394, 383, 373, 364, 354, 345, 337, 328, 320, 312, 305, 298, 291, 284, 278, 271, 265, 259, 507, 496, 485, 475, 465, 456, 446, 437, 428, 420, 412, 404, 396, 388, 381, 374, 367, 360, 354, 347, 341, 335, 329, 323, 318, 312, 307, 302, 297, 292, 287, 282, 278, 273, 269, 265, 261, 512, 505, 497, 489, 482, 475, 468, 461, 454, 447, 441, 435, 428, 422, 417, 411, 405, 399, 394, 389, 383, 378, 373, 368, 364, 359, 354, 350, 345, 341, 337, 332, 328, 324, 320, 316, 312, 309, 305, 301, 298, 294, 291, 287, 284, 281, 278, 274, 271, 268, 265, 262, 259, 257, 507, 501, 496, 491, 485, 480, 475, 470, 465, 460, 456, 451, 446, 442, 437, 433, 428, 424, 420, 416, 412, 408, 404, 400, 396, 392, 388, 385, 381, 377, 374, 370, 367, 363, 360, 357, 354, 350, 347, 344, 341, 338, 335, 332, 329, 326, 323, 320, 318, 315, 312, 310, 307, 304, 302, 299, 297, 294, 292, 289, 287, 285, 282, 280, 278, 275, 273, 271, 269, 267, 265, 263, 261, 259];
var e1 = [9, 11, 12, 13, 13, 14, 14, 15, 15, 15, 15, 16, 16, 16, 16, 17, 17, 17, 17, 17, 17, 17, 18, 18, 18, 18, 18, 18, 18, 18, 18, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24];
function t1(a3, e, t, r, i) {
  if (typeof a3 == "string" && (a3 = document.getElementById(a3)), !a3 || fr(a3) !== "object" || !("getContext" in a3)) throw new TypeError("Expecting canvas with `getContext` method in processCanvasRGB(A) calls!");
  var n = a3.getContext("2d");
  try {
    return n.getImageData(e, t, r, i);
  } catch (o) {
    throw new Error("unable to access image data: " + o);
  }
}
function r1(a3, e, t, r, i, n) {
  if (!(isNaN(n) || n < 1)) {
    n |= 0;
    var o = t1(a3, e, t, r, i);
    o = a1(o, e, t, r, i, n), a3.getContext("2d").putImageData(o, e, t);
  }
}
function a1(a3, e, t, r, i, n) {
  for (var o = a3.data, s = 2 * n + 1, u = r - 1, l = i - 1, h = n + 1, f = h * (h + 1) / 2, c = new So(), v = c, g, d = 1; d < s; d++) v = v.next = new So(), d === h && (g = v);
  v.next = c;
  for (var p = null, y = null, x = 0, b = 0, T = Jb[n], $ = e1[n], E = 0; E < i; E++) {
    v = c;
    for (var O = o[b], C = o[b + 1], P = o[b + 2], V = o[b + 3], j = 0; j < h; j++) v.r = O, v.g = C, v.b = P, v.a = V, v = v.next;
    for (var R = 0, X = 0, W = 0, G = 0, q = h * O, H = h * C, Q = h * P, N = h * V, M = f * O, K = f * C, se = f * P, ge = f * V, Se = 1; Se < h; Se++) {
      var ze = b + ((u < Se ? u : Se) << 2), It = o[ze], un = o[ze + 1], ln = o[ze + 2], hn = o[ze + 3], Mt = h - Se;
      M += (v.r = It) * Mt, K += (v.g = un) * Mt, se += (v.b = ln) * Mt, ge += (v.a = hn) * Mt, R += It, X += un, W += ln, G += hn, v = v.next;
    }
    p = c, y = g;
    for (var jr = 0; jr < r; jr++) {
      var Fr = ge * T >>> $;
      if (o[b + 3] = Fr, Fr !== 0) {
        var Ur = 255 / Fr;
        o[b] = (M * T >>> $) * Ur, o[b + 1] = (K * T >>> $) * Ur, o[b + 2] = (se * T >>> $) * Ur;
      } else o[b] = o[b + 1] = o[b + 2] = 0;
      M -= q, K -= H, se -= Q, ge -= N, q -= p.r, H -= p.g, Q -= p.b, N -= p.a;
      var Ae = jr + n + 1;
      Ae = x + (Ae < u ? Ae : u) << 2, R += p.r = o[Ae], X += p.g = o[Ae + 1], W += p.b = o[Ae + 2], G += p.a = o[Ae + 3], M += R, K += X, se += W, ge += G, p = p.next;
      var _t = y, vn = _t.r, fn = _t.g, cn = _t.b, gn = _t.a;
      q += vn, H += fn, Q += cn, N += gn, R -= vn, X -= fn, W -= cn, G -= gn, y = y.next, b += 4;
    }
    x += r;
  }
  for (var He = 0; He < r; He++) {
    b = He << 2;
    var Pe = o[b], Re = o[b + 1], Ne = o[b + 2], te = o[b + 3], Gr = h * Pe, zr = h * Re, Hr = h * Ne, Yr = h * te, Vt = f * Pe, Dt = f * Re, Lt = f * Ne, kt = f * te;
    v = c;
    for (var dn = 0; dn < h; dn++) v.r = Pe, v.g = Re, v.b = Ne, v.a = te, v = v.next;
    for (var pn = r, Xr = 0, Wr = 0, qr = 0, Qr = 0, Bt = 1; Bt <= n; Bt++) {
      b = pn + He << 2;
      var jt = h - Bt;
      Vt += (v.r = Pe = o[b]) * jt, Dt += (v.g = Re = o[b + 1]) * jt, Lt += (v.b = Ne = o[b + 2]) * jt, kt += (v.a = te = o[b + 3]) * jt, Qr += Pe, Xr += Re, Wr += Ne, qr += te, v = v.next, Bt < l && (pn += r);
    }
    b = He, p = c, y = g;
    for (var Kr = 0; Kr < i; Kr++) {
      var re = b << 2;
      o[re + 3] = te = kt * T >>> $, te > 0 ? (te = 255 / te, o[re] = (Vt * T >>> $) * te, o[re + 1] = (Dt * T >>> $) * te, o[re + 2] = (Lt * T >>> $) * te) : o[re] = o[re + 1] = o[re + 2] = 0, Vt -= Gr, Dt -= zr, Lt -= Hr, kt -= Yr, Gr -= p.r, zr -= p.g, Hr -= p.b, Yr -= p.a, re = He + ((re = Kr + h) < l ? re : l) * r << 2, Vt += Qr += p.r = o[re], Dt += Xr += p.g = o[re + 1], Lt += Wr += p.b = o[re + 2], kt += qr += p.a = o[re + 3], p = p.next, Gr += Pe = y.r, zr += Re = y.g, Hr += Ne = y.b, Yr += te = y.a, Qr -= Pe, Xr -= Re, Wr -= Ne, qr -= te, y = y.next, b += r;
    }
  }
  return a3;
}
var So = (
  /**
   * Set properties.
   */
  function a() {
    Zb(this, a), this.r = 0, this.g = 0, this.b = 0, this.a = 0, this.next = null;
  }
);
function i1() {
  var {
    DOMParser: a3
  } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, e = {
    window: null,
    ignoreAnimation: true,
    ignoreMouse: true,
    DOMParser: a3,
    createCanvas(t, r) {
      return new OffscreenCanvas(t, r);
    },
    createImage(t) {
      return xe(function* () {
        var r = yield fetch(t), i = yield r.blob(), n = yield createImageBitmap(i);
        return n;
      })();
    }
  };
  return (typeof DOMParser < "u" || typeof a3 > "u") && Reflect.deleteProperty(e, "DOMParser"), e;
}
function n1(a3) {
  var {
    DOMParser: e,
    canvas: t,
    fetch: r
  } = a3;
  return {
    window: null,
    ignoreAnimation: true,
    ignoreMouse: true,
    DOMParser: e,
    fetch: r,
    createCanvas: t.createCanvas,
    createImage: t.loadImage
  };
}
var y2 = Object.freeze({
  __proto__: null,
  offscreen: i1,
  node: n1
});
function lt(a3) {
  return a3.replace(/(?!\u3000)\s+/gm, " ");
}
function s1(a3) {
  return a3.replace(/^[\n \t]+/, "");
}
function o1(a3) {
  return a3.replace(/[\n \t]+$/, "");
}
function ne(a3) {
  var e = (a3 || "").match(/-?(\d+(?:\.\d*(?:[eE][+-]?\d+)?)?|\.\d+)(?=\D|$)/gm) || [];
  return e.map(parseFloat);
}
var u1 = /^[A-Z-]+$/;
function l1(a3) {
  return u1.test(a3) ? a3.toLowerCase() : a3;
}
function ml(a3) {
  var e = /url\(('([^']+)'|"([^"]+)"|([^'")]+))\)/.exec(a3) || [];
  return e[2] || e[3] || e[4];
}
function h1(a3) {
  if (!a3.startsWith("rgb")) return a3;
  var e = 3, t = a3.replace(/\d+(\.\d+)?/g, (r, i) => e-- && i ? String(Math.round(parseFloat(r))) : r);
  return t;
}
var v1 = /(\[[^\]]+\])/g;
var f1 = /(#[^\s+>~.[:]+)/g;
var c1 = /(\.[^\s+>~.[:]+)/g;
var g1 = /(::[^\s+>~.[:]+|:first-line|:first-letter|:before|:after)/gi;
var d1 = /(:[\w-]+\([^)]*\))/gi;
var p1 = /(:[^\s+>~.[:]+)/g;
var y1 = /([^\s+>~.[:]+)/g;
function Ve(a3, e) {
  var t = e.exec(a3);
  return t ? [a3.replace(e, " "), t.length] : [a3, 0];
}
function m1(a3) {
  var e = [0, 0, 0], t = a3.replace(/:not\(([^)]*)\)/g, "     $1 ").replace(/{[\s\S]*/gm, " "), r = 0;
  return [t, r] = Ve(t, v1), e[1] += r, [t, r] = Ve(t, f1), e[0] += r, [t, r] = Ve(t, c1), e[1] += r, [t, r] = Ve(t, g1), e[2] += r, [t, r] = Ve(t, d1), e[1] += r, [t, r] = Ve(t, p1), e[1] += r, t = t.replace(/[*\s+>~]/g, " ").replace(/[#.]/g, " "), [t, r] = Ve(t, y1), e[2] += r, e.join("");
}
var rt = 1e-8;
function Eo(a3) {
  return Math.sqrt(Math.pow(a3[0], 2) + Math.pow(a3[1], 2));
}
function xi(a3, e) {
  return (a3[0] * e[0] + a3[1] * e[1]) / (Eo(a3) * Eo(e));
}
function $o(a3, e) {
  return (a3[0] * e[1] < a3[1] * e[0] ? -1 : 1) * Math.acos(xi(a3, e));
}
function wo(a3) {
  return a3 * a3 * a3;
}
function Co(a3) {
  return 3 * a3 * a3 * (1 - a3);
}
function Ao(a3) {
  return 3 * a3 * (1 - a3) * (1 - a3);
}
function Po(a3) {
  return (1 - a3) * (1 - a3) * (1 - a3);
}
function Ro(a3) {
  return a3 * a3;
}
function No(a3) {
  return 2 * a3 * (1 - a3);
}
function Io(a3) {
  return (1 - a3) * (1 - a3);
}
var S = class _S {
  constructor(e, t, r) {
    this.document = e, this.name = t, this.value = r, this.isNormalizedColor = false;
  }
  static empty(e) {
    return new _S(e, "EMPTY", "");
  }
  split() {
    var e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : " ", {
      document: t,
      name: r
    } = this;
    return lt(this.getString()).trim().split(e).map((i) => new _S(t, r, i));
  }
  hasValue(e) {
    var {
      value: t
    } = this;
    return t !== null && t !== "" && (e || t !== 0) && typeof t < "u";
  }
  isString(e) {
    var {
      value: t
    } = this, r = typeof t == "string";
    return !r || !e ? r : e.test(t);
  }
  isUrlDefinition() {
    return this.isString(/^url\(/);
  }
  isPixels() {
    if (!this.hasValue()) return false;
    var e = this.getString();
    switch (true) {
      case e.endsWith("px"):
      case /^[0-9]+$/.test(e):
        return true;
      default:
        return false;
    }
  }
  setValue(e) {
    return this.value = e, this;
  }
  getValue(e) {
    return typeof e > "u" || this.hasValue() ? this.value : e;
  }
  getNumber(e) {
    if (!this.hasValue()) return typeof e > "u" ? 0 : parseFloat(e);
    var {
      value: t
    } = this, r = parseFloat(t);
    return this.isString(/%$/) && (r /= 100), r;
  }
  getString(e) {
    return typeof e > "u" || this.hasValue() ? typeof this.value > "u" ? "" : String(this.value) : String(e);
  }
  getColor(e) {
    var t = this.getString(e);
    return this.isNormalizedColor || (this.isNormalizedColor = true, t = h1(t), this.value = t), t;
  }
  getDpi() {
    return 96;
  }
  getRem() {
    return this.document.rootEmSize;
  }
  getEm() {
    return this.document.emSize;
  }
  getUnits() {
    return this.getString().replace(/[0-9.-]/g, "");
  }
  getPixels(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
    if (!this.hasValue()) return 0;
    var [r, i] = typeof e == "boolean" ? [void 0, e] : [e], {
      viewPort: n
    } = this.document.screen;
    switch (true) {
      case this.isString(/vmin$/):
        return this.getNumber() / 100 * Math.min(n.computeSize("x"), n.computeSize("y"));
      case this.isString(/vmax$/):
        return this.getNumber() / 100 * Math.max(n.computeSize("x"), n.computeSize("y"));
      case this.isString(/vw$/):
        return this.getNumber() / 100 * n.computeSize("x");
      case this.isString(/vh$/):
        return this.getNumber() / 100 * n.computeSize("y");
      case this.isString(/rem$/):
        return this.getNumber() * this.getRem();
      case this.isString(/em$/):
        return this.getNumber() * this.getEm();
      case this.isString(/ex$/):
        return this.getNumber() * this.getEm() / 2;
      case this.isString(/px$/):
        return this.getNumber();
      case this.isString(/pt$/):
        return this.getNumber() * this.getDpi() * (1 / 72);
      case this.isString(/pc$/):
        return this.getNumber() * 15;
      case this.isString(/cm$/):
        return this.getNumber() * this.getDpi() / 2.54;
      case this.isString(/mm$/):
        return this.getNumber() * this.getDpi() / 25.4;
      case this.isString(/in$/):
        return this.getNumber() * this.getDpi();
      case (this.isString(/%$/) && i):
        return this.getNumber() * this.getEm();
      case this.isString(/%$/):
        return this.getNumber() * n.computeSize(r);
      default: {
        var o = this.getNumber();
        return t && o < 1 ? o * n.computeSize(r) : o;
      }
    }
  }
  getMilliseconds() {
    return this.hasValue() ? this.isString(/ms$/) ? this.getNumber() : this.getNumber() * 1e3 : 0;
  }
  getRadians() {
    if (!this.hasValue()) return 0;
    switch (true) {
      case this.isString(/deg$/):
        return this.getNumber() * (Math.PI / 180);
      case this.isString(/grad$/):
        return this.getNumber() * (Math.PI / 200);
      case this.isString(/rad$/):
        return this.getNumber();
      default:
        return this.getNumber() * (Math.PI / 180);
    }
  }
  getDefinition() {
    var e = this.getString(), t = /#([^)'"]+)/.exec(e);
    return t && (t = t[1]), t || (t = e), this.document.definitions[t];
  }
  getFillStyleDefinition(e, t) {
    var r = this.getDefinition();
    if (!r) return null;
    if (typeof r.createGradient == "function") return r.createGradient(this.document.ctx, e, t);
    if (typeof r.createPattern == "function") {
      if (r.getHrefAttribute().hasValue()) {
        var i = r.getAttribute("patternTransform");
        r = r.getHrefAttribute().getDefinition(), i.hasValue() && r.getAttribute("patternTransform", true).setValue(i.value);
      }
      return r.createPattern(this.document.ctx, e, t);
    }
    return null;
  }
  getTextBaseline() {
    return this.hasValue() ? _S.textBaselineMapping[this.getString()] : null;
  }
  addOpacity(e) {
    for (var t = this.getColor(), r = t.length, i = 0, n = 0; n < r && (t[n] === "," && i++, i !== 3); n++) ;
    if (e.hasValue() && this.isString() && i !== 3) {
      var o = new yi(t);
      o.ok && (o.alpha = e.getNumber(), t = o.toRGBA());
    }
    return new _S(this.document, this.name, t);
  }
};
S.textBaselineMapping = {
  baseline: "alphabetic",
  "before-edge": "top",
  "text-before-edge": "top",
  middle: "middle",
  central: "middle",
  "after-edge": "bottom",
  "text-after-edge": "bottom",
  ideographic: "ideographic",
  alphabetic: "alphabetic",
  hanging: "hanging",
  mathematical: "alphabetic"
};
var b1 = class {
  constructor() {
    this.viewPorts = [];
  }
  clear() {
    this.viewPorts = [];
  }
  setCurrent(e, t) {
    this.viewPorts.push({
      width: e,
      height: t
    });
  }
  removeCurrent() {
    this.viewPorts.pop();
  }
  getCurrent() {
    var {
      viewPorts: e
    } = this;
    return e[e.length - 1];
  }
  get width() {
    return this.getCurrent().width;
  }
  get height() {
    return this.getCurrent().height;
  }
  computeSize(e) {
    return typeof e == "number" ? e : e === "x" ? this.width : e === "y" ? this.height : Math.sqrt(Math.pow(this.width, 2) + Math.pow(this.height, 2)) / Math.sqrt(2);
  }
};
var k = class _k {
  constructor(e, t) {
    this.x = e, this.y = t;
  }
  static parse(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0, [r = t, i = t] = ne(e);
    return new _k(r, i);
  }
  static parseScale(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1, [r = t, i = r] = ne(e);
    return new _k(r, i);
  }
  static parsePath(e) {
    for (var t = ne(e), r = t.length, i = [], n = 0; n < r; n += 2) i.push(new _k(t[n], t[n + 1]));
    return i;
  }
  angleTo(e) {
    return Math.atan2(e.y - this.y, e.x - this.x);
  }
  applyTransform(e) {
    var {
      x: t,
      y: r
    } = this, i = t * e[0] + r * e[2] + e[4], n = t * e[1] + r * e[3] + e[5];
    this.x = i, this.y = n;
  }
};
var x1 = class {
  constructor(e) {
    this.screen = e, this.working = false, this.events = [], this.eventElements = [], this.onClick = this.onClick.bind(this), this.onMouseMove = this.onMouseMove.bind(this);
  }
  isWorking() {
    return this.working;
  }
  start() {
    if (!this.working) {
      var {
        screen: e,
        onClick: t,
        onMouseMove: r
      } = this, i = e.ctx.canvas;
      i.onclick = t, i.onmousemove = r, this.working = true;
    }
  }
  stop() {
    if (this.working) {
      var e = this.screen.ctx.canvas;
      this.working = false, e.onclick = null, e.onmousemove = null;
    }
  }
  hasEvents() {
    return this.working && this.events.length > 0;
  }
  runEvents() {
    if (this.working) {
      var {
        screen: e,
        events: t,
        eventElements: r
      } = this, {
        style: i
      } = e.ctx.canvas;
      i && (i.cursor = ""), t.forEach((n, o) => {
        for (var {
          run: s
        } = n, u = r[o]; u; ) s(u), u = u.parent;
      }), this.events = [], this.eventElements = [];
    }
  }
  checkPath(e, t) {
    if (!(!this.working || !t)) {
      var {
        events: r,
        eventElements: i
      } = this;
      r.forEach((n, o) => {
        var {
          x: s,
          y: u
        } = n;
        !i[o] && t.isPointInPath && t.isPointInPath(s, u) && (i[o] = e);
      });
    }
  }
  checkBoundingBox(e, t) {
    if (!(!this.working || !t)) {
      var {
        events: r,
        eventElements: i
      } = this;
      r.forEach((n, o) => {
        var {
          x: s,
          y: u
        } = n;
        !i[o] && t.isPointInBox(s, u) && (i[o] = e);
      });
    }
  }
  mapXY(e, t) {
    for (var {
      window: r,
      ctx: i
    } = this.screen, n = new k(e, t), o = i.canvas; o; ) n.x -= o.offsetLeft, n.y -= o.offsetTop, o = o.offsetParent;
    return r.scrollX && (n.x += r.scrollX), r.scrollY && (n.y += r.scrollY), n;
  }
  onClick(e) {
    var {
      x: t,
      y: r
    } = this.mapXY(e.clientX, e.clientY);
    this.events.push({
      type: "onclick",
      x: t,
      y: r,
      run(i) {
        i.onClick && i.onClick();
      }
    });
  }
  onMouseMove(e) {
    var {
      x: t,
      y: r
    } = this.mapXY(e.clientX, e.clientY);
    this.events.push({
      type: "onmousemove",
      x: t,
      y: r,
      run(i) {
        i.onMouseMove && i.onMouseMove();
      }
    });
  }
};
var bl = typeof window < "u" ? window : null;
var xl = typeof fetch < "u" ? fetch.bind(void 0) : null;
var Dr = class {
  constructor(e) {
    var {
      fetch: t = xl,
      window: r = bl
    } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    this.ctx = e, this.FRAMERATE = 30, this.MAX_VIRTUAL_PIXELS = 3e4, this.CLIENT_WIDTH = 800, this.CLIENT_HEIGHT = 600, this.viewPort = new b1(), this.mouse = new x1(this), this.animations = [], this.waits = [], this.frameDuration = 0, this.isReadyLock = false, this.isFirstRender = true, this.intervalId = null, this.window = r, this.fetch = t;
  }
  wait(e) {
    this.waits.push(e);
  }
  ready() {
    return this.readyPromise ? this.readyPromise : Promise.resolve();
  }
  isReady() {
    if (this.isReadyLock) return true;
    var e = this.waits.every((t) => t());
    return e && (this.waits = [], this.resolveReady && this.resolveReady()), this.isReadyLock = e, e;
  }
  setDefaults(e) {
    e.strokeStyle = "rgba(0,0,0,0)", e.lineCap = "butt", e.lineJoin = "miter", e.miterLimit = 4;
  }
  setViewBox(e) {
    var {
      document: t,
      ctx: r,
      aspectRatio: i,
      width: n,
      desiredWidth: o,
      height: s,
      desiredHeight: u,
      minX: l = 0,
      minY: h = 0,
      refX: f,
      refY: c,
      clip: v = false,
      clipX: g = 0,
      clipY: d = 0
    } = e, p = lt(i).replace(/^defer\s/, ""), [y, x] = p.split(" "), b = y || "xMidYMid", T = x || "meet", $ = n / o, E = s / u, O = Math.min($, E), C = Math.max($, E), P = o, V = u;
    T === "meet" && (P *= O, V *= O), T === "slice" && (P *= C, V *= C);
    var j = new S(t, "refX", f), R = new S(t, "refY", c), X = j.hasValue() && R.hasValue();
    if (X && r.translate(-O * j.getPixels("x"), -O * R.getPixels("y")), v) {
      var W = O * g, G = O * d;
      r.beginPath(), r.moveTo(W, G), r.lineTo(n, G), r.lineTo(n, s), r.lineTo(W, s), r.closePath(), r.clip();
    }
    if (!X) {
      var q = T === "meet" && O === E, H = T === "slice" && C === E, Q = T === "meet" && O === $, N = T === "slice" && C === $;
      b.startsWith("xMid") && (q || H) && r.translate(n / 2 - P / 2, 0), b.endsWith("YMid") && (Q || N) && r.translate(0, s / 2 - V / 2), b.startsWith("xMax") && (q || H) && r.translate(n - P, 0), b.endsWith("YMax") && (Q || N) && r.translate(0, s - V);
    }
    switch (true) {
      case b === "none":
        r.scale($, E);
        break;
      case T === "meet":
        r.scale(O, O);
        break;
      case T === "slice":
        r.scale(C, C);
        break;
    }
    r.translate(-l, -h);
  }
  start(e) {
    var {
      enableRedraw: t = false,
      ignoreMouse: r = false,
      ignoreAnimation: i = false,
      ignoreDimensions: n = false,
      ignoreClear: o = false,
      forceRedraw: s,
      scaleWidth: u,
      scaleHeight: l,
      offsetX: h,
      offsetY: f
    } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
      FRAMERATE: c,
      mouse: v
    } = this, g = 1e3 / c;
    if (this.frameDuration = g, this.readyPromise = new Promise((b) => {
      this.resolveReady = b;
    }), this.isReady() && this.render(e, n, o, u, l, h, f), !!t) {
      var d = Date.now(), p = d, y = 0, x = () => {
        d = Date.now(), y = d - p, y >= g && (p = d - y % g, this.shouldUpdate(i, s) && (this.render(e, n, o, u, l, h, f), v.runEvents())), this.intervalId = Fa(x);
      };
      r || v.start(), this.intervalId = Fa(x);
    }
  }
  stop() {
    this.intervalId && (Fa.cancel(this.intervalId), this.intervalId = null), this.mouse.stop();
  }
  shouldUpdate(e, t) {
    if (!e) {
      var {
        frameDuration: r
      } = this, i = this.animations.reduce((n, o) => o.update(r) || n, false);
      if (i) return true;
    }
    return !!(typeof t == "function" && t() || !this.isReadyLock && this.isReady() || this.mouse.hasEvents());
  }
  render(e, t, r, i, n, o, s) {
    var {
      CLIENT_WIDTH: u,
      CLIENT_HEIGHT: l,
      viewPort: h,
      ctx: f,
      isFirstRender: c
    } = this, v = f.canvas;
    h.clear(), v.width && v.height ? h.setCurrent(v.width, v.height) : h.setCurrent(u, l);
    var g = e.getStyle("width"), d = e.getStyle("height");
    !t && (c || typeof i != "number" && typeof n != "number") && (g.hasValue() && (v.width = g.getPixels("x"), v.style && (v.style.width = "".concat(v.width, "px"))), d.hasValue() && (v.height = d.getPixels("y"), v.style && (v.style.height = "".concat(v.height, "px"))));
    var p = v.clientWidth || v.width, y = v.clientHeight || v.height;
    if (t && g.hasValue() && d.hasValue() && (p = g.getPixels("x"), y = d.getPixels("y")), h.setCurrent(p, y), typeof o == "number" && e.getAttribute("x", true).setValue(o), typeof s == "number" && e.getAttribute("y", true).setValue(s), typeof i == "number" || typeof n == "number") {
      var x = ne(e.getAttribute("viewBox").getString()), b = 0, T = 0;
      if (typeof i == "number") {
        var $ = e.getStyle("width");
        $.hasValue() ? b = $.getPixels("x") / i : isNaN(x[2]) || (b = x[2] / i);
      }
      if (typeof n == "number") {
        var E = e.getStyle("height");
        E.hasValue() ? T = E.getPixels("y") / n : isNaN(x[3]) || (T = x[3] / n);
      }
      b || (b = T), T || (T = b), e.getAttribute("width", true).setValue(i), e.getAttribute("height", true).setValue(n);
      var O = e.getStyle("transform", true, true);
      O.setValue("".concat(O.getString(), " scale(").concat(1 / b, ", ").concat(1 / T, ")"));
    }
    r || f.clearRect(0, 0, p, y), e.render(f), c && (this.isFirstRender = false);
  }
};
Dr.defaultWindow = bl;
Dr.defaultFetch = xl;
var {
  defaultFetch: T1
} = Dr;
var O1 = typeof DOMParser < "u" ? DOMParser : null;
var za = class {
  constructor() {
    var {
      fetch: e = T1,
      DOMParser: t = O1
    } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    this.fetch = e, this.DOMParser = t;
  }
  parse(e) {
    var t = this;
    return xe(function* () {
      return e.startsWith("<") ? t.parseFromString(e) : t.load(e);
    })();
  }
  parseFromString(e) {
    var t = new this.DOMParser();
    try {
      return this.checkDocument(t.parseFromString(e, "image/svg+xml"));
    } catch {
      return this.checkDocument(t.parseFromString(e, "text/xml"));
    }
  }
  checkDocument(e) {
    var t = e.getElementsByTagName("parsererror")[0];
    if (t) throw new Error(t.textContent);
    return e;
  }
  load(e) {
    var t = this;
    return xe(function* () {
      var r = yield t.fetch(e), i = yield r.text();
      return t.parseFromString(i);
    })();
  }
};
var S1 = class {
  constructor(e, t) {
    this.type = "translate", this.point = null, this.point = k.parse(t);
  }
  apply(e) {
    var {
      x: t,
      y: r
    } = this.point;
    e.translate(t || 0, r || 0);
  }
  unapply(e) {
    var {
      x: t,
      y: r
    } = this.point;
    e.translate(-1 * t || 0, -1 * r || 0);
  }
  applyToPoint(e) {
    var {
      x: t,
      y: r
    } = this.point;
    e.applyTransform([1, 0, 0, 1, t || 0, r || 0]);
  }
};
var E1 = class {
  constructor(e, t, r) {
    this.type = "rotate", this.angle = null, this.originX = null, this.originY = null, this.cx = 0, this.cy = 0;
    var i = ne(t);
    this.angle = new S(e, "angle", i[0]), this.originX = r[0], this.originY = r[1], this.cx = i[1] || 0, this.cy = i[2] || 0;
  }
  apply(e) {
    var {
      cx: t,
      cy: r,
      originX: i,
      originY: n,
      angle: o
    } = this, s = t + i.getPixels("x"), u = r + n.getPixels("y");
    e.translate(s, u), e.rotate(o.getRadians()), e.translate(-s, -u);
  }
  unapply(e) {
    var {
      cx: t,
      cy: r,
      originX: i,
      originY: n,
      angle: o
    } = this, s = t + i.getPixels("x"), u = r + n.getPixels("y");
    e.translate(s, u), e.rotate(-1 * o.getRadians()), e.translate(-s, -u);
  }
  applyToPoint(e) {
    var {
      cx: t,
      cy: r,
      angle: i
    } = this, n = i.getRadians();
    e.applyTransform([
      1,
      0,
      0,
      1,
      t || 0,
      r || 0
      // this.p.y
    ]), e.applyTransform([Math.cos(n), Math.sin(n), -Math.sin(n), Math.cos(n), 0, 0]), e.applyTransform([
      1,
      0,
      0,
      1,
      -t || 0,
      -r || 0
      // -this.p.y
    ]);
  }
};
var $1 = class {
  constructor(e, t, r) {
    this.type = "scale", this.scale = null, this.originX = null, this.originY = null;
    var i = k.parseScale(t);
    (i.x === 0 || i.y === 0) && (i.x = rt, i.y = rt), this.scale = i, this.originX = r[0], this.originY = r[1];
  }
  apply(e) {
    var {
      scale: {
        x: t,
        y: r
      },
      originX: i,
      originY: n
    } = this, o = i.getPixels("x"), s = n.getPixels("y");
    e.translate(o, s), e.scale(t, r || t), e.translate(-o, -s);
  }
  unapply(e) {
    var {
      scale: {
        x: t,
        y: r
      },
      originX: i,
      originY: n
    } = this, o = i.getPixels("x"), s = n.getPixels("y");
    e.translate(o, s), e.scale(1 / t, 1 / r || t), e.translate(-o, -s);
  }
  applyToPoint(e) {
    var {
      x: t,
      y: r
    } = this.scale;
    e.applyTransform([t || 0, 0, 0, r || 0, 0, 0]);
  }
};
var Tl = class {
  constructor(e, t, r) {
    this.type = "matrix", this.matrix = [], this.originX = null, this.originY = null, this.matrix = ne(t), this.originX = r[0], this.originY = r[1];
  }
  apply(e) {
    var {
      originX: t,
      originY: r,
      matrix: i
    } = this, n = t.getPixels("x"), o = r.getPixels("y");
    e.translate(n, o), e.transform(i[0], i[1], i[2], i[3], i[4], i[5]), e.translate(-n, -o);
  }
  unapply(e) {
    var {
      originX: t,
      originY: r,
      matrix: i
    } = this, n = i[0], o = i[2], s = i[4], u = i[1], l = i[3], h = i[5], f = 0, c = 0, v = 1, g = 1 / (n * (l * v - h * c) - o * (u * v - h * f) + s * (u * c - l * f)), d = t.getPixels("x"), p = r.getPixels("y");
    e.translate(d, p), e.transform(g * (l * v - h * c), g * (h * f - u * v), g * (s * c - o * v), g * (n * v - s * f), g * (o * h - s * l), g * (s * u - n * h)), e.translate(-d, -p);
  }
  applyToPoint(e) {
    e.applyTransform(this.matrix);
  }
};
var Ol = class extends Tl {
  constructor(e, t, r) {
    super(e, t, r), this.type = "skew", this.angle = null, this.angle = new S(e, "angle", t);
  }
};
var w1 = class extends Ol {
  constructor(e, t, r) {
    super(e, t, r), this.type = "skewX", this.matrix = [1, 0, Math.tan(this.angle.getRadians()), 1, 0, 0];
  }
};
var C1 = class extends Ol {
  constructor(e, t, r) {
    super(e, t, r), this.type = "skewY", this.matrix = [1, Math.tan(this.angle.getRadians()), 0, 1, 0, 0];
  }
};
function A1(a3) {
  return lt(a3).trim().replace(/\)([a-zA-Z])/g, ") $1").replace(/\)(\s?,\s?)/g, ") ").split(/\s(?=[a-z])/);
}
function P1(a3) {
  var [e, t] = a3.split("(");
  return [e.trim(), t.trim().replace(")", "")];
}
var Be = class _Be {
  constructor(e, t, r) {
    this.document = e, this.transforms = [];
    var i = A1(t);
    i.forEach((n) => {
      if (n !== "none") {
        var [o, s] = P1(n), u = _Be.transformTypes[o];
        typeof u < "u" && this.transforms.push(new u(this.document, s, r));
      }
    });
  }
  static fromElement(e, t) {
    var r = t.getStyle("transform", false, true), [i, n = i] = t.getStyle("transform-origin", false, true).split(), o = [i, n];
    return r.hasValue() ? new _Be(e, r.getString(), o) : null;
  }
  apply(e) {
    for (var {
      transforms: t
    } = this, r = t.length, i = 0; i < r; i++) t[i].apply(e);
  }
  unapply(e) {
    for (var {
      transforms: t
    } = this, r = t.length, i = r - 1; i >= 0; i--) t[i].unapply(e);
  }
  // TODO: applyToPoint unused ... remove?
  applyToPoint(e) {
    for (var {
      transforms: t
    } = this, r = t.length, i = 0; i < r; i++) t[i].applyToPoint(e);
  }
};
Be.transformTypes = {
  translate: S1,
  rotate: E1,
  scale: $1,
  matrix: Tl,
  skewX: w1,
  skewY: C1
};
var I = class _I {
  constructor(e, t) {
    var r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
    if (this.document = e, this.node = t, this.captureTextNodes = r, this.attributes = /* @__PURE__ */ Object.create(null), this.styles = /* @__PURE__ */ Object.create(null), this.stylesSpecificity = /* @__PURE__ */ Object.create(null), this.animationFrozen = false, this.animationFrozenValue = "", this.parent = null, this.children = [], !(!t || t.nodeType !== 1)) {
      if (Array.from(t.attributes).forEach((s) => {
        var u = l1(s.nodeName);
        this.attributes[u] = new S(e, u, s.value);
      }), this.addStylesFromStyleDefinition(), this.getAttribute("style").hasValue()) {
        var i = this.getAttribute("style").getString().split(";").map((s) => s.trim());
        i.forEach((s) => {
          if (s) {
            var [u, l] = s.split(":").map((h) => h.trim());
            this.styles[u] = new S(e, u, l);
          }
        });
      }
      var {
        definitions: n
      } = e, o = this.getAttribute("id");
      o.hasValue() && (n[o.getString()] || (n[o.getString()] = this)), Array.from(t.childNodes).forEach((s) => {
        if (s.nodeType === 1) this.addChild(s);
        else if (r && (s.nodeType === 3 || s.nodeType === 4)) {
          var u = e.createTextNode(s);
          u.getText().length > 0 && this.addChild(u);
        }
      });
    }
  }
  getAttribute(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false, r = this.attributes[e];
    if (!r && t) {
      var i = new S(this.document, e, "");
      return this.attributes[e] = i, i;
    }
    return r || S.empty(this.document);
  }
  getHrefAttribute() {
    for (var e in this.attributes) if (e === "href" || e.endsWith(":href")) return this.attributes[e];
    return S.empty(this.document);
  }
  getStyle(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false, r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false, i = this.styles[e];
    if (i) return i;
    var n = this.getAttribute(e);
    if (n != null && n.hasValue()) return this.styles[e] = n, n;
    if (!r) {
      var {
        parent: o
      } = this;
      if (o) {
        var s = o.getStyle(e);
        if (s != null && s.hasValue()) return s;
      }
    }
    if (t) {
      var u = new S(this.document, e, "");
      return this.styles[e] = u, u;
    }
    return i || S.empty(this.document);
  }
  render(e) {
    if (!(this.getStyle("display").getString() === "none" || this.getStyle("visibility").getString() === "hidden")) {
      if (e.save(), this.getStyle("mask").hasValue()) {
        var t = this.getStyle("mask").getDefinition();
        t && (this.applyEffects(e), t.apply(e, this));
      } else if (this.getStyle("filter").getValue("none") !== "none") {
        var r = this.getStyle("filter").getDefinition();
        r && (this.applyEffects(e), r.apply(e, this));
      } else this.setContext(e), this.renderChildren(e), this.clearContext(e);
      e.restore();
    }
  }
  setContext(e) {
  }
  applyEffects(e) {
    var t = Be.fromElement(this.document, this);
    t && t.apply(e);
    var r = this.getStyle("clip-path", false, true);
    if (r.hasValue()) {
      var i = r.getDefinition();
      i && i.apply(e);
    }
  }
  clearContext(e) {
  }
  renderChildren(e) {
    this.children.forEach((t) => {
      t.render(e);
    });
  }
  addChild(e) {
    var t = e instanceof _I ? e : this.document.createElement(e);
    t.parent = this, _I.ignoreChildTypes.includes(t.type) || this.children.push(t);
  }
  matchesSelector(e) {
    var t, {
      node: r
    } = this;
    if (typeof r.matches == "function") return r.matches(e);
    var i = (t = r.getAttribute) === null || t === void 0 ? void 0 : t.call(r, "class");
    return !i || i === "" ? false : i.split(" ").some((n) => ".".concat(n) === e);
  }
  addStylesFromStyleDefinition() {
    var {
      styles: e,
      stylesSpecificity: t
    } = this.document;
    for (var r in e) if (!r.startsWith("@") && this.matchesSelector(r)) {
      var i = e[r], n = t[r];
      if (i) for (var o in i) {
        var s = this.stylesSpecificity[o];
        typeof s > "u" && (s = "000"), n >= s && (this.styles[o] = i[o], this.stylesSpecificity[o] = n);
      }
    }
  }
  removeStyles(e, t) {
    var r = t.reduce((i, n) => {
      var o = e.getStyle(n);
      if (!o.hasValue()) return i;
      var s = o.getString();
      return o.setValue(""), [...i, [n, s]];
    }, []);
    return r;
  }
  restoreStyles(e, t) {
    t.forEach((r) => {
      var [i, n] = r;
      e.getStyle(i, true).setValue(n);
    });
  }
  isFirstChild() {
    var e;
    return ((e = this.parent) === null || e === void 0 ? void 0 : e.children.indexOf(this)) === 0;
  }
};
I.ignoreChildTypes = ["title"];
var R1 = class extends I {
  constructor(e, t, r) {
    super(e, t, r);
  }
};
function N1(a3) {
  var e = a3.trim();
  return /^('|")/.test(e) ? e : '"'.concat(e, '"');
}
function I1(a3) {
  return typeof process > "u" ? a3 : a3.trim().split(",").map(N1).join(",");
}
function M1(a3) {
  if (!a3) return "";
  var e = a3.trim().toLowerCase();
  switch (e) {
    case "normal":
    case "italic":
    case "oblique":
    case "inherit":
    case "initial":
    case "unset":
      return e;
    default:
      return /^oblique\s+(-|)\d+deg$/.test(e) ? e : "";
  }
}
function _1(a3) {
  if (!a3) return "";
  var e = a3.trim().toLowerCase();
  switch (e) {
    case "normal":
    case "bold":
    case "lighter":
    case "bolder":
    case "inherit":
    case "initial":
    case "unset":
      return e;
    default:
      return /^[\d.]+$/.test(e) ? e : "";
  }
}
var Z = class _Z {
  constructor(e, t, r, i, n, o) {
    var s = o ? typeof o == "string" ? _Z.parse(o) : o : {};
    this.fontFamily = n || s.fontFamily, this.fontSize = i || s.fontSize, this.fontStyle = e || s.fontStyle, this.fontWeight = r || s.fontWeight, this.fontVariant = t || s.fontVariant;
  }
  static parse() {
    var e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "", t = arguments.length > 1 ? arguments[1] : void 0, r = "", i = "", n = "", o = "", s = "", u = lt(e).trim().split(" "), l = {
      fontSize: false,
      fontStyle: false,
      fontWeight: false,
      fontVariant: false
    };
    return u.forEach((h) => {
      switch (true) {
        case (!l.fontStyle && _Z.styles.includes(h)):
          h !== "inherit" && (r = h), l.fontStyle = true;
          break;
        case (!l.fontVariant && _Z.variants.includes(h)):
          h !== "inherit" && (i = h), l.fontStyle = true, l.fontVariant = true;
          break;
        case (!l.fontWeight && _Z.weights.includes(h)):
          h !== "inherit" && (n = h), l.fontStyle = true, l.fontVariant = true, l.fontWeight = true;
          break;
        case !l.fontSize:
          h !== "inherit" && ([o] = h.split("/")), l.fontStyle = true, l.fontVariant = true, l.fontWeight = true, l.fontSize = true;
          break;
        default:
          h !== "inherit" && (s += h);
      }
    }), new _Z(r, i, n, o, s, t);
  }
  toString() {
    return [
      M1(this.fontStyle),
      this.fontVariant,
      _1(this.fontWeight),
      this.fontSize,
      // Wrap fontFamily only on nodejs and only for canvas.ctx
      I1(this.fontFamily)
    ].join(" ").trim();
  }
};
Z.styles = "normal|italic|oblique|inherit";
Z.variants = "normal|small-caps|inherit";
Z.weights = "normal|bold|bolder|lighter|100|200|300|400|500|600|700|800|900|inherit";
var ce = class {
  constructor() {
    var e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : Number.NaN, t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : Number.NaN, r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : Number.NaN, i = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : Number.NaN;
    this.x1 = e, this.y1 = t, this.x2 = r, this.y2 = i, this.addPoint(e, t), this.addPoint(r, i);
  }
  get x() {
    return this.x1;
  }
  get y() {
    return this.y1;
  }
  get width() {
    return this.x2 - this.x1;
  }
  get height() {
    return this.y2 - this.y1;
  }
  addPoint(e, t) {
    typeof e < "u" && ((isNaN(this.x1) || isNaN(this.x2)) && (this.x1 = e, this.x2 = e), e < this.x1 && (this.x1 = e), e > this.x2 && (this.x2 = e)), typeof t < "u" && ((isNaN(this.y1) || isNaN(this.y2)) && (this.y1 = t, this.y2 = t), t < this.y1 && (this.y1 = t), t > this.y2 && (this.y2 = t));
  }
  addX(e) {
    this.addPoint(e, null);
  }
  addY(e) {
    this.addPoint(null, e);
  }
  addBoundingBox(e) {
    if (e) {
      var {
        x1: t,
        y1: r,
        x2: i,
        y2: n
      } = e;
      this.addPoint(t, r), this.addPoint(i, n);
    }
  }
  sumCubic(e, t, r, i, n) {
    return Math.pow(1 - e, 3) * t + 3 * Math.pow(1 - e, 2) * e * r + 3 * (1 - e) * Math.pow(e, 2) * i + Math.pow(e, 3) * n;
  }
  bezierCurveAdd(e, t, r, i, n) {
    var o = 6 * t - 12 * r + 6 * i, s = -3 * t + 9 * r - 9 * i + 3 * n, u = 3 * r - 3 * t;
    if (s === 0) {
      if (o === 0) return;
      var l = -u / o;
      0 < l && l < 1 && (e ? this.addX(this.sumCubic(l, t, r, i, n)) : this.addY(this.sumCubic(l, t, r, i, n)));
      return;
    }
    var h = Math.pow(o, 2) - 4 * u * s;
    if (!(h < 0)) {
      var f = (-o + Math.sqrt(h)) / (2 * s);
      0 < f && f < 1 && (e ? this.addX(this.sumCubic(f, t, r, i, n)) : this.addY(this.sumCubic(f, t, r, i, n)));
      var c = (-o - Math.sqrt(h)) / (2 * s);
      0 < c && c < 1 && (e ? this.addX(this.sumCubic(c, t, r, i, n)) : this.addY(this.sumCubic(c, t, r, i, n)));
    }
  }
  // from http://blog.hackers-cafe.net/2009/06/how-to-calculate-bezier-curves-bounding.html
  addBezierCurve(e, t, r, i, n, o, s, u) {
    this.addPoint(e, t), this.addPoint(s, u), this.bezierCurveAdd(true, e, r, n, s), this.bezierCurveAdd(false, t, i, o, u);
  }
  addQuadraticCurve(e, t, r, i, n, o) {
    var s = e + 0.6666666666666666 * (r - e), u = t + 2 / 3 * (i - t), l = s + 1 / 3 * (n - e), h = u + 1 / 3 * (o - t);
    this.addBezierCurve(e, t, s, l, u, h, n, o);
  }
  isPointInBox(e, t) {
    var {
      x1: r,
      y1: i,
      x2: n,
      y2: o
    } = this;
    return r <= e && e <= n && i <= t && t <= o;
  }
};
var w = class extends m {
  constructor(e) {
    super(e.replace(/([+\-.])\s+/gm, "$1").replace(/[^MmZzLlHhVvCcSsQqTtAae\d\s.,+-].*/g, "")), this.control = null, this.start = null, this.current = null, this.command = null, this.commands = this.commands, this.i = -1, this.previousCommand = null, this.points = [], this.angles = [];
  }
  reset() {
    this.i = -1, this.command = null, this.previousCommand = null, this.start = new k(0, 0), this.control = new k(0, 0), this.current = new k(0, 0), this.points = [], this.angles = [];
  }
  isEnd() {
    var {
      i: e,
      commands: t
    } = this;
    return e >= t.length - 1;
  }
  next() {
    var e = this.commands[++this.i];
    return this.previousCommand = this.command, this.command = e, e;
  }
  getPoint() {
    var e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "x", t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "y", r = new k(this.command[e], this.command[t]);
    return this.makeAbsolute(r);
  }
  getAsControlPoint(e, t) {
    var r = this.getPoint(e, t);
    return this.control = r, r;
  }
  getAsCurrentPoint(e, t) {
    var r = this.getPoint(e, t);
    return this.current = r, r;
  }
  getReflectedControlPoint() {
    var e = this.previousCommand.type;
    if (e !== m.CURVE_TO && e !== m.SMOOTH_CURVE_TO && e !== m.QUAD_TO && e !== m.SMOOTH_QUAD_TO) return this.current;
    var {
      current: {
        x: t,
        y: r
      },
      control: {
        x: i,
        y: n
      }
    } = this, o = new k(2 * t - i, 2 * r - n);
    return o;
  }
  makeAbsolute(e) {
    if (this.command.relative) {
      var {
        x: t,
        y: r
      } = this.current;
      e.x += t, e.y += r;
    }
    return e;
  }
  addMarker(e, t, r) {
    var {
      points: i,
      angles: n
    } = this;
    r && n.length > 0 && !n[n.length - 1] && (n[n.length - 1] = i[i.length - 1].angleTo(r)), this.addMarkerAngle(e, t ? t.angleTo(e) : null);
  }
  addMarkerAngle(e, t) {
    this.points.push(e), this.angles.push(t);
  }
  getMarkerPoints() {
    return this.points;
  }
  getMarkerAngles() {
    for (var {
      angles: e
    } = this, t = e.length, r = 0; r < t; r++) if (!e[r]) {
      for (var i = r + 1; i < t; i++) if (e[i]) {
        e[r] = e[i];
        break;
      }
    }
    return e;
  }
};
var Ge = class extends I {
  constructor() {
    super(...arguments), this.modifiedEmSizeStack = false;
  }
  calculateOpacity() {
    for (var e = 1, t = this; t; ) {
      var r = t.getStyle("opacity", false, true);
      r.hasValue(true) && (e *= r.getNumber()), t = t.parent;
    }
    return e;
  }
  setContext(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
    if (!t) {
      var r = this.getStyle("fill"), i = this.getStyle("fill-opacity"), n = this.getStyle("stroke"), o = this.getStyle("stroke-opacity");
      if (r.isUrlDefinition()) {
        var s = r.getFillStyleDefinition(this, i);
        s && (e.fillStyle = s);
      } else if (r.hasValue()) {
        r.getString() === "currentColor" && r.setValue(this.getStyle("color").getColor());
        var u = r.getColor();
        u !== "inherit" && (e.fillStyle = u === "none" ? "rgba(0,0,0,0)" : u);
      }
      if (i.hasValue()) {
        var l = new S(this.document, "fill", e.fillStyle).addOpacity(i).getColor();
        e.fillStyle = l;
      }
      if (n.isUrlDefinition()) {
        var h = n.getFillStyleDefinition(this, o);
        h && (e.strokeStyle = h);
      } else if (n.hasValue()) {
        n.getString() === "currentColor" && n.setValue(this.getStyle("color").getColor());
        var f = n.getString();
        f !== "inherit" && (e.strokeStyle = f === "none" ? "rgba(0,0,0,0)" : f);
      }
      if (o.hasValue()) {
        var c = new S(this.document, "stroke", e.strokeStyle).addOpacity(o).getString();
        e.strokeStyle = c;
      }
      var v = this.getStyle("stroke-width");
      if (v.hasValue()) {
        var g = v.getPixels();
        e.lineWidth = g || rt;
      }
      var d = this.getStyle("stroke-linecap"), p = this.getStyle("stroke-linejoin"), y = this.getStyle("stroke-miterlimit"), x = this.getStyle("stroke-dasharray"), b = this.getStyle("stroke-dashoffset");
      if (d.hasValue() && (e.lineCap = d.getString()), p.hasValue() && (e.lineJoin = p.getString()), y.hasValue() && (e.miterLimit = y.getNumber()), x.hasValue() && x.getString() !== "none") {
        var T = ne(x.getString());
        typeof e.setLineDash < "u" ? e.setLineDash(T) : typeof e.webkitLineDash < "u" ? e.webkitLineDash = T : typeof e.mozDash < "u" && !(T.length === 1 && T[0] === 0) && (e.mozDash = T);
        var $ = b.getPixels();
        typeof e.lineDashOffset < "u" ? e.lineDashOffset = $ : typeof e.webkitLineDashOffset < "u" ? e.webkitLineDashOffset = $ : typeof e.mozDashOffset < "u" && (e.mozDashOffset = $);
      }
    }
    if (this.modifiedEmSizeStack = false, typeof e.font < "u") {
      var E = this.getStyle("font"), O = this.getStyle("font-style"), C = this.getStyle("font-variant"), P = this.getStyle("font-weight"), V = this.getStyle("font-size"), j = this.getStyle("font-family"), R = new Z(O.getString(), C.getString(), P.getString(), V.hasValue() ? "".concat(V.getPixels(true), "px") : "", j.getString(), Z.parse(E.getString(), e.font));
      O.setValue(R.fontStyle), C.setValue(R.fontVariant), P.setValue(R.fontWeight), V.setValue(R.fontSize), j.setValue(R.fontFamily), e.font = R.toString(), V.isPixels() && (this.document.emSize = V.getPixels(), this.modifiedEmSizeStack = true);
    }
    t || (this.applyEffects(e), e.globalAlpha = this.calculateOpacity());
  }
  clearContext(e) {
    super.clearContext(e), this.modifiedEmSizeStack && this.document.popEmSize();
  }
};
var A = class _A extends Ge {
  constructor(e, t, r) {
    super(e, t, r), this.type = "path", this.pathParser = null, this.pathParser = new w(this.getAttribute("d").getString());
  }
  path(e) {
    var {
      pathParser: t
    } = this, r = new ce();
    for (t.reset(), e && e.beginPath(); !t.isEnd(); ) switch (t.next().type) {
      case w.MOVE_TO:
        this.pathM(e, r);
        break;
      case w.LINE_TO:
        this.pathL(e, r);
        break;
      case w.HORIZ_LINE_TO:
        this.pathH(e, r);
        break;
      case w.VERT_LINE_TO:
        this.pathV(e, r);
        break;
      case w.CURVE_TO:
        this.pathC(e, r);
        break;
      case w.SMOOTH_CURVE_TO:
        this.pathS(e, r);
        break;
      case w.QUAD_TO:
        this.pathQ(e, r);
        break;
      case w.SMOOTH_QUAD_TO:
        this.pathT(e, r);
        break;
      case w.ARC:
        this.pathA(e, r);
        break;
      case w.CLOSE_PATH:
        this.pathZ(e, r);
        break;
    }
    return r;
  }
  getBoundingBox(e) {
    return this.path();
  }
  getMarkers() {
    var {
      pathParser: e
    } = this, t = e.getMarkerPoints(), r = e.getMarkerAngles(), i = t.map((n, o) => [n, r[o]]);
    return i;
  }
  renderChildren(e) {
    this.path(e), this.document.screen.mouse.checkPath(this, e);
    var t = this.getStyle("fill-rule");
    e.fillStyle !== "" && (t.getString("inherit") !== "inherit" ? e.fill(t.getString()) : e.fill()), e.strokeStyle !== "" && (this.getAttribute("vector-effect").getString() === "non-scaling-stroke" ? (e.save(), e.setTransform(1, 0, 0, 1, 0, 0), e.stroke(), e.restore()) : e.stroke());
    var r = this.getMarkers();
    if (r) {
      var i = r.length - 1, n = this.getStyle("marker-start"), o = this.getStyle("marker-mid"), s = this.getStyle("marker-end");
      if (n.isUrlDefinition()) {
        var u = n.getDefinition(), [l, h] = r[0];
        u.render(e, l, h);
      }
      if (o.isUrlDefinition()) for (var f = o.getDefinition(), c = 1; c < i; c++) {
        var [v, g] = r[c];
        f.render(e, v, g);
      }
      if (s.isUrlDefinition()) {
        var d = s.getDefinition(), [p, y] = r[i];
        d.render(e, p, y);
      }
    }
  }
  static pathM(e) {
    var t = e.getAsCurrentPoint();
    return e.start = e.current, {
      point: t
    };
  }
  pathM(e, t) {
    var {
      pathParser: r
    } = this, {
      point: i
    } = _A.pathM(r), {
      x: n,
      y: o
    } = i;
    r.addMarker(i), t.addPoint(n, o), e && e.moveTo(n, o);
  }
  static pathL(e) {
    var {
      current: t
    } = e, r = e.getAsCurrentPoint();
    return {
      current: t,
      point: r
    };
  }
  pathL(e, t) {
    var {
      pathParser: r
    } = this, {
      current: i,
      point: n
    } = _A.pathL(r), {
      x: o,
      y: s
    } = n;
    r.addMarker(n, i), t.addPoint(o, s), e && e.lineTo(o, s);
  }
  static pathH(e) {
    var {
      current: t,
      command: r
    } = e, i = new k((r.relative ? t.x : 0) + r.x, t.y);
    return e.current = i, {
      current: t,
      point: i
    };
  }
  pathH(e, t) {
    var {
      pathParser: r
    } = this, {
      current: i,
      point: n
    } = _A.pathH(r), {
      x: o,
      y: s
    } = n;
    r.addMarker(n, i), t.addPoint(o, s), e && e.lineTo(o, s);
  }
  static pathV(e) {
    var {
      current: t,
      command: r
    } = e, i = new k(t.x, (r.relative ? t.y : 0) + r.y);
    return e.current = i, {
      current: t,
      point: i
    };
  }
  pathV(e, t) {
    var {
      pathParser: r
    } = this, {
      current: i,
      point: n
    } = _A.pathV(r), {
      x: o,
      y: s
    } = n;
    r.addMarker(n, i), t.addPoint(o, s), e && e.lineTo(o, s);
  }
  static pathC(e) {
    var {
      current: t
    } = e, r = e.getPoint("x1", "y1"), i = e.getAsControlPoint("x2", "y2"), n = e.getAsCurrentPoint();
    return {
      current: t,
      point: r,
      controlPoint: i,
      currentPoint: n
    };
  }
  pathC(e, t) {
    var {
      pathParser: r
    } = this, {
      current: i,
      point: n,
      controlPoint: o,
      currentPoint: s
    } = _A.pathC(r);
    r.addMarker(s, o, n), t.addBezierCurve(i.x, i.y, n.x, n.y, o.x, o.y, s.x, s.y), e && e.bezierCurveTo(n.x, n.y, o.x, o.y, s.x, s.y);
  }
  static pathS(e) {
    var {
      current: t
    } = e, r = e.getReflectedControlPoint(), i = e.getAsControlPoint("x2", "y2"), n = e.getAsCurrentPoint();
    return {
      current: t,
      point: r,
      controlPoint: i,
      currentPoint: n
    };
  }
  pathS(e, t) {
    var {
      pathParser: r
    } = this, {
      current: i,
      point: n,
      controlPoint: o,
      currentPoint: s
    } = _A.pathS(r);
    r.addMarker(s, o, n), t.addBezierCurve(i.x, i.y, n.x, n.y, o.x, o.y, s.x, s.y), e && e.bezierCurveTo(n.x, n.y, o.x, o.y, s.x, s.y);
  }
  static pathQ(e) {
    var {
      current: t
    } = e, r = e.getAsControlPoint("x1", "y1"), i = e.getAsCurrentPoint();
    return {
      current: t,
      controlPoint: r,
      currentPoint: i
    };
  }
  pathQ(e, t) {
    var {
      pathParser: r
    } = this, {
      current: i,
      controlPoint: n,
      currentPoint: o
    } = _A.pathQ(r);
    r.addMarker(o, n, n), t.addQuadraticCurve(i.x, i.y, n.x, n.y, o.x, o.y), e && e.quadraticCurveTo(n.x, n.y, o.x, o.y);
  }
  static pathT(e) {
    var {
      current: t
    } = e, r = e.getReflectedControlPoint();
    e.control = r;
    var i = e.getAsCurrentPoint();
    return {
      current: t,
      controlPoint: r,
      currentPoint: i
    };
  }
  pathT(e, t) {
    var {
      pathParser: r
    } = this, {
      current: i,
      controlPoint: n,
      currentPoint: o
    } = _A.pathT(r);
    r.addMarker(o, n, n), t.addQuadraticCurve(i.x, i.y, n.x, n.y, o.x, o.y), e && e.quadraticCurveTo(n.x, n.y, o.x, o.y);
  }
  static pathA(e) {
    var {
      current: t,
      command: r
    } = e, {
      rX: i,
      rY: n,
      xRot: o,
      lArcFlag: s,
      sweepFlag: u
    } = r, l = o * (Math.PI / 180), h = e.getAsCurrentPoint(), f = new k(Math.cos(l) * (t.x - h.x) / 2 + Math.sin(l) * (t.y - h.y) / 2, -Math.sin(l) * (t.x - h.x) / 2 + Math.cos(l) * (t.y - h.y) / 2), c = Math.pow(f.x, 2) / Math.pow(i, 2) + Math.pow(f.y, 2) / Math.pow(n, 2);
    c > 1 && (i *= Math.sqrt(c), n *= Math.sqrt(c));
    var v = (s === u ? -1 : 1) * Math.sqrt((Math.pow(i, 2) * Math.pow(n, 2) - Math.pow(i, 2) * Math.pow(f.y, 2) - Math.pow(n, 2) * Math.pow(f.x, 2)) / (Math.pow(i, 2) * Math.pow(f.y, 2) + Math.pow(n, 2) * Math.pow(f.x, 2)));
    isNaN(v) && (v = 0);
    var g = new k(v * i * f.y / n, v * -n * f.x / i), d = new k((t.x + h.x) / 2 + Math.cos(l) * g.x - Math.sin(l) * g.y, (t.y + h.y) / 2 + Math.sin(l) * g.x + Math.cos(l) * g.y), p = $o([1, 0], [(f.x - g.x) / i, (f.y - g.y) / n]), y = [(f.x - g.x) / i, (f.y - g.y) / n], x = [(-f.x - g.x) / i, (-f.y - g.y) / n], b = $o(y, x);
    return xi(y, x) <= -1 && (b = Math.PI), xi(y, x) >= 1 && (b = 0), {
      currentPoint: h,
      rX: i,
      rY: n,
      sweepFlag: u,
      xAxisRotation: l,
      centp: d,
      a1: p,
      ad: b
    };
  }
  pathA(e, t) {
    var {
      pathParser: r
    } = this, {
      currentPoint: i,
      rX: n,
      rY: o,
      sweepFlag: s,
      xAxisRotation: u,
      centp: l,
      a1: h,
      ad: f
    } = _A.pathA(r), c = 1 - s ? 1 : -1, v = h + c * (f / 2), g = new k(l.x + n * Math.cos(v), l.y + o * Math.sin(v));
    if (r.addMarkerAngle(g, v - c * Math.PI / 2), r.addMarkerAngle(i, v - c * Math.PI), t.addPoint(i.x, i.y), e && !isNaN(h) && !isNaN(f)) {
      var d = n > o ? n : o, p = n > o ? 1 : n / o, y = n > o ? o / n : 1;
      e.translate(l.x, l.y), e.rotate(u), e.scale(p, y), e.arc(0, 0, d, h, h + f, !!(1 - s)), e.scale(1 / p, 1 / y), e.rotate(-u), e.translate(-l.x, -l.y);
    }
  }
  static pathZ(e) {
    e.current = e.start;
  }
  pathZ(e, t) {
    _A.pathZ(this.pathParser), e && t.x1 !== t.x2 && t.y1 !== t.y2 && e.closePath();
  }
};
var Sl = class extends A {
  constructor(e, t, r) {
    super(e, t, r), this.type = "glyph", this.horizAdvX = this.getAttribute("horiz-adv-x").getNumber(), this.unicode = this.getAttribute("unicode").getString(), this.arabicForm = this.getAttribute("arabic-form").getString();
  }
};
var Ce = class _Ce extends Ge {
  constructor(e, t, r) {
    super(e, t, new.target === _Ce ? true : r), this.type = "text", this.x = 0, this.y = 0, this.measureCache = -1;
  }
  setContext(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
    super.setContext(e, t);
    var r = this.getStyle("dominant-baseline").getTextBaseline() || this.getStyle("alignment-baseline").getTextBaseline();
    r && (e.textBaseline = r);
  }
  initializeCoordinates() {
    this.x = 0, this.y = 0, this.leafTexts = [], this.textChunkStart = 0, this.minX = Number.POSITIVE_INFINITY, this.maxX = Number.NEGATIVE_INFINITY;
  }
  getBoundingBox(e) {
    if (this.type !== "text") return this.getTElementBoundingBox(e);
    this.initializeCoordinates(), this.adjustChildCoordinatesRecursive(e);
    var t = null;
    return this.children.forEach((r, i) => {
      var n = this.getChildBoundingBox(e, this, this, i);
      t ? t.addBoundingBox(n) : t = n;
    }), t;
  }
  getFontSize() {
    var {
      document: e,
      parent: t
    } = this, r = Z.parse(e.ctx.font).fontSize, i = t.getStyle("font-size").getNumber(r);
    return i;
  }
  getTElementBoundingBox(e) {
    var t = this.getFontSize();
    return new ce(this.x, this.y - t, this.x + this.measureText(e), this.y);
  }
  getGlyph(e, t, r) {
    var i = t[r], n = null;
    if (e.isArabic) {
      var o = t.length, s = t[r - 1], u = t[r + 1], l = "isolated";
      if ((r === 0 || s === " ") && r < o - 1 && u !== " " && (l = "terminal"), r > 0 && s !== " " && r < o - 1 && u !== " " && (l = "medial"), r > 0 && s !== " " && (r === o - 1 || u === " ") && (l = "initial"), typeof e.glyphs[i] < "u") {
        var h = e.glyphs[i];
        n = h instanceof Sl ? h : h[l];
      }
    } else n = e.glyphs[i];
    return n || (n = e.missingGlyph), n;
  }
  getText() {
    return "";
  }
  getTextFromNode(e) {
    var t = e || this.node, r = Array.from(t.parentNode.childNodes), i = r.indexOf(t), n = r.length - 1, o = lt(
      // textNode.value
      // || textNode.text
      t.textContent || ""
    );
    return i === 0 && (o = s1(o)), i === n && (o = o1(o)), o;
  }
  renderChildren(e) {
    if (this.type !== "text") {
      this.renderTElementChildren(e);
      return;
    }
    this.initializeCoordinates(), this.adjustChildCoordinatesRecursive(e), this.children.forEach((r, i) => {
      this.renderChild(e, this, this, i);
    });
    var {
      mouse: t
    } = this.document.screen;
    t.isWorking() && t.checkBoundingBox(this, this.getBoundingBox(e));
  }
  renderTElementChildren(e) {
    var {
      document: t,
      parent: r
    } = this, i = this.getText(), n = r.getStyle("font-family").getDefinition();
    if (n) {
      for (var {
        unitsPerEm: o
      } = n.fontFace, s = Z.parse(t.ctx.font), u = r.getStyle("font-size").getNumber(s.fontSize), l = r.getStyle("font-style").getString(s.fontStyle), h = u / o, f = n.isRTL ? i.split("").reverse().join("") : i, c = ne(r.getAttribute("dx").getString()), v = f.length, g = 0; g < v; g++) {
        var d = this.getGlyph(n, f, g);
        e.translate(this.x, this.y), e.scale(h, -h);
        var p = e.lineWidth;
        e.lineWidth = e.lineWidth * o / u, l === "italic" && e.transform(1, 0, 0.4, 1, 0, 0), d.render(e), l === "italic" && e.transform(1, 0, -0.4, 1, 0, 0), e.lineWidth = p, e.scale(1 / h, -1 / h), e.translate(-this.x, -this.y), this.x += u * (d.horizAdvX || n.horizAdvX) / o, typeof c[g] < "u" && !isNaN(c[g]) && (this.x += c[g]);
      }
      return;
    }
    var {
      x: y,
      y: x
    } = this;
    e.fillStyle && e.fillText(i, y, x), e.strokeStyle && e.strokeText(i, y, x);
  }
  applyAnchoring() {
    if (!(this.textChunkStart >= this.leafTexts.length)) {
      var e = this.leafTexts[this.textChunkStart], t = e.getStyle("text-anchor").getString("start"), r = false, i = 0;
      t === "start" && !r || t === "end" && r ? i = e.x - this.minX : t === "end" && !r || t === "start" && r ? i = e.x - this.maxX : i = e.x - (this.minX + this.maxX) / 2;
      for (var n = this.textChunkStart; n < this.leafTexts.length; n++) this.leafTexts[n].x += i;
      this.minX = Number.POSITIVE_INFINITY, this.maxX = Number.NEGATIVE_INFINITY, this.textChunkStart = this.leafTexts.length;
    }
  }
  adjustChildCoordinatesRecursive(e) {
    this.children.forEach((t, r) => {
      this.adjustChildCoordinatesRecursiveCore(e, this, this, r);
    }), this.applyAnchoring();
  }
  adjustChildCoordinatesRecursiveCore(e, t, r, i) {
    var n = r.children[i];
    n.children.length > 0 ? n.children.forEach((o, s) => {
      t.adjustChildCoordinatesRecursiveCore(e, t, n, s);
    }) : this.adjustChildCoordinates(e, t, r, i);
  }
  adjustChildCoordinates(e, t, r, i) {
    var n = r.children[i];
    if (typeof n.measureText != "function") return n;
    e.save(), n.setContext(e, true);
    var o = n.getAttribute("x"), s = n.getAttribute("y"), u = n.getAttribute("dx"), l = n.getAttribute("dy"), h = n.getStyle("font-family").getDefinition(), f = !!h && h.isRTL;
    i === 0 && (o.hasValue() || o.setValue(n.getInheritedAttribute("x")), s.hasValue() || s.setValue(n.getInheritedAttribute("y")), u.hasValue() || u.setValue(n.getInheritedAttribute("dx")), l.hasValue() || l.setValue(n.getInheritedAttribute("dy")));
    var c = n.measureText(e);
    return f && (t.x -= c), o.hasValue() ? (t.applyAnchoring(), n.x = o.getPixels("x"), u.hasValue() && (n.x += u.getPixels("x"))) : (u.hasValue() && (t.x += u.getPixels("x")), n.x = t.x), t.x = n.x, f || (t.x += c), s.hasValue() ? (n.y = s.getPixels("y"), l.hasValue() && (n.y += l.getPixels("y"))) : (l.hasValue() && (t.y += l.getPixels("y")), n.y = t.y), t.y = n.y, t.leafTexts.push(n), t.minX = Math.min(t.minX, n.x, n.x + c), t.maxX = Math.max(t.maxX, n.x, n.x + c), n.clearContext(e), e.restore(), n;
  }
  getChildBoundingBox(e, t, r, i) {
    var n = r.children[i];
    if (typeof n.getBoundingBox != "function") return null;
    var o = n.getBoundingBox(e);
    return o ? (n.children.forEach((s, u) => {
      var l = t.getChildBoundingBox(e, t, n, u);
      o.addBoundingBox(l);
    }), o) : null;
  }
  renderChild(e, t, r, i) {
    var n = r.children[i];
    n.render(e), n.children.forEach((o, s) => {
      t.renderChild(e, t, n, s);
    });
  }
  measureText(e) {
    var {
      measureCache: t
    } = this;
    if (~t) return t;
    var r = this.getText(), i = this.measureTargetText(e, r);
    return this.measureCache = i, i;
  }
  measureTargetText(e, t) {
    if (!t.length) return 0;
    var {
      parent: r
    } = this, i = r.getStyle("font-family").getDefinition();
    if (i) {
      for (var n = this.getFontSize(), o = i.isRTL ? t.split("").reverse().join("") : t, s = ne(r.getAttribute("dx").getString()), u = o.length, l = 0, h = 0; h < u; h++) {
        var f = this.getGlyph(i, o, h);
        l += (f.horizAdvX || i.horizAdvX) * n / i.fontFace.unitsPerEm, typeof s[h] < "u" && !isNaN(s[h]) && (l += s[h]);
      }
      return l;
    }
    if (!e.measureText) return t.length * 10;
    e.save(), this.setContext(e, true);
    var {
      width: c
    } = e.measureText(t);
    return this.clearContext(e), e.restore(), c;
  }
  /**
   * Inherits positional attributes from {@link TextElement} parent(s). Attributes
   * are only inherited from a parent to its first child.
   * @param name - The attribute name.
   * @returns The attribute value or null.
   */
  getInheritedAttribute(e) {
    for (var t = this; t instanceof _Ce && t.isFirstChild(); ) {
      var r = t.parent.getAttribute(e);
      if (r.hasValue(true)) return r.getValue("0");
      t = t.parent;
    }
    return null;
  }
};
var Lr = class _Lr extends Ce {
  constructor(e, t, r) {
    super(e, t, new.target === _Lr ? true : r), this.type = "tspan", this.text = this.children.length > 0 ? "" : this.getTextFromNode();
  }
  getText() {
    return this.text;
  }
};
var V1 = class extends Lr {
  constructor() {
    super(...arguments), this.type = "textNode";
  }
};
var Nt = class extends Ge {
  constructor() {
    super(...arguments), this.type = "svg", this.root = false;
  }
  setContext(e) {
    var t, {
      document: r
    } = this, {
      screen: i,
      window: n
    } = r, o = e.canvas;
    if (i.setDefaults(e), o.style && typeof e.font < "u" && n && typeof n.getComputedStyle < "u") {
      e.font = n.getComputedStyle(o).getPropertyValue("font");
      var s = new S(r, "fontSize", Z.parse(e.font).fontSize);
      s.hasValue() && (r.rootEmSize = s.getPixels("y"), r.emSize = r.rootEmSize);
    }
    this.getAttribute("x").hasValue() || this.getAttribute("x", true).setValue(0), this.getAttribute("y").hasValue() || this.getAttribute("y", true).setValue(0);
    var {
      width: u,
      height: l
    } = i.viewPort;
    this.getStyle("width").hasValue() || this.getStyle("width", true).setValue("100%"), this.getStyle("height").hasValue() || this.getStyle("height", true).setValue("100%"), this.getStyle("color").hasValue() || this.getStyle("color", true).setValue("black");
    var h = this.getAttribute("refX"), f = this.getAttribute("refY"), c = this.getAttribute("viewBox"), v = c.hasValue() ? ne(c.getString()) : null, g = !this.root && this.getStyle("overflow").getValue("hidden") !== "visible", d = 0, p = 0, y = 0, x = 0;
    v && (d = v[0], p = v[1]), this.root || (u = this.getStyle("width").getPixels("x"), l = this.getStyle("height").getPixels("y"), this.type === "marker" && (y = d, x = p, d = 0, p = 0)), i.viewPort.setCurrent(u, l), this.node && (!this.parent || ((t = this.node.parentNode) === null || t === void 0 ? void 0 : t.nodeName) === "foreignObject") && this.getStyle("transform", false, true).hasValue() && !this.getStyle("transform-origin", false, true).hasValue() && this.getStyle("transform-origin", true, true).setValue("50% 50%"), super.setContext(e), e.translate(this.getAttribute("x").getPixels("x"), this.getAttribute("y").getPixels("y")), v && (u = v[2], l = v[3]), r.setViewBox({
      ctx: e,
      aspectRatio: this.getAttribute("preserveAspectRatio").getString(),
      width: i.viewPort.width,
      desiredWidth: u,
      height: i.viewPort.height,
      desiredHeight: l,
      minX: d,
      minY: p,
      refX: h.getValue(),
      refY: f.getValue(),
      clip: g,
      clipX: y,
      clipY: x
    }), v && (i.viewPort.removeCurrent(), i.viewPort.setCurrent(u, l));
  }
  clearContext(e) {
    super.clearContext(e), this.document.screen.viewPort.removeCurrent();
  }
  /**
   * Resize SVG to fit in given size.
   * @param width
   * @param height
   * @param preserveAspectRatio
   */
  resize(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : e, r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false, i = this.getAttribute("width", true), n = this.getAttribute("height", true), o = this.getAttribute("viewBox"), s = this.getAttribute("style"), u = i.getNumber(0), l = n.getNumber(0);
    if (r) if (typeof r == "string") this.getAttribute("preserveAspectRatio", true).setValue(r);
    else {
      var h = this.getAttribute("preserveAspectRatio");
      h.hasValue() && h.setValue(h.getString().replace(/^\s*(\S.*\S)\s*$/, "$1"));
    }
    if (i.setValue(e), n.setValue(t), o.hasValue() || o.setValue("0 0 ".concat(u || e, " ").concat(l || t)), s.hasValue()) {
      var f = this.getStyle("width"), c = this.getStyle("height");
      f.hasValue() && f.setValue("".concat(e, "px")), c.hasValue() && c.setValue("".concat(t, "px"));
    }
  }
};
var El = class extends A {
  constructor() {
    super(...arguments), this.type = "rect";
  }
  path(e) {
    var t = this.getAttribute("x").getPixels("x"), r = this.getAttribute("y").getPixels("y"), i = this.getStyle("width", false, true).getPixels("x"), n = this.getStyle("height", false, true).getPixels("y"), o = this.getAttribute("rx"), s = this.getAttribute("ry"), u = o.getPixels("x"), l = s.getPixels("y");
    if (o.hasValue() && !s.hasValue() && (l = u), s.hasValue() && !o.hasValue() && (u = l), u = Math.min(u, i / 2), l = Math.min(l, n / 2), e) {
      var h = 4 * ((Math.sqrt(2) - 1) / 3);
      e.beginPath(), n > 0 && i > 0 && (e.moveTo(t + u, r), e.lineTo(t + i - u, r), e.bezierCurveTo(t + i - u + h * u, r, t + i, r + l - h * l, t + i, r + l), e.lineTo(t + i, r + n - l), e.bezierCurveTo(t + i, r + n - l + h * l, t + i - u + h * u, r + n, t + i - u, r + n), e.lineTo(t + u, r + n), e.bezierCurveTo(t + u - h * u, r + n, t, r + n - l + h * l, t, r + n - l), e.lineTo(t, r + l), e.bezierCurveTo(t, r + l - h * l, t + u - h * u, r, t + u, r), e.closePath());
    }
    return new ce(t, r, t + i, r + n);
  }
  getMarkers() {
    return null;
  }
};
var D1 = class extends A {
  constructor() {
    super(...arguments), this.type = "circle";
  }
  path(e) {
    var t = this.getAttribute("cx").getPixels("x"), r = this.getAttribute("cy").getPixels("y"), i = this.getAttribute("r").getPixels();
    return e && i > 0 && (e.beginPath(), e.arc(t, r, i, 0, Math.PI * 2, false), e.closePath()), new ce(t - i, r - i, t + i, r + i);
  }
  getMarkers() {
    return null;
  }
};
var L1 = class extends A {
  constructor() {
    super(...arguments), this.type = "ellipse";
  }
  path(e) {
    var t = 4 * ((Math.sqrt(2) - 1) / 3), r = this.getAttribute("rx").getPixels("x"), i = this.getAttribute("ry").getPixels("y"), n = this.getAttribute("cx").getPixels("x"), o = this.getAttribute("cy").getPixels("y");
    return e && r > 0 && i > 0 && (e.beginPath(), e.moveTo(n + r, o), e.bezierCurveTo(n + r, o + t * i, n + t * r, o + i, n, o + i), e.bezierCurveTo(n - t * r, o + i, n - r, o + t * i, n - r, o), e.bezierCurveTo(n - r, o - t * i, n - t * r, o - i, n, o - i), e.bezierCurveTo(n + t * r, o - i, n + r, o - t * i, n + r, o), e.closePath()), new ce(n - r, o - i, n + r, o + i);
  }
  getMarkers() {
    return null;
  }
};
var k1 = class extends A {
  constructor() {
    super(...arguments), this.type = "line";
  }
  getPoints() {
    return [new k(this.getAttribute("x1").getPixels("x"), this.getAttribute("y1").getPixels("y")), new k(this.getAttribute("x2").getPixels("x"), this.getAttribute("y2").getPixels("y"))];
  }
  path(e) {
    var [{
      x: t,
      y: r
    }, {
      x: i,
      y: n
    }] = this.getPoints();
    return e && (e.beginPath(), e.moveTo(t, r), e.lineTo(i, n)), new ce(t, r, i, n);
  }
  getMarkers() {
    var [e, t] = this.getPoints(), r = e.angleTo(t);
    return [[e, r], [t, r]];
  }
};
var $l = class extends A {
  constructor(e, t, r) {
    super(e, t, r), this.type = "polyline", this.points = [], this.points = k.parsePath(this.getAttribute("points").getString());
  }
  path(e) {
    var {
      points: t
    } = this, [{
      x: r,
      y: i
    }] = t, n = new ce(r, i);
    return e && (e.beginPath(), e.moveTo(r, i)), t.forEach((o) => {
      var {
        x: s,
        y: u
      } = o;
      n.addPoint(s, u), e && e.lineTo(s, u);
    }), n;
  }
  getMarkers() {
    var {
      points: e
    } = this, t = e.length - 1, r = [];
    return e.forEach((i, n) => {
      n !== t && r.push([i, i.angleTo(e[n + 1])]);
    }), r.length > 0 && r.push([e[e.length - 1], r[r.length - 1][1]]), r;
  }
};
var B1 = class extends $l {
  constructor() {
    super(...arguments), this.type = "polygon";
  }
  path(e) {
    var t = super.path(e), [{
      x: r,
      y: i
    }] = this.points;
    return e && (e.lineTo(r, i), e.closePath()), t;
  }
};
var j1 = class extends I {
  constructor() {
    super(...arguments), this.type = "pattern";
  }
  createPattern(e, t, r) {
    var i = this.getStyle("width").getPixels("x", true), n = this.getStyle("height").getPixels("y", true), o = new Nt(this.document, null);
    o.attributes.viewBox = new S(this.document, "viewBox", this.getAttribute("viewBox").getValue()), o.attributes.width = new S(this.document, "width", "".concat(i, "px")), o.attributes.height = new S(this.document, "height", "".concat(n, "px")), o.attributes.transform = new S(this.document, "transform", this.getAttribute("patternTransform").getValue()), o.children = this.children;
    var s = this.document.createCanvas(i, n), u = s.getContext("2d"), l = this.getAttribute("x"), h = this.getAttribute("y");
    l.hasValue() && h.hasValue() && u.translate(l.getPixels("x", true), h.getPixels("y", true)), r.hasValue() ? this.styles["fill-opacity"] = r : Reflect.deleteProperty(this.styles, "fill-opacity");
    for (var f = -1; f <= 1; f++) for (var c = -1; c <= 1; c++) u.save(), o.attributes.x = new S(this.document, "x", f * s.width), o.attributes.y = new S(this.document, "y", c * s.height), o.render(u), u.restore();
    var v = e.createPattern(s, "repeat");
    return v;
  }
};
var F1 = class extends I {
  constructor() {
    super(...arguments), this.type = "marker";
  }
  render(e, t, r) {
    if (t) {
      var {
        x: i,
        y: n
      } = t, o = this.getAttribute("orient").getString("auto"), s = this.getAttribute("markerUnits").getString("strokeWidth");
      e.translate(i, n), o === "auto" && e.rotate(r), s === "strokeWidth" && e.scale(e.lineWidth, e.lineWidth), e.save();
      var u = new Nt(this.document, null);
      u.type = this.type, u.attributes.viewBox = new S(this.document, "viewBox", this.getAttribute("viewBox").getValue()), u.attributes.refX = new S(this.document, "refX", this.getAttribute("refX").getValue()), u.attributes.refY = new S(this.document, "refY", this.getAttribute("refY").getValue()), u.attributes.width = new S(this.document, "width", this.getAttribute("markerWidth").getValue()), u.attributes.height = new S(this.document, "height", this.getAttribute("markerHeight").getValue()), u.attributes.overflow = new S(this.document, "overflow", this.getAttribute("overflow").getValue()), u.attributes.fill = new S(this.document, "fill", this.getAttribute("fill").getColor("black")), u.attributes.stroke = new S(this.document, "stroke", this.getAttribute("stroke").getValue("none")), u.children = this.children, u.render(e), e.restore(), s === "strokeWidth" && e.scale(1 / e.lineWidth, 1 / e.lineWidth), o === "auto" && e.rotate(-r), e.translate(-i, -n);
    }
  }
};
var U1 = class extends I {
  constructor() {
    super(...arguments), this.type = "defs";
  }
  render() {
  }
};
var sn = class extends Ge {
  constructor() {
    super(...arguments), this.type = "g";
  }
  getBoundingBox(e) {
    var t = new ce();
    return this.children.forEach((r) => {
      t.addBoundingBox(r.getBoundingBox(e));
    }), t;
  }
};
var wl = class extends I {
  constructor(e, t, r) {
    super(e, t, r), this.attributesToInherit = ["gradientUnits"], this.stops = [];
    var {
      stops: i,
      children: n
    } = this;
    n.forEach((o) => {
      o.type === "stop" && i.push(o);
    });
  }
  getGradientUnits() {
    return this.getAttribute("gradientUnits").getString("objectBoundingBox");
  }
  createGradient(e, t, r) {
    var i = this;
    this.getHrefAttribute().hasValue() && (i = this.getHrefAttribute().getDefinition(), this.inheritStopContainer(i));
    var {
      stops: n
    } = i, o = this.getGradient(e, t);
    if (!o) return this.addParentOpacity(r, n[n.length - 1].color);
    if (n.forEach((p) => {
      o.addColorStop(p.offset, this.addParentOpacity(r, p.color));
    }), this.getAttribute("gradientTransform").hasValue()) {
      var {
        document: s
      } = this, {
        MAX_VIRTUAL_PIXELS: u,
        viewPort: l
      } = s.screen, [h] = l.viewPorts, f = new El(s, null);
      f.attributes.x = new S(s, "x", -u / 3), f.attributes.y = new S(s, "y", -u / 3), f.attributes.width = new S(s, "width", u), f.attributes.height = new S(s, "height", u);
      var c = new sn(s, null);
      c.attributes.transform = new S(s, "transform", this.getAttribute("gradientTransform").getValue()), c.children = [f];
      var v = new Nt(s, null);
      v.attributes.x = new S(s, "x", 0), v.attributes.y = new S(s, "y", 0), v.attributes.width = new S(s, "width", h.width), v.attributes.height = new S(s, "height", h.height), v.children = [c];
      var g = s.createCanvas(h.width, h.height), d = g.getContext("2d");
      return d.fillStyle = o, v.render(d), d.createPattern(g, "no-repeat");
    }
    return o;
  }
  inheritStopContainer(e) {
    this.attributesToInherit.forEach((t) => {
      !this.getAttribute(t).hasValue() && e.getAttribute(t).hasValue() && this.getAttribute(t, true).setValue(e.getAttribute(t).getValue());
    });
  }
  addParentOpacity(e, t) {
    if (e.hasValue()) {
      var r = new S(this.document, "color", t);
      return r.addOpacity(e).getColor();
    }
    return t;
  }
};
var G1 = class extends wl {
  constructor(e, t, r) {
    super(e, t, r), this.type = "linearGradient", this.attributesToInherit.push("x1", "y1", "x2", "y2");
  }
  getGradient(e, t) {
    var r = this.getGradientUnits() === "objectBoundingBox", i = r ? t.getBoundingBox(e) : null;
    if (r && !i) return null;
    !this.getAttribute("x1").hasValue() && !this.getAttribute("y1").hasValue() && !this.getAttribute("x2").hasValue() && !this.getAttribute("y2").hasValue() && (this.getAttribute("x1", true).setValue(0), this.getAttribute("y1", true).setValue(0), this.getAttribute("x2", true).setValue(1), this.getAttribute("y2", true).setValue(0));
    var n = r ? i.x + i.width * this.getAttribute("x1").getNumber() : this.getAttribute("x1").getPixels("x"), o = r ? i.y + i.height * this.getAttribute("y1").getNumber() : this.getAttribute("y1").getPixels("y"), s = r ? i.x + i.width * this.getAttribute("x2").getNumber() : this.getAttribute("x2").getPixels("x"), u = r ? i.y + i.height * this.getAttribute("y2").getNumber() : this.getAttribute("y2").getPixels("y");
    return n === s && o === u ? null : e.createLinearGradient(n, o, s, u);
  }
};
var z1 = class extends wl {
  constructor(e, t, r) {
    super(e, t, r), this.type = "radialGradient", this.attributesToInherit.push("cx", "cy", "r", "fx", "fy", "fr");
  }
  getGradient(e, t) {
    var r = this.getGradientUnits() === "objectBoundingBox", i = t.getBoundingBox(e);
    if (r && !i) return null;
    this.getAttribute("cx").hasValue() || this.getAttribute("cx", true).setValue("50%"), this.getAttribute("cy").hasValue() || this.getAttribute("cy", true).setValue("50%"), this.getAttribute("r").hasValue() || this.getAttribute("r", true).setValue("50%");
    var n = r ? i.x + i.width * this.getAttribute("cx").getNumber() : this.getAttribute("cx").getPixels("x"), o = r ? i.y + i.height * this.getAttribute("cy").getNumber() : this.getAttribute("cy").getPixels("y"), s = n, u = o;
    this.getAttribute("fx").hasValue() && (s = r ? i.x + i.width * this.getAttribute("fx").getNumber() : this.getAttribute("fx").getPixels("x")), this.getAttribute("fy").hasValue() && (u = r ? i.y + i.height * this.getAttribute("fy").getNumber() : this.getAttribute("fy").getPixels("y"));
    var l = r ? (i.width + i.height) / 2 * this.getAttribute("r").getNumber() : this.getAttribute("r").getPixels(), h = this.getAttribute("fr").getPixels();
    return e.createRadialGradient(s, u, h, n, o, l);
  }
};
var H1 = class extends I {
  constructor(e, t, r) {
    super(e, t, r), this.type = "stop";
    var i = Math.max(0, Math.min(1, this.getAttribute("offset").getNumber())), n = this.getStyle("stop-opacity"), o = this.getStyle("stop-color", true);
    o.getString() === "" && o.setValue("#000"), n.hasValue() && (o = o.addOpacity(n)), this.offset = i, this.color = o.getColor();
  }
};
var on = class extends I {
  constructor(e, t, r) {
    super(e, t, r), this.type = "animate", this.duration = 0, this.initialValue = null, this.initialUnits = "", this.removed = false, this.frozen = false, e.screen.animations.push(this), this.begin = this.getAttribute("begin").getMilliseconds(), this.maxDuration = this.begin + this.getAttribute("dur").getMilliseconds(), this.from = this.getAttribute("from"), this.to = this.getAttribute("to"), this.values = new S(e, "values", null);
    var i = this.getAttribute("values");
    i.hasValue() && this.values.setValue(i.getString().split(";"));
  }
  getProperty() {
    var e = this.getAttribute("attributeType").getString(), t = this.getAttribute("attributeName").getString();
    return e === "CSS" ? this.parent.getStyle(t, true) : this.parent.getAttribute(t, true);
  }
  calcValue() {
    var {
      initialUnits: e
    } = this, {
      progress: t,
      from: r,
      to: i
    } = this.getProgress(), n = r.getNumber() + (i.getNumber() - r.getNumber()) * t;
    return e === "%" && (n *= 100), "".concat(n).concat(e);
  }
  update(e) {
    var {
      parent: t
    } = this, r = this.getProperty();
    if (this.initialValue || (this.initialValue = r.getString(), this.initialUnits = r.getUnits()), this.duration > this.maxDuration) {
      var i = this.getAttribute("fill").getString("remove");
      if (this.getAttribute("repeatCount").getString() === "indefinite" || this.getAttribute("repeatDur").getString() === "indefinite") this.duration = 0;
      else if (i === "freeze" && !this.frozen) this.frozen = true, t.animationFrozen = true, t.animationFrozenValue = r.getString();
      else if (i === "remove" && !this.removed) return this.removed = true, r.setValue(t.animationFrozen ? t.animationFrozenValue : this.initialValue), true;
      return false;
    }
    this.duration += e;
    var n = false;
    if (this.begin < this.duration) {
      var o = this.calcValue(), s = this.getAttribute("type");
      if (s.hasValue()) {
        var u = s.getString();
        o = "".concat(u, "(").concat(o, ")");
      }
      r.setValue(o), n = true;
    }
    return n;
  }
  getProgress() {
    var {
      document: e,
      values: t
    } = this, r = {
      progress: (this.duration - this.begin) / (this.maxDuration - this.begin)
    };
    if (t.hasValue()) {
      var i = r.progress * (t.getValue().length - 1), n = Math.floor(i), o = Math.ceil(i);
      r.from = new S(e, "from", parseFloat(t.getValue()[n])), r.to = new S(e, "to", parseFloat(t.getValue()[o])), r.progress = (i - n) / (o - n);
    } else r.from = this.from, r.to = this.to;
    return r;
  }
};
var Y1 = class extends on {
  constructor() {
    super(...arguments), this.type = "animateColor";
  }
  calcValue() {
    var {
      progress: e,
      from: t,
      to: r
    } = this.getProgress(), i = new yi(t.getColor()), n = new yi(r.getColor());
    if (i.ok && n.ok) {
      var o = i.r + (n.r - i.r) * e, s = i.g + (n.g - i.g) * e, u = i.b + (n.b - i.b) * e;
      return "rgb(".concat(Math.floor(o), ", ").concat(Math.floor(s), ", ").concat(Math.floor(u), ")");
    }
    return this.getAttribute("from").getColor();
  }
};
var X1 = class extends on {
  constructor() {
    super(...arguments), this.type = "animateTransform";
  }
  calcValue() {
    var {
      progress: e,
      from: t,
      to: r
    } = this.getProgress(), i = ne(t.getString()), n = ne(r.getString()), o = i.map((s, u) => {
      var l = n[u];
      return s + (l - s) * e;
    }).join(" ");
    return o;
  }
};
var W1 = class extends I {
  constructor(e, t, r) {
    super(e, t, r), this.type = "font", this.glyphs = /* @__PURE__ */ Object.create(null), this.horizAdvX = this.getAttribute("horiz-adv-x").getNumber();
    var {
      definitions: i
    } = e, {
      children: n
    } = this;
    for (var o of n) switch (o.type) {
      case "font-face": {
        this.fontFace = o;
        var s = o.getStyle("font-family");
        s.hasValue() && (i[s.getString()] = this);
        break;
      }
      case "missing-glyph":
        this.missingGlyph = o;
        break;
      case "glyph": {
        var u = o;
        u.arabicForm ? (this.isRTL = true, this.isArabic = true, typeof this.glyphs[u.unicode] > "u" && (this.glyphs[u.unicode] = /* @__PURE__ */ Object.create(null)), this.glyphs[u.unicode][u.arabicForm] = u) : this.glyphs[u.unicode] = u;
        break;
      }
    }
  }
  render() {
  }
};
var q1 = class extends I {
  constructor(e, t, r) {
    super(e, t, r), this.type = "font-face", this.ascent = this.getAttribute("ascent").getNumber(), this.descent = this.getAttribute("descent").getNumber(), this.unitsPerEm = this.getAttribute("units-per-em").getNumber();
  }
};
var Q1 = class extends A {
  constructor() {
    super(...arguments), this.type = "missing-glyph", this.horizAdvX = 0;
  }
};
var K1 = class extends Ce {
  constructor() {
    super(...arguments), this.type = "tref";
  }
  getText() {
    var e = this.getHrefAttribute().getDefinition();
    if (e) {
      var t = e.children[0];
      if (t) return t.getText();
    }
    return "";
  }
};
var Z1 = class extends Ce {
  constructor(e, t, r) {
    super(e, t, r), this.type = "a";
    var {
      childNodes: i
    } = t, n = i[0], o = i.length > 0 && Array.from(i).every((s) => s.nodeType === 3);
    this.hasText = o, this.text = o ? this.getTextFromNode(n) : "";
  }
  getText() {
    return this.text;
  }
  renderChildren(e) {
    if (this.hasText) {
      super.renderChildren(e);
      var {
        document: t,
        x: r,
        y: i
      } = this, {
        mouse: n
      } = t.screen, o = new S(t, "fontSize", Z.parse(t.ctx.font).fontSize);
      n.isWorking() && n.checkBoundingBox(this, new ce(r, i - o.getPixels("y"), r + this.measureText(e), i));
    } else if (this.children.length > 0) {
      var s = new sn(this.document, null);
      s.children = this.children, s.parent = this, s.render(e);
    }
  }
  onClick() {
    var {
      window: e
    } = this.document;
    e && e.open(this.getHrefAttribute().getString());
  }
  onMouseMove() {
    var e = this.document.ctx;
    e.canvas.style.cursor = "pointer";
  }
};
function Mo(a3, e) {
  var t = Object.keys(a3);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(a3);
    e && (r = r.filter(function(i) {
      return Object.getOwnPropertyDescriptor(a3, i).enumerable;
    })), t.push.apply(t, r);
  }
  return t;
}
function ir(a3) {
  for (var e = 1; e < arguments.length; e++) {
    var t = arguments[e] != null ? arguments[e] : {};
    e % 2 ? Mo(Object(t), true).forEach(function(r) {
      an(a3, r, t[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(a3, Object.getOwnPropertyDescriptors(t)) : Mo(Object(t)).forEach(function(r) {
      Object.defineProperty(a3, r, Object.getOwnPropertyDescriptor(t, r));
    });
  }
  return a3;
}
var J1 = class extends Ce {
  constructor(e, t, r) {
    super(e, t, r), this.type = "textPath", this.textWidth = 0, this.textHeight = 0, this.pathLength = -1, this.glyphInfo = null, this.letterSpacingCache = [], this.measuresCache = /* @__PURE__ */ new Map([["", 0]]);
    var i = this.getHrefAttribute().getDefinition();
    this.text = this.getTextFromNode(), this.dataArray = this.parsePathData(i);
  }
  getText() {
    return this.text;
  }
  path(e) {
    var {
      dataArray: t
    } = this;
    e && e.beginPath(), t.forEach((r) => {
      var {
        type: i,
        points: n
      } = r;
      switch (i) {
        case w.LINE_TO:
          e && e.lineTo(n[0], n[1]);
          break;
        case w.MOVE_TO:
          e && e.moveTo(n[0], n[1]);
          break;
        case w.CURVE_TO:
          e && e.bezierCurveTo(n[0], n[1], n[2], n[3], n[4], n[5]);
          break;
        case w.QUAD_TO:
          e && e.quadraticCurveTo(n[0], n[1], n[2], n[3]);
          break;
        case w.ARC: {
          var [o, s, u, l, h, f, c, v] = n, g = u > l ? u : l, d = u > l ? 1 : u / l, p = u > l ? l / u : 1;
          e && (e.translate(o, s), e.rotate(c), e.scale(d, p), e.arc(0, 0, g, h, h + f, !!(1 - v)), e.scale(1 / d, 1 / p), e.rotate(-c), e.translate(-o, -s));
          break;
        }
        case w.CLOSE_PATH:
          e && e.closePath();
          break;
      }
    });
  }
  renderChildren(e) {
    this.setTextData(e), e.save();
    var t = this.parent.getStyle("text-decoration").getString(), r = this.getFontSize(), {
      glyphInfo: i
    } = this, n = e.fillStyle;
    t === "underline" && e.beginPath(), i.forEach((o, s) => {
      var {
        p0: u,
        p1: l,
        rotation: h,
        text: f
      } = o;
      e.save(), e.translate(u.x, u.y), e.rotate(h), e.fillStyle && e.fillText(f, 0, 0), e.strokeStyle && e.strokeText(f, 0, 0), e.restore(), t === "underline" && (s === 0 && e.moveTo(u.x, u.y + r / 8), e.lineTo(l.x, l.y + r / 5));
    }), t === "underline" && (e.lineWidth = r / 20, e.strokeStyle = n, e.stroke(), e.closePath()), e.restore();
  }
  getLetterSpacingAt() {
    var e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
    return this.letterSpacingCache[e] || 0;
  }
  findSegmentToFitChar(e, t, r, i, n, o, s, u, l) {
    var h = o, f = this.measureText(e, u);
    u === " " && t === "justify" && r < i && (f += (i - r) / n), l > -1 && (h += this.getLetterSpacingAt(l));
    var c = this.textHeight / 20, v = this.getEquidistantPointOnPath(h, c, 0), g = this.getEquidistantPointOnPath(h + f, c, 0), d = {
      p0: v,
      p1: g
    }, p = v && g ? Math.atan2(g.y - v.y, g.x - v.x) : 0;
    if (s) {
      var y = Math.cos(Math.PI / 2 + p) * s, x = Math.cos(-p) * s;
      d.p0 = ir(ir({}, v), {}, {
        x: v.x + y,
        y: v.y + x
      }), d.p1 = ir(ir({}, g), {}, {
        x: g.x + y,
        y: g.y + x
      });
    }
    return h += f, {
      offset: h,
      segment: d,
      rotation: p
    };
  }
  measureText(e, t) {
    var {
      measuresCache: r
    } = this, i = t || this.getText();
    if (r.has(i)) return r.get(i);
    var n = this.measureTargetText(e, i);
    return r.set(i, n), n;
  }
  // This method supposes what all custom fonts already loaded.
  // If some font will be loaded after this method call, <textPath> will not be rendered correctly.
  // You need to call this method manually to update glyphs cache.
  setTextData(e) {
    if (!this.glyphInfo) {
      var t = this.getText(), r = t.split(""), i = t.split(" ").length - 1, n = this.parent.getAttribute("dx").split().map((T) => T.getPixels("x")), o = this.parent.getAttribute("dy").getPixels("y"), s = this.parent.getStyle("text-anchor").getString("start"), u = this.getStyle("letter-spacing"), l = this.parent.getStyle("letter-spacing"), h = 0;
      !u.hasValue() || u.getValue() === "inherit" ? h = l.getPixels() : u.hasValue() && u.getValue() !== "initial" && u.getValue() !== "unset" && (h = u.getPixels());
      var f = [], c = t.length;
      this.letterSpacingCache = f;
      for (var v = 0; v < c; v++) f.push(typeof n[v] < "u" ? n[v] : h);
      var g = f.reduce((T, $, E) => E === 0 ? 0 : T + $ || 0, 0), d = this.measureText(e), p = Math.max(d + g, 0);
      this.textWidth = d, this.textHeight = this.getFontSize(), this.glyphInfo = [];
      var y = this.getPathLength(), x = this.getStyle("startOffset").getNumber(0) * y, b = 0;
      (s === "middle" || s === "center") && (b = -p / 2), (s === "end" || s === "right") && (b = -p), b += x, r.forEach((T, $) => {
        var {
          offset: E,
          segment: O,
          rotation: C
        } = this.findSegmentToFitChar(e, s, p, y, i, b, o, T, $);
        b = E, !(!O.p0 || !O.p1) && this.glyphInfo.push({
          // transposeX: midpoint.x,
          // transposeY: midpoint.y,
          text: r[$],
          p0: O.p0,
          p1: O.p1,
          rotation: C
        });
      });
    }
  }
  parsePathData(e) {
    if (this.pathLength = -1, !e) return [];
    var t = [], {
      pathParser: r
    } = e;
    for (r.reset(); !r.isEnd(); ) {
      var {
        current: i
      } = r, n = i ? i.x : 0, o = i ? i.y : 0, s = r.next(), u = s.type, l = [];
      switch (s.type) {
        case w.MOVE_TO:
          this.pathM(r, l);
          break;
        case w.LINE_TO:
          u = this.pathL(r, l);
          break;
        case w.HORIZ_LINE_TO:
          u = this.pathH(r, l);
          break;
        case w.VERT_LINE_TO:
          u = this.pathV(r, l);
          break;
        case w.CURVE_TO:
          this.pathC(r, l);
          break;
        case w.SMOOTH_CURVE_TO:
          u = this.pathS(r, l);
          break;
        case w.QUAD_TO:
          this.pathQ(r, l);
          break;
        case w.SMOOTH_QUAD_TO:
          u = this.pathT(r, l);
          break;
        case w.ARC:
          l = this.pathA(r);
          break;
        case w.CLOSE_PATH:
          A.pathZ(r);
          break;
      }
      s.type !== w.CLOSE_PATH ? t.push({
        type: u,
        points: l,
        start: {
          x: n,
          y: o
        },
        pathLength: this.calcLength(n, o, u, l)
      }) : t.push({
        type: w.CLOSE_PATH,
        points: [],
        pathLength: 0
      });
    }
    return t;
  }
  pathM(e, t) {
    var {
      x: r,
      y: i
    } = A.pathM(e).point;
    t.push(r, i);
  }
  pathL(e, t) {
    var {
      x: r,
      y: i
    } = A.pathL(e).point;
    return t.push(r, i), w.LINE_TO;
  }
  pathH(e, t) {
    var {
      x: r,
      y: i
    } = A.pathH(e).point;
    return t.push(r, i), w.LINE_TO;
  }
  pathV(e, t) {
    var {
      x: r,
      y: i
    } = A.pathV(e).point;
    return t.push(r, i), w.LINE_TO;
  }
  pathC(e, t) {
    var {
      point: r,
      controlPoint: i,
      currentPoint: n
    } = A.pathC(e);
    t.push(r.x, r.y, i.x, i.y, n.x, n.y);
  }
  pathS(e, t) {
    var {
      point: r,
      controlPoint: i,
      currentPoint: n
    } = A.pathS(e);
    return t.push(r.x, r.y, i.x, i.y, n.x, n.y), w.CURVE_TO;
  }
  pathQ(e, t) {
    var {
      controlPoint: r,
      currentPoint: i
    } = A.pathQ(e);
    t.push(r.x, r.y, i.x, i.y);
  }
  pathT(e, t) {
    var {
      controlPoint: r,
      currentPoint: i
    } = A.pathT(e);
    return t.push(r.x, r.y, i.x, i.y), w.QUAD_TO;
  }
  pathA(e) {
    var {
      rX: t,
      rY: r,
      sweepFlag: i,
      xAxisRotation: n,
      centp: o,
      a1: s,
      ad: u
    } = A.pathA(e);
    return i === 0 && u > 0 && (u -= 2 * Math.PI), i === 1 && u < 0 && (u += 2 * Math.PI), [o.x, o.y, t, r, s, u, n, i];
  }
  calcLength(e, t, r, i) {
    var n = 0, o = null, s = null, u = 0;
    switch (r) {
      case w.LINE_TO:
        return this.getLineLength(e, t, i[0], i[1]);
      case w.CURVE_TO:
        for (n = 0, o = this.getPointOnCubicBezier(0, e, t, i[0], i[1], i[2], i[3], i[4], i[5]), u = 0.01; u <= 1; u += 0.01) s = this.getPointOnCubicBezier(u, e, t, i[0], i[1], i[2], i[3], i[4], i[5]), n += this.getLineLength(o.x, o.y, s.x, s.y), o = s;
        return n;
      case w.QUAD_TO:
        for (n = 0, o = this.getPointOnQuadraticBezier(0, e, t, i[0], i[1], i[2], i[3]), u = 0.01; u <= 1; u += 0.01) s = this.getPointOnQuadraticBezier(u, e, t, i[0], i[1], i[2], i[3]), n += this.getLineLength(o.x, o.y, s.x, s.y), o = s;
        return n;
      case w.ARC: {
        n = 0;
        var l = i[4], h = i[5], f = i[4] + h, c = Math.PI / 180;
        if (Math.abs(l - f) < c && (c = Math.abs(l - f)), o = this.getPointOnEllipticalArc(i[0], i[1], i[2], i[3], l, 0), h < 0) for (u = l - c; u > f; u -= c) s = this.getPointOnEllipticalArc(i[0], i[1], i[2], i[3], u, 0), n += this.getLineLength(o.x, o.y, s.x, s.y), o = s;
        else for (u = l + c; u < f; u += c) s = this.getPointOnEllipticalArc(i[0], i[1], i[2], i[3], u, 0), n += this.getLineLength(o.x, o.y, s.x, s.y), o = s;
        return s = this.getPointOnEllipticalArc(i[0], i[1], i[2], i[3], f, 0), n += this.getLineLength(o.x, o.y, s.x, s.y), n;
      }
    }
    return 0;
  }
  getPointOnLine(e, t, r, i, n) {
    var o = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : t, s = arguments.length > 6 && arguments[6] !== void 0 ? arguments[6] : r, u = (n - r) / (i - t + rt), l = Math.sqrt(e * e / (1 + u * u));
    i < t && (l *= -1);
    var h = u * l, f = null;
    if (i === t) f = {
      x: o,
      y: s + h
    };
    else if ((s - r) / (o - t + rt) === u) f = {
      x: o + l,
      y: s + h
    };
    else {
      var c = 0, v = 0, g = this.getLineLength(t, r, i, n);
      if (g < rt) return null;
      var d = (o - t) * (i - t) + (s - r) * (n - r);
      d /= g * g, c = t + d * (i - t), v = r + d * (n - r);
      var p = this.getLineLength(o, s, c, v), y = Math.sqrt(e * e - p * p);
      l = Math.sqrt(y * y / (1 + u * u)), i < t && (l *= -1), h = u * l, f = {
        x: c + l,
        y: v + h
      };
    }
    return f;
  }
  getPointOnPath(e) {
    var t = this.getPathLength(), r = 0, i = null;
    if (e < -5e-5 || e - 5e-5 > t) return null;
    var {
      dataArray: n
    } = this;
    for (var o of n) {
      if (o && (o.pathLength < 5e-5 || r + o.pathLength + 5e-5 < e)) {
        r += o.pathLength;
        continue;
      }
      var s = e - r, u = 0;
      switch (o.type) {
        case w.LINE_TO:
          i = this.getPointOnLine(s, o.start.x, o.start.y, o.points[0], o.points[1], o.start.x, o.start.y);
          break;
        case w.ARC: {
          var l = o.points[4], h = o.points[5], f = o.points[4] + h;
          if (u = l + s / o.pathLength * h, h < 0 && u < f || h >= 0 && u > f) break;
          i = this.getPointOnEllipticalArc(o.points[0], o.points[1], o.points[2], o.points[3], u, o.points[6]);
          break;
        }
        case w.CURVE_TO:
          u = s / o.pathLength, u > 1 && (u = 1), i = this.getPointOnCubicBezier(u, o.start.x, o.start.y, o.points[0], o.points[1], o.points[2], o.points[3], o.points[4], o.points[5]);
          break;
        case w.QUAD_TO:
          u = s / o.pathLength, u > 1 && (u = 1), i = this.getPointOnQuadraticBezier(u, o.start.x, o.start.y, o.points[0], o.points[1], o.points[2], o.points[3]);
          break;
      }
      if (i) return i;
      break;
    }
    return null;
  }
  getLineLength(e, t, r, i) {
    return Math.sqrt((r - e) * (r - e) + (i - t) * (i - t));
  }
  getPathLength() {
    return this.pathLength === -1 && (this.pathLength = this.dataArray.reduce((e, t) => t.pathLength > 0 ? e + t.pathLength : e, 0)), this.pathLength;
  }
  getPointOnCubicBezier(e, t, r, i, n, o, s, u, l) {
    var h = u * wo(e) + o * Co(e) + i * Ao(e) + t * Po(e), f = l * wo(e) + s * Co(e) + n * Ao(e) + r * Po(e);
    return {
      x: h,
      y: f
    };
  }
  getPointOnQuadraticBezier(e, t, r, i, n, o, s) {
    var u = o * Ro(e) + i * No(e) + t * Io(e), l = s * Ro(e) + n * No(e) + r * Io(e);
    return {
      x: u,
      y: l
    };
  }
  getPointOnEllipticalArc(e, t, r, i, n, o) {
    var s = Math.cos(o), u = Math.sin(o), l = {
      x: r * Math.cos(n),
      y: i * Math.sin(n)
    };
    return {
      x: e + (l.x * s - l.y * u),
      y: t + (l.x * u + l.y * s)
    };
  }
  // TODO need some optimisations. possibly build cache only for curved segments?
  buildEquidistantCache(e, t) {
    var r = this.getPathLength(), i = t || 0.25, n = e || r / 100;
    if (!this.equidistantCache || this.equidistantCache.step !== n || this.equidistantCache.precision !== i) {
      this.equidistantCache = {
        step: n,
        precision: i,
        points: []
      };
      for (var o = 0, s = 0; s <= r; s += i) {
        var u = this.getPointOnPath(s), l = this.getPointOnPath(s + i);
        !u || !l || (o += this.getLineLength(u.x, u.y, l.x, l.y), o >= n && (this.equidistantCache.points.push({
          x: u.x,
          y: u.y,
          distance: s
        }), o -= n));
      }
    }
  }
  getEquidistantPointOnPath(e, t, r) {
    if (this.buildEquidistantCache(t, r), e < 0 || e - this.getPathLength() > 5e-5) return null;
    var i = Math.round(e / this.getPathLength() * (this.equidistantCache.points.length - 1));
    return this.equidistantCache.points[i] || null;
  }
};
var e2 = /^\s*data:(([^/,;]+\/[^/,;]+)(?:;([^,;=]+=[^,;=]+))?)?(?:;(base64))?,(.*)$/i;
var t2 = class extends Ge {
  constructor(e, t, r) {
    super(e, t, r), this.type = "image", this.loaded = false;
    var i = this.getHrefAttribute().getString();
    if (i) {
      var n = i.endsWith(".svg") || /^\s*data:image\/svg\+xml/i.test(i);
      e.images.push(this), n ? this.loadSvg(i) : this.loadImage(i), this.isSvg = n;
    }
  }
  loadImage(e) {
    var t = this;
    return xe(function* () {
      try {
        var r = yield t.document.createImage(e);
        t.image = r;
      } catch (i) {
        console.error('Error while loading image "'.concat(e, '":'), i);
      }
      t.loaded = true;
    })();
  }
  loadSvg(e) {
    var t = this;
    return xe(function* () {
      var r = e2.exec(e);
      if (r) {
        var i = r[5];
        r[4] === "base64" ? t.image = atob(i) : t.image = decodeURIComponent(i);
      } else try {
        var n = yield t.document.fetch(e), o = yield n.text();
        t.image = o;
      } catch (s) {
        console.error('Error while loading image "'.concat(e, '":'), s);
      }
      t.loaded = true;
    })();
  }
  renderChildren(e) {
    var {
      document: t,
      image: r,
      loaded: i
    } = this, n = this.getAttribute("x").getPixels("x"), o = this.getAttribute("y").getPixels("y"), s = this.getStyle("width").getPixels("x"), u = this.getStyle("height").getPixels("y");
    if (!(!i || !r || !s || !u)) {
      if (e.save(), e.translate(n, o), this.isSvg) {
        var l = t.canvg.forkString(e, this.image, {
          ignoreMouse: true,
          ignoreAnimation: true,
          ignoreDimensions: true,
          ignoreClear: true,
          offsetX: 0,
          offsetY: 0,
          scaleWidth: s,
          scaleHeight: u
        });
        l.document.documentElement.parent = this, l.render();
      } else {
        var h = this.image;
        t.setViewBox({
          ctx: e,
          aspectRatio: this.getAttribute("preserveAspectRatio").getString(),
          width: s,
          desiredWidth: h.width,
          height: u,
          desiredHeight: h.height
        }), this.loaded && (typeof h.complete > "u" || h.complete) && e.drawImage(h, 0, 0);
      }
      e.restore();
    }
  }
  getBoundingBox() {
    var e = this.getAttribute("x").getPixels("x"), t = this.getAttribute("y").getPixels("y"), r = this.getStyle("width").getPixels("x"), i = this.getStyle("height").getPixels("y");
    return new ce(e, t, e + r, t + i);
  }
};
var r2 = class extends Ge {
  constructor() {
    super(...arguments), this.type = "symbol";
  }
  render(e) {
  }
};
var a2 = class {
  constructor(e) {
    this.document = e, this.loaded = false, e.fonts.push(this);
  }
  load(e, t) {
    var r = this;
    return xe(function* () {
      try {
        var {
          document: i
        } = r, n = yield i.canvg.parser.load(t), o = n.getElementsByTagName("font");
        Array.from(o).forEach((s) => {
          var u = i.createElement(s);
          i.definitions[e] = u;
        });
      } catch (s) {
        console.error('Error while loading font "'.concat(t, '":'), s);
      }
      r.loaded = true;
    })();
  }
};
var Cl = class extends I {
  constructor(e, t, r) {
    super(e, t, r), this.type = "style";
    var i = lt(
      Array.from(t.childNodes).map((o) => o.textContent).join("").replace(/(\/\*([^*]|[\r\n]|(\*+([^*/]|[\r\n])))*\*+\/)|(^[\s]*\/\/.*)/gm, "").replace(/@import.*;/g, "")
      // remove imports
    ), n = i.split("}");
    n.forEach((o) => {
      var s = o.trim();
      if (s) {
        var u = s.split("{"), l = u[0].split(","), h = u[1].split(";");
        l.forEach((f) => {
          var c = f.trim();
          if (c) {
            var v = e.styles[c] || {};
            if (h.forEach((p) => {
              var y = p.indexOf(":"), x = p.substr(0, y).trim(), b = p.substr(y + 1, p.length - y).trim();
              x && b && (v[x] = new S(e, x, b));
            }), e.styles[c] = v, e.stylesSpecificity[c] = m1(c), c === "@font-face") {
              var g = v["font-family"].getString().replace(/"|'/g, ""), d = v.src.getString().split(",");
              d.forEach((p) => {
                if (p.indexOf('format("svg")') > 0) {
                  var y = ml(p);
                  y && new a2(e).load(g, y);
                }
              });
            }
          }
        });
      }
    });
  }
};
Cl.parseExternalUrl = ml;
var i2 = class extends Ge {
  constructor() {
    super(...arguments), this.type = "use";
  }
  setContext(e) {
    super.setContext(e);
    var t = this.getAttribute("x"), r = this.getAttribute("y");
    t.hasValue() && e.translate(t.getPixels("x"), 0), r.hasValue() && e.translate(0, r.getPixels("y"));
  }
  path(e) {
    var {
      element: t
    } = this;
    t && t.path(e);
  }
  renderChildren(e) {
    var {
      document: t,
      element: r
    } = this;
    if (r) {
      var i = r;
      if (r.type === "symbol" && (i = new Nt(t, null), i.attributes.viewBox = new S(t, "viewBox", r.getAttribute("viewBox").getString()), i.attributes.preserveAspectRatio = new S(t, "preserveAspectRatio", r.getAttribute("preserveAspectRatio").getString()), i.attributes.overflow = new S(t, "overflow", r.getAttribute("overflow").getString()), i.children = r.children, r.styles.opacity = new S(t, "opacity", this.calculateOpacity())), i.type === "svg") {
        var n = this.getStyle("width", false, true), o = this.getStyle("height", false, true);
        n.hasValue() && (i.attributes.width = new S(t, "width", n.getString())), o.hasValue() && (i.attributes.height = new S(t, "height", o.getString()));
      }
      var s = i.parent;
      i.parent = this, i.render(e), i.parent = s;
    }
  }
  getBoundingBox(e) {
    var {
      element: t
    } = this;
    return t ? t.getBoundingBox(e) : null;
  }
  elementTransform() {
    var {
      document: e,
      element: t
    } = this;
    return Be.fromElement(e, t);
  }
  get element() {
    return this.cachedElement || (this.cachedElement = this.getHrefAttribute().getDefinition()), this.cachedElement;
  }
};
function nr(a3, e, t, r, i, n) {
  return a3[t * r * 4 + e * 4 + n];
}
function sr(a3, e, t, r, i, n, o) {
  a3[t * r * 4 + e * 4 + n] = o;
}
function F(a3, e, t) {
  var r = a3[e];
  return r * t;
}
function me(a3, e, t, r) {
  return e + Math.cos(a3) * t + Math.sin(a3) * r;
}
var Al = class extends I {
  constructor(e, t, r) {
    super(e, t, r), this.type = "feColorMatrix";
    var i = ne(this.getAttribute("values").getString());
    switch (this.getAttribute("type").getString("matrix")) {
      case "saturate": {
        var n = i[0];
        i = [0.213 + 0.787 * n, 0.715 - 0.715 * n, 0.072 - 0.072 * n, 0, 0, 0.213 - 0.213 * n, 0.715 + 0.285 * n, 0.072 - 0.072 * n, 0, 0, 0.213 - 0.213 * n, 0.715 - 0.715 * n, 0.072 + 0.928 * n, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1];
        break;
      }
      case "hueRotate": {
        var o = i[0] * Math.PI / 180;
        i = [me(o, 0.213, 0.787, -0.213), me(o, 0.715, -0.715, -0.715), me(o, 0.072, -0.072, 0.928), 0, 0, me(o, 0.213, -0.213, 0.143), me(o, 0.715, 0.285, 0.14), me(o, 0.072, -0.072, -0.283), 0, 0, me(o, 0.213, -0.213, -0.787), me(o, 0.715, -0.715, 0.715), me(o, 0.072, 0.928, 0.072), 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1];
        break;
      }
      case "luminanceToAlpha":
        i = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0.2125, 0.7154, 0.0721, 0, 0, 0, 0, 0, 0, 1];
        break;
    }
    this.matrix = i, this.includeOpacity = this.getAttribute("includeOpacity").hasValue();
  }
  apply(e, t, r, i, n) {
    for (var {
      includeOpacity: o,
      matrix: s
    } = this, u = e.getImageData(0, 0, i, n), l = 0; l < n; l++) for (var h = 0; h < i; h++) {
      var f = nr(u.data, h, l, i, n, 0), c = nr(u.data, h, l, i, n, 1), v = nr(u.data, h, l, i, n, 2), g = nr(u.data, h, l, i, n, 3), d = F(s, 0, f) + F(s, 1, c) + F(s, 2, v) + F(s, 3, g) + F(s, 4, 1), p = F(s, 5, f) + F(s, 6, c) + F(s, 7, v) + F(s, 8, g) + F(s, 9, 1), y = F(s, 10, f) + F(s, 11, c) + F(s, 12, v) + F(s, 13, g) + F(s, 14, 1), x = F(s, 15, f) + F(s, 16, c) + F(s, 17, v) + F(s, 18, g) + F(s, 19, 1);
      o && (d = 0, p = 0, y = 0, x *= g / 255), sr(u.data, h, l, i, n, 0, d), sr(u.data, h, l, i, n, 1, p), sr(u.data, h, l, i, n, 2, y), sr(u.data, h, l, i, n, 3, x);
    }
    e.clearRect(0, 0, i, n), e.putImageData(u, 0, 0);
  }
};
var kr = class _kr extends I {
  constructor() {
    super(...arguments), this.type = "mask";
  }
  apply(e, t) {
    var {
      document: r
    } = this, i = this.getAttribute("x").getPixels("x"), n = this.getAttribute("y").getPixels("y"), o = this.getStyle("width").getPixels("x"), s = this.getStyle("height").getPixels("y");
    if (!o && !s) {
      var u = new ce();
      this.children.forEach((g) => {
        u.addBoundingBox(g.getBoundingBox(e));
      }), i = Math.floor(u.x1), n = Math.floor(u.y1), o = Math.floor(u.width), s = Math.floor(u.height);
    }
    var l = this.removeStyles(t, _kr.ignoreStyles), h = r.createCanvas(i + o, n + s), f = h.getContext("2d");
    r.screen.setDefaults(f), this.renderChildren(f), new Al(r, {
      nodeType: 1,
      childNodes: [],
      attributes: [{
        nodeName: "type",
        value: "luminanceToAlpha"
      }, {
        nodeName: "includeOpacity",
        value: "true"
      }]
    }).apply(f, 0, 0, i + o, n + s);
    var c = r.createCanvas(i + o, n + s), v = c.getContext("2d");
    r.screen.setDefaults(v), t.render(v), v.globalCompositeOperation = "destination-in", v.fillStyle = f.createPattern(h, "no-repeat"), v.fillRect(0, 0, i + o, n + s), e.fillStyle = v.createPattern(c, "no-repeat"), e.fillRect(0, 0, i + o, n + s), this.restoreStyles(t, l);
  }
  render(e) {
  }
};
kr.ignoreStyles = ["mask", "transform", "clip-path"];
var _o = () => {
};
var n2 = class extends I {
  constructor() {
    super(...arguments), this.type = "clipPath";
  }
  apply(e) {
    var {
      document: t
    } = this, r = Reflect.getPrototypeOf(e), {
      beginPath: i,
      closePath: n
    } = e;
    r && (r.beginPath = _o, r.closePath = _o), Reflect.apply(i, e, []), this.children.forEach((o) => {
      if (!(typeof o.path > "u")) {
        var s = typeof o.elementTransform < "u" ? o.elementTransform() : null;
        s || (s = Be.fromElement(t, o)), s && s.apply(e), o.path(e), r && (r.closePath = n), s && s.unapply(e);
      }
    }), Reflect.apply(n, e, []), e.clip(), r && (r.beginPath = i, r.closePath = n);
  }
  render(e) {
  }
};
var Br = class _Br extends I {
  constructor() {
    super(...arguments), this.type = "filter";
  }
  apply(e, t) {
    var {
      document: r,
      children: i
    } = this, n = t.getBoundingBox(e);
    if (n) {
      var o = 0, s = 0;
      i.forEach((y) => {
        var x = y.extraFilterDistance || 0;
        o = Math.max(o, x), s = Math.max(s, x);
      });
      var u = Math.floor(n.width), l = Math.floor(n.height), h = u + 2 * o, f = l + 2 * s;
      if (!(h < 1 || f < 1)) {
        var c = Math.floor(n.x), v = Math.floor(n.y), g = this.removeStyles(t, _Br.ignoreStyles), d = r.createCanvas(h, f), p = d.getContext("2d");
        r.screen.setDefaults(p), p.translate(-c + o, -v + s), t.render(p), i.forEach((y) => {
          typeof y.apply == "function" && y.apply(p, 0, 0, h, f);
        }), e.drawImage(d, 0, 0, h, f, c - o, v - s, h, f), this.restoreStyles(t, g);
      }
    }
  }
  render(e) {
  }
};
Br.ignoreStyles = ["filter", "transform", "clip-path"];
var s2 = class extends I {
  constructor(e, t, r) {
    super(e, t, r), this.type = "feDropShadow", this.addStylesFromStyleDefinition();
  }
  apply(e, t, r, i, n) {
  }
};
var o2 = class extends I {
  constructor() {
    super(...arguments), this.type = "feMorphology";
  }
  apply(e, t, r, i, n) {
  }
};
var u2 = class extends I {
  constructor() {
    super(...arguments), this.type = "feComposite";
  }
  apply(e, t, r, i, n) {
  }
};
var l2 = class extends I {
  constructor(e, t, r) {
    super(e, t, r), this.type = "feGaussianBlur", this.blurRadius = Math.floor(this.getAttribute("stdDeviation").getNumber()), this.extraFilterDistance = this.blurRadius;
  }
  apply(e, t, r, i, n) {
    var {
      document: o,
      blurRadius: s
    } = this, u = o.window ? o.window.document.body : null, l = e.canvas;
    l.id = o.getUniqueId(), u && (l.style.display = "none", u.appendChild(l)), r1(l, t, r, i, n, s), u && u.removeChild(l);
  }
};
var h2 = class extends I {
  constructor() {
    super(...arguments), this.type = "title";
  }
};
var v2 = class extends I {
  constructor() {
    super(...arguments), this.type = "desc";
  }
};
var f2 = {
  svg: Nt,
  rect: El,
  circle: D1,
  ellipse: L1,
  line: k1,
  polyline: $l,
  polygon: B1,
  path: A,
  pattern: j1,
  marker: F1,
  defs: U1,
  linearGradient: G1,
  radialGradient: z1,
  stop: H1,
  animate: on,
  animateColor: Y1,
  animateTransform: X1,
  font: W1,
  "font-face": q1,
  "missing-glyph": Q1,
  glyph: Sl,
  text: Ce,
  tspan: Lr,
  tref: K1,
  a: Z1,
  textPath: J1,
  image: t2,
  g: sn,
  symbol: r2,
  style: Cl,
  use: i2,
  mask: kr,
  clipPath: n2,
  filter: Br,
  feDropShadow: s2,
  feMorphology: o2,
  feComposite: u2,
  feColorMatrix: Al,
  feGaussianBlur: l2,
  title: h2,
  desc: v2
};
function Vo(a3, e) {
  var t = Object.keys(a3);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(a3);
    e && (r = r.filter(function(i) {
      return Object.getOwnPropertyDescriptor(a3, i).enumerable;
    })), t.push.apply(t, r);
  }
  return t;
}
function c2(a3) {
  for (var e = 1; e < arguments.length; e++) {
    var t = arguments[e] != null ? arguments[e] : {};
    e % 2 ? Vo(Object(t), true).forEach(function(r) {
      an(a3, r, t[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(a3, Object.getOwnPropertyDescriptors(t)) : Vo(Object(t)).forEach(function(r) {
      Object.defineProperty(a3, r, Object.getOwnPropertyDescriptor(t, r));
    });
  }
  return a3;
}
function g2(a3, e) {
  var t = document.createElement("canvas");
  return t.width = a3, t.height = e, t;
}
function d2(a3) {
  return Ti.apply(this, arguments);
}
function Ti() {
  return Ti = xe(function* (a3) {
    var e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false, t = document.createElement("img");
    return e && (t.crossOrigin = "Anonymous"), new Promise((r, i) => {
      t.onload = () => {
        r(t);
      }, t.onerror = (n, o, s, u, l) => {
        i(l);
      }, t.src = a3;
    });
  }), Ti.apply(this, arguments);
}
var $e = class _$e {
  constructor(e) {
    var {
      rootEmSize: t = 12,
      emSize: r = 12,
      createCanvas: i = _$e.createCanvas,
      createImage: n = _$e.createImage,
      anonymousCrossOrigin: o
    } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    this.canvg = e, this.definitions = /* @__PURE__ */ Object.create(null), this.styles = /* @__PURE__ */ Object.create(null), this.stylesSpecificity = /* @__PURE__ */ Object.create(null), this.images = [], this.fonts = [], this.emSizeStack = [], this.uniqueId = 0, this.screen = e.screen, this.rootEmSize = t, this.emSize = r, this.createCanvas = i, this.createImage = this.bindCreateImage(n, o), this.screen.wait(this.isImagesLoaded.bind(this)), this.screen.wait(this.isFontsLoaded.bind(this));
  }
  bindCreateImage(e, t) {
    return typeof t == "boolean" ? (r, i) => e(r, typeof i == "boolean" ? i : t) : e;
  }
  get window() {
    return this.screen.window;
  }
  get fetch() {
    return this.screen.fetch;
  }
  get ctx() {
    return this.screen.ctx;
  }
  get emSize() {
    var {
      emSizeStack: e
    } = this;
    return e[e.length - 1];
  }
  set emSize(e) {
    var {
      emSizeStack: t
    } = this;
    t.push(e);
  }
  popEmSize() {
    var {
      emSizeStack: e
    } = this;
    e.pop();
  }
  getUniqueId() {
    return "canvg".concat(++this.uniqueId);
  }
  isImagesLoaded() {
    return this.images.every((e) => e.loaded);
  }
  isFontsLoaded() {
    return this.fonts.every((e) => e.loaded);
  }
  createDocumentElement(e) {
    var t = this.createElement(e.documentElement);
    return t.root = true, t.addStylesFromStyleDefinition(), this.documentElement = t, t;
  }
  createElement(e) {
    var t = e.nodeName.replace(/^[^:]+:/, ""), r = _$e.elementTypes[t];
    return typeof r < "u" ? new r(this, e) : new R1(this, e);
  }
  createTextNode(e) {
    return new V1(this, e);
  }
  setViewBox(e) {
    this.screen.setViewBox(c2({
      document: this
    }, e));
  }
};
$e.createCanvas = g2;
$e.createImage = d2;
$e.elementTypes = f2;
function Do(a3, e) {
  var t = Object.keys(a3);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(a3);
    e && (r = r.filter(function(i) {
      return Object.getOwnPropertyDescriptor(a3, i).enumerable;
    })), t.push.apply(t, r);
  }
  return t;
}
function De(a3) {
  for (var e = 1; e < arguments.length; e++) {
    var t = arguments[e] != null ? arguments[e] : {};
    e % 2 ? Do(Object(t), true).forEach(function(r) {
      an(a3, r, t[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(a3, Object.getOwnPropertyDescriptors(t)) : Do(Object(t)).forEach(function(r) {
      Object.defineProperty(a3, r, Object.getOwnPropertyDescriptor(t, r));
    });
  }
  return a3;
}
var mt = class _mt {
  /**
   * Main constructor.
   * @param ctx - Rendering context.
   * @param svg - SVG Document.
   * @param options - Rendering options.
   */
  constructor(e, t) {
    var r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    this.parser = new za(r), this.screen = new Dr(e, r), this.options = r;
    var i = new $e(this, r), n = i.createDocumentElement(t);
    this.document = i, this.documentElement = n;
  }
  /**
   * Create Canvg instance from SVG source string or URL.
   * @param ctx - Rendering context.
   * @param svg - SVG source string or URL.
   * @param options - Rendering options.
   * @returns Canvg instance.
   */
  static from(e, t) {
    var r = arguments;
    return xe(function* () {
      var i = r.length > 2 && r[2] !== void 0 ? r[2] : {}, n = new za(i), o = yield n.parse(t);
      return new _mt(e, o, i);
    })();
  }
  /**
   * Create Canvg instance from SVG source string.
   * @param ctx - Rendering context.
   * @param svg - SVG source string.
   * @param options - Rendering options.
   * @returns Canvg instance.
   */
  static fromString(e, t) {
    var r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, i = new za(r), n = i.parseFromString(t);
    return new _mt(e, n, r);
  }
  /**
   * Create new Canvg instance with inherited options.
   * @param ctx - Rendering context.
   * @param svg - SVG source string or URL.
   * @param options - Rendering options.
   * @returns Canvg instance.
   */
  fork(e, t) {
    var r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return _mt.from(e, t, De(De({}, this.options), r));
  }
  /**
   * Create new Canvg instance with inherited options.
   * @param ctx - Rendering context.
   * @param svg - SVG source string.
   * @param options - Rendering options.
   * @returns Canvg instance.
   */
  forkString(e, t) {
    var r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return _mt.fromString(e, t, De(De({}, this.options), r));
  }
  /**
   * Document is ready promise.
   * @returns Ready promise.
   */
  ready() {
    return this.screen.ready();
  }
  /**
   * Document is ready value.
   * @returns Is ready or not.
   */
  isReady() {
    return this.screen.isReady();
  }
  /**
   * Render only first frame, ignoring animations and mouse.
   * @param options - Rendering options.
   */
  render() {
    var e = arguments, t = this;
    return xe(function* () {
      var r = e.length > 0 && e[0] !== void 0 ? e[0] : {};
      t.start(De({
        enableRedraw: true,
        ignoreAnimation: true,
        ignoreMouse: true
      }, r)), yield t.ready(), t.stop();
    })();
  }
  /**
   * Start rendering.
   * @param options - Render options.
   */
  start() {
    var e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, {
      documentElement: t,
      screen: r,
      options: i
    } = this;
    r.start(t, De(De({
      enableRedraw: true
    }, i), e));
  }
  /**
   * Stop rendering.
   */
  stop() {
    this.screen.stop();
  }
  /**
   * Resize SVG to fit in given size.
   * @param width
   * @param height
   * @param preserveAspectRatio
   */
  resize(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : e, r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
    this.documentElement.resize(e, t, r);
  }
};
export {
  Z1 as AElement,
  Y1 as AnimateColorElement,
  on as AnimateElement,
  X1 as AnimateTransformElement,
  ce as BoundingBox,
  wo as CB1,
  Co as CB2,
  Ao as CB3,
  Po as CB4,
  mt as Canvg,
  D1 as CircleElement,
  n2 as ClipPathElement,
  U1 as DefsElement,
  v2 as DescElement,
  $e as Document,
  I as Element,
  L1 as EllipseElement,
  Al as FeColorMatrixElement,
  u2 as FeCompositeElement,
  s2 as FeDropShadowElement,
  l2 as FeGaussianBlurElement,
  o2 as FeMorphologyElement,
  Br as FilterElement,
  Z as Font,
  W1 as FontElement,
  q1 as FontFaceElement,
  sn as GElement,
  Sl as GlyphElement,
  wl as GradientElement,
  t2 as ImageElement,
  k1 as LineElement,
  G1 as LinearGradientElement,
  F1 as MarkerElement,
  kr as MaskElement,
  Tl as Matrix,
  Q1 as MissingGlyphElement,
  x1 as Mouse,
  rt as PSEUDO_ZERO,
  za as Parser,
  A as PathElement,
  w as PathParser,
  j1 as PatternElement,
  k as Point,
  B1 as PolygonElement,
  $l as PolylineElement,
  S as Property,
  Ro as QB1,
  No as QB2,
  Io as QB3,
  z1 as RadialGradientElement,
  El as RectElement,
  Ge as RenderedElement,
  E1 as Rotate,
  Nt as SVGElement,
  a2 as SVGFontLoader,
  $1 as Scale,
  Dr as Screen,
  Ol as Skew,
  w1 as SkewX,
  C1 as SkewY,
  H1 as StopElement,
  Cl as StyleElement,
  r2 as SymbolElement,
  K1 as TRefElement,
  Lr as TSpanElement,
  Ce as TextElement,
  J1 as TextPathElement,
  h2 as TitleElement,
  Be as Transform,
  S1 as Translate,
  R1 as UnknownElement,
  i2 as UseElement,
  b1 as ViewPort,
  lt as compressSpaces,
  mt as default,
  m1 as getSelectorSpecificity,
  l1 as normalizeAttributeName,
  h1 as normalizeColor,
  ml as parseExternalUrl,
  y2 as presets,
  ne as toNumbers,
  s1 as trimLeft,
  o1 as trimRight,
  Eo as vectorMagnitude,
  $o as vectorsAngle,
  xi as vectorsRatio
};
/*! Bundled license information:

@mindfiredigital/pivothead/dist/index.es-980ec5f7.mjs:
  (*! *****************************************************************************
  Copyright (c) Microsoft Corporation.
  
  Permission to use, copy, modify, and/or distribute this software for any
  purpose with or without fee is hereby granted.
  
  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
  REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
  AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
  INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
  LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
  OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
  PERFORMANCE OF THIS SOFTWARE.
  ***************************************************************************** *)
*/
//# sourceMappingURL=index.es-980ec5f7-65FC5NO6.js.map



================================================
FILE: .angular/cache/18.2.20/angular-pivothead-example/vite/deps/package.json
================================================
{
  "type": "module"
}



================================================
FILE: .angular/cache/18.2.20/angular-pivothead-example/vite/deps/pivot-head-2VQXMX42.js
================================================
import {
  _w
} from "./chunk-JBLJVEST.js";
import {
  __spreadValues
} from "./chunk-WDMUDEB6.js";

// node_modules/@mindfiredigital/pivothead-angular/node_modules/@mindfiredigital/pivothead-web-component/dist/pivot-head.mjs
function renderSwitch(host) {
  const mode = host.getAttribute("mode") || "default";
  if (mode === "none") {
    if (host.shadowRoot) {
      host.shadowRoot.innerHTML = `<style>:host { display:block; }</style>`;
    }
  } else if (mode === "minimal") {
    if (host.shadowRoot) {
      host.shadowRoot.innerHTML = `
        <style>
        :host { display: block; font-family: inherit; }
        [data-pivot-root] {
          display: grid;
          border: 1px solid #d8dde2; border-radius: 6px; background: #fcfdff;
        }
        [data-pivot-header], [data-pivot-body] {
          padding: 0.3em 0.5em;
        }
        [data-pivot-header] {
          background: #f4f7fa;
          border-bottom: 1px solid #e2e7ed;
          font-weight: bold;
        }
        </style>
        <div role="grid" data-pivot-root>
          <div role="rowgroup" data-pivot-header><slot name="header"></slot></div>
          <div role="rowgroup" data-pivot-body><slot name="body"></slot></div>
        </div>
      `;
    }
  } else {
    host._showRawData ? host.renderRawTable() : host.renderFullUI();
  }
}
function handleEngineStateChange(host, state) {
  host.dispatchEvent(new CustomEvent("stateChange", {
    detail: state,
    bubbles: true,
    composed: true
  }));
  host.calculatePaginationForCurrentView();
  const mode = host.getAttribute("mode");
  if (mode === "none") {
    if (host.shadowRoot) host.shadowRoot.innerHTML = `<style>:host { display:block; }</style>`;
  } else if (mode === "minimal") {
    if (host.shadowRoot) {
      host.shadowRoot.innerHTML = `
        <style>
        :host { display: block; font-family: inherit; }
        [data-pivot-root] {
          display: grid;
          border: 1px solid #d8dde2; border-radius: 6px; background: #fcfdff;
        }
        [data-pivot-header], [data-pivot-body] {
          padding: 0.3em 0.5em;
        }
        [data-pivot-header] {
          background: #f4f7fa;
          border-bottom: 1px solid #e2e7ed;
          font-weight: bold;
        }
        </style>
        <div role="grid" data-pivot-root>
          <div role="rowgroup" data-pivot-header><slot name="header"></slot></div>
          <div role="rowgroup" data-pivot-body><slot name="body"></slot></div>
        </div>
      `;
    }
  } else {
    host._showRawData ? host.renderRawTable() : host.renderFullUI();
  }
}
function renderFullUI(host) {
  const engine = host.engine;
  if (!engine) {
    if (host.shadowRoot) host.shadowRoot.innerHTML = "";
    return;
  }
  const state = engine.getState();
  if (!state.processedData) {
    console.error("No processed data available");
    return;
  }
  const rowField = host._options.rows?.[0];
  const columnField = host._options.columns?.[0];
  const measures = host._options.measures || [];
  if (!rowField || !columnField || !measures.length) {
    console.error("Missing row, column, or measures configuration");
    return;
  }
  host.calculatePaginationForCurrentView();
  let html = `
      <style>
        :host { display: block; font-family: inherit; }
        .controls-container { margin-bottom: 20px; display: flex; flex-wrap: wrap; gap: 10px; align-items: center; }
        .filter-container, .pagination-container { display: flex; gap: 10px; align-items: center; }
        table { width: 100%; border-collapse: collapse; background: #ffffff; border: 1px solid #dee2e6; margin-top: 20px; }
        th, td { border: 1px solid #dee2e6; padding: 8px; text-align: left; }
        th { background-color: #f8f9fa; cursor: grab; font-weight: 600; }
        .sortable-header { cursor: pointer; position: relative; }
        .sort-icon { margin-left: 5px; font-size: 12px; color: #6c757d; opacity: 0.5; }
        .sort-icon.active { color: #007bff; opacity: 1; }
        .corner-cell { background-color: #f8f9fa !important; border-bottom: 2px solid #dee2e6; border-right: 1px solid #dee2e6; }
        .column-header { background-color: #f8f9fa !important; border-bottom: 2px solid #dee2e6; text-align: center; cursor: move; }
        .measure-header { background-color: #f8f9fa !important; border-bottom: 2px solid #dee2e6; cursor: pointer; }
        .row-cell { font-weight: bold; background-color: #f8f9fa; }
        tr[draggable="true"] { cursor: grab; }
        .dragging { opacity: 0.5; }
        .drag-over { outline: 2px dashed #2672dd; background: #f3f8fd !important; }
        tbody tr:nth-child(even) td { background: #f8fafc; }
        button { padding: 5px 10px; background-color: #4CAF50; color: white; border: none; border-radius: 4px; cursor: pointer; }
        button:disabled { background-color: #cccccc; cursor: not-allowed; }
        select, input { padding: 5px; border-radius: 4px; border: 1px solid #ddd; }
        
        /* Drill-down styles */
        .drill-down-cell { cursor: pointer; }
        .drill-down-cell:hover { background-color: #e3f2fd !important; }
        
        /* Modal styles for drill-down details */
        .drill-down-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
        }

        .drill-down-content {
            background: white;
            border-radius: 8px;
            padding: 20px;
            width: 90%;
            max-width: 800px;
            max-height: 80%;
            overflow: auto;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
        }

        .drill-down-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            padding-bottom: 10px;
            border-bottom: 2px solid #e0e0e0;
        }

        .drill-down-title {
            font-size: 18px;
            font-weight: bold;
            color: #333;
        }

        .drill-down-close {
            background: #f44336;
            color: white;
            border: none;
            border-radius: 50%;
            width: 30px;
            height: 30px;
            cursor: pointer;
            font-size: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .drill-down-close:hover {
            background: #d32f2f;
        }

        .drill-down-summary {
            background: #f5f5f5;
            padding: 10px;
            border-radius: 4px;
            margin-bottom: 15px;
            font-size: 14px;
            line-height: 1.4;
        }

        .drill-down-table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 10px;
            font-size: 14px;
        }

        .drill-down-table th {
            background: #f8f9fa;
            padding: 8px;
            border: 1px solid #dee2e6;
            font-weight: bold;
            text-align: left;
        }

        .drill-down-table td {
            padding: 6px 8px;
            border: 1px solid #dee2e6;
        }

        .drill-down-table tr:nth-child(even) {
            background-color: #f9f9f9;
        }

        .drill-down-table tr:hover {
            background-color: #e3f2fd;
        }
      </style>
      <div class="controls-container">
        <div class="filter-container">
          <label>Filter:</label>
          <select id="filterField"></select>
          <select id="filterOperator">
            <option value="equals">Equals</option>
            <option value="contains">Contains</option>
            <option value="greaterThan">Greater Than</option>
            <option value="lessThan">Less Than</option>
          </select>
          <input type="text" id="filterValue" placeholder="Value">
          <button id="applyFilter">Apply</button>
          <button id="resetFilter">Reset</button>
        </div>
        <div class="pagination-container">
          <label>Items per page:</label>
          <select id="pageSize">
            <option value="5">5</option>
            <option value="10">10</option>
            <option value="25">25</option>
            <option value="50">50</option>
          </select>
          <button id="prevPage">Previous</button>
          <span id="pageInfo">Page ${host._pagination.currentPage} of ${host._pagination.totalPages}</span>
          <button id="nextPage">Next</button>
        </div>
        <button id="switchView">Switch to Raw Data</button>
        <button id="exportHTML">Export HTML</button>
        <button id="exportPDF">Export PDF</button>
        <button id="exportExcel">Export Excel</button>
        <button id="printTable">Print</button>
      </div>
    `;
  const groupedData = engine.getGroupedData();
  let uniqueColumnValues = engine.getOrderedColumnValues() || [...new Set(groupedData.map((g) => {
    const keys = g.key ? g.key.split("|") : [];
    return keys[1] || keys[0];
  }))].filter(Boolean);
  if (host._processedColumnOrder.length === 0) {
    host._processedColumnOrder = [...uniqueColumnValues];
  }
  if (host._processedColumnOrder.length > 0) {
    uniqueColumnValues = host._processedColumnOrder.filter((col) => uniqueColumnValues.includes(col));
  }
  html += '<table role="grid">';
  html += "<thead>";
  html += "<tr>";
  html += `<th class="corner-cell">${rowField.caption} / ${columnField.caption}</th>`;
  uniqueColumnValues.forEach((colValue, index) => {
    html += `<th class="column-header" draggable="true" data-column-index="${index}" data-column-value="${colValue}" colspan="${measures.length}">${colValue}</th>`;
  });
  html += "</tr>";
  html += "<tr>";
  const rowSortIcon = host.createProcessedSortIcon(rowField.uniqueName);
  html += `<th class="row-cell sortable-header" data-field="${rowField.uniqueName}">
      ${rowField.caption}${rowSortIcon}
    </th>`;
  uniqueColumnValues.forEach((colValue) => {
    measures.forEach((measure, measureIndex) => {
      const sortIcon = host.createProcessedSortIcon(measure.uniqueName);
      html += `<th class="measure-header sortable-header" data-measure-index="${measureIndex}" data-field="${measure.uniqueName}" data-column-value="${colValue}">
          ${measure.caption}${sortIcon}
        </th>`;
    });
  });
  html += "</tr>";
  html += "</thead>";
  html += "<tbody>";
  const orderedFromEngine = engine.getOrderedRowValues() || [];
  let uniqueRowValues = [...orderedFromEngine];
  if (uniqueRowValues.length === 0) {
    const allGroups = engine.getGroupedData();
    uniqueRowValues = [...new Set(allGroups.map((g) => {
      const keys = g.key ? g.key.split("|") : [];
      return keys[0];
    }))].filter(Boolean);
  }
  const paginatedRowValues = host.getPaginatedData(uniqueRowValues);
  paginatedRowValues.forEach((rowValue, rowIndex) => {
    html += `<tr draggable="true" data-row-index="${rowIndex}" data-row-value="${rowValue}">`;
    html += `<td class="row-cell">${rowValue}</td>`;
    uniqueColumnValues.forEach((colValue) => {
      measures.forEach((measure) => {
        const matchingGroup = groupedData.find((g) => {
          const keys = g.key ? g.key.split("|") : [];
          return keys[0] === rowValue && keys[1] === colValue;
        });
        const aggKey = measure.aggregation + "_" + measure.uniqueName;
        const value = matchingGroup?.aggregates?.[aggKey];
        let formattedValue = "0";
        if (value !== void 0 && value !== null) {
          if (typeof value === "number") {
            formattedValue = value.toLocaleString();
          } else if (String(value).trim() !== "") {
            formattedValue = String(value);
          }
        }
        const hasData = value !== void 0 && value !== null && Number(value) > 0;
        const cellClass = hasData ? "data-cell drill-down-cell" : "data-cell";
        const cellTitle = hasData ? `Double-click to see details for ${rowField.caption}: ${rowValue} - ${columnField.caption}: ${colValue}` : "";
        html += `<td class="${cellClass}" 
                      title="${cellTitle}"
                      data-row-value="${rowValue}" 
                      data-column-value="${colValue}" 
                      data-measure-name="${measure.uniqueName}"
                      data-measure-caption="${measure.caption}"
                      data-row-field="${rowField.uniqueName}"
                      data-column-field="${columnField.uniqueName}"
                      data-aggregate-value="${value || 0}">
                      ${formattedValue}
                   </td>`;
      });
    });
    html += "</tr>";
  });
  html += "</tbody>";
  html += "</table>";
  if (host.shadowRoot) host.shadowRoot.innerHTML = html;
  host.addDragListeners();
  host.setupControls();
}
function renderRawTable(host) {
  const engine = host.engine;
  if (!engine) return;
  const state = engine.getState();
  const allRawData = state.rawData || state.data || [];
  if (!allRawData.length) return;
  host.updatePaginationForData(allRawData);
  const displayData = host.getPaginatedData(allRawData);
  const originalHeaders = Object.keys(displayData[0] || allRawData[0]);
  let headers;
  if (host._rawDataColumnOrder && host._rawDataColumnOrder.length > 0) {
    const missingHeaders = originalHeaders.filter((h) => !host._rawDataColumnOrder.includes(h));
    headers = [...host._rawDataColumnOrder, ...missingHeaders];
  } else {
    headers = originalHeaders;
    host._rawDataColumnOrder = [...headers];
  }
  let html = `
      <style>
        :host { display: block; font-family: inherit; }
        .controls-container { margin-bottom: 20px; display: flex; flex-wrap: wrap; gap: 10px; align-items: center; }
        .filter-container, .pagination-container { display: flex; gap: 10px; align-items: center; }
        table { width: 100%; border-collapse: collapse; background: #ffffff; border: 1px solid #e2e7ed; }
        th, td { border: 1px solid #dde1e7; padding: 8px; text-align: left; }
        th { background-color: #eaf2fa; cursor: grab; font-weight: 600; }
        .sortable-header { cursor: pointer !important; position: relative; }
        .sort-icon { margin-left: 5px; font-size: 12px; color: #6c757d; opacity: 0.5; }
        .sort-icon.active { color: #007bff; opacity: 1; }
        tr[draggable="true"] { cursor: grab; }
        .dragging { opacity: 0.5; }
        .drag-over { outline: 2px dashed #2672dd; background: #f3f8fd !important; }
        tbody tr:nth-child(even) td { background: #f8fafc; }
        button { padding: 5px 10px; background-color: #4CAF50; color: white; border: none; border-radius: 4px; cursor: pointer; }
        button:disabled { background-color: #cccccc; cursor: not-allowed; }
        select, input { padding: 5px; border-radius: 4px; border: 1px solid #ddd; }
      </style>
      <div class="controls-container">
        <div class="filter-container">
          <label>Filter:</label>
          <select id="filterField"></select>
          <select id="filterOperator">
            <option value="equals">Equals</option>
            <option value="contains">Contains</option>
            <option value="greaterThan">Greater Than</option>
            <option value="lessThan">Less Than</option>
          </select>
          <input type="text" id="filterValue" placeholder="Value">
          <button id="applyFilter">Apply</button>
          <button id="resetFilter">Reset</button>
        </div>
        <div class="pagination-container">
          <label>Items per page:</label>
          <select id="pageSize">
            <option value="5">5</option>
            <option value="10">10</option>
            <option value="25">25</option>
            <option value="50">50</option>
          </select>
          <button id="prevPage">Previous</button>
          <span id="pageInfo">Page ${host._pagination.currentPage} of ${host._pagination.totalPages}</span>
          <button id="nextPage">Next</button>
        </div>
        <button id="switchView">Switch to Processed Data</button>
        <button id="exportHTML">Export HTML</button>
        <button id="exportPDF">Export PDF</button>
        <button id="exportExcel">Export Excel</button>
        <button id="printTable">Print</button>
      </div>
    `;
  html += '<table data-raw="true">';
  html += "<thead><tr>";
  headers.forEach((header, index) => {
    const sortIcon = host.createSortIcon(header);
    html += `<th class="sortable-header" draggable="true" data-column-index="${index}" data-field="${header}">
        ${header}${sortIcon}
      </th>`;
  });
  html += "</tr></thead>";
  html += "<tbody>";
  displayData.forEach((row, rowIndex) => {
    const pivotRow = row;
    html += `<tr draggable="true" data-row-index="${rowIndex}">`;
    headers.forEach((header) => {
      html += `<td>${pivotRow[header]}</td>`;
    });
    html += "</tr>";
  });
  html += "</tbody></table>";
  if (host.shadowRoot) host.shadowRoot.innerHTML = html;
  host.addDragListeners();
  host.setupControls();
}
function bindControls(host) {
  const filterField = host.shadowRoot?.getElementById("filterField");
  if (filterField) {
    if (host._showRawData) {
      if (host._data.length > 0) {
        filterField.innerHTML = Object.keys(host._data[0]).map((f) => `<option value="${f}">${f}</option>`).join("");
      }
    } else {
      let options = "";
      if (host._options.rows) {
        host._options.rows.forEach((row) => {
          options += `<option value="${row.uniqueName}">${row.caption}</option>`;
        });
      }
      if (host._options.columns) {
        host._options.columns.forEach((col) => {
          options += `<option value="${col.uniqueName}">${col.caption}</option>`;
        });
      }
      if (host._options.measures) {
        host._options.measures.forEach((measure) => {
          const aggregatedKey = `${measure.aggregation}_${measure.uniqueName}`;
          options += `<option value="${aggregatedKey}">${measure.caption}</option>`;
        });
      }
      filterField.innerHTML = options;
    }
  }
  const filterValueInput = host.shadowRoot?.getElementById("filterValue");
  if (filterValueInput && host._filters.length > 0) {
    const currentFilter = host._filters[0];
    if (currentFilter) {
      const filterFieldElement = host.shadowRoot?.getElementById("filterField");
      const filterOperatorElement = host.shadowRoot?.getElementById("filterOperator");
      if (filterFieldElement) {
        filterFieldElement.value = currentFilter.field;
      }
      if (filterOperatorElement) {
        filterOperatorElement.value = currentFilter.operator;
      }
      filterValueInput.value = currentFilter.value;
    }
  }
  const pageSizeSelect = host.shadowRoot?.getElementById("pageSize");
  if (pageSizeSelect) {
    Array.from(pageSizeSelect.options).forEach((option) => {
      option.removeAttribute("selected");
      option.selected = false;
    });
    pageSizeSelect.value = host._pagination.pageSize.toString();
    const selectedOption = pageSizeSelect.querySelector(`option[value="${host._pagination.pageSize}"]`);
    if (selectedOption) {
      selectedOption.selected = true;
      selectedOption.setAttribute("selected", "selected");
    }
  }
  const applyBtn = host.shadowRoot?.getElementById("applyFilter");
  if (applyBtn) {
    const newApplyBtn = applyBtn.cloneNode(true);
    applyBtn.parentNode?.replaceChild(newApplyBtn, applyBtn);
    newApplyBtn.addEventListener("click", () => {
      const fieldElement = host.shadowRoot?.getElementById("filterField");
      const operatorElement = host.shadowRoot?.getElementById("filterOperator");
      const valueElement = host.shadowRoot?.getElementById("filterValue");
      if (!fieldElement || !operatorElement || !valueElement) return;
      const field = fieldElement.value;
      const operator = operatorElement.value;
      const value = valueElement.value;
      if (!field || !operator || !value) return;
      const filter = {
        field,
        operator,
        value
      };
      host.filters = [filter];
    });
  }
  const resetBtn = host.shadowRoot?.getElementById("resetFilter");
  if (resetBtn) {
    const newResetBtn = resetBtn.cloneNode(true);
    resetBtn.parentNode?.replaceChild(newResetBtn, resetBtn);
    newResetBtn.addEventListener("click", () => {
      host.reset();
    });
  }
  const pageSizeSel = host.shadowRoot?.getElementById("pageSize");
  if (pageSizeSel) {
    const newPageSizeSel = pageSizeSel.cloneNode(true);
    pageSizeSel.parentNode?.replaceChild(newPageSizeSel, pageSizeSel);
    newPageSizeSel.addEventListener("change", (e) => {
      const target = e.target;
      host.setPageSize(Number(target.value));
    });
  }
  const prevBtn = host.shadowRoot?.getElementById("prevPage");
  if (prevBtn) {
    const newPrevBtn = prevBtn.cloneNode(true);
    prevBtn.parentNode?.replaceChild(newPrevBtn, prevBtn);
    newPrevBtn.addEventListener("click", () => host.previousPage());
  }
  const nextBtn = host.shadowRoot?.getElementById("nextPage");
  if (nextBtn) {
    const newNextBtn = nextBtn.cloneNode(true);
    nextBtn.parentNode?.replaceChild(newNextBtn, nextBtn);
    newNextBtn.addEventListener("click", () => host.nextPage());
  }
  updatePaginationInfo(host);
  const switchBtn = host.shadowRoot?.getElementById("switchView");
  if (switchBtn) {
    const newSwitchBtn = switchBtn.cloneNode(true);
    switchBtn.parentNode?.replaceChild(newSwitchBtn, switchBtn);
    newSwitchBtn.textContent = host._showRawData ? "Switch to Processed Data" : "Switch to Raw Data";
    newSwitchBtn.addEventListener("click", () => {
      host._showRawData = !host._showRawData;
      try {
        if (host.engine) {
          host.engine.setDataHandlingMode(host._showRawData ? "raw" : "processed");
          const currentFilters = host._showRawData ? host._rawFilters : host._processedFilters;
          host.engine.applyFilters(currentFilters);
          host.dispatchEvent(new CustomEvent("viewModeChange", {
            detail: {
              mode: host._showRawData ? "raw" : "processed"
            },
            bubbles: true,
            composed: true
          }));
        }
      } catch (error) {
        console.error("Error during view switch:", error);
      }
    });
  }
  const exportHTML = host.shadowRoot?.getElementById("exportHTML");
  if (exportHTML) {
    const newExportHTML = exportHTML.cloneNode(true);
    exportHTML.parentNode?.replaceChild(newExportHTML, exportHTML);
    newExportHTML.addEventListener("click", () => host.exportToHTML());
  }
  const exportPDF = host.shadowRoot?.getElementById("exportPDF");
  if (exportPDF) {
    const newExportPDF = exportPDF.cloneNode(true);
    exportPDF.parentNode?.replaceChild(newExportPDF, exportPDF);
    newExportPDF.addEventListener("click", () => host.exportToPDF());
  }
  const exportExcel = host.shadowRoot?.getElementById("exportExcel");
  if (exportExcel) {
    const newExportExcel = exportExcel.cloneNode(true);
    exportExcel.parentNode?.replaceChild(newExportExcel, exportExcel);
    newExportExcel.addEventListener("click", () => host.exportToExcel());
  }
  const printBtn = host.shadowRoot?.getElementById("printTable");
  if (printBtn) {
    const newPrintBtn = printBtn.cloneNode(true);
    printBtn.parentNode?.replaceChild(newPrintBtn, printBtn);
    newPrintBtn.addEventListener("click", () => host.openPrintDialog());
  }
}
function updatePaginationInfo(host) {
  const pageInfo = host.shadowRoot?.getElementById("pageInfo");
  if (pageInfo) {
    const viewMode = host._showRawData ? "Raw Data" : "Processed Data";
    pageInfo.textContent = `${viewMode} - Page ${host._pagination.currentPage} of ${host._pagination.totalPages}`;
  }
  const prevButton = host.shadowRoot?.getElementById("prevPage");
  const nextButton = host.shadowRoot?.getElementById("nextPage");
  if (prevButton) prevButton.disabled = host._pagination.currentPage <= 1;
  if (nextButton) nextButton.disabled = host._pagination.currentPage >= host._pagination.totalPages;
}
function addDragListeners(host) {
  const headers = host.shadowRoot?.querySelectorAll('th[draggable="true"]');
  headers?.forEach((header) => {
    header.addEventListener("dragstart", (e) => {
      handleColumnDragStart(host, e);
    });
    header.addEventListener("dragover", (e) => {
      handleColumnDragOver(host, e);
    });
    header.addEventListener("dragleave", (e) => {
      handleColumnDragLeave(host, e);
    });
    header.addEventListener("drop", (e) => {
      handleColumnDrop(host, e);
    });
    header.addEventListener("dragend", () => {
      handleColumnDragEnd(host);
    });
  });
  const rows = host.shadowRoot?.querySelectorAll('tr[draggable="true"]');
  rows?.forEach((row) => {
    row.addEventListener("dragstart", (e) => {
      handleRowDragStart(host, e);
    });
    row.addEventListener("dragover", (e) => {
      handleRowDragOver(host, e);
    });
    row.addEventListener("dragleave", (e) => {
      handleRowDragLeave(host, e);
    });
    row.addEventListener("drop", (e) => {
      handleRowDrop(host, e);
    });
    row.addEventListener("dragend", () => {
      handleRowDragEnd(host);
    });
  });
  const sortableHeaders = host.shadowRoot?.querySelectorAll(".sortable-header");
  sortableHeaders?.forEach((header) => {
    header.addEventListener("click", (e) => {
      handleSortClick(host, e);
    });
  });
  const drillDownCells = host.shadowRoot?.querySelectorAll(".drill-down-cell");
  drillDownCells?.forEach((cell) => {
    cell.addEventListener("dblclick", (e) => {
      handleDrillDownClick(host, e);
    });
  });
}
function handleSortClick(host, e) {
  if (!host.engine) return;
  const target = e.target;
  const header = target.closest(".sortable-header");
  if (!header) return;
  const field = header.dataset.field;
  if (!field) return;
  const state = host.engine.getState();
  const current = state.sortConfig && state.sortConfig.length > 0 ? state.sortConfig[0] : null;
  const nextDir = current && current.field === field && current.direction === "asc" ? "desc" : "asc";
  if (!host._showRawData) {
    const isMeasureHeader = header.hasAttribute("data-measure-index");
    const columnValue = header.getAttribute("data-column-value") || "";
    if (isMeasureHeader && columnValue) {
      try {
        const measures = host._options.measures || [];
        const measureCfg = measures.find((m) => m.uniqueName === field);
        const aggregation = measureCfg?.aggregation || "sum";
        const aggKey = `${aggregation}_${field}`;
        const groups = host.engine.getGroupedData();
        const allRowSet = /* @__PURE__ */ new Set();
        groups.forEach((g) => {
          const keys = g.key ? g.key.split("|") : [];
          if (keys[0]) allRowSet.add(keys[0]);
        });
        const allRowValues = Array.from(allRowSet);
        const pairs = allRowValues.map((rv) => {
          const grp = groups.find((gr) => {
            const keys = gr.key ? gr.key.split("|") : [];
            return keys[0] === rv && keys[1] === columnValue;
          });
          const aggregates = grp?.aggregates || {};
          const val = Number(aggregates[aggKey] ?? 0);
          return {
            row: rv,
            val: isFinite(val) ? val : 0
          };
        });
        pairs.sort((a, b) => nextDir === "asc" ? a.val - b.val : b.val - a.val);
        const orderedRows = pairs.map((p) => p.row);
        const rowFieldName = host._options.rows?.[0]?.uniqueName || "";
        if (rowFieldName && orderedRows.length > 0) {
          host.engine.setCustomFieldOrder(rowFieldName, orderedRows, true);
        }
      } catch (err) {
        console.error("Failed to compute/set custom row order for processed sort:", err);
      }
    } else {
      const rowFieldName = host._options.rows?.[0]?.uniqueName || "";
      if (rowFieldName && field === rowFieldName) {
        try {
          const groups = host.engine.getGroupedData();
          const rowSet = /* @__PURE__ */ new Set();
          groups.forEach((g) => {
            const keys = g.key ? g.key.split("|") : [];
            if (keys[0]) rowSet.add(keys[0]);
          });
          const rows = Array.from(rowSet);
          rows.sort((a, b) => nextDir === "asc" ? a.localeCompare(b) : b.localeCompare(a));
          if (rows.length > 0) {
            host.engine.setCustomFieldOrder(rowFieldName, rows, true);
          }
        } catch (err) {
          console.error("Failed to set custom row order for dimension sort:", err);
        }
      }
    }
  }
  host.engine.sort(field, nextDir);
}
function handleDrillDownClick(host, e) {
  if (!host.engine) return;
  const cell = e.target.closest(".drill-down-cell");
  if (!cell) return;
  const rowValue = cell.getAttribute("data-row-value") || "";
  const columnValue = cell.getAttribute("data-column-value") || "";
  const measureName = cell.getAttribute("data-measure-name") || "";
  const measureCaption = cell.getAttribute("data-measure-caption") || measureName;
  const rowField = cell.getAttribute("data-row-field") || "";
  const columnField = cell.getAttribute("data-column-field") || "";
  const state = host.engine.getState();
  const rawData = state.rawData || state.data || [];
  const subset = rawData.filter((r) => {
    const rowOk = rowField ? String(r[rowField] ?? "") === String(rowValue) : true;
    const colOk = columnField ? String(r[columnField] ?? "") === String(columnValue) : true;
    return rowOk && colOk;
  });
  addModalStylesToDocument();
  const overlay = document.createElement("div");
  overlay.className = "drill-down-modal";
  const content = document.createElement("div");
  content.className = "drill-down-content";
  content.innerHTML = `
      <div class="drill-down-header">
        <div class="drill-down-title">Details: ${rowField}: ${rowValue}${columnField ? `, ${columnField}: ${columnValue}` : ""}</div>
        <button class="drill-down-close" aria-label="Close">&times;</button>
      </div>
      <div class="drill-down-summary">
        Records: ${subset.length}. Measure: ${measureCaption} (${measureName}).
      </div>
      <div class="drill-down-body"></div>
    `;
  const bodyDiv = content.querySelector(".drill-down-body");
  if (subset.length > 0) {
    const headers = Object.keys(subset[0]);
    const table = document.createElement("table");
    table.className = "drill-down-table";
    const thead = document.createElement("thead");
    const trh = document.createElement("tr");
    headers.forEach((h) => {
      const th = document.createElement("th");
      th.textContent = h;
      trh.appendChild(th);
    });
    thead.appendChild(trh);
    table.appendChild(thead);
    const tbody = document.createElement("tbody");
    subset.forEach((row) => {
      const tr = document.createElement("tr");
      headers.forEach((h) => {
        const td = document.createElement("td");
        const val = row[h];
        td.textContent = val != null ? String(val) : "";
        tr.appendChild(td);
      });
      tbody.appendChild(tr);
    });
    table.appendChild(tbody);
    bodyDiv.appendChild(table);
  } else {
    bodyDiv.textContent = "No matching records.";
  }
  overlay.appendChild(content);
  document.body.appendChild(overlay);
  const close = () => overlay.remove();
  overlay.addEventListener("click", (evt) => {
    if (evt.target === overlay) close();
  });
  const closeBtn = content.querySelector(".drill-down-close");
  closeBtn?.addEventListener("click", close);
}
function addModalStylesToDocument() {
  if (document.getElementById("pivot-head-modal-styles")) return;
  const styleEl = document.createElement("style");
  styleEl.id = "pivot-head-modal-styles";
  styleEl.textContent = `
      .drill-down-modal {
          position: fixed;
          top: 0;
          left: 0;
          width: 100%;
          height: 100%;
          background-color: rgba(0, 0, 0, 0.5);
          display: flex;
          justify-content: center;
          align-items: center;
          z-index: 1000;
          font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      }
      .drill-down-content {
          background: white;
          border-radius: 8px;
          padding: 20px;
          width: 90%;
          max-width: 800px;
          max-height: 80%;
          overflow: auto;
          box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
      }
      .drill-down-header {
          display: flex;
          justify-content: space-between;
          align-items: center;
          margin-bottom: 20px;
          padding-bottom: 10px;
          border-bottom: 2px solid #e0e0e0;
      }
      .drill-down-title { font-size: 18px; font-weight: bold; color: #333; }
      .drill-down-close {
          background: #f44336;
          color: white;
          border: none;
          border-radius: 50%;
          width: 30px;
          height: 30px;
          cursor: pointer;
          font-size: 16px;
          display: flex;
          align-items: center;
          justify-content: center;
      }
      .drill-down-close:hover { background: #d32f2f; }
      .drill-down-summary { background: #f5f5f5; padding: 10px; border-radius: 4px; margin-bottom: 15px; font-size: 14px; line-height: 1.4; }
      .drill-down-table { width: 100%; border-collapse: collapse; margin-top: 10px; font-size: 14px; }
      .drill-down-table th { background: #f8f9fa; padding: 8px; border: 1px solid #dee2e6; font-weight: bold; text-align: left; }
      .drill-down-table td { padding: 6px 8px; border: 1px solid #dee2e6; }
      .drill-down-table tr:nth-child(even) { background-color: #f9f9f9; }
      .drill-down-table tr:hover { background-color: #e3f2fd; }
    `;
  document.head.appendChild(styleEl);
}
function createSortIcon(host, field) {
  if (!host.engine) {
    return '<span class="sort-icon" title="Click to sort">&#8693;</span>';
  }
  const state = host.engine.getState();
  const sortConfig = state.sortConfig && state.sortConfig.length > 0 ? state.sortConfig[0] : null;
  const isCurrentlySorted = !!(sortConfig && sortConfig.field === field);
  if (isCurrentlySorted) {
    if (sortConfig && sortConfig.direction === "asc") {
      return '<span class="sort-icon active" title="Sorted ascending">&#9650;</span>';
    } else {
      return '<span class="sort-icon active" title="Sorted descending">&#9660;</span>';
    }
  }
  return '<span class="sort-icon" title="Click to sort">&#8693;</span>';
}
function createProcessedSortIcon(host, field) {
  if (!host.engine) {
    return '<span class="sort-icon" title="Click to sort">&#8693;</span>';
  }
  const state = host.engine.getState();
  const sortConfig = state.sortConfig && state.sortConfig.length > 0 ? state.sortConfig[0] : null;
  const isCurrentlySorted = !!(sortConfig && sortConfig.field === field);
  if (isCurrentlySorted) {
    if (sortConfig && sortConfig.direction === "asc") {
      return '<span class="sort-icon active" title="Sorted ascending">&#9650;</span>';
    } else {
      return '<span class="sort-icon active" title="Sorted descending">&#9660;</span>';
    }
  }
  return '<span class="sort-icon" title="Click to sort">&#8693;</span>';
}
function handleColumnDragStart(host, e) {
  host.draggedColumn = e.target;
  if (e.dataTransfer) {
    e.dataTransfer.effectAllowed = "move";
    e.dataTransfer.setData("text/plain", host.draggedColumn.dataset.columnIndex || "");
  }
  setTimeout(() => host.draggedColumn?.classList.add("dragging"), 0);
}
function handleColumnDragOver(host, e) {
  e.preventDefault();
  if (e.dataTransfer?.types.includes("text/plain")) {
    const target = e.target;
    if (target.tagName === "TH" && target !== host.draggedColumn) {
      target.classList.add("drag-over");
    }
  }
}
function handleColumnDragLeave(host, e) {
  e.target.classList.remove("drag-over");
}
function handleColumnDrop(host, e) {
  e.preventDefault();
  const target = e.target;
  target.classList.remove("drag-over");
  if (host.draggedColumn && target.tagName === "TH") {
    const fromIndex = parseInt(host.draggedColumn.dataset.columnIndex || "0");
    const toIndex = parseInt(target.dataset.columnIndex || "0");
    if (fromIndex !== toIndex) host.swapColumns(fromIndex, toIndex);
  }
}
function handleColumnDragEnd(host) {
  host.draggedColumn?.classList.remove("dragging");
  host.draggedColumn = null;
  host.shadowRoot?.querySelectorAll(".drag-over").forEach((el) => el.classList.remove("drag-over"));
}
function handleRowDragStart(host, e) {
  host.draggedRow = e.target;
  if (e.dataTransfer) {
    e.dataTransfer.effectAllowed = "move";
    e.dataTransfer.setData("text/plain", host.draggedRow.dataset.rowIndex || "");
  }
  setTimeout(() => host.draggedRow?.classList.add("dragging"), 0);
}
function handleRowDragOver(host, e) {
  e.preventDefault();
  if (e.dataTransfer?.types.includes("text/plain")) {
    const target = e.target;
    const targetRow = target.closest("tr");
    if (targetRow && targetRow.tagName === "TR" && targetRow !== host.draggedRow) {
      targetRow.classList.add("drag-over");
    }
  }
}
function handleRowDragLeave(host, e) {
  const target = e.target;
  const targetRow = target.closest("tr");
  if (targetRow) targetRow.classList.remove("drag-over");
}
function handleRowDrop(host, e) {
  e.preventDefault();
  const target = e.target;
  const targetRow = target.closest("tr");
  if (targetRow) targetRow.classList.remove("drag-over");
  if (host.draggedRow && targetRow && targetRow.tagName === "TR") {
    const fromIndex = parseInt(host.draggedRow.dataset.rowIndex || "0");
    const toIndex = parseInt(targetRow.dataset.rowIndex || "0");
    if (fromIndex !== toIndex) host.swapRows(fromIndex, toIndex);
  }
}
function handleRowDragEnd(host) {
  host.draggedRow?.classList.remove("dragging");
  host.draggedRow = null;
  host.shadowRoot?.querySelectorAll(".drag-over").forEach((el) => el.classList.remove("drag-over"));
}
function tryInitializeEngine(host) {
  const hasData = host._data && host._data.length > 0;
  const hasOptions = host._options && Object.keys(host._options).length > 0;
  if (!hasData || !hasOptions) return;
  try {
    const options = __spreadValues({}, host._options);
    if (!options.rows || !Array.isArray(options.rows) || options.rows.length === 0) {
      const firstRowField = host._data.length > 0 ? Object.keys(host._data[0])[0] : null;
      if (firstRowField) {
        options.rows = [{
          uniqueName: firstRowField,
          caption: firstRowField
        }];
      }
    }
    if (!options.columns || !Array.isArray(options.columns) || options.columns.length === 0) {
      const keys = host._data.length > 0 ? Object.keys(host._data[0]) : [];
      const colField = keys.length > 1 ? keys[1] : null;
      if (colField) {
        options.columns = [{
          uniqueName: colField,
          caption: colField
        }];
      }
    }
    if (!options.measures || !Array.isArray(options.measures) || options.measures.length === 0) {
      const keys = host._data.length > 0 ? Object.keys(host._data[0]) : [];
      const measureField = keys.find((k) => typeof host._data[0][k] === "number");
      if (measureField) {
        options.measures = [{
          uniqueName: measureField,
          caption: `Sum of ${measureField}`,
          aggregation: "sum"
        }];
      }
    }
    if (!options.groupConfig && options.rows && options.columns) {
      options.groupConfig = {
        rowFields: options.rows.map((r) => r.uniqueName),
        columnFields: options.columns.map((c) => c.uniqueName),
        grouper: (item) => {
          return [...options.rows?.map((r) => item[r.uniqueName]) ?? [], ...options.columns?.map((c) => item[c.uniqueName]) ?? []].join("|");
        }
      };
    }
    const config = {
      data: host._data,
      rawData: host._data,
      dimensions: [],
      defaultAggregation: "sum",
      rows: options.rows || [],
      columns: options.columns || [],
      measures: options.measures || [],
      groupConfig: options.groupConfig
    };
    host.engine = new _w(config);
    host.engine.setPagination({
      currentPage: 1,
      pageSize: Number.MAX_SAFE_INTEGER,
      totalPages: 1
    });
    host.engine.setDataHandlingMode(host._showRawData ? "raw" : "processed");
    if (host._engineUnsubscribe) host._engineUnsubscribe();
    host._engineUnsubscribe = host.engine.subscribe((state) => {
      host.handleEngineStateChange(state);
    });
    host._processedColumnOrder = [];
    const currentFilters = host._showRawData ? host._rawFilters : host._processedFilters;
    if (currentFilters.length > 0) {
      host.engine.applyFilters(currentFilters);
      return;
    }
  } catch (error) {
    console.error("Error initializing PivotEngine:", error);
  }
}
function parseAttributesIfNeeded(host) {
  const rawData = host.getAttribute("data");
  if (rawData && !host._data.length) {
    try {
      host.data = JSON.parse(rawData);
    } catch (error) {
      console.error("Error parsing data attribute:", error);
    }
  }
  const rawOptions = host.getAttribute("options");
  if (rawOptions && !Object.keys(host._options).length) {
    try {
      host.options = JSON.parse(rawOptions);
    } catch (error) {
      console.error("Error parsing options attribute:", error);
    }
  }
  parseOtherAttributes(host);
}
function parseOtherAttributes(host) {
  const rawFilters = host.getAttribute("filters");
  if (rawFilters) {
    try {
      host.filters = JSON.parse(rawFilters);
    } catch (error) {
      console.error("Error parsing filters attribute:", error);
    }
  }
  const rawPagination = host.getAttribute("pagination");
  if (rawPagination) {
    try {
      host.pagination = __spreadValues(__spreadValues({}, host._pagination), JSON.parse(rawPagination));
    } catch (error) {
      console.error("Error parsing pagination attribute:", error);
    }
  }
}
function attributeChanged(host, name, oldValue, newValue) {
  if (oldValue === newValue) return;
  if (name === "mode") {
    renderSwitch(host);
    return;
  }
  switch (name) {
    case "data":
      if (newValue) {
        try {
          host.data = JSON.parse(newValue);
        } catch (error) {
          console.error("Error parsing data attribute:", error);
        }
      }
      break;
    case "options":
      if (newValue) {
        try {
          host.options = JSON.parse(newValue);
        } catch (error) {
          console.error("Error parsing options attribute:", error);
        }
      }
      break;
    case "filters":
      if (newValue) {
        try {
          host.filters = JSON.parse(newValue);
        } catch (error) {
          console.error("Error parsing filters attribute:", error);
        }
      } else {
        host.filters = [];
      }
      break;
    case "pagination":
      if (newValue) {
        try {
          host.pagination = __spreadValues(__spreadValues({}, host._pagination), JSON.parse(newValue));
        } catch (error) {
          console.error("Error parsing pagination attribute:", error);
        }
      } else {
        host.pagination = {
          currentPage: 1,
          pageSize: 30,
          totalPages: 1
        };
      }
      break;
  }
}
function calculatePaginationForCurrentView(host) {
  if (host._showRawData) {
    if (!host.engine) return;
    const state = host.engine.getState();
    const allRawData = state.rawData || state.data || [];
    updatePaginationForData(host, allRawData);
  } else {
    if (!host.engine) return;
    const groupedData = host.engine.getGroupedData();
    let uniqueRowValues = host.engine.getOrderedRowValues();
    if (!uniqueRowValues) {
      uniqueRowValues = [...new Set(groupedData.map((g) => {
        const keys = g.key ? g.key.split("|") : [];
        return keys[0];
      }))].filter(Boolean);
    }
    updatePaginationForData(host, uniqueRowValues);
  }
}
function updatePaginationForData(host, data) {
  const pageSize = host._pagination.pageSize;
  const totalPages = Math.ceil(data.length / pageSize) || 1;
  if (host._pagination.currentPage > totalPages) {
    host._pagination.currentPage = Math.max(1, totalPages);
  }
  host._pagination.totalPages = totalPages;
}
function getPaginatedData(host, data) {
  const start = (host._pagination.currentPage - 1) * host._pagination.pageSize;
  const end = start + host._pagination.pageSize;
  return data.slice(start, end);
}
function previousPage(host) {
  if (host._pagination.currentPage > 1) {
    host._pagination.currentPage--;
    renderSwitch(host);
    host.dispatchEvent(new CustomEvent("paginationChange", {
      detail: __spreadValues({}, host._pagination),
      bubbles: true,
      composed: true
    }));
  }
  updatePaginationInfo(host);
}
function nextPage(host) {
  if (host._pagination.currentPage < host._pagination.totalPages) {
    host._pagination.currentPage++;
    renderSwitch(host);
    host.dispatchEvent(new CustomEvent("paginationChange", {
      detail: __spreadValues({}, host._pagination),
      bubbles: true,
      composed: true
    }));
  }
  updatePaginationInfo(host);
}
function setPageSize(host, pageSize) {
  if (pageSize > 0) {
    host._pagination.pageSize = pageSize;
    host._pagination.currentPage = 1;
    calculatePaginationForCurrentView(host);
    renderSwitch(host);
    host.dispatchEvent(new CustomEvent("paginationChange", {
      detail: __spreadValues({}, host._pagination),
      bubbles: true,
      composed: true
    }));
  }
  updatePaginationInfo(host);
}
function goToPage(host, page) {
  if (page >= 1 && page <= host._pagination.totalPages) {
    host._pagination.currentPage = page;
    renderSwitch(host);
    host.dispatchEvent(new CustomEvent("paginationChange", {
      detail: __spreadValues({}, host._pagination),
      bubbles: true,
      composed: true
    }));
  }
  updatePaginationInfo(host);
}
function getState(host) {
  if (!host.engine) {
    throw new Error("Engine not initialized");
  }
  return host.engine.getState();
}
function sort(host, field, direction) {
  if (!host.engine) {
    console.error("Engine not initialized");
    return;
  }
  host.engine.sort(field, direction);
}
function setMeasures(host, measures) {
  if (!host.engine) {
    console.error("Engine not initialized");
    return;
  }
  host.engine.setMeasures(measures);
}
function setDimensions(host, dimensions) {
  if (!host.engine) {
    console.error("Engine not initialized");
    return;
  }
  host.engine.setDimensions(dimensions);
}
function setGroupConfig(host, groupConfig) {
  if (!host.engine) {
    console.error("Engine not initialized");
    return;
  }
  host.engine.setGroupConfig(groupConfig);
}
function setAggregation(host, type) {
  if (!host.engine) {
    console.error("Engine not initialized");
    return;
  }
  host.engine.setAggregation(type);
}
function formatValue(host, value, field) {
  if (!host.engine) {
    console.error("Engine not initialized");
    return String(value);
  }
  return host.engine.formatValue(value, field);
}
function getGroupedData(host) {
  if (!host.engine) {
    console.error("Engine not initialized");
    return [];
  }
  return host.engine.getGroupedData();
}
function getData(host) {
  if (!host.engine) {
    console.error("Engine not initialized");
    return [];
  }
  return host.engine.getState().rawData;
}
function getProcessedData(host) {
  if (!host.engine) {
    console.error("Engine not initialized");
    return null;
  }
  return host.engine.getState().processedData;
}
function setFilters(host, value) {
  console.log("Setting filters, current view mode:", host._showRawData ? "RAW" : "PROCESSED");
  console.log("New filter value:", value);
  if (host._showRawData) {
    host._rawFilters = value || [];
    console.log("Applied RAW filters:", host._rawFilters);
  } else {
    host._processedFilters = value || [];
    console.log("Applied PROCESSED filters:", host._processedFilters);
  }
  if (host.engine) {
    host.engine.setDataHandlingMode(host._showRawData ? "raw" : "processed");
    host.engine.applyFilters(value || []);
  }
  host._filters = value || [];
  host.setAttribute("filters", JSON.stringify(value));
}
function getFilters(host) {
  if (host._showRawData) {
    return host._rawFilters;
  } else {
    return host._processedFilters;
  }
}
function refresh(host) {
  if (!host.engine) {
    console.error("Engine not initialized");
    return;
  }
  host._filters = [];
  host.removeAttribute("filters");
  host.engine.reset();
  const filterValueInput = host.shadowRoot?.getElementById("filterValue");
  if (filterValueInput) {
    filterValueInput.value = "";
  }
}
function reset(host) {
  if (!host.engine) {
    console.error("Engine not initialized");
    return;
  }
  host._rawFilters = [];
  host._processedFilters = [];
  host._filters = [];
  host.removeAttribute("filters");
  host._pagination.currentPage = 1;
  host.engine.reset();
  clearFilterUI(host);
}
function clearFilterUI(host) {
  const filterValueInput = host.shadowRoot?.getElementById("filterValue");
  if (filterValueInput) {
    filterValueInput.value = "";
  }
  const filterFieldSelect = host.shadowRoot?.getElementById("filterField");
  const filterOperatorSelect = host.shadowRoot?.getElementById("filterOperator");
  if (filterFieldSelect) filterFieldSelect.selectedIndex = 0;
  if (filterOperatorSelect) filterOperatorSelect.selectedIndex = 0;
}
function exportToHTML(host, fileName = "pivot-table") {
  if (!host.engine) {
    console.error("Engine not initialized. Cannot export to HTML.");
    return;
  }
  host.engine.exportToHTML(fileName);
}
function exportToPDF(host, fileName = "pivot-table") {
  if (!host.engine) {
    console.error("Engine not initialized. Cannot export to PDF.");
    return;
  }
  host.engine.exportToPDF(fileName);
}
function exportToExcel(host, fileName = "pivot-table") {
  if (!host.engine) {
    console.error("Engine not initialized. Cannot export to Excel.");
    return;
  }
  host.engine.exportToExcel(fileName);
}
function openPrintDialog(host) {
  if (!host.engine) {
    console.error("Engine not initialized. Cannot open print dialog.");
    return;
  }
  host.engine.openPrintDialog();
}
function loadFromFile(host, file) {
  return new Promise((resolve, reject) => {
    const reader = new FileReader();
    reader.onload = (event) => {
      try {
        const result = event.target?.result;
        if (typeof result === "string") {
          const data = JSON.parse(result);
          host.data = data;
          resolve();
        } else {
          reject(new Error("Failed to read file as text"));
        }
      } catch (error) {
        reject(error);
      }
    };
    reader.onerror = () => reject(new Error("Failed to read file"));
    reader.readAsText(file);
  });
}
function loadFromUrl(host, url) {
  return fetch(url).then((response) => {
    if (!response.ok) {
      throw new Error(`Failed to fetch data from ${url}: ${response.status} ${response.statusText}`);
    }
    return response.json();
  }).then((data) => {
    host.data = data;
  });
}
function dragRow(host, fromIndex, toIndex) {
  if (!host.engine) {
    console.error("Engine not initialized");
    return;
  }
  host.engine.dragRow(fromIndex, toIndex);
}
function dragColumn(host, fromIndex, toIndex) {
  if (!host.engine) {
    console.error("Engine not initialized");
    return;
  }
  host.engine.dragColumn(fromIndex, toIndex);
}
function swapRows(host, fromIndex, toIndex) {
  if (!host.engine) {
    console.error("Engine not initialized");
    return;
  }
  try {
    if (host._showRawData) {
      host.engine.swapRawDataRows(fromIndex, toIndex);
    } else {
      host.engine.swapDataRows(fromIndex, toIndex);
    }
  } catch (error) {
    console.error("Row swap failed:", error);
  }
}
function swapColumns(host, fromIndex, toIndex) {
  if (!host.engine) {
    console.error("Engine not initialized");
    return;
  }
  try {
    if (host._showRawData) {
      const headers = host._data.length > 0 ? Object.keys(host._data[0]) : [];
      if (fromIndex < 0 || toIndex < 0 || fromIndex >= headers.length || toIndex >= headers.length) {
        console.error(`Invalid column indices for raw data swap: ${fromIndex}, ${toIndex}, total: ${headers.length}`);
        return;
      }
      if (!host._rawDataColumnOrder || host._rawDataColumnOrder.length === 0) {
        host._rawDataColumnOrder = [...headers];
      }
      const temp = host._rawDataColumnOrder[fromIndex];
      host._rawDataColumnOrder[fromIndex] = host._rawDataColumnOrder[toIndex];
      host._rawDataColumnOrder[toIndex] = temp;
      host.renderRawTable();
    } else {
      host.engine.swapDataColumns(fromIndex, toIndex);
      const newOrder = host.engine.getOrderedColumnValues();
      if (newOrder) host._processedColumnOrder = [...newOrder];
    }
  } catch (error) {
    console.error("Column swap failed:", error);
  }
}
function swapRawDataColumns(host, fromIndex, toIndex) {
  if (!host._data || host._data.length === 0) {
    console.error("No raw data available for column swap");
    return;
  }
  const headers = Object.keys(host._data[0]);
  if (fromIndex < 0 || toIndex < 0 || fromIndex >= headers.length || toIndex >= headers.length) {
    console.error(`Invalid column indices for raw data swap: ${fromIndex}, ${toIndex}, total: ${headers.length}`);
    return;
  }
  if (fromIndex === toIndex) return;
  if (!host._rawDataColumnOrder) host._rawDataColumnOrder = [...headers];
  const temp = host._rawDataColumnOrder[fromIndex];
  host._rawDataColumnOrder[fromIndex] = host._rawDataColumnOrder[toIndex];
  host._rawDataColumnOrder[toIndex] = temp;
  host.renderRawTable();
}
function setDragAndDropEnabled(host, enabled) {
  const table = host.shadowRoot?.querySelector("table");
  if (table) {
    if (enabled) {
      host.addDragListeners();
    } else {
      const draggableElements = table.querySelectorAll('[draggable="true"]');
      draggableElements.forEach((element) => {
        element.setAttribute("draggable", "false");
      });
    }
  }
}
function isDragAndDropEnabled(host) {
  const firstDraggableElement = host.shadowRoot?.querySelector('[draggable="true"]');
  return !!firstDraggableElement;
}
var PivotHeadElement = class extends HTMLElement {
  static get observedAttributes() {
    return ["data", "options", "filters", "pagination", "mode"];
  }
  constructor() {
    super();
    this._engineUnsubscribe = null;
    this._data = [];
    this._originalData = [];
    this._options = {};
    this._filters = [];
    this._rawFilters = [];
    this._processedFilters = [];
    this._rowGroups = [];
    this._columnGroups = [];
    this._pagination = {
      currentPage: 1,
      pageSize: 10,
      totalPages: 1
    };
    this._showRawData = false;
    this._rawDataColumnOrder = [];
    this._processedColumnOrder = [];
    this.draggedColumn = null;
    this.draggedRow = null;
    this.attachShadow({
      mode: "open"
    });
  }
  set data(value) {
    this._data = value || [];
    this._originalData = [...value || []];
    this.tryInitializeEngine();
  }
  get data() {
    return this._data;
  }
  set options(value) {
    this._options = value || {};
    this.tryInitializeEngine();
  }
  get options() {
    return this._options;
  }
  set filters(value) {
    setFilters(this, value);
  }
  get filters() {
    return getFilters(this);
  }
  set pagination(value) {
    this._pagination = __spreadValues(__spreadValues({}, this._pagination), value);
    this.setAttribute("pagination", JSON.stringify(this._pagination));
    this._renderSwitch();
  }
  get pagination() {
    return this._pagination;
  }
  handleEngineStateChange(state) {
    handleEngineStateChange(this, state);
  }
  tryInitializeEngine() {
    tryInitializeEngine(this);
  }
  connectedCallback() {
    if (!this._data.length && !Object.keys(this._options).length) {
      parseAttributesIfNeeded(this);
    }
    this._renderSwitch();
  }
  parseAttributesIfNeeded() {
    parseAttributesIfNeeded(this);
  }
  parseOtherAttributes() {
    parseOtherAttributes(this);
  }
  attributeChangedCallback(name, oldValue, newValue) {
    attributeChanged(this, name, oldValue, newValue);
  }
  _renderSwitch() {
    renderSwitch(this);
  }
  renderFullUI() {
    renderFullUI(this);
  }
  setupControls() {
    bindControls(this);
  }
  updatePaginationInfo() {
    updatePaginationInfo(this);
  }
  calculatePaginationForCurrentView() {
    calculatePaginationForCurrentView(this);
  }
  updatePaginationForData(data) {
    updatePaginationForData(this, data);
  }
  getPaginatedData(data) {
    return getPaginatedData(this, data);
  }
  renderRawTable() {
    renderRawTable(this);
  }
  createSortIcon(field) {
    return createSortIcon(this, field);
  }
  createProcessedSortIcon(field) {
    return createProcessedSortIcon(this, field);
  }
  addDragListeners() {
    addDragListeners(this);
  }
  handleSortClick(e) {
    handleSortClick(this, e);
  }
  handleDrillDownClick(e) {
    handleDrillDownClick(this, e);
  }
  getRawData() {
    return this._data;
  }
  getPagination() {
    return this._pagination;
  }
  getState() {
    return getState(this);
  }
  refresh() {
    refresh(this);
  }
  reset() {
    reset(this);
  }
  clearFilterUI() {
    clearFilterUI(this);
  }
  sort(field, direction) {
    sort(this, field, direction);
  }
  setMeasures(measures) {
    setMeasures(this, measures);
  }
  setDimensions(dimensions) {
    setDimensions(this, dimensions);
  }
  setGroupConfig(groupConfig) {
    setGroupConfig(this, groupConfig);
  }
  setAggregation(type) {
    setAggregation(this, type);
  }
  formatValue(value, field) {
    return formatValue(this, value, field);
  }
  getGroupedData() {
    return getGroupedData(this);
  }
  getFilters() {
    return this._filters;
  }
  getData() {
    return getData(this);
  }
  getProcessedData() {
    return getProcessedData(this);
  }
  exportToHTML(fileName = "pivot-table") {
    exportToHTML(this, fileName);
  }
  exportToPDF(fileName = "pivot-table") {
    exportToPDF(this, fileName);
  }
  exportToExcel(fileName = "pivot-table") {
    exportToExcel(this, fileName);
  }
  openPrintDialog() {
    openPrintDialog(this);
  }
  loadFromFile(file) {
    return loadFromFile(this, file);
  }
  loadFromUrl(url) {
    return loadFromUrl(this, url);
  }
  dragRow(fromIndex, toIndex) {
    dragRow(this, fromIndex, toIndex);
  }
  dragColumn(fromIndex, toIndex) {
    dragColumn(this, fromIndex, toIndex);
  }
  swapRows(fromIndex, toIndex) {
    swapRows(this, fromIndex, toIndex);
  }
  swapColumns(fromIndex, toIndex) {
    swapColumns(this, fromIndex, toIndex);
  }
  swapRawDataColumns(fromIndex, toIndex) {
    swapRawDataColumns(this, fromIndex, toIndex);
  }
  setDragAndDropEnabled(enabled) {
    setDragAndDropEnabled(this, enabled);
  }
  isDragAndDropEnabled() {
    return isDragAndDropEnabled(this);
  }
  swapDataRowsByIndex(fromIndex, toIndex) {
    this.swapRows(fromIndex, toIndex);
  }
  swapDataColumnsByIndex(fromIndex, toIndex) {
    this.swapColumns(fromIndex, toIndex);
  }
  previousPage() {
    previousPage(this);
  }
  nextPage() {
    nextPage(this);
  }
  setPageSize(pageSize) {
    setPageSize(this, pageSize);
  }
  goToPage(page) {
    goToPage(this, page);
  }
  setViewMode(mode) {
    const wantRaw = mode === "raw";
    if (this._showRawData === wantRaw) return;
    this._showRawData = wantRaw;
    if (!this.engine) return;
    try {
      this.engine.setDataHandlingMode(wantRaw ? "raw" : "processed");
      const currentFilters = wantRaw ? this._rawFilters : this._processedFilters;
      this.engine.applyFilters(currentFilters);
      this.dispatchEvent(new CustomEvent("viewModeChange", {
        detail: {
          mode
        },
        bubbles: true,
        composed: true
      }));
    } catch (err) {
      console.error("Failed to set view mode:", err);
    }
  }
  getViewMode() {
    return this._showRawData ? "raw" : "processed";
  }
};
customElements.define("pivot-head", PivotHeadElement);
export {
  PivotHeadElement
};
//# sourceMappingURL=pivot-head-2VQXMX42.js.map



================================================
FILE: .angular/cache/18.2.20/angular-pivothead-example/vite/deps/purify.es-78c333b1-RMLJBMGN.js
================================================
import "./chunk-WDMUDEB6.js";

// node_modules/@mindfiredigital/pivothead-angular/node_modules/@mindfiredigital/pivothead-web-component/node_modules/@mindfiredigital/pivothead/dist/purify.es-78c333b1.mjs
var {
  entries: Tt,
  setPrototypeOf: rt,
  isFrozen: Bt,
  getPrototypeOf: Yt,
  getOwnPropertyDescriptor: Xt
} = Object;
var {
  freeze: S,
  seal: O,
  create: _t
} = Object;
var {
  apply: we,
  construct: xe
} = typeof Reflect < "u" && Reflect;
S || (S = function(o) {
  return o;
});
O || (O = function(o) {
  return o;
});
we || (we = function(o, l, s) {
  return o.apply(l, s);
});
xe || (xe = function(o, l) {
  return new o(...l);
});
var le = R(Array.prototype.forEach);
var jt = R(Array.prototype.lastIndexOf);
var st = R(Array.prototype.pop);
var $ = R(Array.prototype.push);
var Vt = R(Array.prototype.splice);
var fe = R(String.prototype.toLowerCase);
var Ne = R(String.prototype.toString);
var lt = R(String.prototype.match);
var q = R(String.prototype.replace);
var $t = R(String.prototype.indexOf);
var qt = R(String.prototype.trim);
var L = R(Object.prototype.hasOwnProperty);
var A = R(RegExp.prototype.test);
var K = Kt(TypeError);
function R(r) {
  return function(o) {
    o instanceof RegExp && (o.lastIndex = 0);
    for (var l = arguments.length, s = new Array(l > 1 ? l - 1 : 0), T = 1; T < l; T++) s[T - 1] = arguments[T];
    return we(r, o, s);
  };
}
function Kt(r) {
  return function() {
    for (var o = arguments.length, l = new Array(o), s = 0; s < o; s++) l[s] = arguments[s];
    return xe(r, l);
  };
}
function a(r, o) {
  let l = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : fe;
  rt && rt(r, null);
  let s = o.length;
  for (; s--; ) {
    let T = o[s];
    if (typeof T == "string") {
      const N = l(T);
      N !== T && (Bt(o) || (o[s] = N), T = N);
    }
    r[T] = true;
  }
  return r;
}
function Zt(r) {
  for (let o = 0; o < r.length; o++) L(r, o) || (r[o] = null);
  return r;
}
function C(r) {
  const o = _t(null);
  for (const [l, s] of Tt(r)) L(r, l) && (Array.isArray(s) ? o[l] = Zt(s) : s && typeof s == "object" && s.constructor === Object ? o[l] = C(s) : o[l] = s);
  return o;
}
function Z(r, o) {
  for (; r !== null; ) {
    const s = Xt(r, o);
    if (s) {
      if (s.get) return R(s.get);
      if (typeof s.value == "function") return R(s.value);
    }
    r = Yt(r);
  }
  function l() {
    return null;
  }
  return l;
}
var ct = S(["a", "abbr", "acronym", "address", "area", "article", "aside", "audio", "b", "bdi", "bdo", "big", "blink", "blockquote", "body", "br", "button", "canvas", "caption", "center", "cite", "code", "col", "colgroup", "content", "data", "datalist", "dd", "decorator", "del", "details", "dfn", "dialog", "dir", "div", "dl", "dt", "element", "em", "fieldset", "figcaption", "figure", "font", "footer", "form", "h1", "h2", "h3", "h4", "h5", "h6", "head", "header", "hgroup", "hr", "html", "i", "img", "input", "ins", "kbd", "label", "legend", "li", "main", "map", "mark", "marquee", "menu", "menuitem", "meter", "nav", "nobr", "ol", "optgroup", "option", "output", "p", "picture", "pre", "progress", "q", "rp", "rt", "ruby", "s", "samp", "section", "select", "shadow", "small", "source", "spacer", "span", "strike", "strong", "style", "sub", "summary", "sup", "table", "tbody", "td", "template", "textarea", "tfoot", "th", "thead", "time", "tr", "track", "tt", "u", "ul", "var", "video", "wbr"]);
var be = S(["svg", "a", "altglyph", "altglyphdef", "altglyphitem", "animatecolor", "animatemotion", "animatetransform", "circle", "clippath", "defs", "desc", "ellipse", "filter", "font", "g", "glyph", "glyphref", "hkern", "image", "line", "lineargradient", "marker", "mask", "metadata", "mpath", "path", "pattern", "polygon", "polyline", "radialgradient", "rect", "stop", "style", "switch", "symbol", "text", "textpath", "title", "tref", "tspan", "view", "vkern"]);
var Ie = S(["feBlend", "feColorMatrix", "feComponentTransfer", "feComposite", "feConvolveMatrix", "feDiffuseLighting", "feDisplacementMap", "feDistantLight", "feDropShadow", "feFlood", "feFuncA", "feFuncB", "feFuncG", "feFuncR", "feGaussianBlur", "feImage", "feMerge", "feMergeNode", "feMorphology", "feOffset", "fePointLight", "feSpecularLighting", "feSpotLight", "feTile", "feTurbulence"]);
var Jt = S(["animate", "color-profile", "cursor", "discard", "font-face", "font-face-format", "font-face-name", "font-face-src", "font-face-uri", "foreignobject", "hatch", "hatchpath", "mesh", "meshgradient", "meshpatch", "meshrow", "missing-glyph", "script", "set", "solidcolor", "unknown", "use"]);
var Me = S(["math", "menclose", "merror", "mfenced", "mfrac", "mglyph", "mi", "mlabeledtr", "mmultiscripts", "mn", "mo", "mover", "mpadded", "mphantom", "mroot", "mrow", "ms", "mspace", "msqrt", "mstyle", "msub", "msup", "msubsup", "mtable", "mtd", "mtext", "mtr", "munder", "munderover", "mprescripts"]);
var Qt = S(["maction", "maligngroup", "malignmark", "mlongdiv", "mscarries", "mscarry", "msgroup", "mstack", "msline", "msrow", "semantics", "annotation", "annotation-xml", "mprescripts", "none"]);
var ft = S(["#text"]);
var ut = S(["accept", "action", "align", "alt", "autocapitalize", "autocomplete", "autopictureinpicture", "autoplay", "background", "bgcolor", "border", "capture", "cellpadding", "cellspacing", "checked", "cite", "class", "clear", "color", "cols", "colspan", "controls", "controlslist", "coords", "crossorigin", "datetime", "decoding", "default", "dir", "disabled", "disablepictureinpicture", "disableremoteplayback", "download", "draggable", "enctype", "enterkeyhint", "face", "for", "headers", "height", "hidden", "high", "href", "hreflang", "id", "inputmode", "integrity", "ismap", "kind", "label", "lang", "list", "loading", "loop", "low", "max", "maxlength", "media", "method", "min", "minlength", "multiple", "muted", "name", "nonce", "noshade", "novalidate", "nowrap", "open", "optimum", "pattern", "placeholder", "playsinline", "popover", "popovertarget", "popovertargetaction", "poster", "preload", "pubdate", "radiogroup", "readonly", "rel", "required", "rev", "reversed", "role", "rows", "rowspan", "spellcheck", "scope", "selected", "shape", "size", "sizes", "span", "srclang", "start", "src", "srcset", "step", "style", "summary", "tabindex", "title", "translate", "type", "usemap", "valign", "value", "width", "wrap", "xmlns", "slot"]);
var Ce = S(["accent-height", "accumulate", "additive", "alignment-baseline", "amplitude", "ascent", "attributename", "attributetype", "azimuth", "basefrequency", "baseline-shift", "begin", "bias", "by", "class", "clip", "clippathunits", "clip-path", "clip-rule", "color", "color-interpolation", "color-interpolation-filters", "color-profile", "color-rendering", "cx", "cy", "d", "dx", "dy", "diffuseconstant", "direction", "display", "divisor", "dur", "edgemode", "elevation", "end", "exponent", "fill", "fill-opacity", "fill-rule", "filter", "filterunits", "flood-color", "flood-opacity", "font-family", "font-size", "font-size-adjust", "font-stretch", "font-style", "font-variant", "font-weight", "fx", "fy", "g1", "g2", "glyph-name", "glyphref", "gradientunits", "gradienttransform", "height", "href", "id", "image-rendering", "in", "in2", "intercept", "k", "k1", "k2", "k3", "k4", "kerning", "keypoints", "keysplines", "keytimes", "lang", "lengthadjust", "letter-spacing", "kernelmatrix", "kernelunitlength", "lighting-color", "local", "marker-end", "marker-mid", "marker-start", "markerheight", "markerunits", "markerwidth", "maskcontentunits", "maskunits", "max", "mask", "media", "method", "mode", "min", "name", "numoctaves", "offset", "operator", "opacity", "order", "orient", "orientation", "origin", "overflow", "paint-order", "path", "pathlength", "patterncontentunits", "patterntransform", "patternunits", "points", "preservealpha", "preserveaspectratio", "primitiveunits", "r", "rx", "ry", "radius", "refx", "refy", "repeatcount", "repeatdur", "restart", "result", "rotate", "scale", "seed", "shape-rendering", "slope", "specularconstant", "specularexponent", "spreadmethod", "startoffset", "stddeviation", "stitchtiles", "stop-color", "stop-opacity", "stroke-dasharray", "stroke-dashoffset", "stroke-linecap", "stroke-linejoin", "stroke-miterlimit", "stroke-opacity", "stroke", "stroke-width", "style", "surfacescale", "systemlanguage", "tabindex", "tablevalues", "targetx", "targety", "transform", "transform-origin", "text-anchor", "text-decoration", "text-rendering", "textlength", "type", "u1", "u2", "unicode", "values", "viewbox", "visibility", "version", "vert-adv-y", "vert-origin-x", "vert-origin-y", "width", "word-spacing", "wrap", "writing-mode", "xchannelselector", "ychannelselector", "x", "x1", "x2", "xmlns", "y", "y1", "y2", "z", "zoomandpan"]);
var mt = S(["accent", "accentunder", "align", "bevelled", "close", "columnsalign", "columnlines", "columnspan", "denomalign", "depth", "dir", "display", "displaystyle", "encoding", "fence", "frame", "height", "href", "id", "largeop", "length", "linethickness", "lspace", "lquote", "mathbackground", "mathcolor", "mathsize", "mathvariant", "maxsize", "minsize", "movablelimits", "notation", "numalign", "open", "rowalign", "rowlines", "rowspacing", "rowspan", "rspace", "rquote", "scriptlevel", "scriptminsize", "scriptsizemultiplier", "selection", "separator", "separators", "stretchy", "subscriptshift", "supscriptshift", "symmetric", "voffset", "width", "xmlns"]);
var ce = S(["xlink:href", "xml:id", "xlink:title", "xml:space", "xmlns:xlink"]);
var en = O(/\{\{[\w\W]*|[\w\W]*\}\}/gm);
var tn = O(/<%[\w\W]*|[\w\W]*%>/gm);
var nn = O(/\$\{[\w\W]*/gm);
var on = O(/^data-[\-\w.\u00B7-\uFFFF]+$/);
var an = O(/^aria-[\-\w]+$/);
var Et = O(
  /^(?:(?:(?:f|ht)tps?|mailto|tel|callto|sms|cid|xmpp|matrix):|[^a-z]|[a-z+.\-]+(?:[^a-z+.\-:]|$))/i
  // eslint-disable-line no-useless-escape
);
var rn = O(/^(?:\w+script|data):/i);
var sn = O(
  /[\u0000-\u0020\u00A0\u1680\u180E\u2000-\u2029\u205F\u3000]/g
  // eslint-disable-line no-control-regex
);
var gt = O(/^html$/i);
var ln = O(/^[a-z][.\w]*(-[.\w]+)+$/i);
var pt = Object.freeze({
  __proto__: null,
  ARIA_ATTR: an,
  ATTR_WHITESPACE: sn,
  CUSTOM_ELEMENT: ln,
  DATA_ATTR: on,
  DOCTYPE_NAME: gt,
  ERB_EXPR: tn,
  IS_ALLOWED_URI: Et,
  IS_SCRIPT_OR_DATA: rn,
  MUSTACHE_EXPR: en,
  TMPLIT_EXPR: nn
});
var J = {
  element: 1,
  attribute: 2,
  text: 3,
  cdataSection: 4,
  entityReference: 5,
  // Deprecated
  entityNode: 6,
  // Deprecated
  progressingInstruction: 7,
  comment: 8,
  document: 9,
  documentType: 10,
  documentFragment: 11,
  notation: 12
  // Deprecated
};
var cn = function() {
  return typeof window > "u" ? null : window;
};
var fn = function(o, l) {
  if (typeof o != "object" || typeof o.createPolicy != "function") return null;
  let s = null;
  const T = "data-tt-policy-suffix";
  l && l.hasAttribute(T) && (s = l.getAttribute(T));
  const N = "dompurify" + (s ? "#" + s : "");
  try {
    return o.createPolicy(N, {
      createHTML(x) {
        return x;
      },
      createScriptURL(x) {
        return x;
      }
    });
  } catch {
    return console.warn("TrustedTypes policy " + N + " could not be created."), null;
  }
};
var dt = function() {
  return {
    afterSanitizeAttributes: [],
    afterSanitizeElements: [],
    afterSanitizeShadowDOM: [],
    beforeSanitizeAttributes: [],
    beforeSanitizeElements: [],
    beforeSanitizeShadowDOM: [],
    uponSanitizeAttribute: [],
    uponSanitizeElement: [],
    uponSanitizeShadowNode: []
  };
};
function ht() {
  let r = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : cn();
  const o = (i) => ht(i);
  if (o.version = "3.2.6", o.removed = [], !r || !r.document || r.document.nodeType !== J.document || !r.Element) return o.isSupported = false, o;
  let {
    document: l
  } = r;
  const s = l, T = s.currentScript, {
    DocumentFragment: N,
    HTMLTemplateElement: x,
    Node: ue,
    Element: Pe,
    NodeFilter: G,
    NamedNodeMap: At = r.NamedNodeMap || r.MozNamedAttrMap,
    HTMLFormElement: St,
    DOMParser: Rt,
    trustedTypes: Q
  } = r, W = Pe.prototype, yt = Z(W, "cloneNode"), Ot = Z(W, "remove"), Lt = Z(W, "nextSibling"), Dt = Z(W, "childNodes"), ee = Z(W, "parentNode");
  if (typeof x == "function") {
    const i = l.createElement("template");
    i.content && i.content.ownerDocument && (l = i.content.ownerDocument);
  }
  let g, B = "";
  const {
    implementation: me,
    createNodeIterator: Nt,
    createDocumentFragment: bt,
    getElementsByTagName: It
  } = l, {
    importNode: Mt
  } = s;
  let h = dt();
  o.isSupported = typeof Tt == "function" && typeof ee == "function" && me && me.createHTMLDocument !== void 0;
  const {
    MUSTACHE_EXPR: pe,
    ERB_EXPR: de,
    TMPLIT_EXPR: Te,
    DATA_ATTR: Ct,
    ARIA_ATTR: wt,
    IS_SCRIPT_OR_DATA: xt,
    ATTR_WHITESPACE: ve,
    CUSTOM_ELEMENT: Pt
  } = pt;
  let {
    IS_ALLOWED_URI: ke
  } = pt, m = null;
  const Ue = a({}, [...ct, ...be, ...Ie, ...Me, ...ft]);
  let d = null;
  const Fe = a({}, [...ut, ...Ce, ...mt, ...ce]);
  let f = Object.seal(_t(null, {
    tagNameCheck: {
      writable: true,
      configurable: false,
      enumerable: true,
      value: null
    },
    attributeNameCheck: {
      writable: true,
      configurable: false,
      enumerable: true,
      value: null
    },
    allowCustomizedBuiltInElements: {
      writable: true,
      configurable: false,
      enumerable: true,
      value: false
    }
  })), Y = null, _e = null, He = true, Ee = true, ze = false, Ge = true, P = false, te = true, w = false, ge = false, he = false, v = false, ne = false, oe = false, We = true, Be = false;
  const vt = "user-content-";
  let Ae = true, X = false, k = {}, U = null;
  const Ye = a({}, ["annotation-xml", "audio", "colgroup", "desc", "foreignobject", "head", "iframe", "math", "mi", "mn", "mo", "ms", "mtext", "noembed", "noframes", "noscript", "plaintext", "script", "style", "svg", "template", "thead", "title", "video", "xmp"]);
  let Xe = null;
  const je = a({}, ["audio", "video", "img", "source", "image", "track"]);
  let Se = null;
  const Ve = a({}, ["alt", "class", "for", "id", "label", "name", "pattern", "placeholder", "role", "summary", "title", "value", "style", "xmlns"]), ie = "http://www.w3.org/1998/Math/MathML", ae = "http://www.w3.org/2000/svg", b = "http://www.w3.org/1999/xhtml";
  let F = b, Re = false, ye = null;
  const kt = a({}, [ie, ae, b], Ne);
  let re = a({}, ["mi", "mo", "mn", "ms", "mtext"]), se = a({}, ["annotation-xml"]);
  const Ut = a({}, ["title", "style", "font", "a", "script"]);
  let j = null;
  const Ft = ["application/xhtml+xml", "text/html"], Ht = "text/html";
  let p = null, H = null;
  const zt = l.createElement("form"), $e = function(e) {
    return e instanceof RegExp || e instanceof Function;
  }, Oe = function() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    if (!(H && H === e)) {
      if ((!e || typeof e != "object") && (e = {}), e = C(e), j = // eslint-disable-next-line unicorn/prefer-includes
      Ft.indexOf(e.PARSER_MEDIA_TYPE) === -1 ? Ht : e.PARSER_MEDIA_TYPE, p = j === "application/xhtml+xml" ? Ne : fe, m = L(e, "ALLOWED_TAGS") ? a({}, e.ALLOWED_TAGS, p) : Ue, d = L(e, "ALLOWED_ATTR") ? a({}, e.ALLOWED_ATTR, p) : Fe, ye = L(e, "ALLOWED_NAMESPACES") ? a({}, e.ALLOWED_NAMESPACES, Ne) : kt, Se = L(e, "ADD_URI_SAFE_ATTR") ? a(C(Ve), e.ADD_URI_SAFE_ATTR, p) : Ve, Xe = L(e, "ADD_DATA_URI_TAGS") ? a(C(je), e.ADD_DATA_URI_TAGS, p) : je, U = L(e, "FORBID_CONTENTS") ? a({}, e.FORBID_CONTENTS, p) : Ye, Y = L(e, "FORBID_TAGS") ? a({}, e.FORBID_TAGS, p) : C({}), _e = L(e, "FORBID_ATTR") ? a({}, e.FORBID_ATTR, p) : C({}), k = L(e, "USE_PROFILES") ? e.USE_PROFILES : false, He = e.ALLOW_ARIA_ATTR !== false, Ee = e.ALLOW_DATA_ATTR !== false, ze = e.ALLOW_UNKNOWN_PROTOCOLS || false, Ge = e.ALLOW_SELF_CLOSE_IN_ATTR !== false, P = e.SAFE_FOR_TEMPLATES || false, te = e.SAFE_FOR_XML !== false, w = e.WHOLE_DOCUMENT || false, v = e.RETURN_DOM || false, ne = e.RETURN_DOM_FRAGMENT || false, oe = e.RETURN_TRUSTED_TYPE || false, he = e.FORCE_BODY || false, We = e.SANITIZE_DOM !== false, Be = e.SANITIZE_NAMED_PROPS || false, Ae = e.KEEP_CONTENT !== false, X = e.IN_PLACE || false, ke = e.ALLOWED_URI_REGEXP || Et, F = e.NAMESPACE || b, re = e.MATHML_TEXT_INTEGRATION_POINTS || re, se = e.HTML_INTEGRATION_POINTS || se, f = e.CUSTOM_ELEMENT_HANDLING || {}, e.CUSTOM_ELEMENT_HANDLING && $e(e.CUSTOM_ELEMENT_HANDLING.tagNameCheck) && (f.tagNameCheck = e.CUSTOM_ELEMENT_HANDLING.tagNameCheck), e.CUSTOM_ELEMENT_HANDLING && $e(e.CUSTOM_ELEMENT_HANDLING.attributeNameCheck) && (f.attributeNameCheck = e.CUSTOM_ELEMENT_HANDLING.attributeNameCheck), e.CUSTOM_ELEMENT_HANDLING && typeof e.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements == "boolean" && (f.allowCustomizedBuiltInElements = e.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements), P && (Ee = false), ne && (v = true), k && (m = a({}, ft), d = [], k.html === true && (a(m, ct), a(d, ut)), k.svg === true && (a(m, be), a(d, Ce), a(d, ce)), k.svgFilters === true && (a(m, Ie), a(d, Ce), a(d, ce)), k.mathMl === true && (a(m, Me), a(d, mt), a(d, ce))), e.ADD_TAGS && (m === Ue && (m = C(m)), a(m, e.ADD_TAGS, p)), e.ADD_ATTR && (d === Fe && (d = C(d)), a(d, e.ADD_ATTR, p)), e.ADD_URI_SAFE_ATTR && a(Se, e.ADD_URI_SAFE_ATTR, p), e.FORBID_CONTENTS && (U === Ye && (U = C(U)), a(U, e.FORBID_CONTENTS, p)), Ae && (m["#text"] = true), w && a(m, ["html", "head", "body"]), m.table && (a(m, ["tbody"]), delete Y.tbody), e.TRUSTED_TYPES_POLICY) {
        if (typeof e.TRUSTED_TYPES_POLICY.createHTML != "function") throw K('TRUSTED_TYPES_POLICY configuration option must provide a "createHTML" hook.');
        if (typeof e.TRUSTED_TYPES_POLICY.createScriptURL != "function") throw K('TRUSTED_TYPES_POLICY configuration option must provide a "createScriptURL" hook.');
        g = e.TRUSTED_TYPES_POLICY, B = g.createHTML("");
      } else g === void 0 && (g = fn(Q, T)), g !== null && typeof B == "string" && (B = g.createHTML(""));
      S && S(e), H = e;
    }
  }, qe = a({}, [...be, ...Ie, ...Jt]), Ke = a({}, [...Me, ...Qt]), Gt = function(e) {
    let t = ee(e);
    (!t || !t.tagName) && (t = {
      namespaceURI: F,
      tagName: "template"
    });
    const n = fe(e.tagName), c = fe(t.tagName);
    return ye[e.namespaceURI] ? e.namespaceURI === ae ? t.namespaceURI === b ? n === "svg" : t.namespaceURI === ie ? n === "svg" && (c === "annotation-xml" || re[c]) : !!qe[n] : e.namespaceURI === ie ? t.namespaceURI === b ? n === "math" : t.namespaceURI === ae ? n === "math" && se[c] : !!Ke[n] : e.namespaceURI === b ? t.namespaceURI === ae && !se[c] || t.namespaceURI === ie && !re[c] ? false : !Ke[n] && (Ut[n] || !qe[n]) : !!(j === "application/xhtml+xml" && ye[e.namespaceURI]) : false;
  }, D = function(e) {
    $(o.removed, {
      element: e
    });
    try {
      ee(e).removeChild(e);
    } catch {
      Ot(e);
    }
  }, z = function(e, t) {
    try {
      $(o.removed, {
        attribute: t.getAttributeNode(e),
        from: t
      });
    } catch {
      $(o.removed, {
        attribute: null,
        from: t
      });
    }
    if (t.removeAttribute(e), e === "is") if (v || ne) try {
      D(t);
    } catch {
    }
    else try {
      t.setAttribute(e, "");
    } catch {
    }
  }, Ze = function(e) {
    let t = null, n = null;
    if (he) e = "<remove></remove>" + e;
    else {
      const u = lt(e, /^[\r\n\t ]+/);
      n = u && u[0];
    }
    j === "application/xhtml+xml" && F === b && (e = '<html xmlns="http://www.w3.org/1999/xhtml"><head></head><body>' + e + "</body></html>");
    const c = g ? g.createHTML(e) : e;
    if (F === b) try {
      t = new Rt().parseFromString(c, j);
    } catch {
    }
    if (!t || !t.documentElement) {
      t = me.createDocument(F, "template", null);
      try {
        t.documentElement.innerHTML = Re ? B : c;
      } catch {
      }
    }
    const _ = t.body || t.documentElement;
    return e && n && _.insertBefore(l.createTextNode(n), _.childNodes[0] || null), F === b ? It.call(t, w ? "html" : "body")[0] : w ? t.documentElement : _;
  }, Je = function(e) {
    return Nt.call(
      e.ownerDocument || e,
      e,
      // eslint-disable-next-line no-bitwise
      G.SHOW_ELEMENT | G.SHOW_COMMENT | G.SHOW_TEXT | G.SHOW_PROCESSING_INSTRUCTION | G.SHOW_CDATA_SECTION,
      null
    );
  }, Le = function(e) {
    return e instanceof St && (typeof e.nodeName != "string" || typeof e.textContent != "string" || typeof e.removeChild != "function" || !(e.attributes instanceof At) || typeof e.removeAttribute != "function" || typeof e.setAttribute != "function" || typeof e.namespaceURI != "string" || typeof e.insertBefore != "function" || typeof e.hasChildNodes != "function");
  }, Qe = function(e) {
    return typeof ue == "function" && e instanceof ue;
  };
  function I(i, e, t) {
    le(i, (n) => {
      n.call(o, e, t, H);
    });
  }
  const et = function(e) {
    let t = null;
    if (I(h.beforeSanitizeElements, e, null), Le(e)) return D(e), true;
    const n = p(e.nodeName);
    if (I(h.uponSanitizeElement, e, {
      tagName: n,
      allowedTags: m
    }), te && e.hasChildNodes() && !Qe(e.firstElementChild) && A(/<[/\w!]/g, e.innerHTML) && A(/<[/\w!]/g, e.textContent) || e.nodeType === J.progressingInstruction || te && e.nodeType === J.comment && A(/<[/\w]/g, e.data)) return D(e), true;
    if (!m[n] || Y[n]) {
      if (!Y[n] && nt(n) && (f.tagNameCheck instanceof RegExp && A(f.tagNameCheck, n) || f.tagNameCheck instanceof Function && f.tagNameCheck(n))) return false;
      if (Ae && !U[n]) {
        const c = ee(e) || e.parentNode, _ = Dt(e) || e.childNodes;
        if (_ && c) {
          const u = _.length;
          for (let y = u - 1; y >= 0; --y) {
            const M = yt(_[y], true);
            M.__removalCount = (e.__removalCount || 0) + 1, c.insertBefore(M, Lt(e));
          }
        }
      }
      return D(e), true;
    }
    return e instanceof Pe && !Gt(e) || (n === "noscript" || n === "noembed" || n === "noframes") && A(/<\/no(script|embed|frames)/i, e.innerHTML) ? (D(e), true) : (P && e.nodeType === J.text && (t = e.textContent, le([pe, de, Te], (c) => {
      t = q(t, c, " ");
    }), e.textContent !== t && ($(o.removed, {
      element: e.cloneNode()
    }), e.textContent = t)), I(h.afterSanitizeElements, e, null), false);
  }, tt = function(e, t, n) {
    if (We && (t === "id" || t === "name") && (n in l || n in zt)) return false;
    if (!(Ee && !_e[t] && A(Ct, t))) {
      if (!(He && A(wt, t))) {
        if (!d[t] || _e[t]) {
          if (
            // First condition does a very basic check if a) it's basically a valid custom element tagname AND
            // b) if the tagName passes whatever the user has configured for CUSTOM_ELEMENT_HANDLING.tagNameCheck
            // and c) if the attribute name passes whatever the user has configured for CUSTOM_ELEMENT_HANDLING.attributeNameCheck
            !(nt(e) && (f.tagNameCheck instanceof RegExp && A(f.tagNameCheck, e) || f.tagNameCheck instanceof Function && f.tagNameCheck(e)) && (f.attributeNameCheck instanceof RegExp && A(f.attributeNameCheck, t) || f.attributeNameCheck instanceof Function && f.attributeNameCheck(t)) || // Alternative, second condition checks if it's an `is`-attribute, AND
            // the value passes whatever the user has configured for CUSTOM_ELEMENT_HANDLING.tagNameCheck
            t === "is" && f.allowCustomizedBuiltInElements && (f.tagNameCheck instanceof RegExp && A(f.tagNameCheck, n) || f.tagNameCheck instanceof Function && f.tagNameCheck(n)))
          ) return false;
        } else if (!Se[t]) {
          if (!A(ke, q(n, ve, ""))) {
            if (!((t === "src" || t === "xlink:href" || t === "href") && e !== "script" && $t(n, "data:") === 0 && Xe[e])) {
              if (!(ze && !A(xt, q(n, ve, "")))) {
                if (n) return false;
              }
            }
          }
        }
      }
    }
    return true;
  }, nt = function(e) {
    return e !== "annotation-xml" && lt(e, Pt);
  }, ot = function(e) {
    I(h.beforeSanitizeAttributes, e, null);
    const {
      attributes: t
    } = e;
    if (!t || Le(e)) return;
    const n = {
      attrName: "",
      attrValue: "",
      keepAttr: true,
      allowedAttributes: d,
      forceKeepAttr: void 0
    };
    let c = t.length;
    for (; c--; ) {
      const _ = t[c], {
        name: u,
        namespaceURI: y,
        value: M
      } = _, V = p(u), De = M;
      let E = u === "value" ? De : qt(De);
      if (n.attrName = V, n.attrValue = E, n.keepAttr = true, n.forceKeepAttr = void 0, I(h.uponSanitizeAttribute, e, n), E = n.attrValue, Be && (V === "id" || V === "name") && (z(u, e), E = vt + E), te && A(/((--!?|])>)|<\/(style|title)/i, E)) {
        z(u, e);
        continue;
      }
      if (n.forceKeepAttr) continue;
      if (!n.keepAttr) {
        z(u, e);
        continue;
      }
      if (!Ge && A(/\/>/i, E)) {
        z(u, e);
        continue;
      }
      P && le([pe, de, Te], (at) => {
        E = q(E, at, " ");
      });
      const it = p(e.nodeName);
      if (!tt(it, V, E)) {
        z(u, e);
        continue;
      }
      if (g && typeof Q == "object" && typeof Q.getAttributeType == "function" && !y) switch (Q.getAttributeType(it, V)) {
        case "TrustedHTML": {
          E = g.createHTML(E);
          break;
        }
        case "TrustedScriptURL": {
          E = g.createScriptURL(E);
          break;
        }
      }
      if (E !== De) try {
        y ? e.setAttributeNS(y, u, E) : e.setAttribute(u, E), Le(e) ? D(e) : st(o.removed);
      } catch {
        z(u, e);
      }
    }
    I(h.afterSanitizeAttributes, e, null);
  }, Wt = function i(e) {
    let t = null;
    const n = Je(e);
    for (I(h.beforeSanitizeShadowDOM, e, null); t = n.nextNode(); ) I(h.uponSanitizeShadowNode, t, null), et(t), ot(t), t.content instanceof N && i(t.content);
    I(h.afterSanitizeShadowDOM, e, null);
  };
  return o.sanitize = function(i) {
    let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, t = null, n = null, c = null, _ = null;
    if (Re = !i, Re && (i = "<!-->"), typeof i != "string" && !Qe(i)) if (typeof i.toString == "function") {
      if (i = i.toString(), typeof i != "string") throw K("dirty is not a string, aborting");
    } else throw K("toString is not a function");
    if (!o.isSupported) return i;
    if (ge || Oe(e), o.removed = [], typeof i == "string" && (X = false), X) {
      if (i.nodeName) {
        const M = p(i.nodeName);
        if (!m[M] || Y[M]) throw K("root node is forbidden and cannot be sanitized in-place");
      }
    } else if (i instanceof ue) t = Ze("<!---->"), n = t.ownerDocument.importNode(i, true), n.nodeType === J.element && n.nodeName === "BODY" || n.nodeName === "HTML" ? t = n : t.appendChild(n);
    else {
      if (!v && !P && !w && // eslint-disable-next-line unicorn/prefer-includes
      i.indexOf("<") === -1) return g && oe ? g.createHTML(i) : i;
      if (t = Ze(i), !t) return v ? null : oe ? B : "";
    }
    t && he && D(t.firstChild);
    const u = Je(X ? i : t);
    for (; c = u.nextNode(); ) et(c), ot(c), c.content instanceof N && Wt(c.content);
    if (X) return i;
    if (v) {
      if (ne) for (_ = bt.call(t.ownerDocument); t.firstChild; ) _.appendChild(t.firstChild);
      else _ = t;
      return (d.shadowroot || d.shadowrootmode) && (_ = Mt.call(s, _, true)), _;
    }
    let y = w ? t.outerHTML : t.innerHTML;
    return w && m["!doctype"] && t.ownerDocument && t.ownerDocument.doctype && t.ownerDocument.doctype.name && A(gt, t.ownerDocument.doctype.name) && (y = "<!DOCTYPE " + t.ownerDocument.doctype.name + `>
` + y), P && le([pe, de, Te], (M) => {
      y = q(y, M, " ");
    }), g && oe ? g.createHTML(y) : y;
  }, o.setConfig = function() {
    let i = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    Oe(i), ge = true;
  }, o.clearConfig = function() {
    H = null, ge = false;
  }, o.isValidAttribute = function(i, e, t) {
    H || Oe({});
    const n = p(i), c = p(e);
    return tt(n, c, t);
  }, o.addHook = function(i, e) {
    typeof e == "function" && $(h[i], e);
  }, o.removeHook = function(i, e) {
    if (e !== void 0) {
      const t = jt(h[i], e);
      return t === -1 ? void 0 : Vt(h[i], t, 1)[0];
    }
    return st(h[i]);
  }, o.removeHooks = function(i) {
    h[i] = [];
  }, o.removeAllHooks = function() {
    h = dt();
  }, o;
}
var un = ht();
export {
  un as default
};
/*! Bundled license information:

@mindfiredigital/pivothead/dist/purify.es-78c333b1.mjs:
  (*! @license DOMPurify 3.2.6 | (c) Cure53 and other contributors | Released under the Apache license 2.0 and Mozilla Public License 2.0 | github.com/cure53/DOMPurify/blob/3.2.6/LICENSE *)
*/
//# sourceMappingURL=purify.es-78c333b1-RMLJBMGN.js.map



================================================
FILE: .angular/cache/18.2.20/angular-pivothead-example/vite/deps/rxjs.js
================================================
import {
  NEVER,
  VirtualAction,
  VirtualTimeScheduler,
  animationFrame,
  animationFrameScheduler,
  animationFrames,
  asap,
  asapScheduler,
  bindCallback,
  bindNodeCallback,
  connectable,
  defer,
  firstValueFrom,
  forkJoin,
  fromEvent,
  fromEventPattern,
  generate,
  iif,
  isObservable,
  lastValueFrom,
  merge,
  never,
  pairs,
  partition,
  queue,
  queueScheduler,
  range,
  using
} from "./chunk-HHOT2EEL.js";
import {
  ArgumentOutOfRangeError,
  AsyncSubject,
  BehaviorSubject,
  ConnectableObservable,
  EMPTY,
  EmptyError,
  NotFoundError,
  Notification,
  NotificationKind,
  ObjectUnsubscribedError,
  Observable,
  ReplaySubject,
  Scheduler,
  SequenceError,
  Subject,
  Subscriber,
  Subscription,
  TimeoutError,
  UnsubscriptionError,
  async,
  asyncScheduler,
  audit,
  auditTime,
  buffer,
  bufferCount,
  bufferTime,
  bufferToggle,
  bufferWhen,
  catchError,
  combineAll,
  combineLatest,
  combineLatestAll,
  combineLatestWith,
  concat,
  concatAll,
  concatMap,
  concatMapTo,
  concatWith,
  config,
  connect,
  count,
  debounce,
  debounceTime,
  defaultIfEmpty,
  delay,
  delayWhen,
  dematerialize,
  distinct,
  distinctUntilChanged,
  distinctUntilKeyChanged,
  elementAt,
  empty,
  endWith,
  every,
  exhaust,
  exhaustAll,
  exhaustMap,
  expand,
  filter,
  finalize,
  find,
  findIndex,
  first,
  flatMap,
  from,
  groupBy,
  identity,
  ignoreElements,
  interval,
  isEmpty,
  last,
  map,
  mapTo,
  materialize,
  max,
  mergeAll,
  mergeMap,
  mergeMapTo,
  mergeScan,
  mergeWith,
  min,
  multicast,
  noop,
  observable,
  observeOn,
  of,
  onErrorResumeNext,
  onErrorResumeNextWith,
  pairwise,
  pipe,
  pluck,
  publish,
  publishBehavior,
  publishLast,
  publishReplay,
  race,
  raceWith,
  reduce,
  refCount,
  repeat,
  repeatWhen,
  retry,
  retryWhen,
  sample,
  sampleTime,
  scan,
  scheduled,
  sequenceEqual,
  share,
  shareReplay,
  single,
  skip,
  skipLast,
  skipUntil,
  skipWhile,
  startWith,
  subscribeOn,
  switchAll,
  switchMap,
  switchMapTo,
  switchScan,
  take,
  takeLast,
  takeUntil,
  takeWhile,
  tap,
  throttle,
  throttleTime,
  throwError,
  throwIfEmpty,
  timeInterval,
  timeout,
  timeoutWith,
  timer,
  timestamp,
  toArray,
  window,
  windowCount,
  windowTime,
  windowToggle,
  windowWhen,
  withLatestFrom,
  zip,
  zipAll,
  zipWith
} from "./chunk-OVFEQSRS.js";
import "./chunk-WDMUDEB6.js";
export {
  ArgumentOutOfRangeError,
  AsyncSubject,
  BehaviorSubject,
  ConnectableObservable,
  EMPTY,
  EmptyError,
  NEVER,
  NotFoundError,
  Notification,
  NotificationKind,
  ObjectUnsubscribedError,
  Observable,
  ReplaySubject,
  Scheduler,
  SequenceError,
  Subject,
  Subscriber,
  Subscription,
  TimeoutError,
  UnsubscriptionError,
  VirtualAction,
  VirtualTimeScheduler,
  animationFrame,
  animationFrameScheduler,
  animationFrames,
  asap,
  asapScheduler,
  async,
  asyncScheduler,
  audit,
  auditTime,
  bindCallback,
  bindNodeCallback,
  buffer,
  bufferCount,
  bufferTime,
  bufferToggle,
  bufferWhen,
  catchError,
  combineAll,
  combineLatest,
  combineLatestAll,
  combineLatestWith,
  concat,
  concatAll,
  concatMap,
  concatMapTo,
  concatWith,
  config,
  connect,
  connectable,
  count,
  debounce,
  debounceTime,
  defaultIfEmpty,
  defer,
  delay,
  delayWhen,
  dematerialize,
  distinct,
  distinctUntilChanged,
  distinctUntilKeyChanged,
  elementAt,
  empty,
  endWith,
  every,
  exhaust,
  exhaustAll,
  exhaustMap,
  expand,
  filter,
  finalize,
  find,
  findIndex,
  first,
  firstValueFrom,
  flatMap,
  forkJoin,
  from,
  fromEvent,
  fromEventPattern,
  generate,
  groupBy,
  identity,
  ignoreElements,
  iif,
  interval,
  isEmpty,
  isObservable,
  last,
  lastValueFrom,
  map,
  mapTo,
  materialize,
  max,
  merge,
  mergeAll,
  mergeMap,
  mergeMapTo,
  mergeScan,
  mergeWith,
  min,
  multicast,
  never,
  noop,
  observable,
  observeOn,
  of,
  onErrorResumeNext,
  onErrorResumeNextWith,
  pairs,
  pairwise,
  partition,
  pipe,
  pluck,
  publish,
  publishBehavior,
  publishLast,
  publishReplay,
  queue,
  queueScheduler,
  race,
  raceWith,
  range,
  reduce,
  refCount,
  repeat,
  repeatWhen,
  retry,
  retryWhen,
  sample,
  sampleTime,
  scan,
  scheduled,
  sequenceEqual,
  share,
  shareReplay,
  single,
  skip,
  skipLast,
  skipUntil,
  skipWhile,
  startWith,
  subscribeOn,
  switchAll,
  switchMap,
  switchMapTo,
  switchScan,
  take,
  takeLast,
  takeUntil,
  takeWhile,
  tap,
  throttle,
  throttleTime,
  throwError,
  throwIfEmpty,
  timeInterval,
  timeout,
  timeoutWith,
  timer,
  timestamp,
  toArray,
  using,
  window,
  windowCount,
  windowTime,
  windowToggle,
  windowWhen,
  withLatestFrom,
  zip,
  zipAll,
  zipWith
};
//# sourceMappingURL=rxjs.js.map



================================================
FILE: .angular/cache/18.2.20/angular-pivothead-example/vite/deps/rxjs_operators.js
================================================
import {
  partition,
  race
} from "./chunk-LPUAGQXJ.js";
import {
  audit,
  auditTime,
  buffer,
  bufferCount,
  bufferTime,
  bufferToggle,
  bufferWhen,
  catchError,
  combineAll,
  combineLatest2 as combineLatest,
  combineLatestAll,
  combineLatestWith,
  concat2 as concat,
  concatAll,
  concatMap,
  concatMapTo,
  concatWith,
  connect,
  count,
  debounce,
  debounceTime,
  defaultIfEmpty,
  delay,
  delayWhen,
  dematerialize,
  distinct,
  distinctUntilChanged,
  distinctUntilKeyChanged,
  elementAt,
  endWith,
  every,
  exhaust,
  exhaustAll,
  exhaustMap,
  expand,
  filter,
  finalize,
  find,
  findIndex,
  first,
  flatMap,
  groupBy,
  ignoreElements,
  isEmpty,
  last,
  map,
  mapTo,
  materialize,
  max,
  merge,
  mergeAll,
  mergeMap,
  mergeMapTo,
  mergeScan,
  mergeWith,
  min,
  multicast,
  observeOn,
  onErrorResumeNext2 as onErrorResumeNext,
  pairwise,
  pluck,
  publish,
  publishBehavior,
  publishLast,
  publishReplay,
  raceWith,
  reduce,
  refCount,
  repeat,
  repeatWhen,
  retry,
  retryWhen,
  sample,
  sampleTime,
  scan,
  sequenceEqual,
  share,
  shareReplay,
  single,
  skip,
  skipLast,
  skipUntil,
  skipWhile,
  startWith,
  subscribeOn,
  switchAll,
  switchMap,
  switchMapTo,
  switchScan,
  take,
  takeLast,
  takeUntil,
  takeWhile,
  tap,
  throttle,
  throttleTime,
  throwIfEmpty,
  timeInterval,
  timeout,
  timeoutWith,
  timestamp,
  toArray,
  window,
  windowCount,
  windowTime,
  windowToggle,
  windowWhen,
  withLatestFrom,
  zip2 as zip,
  zipAll,
  zipWith
} from "./chunk-OVFEQSRS.js";
import "./chunk-WDMUDEB6.js";
export {
  audit,
  auditTime,
  buffer,
  bufferCount,
  bufferTime,
  bufferToggle,
  bufferWhen,
  catchError,
  combineAll,
  combineLatest,
  combineLatestAll,
  combineLatestWith,
  concat,
  concatAll,
  concatMap,
  concatMapTo,
  concatWith,
  connect,
  count,
  debounce,
  debounceTime,
  defaultIfEmpty,
  delay,
  delayWhen,
  dematerialize,
  distinct,
  distinctUntilChanged,
  distinctUntilKeyChanged,
  elementAt,
  endWith,
  every,
  exhaust,
  exhaustAll,
  exhaustMap,
  expand,
  filter,
  finalize,
  find,
  findIndex,
  first,
  flatMap,
  groupBy,
  ignoreElements,
  isEmpty,
  last,
  map,
  mapTo,
  materialize,
  max,
  merge,
  mergeAll,
  mergeMap,
  mergeMapTo,
  mergeScan,
  mergeWith,
  min,
  multicast,
  observeOn,
  onErrorResumeNext,
  pairwise,
  partition,
  pluck,
  publish,
  publishBehavior,
  publishLast,
  publishReplay,
  race,
  raceWith,
  reduce,
  refCount,
  repeat,
  repeatWhen,
  retry,
  retryWhen,
  sample,
  sampleTime,
  scan,
  sequenceEqual,
  share,
  shareReplay,
  single,
  skip,
  skipLast,
  skipUntil,
  skipWhile,
  startWith,
  subscribeOn,
  switchAll,
  switchMap,
  switchMapTo,
  switchScan,
  take,
  takeLast,
  takeUntil,
  takeWhile,
  tap,
  throttle,
  throttleTime,
  throwIfEmpty,
  timeInterval,
  timeout,
  timeoutWith,
  timestamp,
  toArray,
  window,
  windowCount,
  windowTime,
  windowToggle,
  windowWhen,
  withLatestFrom,
  zip,
  zipAll,
  zipWith
};
//# sourceMappingURL=rxjs_operators.js.map


