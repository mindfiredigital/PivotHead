{
  "ast": null,
  "code": "\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.argsToTemplate = argsToTemplate;\nconst ComputesTemplateFromComponent_1 = require(\"./angular-beta/ComputesTemplateFromComponent\");\n/**\n * Converts an object of arguments to a string of property and event bindings and excludes undefined\n * values. Why? Because Angular treats undefined values in property bindings as an actual value and\n * does not apply the default value of the property as soon as the binding is set. This feels\n * counter-intuitive and is a common source of bugs in stories.\n *\n * @example\n *\n * ```ts\n * // component.ts\n * ㅤ@Component({ selector: 'example' })\n *  export class ExampleComponent {\n *   ㅤ@Input() input1: string = 'Default Input1';\n *   ㅤ@Input() input2: string = 'Default Input2';\n *   ㅤ@Output() click = new EventEmitter();\n *  }\n *\n * // component.stories.ts\n * import { argsToTemplate } from '@storybook/angular';\n * export const Input1: Story = {\n *  render: (args) => ({\n *    props: args,\n *    // Problem1: <example [input1]=\"input1\" [input2]=\"input2\" (click)=\"click($event)\"></example>\n *    // This will set input2 to undefined and the internal default value will not be used.\n *    // Problem2: <example [input1]=\"input1\" (click)=\"click($event)\"></example>\n *    // The default value of input2 will be used, but it is not overridable by the user via controls.\n *    // Solution: Now the controls will be applicable to both input1 and input2, and the default values will be used if the user does not override them.\n *    template: `<example ${argsToTemplate(args)}\"></example>`,\n *  }),\n *  args: {\n *    // In this Story, we want to set the input1 property, and the internal default property of input2 should be used.\n *    input1: 'Input 1',\n *    click: { action: 'clicked' },\n *  },\n * };\n * ```\n */\nfunction argsToTemplate(args, options = {}) {\n  const includeSet = options.include ? new Set(options.include) : null;\n  const excludeSet = options.exclude ? new Set(options.exclude) : null;\n  return Object.entries(args).filter(([key]) => args[key] !== undefined).filter(([key]) => {\n    if (includeSet) return includeSet.has(key);\n    if (excludeSet) return !excludeSet.has(key);\n    return true;\n  }).map(([key, value]) => typeof value === 'function' ? `(${key})=\"${(0, ComputesTemplateFromComponent_1.formatPropInTemplate)(key)}($event)\"` : `[${key}]=\"${(0, ComputesTemplateFromComponent_1.formatPropInTemplate)(key)}\"`).join(' ');\n}",
  "map": {
    "version": 3,
    "names": [
      "Object",
      "defineProperty",
      "exports",
      "value",
      "argsToTemplate",
      "ComputesTemplateFromComponent_1",
      "require",
      "args",
      "options",
      "includeSet",
      "include",
      "Set",
      "excludeSet",
      "exclude",
      "entries",
      "filter",
      "key",
      "undefined",
      "has",
      "map",
      "formatPropInTemplate",
      "join"
    ],
    "sources": [
      "/home/sanghamitrad/Documents/open-source/pivot-tablesrc/PivotHead/node_modules/.pnpm/@storybook+angular@8.6.14_@angular-devkit+architect@0.1703.0_@angular-devkit+build-angular@17_a7aajamgs7bgz2yqzrp63bsev4/node_modules/@storybook/angular/dist/client/argsToTemplate.js"
    ],
    "sourcesContent": [
      "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.argsToTemplate = argsToTemplate;\nconst ComputesTemplateFromComponent_1 = require(\"./angular-beta/ComputesTemplateFromComponent\");\n/**\n * Converts an object of arguments to a string of property and event bindings and excludes undefined\n * values. Why? Because Angular treats undefined values in property bindings as an actual value and\n * does not apply the default value of the property as soon as the binding is set. This feels\n * counter-intuitive and is a common source of bugs in stories.\n *\n * @example\n *\n * ```ts\n * // component.ts\n * ㅤ@Component({ selector: 'example' })\n *  export class ExampleComponent {\n *   ㅤ@Input() input1: string = 'Default Input1';\n *   ㅤ@Input() input2: string = 'Default Input2';\n *   ㅤ@Output() click = new EventEmitter();\n *  }\n *\n * // component.stories.ts\n * import { argsToTemplate } from '@storybook/angular';\n * export const Input1: Story = {\n *  render: (args) => ({\n *    props: args,\n *    // Problem1: <example [input1]=\"input1\" [input2]=\"input2\" (click)=\"click($event)\"></example>\n *    // This will set input2 to undefined and the internal default value will not be used.\n *    // Problem2: <example [input1]=\"input1\" (click)=\"click($event)\"></example>\n *    // The default value of input2 will be used, but it is not overridable by the user via controls.\n *    // Solution: Now the controls will be applicable to both input1 and input2, and the default values will be used if the user does not override them.\n *    template: `<example ${argsToTemplate(args)}\"></example>`,\n *  }),\n *  args: {\n *    // In this Story, we want to set the input1 property, and the internal default property of input2 should be used.\n *    input1: 'Input 1',\n *    click: { action: 'clicked' },\n *  },\n * };\n * ```\n */\nfunction argsToTemplate(args, options = {}) {\n    const includeSet = options.include ? new Set(options.include) : null;\n    const excludeSet = options.exclude ? new Set(options.exclude) : null;\n    return Object.entries(args)\n        .filter(([key]) => args[key] !== undefined)\n        .filter(([key]) => {\n        if (includeSet)\n            return includeSet.has(key);\n        if (excludeSet)\n            return !excludeSet.has(key);\n        return true;\n    })\n        .map(([key, value]) => typeof value === 'function'\n        ? `(${key})=\"${(0, ComputesTemplateFromComponent_1.formatPropInTemplate)(key)}($event)\"`\n        : `[${key}]=\"${(0, ComputesTemplateFromComponent_1.formatPropInTemplate)(key)}\"`)\n        .join(' ');\n}\n"
    ],
    "mappings": "AAAA,YAAY;;AACZA,MAAM,CAACC,cAAc,CAACC,OAAO,EAAE,YAAY,EAAE;EAAEC,KAAK,EAAE;AAAK,CAAC,CAAC;AAC7DD,OAAO,CAACE,cAAc,GAAGA,cAAc;AACvC,MAAMC,+BAA+B,GAAGC,OAAO,CAAC,8CAA8C,CAAC;AAC/F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASF,cAAcA,CAACG,IAAI,EAAEC,OAAO,GAAG,CAAC,CAAC,EAAE;EACxC,MAAMC,UAAU,GAAGD,OAAO,CAACE,OAAO,GAAG,IAAIC,GAAG,CAACH,OAAO,CAACE,OAAO,CAAC,GAAG,IAAI;EACpE,MAAME,UAAU,GAAGJ,OAAO,CAACK,OAAO,GAAG,IAAIF,GAAG,CAACH,OAAO,CAACK,OAAO,CAAC,GAAG,IAAI;EACpE,OAAOb,MAAM,CAACc,OAAO,CAACP,IAAI,CAAC,CACtBQ,MAAM,CAAC,CAAC,CAACC,GAAG,CAAC,KAAKT,IAAI,CAACS,GAAG,CAAC,KAAKC,SAAS,CAAC,CAC1CF,MAAM,CAAC,CAAC,CAACC,GAAG,CAAC,KAAK;IACnB,IAAIP,UAAU,EACV,OAAOA,UAAU,CAACS,GAAG,CAACF,GAAG,CAAC;IAC9B,IAAIJ,UAAU,EACV,OAAO,CAACA,UAAU,CAACM,GAAG,CAACF,GAAG,CAAC;IAC/B,OAAO,IAAI;EACf,CAAC,CAAC,CACGG,GAAG,CAAC,CAAC,CAACH,GAAG,EAAEb,KAAK,CAAC,KAAK,OAAOA,KAAK,KAAK,UAAU,GAC/C,IAAGa,GAAI,MAAK,CAAC,CAAC,EAAEX,+BAA+B,CAACe,oBAAoB,EAAEJ,GAAG,CAAE,WAAU,GACrF,IAAGA,GAAI,MAAK,CAAC,CAAC,EAAEX,+BAA+B,CAACe,oBAAoB,EAAEJ,GAAG,CAAE,GAAE,CAAC,CAChFK,IAAI,CAAC,GAAG,CAAC;AAClB",
    "ignoreList": []
  },
  "metadata": {},
  "sourceType": "script",
  "externalDependencies": []
}
