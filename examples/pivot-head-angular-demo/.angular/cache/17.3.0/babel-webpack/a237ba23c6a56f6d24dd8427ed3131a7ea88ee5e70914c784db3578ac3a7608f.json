{
  "ast": null,
  "code": "(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) : typeof define === 'function' && define.amd ? define(['exports'], factory) : (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.jtpp = {}));\n})(this, function (exports) {\n  'use strict';\n\n  function tokenToString(token) {\n    if (token.text !== undefined && token.text !== '') {\n      return `'${token.type}' with value '${token.text}'`;\n    } else {\n      return `'${token.type}'`;\n    }\n  }\n  class NoParsletFoundError extends Error {\n    constructor(token) {\n      super(`No parslet found for token: ${tokenToString(token)}`);\n      this.token = token;\n      Object.setPrototypeOf(this, NoParsletFoundError.prototype);\n    }\n    getToken() {\n      return this.token;\n    }\n  }\n  class EarlyEndOfParseError extends Error {\n    constructor(token) {\n      super(`The parsing ended early. The next token was: ${tokenToString(token)}`);\n      this.token = token;\n      Object.setPrototypeOf(this, EarlyEndOfParseError.prototype);\n    }\n    getToken() {\n      return this.token;\n    }\n  }\n  class UnexpectedTypeError extends Error {\n    constructor(result, message) {\n      let error = `Unexpected type: '${result.type}'.`;\n      if (message !== undefined) {\n        error += ` Message: ${message}`;\n      }\n      super(error);\n      Object.setPrototypeOf(this, UnexpectedTypeError.prototype);\n    }\n  }\n  // export class UnexpectedTokenError extends Error {\n  //   private expected: Token\n  //   private found: Token\n  //\n  //   constructor (expected: Token, found: Token) {\n  //     super(`The parsing ended early. The next token was: ${tokenToString(token)}`)\n  //\n  //     this.token = token\n  //\n  //     Object.setPrototypeOf(this, EarlyEndOfParseError.prototype)\n  //   }\n  //\n  //   getToken() {\n  //     return this.token\n  //   }\n  // }\n\n  function makePunctuationRule(type) {\n    return text => {\n      if (text.startsWith(type)) {\n        return {\n          type,\n          text: type\n        };\n      } else {\n        return null;\n      }\n    };\n  }\n  function getQuoted(text) {\n    let position = 0;\n    let char;\n    const mark = text[0];\n    let escaped = false;\n    if (mark !== '\\'' && mark !== '\"') {\n      return null;\n    }\n    while (position < text.length) {\n      position++;\n      char = text[position];\n      if (!escaped && char === mark) {\n        position++;\n        break;\n      }\n      escaped = !escaped && char === '\\\\';\n    }\n    if (char !== mark) {\n      throw new Error('Unterminated String');\n    }\n    return text.slice(0, position);\n  }\n  const identifierStartRegex = /[$_\\p{ID_Start}]|\\\\u\\p{Hex_Digit}{4}|\\\\u\\{0*(?:\\p{Hex_Digit}{1,5}|10\\p{Hex_Digit}{4})\\}/u;\n  // A hyphen is not technically allowed, but to keep it liberal for now,\n  //  adding it here\n  const identifierContinueRegex = /[$\\-\\p{ID_Continue}\\u200C\\u200D]|\\\\u\\p{Hex_Digit}{4}|\\\\u\\{0*(?:\\p{Hex_Digit}{1,5}|10\\p{Hex_Digit}{4})\\}/u;\n  function getIdentifier(text) {\n    let char = text[0];\n    if (!identifierStartRegex.test(char)) {\n      return null;\n    }\n    let position = 1;\n    do {\n      char = text[position];\n      if (!identifierContinueRegex.test(char)) {\n        break;\n      }\n      position++;\n    } while (position < text.length);\n    return text.slice(0, position);\n  }\n  // we are a bit more liberal than TypeScript here and allow `NaN`, `Infinity` and `-Infinity`\n  const numberRegex = /^(NaN|-?((\\d*\\.\\d+|\\d+)([Ee][+-]?\\d+)?|Infinity))/;\n  function getNumber(text) {\n    var _a, _b;\n    return (_b = (_a = numberRegex.exec(text)) === null || _a === void 0 ? void 0 : _a[0]) !== null && _b !== void 0 ? _b : null;\n  }\n  const identifierRule = text => {\n    const value = getIdentifier(text);\n    if (value == null) {\n      return null;\n    }\n    return {\n      type: 'Identifier',\n      text: value\n    };\n  };\n  function makeKeyWordRule(type) {\n    return text => {\n      if (!text.startsWith(type)) {\n        return null;\n      }\n      const prepends = text[type.length];\n      if (prepends !== undefined && identifierContinueRegex.test(prepends)) {\n        return null;\n      }\n      return {\n        type,\n        text: type\n      };\n    };\n  }\n  const stringValueRule = text => {\n    const value = getQuoted(text);\n    if (value == null) {\n      return null;\n    }\n    return {\n      type: 'StringValue',\n      text: value\n    };\n  };\n  const eofRule = text => {\n    if (text.length > 0) {\n      return null;\n    }\n    return {\n      type: 'EOF',\n      text: ''\n    };\n  };\n  const numberRule = text => {\n    const value = getNumber(text);\n    if (value === null) {\n      return null;\n    }\n    return {\n      type: 'Number',\n      text: value\n    };\n  };\n  const rules = [eofRule, makePunctuationRule('=>'), makePunctuationRule('('), makePunctuationRule(')'), makePunctuationRule('{'), makePunctuationRule('}'), makePunctuationRule('['), makePunctuationRule(']'), makePunctuationRule('|'), makePunctuationRule('&'), makePunctuationRule('<'), makePunctuationRule('>'), makePunctuationRule(','), makePunctuationRule(';'), makePunctuationRule('*'), makePunctuationRule('?'), makePunctuationRule('!'), makePunctuationRule('='), makePunctuationRule(':'), makePunctuationRule('...'), makePunctuationRule('.'), makePunctuationRule('#'), makePunctuationRule('~'), makePunctuationRule('/'), makePunctuationRule('@'), makeKeyWordRule('undefined'), makeKeyWordRule('null'), makeKeyWordRule('function'), makeKeyWordRule('this'), makeKeyWordRule('new'), makeKeyWordRule('module'), makeKeyWordRule('event'), makeKeyWordRule('extends'), makeKeyWordRule('external'), makeKeyWordRule('infer'), makeKeyWordRule('typeof'), makeKeyWordRule('keyof'), makeKeyWordRule('readonly'), makeKeyWordRule('import'), makeKeyWordRule('is'), makeKeyWordRule('in'), makeKeyWordRule('asserts'), numberRule, identifierRule, stringValueRule];\n  const breakingWhitespaceRegex = /^\\s*\\n\\s*/;\n  class Lexer {\n    static create(text) {\n      const current = this.read(text);\n      text = current.text;\n      const next = this.read(text);\n      text = next.text;\n      return new Lexer(text, undefined, current.token, next.token);\n    }\n    constructor(text, previous, current, next) {\n      this.text = '';\n      this.text = text;\n      this.previous = previous;\n      this.current = current;\n      this.next = next;\n    }\n    static read(text, startOfLine = false) {\n      startOfLine = startOfLine || breakingWhitespaceRegex.test(text);\n      text = text.trim();\n      for (const rule of rules) {\n        const partial = rule(text);\n        if (partial !== null) {\n          const token = Object.assign(Object.assign({}, partial), {\n            startOfLine\n          });\n          text = text.slice(token.text.length);\n          return {\n            text,\n            token\n          };\n        }\n      }\n      throw new Error('Unexpected Token ' + text);\n    }\n    advance() {\n      const next = Lexer.read(this.text);\n      return new Lexer(next.text, this.current, this.next, next.token);\n    }\n  }\n\n  /**\n   * Throws an error if the provided result is not a {@link RootResult}\n   */\n  function assertRootResult(result) {\n    if (result === undefined) {\n      throw new Error('Unexpected undefined');\n    }\n    if (result.type === 'JsdocTypeKeyValue' || result.type === 'JsdocTypeParameterList' || result.type === 'JsdocTypeProperty' || result.type === 'JsdocTypeReadonlyProperty' || result.type === 'JsdocTypeObjectField' || result.type === 'JsdocTypeJsdocObjectField' || result.type === 'JsdocTypeIndexSignature' || result.type === 'JsdocTypeMappedType' || result.type === 'JsdocTypeTypeParameter') {\n      throw new UnexpectedTypeError(result);\n    }\n    return result;\n  }\n  function assertPlainKeyValueOrRootResult(result) {\n    if (result.type === 'JsdocTypeKeyValue') {\n      return assertPlainKeyValueResult(result);\n    }\n    return assertRootResult(result);\n  }\n  function assertPlainKeyValueOrNameResult(result) {\n    if (result.type === 'JsdocTypeName') {\n      return result;\n    }\n    return assertPlainKeyValueResult(result);\n  }\n  function assertPlainKeyValueResult(result) {\n    if (result.type !== 'JsdocTypeKeyValue') {\n      throw new UnexpectedTypeError(result);\n    }\n    return result;\n  }\n  function assertNumberOrVariadicNameResult(result) {\n    var _a;\n    if (result.type === 'JsdocTypeVariadic') {\n      if (((_a = result.element) === null || _a === void 0 ? void 0 : _a.type) === 'JsdocTypeName') {\n        return result;\n      }\n      throw new UnexpectedTypeError(result);\n    }\n    if (result.type !== 'JsdocTypeNumber' && result.type !== 'JsdocTypeName') {\n      throw new UnexpectedTypeError(result);\n    }\n    return result;\n  }\n  function assertArrayOrTupleResult(result) {\n    if (result.type === 'JsdocTypeTuple') {\n      return result;\n    }\n    if (result.type === 'JsdocTypeGeneric' && result.meta.brackets === 'square') {\n      return result;\n    }\n    throw new UnexpectedTypeError(result);\n  }\n  function isSquaredProperty(result) {\n    return result.type === 'JsdocTypeIndexSignature' || result.type === 'JsdocTypeMappedType';\n  }\n\n  // higher precedence = higher importance\n  var Precedence;\n  (function (Precedence) {\n    Precedence[Precedence[\"ALL\"] = 0] = \"ALL\";\n    Precedence[Precedence[\"PARAMETER_LIST\"] = 1] = \"PARAMETER_LIST\";\n    Precedence[Precedence[\"OBJECT\"] = 2] = \"OBJECT\";\n    Precedence[Precedence[\"KEY_VALUE\"] = 3] = \"KEY_VALUE\";\n    Precedence[Precedence[\"INDEX_BRACKETS\"] = 4] = \"INDEX_BRACKETS\";\n    Precedence[Precedence[\"UNION\"] = 5] = \"UNION\";\n    Precedence[Precedence[\"INTERSECTION\"] = 6] = \"INTERSECTION\";\n    Precedence[Precedence[\"PREFIX\"] = 7] = \"PREFIX\";\n    Precedence[Precedence[\"INFIX\"] = 8] = \"INFIX\";\n    Precedence[Precedence[\"TUPLE\"] = 9] = \"TUPLE\";\n    Precedence[Precedence[\"SYMBOL\"] = 10] = \"SYMBOL\";\n    Precedence[Precedence[\"OPTIONAL\"] = 11] = \"OPTIONAL\";\n    Precedence[Precedence[\"NULLABLE\"] = 12] = \"NULLABLE\";\n    Precedence[Precedence[\"KEY_OF_TYPE_OF\"] = 13] = \"KEY_OF_TYPE_OF\";\n    Precedence[Precedence[\"FUNCTION\"] = 14] = \"FUNCTION\";\n    Precedence[Precedence[\"ARROW\"] = 15] = \"ARROW\";\n    Precedence[Precedence[\"ARRAY_BRACKETS\"] = 16] = \"ARRAY_BRACKETS\";\n    Precedence[Precedence[\"GENERIC\"] = 17] = \"GENERIC\";\n    Precedence[Precedence[\"NAME_PATH\"] = 18] = \"NAME_PATH\";\n    Precedence[Precedence[\"PARENTHESIS\"] = 19] = \"PARENTHESIS\";\n    Precedence[Precedence[\"SPECIAL_TYPES\"] = 20] = \"SPECIAL_TYPES\";\n  })(Precedence || (Precedence = {}));\n  class Parser {\n    constructor(grammar, textOrLexer, baseParser) {\n      this.grammar = grammar;\n      if (typeof textOrLexer === 'string') {\n        this._lexer = Lexer.create(textOrLexer);\n      } else {\n        this._lexer = textOrLexer;\n      }\n      this.baseParser = baseParser;\n    }\n    get lexer() {\n      return this._lexer;\n    }\n    /**\n     * Parses a given string and throws an error if the parse ended before the end of the string.\n     */\n    parse() {\n      const result = this.parseType(Precedence.ALL);\n      if (this.lexer.current.type !== 'EOF') {\n        throw new EarlyEndOfParseError(this.lexer.current);\n      }\n      return result;\n    }\n    /**\n     * Parses with the current lexer and asserts that the result is a {@link RootResult}.\n     */\n    parseType(precedence) {\n      return assertRootResult(this.parseIntermediateType(precedence));\n    }\n    /**\n     * The main parsing function. First it tries to parse the current state in the prefix step, and then it continues\n     * to parse the state in the infix step.\n     */\n    parseIntermediateType(precedence) {\n      const result = this.tryParslets(null, precedence);\n      if (result === null) {\n        throw new NoParsletFoundError(this.lexer.current);\n      }\n      return this.parseInfixIntermediateType(result, precedence);\n    }\n    /**\n     * In the infix parsing step the parser continues to parse the current state with all parslets until none returns\n     * a result.\n     */\n    parseInfixIntermediateType(left, precedence) {\n      let result = this.tryParslets(left, precedence);\n      while (result !== null) {\n        left = result;\n        result = this.tryParslets(left, precedence);\n      }\n      return left;\n    }\n    /**\n     * Tries to parse the current state with all parslets in the grammar and returns the first non null result.\n     */\n    tryParslets(left, precedence) {\n      for (const parslet of this.grammar) {\n        const result = parslet(this, precedence, left);\n        if (result !== null) {\n          return result;\n        }\n      }\n      return null;\n    }\n    /**\n     * If the given type equals the current type of the {@link Lexer} advance the lexer. Return true if the lexer was\n     * advanced.\n     */\n    consume(types) {\n      if (!Array.isArray(types)) {\n        types = [types];\n      }\n      if (types.includes(this.lexer.current.type)) {\n        this._lexer = this.lexer.advance();\n        return true;\n      } else {\n        return false;\n      }\n    }\n    acceptLexerState(parser) {\n      this._lexer = parser.lexer;\n    }\n  }\n  function isQuestionMarkUnknownType(next) {\n    return next === '}' || next === 'EOF' || next === '|' || next === ',' || next === ')' || next === '>';\n  }\n  const nullableParslet = (parser, precedence, left) => {\n    const type = parser.lexer.current.type;\n    const next = parser.lexer.next.type;\n    const accept = left == null && type === '?' && !isQuestionMarkUnknownType(next) || left != null && type === '?';\n    if (!accept) {\n      return null;\n    }\n    parser.consume('?');\n    if (left == null) {\n      return {\n        type: 'JsdocTypeNullable',\n        element: parser.parseType(Precedence.NULLABLE),\n        meta: {\n          position: 'prefix'\n        }\n      };\n    } else {\n      return {\n        type: 'JsdocTypeNullable',\n        element: assertRootResult(left),\n        meta: {\n          position: 'suffix'\n        }\n      };\n    }\n  };\n  function composeParslet(options) {\n    const parslet = (parser, curPrecedence, left) => {\n      const type = parser.lexer.current.type;\n      const next = parser.lexer.next.type;\n      if (left === null) {\n        if ('parsePrefix' in options) {\n          if (options.accept(type, next)) {\n            return options.parsePrefix(parser);\n          }\n        }\n      } else {\n        if ('parseInfix' in options) {\n          if (options.precedence > curPrecedence && options.accept(type, next)) {\n            return options.parseInfix(parser, left);\n          }\n        }\n      }\n      return null;\n    };\n    // for debugging\n    Object.defineProperty(parslet, 'name', {\n      value: options.name\n    });\n    return parslet;\n  }\n  const optionalParslet = composeParslet({\n    name: 'optionalParslet',\n    accept: type => type === '=',\n    precedence: Precedence.OPTIONAL,\n    parsePrefix: parser => {\n      parser.consume('=');\n      return {\n        type: 'JsdocTypeOptional',\n        element: parser.parseType(Precedence.OPTIONAL),\n        meta: {\n          position: 'prefix'\n        }\n      };\n    },\n    parseInfix: (parser, left) => {\n      parser.consume('=');\n      return {\n        type: 'JsdocTypeOptional',\n        element: assertRootResult(left),\n        meta: {\n          position: 'suffix'\n        }\n      };\n    }\n  });\n  const numberParslet = composeParslet({\n    name: 'numberParslet',\n    accept: type => type === 'Number',\n    parsePrefix: parser => {\n      const value = parseFloat(parser.lexer.current.text);\n      parser.consume('Number');\n      return {\n        type: 'JsdocTypeNumber',\n        value\n      };\n    }\n  });\n  const parenthesisParslet = composeParslet({\n    name: 'parenthesisParslet',\n    accept: type => type === '(',\n    parsePrefix: parser => {\n      parser.consume('(');\n      if (parser.consume(')')) {\n        return {\n          type: 'JsdocTypeParameterList',\n          elements: []\n        };\n      }\n      const result = parser.parseIntermediateType(Precedence.ALL);\n      if (!parser.consume(')')) {\n        throw new Error('Unterminated parenthesis');\n      }\n      if (result.type === 'JsdocTypeParameterList') {\n        return result;\n      } else if (result.type === 'JsdocTypeKeyValue') {\n        return {\n          type: 'JsdocTypeParameterList',\n          elements: [result]\n        };\n      }\n      return {\n        type: 'JsdocTypeParenthesis',\n        element: assertRootResult(result)\n      };\n    }\n  });\n  const specialTypesParslet = composeParslet({\n    name: 'specialTypesParslet',\n    accept: (type, next) => type === '?' && isQuestionMarkUnknownType(next) || type === 'null' || type === 'undefined' || type === '*',\n    parsePrefix: parser => {\n      if (parser.consume('null')) {\n        return {\n          type: 'JsdocTypeNull'\n        };\n      }\n      if (parser.consume('undefined')) {\n        return {\n          type: 'JsdocTypeUndefined'\n        };\n      }\n      if (parser.consume('*')) {\n        return {\n          type: 'JsdocTypeAny'\n        };\n      }\n      if (parser.consume('?')) {\n        return {\n          type: 'JsdocTypeUnknown'\n        };\n      }\n      throw new Error('Unacceptable token: ' + parser.lexer.current.text);\n    }\n  });\n  const notNullableParslet = composeParslet({\n    name: 'notNullableParslet',\n    accept: type => type === '!',\n    precedence: Precedence.NULLABLE,\n    parsePrefix: parser => {\n      parser.consume('!');\n      return {\n        type: 'JsdocTypeNotNullable',\n        element: parser.parseType(Precedence.NULLABLE),\n        meta: {\n          position: 'prefix'\n        }\n      };\n    },\n    parseInfix: (parser, left) => {\n      parser.consume('!');\n      return {\n        type: 'JsdocTypeNotNullable',\n        element: assertRootResult(left),\n        meta: {\n          position: 'suffix'\n        }\n      };\n    }\n  });\n  function createParameterListParslet({\n    allowTrailingComma\n  }) {\n    return composeParslet({\n      name: 'parameterListParslet',\n      accept: type => type === ',',\n      precedence: Precedence.PARAMETER_LIST,\n      parseInfix: (parser, left) => {\n        const elements = [assertPlainKeyValueOrRootResult(left)];\n        parser.consume(',');\n        do {\n          try {\n            const next = parser.parseIntermediateType(Precedence.PARAMETER_LIST);\n            elements.push(assertPlainKeyValueOrRootResult(next));\n          } catch (e) {\n            if (e instanceof NoParsletFoundError) {\n              break;\n            } else {\n              throw e;\n            }\n          }\n        } while (parser.consume(','));\n        if (elements.length > 0 && elements.slice(0, -1).some(e => e.type === 'JsdocTypeVariadic')) {\n          throw new Error('Only the last parameter may be a rest parameter');\n        }\n        return {\n          type: 'JsdocTypeParameterList',\n          elements\n        };\n      }\n    });\n  }\n  const genericParslet = composeParslet({\n    name: 'genericParslet',\n    accept: (type, next) => type === '<' || type === '.' && next === '<',\n    precedence: Precedence.GENERIC,\n    parseInfix: (parser, left) => {\n      const dot = parser.consume('.');\n      parser.consume('<');\n      const objects = [];\n      let infer = false;\n      if (parser.consume('infer')) {\n        infer = true;\n        const left = parser.parseIntermediateType(Precedence.SYMBOL);\n        if (left.type !== 'JsdocTypeName') {\n          throw new UnexpectedTypeError(left, 'A typescript asserts always has to have a name on the left side.');\n        }\n        objects.push(left);\n      } else {\n        do {\n          objects.push(parser.parseType(Precedence.PARAMETER_LIST));\n        } while (parser.consume(','));\n      }\n      if (!parser.consume('>')) {\n        throw new Error('Unterminated generic parameter list');\n      }\n      return Object.assign(Object.assign({\n        type: 'JsdocTypeGeneric',\n        left: assertRootResult(left),\n        elements: objects\n      }, infer ? {\n        infer: true\n      } : {}), {\n        meta: {\n          brackets: 'angle',\n          dot\n        }\n      });\n    }\n  });\n  const unionParslet = composeParslet({\n    name: 'unionParslet',\n    accept: type => type === '|',\n    precedence: Precedence.UNION,\n    parseInfix: (parser, left) => {\n      parser.consume('|');\n      const elements = [];\n      do {\n        elements.push(parser.parseType(Precedence.UNION));\n      } while (parser.consume('|'));\n      return {\n        type: 'JsdocTypeUnion',\n        elements: [assertRootResult(left), ...elements]\n      };\n    }\n  });\n  const baseGrammar = [nullableParslet, optionalParslet, numberParslet, parenthesisParslet, specialTypesParslet, notNullableParslet, createParameterListParslet({\n    allowTrailingComma: true\n  }), genericParslet, unionParslet, optionalParslet];\n  function createNamePathParslet({\n    allowSquareBracketsOnAnyType,\n    allowJsdocNamePaths,\n    pathGrammar\n  }) {\n    return function namePathParslet(parser, precedence, left) {\n      if (left == null || precedence >= Precedence.NAME_PATH) {\n        return null;\n      }\n      const type = parser.lexer.current.type;\n      const next = parser.lexer.next.type;\n      const accept = type === '.' && next !== '<' || type === '[' && (allowSquareBracketsOnAnyType || left.type === 'JsdocTypeName') || allowJsdocNamePaths && (type === '~' || type === '#');\n      if (!accept) {\n        return null;\n      }\n      let pathType;\n      let brackets = false;\n      if (parser.consume('.')) {\n        pathType = 'property';\n      } else if (parser.consume('[')) {\n        pathType = 'property-brackets';\n        brackets = true;\n      } else if (parser.consume('~')) {\n        pathType = 'inner';\n      } else {\n        parser.consume('#');\n        pathType = 'instance';\n      }\n      const pathParser = pathGrammar !== null ? new Parser(pathGrammar, parser.lexer, parser) : parser;\n      const parsed = pathParser.parseIntermediateType(Precedence.NAME_PATH);\n      parser.acceptLexerState(pathParser);\n      let right;\n      switch (parsed.type) {\n        case 'JsdocTypeName':\n          right = {\n            type: 'JsdocTypeProperty',\n            value: parsed.value,\n            meta: {\n              quote: undefined\n            }\n          };\n          break;\n        case 'JsdocTypeNumber':\n          right = {\n            type: 'JsdocTypeProperty',\n            value: parsed.value.toString(10),\n            meta: {\n              quote: undefined\n            }\n          };\n          break;\n        case 'JsdocTypeStringValue':\n          right = {\n            type: 'JsdocTypeProperty',\n            value: parsed.value,\n            meta: {\n              quote: parsed.meta.quote\n            }\n          };\n          break;\n        case 'JsdocTypeSpecialNamePath':\n          if (parsed.specialType === 'event') {\n            right = parsed;\n          } else {\n            throw new UnexpectedTypeError(parsed, 'Type \\'JsdocTypeSpecialNamePath\\' is only allowed with specialType \\'event\\'');\n          }\n          break;\n        default:\n          throw new UnexpectedTypeError(parsed, 'Expecting \\'JsdocTypeName\\', \\'JsdocTypeNumber\\', \\'JsdocStringValue\\' or \\'JsdocTypeSpecialNamePath\\'');\n      }\n      if (brackets && !parser.consume(']')) {\n        const token = parser.lexer.current;\n        throw new Error(`Unterminated square brackets. Next token is '${token.type}' ` + `with text '${token.text}'`);\n      }\n      return {\n        type: 'JsdocTypeNamePath',\n        left: assertRootResult(left),\n        right,\n        pathType\n      };\n    };\n  }\n  function createNameParslet({\n    allowedAdditionalTokens\n  }) {\n    return composeParslet({\n      name: 'nameParslet',\n      accept: type => type === 'Identifier' || type === 'this' || type === 'new' || allowedAdditionalTokens.includes(type),\n      parsePrefix: parser => {\n        const {\n          type,\n          text\n        } = parser.lexer.current;\n        parser.consume(type);\n        return {\n          type: 'JsdocTypeName',\n          value: text\n        };\n      }\n    });\n  }\n  const stringValueParslet = composeParslet({\n    name: 'stringValueParslet',\n    accept: type => type === 'StringValue',\n    parsePrefix: parser => {\n      const text = parser.lexer.current.text;\n      parser.consume('StringValue');\n      return {\n        type: 'JsdocTypeStringValue',\n        value: text.slice(1, -1),\n        meta: {\n          quote: text[0] === '\\'' ? 'single' : 'double'\n        }\n      };\n    }\n  });\n  function createSpecialNamePathParslet({\n    pathGrammar,\n    allowedTypes\n  }) {\n    return composeParslet({\n      name: 'specialNamePathParslet',\n      accept: type => allowedTypes.includes(type),\n      parsePrefix: parser => {\n        const type = parser.lexer.current.type;\n        parser.consume(type);\n        if (!parser.consume(':')) {\n          return {\n            type: 'JsdocTypeName',\n            value: type\n          };\n        }\n        let result;\n        let token = parser.lexer.current;\n        if (parser.consume('StringValue')) {\n          result = {\n            type: 'JsdocTypeSpecialNamePath',\n            value: token.text.slice(1, -1),\n            specialType: type,\n            meta: {\n              quote: token.text[0] === '\\'' ? 'single' : 'double'\n            }\n          };\n        } else {\n          let value = '';\n          const allowed = ['Identifier', '@', '/'];\n          while (allowed.some(type => parser.consume(type))) {\n            value += token.text;\n            token = parser.lexer.current;\n          }\n          result = {\n            type: 'JsdocTypeSpecialNamePath',\n            value,\n            specialType: type,\n            meta: {\n              quote: undefined\n            }\n          };\n        }\n        const moduleParser = new Parser(pathGrammar, parser.lexer, parser);\n        const moduleResult = moduleParser.parseInfixIntermediateType(result, Precedence.ALL);\n        parser.acceptLexerState(moduleParser);\n        return assertRootResult(moduleResult);\n      }\n    });\n  }\n  const basePathGrammar = [createNameParslet({\n    allowedAdditionalTokens: ['external', 'module']\n  }), stringValueParslet, numberParslet, createNamePathParslet({\n    allowSquareBracketsOnAnyType: false,\n    allowJsdocNamePaths: true,\n    pathGrammar: null\n  })];\n  const pathGrammar = [...basePathGrammar, createSpecialNamePathParslet({\n    allowedTypes: ['event'],\n    pathGrammar: basePathGrammar\n  })];\n  function getParameters(value) {\n    let parameters;\n    if (value.type === 'JsdocTypeParameterList') {\n      parameters = value.elements;\n    } else if (value.type === 'JsdocTypeParenthesis') {\n      parameters = [value.element];\n    } else {\n      throw new UnexpectedTypeError(value);\n    }\n    return parameters.map(p => assertPlainKeyValueOrRootResult(p));\n  }\n  function getUnnamedParameters(value) {\n    const parameters = getParameters(value);\n    if (parameters.some(p => p.type === 'JsdocTypeKeyValue')) {\n      throw new Error('No parameter should be named');\n    }\n    return parameters;\n  }\n  function createFunctionParslet({\n    allowNamedParameters,\n    allowNoReturnType,\n    allowWithoutParenthesis,\n    allowNewAsFunctionKeyword\n  }) {\n    return composeParslet({\n      name: 'functionParslet',\n      accept: (type, next) => type === 'function' || allowNewAsFunctionKeyword && type === 'new' && next === '(',\n      parsePrefix: parser => {\n        const newKeyword = parser.consume('new');\n        parser.consume('function');\n        const hasParenthesis = parser.lexer.current.type === '(';\n        if (!hasParenthesis) {\n          if (!allowWithoutParenthesis) {\n            throw new Error('function is missing parameter list');\n          }\n          return {\n            type: 'JsdocTypeName',\n            value: 'function'\n          };\n        }\n        let result = {\n          type: 'JsdocTypeFunction',\n          parameters: [],\n          arrow: false,\n          constructor: newKeyword,\n          parenthesis: hasParenthesis\n        };\n        const value = parser.parseIntermediateType(Precedence.FUNCTION);\n        if (allowNamedParameters === undefined) {\n          result.parameters = getUnnamedParameters(value);\n        } else if (newKeyword && value.type === 'JsdocTypeFunction' && value.arrow) {\n          result = value;\n          result.constructor = true;\n          return result;\n        } else {\n          result.parameters = getParameters(value);\n          for (const p of result.parameters) {\n            if (p.type === 'JsdocTypeKeyValue' && !allowNamedParameters.includes(p.key)) {\n              throw new Error(`only allowed named parameters are ${allowNamedParameters.join(', ')} but got ${p.type}`);\n            }\n          }\n        }\n        if (parser.consume(':')) {\n          result.returnType = parser.parseType(Precedence.PREFIX);\n        } else {\n          if (!allowNoReturnType) {\n            throw new Error('function is missing return type');\n          }\n        }\n        return result;\n      }\n    });\n  }\n  function createVariadicParslet({\n    allowPostfix,\n    allowEnclosingBrackets\n  }) {\n    return composeParslet({\n      name: 'variadicParslet',\n      accept: type => type === '...',\n      precedence: Precedence.PREFIX,\n      parsePrefix: parser => {\n        parser.consume('...');\n        const brackets = allowEnclosingBrackets && parser.consume('[');\n        try {\n          const element = parser.parseType(Precedence.PREFIX);\n          if (brackets && !parser.consume(']')) {\n            throw new Error('Unterminated variadic type. Missing \\']\\'');\n          }\n          return {\n            type: 'JsdocTypeVariadic',\n            element: assertRootResult(element),\n            meta: {\n              position: 'prefix',\n              squareBrackets: brackets\n            }\n          };\n        } catch (e) {\n          if (e instanceof NoParsletFoundError) {\n            if (brackets) {\n              throw new Error('Empty square brackets for variadic are not allowed.');\n            }\n            return {\n              type: 'JsdocTypeVariadic',\n              meta: {\n                position: undefined,\n                squareBrackets: false\n              }\n            };\n          } else {\n            throw e;\n          }\n        }\n      },\n      parseInfix: allowPostfix ? (parser, left) => {\n        parser.consume('...');\n        return {\n          type: 'JsdocTypeVariadic',\n          element: assertRootResult(left),\n          meta: {\n            position: 'suffix',\n            squareBrackets: false\n          }\n        };\n      } : undefined\n    });\n  }\n  const symbolParslet = composeParslet({\n    name: 'symbolParslet',\n    accept: type => type === '(',\n    precedence: Precedence.SYMBOL,\n    parseInfix: (parser, left) => {\n      if (left.type !== 'JsdocTypeName') {\n        throw new Error('Symbol expects a name on the left side. (Reacting on \\'(\\')');\n      }\n      parser.consume('(');\n      const result = {\n        type: 'JsdocTypeSymbol',\n        value: left.value\n      };\n      if (!parser.consume(')')) {\n        const next = parser.parseIntermediateType(Precedence.SYMBOL);\n        result.element = assertNumberOrVariadicNameResult(next);\n        if (!parser.consume(')')) {\n          throw new Error('Symbol does not end after value');\n        }\n      }\n      return result;\n    }\n  });\n  const arrayBracketsParslet = composeParslet({\n    name: 'arrayBracketsParslet',\n    precedence: Precedence.ARRAY_BRACKETS,\n    accept: (type, next) => type === '[' && next === ']',\n    parseInfix: (parser, left) => {\n      parser.consume('[');\n      parser.consume(']');\n      return {\n        type: 'JsdocTypeGeneric',\n        left: {\n          type: 'JsdocTypeName',\n          value: 'Array'\n        },\n        elements: [assertRootResult(left)],\n        meta: {\n          brackets: 'square',\n          dot: false\n        }\n      };\n    }\n  });\n  function createObjectParslet({\n    objectFieldGrammar,\n    allowKeyTypes\n  }) {\n    return composeParslet({\n      name: 'objectParslet',\n      accept: type => type === '{',\n      parsePrefix: parser => {\n        parser.consume('{');\n        const result = {\n          type: 'JsdocTypeObject',\n          meta: {\n            separator: 'comma'\n          },\n          elements: []\n        };\n        if (!parser.consume('}')) {\n          let separator;\n          const fieldParser = new Parser(objectFieldGrammar, parser.lexer, parser);\n          while (true) {\n            fieldParser.acceptLexerState(parser);\n            let field = fieldParser.parseIntermediateType(Precedence.OBJECT);\n            parser.acceptLexerState(fieldParser);\n            if (field === undefined && allowKeyTypes) {\n              field = parser.parseIntermediateType(Precedence.OBJECT);\n            }\n            let optional = false;\n            if (field.type === 'JsdocTypeNullable') {\n              optional = true;\n              field = field.element;\n            }\n            if (field.type === 'JsdocTypeNumber' || field.type === 'JsdocTypeName' || field.type === 'JsdocTypeStringValue') {\n              let quote;\n              if (field.type === 'JsdocTypeStringValue') {\n                quote = field.meta.quote;\n              }\n              result.elements.push({\n                type: 'JsdocTypeObjectField',\n                key: field.value.toString(),\n                right: undefined,\n                optional,\n                readonly: false,\n                meta: {\n                  quote\n                }\n              });\n            } else if (field.type === 'JsdocTypeObjectField' || field.type === 'JsdocTypeJsdocObjectField') {\n              result.elements.push(field);\n            } else {\n              throw new UnexpectedTypeError(field);\n            }\n            if (parser.lexer.current.startOfLine) {\n              separator = 'linebreak';\n              // Handle single stray comma/semi-colon\n              parser.consume(',') || parser.consume(';');\n            } else if (parser.consume(',')) {\n              separator = 'comma';\n            } else if (parser.consume(';')) {\n              separator = 'semicolon';\n            } else {\n              break;\n            }\n            const type = parser.lexer.current.type;\n            if (type === '}') {\n              break;\n            }\n          }\n          result.meta.separator = separator !== null && separator !== void 0 ? separator : 'comma'; // TODO: use undefined here\n          if (separator === 'linebreak') {\n            // TODO: Consume appropriate whitespace\n            result.meta.propertyIndent = '  ';\n          }\n          if (!parser.consume('}')) {\n            throw new Error('Unterminated record type. Missing \\'}\\'');\n          }\n        }\n        return result;\n      }\n    });\n  }\n  function createObjectFieldParslet({\n    allowSquaredProperties,\n    allowKeyTypes,\n    allowReadonly,\n    allowOptional\n  }) {\n    return composeParslet({\n      name: 'objectFieldParslet',\n      precedence: Precedence.KEY_VALUE,\n      accept: type => type === ':',\n      parseInfix: (parser, left) => {\n        var _a;\n        let optional = false;\n        let readonlyProperty = false;\n        if (allowOptional && left.type === 'JsdocTypeNullable') {\n          optional = true;\n          left = left.element;\n        }\n        if (allowReadonly && left.type === 'JsdocTypeReadonlyProperty') {\n          readonlyProperty = true;\n          left = left.element;\n        }\n        // object parslet uses a special grammar and for the value we want to switch back to the parent\n        const parentParser = (_a = parser.baseParser) !== null && _a !== void 0 ? _a : parser;\n        parentParser.acceptLexerState(parser);\n        if (left.type === 'JsdocTypeNumber' || left.type === 'JsdocTypeName' || left.type === 'JsdocTypeStringValue' || isSquaredProperty(left)) {\n          if (isSquaredProperty(left) && !allowSquaredProperties) {\n            throw new UnexpectedTypeError(left);\n          }\n          parentParser.consume(':');\n          let quote;\n          if (left.type === 'JsdocTypeStringValue') {\n            quote = left.meta.quote;\n          }\n          const right = parentParser.parseType(Precedence.KEY_VALUE);\n          parser.acceptLexerState(parentParser);\n          return {\n            type: 'JsdocTypeObjectField',\n            key: isSquaredProperty(left) ? left : left.value.toString(),\n            right,\n            optional,\n            readonly: readonlyProperty,\n            meta: {\n              quote\n            }\n          };\n        } else {\n          if (!allowKeyTypes) {\n            throw new UnexpectedTypeError(left);\n          }\n          parentParser.consume(':');\n          const right = parentParser.parseType(Precedence.KEY_VALUE);\n          parser.acceptLexerState(parentParser);\n          return {\n            type: 'JsdocTypeJsdocObjectField',\n            left: assertRootResult(left),\n            right\n          };\n        }\n      }\n    });\n  }\n  function createKeyValueParslet({\n    allowOptional,\n    allowVariadic\n  }) {\n    return composeParslet({\n      name: 'keyValueParslet',\n      precedence: Precedence.KEY_VALUE,\n      accept: type => type === ':',\n      parseInfix: (parser, left) => {\n        let optional = false;\n        let variadic = false;\n        if (allowOptional && left.type === 'JsdocTypeNullable') {\n          optional = true;\n          left = left.element;\n        }\n        if (allowVariadic && left.type === 'JsdocTypeVariadic' && left.element !== undefined) {\n          variadic = true;\n          left = left.element;\n        }\n        if (left.type !== 'JsdocTypeName') {\n          throw new UnexpectedTypeError(left);\n        }\n        parser.consume(':');\n        const right = parser.parseType(Precedence.KEY_VALUE);\n        return {\n          type: 'JsdocTypeKeyValue',\n          key: left.value,\n          right,\n          optional,\n          variadic\n        };\n      }\n    });\n  }\n  const jsdocBaseGrammar = [...baseGrammar, createFunctionParslet({\n    allowWithoutParenthesis: true,\n    allowNamedParameters: ['this', 'new'],\n    allowNoReturnType: true,\n    allowNewAsFunctionKeyword: false\n  }), stringValueParslet, createSpecialNamePathParslet({\n    allowedTypes: ['module', 'external', 'event'],\n    pathGrammar\n  }), createVariadicParslet({\n    allowEnclosingBrackets: true,\n    allowPostfix: true\n  }), createNameParslet({\n    allowedAdditionalTokens: ['keyof']\n  }), symbolParslet, arrayBracketsParslet, createNamePathParslet({\n    allowSquareBracketsOnAnyType: false,\n    allowJsdocNamePaths: true,\n    pathGrammar\n  })];\n  const jsdocGrammar = [...jsdocBaseGrammar, createObjectParslet({\n    // jsdoc syntax allows full types as keys, so we need to pull in the full grammar here\n    // we leave out the object type deliberately\n    objectFieldGrammar: [createNameParslet({\n      allowedAdditionalTokens: ['typeof', 'module', 'in']\n    }), createObjectFieldParslet({\n      allowSquaredProperties: false,\n      allowKeyTypes: true,\n      allowOptional: false,\n      allowReadonly: false\n    }), ...jsdocBaseGrammar],\n    allowKeyTypes: true\n  }), createKeyValueParslet({\n    allowOptional: true,\n    allowVariadic: true\n  })];\n  const typeOfParslet = composeParslet({\n    name: 'typeOfParslet',\n    accept: type => type === 'typeof',\n    parsePrefix: parser => {\n      parser.consume('typeof');\n      return {\n        type: 'JsdocTypeTypeof',\n        element: parser.parseType(Precedence.KEY_OF_TYPE_OF)\n      };\n    }\n  });\n  const objectFieldGrammar$1 = [createNameParslet({\n    allowedAdditionalTokens: ['typeof', 'module', 'keyof', 'event', 'external', 'in']\n  }), nullableParslet, optionalParslet, stringValueParslet, numberParslet, createObjectFieldParslet({\n    allowSquaredProperties: false,\n    allowKeyTypes: false,\n    allowOptional: false,\n    allowReadonly: false\n  })];\n  const closureGrammar = [...baseGrammar, createObjectParslet({\n    allowKeyTypes: false,\n    objectFieldGrammar: objectFieldGrammar$1\n  }), createNameParslet({\n    allowedAdditionalTokens: ['event', 'external', 'in']\n  }), typeOfParslet, createFunctionParslet({\n    allowWithoutParenthesis: false,\n    allowNamedParameters: ['this', 'new'],\n    allowNoReturnType: true,\n    allowNewAsFunctionKeyword: false\n  }), createVariadicParslet({\n    allowEnclosingBrackets: false,\n    allowPostfix: false\n  }),\n  // additional name parslet is needed for some special cases\n  createNameParslet({\n    allowedAdditionalTokens: ['keyof']\n  }), createSpecialNamePathParslet({\n    allowedTypes: ['module'],\n    pathGrammar\n  }), createNamePathParslet({\n    allowSquareBracketsOnAnyType: false,\n    allowJsdocNamePaths: true,\n    pathGrammar\n  }), createKeyValueParslet({\n    allowOptional: false,\n    allowVariadic: false\n  }), symbolParslet];\n  const assertsParslet = composeParslet({\n    name: 'assertsParslet',\n    accept: type => type === 'asserts',\n    parsePrefix: parser => {\n      parser.consume('asserts');\n      const left = parser.parseIntermediateType(Precedence.SYMBOL);\n      if (left.type !== 'JsdocTypeName') {\n        throw new UnexpectedTypeError(left, 'A typescript asserts always has to have a name on the left side.');\n      }\n      if (!parser.consume('is')) {\n        return {\n          type: 'JsdocTypeAssertsPlain',\n          element: left\n        };\n      }\n      return {\n        type: 'JsdocTypeAsserts',\n        left,\n        right: assertRootResult(parser.parseIntermediateType(Precedence.INFIX))\n      };\n    }\n  });\n  function createTupleParslet({\n    allowQuestionMark\n  }) {\n    return composeParslet({\n      name: 'tupleParslet',\n      accept: type => type === '[',\n      parsePrefix: parser => {\n        parser.consume('[');\n        const result = {\n          type: 'JsdocTypeTuple',\n          elements: []\n        };\n        if (parser.consume(']')) {\n          return result;\n        }\n        const typeList = parser.parseIntermediateType(Precedence.ALL);\n        if (typeList.type === 'JsdocTypeParameterList') {\n          if (typeList.elements[0].type === 'JsdocTypeKeyValue') {\n            result.elements = typeList.elements.map(assertPlainKeyValueResult);\n          } else {\n            result.elements = typeList.elements.map(assertRootResult);\n          }\n        } else {\n          if (typeList.type === 'JsdocTypeKeyValue') {\n            result.elements = [assertPlainKeyValueResult(typeList)];\n          } else {\n            result.elements = [assertRootResult(typeList)];\n          }\n        }\n        if (!parser.consume(']')) {\n          throw new Error('Unterminated \\'[\\'');\n        }\n        if (result.elements.some(e => e.type === 'JsdocTypeUnknown')) {\n          throw new Error('Question mark in tuple not allowed');\n        }\n        return result;\n      }\n    });\n  }\n  const keyOfParslet = composeParslet({\n    name: 'keyOfParslet',\n    accept: type => type === 'keyof',\n    parsePrefix: parser => {\n      parser.consume('keyof');\n      return {\n        type: 'JsdocTypeKeyof',\n        element: assertRootResult(parser.parseType(Precedence.KEY_OF_TYPE_OF))\n      };\n    }\n  });\n  const importParslet = composeParslet({\n    name: 'importParslet',\n    accept: type => type === 'import',\n    parsePrefix: parser => {\n      parser.consume('import');\n      if (!parser.consume('(')) {\n        throw new Error('Missing parenthesis after import keyword');\n      }\n      const path = parser.parseType(Precedence.PREFIX);\n      if (path.type !== 'JsdocTypeStringValue') {\n        throw new Error('Only string values are allowed as paths for imports');\n      }\n      if (!parser.consume(')')) {\n        throw new Error('Missing closing parenthesis after import keyword');\n      }\n      return {\n        type: 'JsdocTypeImport',\n        element: path\n      };\n    }\n  });\n  const readonlyPropertyParslet = composeParslet({\n    name: 'readonlyPropertyParslet',\n    accept: type => type === 'readonly',\n    parsePrefix: parser => {\n      parser.consume('readonly');\n      return {\n        type: 'JsdocTypeReadonlyProperty',\n        element: parser.parseIntermediateType(Precedence.KEY_VALUE)\n      };\n    }\n  });\n  const arrowFunctionParslet = composeParslet({\n    name: 'arrowFunctionParslet',\n    precedence: Precedence.ARROW,\n    accept: type => type === '=>',\n    parseInfix: (parser, left) => {\n      parser.consume('=>');\n      return {\n        type: 'JsdocTypeFunction',\n        parameters: getParameters(left).map(assertPlainKeyValueOrNameResult),\n        arrow: true,\n        constructor: false,\n        parenthesis: true,\n        returnType: parser.parseType(Precedence.OBJECT)\n      };\n    }\n  });\n  const genericArrowFunctionParslet = composeParslet({\n    name: 'genericArrowFunctionParslet',\n    accept: type => type === '<',\n    parsePrefix: parser => {\n      const typeParameters = [];\n      parser.consume('<');\n      do {\n        let defaultValue;\n        let name = parser.parseIntermediateType(Precedence.SYMBOL);\n        if (name.type === 'JsdocTypeOptional') {\n          name = name.element;\n          defaultValue = parser.parseType(Precedence.SYMBOL);\n        }\n        if (name.type !== 'JsdocTypeName') {\n          throw new UnexpectedTypeError(name);\n        }\n        let constraint;\n        if (parser.consume('extends')) {\n          constraint = parser.parseType(Precedence.SYMBOL);\n          // Got an equal sign\n          if (constraint.type === 'JsdocTypeOptional') {\n            constraint = constraint.element;\n            defaultValue = parser.parseType(Precedence.SYMBOL);\n          }\n        }\n        const typeParameter = {\n          type: 'JsdocTypeTypeParameter',\n          name\n        };\n        if (constraint !== undefined) {\n          typeParameter.constraint = constraint;\n        }\n        if (defaultValue !== undefined) {\n          typeParameter.defaultValue = defaultValue;\n        }\n        typeParameters.push(typeParameter);\n        if (parser.consume('>')) {\n          break;\n        }\n      } while (parser.consume(','));\n      const functionBase = parser.parseIntermediateType(Precedence.SYMBOL);\n      functionBase.typeParameters = typeParameters;\n      return functionBase;\n    }\n  });\n  const intersectionParslet = composeParslet({\n    name: 'intersectionParslet',\n    accept: type => type === '&',\n    precedence: Precedence.INTERSECTION,\n    parseInfix: (parser, left) => {\n      parser.consume('&');\n      const elements = [];\n      do {\n        elements.push(parser.parseType(Precedence.INTERSECTION));\n      } while (parser.consume('&'));\n      return {\n        type: 'JsdocTypeIntersection',\n        elements: [assertRootResult(left), ...elements]\n      };\n    }\n  });\n  const predicateParslet = composeParslet({\n    name: 'predicateParslet',\n    precedence: Precedence.INFIX,\n    accept: type => type === 'is',\n    parseInfix: (parser, left) => {\n      if (left.type !== 'JsdocTypeName') {\n        throw new UnexpectedTypeError(left, 'A typescript predicate always has to have a name on the left side.');\n      }\n      parser.consume('is');\n      return {\n        type: 'JsdocTypePredicate',\n        left,\n        right: assertRootResult(parser.parseIntermediateType(Precedence.INFIX))\n      };\n    }\n  });\n  const objectSquaredPropertyParslet = composeParslet({\n    name: 'objectSquareBracketPropertyParslet',\n    accept: type => type === '[',\n    parsePrefix: parser => {\n      if (parser.baseParser === undefined) {\n        throw new Error('Only allowed inside object grammar');\n      }\n      parser.consume('[');\n      const key = parser.lexer.current.text;\n      parser.consume('Identifier');\n      let result;\n      if (parser.consume(':')) {\n        const parentParser = parser.baseParser;\n        parentParser.acceptLexerState(parser);\n        result = {\n          type: 'JsdocTypeIndexSignature',\n          key,\n          right: parentParser.parseType(Precedence.INDEX_BRACKETS)\n        };\n        parser.acceptLexerState(parentParser);\n      } else if (parser.consume('in')) {\n        const parentParser = parser.baseParser;\n        parentParser.acceptLexerState(parser);\n        result = {\n          type: 'JsdocTypeMappedType',\n          key,\n          right: parentParser.parseType(Precedence.ARRAY_BRACKETS)\n        };\n        parser.acceptLexerState(parentParser);\n      } else {\n        throw new Error('Missing \\':\\' or \\'in\\' inside square bracketed property.');\n      }\n      if (!parser.consume(']')) {\n        throw new Error('Unterminated square brackets');\n      }\n      return result;\n    }\n  });\n  const readonlyArrayParslet = composeParslet({\n    name: 'readonlyArrayParslet',\n    accept: type => type === 'readonly',\n    parsePrefix: parser => {\n      parser.consume('readonly');\n      return {\n        type: 'JsdocTypeReadonlyArray',\n        element: assertArrayOrTupleResult(parser.parseIntermediateType(Precedence.ALL))\n      };\n    }\n  });\n  const conditionalParslet = composeParslet({\n    name: 'conditionalParslet',\n    precedence: Precedence.INFIX,\n    accept: type => type === 'extends',\n    parseInfix: (parser, left) => {\n      parser.consume('extends');\n      const extendsType = parser.parseType(Precedence.KEY_OF_TYPE_OF).element;\n      // parser.consume('?')\n      const trueType = parser.parseType(Precedence.INFIX);\n      parser.consume(':');\n      return {\n        type: 'JsdocTypeConditional',\n        checksType: assertRootResult(left),\n        extendsType,\n        trueType,\n        falseType: parser.parseType(Precedence.INFIX)\n      };\n    }\n  });\n  const objectFieldGrammar = [readonlyPropertyParslet, createNameParslet({\n    allowedAdditionalTokens: ['typeof', 'module', 'keyof', 'event', 'external', 'in']\n  }), nullableParslet, optionalParslet, stringValueParslet, numberParslet, createObjectFieldParslet({\n    allowSquaredProperties: true,\n    allowKeyTypes: false,\n    allowOptional: true,\n    allowReadonly: true\n  }), objectSquaredPropertyParslet];\n  const typescriptGrammar = [...baseGrammar, createObjectParslet({\n    allowKeyTypes: false,\n    objectFieldGrammar\n  }), readonlyArrayParslet, typeOfParslet, keyOfParslet, importParslet, stringValueParslet, createFunctionParslet({\n    allowWithoutParenthesis: true,\n    allowNoReturnType: false,\n    allowNamedParameters: ['this', 'new', 'args'],\n    allowNewAsFunctionKeyword: true\n  }), createTupleParslet({\n    allowQuestionMark: false\n  }), createVariadicParslet({\n    allowEnclosingBrackets: false,\n    allowPostfix: false\n  }), assertsParslet, conditionalParslet, createNameParslet({\n    allowedAdditionalTokens: ['event', 'external', 'in']\n  }), createSpecialNamePathParslet({\n    allowedTypes: ['module'],\n    pathGrammar\n  }), arrayBracketsParslet, arrowFunctionParslet, genericArrowFunctionParslet, createNamePathParslet({\n    allowSquareBracketsOnAnyType: true,\n    allowJsdocNamePaths: false,\n    pathGrammar\n  }), intersectionParslet, predicateParslet, createKeyValueParslet({\n    allowVariadic: true,\n    allowOptional: true\n  })];\n\n  /**\n   * This function parses the given expression in the given mode and produces a {@link RootResult}.\n   * @param expression\n   * @param mode\n   */\n  function parse(expression, mode) {\n    switch (mode) {\n      case 'closure':\n        return new Parser(closureGrammar, expression).parse();\n      case 'jsdoc':\n        return new Parser(jsdocGrammar, expression).parse();\n      case 'typescript':\n        return new Parser(typescriptGrammar, expression).parse();\n    }\n  }\n  /**\n   * This function tries to parse the given expression in multiple modes and returns the first successful\n   * {@link RootResult}. By default it tries `'typescript'`, `'closure'` and `'jsdoc'` in this order. If\n   * no mode was successful it throws the error that was produced by the last parsing attempt.\n   * @param expression\n   * @param modes\n   */\n  function tryParse(expression, modes = ['typescript', 'closure', 'jsdoc']) {\n    let error;\n    for (const mode of modes) {\n      try {\n        return parse(expression, mode);\n      } catch (e) {\n        error = e;\n      }\n    }\n    throw error;\n  }\n  function transform(rules, parseResult) {\n    const rule = rules[parseResult.type];\n    if (rule === undefined) {\n      throw new Error(`In this set of transform rules exists no rule for type ${parseResult.type}.`);\n    }\n    return rule(parseResult, aParseResult => transform(rules, aParseResult));\n  }\n  function notAvailableTransform(parseResult) {\n    throw new Error('This transform is not available. Are you trying the correct parsing mode?');\n  }\n  function extractSpecialParams(source) {\n    const result = {\n      params: []\n    };\n    for (const param of source.parameters) {\n      if (param.type === 'JsdocTypeKeyValue') {\n        if (param.key === 'this') {\n          result.this = param.right;\n        } else if (param.key === 'new') {\n          result.new = param.right;\n        } else {\n          result.params.push(param);\n        }\n      } else {\n        result.params.push(param);\n      }\n    }\n    return result;\n  }\n  function applyPosition(position, target, value) {\n    return position === 'prefix' ? value + target : target + value;\n  }\n  function quote(value, quote) {\n    switch (quote) {\n      case 'double':\n        return `\"${value}\"`;\n      case 'single':\n        return `'${value}'`;\n      case undefined:\n        return value;\n    }\n  }\n  function stringifyRules() {\n    return {\n      JsdocTypeParenthesis: (result, transform) => `(${result.element !== undefined ? transform(result.element) : ''})`,\n      JsdocTypeKeyof: (result, transform) => `keyof ${transform(result.element)}`,\n      JsdocTypeFunction: (result, transform) => {\n        var _a;\n        if (!result.arrow) {\n          let stringified = result.constructor ? 'new' : 'function';\n          if (!result.parenthesis) {\n            return stringified;\n          }\n          stringified += `(${result.parameters.map(transform).join(', ')})`;\n          if (result.returnType !== undefined) {\n            stringified += `: ${transform(result.returnType)}`;\n          }\n          return stringified;\n        } else {\n          if (result.returnType === undefined) {\n            throw new Error('Arrow function needs a return type.');\n          }\n          let stringified = `${result.typeParameters !== undefined ? `<${(_a = result.typeParameters.map(transform).join(', ')) !== null && _a !== void 0 ? _a : ''}>` : ''}(${result.parameters.map(transform).join(', ')}) => ${transform(result.returnType)}`;\n          if (result.constructor) {\n            stringified = 'new ' + stringified;\n          }\n          return stringified;\n        }\n      },\n      JsdocTypeName: result => result.value,\n      JsdocTypeTuple: (result, transform) => `[${result.elements.map(transform).join(', ')}]`,\n      JsdocTypeVariadic: (result, transform) => result.meta.position === undefined ? '...' : applyPosition(result.meta.position, transform(result.element), '...'),\n      JsdocTypeNamePath: (result, transform) => {\n        const left = transform(result.left);\n        const right = transform(result.right);\n        switch (result.pathType) {\n          case 'inner':\n            return `${left}~${right}`;\n          case 'instance':\n            return `${left}#${right}`;\n          case 'property':\n            return `${left}.${right}`;\n          case 'property-brackets':\n            return `${left}[${right}]`;\n        }\n      },\n      JsdocTypeStringValue: result => quote(result.value, result.meta.quote),\n      JsdocTypeAny: () => '*',\n      JsdocTypeGeneric: (result, transform) => {\n        if (result.meta.brackets === 'square') {\n          const element = result.elements[0];\n          const transformed = transform(element);\n          if (element.type === 'JsdocTypeUnion' || element.type === 'JsdocTypeIntersection') {\n            return `(${transformed})[]`;\n          } else {\n            return `${transformed}[]`;\n          }\n        } else {\n          return `${transform(result.left)}${result.meta.dot ? '.' : ''}<${result.infer === true ? 'infer ' : ''}${result.elements.map(transform).join(', ')}>`;\n        }\n      },\n      JsdocTypeImport: (result, transform) => `import(${transform(result.element)})`,\n      JsdocTypeObjectField: (result, transform) => {\n        let text = '';\n        if (result.readonly) {\n          text += 'readonly ';\n        }\n        if (typeof result.key === 'string') {\n          text += quote(result.key, result.meta.quote);\n        } else {\n          text += transform(result.key);\n        }\n        if (result.optional) {\n          text += '?';\n        }\n        if (result.right === undefined) {\n          return text;\n        } else {\n          return text + `: ${transform(result.right)}`;\n        }\n      },\n      JsdocTypeJsdocObjectField: (result, transform) => {\n        return `${transform(result.left)}: ${transform(result.right)}`;\n      },\n      JsdocTypeKeyValue: (result, transform) => {\n        let text = result.key;\n        if (result.optional) {\n          text += '?';\n        }\n        if (result.variadic) {\n          text = '...' + text;\n        }\n        if (result.right === undefined) {\n          return text;\n        } else {\n          return text + `: ${transform(result.right)}`;\n        }\n      },\n      JsdocTypeSpecialNamePath: result => `${result.specialType}:${quote(result.value, result.meta.quote)}`,\n      JsdocTypeNotNullable: (result, transform) => applyPosition(result.meta.position, transform(result.element), '!'),\n      JsdocTypeNull: () => 'null',\n      JsdocTypeNullable: (result, transform) => applyPosition(result.meta.position, transform(result.element), '?'),\n      JsdocTypeNumber: result => result.value.toString(),\n      JsdocTypeObject: (result, transform) => {\n        var _a, _b;\n        return `{${(result.meta.separator === 'linebreak' && result.elements.length > 1 ? '\\n' + ((_a = result.meta.propertyIndent) !== null && _a !== void 0 ? _a : '') : '') + result.elements.map(transform).join(result.meta.separator === 'comma' ? ', ' : result.meta.separator === 'linebreak' ? '\\n' + ((_b = result.meta.propertyIndent) !== null && _b !== void 0 ? _b : '') : '; ') + (result.meta.separator === 'linebreak' && result.elements.length > 1 ? '\\n' : '')}}`;\n      },\n      JsdocTypeOptional: (result, transform) => applyPosition(result.meta.position, transform(result.element), '='),\n      JsdocTypeSymbol: (result, transform) => `${result.value}(${result.element !== undefined ? transform(result.element) : ''})`,\n      JsdocTypeTypeof: (result, transform) => `typeof ${transform(result.element)}`,\n      JsdocTypeUndefined: () => 'undefined',\n      JsdocTypeUnion: (result, transform) => result.elements.map(transform).join(' | '),\n      JsdocTypeUnknown: () => '?',\n      JsdocTypeIntersection: (result, transform) => result.elements.map(transform).join(' & '),\n      JsdocTypeProperty: result => quote(result.value, result.meta.quote),\n      JsdocTypePredicate: (result, transform) => `${transform(result.left)} is ${transform(result.right)}`,\n      JsdocTypeIndexSignature: (result, transform) => `[${result.key}: ${transform(result.right)}]`,\n      JsdocTypeMappedType: (result, transform) => `[${result.key} in ${transform(result.right)}]`,\n      JsdocTypeAsserts: (result, transform) => `asserts ${transform(result.left)} is ${transform(result.right)}`,\n      JsdocTypeReadonlyArray: (result, transform) => `readonly ${transform(result.element)}`,\n      JsdocTypeAssertsPlain: (result, transform) => `asserts ${transform(result.element)}`,\n      JsdocTypeConditional: (result, transform) => `${transform(result.checksType)} extends ${transform(result.extendsType)} ? ${transform(result.trueType)} : ${transform(result.falseType)}`,\n      JsdocTypeTypeParameter: (result, transform) => `${transform(result.name)}${result.constraint !== undefined ? ` extends ${transform(result.constraint)}` : ''}${result.defaultValue !== undefined ? ` = ${transform(result.defaultValue)}` : ''}`\n    };\n  }\n  const storedStringifyRules = stringifyRules();\n  function stringify(result) {\n    return transform(storedStringifyRules, result);\n  }\n  const reservedWords = ['null', 'true', 'false', 'break', 'case', 'catch', 'class', 'const', 'continue', 'debugger', 'default', 'delete', 'do', 'else', 'export', 'extends', 'finally', 'for', 'function', 'if', 'import', 'in', 'instanceof', 'new', 'return', 'super', 'switch', 'this', 'throw', 'try', 'typeof', 'var', 'void', 'while', 'with', 'yield'];\n  function makeName(value) {\n    const result = {\n      type: 'NameExpression',\n      name: value\n    };\n    if (reservedWords.includes(value)) {\n      result.reservedWord = true;\n    }\n    return result;\n  }\n  const catharsisTransformRules = {\n    JsdocTypeOptional: (result, transform) => {\n      const transformed = transform(result.element);\n      transformed.optional = true;\n      return transformed;\n    },\n    JsdocTypeNullable: (result, transform) => {\n      const transformed = transform(result.element);\n      transformed.nullable = true;\n      return transformed;\n    },\n    JsdocTypeNotNullable: (result, transform) => {\n      const transformed = transform(result.element);\n      transformed.nullable = false;\n      return transformed;\n    },\n    JsdocTypeVariadic: (result, transform) => {\n      if (result.element === undefined) {\n        throw new Error('dots without value are not allowed in catharsis mode');\n      }\n      const transformed = transform(result.element);\n      transformed.repeatable = true;\n      return transformed;\n    },\n    JsdocTypeAny: () => ({\n      type: 'AllLiteral'\n    }),\n    JsdocTypeNull: () => ({\n      type: 'NullLiteral'\n    }),\n    JsdocTypeStringValue: result => makeName(quote(result.value, result.meta.quote)),\n    JsdocTypeUndefined: () => ({\n      type: 'UndefinedLiteral'\n    }),\n    JsdocTypeUnknown: () => ({\n      type: 'UnknownLiteral'\n    }),\n    JsdocTypeFunction: (result, transform) => {\n      const params = extractSpecialParams(result);\n      const transformed = {\n        type: 'FunctionType',\n        params: params.params.map(transform)\n      };\n      if (params.this !== undefined) {\n        transformed.this = transform(params.this);\n      }\n      if (params.new !== undefined) {\n        transformed.new = transform(params.new);\n      }\n      if (result.returnType !== undefined) {\n        transformed.result = transform(result.returnType);\n      }\n      return transformed;\n    },\n    JsdocTypeGeneric: (result, transform) => ({\n      type: 'TypeApplication',\n      applications: result.elements.map(o => transform(o)),\n      expression: transform(result.left)\n    }),\n    JsdocTypeSpecialNamePath: result => makeName(result.specialType + ':' + quote(result.value, result.meta.quote)),\n    JsdocTypeName: result => {\n      if (result.value !== 'function') {\n        return makeName(result.value);\n      } else {\n        return {\n          type: 'FunctionType',\n          params: []\n        };\n      }\n    },\n    JsdocTypeNumber: result => makeName(result.value.toString()),\n    JsdocTypeObject: (result, transform) => {\n      const transformed = {\n        type: 'RecordType',\n        fields: []\n      };\n      for (const field of result.elements) {\n        if (field.type !== 'JsdocTypeObjectField' && field.type !== 'JsdocTypeJsdocObjectField') {\n          transformed.fields.push({\n            type: 'FieldType',\n            key: transform(field),\n            value: undefined\n          });\n        } else {\n          transformed.fields.push(transform(field));\n        }\n      }\n      return transformed;\n    },\n    JsdocTypeObjectField: (result, transform) => {\n      if (typeof result.key !== 'string') {\n        throw new Error('Index signatures and mapped types are not supported');\n      }\n      return {\n        type: 'FieldType',\n        key: makeName(quote(result.key, result.meta.quote)),\n        value: result.right === undefined ? undefined : transform(result.right)\n      };\n    },\n    JsdocTypeJsdocObjectField: (result, transform) => ({\n      type: 'FieldType',\n      key: transform(result.left),\n      value: transform(result.right)\n    }),\n    JsdocTypeUnion: (result, transform) => ({\n      type: 'TypeUnion',\n      elements: result.elements.map(e => transform(e))\n    }),\n    JsdocTypeKeyValue: (result, transform) => {\n      return {\n        type: 'FieldType',\n        key: makeName(result.key),\n        value: result.right === undefined ? undefined : transform(result.right)\n      };\n    },\n    JsdocTypeNamePath: (result, transform) => {\n      const leftResult = transform(result.left);\n      let rightValue;\n      if (result.right.type === 'JsdocTypeSpecialNamePath') {\n        rightValue = transform(result.right).name;\n      } else {\n        rightValue = quote(result.right.value, result.right.meta.quote);\n      }\n      const joiner = result.pathType === 'inner' ? '~' : result.pathType === 'instance' ? '#' : '.';\n      return makeName(`${leftResult.name}${joiner}${rightValue}`);\n    },\n    JsdocTypeSymbol: result => {\n      let value = '';\n      let element = result.element;\n      let trailingDots = false;\n      if ((element === null || element === void 0 ? void 0 : element.type) === 'JsdocTypeVariadic') {\n        if (element.meta.position === 'prefix') {\n          value = '...';\n        } else {\n          trailingDots = true;\n        }\n        element = element.element;\n      }\n      if ((element === null || element === void 0 ? void 0 : element.type) === 'JsdocTypeName') {\n        value += element.value;\n      } else if ((element === null || element === void 0 ? void 0 : element.type) === 'JsdocTypeNumber') {\n        value += element.value.toString();\n      }\n      if (trailingDots) {\n        value += '...';\n      }\n      return makeName(`${result.value}(${value})`);\n    },\n    JsdocTypeParenthesis: (result, transform) => transform(assertRootResult(result.element)),\n    JsdocTypeMappedType: notAvailableTransform,\n    JsdocTypeIndexSignature: notAvailableTransform,\n    JsdocTypeImport: notAvailableTransform,\n    JsdocTypeKeyof: notAvailableTransform,\n    JsdocTypeTuple: notAvailableTransform,\n    JsdocTypeTypeof: notAvailableTransform,\n    JsdocTypeIntersection: notAvailableTransform,\n    JsdocTypeProperty: notAvailableTransform,\n    JsdocTypePredicate: notAvailableTransform,\n    JsdocTypeAsserts: notAvailableTransform,\n    JsdocTypeReadonlyArray: notAvailableTransform,\n    JsdocTypeAssertsPlain: notAvailableTransform,\n    JsdocTypeConditional: notAvailableTransform,\n    JsdocTypeTypeParameter: notAvailableTransform\n  };\n  function catharsisTransform(result) {\n    return transform(catharsisTransformRules, result);\n  }\n  function getQuoteStyle(quote) {\n    switch (quote) {\n      case undefined:\n        return 'none';\n      case 'single':\n        return 'single';\n      case 'double':\n        return 'double';\n    }\n  }\n  function getMemberType(type) {\n    switch (type) {\n      case 'inner':\n        return 'INNER_MEMBER';\n      case 'instance':\n        return 'INSTANCE_MEMBER';\n      case 'property':\n        return 'MEMBER';\n      case 'property-brackets':\n        return 'MEMBER';\n    }\n  }\n  function nestResults(type, results) {\n    if (results.length === 2) {\n      return {\n        type,\n        left: results[0],\n        right: results[1]\n      };\n    } else {\n      return {\n        type,\n        left: results[0],\n        right: nestResults(type, results.slice(1))\n      };\n    }\n  }\n  const jtpRules = {\n    JsdocTypeOptional: (result, transform) => ({\n      type: 'OPTIONAL',\n      value: transform(result.element),\n      meta: {\n        syntax: result.meta.position === 'prefix' ? 'PREFIX_EQUAL_SIGN' : 'SUFFIX_EQUALS_SIGN'\n      }\n    }),\n    JsdocTypeNullable: (result, transform) => ({\n      type: 'NULLABLE',\n      value: transform(result.element),\n      meta: {\n        syntax: result.meta.position === 'prefix' ? 'PREFIX_QUESTION_MARK' : 'SUFFIX_QUESTION_MARK'\n      }\n    }),\n    JsdocTypeNotNullable: (result, transform) => ({\n      type: 'NOT_NULLABLE',\n      value: transform(result.element),\n      meta: {\n        syntax: result.meta.position === 'prefix' ? 'PREFIX_BANG' : 'SUFFIX_BANG'\n      }\n    }),\n    JsdocTypeVariadic: (result, transform) => {\n      const transformed = {\n        type: 'VARIADIC',\n        meta: {\n          syntax: result.meta.position === 'prefix' ? 'PREFIX_DOTS' : result.meta.position === 'suffix' ? 'SUFFIX_DOTS' : 'ONLY_DOTS'\n        }\n      };\n      if (result.element !== undefined) {\n        transformed.value = transform(result.element);\n      }\n      return transformed;\n    },\n    JsdocTypeName: result => ({\n      type: 'NAME',\n      name: result.value\n    }),\n    JsdocTypeTypeof: (result, transform) => ({\n      type: 'TYPE_QUERY',\n      name: transform(result.element)\n    }),\n    JsdocTypeTuple: (result, transform) => ({\n      type: 'TUPLE',\n      entries: result.elements.map(transform)\n    }),\n    JsdocTypeKeyof: (result, transform) => ({\n      type: 'KEY_QUERY',\n      value: transform(result.element)\n    }),\n    JsdocTypeImport: result => ({\n      type: 'IMPORT',\n      path: {\n        type: 'STRING_VALUE',\n        quoteStyle: getQuoteStyle(result.element.meta.quote),\n        string: result.element.value\n      }\n    }),\n    JsdocTypeUndefined: () => ({\n      type: 'NAME',\n      name: 'undefined'\n    }),\n    JsdocTypeAny: () => ({\n      type: 'ANY'\n    }),\n    JsdocTypeFunction: (result, transform) => {\n      const specialParams = extractSpecialParams(result);\n      const transformed = {\n        type: result.arrow ? 'ARROW' : 'FUNCTION',\n        params: specialParams.params.map(param => {\n          if (param.type === 'JsdocTypeKeyValue') {\n            if (param.right === undefined) {\n              throw new Error('Function parameter without \\':\\' is not expected to be \\'KEY_VALUE\\'');\n            }\n            return {\n              type: 'NAMED_PARAMETER',\n              name: param.key,\n              typeName: transform(param.right)\n            };\n          } else {\n            return transform(param);\n          }\n        }),\n        new: null,\n        returns: null\n      };\n      if (specialParams.this !== undefined) {\n        transformed.this = transform(specialParams.this);\n      } else if (!result.arrow) {\n        transformed.this = null;\n      }\n      if (specialParams.new !== undefined) {\n        transformed.new = transform(specialParams.new);\n      }\n      if (result.returnType !== undefined) {\n        transformed.returns = transform(result.returnType);\n      }\n      return transformed;\n    },\n    JsdocTypeGeneric: (result, transform) => {\n      const transformed = {\n        type: 'GENERIC',\n        subject: transform(result.left),\n        objects: result.elements.map(transform),\n        meta: {\n          syntax: result.meta.brackets === 'square' ? 'SQUARE_BRACKET' : result.meta.dot ? 'ANGLE_BRACKET_WITH_DOT' : 'ANGLE_BRACKET'\n        }\n      };\n      if (result.meta.brackets === 'square' && result.elements[0].type === 'JsdocTypeFunction' && !result.elements[0].parenthesis) {\n        transformed.objects[0] = {\n          type: 'NAME',\n          name: 'function'\n        };\n      }\n      return transformed;\n    },\n    JsdocTypeObjectField: (result, transform) => {\n      if (typeof result.key !== 'string') {\n        throw new Error('Index signatures and mapped types are not supported');\n      }\n      if (result.right === undefined) {\n        return {\n          type: 'RECORD_ENTRY',\n          key: result.key,\n          quoteStyle: getQuoteStyle(result.meta.quote),\n          value: null,\n          readonly: false\n        };\n      }\n      let right = transform(result.right);\n      if (result.optional) {\n        right = {\n          type: 'OPTIONAL',\n          value: right,\n          meta: {\n            syntax: 'SUFFIX_KEY_QUESTION_MARK'\n          }\n        };\n      }\n      return {\n        type: 'RECORD_ENTRY',\n        key: result.key.toString(),\n        quoteStyle: getQuoteStyle(result.meta.quote),\n        value: right,\n        readonly: false\n      };\n    },\n    JsdocTypeJsdocObjectField: () => {\n      throw new Error('Keys may not be typed in jsdoctypeparser.');\n    },\n    JsdocTypeKeyValue: (result, transform) => {\n      if (result.right === undefined) {\n        return {\n          type: 'RECORD_ENTRY',\n          key: result.key,\n          quoteStyle: 'none',\n          value: null,\n          readonly: false\n        };\n      }\n      let right = transform(result.right);\n      if (result.optional) {\n        right = {\n          type: 'OPTIONAL',\n          value: right,\n          meta: {\n            syntax: 'SUFFIX_KEY_QUESTION_MARK'\n          }\n        };\n      }\n      return {\n        type: 'RECORD_ENTRY',\n        key: result.key,\n        quoteStyle: 'none',\n        value: right,\n        readonly: false\n      };\n    },\n    JsdocTypeObject: (result, transform) => {\n      const entries = [];\n      for (const field of result.elements) {\n        if (field.type === 'JsdocTypeObjectField' || field.type === 'JsdocTypeJsdocObjectField') {\n          entries.push(transform(field));\n        }\n      }\n      return {\n        type: 'RECORD',\n        entries\n      };\n    },\n    JsdocTypeSpecialNamePath: result => {\n      if (result.specialType !== 'module') {\n        throw new Error(`jsdoctypeparser does not support type ${result.specialType} at this point.`);\n      }\n      return {\n        type: 'MODULE',\n        value: {\n          type: 'FILE_PATH',\n          quoteStyle: getQuoteStyle(result.meta.quote),\n          path: result.value\n        }\n      };\n    },\n    JsdocTypeNamePath: (result, transform) => {\n      let hasEventPrefix = false;\n      let name;\n      let quoteStyle;\n      if (result.right.type === 'JsdocTypeSpecialNamePath' && result.right.specialType === 'event') {\n        hasEventPrefix = true;\n        name = result.right.value;\n        quoteStyle = getQuoteStyle(result.right.meta.quote);\n      } else {\n        name = result.right.value;\n        quoteStyle = getQuoteStyle(result.right.meta.quote);\n      }\n      const transformed = {\n        type: getMemberType(result.pathType),\n        owner: transform(result.left),\n        name,\n        quoteStyle,\n        hasEventPrefix\n      };\n      if (transformed.owner.type === 'MODULE') {\n        const tModule = transformed.owner;\n        transformed.owner = transformed.owner.value;\n        tModule.value = transformed;\n        return tModule;\n      } else {\n        return transformed;\n      }\n    },\n    JsdocTypeUnion: (result, transform) => nestResults('UNION', result.elements.map(transform)),\n    JsdocTypeParenthesis: (result, transform) => ({\n      type: 'PARENTHESIS',\n      value: transform(assertRootResult(result.element))\n    }),\n    JsdocTypeNull: () => ({\n      type: 'NAME',\n      name: 'null'\n    }),\n    JsdocTypeUnknown: () => ({\n      type: 'UNKNOWN'\n    }),\n    JsdocTypeStringValue: result => ({\n      type: 'STRING_VALUE',\n      quoteStyle: getQuoteStyle(result.meta.quote),\n      string: result.value\n    }),\n    JsdocTypeIntersection: (result, transform) => nestResults('INTERSECTION', result.elements.map(transform)),\n    JsdocTypeNumber: result => ({\n      type: 'NUMBER_VALUE',\n      number: result.value.toString()\n    }),\n    JsdocTypeSymbol: notAvailableTransform,\n    JsdocTypeProperty: notAvailableTransform,\n    JsdocTypePredicate: notAvailableTransform,\n    JsdocTypeMappedType: notAvailableTransform,\n    JsdocTypeIndexSignature: notAvailableTransform,\n    JsdocTypeAsserts: notAvailableTransform,\n    JsdocTypeReadonlyArray: notAvailableTransform,\n    JsdocTypeAssertsPlain: notAvailableTransform,\n    JsdocTypeConditional: notAvailableTransform,\n    JsdocTypeTypeParameter: notAvailableTransform\n  };\n  function jtpTransform(result) {\n    return transform(jtpRules, result);\n  }\n  function identityTransformRules() {\n    return {\n      JsdocTypeIntersection: (result, transform) => ({\n        type: 'JsdocTypeIntersection',\n        elements: result.elements.map(transform)\n      }),\n      JsdocTypeGeneric: (result, transform) => ({\n        type: 'JsdocTypeGeneric',\n        left: transform(result.left),\n        elements: result.elements.map(transform),\n        meta: {\n          dot: result.meta.dot,\n          brackets: result.meta.brackets\n        }\n      }),\n      JsdocTypeNullable: result => result,\n      JsdocTypeUnion: (result, transform) => ({\n        type: 'JsdocTypeUnion',\n        elements: result.elements.map(transform)\n      }),\n      JsdocTypeUnknown: result => result,\n      JsdocTypeUndefined: result => result,\n      JsdocTypeTypeof: (result, transform) => ({\n        type: 'JsdocTypeTypeof',\n        element: transform(result.element)\n      }),\n      JsdocTypeSymbol: (result, transform) => {\n        const transformed = {\n          type: 'JsdocTypeSymbol',\n          value: result.value\n        };\n        if (result.element !== undefined) {\n          transformed.element = transform(result.element);\n        }\n        return transformed;\n      },\n      JsdocTypeOptional: (result, transform) => ({\n        type: 'JsdocTypeOptional',\n        element: transform(result.element),\n        meta: {\n          position: result.meta.position\n        }\n      }),\n      JsdocTypeObject: (result, transform) => ({\n        type: 'JsdocTypeObject',\n        meta: {\n          separator: 'comma'\n        },\n        elements: result.elements.map(transform)\n      }),\n      JsdocTypeNumber: result => result,\n      JsdocTypeNull: result => result,\n      JsdocTypeNotNullable: (result, transform) => ({\n        type: 'JsdocTypeNotNullable',\n        element: transform(result.element),\n        meta: {\n          position: result.meta.position\n        }\n      }),\n      JsdocTypeSpecialNamePath: result => result,\n      JsdocTypeObjectField: (result, transform) => ({\n        type: 'JsdocTypeObjectField',\n        key: result.key,\n        right: result.right === undefined ? undefined : transform(result.right),\n        optional: result.optional,\n        readonly: result.readonly,\n        meta: result.meta\n      }),\n      JsdocTypeJsdocObjectField: (result, transform) => ({\n        type: 'JsdocTypeJsdocObjectField',\n        left: transform(result.left),\n        right: transform(result.right)\n      }),\n      JsdocTypeKeyValue: (result, transform) => {\n        return {\n          type: 'JsdocTypeKeyValue',\n          key: result.key,\n          right: result.right === undefined ? undefined : transform(result.right),\n          optional: result.optional,\n          variadic: result.variadic\n        };\n      },\n      JsdocTypeImport: (result, transform) => ({\n        type: 'JsdocTypeImport',\n        element: transform(result.element)\n      }),\n      JsdocTypeAny: result => result,\n      JsdocTypeStringValue: result => result,\n      JsdocTypeNamePath: result => result,\n      JsdocTypeVariadic: (result, transform) => {\n        const transformed = {\n          type: 'JsdocTypeVariadic',\n          meta: {\n            position: result.meta.position,\n            squareBrackets: result.meta.squareBrackets\n          }\n        };\n        if (result.element !== undefined) {\n          transformed.element = transform(result.element);\n        }\n        return transformed;\n      },\n      JsdocTypeTuple: (result, transform) => ({\n        type: 'JsdocTypeTuple',\n        elements: result.elements.map(transform)\n      }),\n      JsdocTypeName: result => result,\n      JsdocTypeFunction: (result, transform) => {\n        const transformed = {\n          type: 'JsdocTypeFunction',\n          arrow: result.arrow,\n          parameters: result.parameters.map(transform),\n          constructor: result.constructor,\n          parenthesis: result.parenthesis\n        };\n        if (result.returnType !== undefined) {\n          transformed.returnType = transform(result.returnType);\n        }\n        return transformed;\n      },\n      JsdocTypeKeyof: (result, transform) => ({\n        type: 'JsdocTypeKeyof',\n        element: transform(result.element)\n      }),\n      JsdocTypeParenthesis: (result, transform) => ({\n        type: 'JsdocTypeParenthesis',\n        element: transform(result.element)\n      }),\n      JsdocTypeProperty: result => result,\n      JsdocTypePredicate: (result, transform) => ({\n        type: 'JsdocTypePredicate',\n        left: transform(result.left),\n        right: transform(result.right)\n      }),\n      JsdocTypeIndexSignature: (result, transform) => ({\n        type: 'JsdocTypeIndexSignature',\n        key: result.key,\n        right: transform(result.right)\n      }),\n      JsdocTypeMappedType: (result, transform) => ({\n        type: 'JsdocTypeMappedType',\n        key: result.key,\n        right: transform(result.right)\n      }),\n      JsdocTypeAsserts: (result, transform) => ({\n        type: 'JsdocTypeAsserts',\n        left: transform(result.left),\n        right: transform(result.right)\n      }),\n      JsdocTypeReadonlyArray: (result, transform) => ({\n        type: 'JsdocTypeReadonlyArray',\n        element: transform(result.element)\n      }),\n      JsdocTypeAssertsPlain: (result, transform) => ({\n        type: 'JsdocTypeAssertsPlain',\n        element: transform(result.element)\n      }),\n      JsdocTypeConditional: (result, transform) => ({\n        type: 'JsdocTypeConditional',\n        checksType: transform(result.checksType),\n        extendsType: transform(result.extendsType),\n        trueType: transform(result.trueType),\n        falseType: transform(result.falseType)\n      }),\n      JsdocTypeTypeParameter: (result, transform) => ({\n        type: 'JsdocTypeTypeParameter',\n        name: transform(result.name),\n        constraint: result.constraint !== undefined ? transform(result.constraint) : undefined,\n        defaultValue: result.defaultValue !== undefined ? transform(result.defaultValue) : undefined\n      })\n    };\n  }\n  const visitorKeys = {\n    JsdocTypeAny: [],\n    JsdocTypeFunction: ['parameters', 'returnType'],\n    JsdocTypeGeneric: ['left', 'elements'],\n    JsdocTypeImport: [],\n    JsdocTypeIndexSignature: ['right'],\n    JsdocTypeIntersection: ['elements'],\n    JsdocTypeKeyof: ['element'],\n    JsdocTypeKeyValue: ['right'],\n    JsdocTypeMappedType: ['right'],\n    JsdocTypeName: [],\n    JsdocTypeNamePath: ['left', 'right'],\n    JsdocTypeNotNullable: ['element'],\n    JsdocTypeNull: [],\n    JsdocTypeNullable: ['element'],\n    JsdocTypeNumber: [],\n    JsdocTypeObject: ['elements'],\n    JsdocTypeObjectField: ['right'],\n    JsdocTypeJsdocObjectField: ['left', 'right'],\n    JsdocTypeOptional: ['element'],\n    JsdocTypeParenthesis: ['element'],\n    JsdocTypeSpecialNamePath: [],\n    JsdocTypeStringValue: [],\n    JsdocTypeSymbol: ['element'],\n    JsdocTypeTuple: ['elements'],\n    JsdocTypeTypeof: ['element'],\n    JsdocTypeUndefined: [],\n    JsdocTypeUnion: ['elements'],\n    JsdocTypeUnknown: [],\n    JsdocTypeVariadic: ['element'],\n    JsdocTypeProperty: [],\n    JsdocTypePredicate: ['left', 'right'],\n    JsdocTypeAsserts: ['left', 'right'],\n    JsdocTypeReadonlyArray: ['element'],\n    JsdocTypeAssertsPlain: ['element'],\n    JsdocTypeConditional: ['checksType', 'extendsType', 'trueType', 'falseType'],\n    JsdocTypeTypeParameter: ['name', 'constraint', 'defaultValue']\n  };\n  function _traverse(node, parentNode, property, onEnter, onLeave) {\n    onEnter === null || onEnter === void 0 ? void 0 : onEnter(node, parentNode, property);\n    const keysToVisit = visitorKeys[node.type];\n    for (const key of keysToVisit) {\n      const value = node[key];\n      if (value !== undefined) {\n        if (Array.isArray(value)) {\n          for (const element of value) {\n            _traverse(element, node, key, onEnter, onLeave);\n          }\n        } else {\n          _traverse(value, node, key, onEnter, onLeave);\n        }\n      }\n    }\n    onLeave === null || onLeave === void 0 ? void 0 : onLeave(node, parentNode, property);\n  }\n  /**\n   * A function to traverse an AST. It traverses it depth first.\n   * @param node the node to start traversing at.\n   * @param onEnter node visitor function that will be called on entering the node. This corresponds to preorder traversing.\n   * @param onLeave node visitor function that will be called on leaving the node. This corresponds to postorder traversing.\n   */\n  function traverse(node, onEnter, onLeave) {\n    _traverse(node, undefined, undefined, onEnter, onLeave);\n  }\n  exports.catharsisTransform = catharsisTransform;\n  exports.identityTransformRules = identityTransformRules;\n  exports.jtpTransform = jtpTransform;\n  exports.parse = parse;\n  exports.stringify = stringify;\n  exports.stringifyRules = stringifyRules;\n  exports.transform = transform;\n  exports.traverse = traverse;\n  exports.tryParse = tryParse;\n  exports.visitorKeys = visitorKeys;\n});",
  "map": {
    "version": 3,
    "names": [
      "global",
      "factory",
      "exports",
      "module",
      "define",
      "amd",
      "globalThis",
      "self",
      "jtpp",
      "tokenToString",
      "token",
      "text",
      "undefined",
      "type",
      "NoParsletFoundError",
      "Error",
      "constructor",
      "Object",
      "setPrototypeOf",
      "prototype",
      "getToken",
      "EarlyEndOfParseError",
      "UnexpectedTypeError",
      "result",
      "message",
      "error",
      "makePunctuationRule",
      "startsWith",
      "getQuoted",
      "position",
      "char",
      "mark",
      "escaped",
      "length",
      "slice",
      "identifierStartRegex",
      "identifierContinueRegex",
      "getIdentifier",
      "test",
      "numberRegex",
      "getNumber",
      "_a",
      "_b",
      "exec",
      "identifierRule",
      "value",
      "makeKeyWordRule",
      "prepends",
      "stringValueRule",
      "eofRule",
      "numberRule",
      "rules",
      "breakingWhitespaceRegex",
      "Lexer",
      "create",
      "current",
      "read",
      "next",
      "previous",
      "startOfLine",
      "trim",
      "rule",
      "partial",
      "assign",
      "advance",
      "assertRootResult",
      "assertPlainKeyValueOrRootResult",
      "assertPlainKeyValueResult",
      "assertPlainKeyValueOrNameResult",
      "assertNumberOrVariadicNameResult",
      "element",
      "assertArrayOrTupleResult",
      "meta",
      "brackets",
      "isSquaredProperty",
      "Precedence",
      "Parser",
      "grammar",
      "textOrLexer",
      "baseParser",
      "_lexer",
      "lexer",
      "parse",
      "parseType",
      "ALL",
      "precedence",
      "parseIntermediateType",
      "tryParslets",
      "parseInfixIntermediateType",
      "left",
      "parslet",
      "consume",
      "types",
      "Array",
      "isArray",
      "includes",
      "acceptLexerState",
      "parser",
      "isQuestionMarkUnknownType",
      "nullableParslet",
      "accept",
      "NULLABLE",
      "composeParslet",
      "options",
      "curPrecedence",
      "parsePrefix",
      "parseInfix",
      "defineProperty",
      "name",
      "optionalParslet",
      "OPTIONAL",
      "numberParslet",
      "parseFloat",
      "parenthesisParslet",
      "elements",
      "specialTypesParslet",
      "notNullableParslet",
      "createParameterListParslet",
      "allowTrailingComma",
      "PARAMETER_LIST",
      "push",
      "e",
      "some",
      "genericParslet",
      "GENERIC",
      "dot",
      "objects",
      "infer",
      "SYMBOL",
      "unionParslet",
      "UNION",
      "baseGrammar",
      "createNamePathParslet",
      "allowSquareBracketsOnAnyType",
      "allowJsdocNamePaths",
      "pathGrammar",
      "namePathParslet",
      "NAME_PATH",
      "pathType",
      "pathParser",
      "parsed",
      "right",
      "quote",
      "toString",
      "specialType",
      "createNameParslet",
      "allowedAdditionalTokens",
      "stringValueParslet",
      "createSpecialNamePathParslet",
      "allowedTypes",
      "allowed",
      "moduleParser",
      "moduleResult",
      "basePathGrammar",
      "getParameters",
      "parameters",
      "map",
      "p",
      "getUnnamedParameters",
      "createFunctionParslet",
      "allowNamedParameters",
      "allowNoReturnType",
      "allowWithoutParenthesis",
      "allowNewAsFunctionKeyword",
      "newKeyword",
      "hasParenthesis",
      "arrow",
      "parenthesis",
      "FUNCTION",
      "key",
      "join",
      "returnType",
      "PREFIX",
      "createVariadicParslet",
      "allowPostfix",
      "allowEnclosingBrackets",
      "squareBrackets",
      "symbolParslet",
      "arrayBracketsParslet",
      "ARRAY_BRACKETS",
      "createObjectParslet",
      "objectFieldGrammar",
      "allowKeyTypes",
      "separator",
      "fieldParser",
      "field",
      "OBJECT",
      "optional",
      "readonly",
      "propertyIndent",
      "createObjectFieldParslet",
      "allowSquaredProperties",
      "allowReadonly",
      "allowOptional",
      "KEY_VALUE",
      "readonlyProperty",
      "parentParser",
      "createKeyValueParslet",
      "allowVariadic",
      "variadic",
      "jsdocBaseGrammar",
      "jsdocGrammar",
      "typeOfParslet",
      "KEY_OF_TYPE_OF",
      "objectFieldGrammar$1",
      "closureGrammar",
      "assertsParslet",
      "INFIX",
      "createTupleParslet",
      "allowQuestionMark",
      "typeList",
      "keyOfParslet",
      "importParslet",
      "path",
      "readonlyPropertyParslet",
      "arrowFunctionParslet",
      "ARROW",
      "genericArrowFunctionParslet",
      "typeParameters",
      "defaultValue",
      "constraint",
      "typeParameter",
      "functionBase",
      "intersectionParslet",
      "INTERSECTION",
      "predicateParslet",
      "objectSquaredPropertyParslet",
      "INDEX_BRACKETS",
      "readonlyArrayParslet",
      "conditionalParslet",
      "extendsType",
      "trueType",
      "checksType",
      "falseType",
      "typescriptGrammar",
      "expression",
      "mode",
      "tryParse",
      "modes",
      "transform",
      "parseResult",
      "aParseResult",
      "notAvailableTransform",
      "extractSpecialParams",
      "source",
      "params",
      "param",
      "this",
      "new",
      "applyPosition",
      "target",
      "stringifyRules",
      "JsdocTypeParenthesis",
      "JsdocTypeKeyof",
      "JsdocTypeFunction",
      "stringified",
      "JsdocTypeName",
      "JsdocTypeTuple",
      "JsdocTypeVariadic",
      "JsdocTypeNamePath",
      "JsdocTypeStringValue",
      "JsdocTypeAny",
      "JsdocTypeGeneric",
      "transformed",
      "JsdocTypeImport",
      "JsdocTypeObjectField",
      "JsdocTypeJsdocObjectField",
      "JsdocTypeKeyValue",
      "JsdocTypeSpecialNamePath",
      "JsdocTypeNotNullable",
      "JsdocTypeNull",
      "JsdocTypeNullable",
      "JsdocTypeNumber",
      "JsdocTypeObject",
      "JsdocTypeOptional",
      "JsdocTypeSymbol",
      "JsdocTypeTypeof",
      "JsdocTypeUndefined",
      "JsdocTypeUnion",
      "JsdocTypeUnknown",
      "JsdocTypeIntersection",
      "JsdocTypeProperty",
      "JsdocTypePredicate",
      "JsdocTypeIndexSignature",
      "JsdocTypeMappedType",
      "JsdocTypeAsserts",
      "JsdocTypeReadonlyArray",
      "JsdocTypeAssertsPlain",
      "JsdocTypeConditional",
      "JsdocTypeTypeParameter",
      "storedStringifyRules",
      "stringify",
      "reservedWords",
      "makeName",
      "reservedWord",
      "catharsisTransformRules",
      "nullable",
      "repeatable",
      "applications",
      "o",
      "fields",
      "leftResult",
      "rightValue",
      "joiner",
      "trailingDots",
      "catharsisTransform",
      "getQuoteStyle",
      "getMemberType",
      "nestResults",
      "results",
      "jtpRules",
      "syntax",
      "entries",
      "quoteStyle",
      "string",
      "specialParams",
      "typeName",
      "returns",
      "subject",
      "hasEventPrefix",
      "owner",
      "tModule",
      "number",
      "jtpTransform",
      "identityTransformRules",
      "visitorKeys",
      "_traverse",
      "node",
      "parentNode",
      "property",
      "onEnter",
      "onLeave",
      "keysToVisit",
      "traverse"
    ],
    "sources": [
      "/home/sanghamitrad/Documents/open-source/pivot-tablesrc/PivotHead/node_modules/.pnpm/jsdoc-type-pratt-parser@4.8.0/node_modules/jsdoc-type-pratt-parser/dist/index.js"
    ],
    "sourcesContent": [
      "(function (global, factory) {\n    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :\n    typeof define === 'function' && define.amd ? define(['exports'], factory) :\n    (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.jtpp = {}));\n})(this, (function (exports) { 'use strict';\n\n    function tokenToString(token) {\n        if (token.text !== undefined && token.text !== '') {\n            return `'${token.type}' with value '${token.text}'`;\n        }\n        else {\n            return `'${token.type}'`;\n        }\n    }\n    class NoParsletFoundError extends Error {\n        constructor(token) {\n            super(`No parslet found for token: ${tokenToString(token)}`);\n            this.token = token;\n            Object.setPrototypeOf(this, NoParsletFoundError.prototype);\n        }\n        getToken() {\n            return this.token;\n        }\n    }\n    class EarlyEndOfParseError extends Error {\n        constructor(token) {\n            super(`The parsing ended early. The next token was: ${tokenToString(token)}`);\n            this.token = token;\n            Object.setPrototypeOf(this, EarlyEndOfParseError.prototype);\n        }\n        getToken() {\n            return this.token;\n        }\n    }\n    class UnexpectedTypeError extends Error {\n        constructor(result, message) {\n            let error = `Unexpected type: '${result.type}'.`;\n            if (message !== undefined) {\n                error += ` Message: ${message}`;\n            }\n            super(error);\n            Object.setPrototypeOf(this, UnexpectedTypeError.prototype);\n        }\n    }\n    // export class UnexpectedTokenError extends Error {\n    //   private expected: Token\n    //   private found: Token\n    //\n    //   constructor (expected: Token, found: Token) {\n    //     super(`The parsing ended early. The next token was: ${tokenToString(token)}`)\n    //\n    //     this.token = token\n    //\n    //     Object.setPrototypeOf(this, EarlyEndOfParseError.prototype)\n    //   }\n    //\n    //   getToken() {\n    //     return this.token\n    //   }\n    // }\n\n    function makePunctuationRule(type) {\n        return text => {\n            if (text.startsWith(type)) {\n                return { type, text: type };\n            }\n            else {\n                return null;\n            }\n        };\n    }\n    function getQuoted(text) {\n        let position = 0;\n        let char;\n        const mark = text[0];\n        let escaped = false;\n        if (mark !== '\\'' && mark !== '\"') {\n            return null;\n        }\n        while (position < text.length) {\n            position++;\n            char = text[position];\n            if (!escaped && char === mark) {\n                position++;\n                break;\n            }\n            escaped = !escaped && char === '\\\\';\n        }\n        if (char !== mark) {\n            throw new Error('Unterminated String');\n        }\n        return text.slice(0, position);\n    }\n    const identifierStartRegex = /[$_\\p{ID_Start}]|\\\\u\\p{Hex_Digit}{4}|\\\\u\\{0*(?:\\p{Hex_Digit}{1,5}|10\\p{Hex_Digit}{4})\\}/u;\n    // A hyphen is not technically allowed, but to keep it liberal for now,\n    //  adding it here\n    const identifierContinueRegex = /[$\\-\\p{ID_Continue}\\u200C\\u200D]|\\\\u\\p{Hex_Digit}{4}|\\\\u\\{0*(?:\\p{Hex_Digit}{1,5}|10\\p{Hex_Digit}{4})\\}/u;\n    function getIdentifier(text) {\n        let char = text[0];\n        if (!identifierStartRegex.test(char)) {\n            return null;\n        }\n        let position = 1;\n        do {\n            char = text[position];\n            if (!identifierContinueRegex.test(char)) {\n                break;\n            }\n            position++;\n        } while (position < text.length);\n        return text.slice(0, position);\n    }\n    // we are a bit more liberal than TypeScript here and allow `NaN`, `Infinity` and `-Infinity`\n    const numberRegex = /^(NaN|-?((\\d*\\.\\d+|\\d+)([Ee][+-]?\\d+)?|Infinity))/;\n    function getNumber(text) {\n        var _a, _b;\n        return (_b = (_a = numberRegex.exec(text)) === null || _a === void 0 ? void 0 : _a[0]) !== null && _b !== void 0 ? _b : null;\n    }\n    const identifierRule = text => {\n        const value = getIdentifier(text);\n        if (value == null) {\n            return null;\n        }\n        return {\n            type: 'Identifier',\n            text: value\n        };\n    };\n    function makeKeyWordRule(type) {\n        return text => {\n            if (!text.startsWith(type)) {\n                return null;\n            }\n            const prepends = text[type.length];\n            if (prepends !== undefined && identifierContinueRegex.test(prepends)) {\n                return null;\n            }\n            return {\n                type,\n                text: type\n            };\n        };\n    }\n    const stringValueRule = text => {\n        const value = getQuoted(text);\n        if (value == null) {\n            return null;\n        }\n        return {\n            type: 'StringValue',\n            text: value\n        };\n    };\n    const eofRule = text => {\n        if (text.length > 0) {\n            return null;\n        }\n        return {\n            type: 'EOF',\n            text: ''\n        };\n    };\n    const numberRule = text => {\n        const value = getNumber(text);\n        if (value === null) {\n            return null;\n        }\n        return {\n            type: 'Number',\n            text: value\n        };\n    };\n    const rules = [\n        eofRule,\n        makePunctuationRule('=>'),\n        makePunctuationRule('('),\n        makePunctuationRule(')'),\n        makePunctuationRule('{'),\n        makePunctuationRule('}'),\n        makePunctuationRule('['),\n        makePunctuationRule(']'),\n        makePunctuationRule('|'),\n        makePunctuationRule('&'),\n        makePunctuationRule('<'),\n        makePunctuationRule('>'),\n        makePunctuationRule(','),\n        makePunctuationRule(';'),\n        makePunctuationRule('*'),\n        makePunctuationRule('?'),\n        makePunctuationRule('!'),\n        makePunctuationRule('='),\n        makePunctuationRule(':'),\n        makePunctuationRule('...'),\n        makePunctuationRule('.'),\n        makePunctuationRule('#'),\n        makePunctuationRule('~'),\n        makePunctuationRule('/'),\n        makePunctuationRule('@'),\n        makeKeyWordRule('undefined'),\n        makeKeyWordRule('null'),\n        makeKeyWordRule('function'),\n        makeKeyWordRule('this'),\n        makeKeyWordRule('new'),\n        makeKeyWordRule('module'),\n        makeKeyWordRule('event'),\n        makeKeyWordRule('extends'),\n        makeKeyWordRule('external'),\n        makeKeyWordRule('infer'),\n        makeKeyWordRule('typeof'),\n        makeKeyWordRule('keyof'),\n        makeKeyWordRule('readonly'),\n        makeKeyWordRule('import'),\n        makeKeyWordRule('is'),\n        makeKeyWordRule('in'),\n        makeKeyWordRule('asserts'),\n        numberRule,\n        identifierRule,\n        stringValueRule\n    ];\n    const breakingWhitespaceRegex = /^\\s*\\n\\s*/;\n    class Lexer {\n        static create(text) {\n            const current = this.read(text);\n            text = current.text;\n            const next = this.read(text);\n            text = next.text;\n            return new Lexer(text, undefined, current.token, next.token);\n        }\n        constructor(text, previous, current, next) {\n            this.text = '';\n            this.text = text;\n            this.previous = previous;\n            this.current = current;\n            this.next = next;\n        }\n        static read(text, startOfLine = false) {\n            startOfLine = startOfLine || breakingWhitespaceRegex.test(text);\n            text = text.trim();\n            for (const rule of rules) {\n                const partial = rule(text);\n                if (partial !== null) {\n                    const token = Object.assign(Object.assign({}, partial), { startOfLine });\n                    text = text.slice(token.text.length);\n                    return { text, token };\n                }\n            }\n            throw new Error('Unexpected Token ' + text);\n        }\n        advance() {\n            const next = Lexer.read(this.text);\n            return new Lexer(next.text, this.current, this.next, next.token);\n        }\n    }\n\n    /**\n     * Throws an error if the provided result is not a {@link RootResult}\n     */\n    function assertRootResult(result) {\n        if (result === undefined) {\n            throw new Error('Unexpected undefined');\n        }\n        if (result.type === 'JsdocTypeKeyValue' || result.type === 'JsdocTypeParameterList' ||\n            result.type === 'JsdocTypeProperty' || result.type === 'JsdocTypeReadonlyProperty' ||\n            result.type === 'JsdocTypeObjectField' || result.type === 'JsdocTypeJsdocObjectField' ||\n            result.type === 'JsdocTypeIndexSignature' || result.type === 'JsdocTypeMappedType' ||\n            result.type === 'JsdocTypeTypeParameter') {\n            throw new UnexpectedTypeError(result);\n        }\n        return result;\n    }\n    function assertPlainKeyValueOrRootResult(result) {\n        if (result.type === 'JsdocTypeKeyValue') {\n            return assertPlainKeyValueResult(result);\n        }\n        return assertRootResult(result);\n    }\n    function assertPlainKeyValueOrNameResult(result) {\n        if (result.type === 'JsdocTypeName') {\n            return result;\n        }\n        return assertPlainKeyValueResult(result);\n    }\n    function assertPlainKeyValueResult(result) {\n        if (result.type !== 'JsdocTypeKeyValue') {\n            throw new UnexpectedTypeError(result);\n        }\n        return result;\n    }\n    function assertNumberOrVariadicNameResult(result) {\n        var _a;\n        if (result.type === 'JsdocTypeVariadic') {\n            if (((_a = result.element) === null || _a === void 0 ? void 0 : _a.type) === 'JsdocTypeName') {\n                return result;\n            }\n            throw new UnexpectedTypeError(result);\n        }\n        if (result.type !== 'JsdocTypeNumber' && result.type !== 'JsdocTypeName') {\n            throw new UnexpectedTypeError(result);\n        }\n        return result;\n    }\n    function assertArrayOrTupleResult(result) {\n        if (result.type === 'JsdocTypeTuple') {\n            return result;\n        }\n        if (result.type === 'JsdocTypeGeneric' && result.meta.brackets === 'square') {\n            return result;\n        }\n        throw new UnexpectedTypeError(result);\n    }\n    function isSquaredProperty(result) {\n        return result.type === 'JsdocTypeIndexSignature' || result.type === 'JsdocTypeMappedType';\n    }\n\n    // higher precedence = higher importance\n    var Precedence;\n    (function (Precedence) {\n        Precedence[Precedence[\"ALL\"] = 0] = \"ALL\";\n        Precedence[Precedence[\"PARAMETER_LIST\"] = 1] = \"PARAMETER_LIST\";\n        Precedence[Precedence[\"OBJECT\"] = 2] = \"OBJECT\";\n        Precedence[Precedence[\"KEY_VALUE\"] = 3] = \"KEY_VALUE\";\n        Precedence[Precedence[\"INDEX_BRACKETS\"] = 4] = \"INDEX_BRACKETS\";\n        Precedence[Precedence[\"UNION\"] = 5] = \"UNION\";\n        Precedence[Precedence[\"INTERSECTION\"] = 6] = \"INTERSECTION\";\n        Precedence[Precedence[\"PREFIX\"] = 7] = \"PREFIX\";\n        Precedence[Precedence[\"INFIX\"] = 8] = \"INFIX\";\n        Precedence[Precedence[\"TUPLE\"] = 9] = \"TUPLE\";\n        Precedence[Precedence[\"SYMBOL\"] = 10] = \"SYMBOL\";\n        Precedence[Precedence[\"OPTIONAL\"] = 11] = \"OPTIONAL\";\n        Precedence[Precedence[\"NULLABLE\"] = 12] = \"NULLABLE\";\n        Precedence[Precedence[\"KEY_OF_TYPE_OF\"] = 13] = \"KEY_OF_TYPE_OF\";\n        Precedence[Precedence[\"FUNCTION\"] = 14] = \"FUNCTION\";\n        Precedence[Precedence[\"ARROW\"] = 15] = \"ARROW\";\n        Precedence[Precedence[\"ARRAY_BRACKETS\"] = 16] = \"ARRAY_BRACKETS\";\n        Precedence[Precedence[\"GENERIC\"] = 17] = \"GENERIC\";\n        Precedence[Precedence[\"NAME_PATH\"] = 18] = \"NAME_PATH\";\n        Precedence[Precedence[\"PARENTHESIS\"] = 19] = \"PARENTHESIS\";\n        Precedence[Precedence[\"SPECIAL_TYPES\"] = 20] = \"SPECIAL_TYPES\";\n    })(Precedence || (Precedence = {}));\n\n    class Parser {\n        constructor(grammar, textOrLexer, baseParser) {\n            this.grammar = grammar;\n            if (typeof textOrLexer === 'string') {\n                this._lexer = Lexer.create(textOrLexer);\n            }\n            else {\n                this._lexer = textOrLexer;\n            }\n            this.baseParser = baseParser;\n        }\n        get lexer() {\n            return this._lexer;\n        }\n        /**\n         * Parses a given string and throws an error if the parse ended before the end of the string.\n         */\n        parse() {\n            const result = this.parseType(Precedence.ALL);\n            if (this.lexer.current.type !== 'EOF') {\n                throw new EarlyEndOfParseError(this.lexer.current);\n            }\n            return result;\n        }\n        /**\n         * Parses with the current lexer and asserts that the result is a {@link RootResult}.\n         */\n        parseType(precedence) {\n            return assertRootResult(this.parseIntermediateType(precedence));\n        }\n        /**\n         * The main parsing function. First it tries to parse the current state in the prefix step, and then it continues\n         * to parse the state in the infix step.\n         */\n        parseIntermediateType(precedence) {\n            const result = this.tryParslets(null, precedence);\n            if (result === null) {\n                throw new NoParsletFoundError(this.lexer.current);\n            }\n            return this.parseInfixIntermediateType(result, precedence);\n        }\n        /**\n         * In the infix parsing step the parser continues to parse the current state with all parslets until none returns\n         * a result.\n         */\n        parseInfixIntermediateType(left, precedence) {\n            let result = this.tryParslets(left, precedence);\n            while (result !== null) {\n                left = result;\n                result = this.tryParslets(left, precedence);\n            }\n            return left;\n        }\n        /**\n         * Tries to parse the current state with all parslets in the grammar and returns the first non null result.\n         */\n        tryParslets(left, precedence) {\n            for (const parslet of this.grammar) {\n                const result = parslet(this, precedence, left);\n                if (result !== null) {\n                    return result;\n                }\n            }\n            return null;\n        }\n        /**\n         * If the given type equals the current type of the {@link Lexer} advance the lexer. Return true if the lexer was\n         * advanced.\n         */\n        consume(types) {\n            if (!Array.isArray(types)) {\n                types = [types];\n            }\n            if (types.includes(this.lexer.current.type)) {\n                this._lexer = this.lexer.advance();\n                return true;\n            }\n            else {\n                return false;\n            }\n        }\n        acceptLexerState(parser) {\n            this._lexer = parser.lexer;\n        }\n    }\n\n    function isQuestionMarkUnknownType(next) {\n        return next === '}' || next === 'EOF' || next === '|' || next === ',' || next === ')' || next === '>';\n    }\n\n    const nullableParslet = (parser, precedence, left) => {\n        const type = parser.lexer.current.type;\n        const next = parser.lexer.next.type;\n        const accept = ((left == null) && type === '?' && !isQuestionMarkUnknownType(next)) ||\n            ((left != null) && type === '?');\n        if (!accept) {\n            return null;\n        }\n        parser.consume('?');\n        if (left == null) {\n            return {\n                type: 'JsdocTypeNullable',\n                element: parser.parseType(Precedence.NULLABLE),\n                meta: {\n                    position: 'prefix'\n                }\n            };\n        }\n        else {\n            return {\n                type: 'JsdocTypeNullable',\n                element: assertRootResult(left),\n                meta: {\n                    position: 'suffix'\n                }\n            };\n        }\n    };\n\n    function composeParslet(options) {\n        const parslet = (parser, curPrecedence, left) => {\n            const type = parser.lexer.current.type;\n            const next = parser.lexer.next.type;\n            if (left === null) {\n                if ('parsePrefix' in options) {\n                    if (options.accept(type, next)) {\n                        return options.parsePrefix(parser);\n                    }\n                }\n            }\n            else {\n                if ('parseInfix' in options) {\n                    if (options.precedence > curPrecedence && options.accept(type, next)) {\n                        return options.parseInfix(parser, left);\n                    }\n                }\n            }\n            return null;\n        };\n        // for debugging\n        Object.defineProperty(parslet, 'name', {\n            value: options.name\n        });\n        return parslet;\n    }\n\n    const optionalParslet = composeParslet({\n        name: 'optionalParslet',\n        accept: type => type === '=',\n        precedence: Precedence.OPTIONAL,\n        parsePrefix: parser => {\n            parser.consume('=');\n            return {\n                type: 'JsdocTypeOptional',\n                element: parser.parseType(Precedence.OPTIONAL),\n                meta: {\n                    position: 'prefix'\n                }\n            };\n        },\n        parseInfix: (parser, left) => {\n            parser.consume('=');\n            return {\n                type: 'JsdocTypeOptional',\n                element: assertRootResult(left),\n                meta: {\n                    position: 'suffix'\n                }\n            };\n        }\n    });\n\n    const numberParslet = composeParslet({\n        name: 'numberParslet',\n        accept: type => type === 'Number',\n        parsePrefix: parser => {\n            const value = parseFloat(parser.lexer.current.text);\n            parser.consume('Number');\n            return {\n                type: 'JsdocTypeNumber',\n                value\n            };\n        }\n    });\n\n    const parenthesisParslet = composeParslet({\n        name: 'parenthesisParslet',\n        accept: type => type === '(',\n        parsePrefix: parser => {\n            parser.consume('(');\n            if (parser.consume(')')) {\n                return {\n                    type: 'JsdocTypeParameterList',\n                    elements: []\n                };\n            }\n            const result = parser.parseIntermediateType(Precedence.ALL);\n            if (!parser.consume(')')) {\n                throw new Error('Unterminated parenthesis');\n            }\n            if (result.type === 'JsdocTypeParameterList') {\n                return result;\n            }\n            else if (result.type === 'JsdocTypeKeyValue') {\n                return {\n                    type: 'JsdocTypeParameterList',\n                    elements: [result]\n                };\n            }\n            return {\n                type: 'JsdocTypeParenthesis',\n                element: assertRootResult(result)\n            };\n        }\n    });\n\n    const specialTypesParslet = composeParslet({\n        name: 'specialTypesParslet',\n        accept: (type, next) => (type === '?' && isQuestionMarkUnknownType(next)) ||\n            type === 'null' || type === 'undefined' || type === '*',\n        parsePrefix: parser => {\n            if (parser.consume('null')) {\n                return {\n                    type: 'JsdocTypeNull'\n                };\n            }\n            if (parser.consume('undefined')) {\n                return {\n                    type: 'JsdocTypeUndefined'\n                };\n            }\n            if (parser.consume('*')) {\n                return {\n                    type: 'JsdocTypeAny'\n                };\n            }\n            if (parser.consume('?')) {\n                return {\n                    type: 'JsdocTypeUnknown'\n                };\n            }\n            throw new Error('Unacceptable token: ' + parser.lexer.current.text);\n        }\n    });\n\n    const notNullableParslet = composeParslet({\n        name: 'notNullableParslet',\n        accept: type => type === '!',\n        precedence: Precedence.NULLABLE,\n        parsePrefix: parser => {\n            parser.consume('!');\n            return {\n                type: 'JsdocTypeNotNullable',\n                element: parser.parseType(Precedence.NULLABLE),\n                meta: {\n                    position: 'prefix'\n                }\n            };\n        },\n        parseInfix: (parser, left) => {\n            parser.consume('!');\n            return {\n                type: 'JsdocTypeNotNullable',\n                element: assertRootResult(left),\n                meta: {\n                    position: 'suffix'\n                }\n            };\n        }\n    });\n\n    function createParameterListParslet({ allowTrailingComma }) {\n        return composeParslet({\n            name: 'parameterListParslet',\n            accept: type => type === ',',\n            precedence: Precedence.PARAMETER_LIST,\n            parseInfix: (parser, left) => {\n                const elements = [\n                    assertPlainKeyValueOrRootResult(left)\n                ];\n                parser.consume(',');\n                do {\n                    try {\n                        const next = parser.parseIntermediateType(Precedence.PARAMETER_LIST);\n                        elements.push(assertPlainKeyValueOrRootResult(next));\n                    }\n                    catch (e) {\n                        if (e instanceof NoParsletFoundError) {\n                            break;\n                        }\n                        else {\n                            throw e;\n                        }\n                    }\n                } while (parser.consume(','));\n                if (elements.length > 0 && elements.slice(0, -1).some(e => e.type === 'JsdocTypeVariadic')) {\n                    throw new Error('Only the last parameter may be a rest parameter');\n                }\n                return {\n                    type: 'JsdocTypeParameterList',\n                    elements\n                };\n            }\n        });\n    }\n\n    const genericParslet = composeParslet({\n        name: 'genericParslet',\n        accept: (type, next) => type === '<' || (type === '.' && next === '<'),\n        precedence: Precedence.GENERIC,\n        parseInfix: (parser, left) => {\n            const dot = parser.consume('.');\n            parser.consume('<');\n            const objects = [];\n            let infer = false;\n            if (parser.consume('infer')) {\n                infer = true;\n                const left = parser.parseIntermediateType(Precedence.SYMBOL);\n                if (left.type !== 'JsdocTypeName') {\n                    throw new UnexpectedTypeError(left, 'A typescript asserts always has to have a name on the left side.');\n                }\n                objects.push(left);\n            }\n            else {\n                do {\n                    objects.push(parser.parseType(Precedence.PARAMETER_LIST));\n                } while (parser.consume(','));\n            }\n            if (!parser.consume('>')) {\n                throw new Error('Unterminated generic parameter list');\n            }\n            return Object.assign(Object.assign({ type: 'JsdocTypeGeneric', left: assertRootResult(left), elements: objects }, (infer ? { infer: true } : {})), { meta: {\n                    brackets: 'angle',\n                    dot\n                } });\n        }\n    });\n\n    const unionParslet = composeParslet({\n        name: 'unionParslet',\n        accept: type => type === '|',\n        precedence: Precedence.UNION,\n        parseInfix: (parser, left) => {\n            parser.consume('|');\n            const elements = [];\n            do {\n                elements.push(parser.parseType(Precedence.UNION));\n            } while (parser.consume('|'));\n            return {\n                type: 'JsdocTypeUnion',\n                elements: [assertRootResult(left), ...elements]\n            };\n        }\n    });\n\n    const baseGrammar = [\n        nullableParslet,\n        optionalParslet,\n        numberParslet,\n        parenthesisParslet,\n        specialTypesParslet,\n        notNullableParslet,\n        createParameterListParslet({\n            allowTrailingComma: true\n        }),\n        genericParslet,\n        unionParslet,\n        optionalParslet\n    ];\n\n    function createNamePathParslet({ allowSquareBracketsOnAnyType, allowJsdocNamePaths, pathGrammar }) {\n        return function namePathParslet(parser, precedence, left) {\n            if ((left == null) || precedence >= Precedence.NAME_PATH) {\n                return null;\n            }\n            const type = parser.lexer.current.type;\n            const next = parser.lexer.next.type;\n            const accept = (type === '.' && next !== '<') ||\n                (type === '[' && (allowSquareBracketsOnAnyType || left.type === 'JsdocTypeName')) ||\n                (allowJsdocNamePaths && (type === '~' || type === '#'));\n            if (!accept) {\n                return null;\n            }\n            let pathType;\n            let brackets = false;\n            if (parser.consume('.')) {\n                pathType = 'property';\n            }\n            else if (parser.consume('[')) {\n                pathType = 'property-brackets';\n                brackets = true;\n            }\n            else if (parser.consume('~')) {\n                pathType = 'inner';\n            }\n            else {\n                parser.consume('#');\n                pathType = 'instance';\n            }\n            const pathParser = pathGrammar !== null\n                ? new Parser(pathGrammar, parser.lexer, parser)\n                : parser;\n            const parsed = pathParser.parseIntermediateType(Precedence.NAME_PATH);\n            parser.acceptLexerState(pathParser);\n            let right;\n            switch (parsed.type) {\n                case 'JsdocTypeName':\n                    right = {\n                        type: 'JsdocTypeProperty',\n                        value: parsed.value,\n                        meta: {\n                            quote: undefined\n                        }\n                    };\n                    break;\n                case 'JsdocTypeNumber':\n                    right = {\n                        type: 'JsdocTypeProperty',\n                        value: parsed.value.toString(10),\n                        meta: {\n                            quote: undefined\n                        }\n                    };\n                    break;\n                case 'JsdocTypeStringValue':\n                    right = {\n                        type: 'JsdocTypeProperty',\n                        value: parsed.value,\n                        meta: {\n                            quote: parsed.meta.quote\n                        }\n                    };\n                    break;\n                case 'JsdocTypeSpecialNamePath':\n                    if (parsed.specialType === 'event') {\n                        right = parsed;\n                    }\n                    else {\n                        throw new UnexpectedTypeError(parsed, 'Type \\'JsdocTypeSpecialNamePath\\' is only allowed with specialType \\'event\\'');\n                    }\n                    break;\n                default:\n                    throw new UnexpectedTypeError(parsed, 'Expecting \\'JsdocTypeName\\', \\'JsdocTypeNumber\\', \\'JsdocStringValue\\' or \\'JsdocTypeSpecialNamePath\\'');\n            }\n            if (brackets && !parser.consume(']')) {\n                const token = parser.lexer.current;\n                throw new Error(`Unterminated square brackets. Next token is '${token.type}' ` +\n                    `with text '${token.text}'`);\n            }\n            return {\n                type: 'JsdocTypeNamePath',\n                left: assertRootResult(left),\n                right,\n                pathType\n            };\n        };\n    }\n\n    function createNameParslet({ allowedAdditionalTokens }) {\n        return composeParslet({\n            name: 'nameParslet',\n            accept: type => type === 'Identifier' || type === 'this' || type === 'new' || allowedAdditionalTokens.includes(type),\n            parsePrefix: parser => {\n                const { type, text } = parser.lexer.current;\n                parser.consume(type);\n                return {\n                    type: 'JsdocTypeName',\n                    value: text\n                };\n            }\n        });\n    }\n\n    const stringValueParslet = composeParslet({\n        name: 'stringValueParslet',\n        accept: type => type === 'StringValue',\n        parsePrefix: parser => {\n            const text = parser.lexer.current.text;\n            parser.consume('StringValue');\n            return {\n                type: 'JsdocTypeStringValue',\n                value: text.slice(1, -1),\n                meta: {\n                    quote: text[0] === '\\'' ? 'single' : 'double'\n                }\n            };\n        }\n    });\n\n    function createSpecialNamePathParslet({ pathGrammar, allowedTypes }) {\n        return composeParslet({\n            name: 'specialNamePathParslet',\n            accept: type => allowedTypes.includes(type),\n            parsePrefix: parser => {\n                const type = parser.lexer.current.type;\n                parser.consume(type);\n                if (!parser.consume(':')) {\n                    return {\n                        type: 'JsdocTypeName',\n                        value: type\n                    };\n                }\n                let result;\n                let token = parser.lexer.current;\n                if (parser.consume('StringValue')) {\n                    result = {\n                        type: 'JsdocTypeSpecialNamePath',\n                        value: token.text.slice(1, -1),\n                        specialType: type,\n                        meta: {\n                            quote: token.text[0] === '\\'' ? 'single' : 'double'\n                        }\n                    };\n                }\n                else {\n                    let value = '';\n                    const allowed = ['Identifier', '@', '/'];\n                    while (allowed.some(type => parser.consume(type))) {\n                        value += token.text;\n                        token = parser.lexer.current;\n                    }\n                    result = {\n                        type: 'JsdocTypeSpecialNamePath',\n                        value,\n                        specialType: type,\n                        meta: {\n                            quote: undefined\n                        }\n                    };\n                }\n                const moduleParser = new Parser(pathGrammar, parser.lexer, parser);\n                const moduleResult = moduleParser.parseInfixIntermediateType(result, Precedence.ALL);\n                parser.acceptLexerState(moduleParser);\n                return assertRootResult(moduleResult);\n            }\n        });\n    }\n\n    const basePathGrammar = [\n        createNameParslet({\n            allowedAdditionalTokens: ['external', 'module']\n        }),\n        stringValueParslet,\n        numberParslet,\n        createNamePathParslet({\n            allowSquareBracketsOnAnyType: false,\n            allowJsdocNamePaths: true,\n            pathGrammar: null\n        })\n    ];\n    const pathGrammar = [\n        ...basePathGrammar,\n        createSpecialNamePathParslet({\n            allowedTypes: ['event'],\n            pathGrammar: basePathGrammar\n        })\n    ];\n\n    function getParameters(value) {\n        let parameters;\n        if (value.type === 'JsdocTypeParameterList') {\n            parameters = value.elements;\n        }\n        else if (value.type === 'JsdocTypeParenthesis') {\n            parameters = [value.element];\n        }\n        else {\n            throw new UnexpectedTypeError(value);\n        }\n        return parameters.map(p => assertPlainKeyValueOrRootResult(p));\n    }\n    function getUnnamedParameters(value) {\n        const parameters = getParameters(value);\n        if (parameters.some(p => p.type === 'JsdocTypeKeyValue')) {\n            throw new Error('No parameter should be named');\n        }\n        return parameters;\n    }\n    function createFunctionParslet({ allowNamedParameters, allowNoReturnType, allowWithoutParenthesis, allowNewAsFunctionKeyword }) {\n        return composeParslet({\n            name: 'functionParslet',\n            accept: (type, next) => type === 'function' || (allowNewAsFunctionKeyword && type === 'new' && next === '('),\n            parsePrefix: parser => {\n                const newKeyword = parser.consume('new');\n                parser.consume('function');\n                const hasParenthesis = parser.lexer.current.type === '(';\n                if (!hasParenthesis) {\n                    if (!allowWithoutParenthesis) {\n                        throw new Error('function is missing parameter list');\n                    }\n                    return {\n                        type: 'JsdocTypeName',\n                        value: 'function'\n                    };\n                }\n                let result = {\n                    type: 'JsdocTypeFunction',\n                    parameters: [],\n                    arrow: false,\n                    constructor: newKeyword,\n                    parenthesis: hasParenthesis\n                };\n                const value = parser.parseIntermediateType(Precedence.FUNCTION);\n                if (allowNamedParameters === undefined) {\n                    result.parameters = getUnnamedParameters(value);\n                }\n                else if (newKeyword && value.type === 'JsdocTypeFunction' && value.arrow) {\n                    result = value;\n                    result.constructor = true;\n                    return result;\n                }\n                else {\n                    result.parameters = getParameters(value);\n                    for (const p of result.parameters) {\n                        if (p.type === 'JsdocTypeKeyValue' && (!allowNamedParameters.includes(p.key))) {\n                            throw new Error(`only allowed named parameters are ${allowNamedParameters.join(', ')} but got ${p.type}`);\n                        }\n                    }\n                }\n                if (parser.consume(':')) {\n                    result.returnType = parser.parseType(Precedence.PREFIX);\n                }\n                else {\n                    if (!allowNoReturnType) {\n                        throw new Error('function is missing return type');\n                    }\n                }\n                return result;\n            }\n        });\n    }\n\n    function createVariadicParslet({ allowPostfix, allowEnclosingBrackets }) {\n        return composeParslet({\n            name: 'variadicParslet',\n            accept: type => type === '...',\n            precedence: Precedence.PREFIX,\n            parsePrefix: parser => {\n                parser.consume('...');\n                const brackets = allowEnclosingBrackets && parser.consume('[');\n                try {\n                    const element = parser.parseType(Precedence.PREFIX);\n                    if (brackets && !parser.consume(']')) {\n                        throw new Error('Unterminated variadic type. Missing \\']\\'');\n                    }\n                    return {\n                        type: 'JsdocTypeVariadic',\n                        element: assertRootResult(element),\n                        meta: {\n                            position: 'prefix',\n                            squareBrackets: brackets\n                        }\n                    };\n                }\n                catch (e) {\n                    if (e instanceof NoParsletFoundError) {\n                        if (brackets) {\n                            throw new Error('Empty square brackets for variadic are not allowed.');\n                        }\n                        return {\n                            type: 'JsdocTypeVariadic',\n                            meta: {\n                                position: undefined,\n                                squareBrackets: false\n                            }\n                        };\n                    }\n                    else {\n                        throw e;\n                    }\n                }\n            },\n            parseInfix: allowPostfix\n                ? (parser, left) => {\n                    parser.consume('...');\n                    return {\n                        type: 'JsdocTypeVariadic',\n                        element: assertRootResult(left),\n                        meta: {\n                            position: 'suffix',\n                            squareBrackets: false\n                        }\n                    };\n                }\n                : undefined\n        });\n    }\n\n    const symbolParslet = composeParslet({\n        name: 'symbolParslet',\n        accept: type => type === '(',\n        precedence: Precedence.SYMBOL,\n        parseInfix: (parser, left) => {\n            if (left.type !== 'JsdocTypeName') {\n                throw new Error('Symbol expects a name on the left side. (Reacting on \\'(\\')');\n            }\n            parser.consume('(');\n            const result = {\n                type: 'JsdocTypeSymbol',\n                value: left.value\n            };\n            if (!parser.consume(')')) {\n                const next = parser.parseIntermediateType(Precedence.SYMBOL);\n                result.element = assertNumberOrVariadicNameResult(next);\n                if (!parser.consume(')')) {\n                    throw new Error('Symbol does not end after value');\n                }\n            }\n            return result;\n        }\n    });\n\n    const arrayBracketsParslet = composeParslet({\n        name: 'arrayBracketsParslet',\n        precedence: Precedence.ARRAY_BRACKETS,\n        accept: (type, next) => type === '[' && next === ']',\n        parseInfix: (parser, left) => {\n            parser.consume('[');\n            parser.consume(']');\n            return {\n                type: 'JsdocTypeGeneric',\n                left: {\n                    type: 'JsdocTypeName',\n                    value: 'Array'\n                },\n                elements: [\n                    assertRootResult(left)\n                ],\n                meta: {\n                    brackets: 'square',\n                    dot: false\n                }\n            };\n        }\n    });\n\n    function createObjectParslet({ objectFieldGrammar, allowKeyTypes }) {\n        return composeParslet({\n            name: 'objectParslet',\n            accept: type => type === '{',\n            parsePrefix: parser => {\n                parser.consume('{');\n                const result = {\n                    type: 'JsdocTypeObject',\n                    meta: {\n                        separator: 'comma'\n                    },\n                    elements: []\n                };\n                if (!parser.consume('}')) {\n                    let separator;\n                    const fieldParser = new Parser(objectFieldGrammar, parser.lexer, parser);\n                    while (true) {\n                        fieldParser.acceptLexerState(parser);\n                        let field = fieldParser.parseIntermediateType(Precedence.OBJECT);\n                        parser.acceptLexerState(fieldParser);\n                        if (field === undefined && allowKeyTypes) {\n                            field = parser.parseIntermediateType(Precedence.OBJECT);\n                        }\n                        let optional = false;\n                        if (field.type === 'JsdocTypeNullable') {\n                            optional = true;\n                            field = field.element;\n                        }\n                        if (field.type === 'JsdocTypeNumber' || field.type === 'JsdocTypeName' || field.type === 'JsdocTypeStringValue') {\n                            let quote;\n                            if (field.type === 'JsdocTypeStringValue') {\n                                quote = field.meta.quote;\n                            }\n                            result.elements.push({\n                                type: 'JsdocTypeObjectField',\n                                key: field.value.toString(),\n                                right: undefined,\n                                optional,\n                                readonly: false,\n                                meta: {\n                                    quote\n                                }\n                            });\n                        }\n                        else if (field.type === 'JsdocTypeObjectField' || field.type === 'JsdocTypeJsdocObjectField') {\n                            result.elements.push(field);\n                        }\n                        else {\n                            throw new UnexpectedTypeError(field);\n                        }\n                        if (parser.lexer.current.startOfLine) {\n                            separator = 'linebreak';\n                            // Handle single stray comma/semi-colon\n                            parser.consume(',') || parser.consume(';');\n                        }\n                        else if (parser.consume(',')) {\n                            separator = 'comma';\n                        }\n                        else if (parser.consume(';')) {\n                            separator = 'semicolon';\n                        }\n                        else {\n                            break;\n                        }\n                        const type = parser.lexer.current.type;\n                        if (type === '}') {\n                            break;\n                        }\n                    }\n                    result.meta.separator = separator !== null && separator !== void 0 ? separator : 'comma'; // TODO: use undefined here\n                    if (separator === 'linebreak') {\n                        // TODO: Consume appropriate whitespace\n                        result.meta.propertyIndent = '  ';\n                    }\n                    if (!parser.consume('}')) {\n                        throw new Error('Unterminated record type. Missing \\'}\\'');\n                    }\n                }\n                return result;\n            }\n        });\n    }\n\n    function createObjectFieldParslet({ allowSquaredProperties, allowKeyTypes, allowReadonly, allowOptional }) {\n        return composeParslet({\n            name: 'objectFieldParslet',\n            precedence: Precedence.KEY_VALUE,\n            accept: type => type === ':',\n            parseInfix: (parser, left) => {\n                var _a;\n                let optional = false;\n                let readonlyProperty = false;\n                if (allowOptional && left.type === 'JsdocTypeNullable') {\n                    optional = true;\n                    left = left.element;\n                }\n                if (allowReadonly && left.type === 'JsdocTypeReadonlyProperty') {\n                    readonlyProperty = true;\n                    left = left.element;\n                }\n                // object parslet uses a special grammar and for the value we want to switch back to the parent\n                const parentParser = (_a = parser.baseParser) !== null && _a !== void 0 ? _a : parser;\n                parentParser.acceptLexerState(parser);\n                if (left.type === 'JsdocTypeNumber' || left.type === 'JsdocTypeName' || left.type === 'JsdocTypeStringValue' ||\n                    isSquaredProperty(left)) {\n                    if (isSquaredProperty(left) && !allowSquaredProperties) {\n                        throw new UnexpectedTypeError(left);\n                    }\n                    parentParser.consume(':');\n                    let quote;\n                    if (left.type === 'JsdocTypeStringValue') {\n                        quote = left.meta.quote;\n                    }\n                    const right = parentParser.parseType(Precedence.KEY_VALUE);\n                    parser.acceptLexerState(parentParser);\n                    return {\n                        type: 'JsdocTypeObjectField',\n                        key: isSquaredProperty(left) ? left : left.value.toString(),\n                        right,\n                        optional,\n                        readonly: readonlyProperty,\n                        meta: {\n                            quote\n                        }\n                    };\n                }\n                else {\n                    if (!allowKeyTypes) {\n                        throw new UnexpectedTypeError(left);\n                    }\n                    parentParser.consume(':');\n                    const right = parentParser.parseType(Precedence.KEY_VALUE);\n                    parser.acceptLexerState(parentParser);\n                    return {\n                        type: 'JsdocTypeJsdocObjectField',\n                        left: assertRootResult(left),\n                        right\n                    };\n                }\n            }\n        });\n    }\n\n    function createKeyValueParslet({ allowOptional, allowVariadic }) {\n        return composeParslet({\n            name: 'keyValueParslet',\n            precedence: Precedence.KEY_VALUE,\n            accept: type => type === ':',\n            parseInfix: (parser, left) => {\n                let optional = false;\n                let variadic = false;\n                if (allowOptional && left.type === 'JsdocTypeNullable') {\n                    optional = true;\n                    left = left.element;\n                }\n                if (allowVariadic && left.type === 'JsdocTypeVariadic' && left.element !== undefined) {\n                    variadic = true;\n                    left = left.element;\n                }\n                if (left.type !== 'JsdocTypeName') {\n                    throw new UnexpectedTypeError(left);\n                }\n                parser.consume(':');\n                const right = parser.parseType(Precedence.KEY_VALUE);\n                return {\n                    type: 'JsdocTypeKeyValue',\n                    key: left.value,\n                    right,\n                    optional,\n                    variadic\n                };\n            }\n        });\n    }\n\n    const jsdocBaseGrammar = [\n        ...baseGrammar,\n        createFunctionParslet({\n            allowWithoutParenthesis: true,\n            allowNamedParameters: ['this', 'new'],\n            allowNoReturnType: true,\n            allowNewAsFunctionKeyword: false\n        }),\n        stringValueParslet,\n        createSpecialNamePathParslet({\n            allowedTypes: ['module', 'external', 'event'],\n            pathGrammar\n        }),\n        createVariadicParslet({\n            allowEnclosingBrackets: true,\n            allowPostfix: true\n        }),\n        createNameParslet({\n            allowedAdditionalTokens: ['keyof']\n        }),\n        symbolParslet,\n        arrayBracketsParslet,\n        createNamePathParslet({\n            allowSquareBracketsOnAnyType: false,\n            allowJsdocNamePaths: true,\n            pathGrammar\n        })\n    ];\n    const jsdocGrammar = [\n        ...jsdocBaseGrammar,\n        createObjectParslet({\n            // jsdoc syntax allows full types as keys, so we need to pull in the full grammar here\n            // we leave out the object type deliberately\n            objectFieldGrammar: [\n                createNameParslet({\n                    allowedAdditionalTokens: ['typeof', 'module', 'in']\n                }),\n                createObjectFieldParslet({\n                    allowSquaredProperties: false,\n                    allowKeyTypes: true,\n                    allowOptional: false,\n                    allowReadonly: false\n                }),\n                ...jsdocBaseGrammar\n            ],\n            allowKeyTypes: true\n        }),\n        createKeyValueParslet({\n            allowOptional: true,\n            allowVariadic: true\n        })\n    ];\n\n    const typeOfParslet = composeParslet({\n        name: 'typeOfParslet',\n        accept: type => type === 'typeof',\n        parsePrefix: parser => {\n            parser.consume('typeof');\n            return {\n                type: 'JsdocTypeTypeof',\n                element: parser.parseType(Precedence.KEY_OF_TYPE_OF)\n            };\n        }\n    });\n\n    const objectFieldGrammar$1 = [\n        createNameParslet({\n            allowedAdditionalTokens: ['typeof', 'module', 'keyof', 'event', 'external', 'in']\n        }),\n        nullableParslet,\n        optionalParslet,\n        stringValueParslet,\n        numberParslet,\n        createObjectFieldParslet({\n            allowSquaredProperties: false,\n            allowKeyTypes: false,\n            allowOptional: false,\n            allowReadonly: false\n        })\n    ];\n    const closureGrammar = [\n        ...baseGrammar,\n        createObjectParslet({\n            allowKeyTypes: false,\n            objectFieldGrammar: objectFieldGrammar$1\n        }),\n        createNameParslet({\n            allowedAdditionalTokens: ['event', 'external', 'in']\n        }),\n        typeOfParslet,\n        createFunctionParslet({\n            allowWithoutParenthesis: false,\n            allowNamedParameters: ['this', 'new'],\n            allowNoReturnType: true,\n            allowNewAsFunctionKeyword: false\n        }),\n        createVariadicParslet({\n            allowEnclosingBrackets: false,\n            allowPostfix: false\n        }),\n        // additional name parslet is needed for some special cases\n        createNameParslet({\n            allowedAdditionalTokens: ['keyof']\n        }),\n        createSpecialNamePathParslet({\n            allowedTypes: ['module'],\n            pathGrammar\n        }),\n        createNamePathParslet({\n            allowSquareBracketsOnAnyType: false,\n            allowJsdocNamePaths: true,\n            pathGrammar\n        }),\n        createKeyValueParslet({\n            allowOptional: false,\n            allowVariadic: false\n        }),\n        symbolParslet\n    ];\n\n    const assertsParslet = composeParslet({\n        name: 'assertsParslet',\n        accept: type => type === 'asserts',\n        parsePrefix: (parser) => {\n            parser.consume('asserts');\n            const left = parser.parseIntermediateType(Precedence.SYMBOL);\n            if (left.type !== 'JsdocTypeName') {\n                throw new UnexpectedTypeError(left, 'A typescript asserts always has to have a name on the left side.');\n            }\n            if (!parser.consume('is')) {\n                return {\n                    type: 'JsdocTypeAssertsPlain',\n                    element: left\n                };\n            }\n            return {\n                type: 'JsdocTypeAsserts',\n                left,\n                right: assertRootResult(parser.parseIntermediateType(Precedence.INFIX))\n            };\n        }\n    });\n\n    function createTupleParslet({ allowQuestionMark }) {\n        return composeParslet({\n            name: 'tupleParslet',\n            accept: type => type === '[',\n            parsePrefix: parser => {\n                parser.consume('[');\n                const result = {\n                    type: 'JsdocTypeTuple',\n                    elements: []\n                };\n                if (parser.consume(']')) {\n                    return result;\n                }\n                const typeList = parser.parseIntermediateType(Precedence.ALL);\n                if (typeList.type === 'JsdocTypeParameterList') {\n                    if (typeList.elements[0].type === 'JsdocTypeKeyValue') {\n                        result.elements = typeList.elements.map(assertPlainKeyValueResult);\n                    }\n                    else {\n                        result.elements = typeList.elements.map(assertRootResult);\n                    }\n                }\n                else {\n                    if (typeList.type === 'JsdocTypeKeyValue') {\n                        result.elements = [assertPlainKeyValueResult(typeList)];\n                    }\n                    else {\n                        result.elements = [assertRootResult(typeList)];\n                    }\n                }\n                if (!parser.consume(']')) {\n                    throw new Error('Unterminated \\'[\\'');\n                }\n                if (result.elements.some((e) => e.type === 'JsdocTypeUnknown')) {\n                    throw new Error('Question mark in tuple not allowed');\n                }\n                return result;\n            }\n        });\n    }\n\n    const keyOfParslet = composeParslet({\n        name: 'keyOfParslet',\n        accept: type => type === 'keyof',\n        parsePrefix: parser => {\n            parser.consume('keyof');\n            return {\n                type: 'JsdocTypeKeyof',\n                element: assertRootResult(parser.parseType(Precedence.KEY_OF_TYPE_OF))\n            };\n        }\n    });\n\n    const importParslet = composeParslet({\n        name: 'importParslet',\n        accept: type => type === 'import',\n        parsePrefix: parser => {\n            parser.consume('import');\n            if (!parser.consume('(')) {\n                throw new Error('Missing parenthesis after import keyword');\n            }\n            const path = parser.parseType(Precedence.PREFIX);\n            if (path.type !== 'JsdocTypeStringValue') {\n                throw new Error('Only string values are allowed as paths for imports');\n            }\n            if (!parser.consume(')')) {\n                throw new Error('Missing closing parenthesis after import keyword');\n            }\n            return {\n                type: 'JsdocTypeImport',\n                element: path\n            };\n        }\n    });\n\n    const readonlyPropertyParslet = composeParslet({\n        name: 'readonlyPropertyParslet',\n        accept: type => type === 'readonly',\n        parsePrefix: parser => {\n            parser.consume('readonly');\n            return {\n                type: 'JsdocTypeReadonlyProperty',\n                element: parser.parseIntermediateType(Precedence.KEY_VALUE)\n            };\n        }\n    });\n\n    const arrowFunctionParslet = composeParslet({\n        name: 'arrowFunctionParslet',\n        precedence: Precedence.ARROW,\n        accept: type => type === '=>',\n        parseInfix: (parser, left) => {\n            parser.consume('=>');\n            return {\n                type: 'JsdocTypeFunction',\n                parameters: getParameters(left).map(assertPlainKeyValueOrNameResult),\n                arrow: true,\n                constructor: false,\n                parenthesis: true,\n                returnType: parser.parseType(Precedence.OBJECT)\n            };\n        }\n    });\n\n    const genericArrowFunctionParslet = composeParslet({\n        name: 'genericArrowFunctionParslet',\n        accept: type => type === '<',\n        parsePrefix: (parser) => {\n            const typeParameters = [];\n            parser.consume('<');\n            do {\n                let defaultValue;\n                let name = parser.parseIntermediateType(Precedence.SYMBOL);\n                if (name.type === 'JsdocTypeOptional') {\n                    name = name.element;\n                    defaultValue = parser.parseType(Precedence.SYMBOL);\n                }\n                if (name.type !== 'JsdocTypeName') {\n                    throw new UnexpectedTypeError(name);\n                }\n                let constraint;\n                if (parser.consume('extends')) {\n                    constraint = parser.parseType(Precedence.SYMBOL);\n                    // Got an equal sign\n                    if (constraint.type === 'JsdocTypeOptional') {\n                        constraint = constraint.element;\n                        defaultValue = parser.parseType(Precedence.SYMBOL);\n                    }\n                }\n                const typeParameter = {\n                    type: 'JsdocTypeTypeParameter',\n                    name\n                };\n                if (constraint !== undefined) {\n                    typeParameter.constraint = constraint;\n                }\n                if (defaultValue !== undefined) {\n                    typeParameter.defaultValue = defaultValue;\n                }\n                typeParameters.push(typeParameter);\n                if (parser.consume('>')) {\n                    break;\n                }\n            } while (parser.consume(','));\n            const functionBase = parser.parseIntermediateType(Precedence.SYMBOL);\n            functionBase.typeParameters = typeParameters;\n            return functionBase;\n        }\n    });\n\n    const intersectionParslet = composeParslet({\n        name: 'intersectionParslet',\n        accept: type => type === '&',\n        precedence: Precedence.INTERSECTION,\n        parseInfix: (parser, left) => {\n            parser.consume('&');\n            const elements = [];\n            do {\n                elements.push(parser.parseType(Precedence.INTERSECTION));\n            } while (parser.consume('&'));\n            return {\n                type: 'JsdocTypeIntersection',\n                elements: [assertRootResult(left), ...elements]\n            };\n        }\n    });\n\n    const predicateParslet = composeParslet({\n        name: 'predicateParslet',\n        precedence: Precedence.INFIX,\n        accept: type => type === 'is',\n        parseInfix: (parser, left) => {\n            if (left.type !== 'JsdocTypeName') {\n                throw new UnexpectedTypeError(left, 'A typescript predicate always has to have a name on the left side.');\n            }\n            parser.consume('is');\n            return {\n                type: 'JsdocTypePredicate',\n                left,\n                right: assertRootResult(parser.parseIntermediateType(Precedence.INFIX))\n            };\n        }\n    });\n\n    const objectSquaredPropertyParslet = composeParslet({\n        name: 'objectSquareBracketPropertyParslet',\n        accept: type => type === '[',\n        parsePrefix: parser => {\n            if (parser.baseParser === undefined) {\n                throw new Error('Only allowed inside object grammar');\n            }\n            parser.consume('[');\n            const key = parser.lexer.current.text;\n            parser.consume('Identifier');\n            let result;\n            if (parser.consume(':')) {\n                const parentParser = parser.baseParser;\n                parentParser.acceptLexerState(parser);\n                result = {\n                    type: 'JsdocTypeIndexSignature',\n                    key,\n                    right: parentParser.parseType(Precedence.INDEX_BRACKETS)\n                };\n                parser.acceptLexerState(parentParser);\n            }\n            else if (parser.consume('in')) {\n                const parentParser = parser.baseParser;\n                parentParser.acceptLexerState(parser);\n                result = {\n                    type: 'JsdocTypeMappedType',\n                    key,\n                    right: parentParser.parseType(Precedence.ARRAY_BRACKETS)\n                };\n                parser.acceptLexerState(parentParser);\n            }\n            else {\n                throw new Error('Missing \\':\\' or \\'in\\' inside square bracketed property.');\n            }\n            if (!parser.consume(']')) {\n                throw new Error('Unterminated square brackets');\n            }\n            return result;\n        }\n    });\n\n    const readonlyArrayParslet = composeParslet({\n        name: 'readonlyArrayParslet',\n        accept: type => type === 'readonly',\n        parsePrefix: parser => {\n            parser.consume('readonly');\n            return {\n                type: 'JsdocTypeReadonlyArray',\n                element: assertArrayOrTupleResult(parser.parseIntermediateType(Precedence.ALL))\n            };\n        }\n    });\n\n    const conditionalParslet = composeParslet({\n        name: 'conditionalParslet',\n        precedence: Precedence.INFIX,\n        accept: type => type === 'extends',\n        parseInfix: (parser, left) => {\n            parser.consume('extends');\n            const extendsType = parser.parseType(Precedence.KEY_OF_TYPE_OF).element;\n            // parser.consume('?')\n            const trueType = parser.parseType(Precedence.INFIX);\n            parser.consume(':');\n            return {\n                type: 'JsdocTypeConditional',\n                checksType: assertRootResult(left),\n                extendsType,\n                trueType,\n                falseType: parser.parseType(Precedence.INFIX)\n            };\n        }\n    });\n\n    const objectFieldGrammar = [\n        readonlyPropertyParslet,\n        createNameParslet({\n            allowedAdditionalTokens: ['typeof', 'module', 'keyof', 'event', 'external', 'in']\n        }),\n        nullableParslet,\n        optionalParslet,\n        stringValueParslet,\n        numberParslet,\n        createObjectFieldParslet({\n            allowSquaredProperties: true,\n            allowKeyTypes: false,\n            allowOptional: true,\n            allowReadonly: true\n        }),\n        objectSquaredPropertyParslet\n    ];\n    const typescriptGrammar = [\n        ...baseGrammar,\n        createObjectParslet({\n            allowKeyTypes: false,\n            objectFieldGrammar\n        }),\n        readonlyArrayParslet,\n        typeOfParslet,\n        keyOfParslet,\n        importParslet,\n        stringValueParslet,\n        createFunctionParslet({\n            allowWithoutParenthesis: true,\n            allowNoReturnType: false,\n            allowNamedParameters: ['this', 'new', 'args'],\n            allowNewAsFunctionKeyword: true\n        }),\n        createTupleParslet({\n            allowQuestionMark: false\n        }),\n        createVariadicParslet({\n            allowEnclosingBrackets: false,\n            allowPostfix: false\n        }),\n        assertsParslet,\n        conditionalParslet,\n        createNameParslet({\n            allowedAdditionalTokens: ['event', 'external', 'in']\n        }),\n        createSpecialNamePathParslet({\n            allowedTypes: ['module'],\n            pathGrammar\n        }),\n        arrayBracketsParslet,\n        arrowFunctionParslet,\n        genericArrowFunctionParslet,\n        createNamePathParslet({\n            allowSquareBracketsOnAnyType: true,\n            allowJsdocNamePaths: false,\n            pathGrammar\n        }),\n        intersectionParslet,\n        predicateParslet,\n        createKeyValueParslet({\n            allowVariadic: true,\n            allowOptional: true\n        })\n    ];\n\n    /**\n     * This function parses the given expression in the given mode and produces a {@link RootResult}.\n     * @param expression\n     * @param mode\n     */\n    function parse(expression, mode) {\n        switch (mode) {\n            case 'closure':\n                return (new Parser(closureGrammar, expression)).parse();\n            case 'jsdoc':\n                return (new Parser(jsdocGrammar, expression)).parse();\n            case 'typescript':\n                return (new Parser(typescriptGrammar, expression)).parse();\n        }\n    }\n    /**\n     * This function tries to parse the given expression in multiple modes and returns the first successful\n     * {@link RootResult}. By default it tries `'typescript'`, `'closure'` and `'jsdoc'` in this order. If\n     * no mode was successful it throws the error that was produced by the last parsing attempt.\n     * @param expression\n     * @param modes\n     */\n    function tryParse(expression, modes = ['typescript', 'closure', 'jsdoc']) {\n        let error;\n        for (const mode of modes) {\n            try {\n                return parse(expression, mode);\n            }\n            catch (e) {\n                error = e;\n            }\n        }\n        throw error;\n    }\n\n    function transform(rules, parseResult) {\n        const rule = rules[parseResult.type];\n        if (rule === undefined) {\n            throw new Error(`In this set of transform rules exists no rule for type ${parseResult.type}.`);\n        }\n        return rule(parseResult, aParseResult => transform(rules, aParseResult));\n    }\n    function notAvailableTransform(parseResult) {\n        throw new Error('This transform is not available. Are you trying the correct parsing mode?');\n    }\n    function extractSpecialParams(source) {\n        const result = {\n            params: []\n        };\n        for (const param of source.parameters) {\n            if (param.type === 'JsdocTypeKeyValue') {\n                if (param.key === 'this') {\n                    result.this = param.right;\n                }\n                else if (param.key === 'new') {\n                    result.new = param.right;\n                }\n                else {\n                    result.params.push(param);\n                }\n            }\n            else {\n                result.params.push(param);\n            }\n        }\n        return result;\n    }\n\n    function applyPosition(position, target, value) {\n        return position === 'prefix' ? value + target : target + value;\n    }\n    function quote(value, quote) {\n        switch (quote) {\n            case 'double':\n                return `\"${value}\"`;\n            case 'single':\n                return `'${value}'`;\n            case undefined:\n                return value;\n        }\n    }\n    function stringifyRules() {\n        return {\n            JsdocTypeParenthesis: (result, transform) => `(${result.element !== undefined ? transform(result.element) : ''})`,\n            JsdocTypeKeyof: (result, transform) => `keyof ${transform(result.element)}`,\n            JsdocTypeFunction: (result, transform) => {\n                var _a;\n                if (!result.arrow) {\n                    let stringified = result.constructor ? 'new' : 'function';\n                    if (!result.parenthesis) {\n                        return stringified;\n                    }\n                    stringified += `(${result.parameters.map(transform).join(', ')})`;\n                    if (result.returnType !== undefined) {\n                        stringified += `: ${transform(result.returnType)}`;\n                    }\n                    return stringified;\n                }\n                else {\n                    if (result.returnType === undefined) {\n                        throw new Error('Arrow function needs a return type.');\n                    }\n                    let stringified = `${result.typeParameters !== undefined\n                    ? `<${(_a = result.typeParameters.map(transform).join(', ')) !== null && _a !== void 0 ? _a : ''}>`\n                    : ''}(${result.parameters.map(transform).join(', ')}) => ${transform(result.returnType)}`;\n                    if (result.constructor) {\n                        stringified = 'new ' + stringified;\n                    }\n                    return stringified;\n                }\n            },\n            JsdocTypeName: result => result.value,\n            JsdocTypeTuple: (result, transform) => `[${result.elements.map(transform).join(', ')}]`,\n            JsdocTypeVariadic: (result, transform) => result.meta.position === undefined\n                ? '...'\n                : applyPosition(result.meta.position, transform(result.element), '...'),\n            JsdocTypeNamePath: (result, transform) => {\n                const left = transform(result.left);\n                const right = transform(result.right);\n                switch (result.pathType) {\n                    case 'inner':\n                        return `${left}~${right}`;\n                    case 'instance':\n                        return `${left}#${right}`;\n                    case 'property':\n                        return `${left}.${right}`;\n                    case 'property-brackets':\n                        return `${left}[${right}]`;\n                }\n            },\n            JsdocTypeStringValue: result => quote(result.value, result.meta.quote),\n            JsdocTypeAny: () => '*',\n            JsdocTypeGeneric: (result, transform) => {\n                if (result.meta.brackets === 'square') {\n                    const element = result.elements[0];\n                    const transformed = transform(element);\n                    if (element.type === 'JsdocTypeUnion' || element.type === 'JsdocTypeIntersection') {\n                        return `(${transformed})[]`;\n                    }\n                    else {\n                        return `${transformed}[]`;\n                    }\n                }\n                else {\n                    return `${transform(result.left)}${result.meta.dot ? '.' : ''}<${result.infer === true ? 'infer ' : ''}${result.elements.map(transform).join(', ')}>`;\n                }\n            },\n            JsdocTypeImport: (result, transform) => `import(${transform(result.element)})`,\n            JsdocTypeObjectField: (result, transform) => {\n                let text = '';\n                if (result.readonly) {\n                    text += 'readonly ';\n                }\n                if (typeof result.key === 'string') {\n                    text += quote(result.key, result.meta.quote);\n                }\n                else {\n                    text += transform(result.key);\n                }\n                if (result.optional) {\n                    text += '?';\n                }\n                if (result.right === undefined) {\n                    return text;\n                }\n                else {\n                    return text + `: ${transform(result.right)}`;\n                }\n            },\n            JsdocTypeJsdocObjectField: (result, transform) => {\n                return `${transform(result.left)}: ${transform(result.right)}`;\n            },\n            JsdocTypeKeyValue: (result, transform) => {\n                let text = result.key;\n                if (result.optional) {\n                    text += '?';\n                }\n                if (result.variadic) {\n                    text = '...' + text;\n                }\n                if (result.right === undefined) {\n                    return text;\n                }\n                else {\n                    return text + `: ${transform(result.right)}`;\n                }\n            },\n            JsdocTypeSpecialNamePath: result => `${result.specialType}:${quote(result.value, result.meta.quote)}`,\n            JsdocTypeNotNullable: (result, transform) => applyPosition(result.meta.position, transform(result.element), '!'),\n            JsdocTypeNull: () => 'null',\n            JsdocTypeNullable: (result, transform) => applyPosition(result.meta.position, transform(result.element), '?'),\n            JsdocTypeNumber: result => result.value.toString(),\n            JsdocTypeObject: (result, transform) => {\n                var _a, _b;\n                return `{${(result.meta.separator === 'linebreak' && result.elements.length > 1\n                ? '\\n' + ((_a = result.meta.propertyIndent) !== null && _a !== void 0 ? _a : '')\n                : '') +\n                result.elements.map(transform).join((result.meta.separator === 'comma' ? ', ' : result.meta.separator === 'linebreak' ? '\\n' + ((_b = result.meta.propertyIndent) !== null && _b !== void 0 ? _b : '') : '; ')) +\n                (result.meta.separator === 'linebreak' && result.elements.length > 1\n                    ? '\\n'\n                    : '')}}`;\n            },\n            JsdocTypeOptional: (result, transform) => applyPosition(result.meta.position, transform(result.element), '='),\n            JsdocTypeSymbol: (result, transform) => `${result.value}(${result.element !== undefined ? transform(result.element) : ''})`,\n            JsdocTypeTypeof: (result, transform) => `typeof ${transform(result.element)}`,\n            JsdocTypeUndefined: () => 'undefined',\n            JsdocTypeUnion: (result, transform) => result.elements.map(transform).join(' | '),\n            JsdocTypeUnknown: () => '?',\n            JsdocTypeIntersection: (result, transform) => result.elements.map(transform).join(' & '),\n            JsdocTypeProperty: result => quote(result.value, result.meta.quote),\n            JsdocTypePredicate: (result, transform) => `${transform(result.left)} is ${transform(result.right)}`,\n            JsdocTypeIndexSignature: (result, transform) => `[${result.key}: ${transform(result.right)}]`,\n            JsdocTypeMappedType: (result, transform) => `[${result.key} in ${transform(result.right)}]`,\n            JsdocTypeAsserts: (result, transform) => `asserts ${transform(result.left)} is ${transform(result.right)}`,\n            JsdocTypeReadonlyArray: (result, transform) => `readonly ${transform(result.element)}`,\n            JsdocTypeAssertsPlain: (result, transform) => `asserts ${transform(result.element)}`,\n            JsdocTypeConditional: (result, transform) => `${transform(result.checksType)} extends ${transform(result.extendsType)} ? ${transform(result.trueType)} : ${transform(result.falseType)}`,\n            JsdocTypeTypeParameter: (result, transform) => `${transform(result.name)}${result.constraint !== undefined ? ` extends ${transform(result.constraint)}` : ''}${result.defaultValue !== undefined ? ` = ${transform(result.defaultValue)}` : ''}`\n        };\n    }\n    const storedStringifyRules = stringifyRules();\n    function stringify(result) {\n        return transform(storedStringifyRules, result);\n    }\n\n    const reservedWords = [\n        'null',\n        'true',\n        'false',\n        'break',\n        'case',\n        'catch',\n        'class',\n        'const',\n        'continue',\n        'debugger',\n        'default',\n        'delete',\n        'do',\n        'else',\n        'export',\n        'extends',\n        'finally',\n        'for',\n        'function',\n        'if',\n        'import',\n        'in',\n        'instanceof',\n        'new',\n        'return',\n        'super',\n        'switch',\n        'this',\n        'throw',\n        'try',\n        'typeof',\n        'var',\n        'void',\n        'while',\n        'with',\n        'yield'\n    ];\n    function makeName(value) {\n        const result = {\n            type: 'NameExpression',\n            name: value\n        };\n        if (reservedWords.includes(value)) {\n            result.reservedWord = true;\n        }\n        return result;\n    }\n    const catharsisTransformRules = {\n        JsdocTypeOptional: (result, transform) => {\n            const transformed = transform(result.element);\n            transformed.optional = true;\n            return transformed;\n        },\n        JsdocTypeNullable: (result, transform) => {\n            const transformed = transform(result.element);\n            transformed.nullable = true;\n            return transformed;\n        },\n        JsdocTypeNotNullable: (result, transform) => {\n            const transformed = transform(result.element);\n            transformed.nullable = false;\n            return transformed;\n        },\n        JsdocTypeVariadic: (result, transform) => {\n            if (result.element === undefined) {\n                throw new Error('dots without value are not allowed in catharsis mode');\n            }\n            const transformed = transform(result.element);\n            transformed.repeatable = true;\n            return transformed;\n        },\n        JsdocTypeAny: () => ({\n            type: 'AllLiteral'\n        }),\n        JsdocTypeNull: () => ({\n            type: 'NullLiteral'\n        }),\n        JsdocTypeStringValue: result => makeName(quote(result.value, result.meta.quote)),\n        JsdocTypeUndefined: () => ({\n            type: 'UndefinedLiteral'\n        }),\n        JsdocTypeUnknown: () => ({\n            type: 'UnknownLiteral'\n        }),\n        JsdocTypeFunction: (result, transform) => {\n            const params = extractSpecialParams(result);\n            const transformed = {\n                type: 'FunctionType',\n                params: params.params.map(transform)\n            };\n            if (params.this !== undefined) {\n                transformed.this = transform(params.this);\n            }\n            if (params.new !== undefined) {\n                transformed.new = transform(params.new);\n            }\n            if (result.returnType !== undefined) {\n                transformed.result = transform(result.returnType);\n            }\n            return transformed;\n        },\n        JsdocTypeGeneric: (result, transform) => ({\n            type: 'TypeApplication',\n            applications: result.elements.map(o => transform(o)),\n            expression: transform(result.left)\n        }),\n        JsdocTypeSpecialNamePath: result => makeName(result.specialType + ':' + quote(result.value, result.meta.quote)),\n        JsdocTypeName: result => {\n            if (result.value !== 'function') {\n                return makeName(result.value);\n            }\n            else {\n                return {\n                    type: 'FunctionType',\n                    params: []\n                };\n            }\n        },\n        JsdocTypeNumber: result => makeName(result.value.toString()),\n        JsdocTypeObject: (result, transform) => {\n            const transformed = {\n                type: 'RecordType',\n                fields: []\n            };\n            for (const field of result.elements) {\n                if (field.type !== 'JsdocTypeObjectField' && field.type !== 'JsdocTypeJsdocObjectField') {\n                    transformed.fields.push({\n                        type: 'FieldType',\n                        key: transform(field),\n                        value: undefined\n                    });\n                }\n                else {\n                    transformed.fields.push(transform(field));\n                }\n            }\n            return transformed;\n        },\n        JsdocTypeObjectField: (result, transform) => {\n            if (typeof result.key !== 'string') {\n                throw new Error('Index signatures and mapped types are not supported');\n            }\n            return {\n                type: 'FieldType',\n                key: makeName(quote(result.key, result.meta.quote)),\n                value: result.right === undefined ? undefined : transform(result.right)\n            };\n        },\n        JsdocTypeJsdocObjectField: (result, transform) => ({\n            type: 'FieldType',\n            key: transform(result.left),\n            value: transform(result.right)\n        }),\n        JsdocTypeUnion: (result, transform) => ({\n            type: 'TypeUnion',\n            elements: result.elements.map(e => transform(e))\n        }),\n        JsdocTypeKeyValue: (result, transform) => {\n            return {\n                type: 'FieldType',\n                key: makeName(result.key),\n                value: result.right === undefined ? undefined : transform(result.right)\n            };\n        },\n        JsdocTypeNamePath: (result, transform) => {\n            const leftResult = transform(result.left);\n            let rightValue;\n            if (result.right.type === 'JsdocTypeSpecialNamePath') {\n                rightValue = transform(result.right).name;\n            }\n            else {\n                rightValue = quote(result.right.value, result.right.meta.quote);\n            }\n            const joiner = result.pathType === 'inner' ? '~' : result.pathType === 'instance' ? '#' : '.';\n            return makeName(`${leftResult.name}${joiner}${rightValue}`);\n        },\n        JsdocTypeSymbol: result => {\n            let value = '';\n            let element = result.element;\n            let trailingDots = false;\n            if ((element === null || element === void 0 ? void 0 : element.type) === 'JsdocTypeVariadic') {\n                if (element.meta.position === 'prefix') {\n                    value = '...';\n                }\n                else {\n                    trailingDots = true;\n                }\n                element = element.element;\n            }\n            if ((element === null || element === void 0 ? void 0 : element.type) === 'JsdocTypeName') {\n                value += element.value;\n            }\n            else if ((element === null || element === void 0 ? void 0 : element.type) === 'JsdocTypeNumber') {\n                value += element.value.toString();\n            }\n            if (trailingDots) {\n                value += '...';\n            }\n            return makeName(`${result.value}(${value})`);\n        },\n        JsdocTypeParenthesis: (result, transform) => transform(assertRootResult(result.element)),\n        JsdocTypeMappedType: notAvailableTransform,\n        JsdocTypeIndexSignature: notAvailableTransform,\n        JsdocTypeImport: notAvailableTransform,\n        JsdocTypeKeyof: notAvailableTransform,\n        JsdocTypeTuple: notAvailableTransform,\n        JsdocTypeTypeof: notAvailableTransform,\n        JsdocTypeIntersection: notAvailableTransform,\n        JsdocTypeProperty: notAvailableTransform,\n        JsdocTypePredicate: notAvailableTransform,\n        JsdocTypeAsserts: notAvailableTransform,\n        JsdocTypeReadonlyArray: notAvailableTransform,\n        JsdocTypeAssertsPlain: notAvailableTransform,\n        JsdocTypeConditional: notAvailableTransform,\n        JsdocTypeTypeParameter: notAvailableTransform\n    };\n    function catharsisTransform(result) {\n        return transform(catharsisTransformRules, result);\n    }\n\n    function getQuoteStyle(quote) {\n        switch (quote) {\n            case undefined:\n                return 'none';\n            case 'single':\n                return 'single';\n            case 'double':\n                return 'double';\n        }\n    }\n    function getMemberType(type) {\n        switch (type) {\n            case 'inner':\n                return 'INNER_MEMBER';\n            case 'instance':\n                return 'INSTANCE_MEMBER';\n            case 'property':\n                return 'MEMBER';\n            case 'property-brackets':\n                return 'MEMBER';\n        }\n    }\n    function nestResults(type, results) {\n        if (results.length === 2) {\n            return {\n                type,\n                left: results[0],\n                right: results[1]\n            };\n        }\n        else {\n            return {\n                type,\n                left: results[0],\n                right: nestResults(type, results.slice(1))\n            };\n        }\n    }\n    const jtpRules = {\n        JsdocTypeOptional: (result, transform) => ({\n            type: 'OPTIONAL',\n            value: transform(result.element),\n            meta: {\n                syntax: result.meta.position === 'prefix' ? 'PREFIX_EQUAL_SIGN' : 'SUFFIX_EQUALS_SIGN'\n            }\n        }),\n        JsdocTypeNullable: (result, transform) => ({\n            type: 'NULLABLE',\n            value: transform(result.element),\n            meta: {\n                syntax: result.meta.position === 'prefix' ? 'PREFIX_QUESTION_MARK' : 'SUFFIX_QUESTION_MARK'\n            }\n        }),\n        JsdocTypeNotNullable: (result, transform) => ({\n            type: 'NOT_NULLABLE',\n            value: transform(result.element),\n            meta: {\n                syntax: result.meta.position === 'prefix' ? 'PREFIX_BANG' : 'SUFFIX_BANG'\n            }\n        }),\n        JsdocTypeVariadic: (result, transform) => {\n            const transformed = {\n                type: 'VARIADIC',\n                meta: {\n                    syntax: result.meta.position === 'prefix'\n                        ? 'PREFIX_DOTS'\n                        : result.meta.position === 'suffix' ? 'SUFFIX_DOTS' : 'ONLY_DOTS'\n                }\n            };\n            if (result.element !== undefined) {\n                transformed.value = transform(result.element);\n            }\n            return transformed;\n        },\n        JsdocTypeName: result => ({\n            type: 'NAME',\n            name: result.value\n        }),\n        JsdocTypeTypeof: (result, transform) => ({\n            type: 'TYPE_QUERY',\n            name: transform(result.element)\n        }),\n        JsdocTypeTuple: (result, transform) => ({\n            type: 'TUPLE',\n            entries: result.elements.map(transform)\n        }),\n        JsdocTypeKeyof: (result, transform) => ({\n            type: 'KEY_QUERY',\n            value: transform(result.element)\n        }),\n        JsdocTypeImport: result => ({\n            type: 'IMPORT',\n            path: {\n                type: 'STRING_VALUE',\n                quoteStyle: getQuoteStyle(result.element.meta.quote),\n                string: result.element.value\n            }\n        }),\n        JsdocTypeUndefined: () => ({\n            type: 'NAME',\n            name: 'undefined'\n        }),\n        JsdocTypeAny: () => ({\n            type: 'ANY'\n        }),\n        JsdocTypeFunction: (result, transform) => {\n            const specialParams = extractSpecialParams(result);\n            const transformed = {\n                type: result.arrow ? 'ARROW' : 'FUNCTION',\n                params: specialParams.params.map(param => {\n                    if (param.type === 'JsdocTypeKeyValue') {\n                        if (param.right === undefined) {\n                            throw new Error('Function parameter without \\':\\' is not expected to be \\'KEY_VALUE\\'');\n                        }\n                        return {\n                            type: 'NAMED_PARAMETER',\n                            name: param.key,\n                            typeName: transform(param.right)\n                        };\n                    }\n                    else {\n                        return transform(param);\n                    }\n                }),\n                new: null,\n                returns: null\n            };\n            if (specialParams.this !== undefined) {\n                transformed.this = transform(specialParams.this);\n            }\n            else if (!result.arrow) {\n                transformed.this = null;\n            }\n            if (specialParams.new !== undefined) {\n                transformed.new = transform(specialParams.new);\n            }\n            if (result.returnType !== undefined) {\n                transformed.returns = transform(result.returnType);\n            }\n            return transformed;\n        },\n        JsdocTypeGeneric: (result, transform) => {\n            const transformed = {\n                type: 'GENERIC',\n                subject: transform(result.left),\n                objects: result.elements.map(transform),\n                meta: {\n                    syntax: result.meta.brackets === 'square' ? 'SQUARE_BRACKET' : result.meta.dot ? 'ANGLE_BRACKET_WITH_DOT' : 'ANGLE_BRACKET'\n                }\n            };\n            if (result.meta.brackets === 'square' && result.elements[0].type === 'JsdocTypeFunction' && !result.elements[0].parenthesis) {\n                transformed.objects[0] = {\n                    type: 'NAME',\n                    name: 'function'\n                };\n            }\n            return transformed;\n        },\n        JsdocTypeObjectField: (result, transform) => {\n            if (typeof result.key !== 'string') {\n                throw new Error('Index signatures and mapped types are not supported');\n            }\n            if (result.right === undefined) {\n                return {\n                    type: 'RECORD_ENTRY',\n                    key: result.key,\n                    quoteStyle: getQuoteStyle(result.meta.quote),\n                    value: null,\n                    readonly: false\n                };\n            }\n            let right = transform(result.right);\n            if (result.optional) {\n                right = {\n                    type: 'OPTIONAL',\n                    value: right,\n                    meta: {\n                        syntax: 'SUFFIX_KEY_QUESTION_MARK'\n                    }\n                };\n            }\n            return {\n                type: 'RECORD_ENTRY',\n                key: result.key.toString(),\n                quoteStyle: getQuoteStyle(result.meta.quote),\n                value: right,\n                readonly: false\n            };\n        },\n        JsdocTypeJsdocObjectField: () => {\n            throw new Error('Keys may not be typed in jsdoctypeparser.');\n        },\n        JsdocTypeKeyValue: (result, transform) => {\n            if (result.right === undefined) {\n                return {\n                    type: 'RECORD_ENTRY',\n                    key: result.key,\n                    quoteStyle: 'none',\n                    value: null,\n                    readonly: false\n                };\n            }\n            let right = transform(result.right);\n            if (result.optional) {\n                right = {\n                    type: 'OPTIONAL',\n                    value: right,\n                    meta: {\n                        syntax: 'SUFFIX_KEY_QUESTION_MARK'\n                    }\n                };\n            }\n            return {\n                type: 'RECORD_ENTRY',\n                key: result.key,\n                quoteStyle: 'none',\n                value: right,\n                readonly: false\n            };\n        },\n        JsdocTypeObject: (result, transform) => {\n            const entries = [];\n            for (const field of result.elements) {\n                if (field.type === 'JsdocTypeObjectField' || field.type === 'JsdocTypeJsdocObjectField') {\n                    entries.push(transform(field));\n                }\n            }\n            return {\n                type: 'RECORD',\n                entries\n            };\n        },\n        JsdocTypeSpecialNamePath: result => {\n            if (result.specialType !== 'module') {\n                throw new Error(`jsdoctypeparser does not support type ${result.specialType} at this point.`);\n            }\n            return {\n                type: 'MODULE',\n                value: {\n                    type: 'FILE_PATH',\n                    quoteStyle: getQuoteStyle(result.meta.quote),\n                    path: result.value\n                }\n            };\n        },\n        JsdocTypeNamePath: (result, transform) => {\n            let hasEventPrefix = false;\n            let name;\n            let quoteStyle;\n            if (result.right.type === 'JsdocTypeSpecialNamePath' && result.right.specialType === 'event') {\n                hasEventPrefix = true;\n                name = result.right.value;\n                quoteStyle = getQuoteStyle(result.right.meta.quote);\n            }\n            else {\n                name = result.right.value;\n                quoteStyle = getQuoteStyle(result.right.meta.quote);\n            }\n            const transformed = {\n                type: getMemberType(result.pathType),\n                owner: transform(result.left),\n                name,\n                quoteStyle,\n                hasEventPrefix\n            };\n            if (transformed.owner.type === 'MODULE') {\n                const tModule = transformed.owner;\n                transformed.owner = transformed.owner.value;\n                tModule.value = transformed;\n                return tModule;\n            }\n            else {\n                return transformed;\n            }\n        },\n        JsdocTypeUnion: (result, transform) => nestResults('UNION', result.elements.map(transform)),\n        JsdocTypeParenthesis: (result, transform) => ({\n            type: 'PARENTHESIS',\n            value: transform(assertRootResult(result.element))\n        }),\n        JsdocTypeNull: () => ({\n            type: 'NAME',\n            name: 'null'\n        }),\n        JsdocTypeUnknown: () => ({\n            type: 'UNKNOWN'\n        }),\n        JsdocTypeStringValue: result => ({\n            type: 'STRING_VALUE',\n            quoteStyle: getQuoteStyle(result.meta.quote),\n            string: result.value\n        }),\n        JsdocTypeIntersection: (result, transform) => nestResults('INTERSECTION', result.elements.map(transform)),\n        JsdocTypeNumber: result => ({\n            type: 'NUMBER_VALUE',\n            number: result.value.toString()\n        }),\n        JsdocTypeSymbol: notAvailableTransform,\n        JsdocTypeProperty: notAvailableTransform,\n        JsdocTypePredicate: notAvailableTransform,\n        JsdocTypeMappedType: notAvailableTransform,\n        JsdocTypeIndexSignature: notAvailableTransform,\n        JsdocTypeAsserts: notAvailableTransform,\n        JsdocTypeReadonlyArray: notAvailableTransform,\n        JsdocTypeAssertsPlain: notAvailableTransform,\n        JsdocTypeConditional: notAvailableTransform,\n        JsdocTypeTypeParameter: notAvailableTransform\n    };\n    function jtpTransform(result) {\n        return transform(jtpRules, result);\n    }\n\n    function identityTransformRules() {\n        return {\n            JsdocTypeIntersection: (result, transform) => ({\n                type: 'JsdocTypeIntersection',\n                elements: result.elements.map(transform)\n            }),\n            JsdocTypeGeneric: (result, transform) => ({\n                type: 'JsdocTypeGeneric',\n                left: transform(result.left),\n                elements: result.elements.map(transform),\n                meta: {\n                    dot: result.meta.dot,\n                    brackets: result.meta.brackets\n                }\n            }),\n            JsdocTypeNullable: result => result,\n            JsdocTypeUnion: (result, transform) => ({\n                type: 'JsdocTypeUnion',\n                elements: result.elements.map(transform)\n            }),\n            JsdocTypeUnknown: result => result,\n            JsdocTypeUndefined: result => result,\n            JsdocTypeTypeof: (result, transform) => ({\n                type: 'JsdocTypeTypeof',\n                element: transform(result.element)\n            }),\n            JsdocTypeSymbol: (result, transform) => {\n                const transformed = {\n                    type: 'JsdocTypeSymbol',\n                    value: result.value\n                };\n                if (result.element !== undefined) {\n                    transformed.element = transform(result.element);\n                }\n                return transformed;\n            },\n            JsdocTypeOptional: (result, transform) => ({\n                type: 'JsdocTypeOptional',\n                element: transform(result.element),\n                meta: {\n                    position: result.meta.position\n                }\n            }),\n            JsdocTypeObject: (result, transform) => ({\n                type: 'JsdocTypeObject',\n                meta: {\n                    separator: 'comma'\n                },\n                elements: result.elements.map(transform)\n            }),\n            JsdocTypeNumber: result => result,\n            JsdocTypeNull: result => result,\n            JsdocTypeNotNullable: (result, transform) => ({\n                type: 'JsdocTypeNotNullable',\n                element: transform(result.element),\n                meta: {\n                    position: result.meta.position\n                }\n            }),\n            JsdocTypeSpecialNamePath: result => result,\n            JsdocTypeObjectField: (result, transform) => ({\n                type: 'JsdocTypeObjectField',\n                key: result.key,\n                right: result.right === undefined ? undefined : transform(result.right),\n                optional: result.optional,\n                readonly: result.readonly,\n                meta: result.meta\n            }),\n            JsdocTypeJsdocObjectField: (result, transform) => ({\n                type: 'JsdocTypeJsdocObjectField',\n                left: transform(result.left),\n                right: transform(result.right)\n            }),\n            JsdocTypeKeyValue: (result, transform) => {\n                return {\n                    type: 'JsdocTypeKeyValue',\n                    key: result.key,\n                    right: result.right === undefined ? undefined : transform(result.right),\n                    optional: result.optional,\n                    variadic: result.variadic\n                };\n            },\n            JsdocTypeImport: (result, transform) => ({\n                type: 'JsdocTypeImport',\n                element: transform(result.element)\n            }),\n            JsdocTypeAny: result => result,\n            JsdocTypeStringValue: result => result,\n            JsdocTypeNamePath: result => result,\n            JsdocTypeVariadic: (result, transform) => {\n                const transformed = {\n                    type: 'JsdocTypeVariadic',\n                    meta: {\n                        position: result.meta.position,\n                        squareBrackets: result.meta.squareBrackets\n                    }\n                };\n                if (result.element !== undefined) {\n                    transformed.element = transform(result.element);\n                }\n                return transformed;\n            },\n            JsdocTypeTuple: (result, transform) => ({\n                type: 'JsdocTypeTuple',\n                elements: result.elements.map(transform)\n            }),\n            JsdocTypeName: result => result,\n            JsdocTypeFunction: (result, transform) => {\n                const transformed = {\n                    type: 'JsdocTypeFunction',\n                    arrow: result.arrow,\n                    parameters: result.parameters.map(transform),\n                    constructor: result.constructor,\n                    parenthesis: result.parenthesis\n                };\n                if (result.returnType !== undefined) {\n                    transformed.returnType = transform(result.returnType);\n                }\n                return transformed;\n            },\n            JsdocTypeKeyof: (result, transform) => ({\n                type: 'JsdocTypeKeyof',\n                element: transform(result.element)\n            }),\n            JsdocTypeParenthesis: (result, transform) => ({\n                type: 'JsdocTypeParenthesis',\n                element: transform(result.element)\n            }),\n            JsdocTypeProperty: result => result,\n            JsdocTypePredicate: (result, transform) => ({\n                type: 'JsdocTypePredicate',\n                left: transform(result.left),\n                right: transform(result.right)\n            }),\n            JsdocTypeIndexSignature: (result, transform) => ({\n                type: 'JsdocTypeIndexSignature',\n                key: result.key,\n                right: transform(result.right)\n            }),\n            JsdocTypeMappedType: (result, transform) => ({\n                type: 'JsdocTypeMappedType',\n                key: result.key,\n                right: transform(result.right)\n            }),\n            JsdocTypeAsserts: (result, transform) => ({\n                type: 'JsdocTypeAsserts',\n                left: transform(result.left),\n                right: transform(result.right)\n            }),\n            JsdocTypeReadonlyArray: (result, transform) => ({\n                type: 'JsdocTypeReadonlyArray',\n                element: transform(result.element)\n            }),\n            JsdocTypeAssertsPlain: (result, transform) => ({\n                type: 'JsdocTypeAssertsPlain',\n                element: transform(result.element)\n            }),\n            JsdocTypeConditional: (result, transform) => ({\n                type: 'JsdocTypeConditional',\n                checksType: transform(result.checksType),\n                extendsType: transform(result.extendsType),\n                trueType: transform(result.trueType),\n                falseType: transform(result.falseType)\n            }),\n            JsdocTypeTypeParameter: (result, transform) => ({\n                type: 'JsdocTypeTypeParameter',\n                name: transform(result.name),\n                constraint: result.constraint !== undefined ? transform(result.constraint) : undefined,\n                defaultValue: result.defaultValue !== undefined ? transform(result.defaultValue) : undefined\n            })\n        };\n    }\n\n    const visitorKeys = {\n        JsdocTypeAny: [],\n        JsdocTypeFunction: ['parameters', 'returnType'],\n        JsdocTypeGeneric: ['left', 'elements'],\n        JsdocTypeImport: [],\n        JsdocTypeIndexSignature: ['right'],\n        JsdocTypeIntersection: ['elements'],\n        JsdocTypeKeyof: ['element'],\n        JsdocTypeKeyValue: ['right'],\n        JsdocTypeMappedType: ['right'],\n        JsdocTypeName: [],\n        JsdocTypeNamePath: ['left', 'right'],\n        JsdocTypeNotNullable: ['element'],\n        JsdocTypeNull: [],\n        JsdocTypeNullable: ['element'],\n        JsdocTypeNumber: [],\n        JsdocTypeObject: ['elements'],\n        JsdocTypeObjectField: ['right'],\n        JsdocTypeJsdocObjectField: ['left', 'right'],\n        JsdocTypeOptional: ['element'],\n        JsdocTypeParenthesis: ['element'],\n        JsdocTypeSpecialNamePath: [],\n        JsdocTypeStringValue: [],\n        JsdocTypeSymbol: ['element'],\n        JsdocTypeTuple: ['elements'],\n        JsdocTypeTypeof: ['element'],\n        JsdocTypeUndefined: [],\n        JsdocTypeUnion: ['elements'],\n        JsdocTypeUnknown: [],\n        JsdocTypeVariadic: ['element'],\n        JsdocTypeProperty: [],\n        JsdocTypePredicate: ['left', 'right'],\n        JsdocTypeAsserts: ['left', 'right'],\n        JsdocTypeReadonlyArray: ['element'],\n        JsdocTypeAssertsPlain: ['element'],\n        JsdocTypeConditional: ['checksType', 'extendsType', 'trueType', 'falseType'],\n        JsdocTypeTypeParameter: ['name', 'constraint', 'defaultValue']\n    };\n\n    function _traverse(node, parentNode, property, onEnter, onLeave) {\n        onEnter === null || onEnter === void 0 ? void 0 : onEnter(node, parentNode, property);\n        const keysToVisit = visitorKeys[node.type];\n        for (const key of keysToVisit) {\n            const value = node[key];\n            if (value !== undefined) {\n                if (Array.isArray(value)) {\n                    for (const element of value) {\n                        _traverse(element, node, key, onEnter, onLeave);\n                    }\n                }\n                else {\n                    _traverse(value, node, key, onEnter, onLeave);\n                }\n            }\n        }\n        onLeave === null || onLeave === void 0 ? void 0 : onLeave(node, parentNode, property);\n    }\n    /**\n     * A function to traverse an AST. It traverses it depth first.\n     * @param node the node to start traversing at.\n     * @param onEnter node visitor function that will be called on entering the node. This corresponds to preorder traversing.\n     * @param onLeave node visitor function that will be called on leaving the node. This corresponds to postorder traversing.\n     */\n    function traverse(node, onEnter, onLeave) {\n        _traverse(node, undefined, undefined, onEnter, onLeave);\n    }\n\n    exports.catharsisTransform = catharsisTransform;\n    exports.identityTransformRules = identityTransformRules;\n    exports.jtpTransform = jtpTransform;\n    exports.parse = parse;\n    exports.stringify = stringify;\n    exports.stringifyRules = stringifyRules;\n    exports.transform = transform;\n    exports.traverse = traverse;\n    exports.tryParse = tryParse;\n    exports.visitorKeys = visitorKeys;\n\n}));\n"
    ],
    "mappings": "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",
    "ignoreList": []
  },
  "metadata": {},
  "sourceType": "script",
  "externalDependencies": []
}
