{
  "ast": null,
  "code": "import { _ as Ha } from \"./index-944f225b.mjs\";\nvar Qe = typeof globalThis < \"u\" ? globalThis : typeof window < \"u\" ? window : typeof global < \"u\" ? global : typeof self < \"u\" ? self : {};\nfunction Lo(a) {\n  return a && a.__esModule && Object.prototype.hasOwnProperty.call(a, \"default\") ? a.default : a;\n}\nvar ht = function (a) {\n    return a && a.Math === Math && a;\n  },\n  _ =\n  // eslint-disable-next-line es/no-global-this -- safe\n  ht(typeof globalThis == \"object\" && globalThis) || ht(typeof window == \"object\" && window) ||\n  // eslint-disable-next-line no-restricted-globals -- safe\n  ht(typeof self == \"object\" && self) || ht(typeof Qe == \"object\" && Qe) || ht(typeof Qe == \"object\" && Qe) ||\n  // eslint-disable-next-line no-new-func -- fallback\n  function () {\n    return this;\n  }() || Function(\"return this\")(),\n  Et = {},\n  D = function (a) {\n    try {\n      return !!a();\n    } catch {\n      return !0;\n    }\n  },\n  Pl = D,\n  he = !Pl(function () {\n    return Object.defineProperty({}, 1, {\n      get: function () {\n        return 7;\n      }\n    })[1] !== 7;\n  }),\n  Rl = D,\n  br = !Rl(function () {\n    var a = function () {}.bind();\n    return typeof a != \"function\" || a.hasOwnProperty(\"prototype\");\n  }),\n  Nl = br,\n  Ft = Function.prototype.call,\n  Y = Nl ? Ft.bind(Ft) : function () {\n    return Ft.apply(Ft, arguments);\n  },\n  ko = {},\n  Bo = {}.propertyIsEnumerable,\n  jo = Object.getOwnPropertyDescriptor,\n  Il = jo && !Bo.call({\n    1: 2\n  }, 1);\nko.f = Il ? function (e) {\n  var t = jo(this, e);\n  return !!t && t.enumerable;\n} : Bo;\nvar Oi = function (a, e) {\n    return {\n      enumerable: !(a & 1),\n      configurable: !(a & 2),\n      writable: !(a & 4),\n      value: e\n    };\n  },\n  Fo = br,\n  Uo = Function.prototype,\n  Ya = Uo.call,\n  Ml = Fo && Uo.bind.bind(Ya, Ya),\n  L = Fo ? Ml : function (a) {\n    return function () {\n      return Ya.apply(a, arguments);\n    };\n  },\n  Go = L,\n  _l = Go({}.toString),\n  Vl = Go(\"\".slice),\n  je = function (a) {\n    return Vl(_l(a), 8, -1);\n  },\n  Dl = L,\n  Ll = D,\n  kl = je,\n  Zr = Object,\n  Bl = Dl(\"\".split),\n  zo = Ll(function () {\n    return !Zr(\"z\").propertyIsEnumerable(0);\n  }) ? function (a) {\n    return kl(a) === \"String\" ? Bl(a, \"\") : Zr(a);\n  } : Zr,\n  xr = function (a) {\n    return a == null;\n  },\n  jl = xr,\n  Fl = TypeError,\n  ve = function (a) {\n    if (jl(a)) throw new Fl(\"Can't call method on \" + a);\n    return a;\n  },\n  Ul = zo,\n  Gl = ve,\n  $t = function (a) {\n    return Ul(Gl(a));\n  },\n  Jr = typeof document == \"object\" && document.all,\n  B = typeof Jr > \"u\" && Jr !== void 0 ? function (a) {\n    return typeof a == \"function\" || a === Jr;\n  } : function (a) {\n    return typeof a == \"function\";\n  },\n  zl = B,\n  ae = function (a) {\n    return typeof a == \"object\" ? a !== null : zl(a);\n  },\n  ea = _,\n  Hl = B,\n  Yl = function (a) {\n    return Hl(a) ? a : void 0;\n  },\n  Fe = function (a, e) {\n    return arguments.length < 2 ? Yl(ea[a]) : ea[a] && ea[a][e];\n  },\n  Xl = L,\n  Tr = Xl({}.isPrototypeOf),\n  Wl = _,\n  yn = Wl.navigator,\n  mn = yn && yn.userAgent,\n  wt = mn ? String(mn) : \"\",\n  Ho = _,\n  ta = wt,\n  bn = Ho.process,\n  xn = Ho.Deno,\n  Tn = bn && bn.versions || xn && xn.version,\n  On = Tn && Tn.v8,\n  le,\n  cr;\nOn && (le = On.split(\".\"), cr = le[0] > 0 && le[0] < 4 ? 1 : +(le[0] + le[1]));\n!cr && ta && (le = ta.match(/Edge\\/(\\d+)/), (!le || le[1] >= 74) && (le = ta.match(/Chrome\\/(\\d+)/), le && (cr = +le[1])));\nvar Si = cr,\n  Sn = Si,\n  ql = D,\n  Ql = _,\n  Kl = Ql.String,\n  Yo = !!Object.getOwnPropertySymbols && !ql(function () {\n    var a = Symbol(\"symbol detection\");\n    return !Kl(a) || !(Object(a) instanceof Symbol) ||\n    // Chrome 38-40 symbols are not inherited from DOM collections prototypes to instances\n    !Symbol.sham && Sn && Sn < 41;\n  }),\n  Zl = Yo,\n  Xo = Zl && !Symbol.sham && typeof Symbol.iterator == \"symbol\",\n  Jl = Fe,\n  eh = B,\n  th = Tr,\n  rh = Xo,\n  ah = Object,\n  Wo = rh ? function (a) {\n    return typeof a == \"symbol\";\n  } : function (a) {\n    var e = Jl(\"Symbol\");\n    return eh(e) && th(e.prototype, ah(a));\n  },\n  ih = String,\n  Or = function (a) {\n    try {\n      return ih(a);\n    } catch {\n      return \"Object\";\n    }\n  },\n  nh = B,\n  sh = Or,\n  oh = TypeError,\n  Te = function (a) {\n    if (nh(a)) return a;\n    throw new oh(sh(a) + \" is not a function\");\n  },\n  uh = Te,\n  lh = xr,\n  st = function (a, e) {\n    var t = a[e];\n    return lh(t) ? void 0 : uh(t);\n  },\n  ra = Y,\n  aa = B,\n  ia = ae,\n  hh = TypeError,\n  vh = function (a, e) {\n    var t, r;\n    if (e === \"string\" && aa(t = a.toString) && !ia(r = ra(t, a)) || aa(t = a.valueOf) && !ia(r = ra(t, a)) || e !== \"string\" && aa(t = a.toString) && !ia(r = ra(t, a))) return r;\n    throw new hh(\"Can't convert object to primitive value\");\n  },\n  qo = {\n    exports: {}\n  },\n  En = _,\n  fh = Object.defineProperty,\n  Ei = function (a, e) {\n    try {\n      fh(En, a, {\n        value: e,\n        configurable: !0,\n        writable: !0\n      });\n    } catch {\n      En[a] = e;\n    }\n    return e;\n  },\n  ch = _,\n  gh = Ei,\n  $n = \"__core-js_shared__\",\n  wn = qo.exports = ch[$n] || gh($n, {});\n(wn.versions || (wn.versions = [])).push({\n  version: \"3.45.1\",\n  mode: \"global\",\n  copyright: \"Â© 2014-2025 Denis Pushkarev (zloirock.ru)\",\n  license: \"https://github.com/zloirock/core-js/blob/v3.45.1/LICENSE\",\n  source: \"https://github.com/zloirock/core-js\"\n});\nvar $i = qo.exports,\n  Cn = $i,\n  wi = function (a, e) {\n    return Cn[a] || (Cn[a] = e || {});\n  },\n  dh = ve,\n  ph = Object,\n  Sr = function (a) {\n    return ph(dh(a));\n  },\n  yh = L,\n  mh = Sr,\n  bh = yh({}.hasOwnProperty),\n  fe = Object.hasOwn || function (e, t) {\n    return bh(mh(e), t);\n  },\n  xh = L,\n  Th = 0,\n  Oh = Math.random(),\n  Sh = xh(1.1.toString),\n  Qo = function (a) {\n    return \"Symbol(\" + (a === void 0 ? \"\" : a) + \")_\" + Sh(++Th + Oh, 36);\n  },\n  Eh = _,\n  $h = wi,\n  An = fe,\n  wh = Qo,\n  Ch = Yo,\n  Ah = Xo,\n  Ke = Eh.Symbol,\n  na = $h(\"wks\"),\n  Ph = Ah ? Ke.for || Ke : Ke && Ke.withoutSetter || wh,\n  z = function (a) {\n    return An(na, a) || (na[a] = Ch && An(Ke, a) ? Ke[a] : Ph(\"Symbol.\" + a)), na[a];\n  },\n  Rh = Y,\n  Pn = ae,\n  Rn = Wo,\n  Nh = st,\n  Ih = vh,\n  Mh = z,\n  _h = TypeError,\n  Vh = Mh(\"toPrimitive\"),\n  Dh = function (a, e) {\n    if (!Pn(a) || Rn(a)) return a;\n    var t = Nh(a, Vh),\n      r;\n    if (t) {\n      if (e === void 0 && (e = \"default\"), r = Rh(t, a, e), !Pn(r) || Rn(r)) return r;\n      throw new _h(\"Can't convert object to primitive value\");\n    }\n    return e === void 0 && (e = \"number\"), Ih(a, e);\n  },\n  Lh = Dh,\n  kh = Wo,\n  Ko = function (a) {\n    var e = Lh(a, \"string\");\n    return kh(e) ? e : e + \"\";\n  },\n  Bh = _,\n  Nn = ae,\n  Xa = Bh.document,\n  jh = Nn(Xa) && Nn(Xa.createElement),\n  Er = function (a) {\n    return jh ? Xa.createElement(a) : {};\n  },\n  Fh = he,\n  Uh = D,\n  Gh = Er,\n  Zo = !Fh && !Uh(function () {\n    return Object.defineProperty(Gh(\"div\"), \"a\", {\n      get: function () {\n        return 7;\n      }\n    }).a !== 7;\n  }),\n  zh = he,\n  Hh = Y,\n  Yh = ko,\n  Xh = Oi,\n  Wh = $t,\n  qh = Ko,\n  Qh = fe,\n  Kh = Zo,\n  In = Object.getOwnPropertyDescriptor;\nEt.f = zh ? In : function (e, t) {\n  if (e = Wh(e), t = qh(t), Kh) try {\n    return In(e, t);\n  } catch {}\n  if (Qh(e, t)) return Xh(!Hh(Yh.f, e, t), e[t]);\n};\nvar Oe = {},\n  Zh = he,\n  Jh = D,\n  Jo = Zh && Jh(function () {\n    return Object.defineProperty(function () {}, \"prototype\", {\n      value: 42,\n      writable: !1\n    }).prototype !== 42;\n  }),\n  ev = ae,\n  tv = String,\n  rv = TypeError,\n  J = function (a) {\n    if (ev(a)) return a;\n    throw new rv(tv(a) + \" is not an object\");\n  },\n  av = he,\n  iv = Zo,\n  nv = Jo,\n  Ut = J,\n  Mn = Ko,\n  sv = TypeError,\n  sa = Object.defineProperty,\n  ov = Object.getOwnPropertyDescriptor,\n  oa = \"enumerable\",\n  ua = \"configurable\",\n  la = \"writable\";\nOe.f = av ? nv ? function (e, t, r) {\n  if (Ut(e), t = Mn(t), Ut(r), typeof e == \"function\" && t === \"prototype\" && \"value\" in r && la in r && !r[la]) {\n    var i = ov(e, t);\n    i && i[la] && (e[t] = r.value, r = {\n      configurable: ua in r ? r[ua] : i[ua],\n      enumerable: oa in r ? r[oa] : i[oa],\n      writable: !1\n    });\n  }\n  return sa(e, t, r);\n} : sa : function (e, t, r) {\n  if (Ut(e), t = Mn(t), Ut(r), iv) try {\n    return sa(e, t, r);\n  } catch {}\n  if (\"get\" in r || \"set\" in r) throw new sv(\"Accessors not supported\");\n  return \"value\" in r && (e[t] = r.value), e;\n};\nvar uv = he,\n  lv = Oe,\n  hv = Oi,\n  Ct = uv ? function (a, e, t) {\n    return lv.f(a, e, hv(1, t));\n  } : function (a, e, t) {\n    return a[e] = t, a;\n  },\n  eu = {\n    exports: {}\n  },\n  Wa = he,\n  vv = fe,\n  tu = Function.prototype,\n  fv = Wa && Object.getOwnPropertyDescriptor,\n  Ci = vv(tu, \"name\"),\n  cv = Ci && function () {}.name === \"something\",\n  gv = Ci && (!Wa || Wa && fv(tu, \"name\").configurable),\n  $r = {\n    EXISTS: Ci,\n    PROPER: cv,\n    CONFIGURABLE: gv\n  },\n  dv = L,\n  pv = B,\n  qa = $i,\n  yv = dv(Function.toString);\npv(qa.inspectSource) || (qa.inspectSource = function (a) {\n  return yv(a);\n});\nvar Ai = qa.inspectSource,\n  mv = _,\n  bv = B,\n  _n = mv.WeakMap,\n  xv = bv(_n) && /native code/.test(String(_n)),\n  Tv = wi,\n  Ov = Qo,\n  Vn = Tv(\"keys\"),\n  Pi = function (a) {\n    return Vn[a] || (Vn[a] = Ov(a));\n  },\n  Ri = {},\n  Sv = xv,\n  ru = _,\n  Ev = ae,\n  $v = Ct,\n  ha = fe,\n  va = $i,\n  wv = Pi,\n  Cv = Ri,\n  Dn = \"Object already initialized\",\n  Qa = ru.TypeError,\n  Av = ru.WeakMap,\n  gr,\n  Tt,\n  dr,\n  Pv = function (a) {\n    return dr(a) ? Tt(a) : gr(a, {});\n  },\n  Rv = function (a) {\n    return function (e) {\n      var t;\n      if (!Ev(e) || (t = Tt(e)).type !== a) throw new Qa(\"Incompatible receiver, \" + a + \" required\");\n      return t;\n    };\n  };\nif (Sv || va.state) {\n  var de = va.state || (va.state = new Av());\n  de.get = de.get, de.has = de.has, de.set = de.set, gr = function (a, e) {\n    if (de.has(a)) throw new Qa(Dn);\n    return e.facade = a, de.set(a, e), e;\n  }, Tt = function (a) {\n    return de.get(a) || {};\n  }, dr = function (a) {\n    return de.has(a);\n  };\n} else {\n  var Ye = wv(\"state\");\n  Cv[Ye] = !0, gr = function (a, e) {\n    if (ha(a, Ye)) throw new Qa(Dn);\n    return e.facade = a, $v(a, Ye, e), e;\n  }, Tt = function (a) {\n    return ha(a, Ye) ? a[Ye] : {};\n  }, dr = function (a) {\n    return ha(a, Ye);\n  };\n}\nvar wr = {\n    set: gr,\n    get: Tt,\n    has: dr,\n    enforce: Pv,\n    getterFor: Rv\n  },\n  Ni = L,\n  Nv = D,\n  Iv = B,\n  Gt = fe,\n  Ka = he,\n  Mv = $r.CONFIGURABLE,\n  _v = Ai,\n  au = wr,\n  Vv = au.enforce,\n  Dv = au.get,\n  Ln = String,\n  or = Object.defineProperty,\n  Lv = Ni(\"\".slice),\n  kv = Ni(\"\".replace),\n  Bv = Ni([].join),\n  jv = Ka && !Nv(function () {\n    return or(function () {}, \"length\", {\n      value: 8\n    }).length !== 8;\n  }),\n  Fv = String(String).split(\"String\"),\n  Uv = eu.exports = function (a, e, t) {\n    Lv(Ln(e), 0, 7) === \"Symbol(\" && (e = \"[\" + kv(Ln(e), /^Symbol\\(([^)]*)\\).*$/, \"$1\") + \"]\"), t && t.getter && (e = \"get \" + e), t && t.setter && (e = \"set \" + e), (!Gt(a, \"name\") || Mv && a.name !== e) && (Ka ? or(a, \"name\", {\n      value: e,\n      configurable: !0\n    }) : a.name = e), jv && t && Gt(t, \"arity\") && a.length !== t.arity && or(a, \"length\", {\n      value: t.arity\n    });\n    try {\n      t && Gt(t, \"constructor\") && t.constructor ? Ka && or(a, \"prototype\", {\n        writable: !1\n      }) : a.prototype && (a.prototype = void 0);\n    } catch {}\n    var r = Vv(a);\n    return Gt(r, \"source\") || (r.source = Bv(Fv, typeof e == \"string\" ? e : \"\")), a;\n  };\nFunction.prototype.toString = Uv(function () {\n  return Iv(this) && Dv(this).source || _v(this);\n}, \"toString\");\nvar iu = eu.exports,\n  Gv = B,\n  zv = Oe,\n  Hv = iu,\n  Yv = Ei,\n  Ue = function (a, e, t, r) {\n    r || (r = {});\n    var i = r.enumerable,\n      n = r.name !== void 0 ? r.name : e;\n    if (Gv(t) && Hv(t, n, r), r.global) i ? a[e] = t : Yv(e, t);else {\n      try {\n        r.unsafe ? a[e] && (i = !0) : delete a[e];\n      } catch {}\n      i ? a[e] = t : zv.f(a, e, {\n        value: t,\n        enumerable: !1,\n        configurable: !r.nonConfigurable,\n        writable: !r.nonWritable\n      });\n    }\n    return a;\n  },\n  nu = {},\n  Xv = Math.ceil,\n  Wv = Math.floor,\n  qv = Math.trunc || function (e) {\n    var t = +e;\n    return (t > 0 ? Wv : Xv)(t);\n  },\n  Qv = qv,\n  Cr = function (a) {\n    var e = +a;\n    return e !== e || e === 0 ? 0 : Qv(e);\n  },\n  Kv = Cr,\n  Zv = Math.max,\n  Jv = Math.min,\n  ef = function (a, e) {\n    var t = Kv(a);\n    return t < 0 ? Zv(t + e, 0) : Jv(t, e);\n  },\n  tf = Cr,\n  rf = Math.min,\n  ot = function (a) {\n    var e = tf(a);\n    return e > 0 ? rf(e, 9007199254740991) : 0;\n  },\n  af = ot,\n  Ii = function (a) {\n    return af(a.length);\n  },\n  nf = $t,\n  sf = ef,\n  of = Ii,\n  kn = function (a) {\n    return function (e, t, r) {\n      var i = nf(e),\n        n = of(i);\n      if (n === 0) return !a && -1;\n      var o = sf(r, n),\n        s;\n      if (a && t !== t) {\n        for (; n > o;) if (s = i[o++], s !== s) return !0;\n      } else for (; n > o; o++) if ((a || o in i) && i[o] === t) return a || o || 0;\n      return !a && -1;\n    };\n  },\n  su = {\n    // `Array.prototype.includes` method\n    // https://tc39.es/ecma262/#sec-array.prototype.includes\n    includes: kn(!0),\n    // `Array.prototype.indexOf` method\n    // https://tc39.es/ecma262/#sec-array.prototype.indexof\n    indexOf: kn(!1)\n  },\n  uf = L,\n  fa = fe,\n  lf = $t,\n  hf = su.indexOf,\n  vf = Ri,\n  Bn = uf([].push),\n  ou = function (a, e) {\n    var t = lf(a),\n      r = 0,\n      i = [],\n      n;\n    for (n in t) !fa(vf, n) && fa(t, n) && Bn(i, n);\n    for (; e.length > r;) fa(t, n = e[r++]) && (~hf(i, n) || Bn(i, n));\n    return i;\n  },\n  Mi = [\"constructor\", \"hasOwnProperty\", \"isPrototypeOf\", \"propertyIsEnumerable\", \"toLocaleString\", \"toString\", \"valueOf\"],\n  ff = ou,\n  cf = Mi,\n  gf = cf.concat(\"length\", \"prototype\");\nnu.f = Object.getOwnPropertyNames || function (e) {\n  return ff(e, gf);\n};\nvar uu = {};\nuu.f = Object.getOwnPropertySymbols;\nvar df = Fe,\n  pf = L,\n  yf = nu,\n  mf = uu,\n  bf = J,\n  xf = pf([].concat),\n  Tf = df(\"Reflect\", \"ownKeys\") || function (e) {\n    var t = yf.f(bf(e)),\n      r = mf.f;\n    return r ? xf(t, r(e)) : t;\n  },\n  jn = fe,\n  Of = Tf,\n  Sf = Et,\n  Ef = Oe,\n  $f = function (a, e, t) {\n    for (var r = Of(e), i = Ef.f, n = Sf.f, o = 0; o < r.length; o++) {\n      var s = r[o];\n      !jn(a, s) && !(t && jn(t, s)) && i(a, s, n(e, s));\n    }\n  },\n  wf = D,\n  Cf = B,\n  Af = /#|\\.prototype\\./,\n  At = function (a, e) {\n    var t = Rf[Pf(a)];\n    return t === If ? !0 : t === Nf ? !1 : Cf(e) ? wf(e) : !!e;\n  },\n  Pf = At.normalize = function (a) {\n    return String(a).replace(Af, \".\").toLowerCase();\n  },\n  Rf = At.data = {},\n  Nf = At.NATIVE = \"N\",\n  If = At.POLYFILL = \"P\",\n  lu = At,\n  zt = _,\n  Mf = Et.f,\n  _f = Ct,\n  Vf = Ue,\n  Df = Ei,\n  Lf = $f,\n  kf = lu,\n  ee = function (a, e) {\n    var t = a.target,\n      r = a.global,\n      i = a.stat,\n      n,\n      o,\n      s,\n      u,\n      l,\n      h;\n    if (r ? o = zt : i ? o = zt[t] || Df(t, {}) : o = zt[t] && zt[t].prototype, o) for (s in e) {\n      if (l = e[s], a.dontCallGetSet ? (h = Mf(o, s), u = h && h.value) : u = o[s], n = kf(r ? s : t + (i ? \".\" : \"#\") + s, a.forced), !n && u !== void 0) {\n        if (typeof l == typeof u) continue;\n        Lf(l, u);\n      }\n      (a.sham || u && u.sham) && _f(l, \"sham\", !0), Vf(o, s, l, a);\n    }\n  },\n  vt = _,\n  Bf = wt,\n  jf = je,\n  Ht = function (a) {\n    return Bf.slice(0, a.length) === a;\n  },\n  hu = function () {\n    return Ht(\"Bun/\") ? \"BUN\" : Ht(\"Cloudflare-Workers\") ? \"CLOUDFLARE\" : Ht(\"Deno/\") ? \"DENO\" : Ht(\"Node.js/\") ? \"NODE\" : vt.Bun && typeof Bun.version == \"string\" ? \"BUN\" : vt.Deno && typeof Deno.version == \"object\" ? \"DENO\" : jf(vt.process) === \"process\" ? \"NODE\" : vt.window && vt.document ? \"BROWSER\" : \"REST\";\n  }(),\n  Ff = hu,\n  Ar = Ff === \"NODE\",\n  Uf = _,\n  Gf = Uf,\n  zf = L,\n  Hf = Te,\n  Yf = function (a, e, t) {\n    try {\n      return zf(Hf(Object.getOwnPropertyDescriptor(a, e)[t]));\n    } catch {}\n  },\n  Xf = ae,\n  Wf = function (a) {\n    return Xf(a) || a === null;\n  },\n  qf = Wf,\n  Qf = String,\n  Kf = TypeError,\n  Zf = function (a) {\n    if (qf(a)) return a;\n    throw new Kf(\"Can't set \" + Qf(a) + \" as a prototype\");\n  },\n  Jf = Yf,\n  ec = ae,\n  tc = ve,\n  rc = Zf,\n  vu = Object.setPrototypeOf || (\"__proto__\" in {} ? function () {\n    var a = !1,\n      e = {},\n      t;\n    try {\n      t = Jf(Object.prototype, \"__proto__\", \"set\"), t(e, []), a = e instanceof Array;\n    } catch {}\n    return function (i, n) {\n      return tc(i), rc(n), ec(i) && (a ? t(i, n) : i.__proto__ = n), i;\n    };\n  }() : void 0),\n  ac = Oe.f,\n  ic = fe,\n  nc = z,\n  Fn = nc(\"toStringTag\"),\n  Pr = function (a, e, t) {\n    a && !t && (a = a.prototype), a && !ic(a, Fn) && ac(a, Fn, {\n      configurable: !0,\n      value: e\n    });\n  },\n  Un = iu,\n  sc = Oe,\n  oc = function (a, e, t) {\n    return t.get && Un(t.get, e, {\n      getter: !0\n    }), t.set && Un(t.set, e, {\n      setter: !0\n    }), sc.f(a, e, t);\n  },\n  uc = Fe,\n  lc = oc,\n  hc = z,\n  vc = he,\n  Gn = hc(\"species\"),\n  fc = function (a) {\n    var e = uc(a);\n    vc && e && !e[Gn] && lc(e, Gn, {\n      configurable: !0,\n      get: function () {\n        return this;\n      }\n    });\n  },\n  cc = Tr,\n  gc = TypeError,\n  dc = function (a, e) {\n    if (cc(e, a)) return a;\n    throw new gc(\"Incorrect invocation\");\n  },\n  pc = z,\n  yc = pc(\"toStringTag\"),\n  fu = {};\nfu[yc] = \"z\";\nvar mc = String(fu) === \"[object z]\",\n  bc = mc,\n  xc = B,\n  ur = je,\n  Tc = z,\n  Oc = Tc(\"toStringTag\"),\n  Sc = Object,\n  Ec = ur(function () {\n    return arguments;\n  }()) === \"Arguments\",\n  $c = function (a, e) {\n    try {\n      return a[e];\n    } catch {}\n  },\n  _i = bc ? ur : function (a) {\n    var e, t, r;\n    return a === void 0 ? \"Undefined\" : a === null ? \"Null\" : typeof (t = $c(e = Sc(a), Oc)) == \"string\" ? t : Ec ? ur(e) : (r = ur(e)) === \"Object\" && xc(e.callee) ? \"Arguments\" : r;\n  },\n  wc = L,\n  Cc = D,\n  cu = B,\n  Ac = _i,\n  Pc = Fe,\n  Rc = Ai,\n  gu = function () {},\n  du = Pc(\"Reflect\", \"construct\"),\n  Vi = /^\\s*(?:class|function)\\b/,\n  Nc = wc(Vi.exec),\n  Ic = !Vi.test(gu),\n  ft = function (e) {\n    if (!cu(e)) return !1;\n    try {\n      return du(gu, [], e), !0;\n    } catch {\n      return !1;\n    }\n  },\n  pu = function (e) {\n    if (!cu(e)) return !1;\n    switch (Ac(e)) {\n      case \"AsyncFunction\":\n      case \"GeneratorFunction\":\n      case \"AsyncGeneratorFunction\":\n        return !1;\n    }\n    try {\n      return Ic || !!Nc(Vi, Rc(e));\n    } catch {\n      return !0;\n    }\n  };\npu.sham = !0;\nvar Mc = !du || Cc(function () {\n    var a;\n    return ft(ft.call) || !ft(Object) || !ft(function () {\n      a = !0;\n    }) || a;\n  }) ? pu : ft,\n  _c = Mc,\n  Vc = Or,\n  Dc = TypeError,\n  Lc = function (a) {\n    if (_c(a)) return a;\n    throw new Dc(Vc(a) + \" is not a constructor\");\n  },\n  zn = J,\n  kc = Lc,\n  Bc = xr,\n  jc = z,\n  Fc = jc(\"species\"),\n  yu = function (a, e) {\n    var t = zn(a).constructor,\n      r;\n    return t === void 0 || Bc(r = zn(t)[Fc]) ? e : kc(r);\n  },\n  Uc = br,\n  mu = Function.prototype,\n  Hn = mu.apply,\n  Yn = mu.call,\n  bu = typeof Reflect == \"object\" && Reflect.apply || (Uc ? Yn.bind(Hn) : function () {\n    return Yn.apply(Hn, arguments);\n  }),\n  Gc = je,\n  zc = L,\n  Rr = function (a) {\n    if (Gc(a) === \"Function\") return zc(a);\n  },\n  Xn = Rr,\n  Hc = Te,\n  Yc = br,\n  Xc = Xn(Xn.bind),\n  Di = function (a, e) {\n    return Hc(a), e === void 0 ? a : Yc ? Xc(a, e) : function () {\n      return a.apply(e, arguments);\n    };\n  },\n  Wc = Fe,\n  xu = Wc(\"document\", \"documentElement\"),\n  qc = L,\n  Qc = qc([].slice),\n  Kc = TypeError,\n  Zc = function (a, e) {\n    if (a < e) throw new Kc(\"Not enough arguments\");\n    return a;\n  },\n  Jc = wt,\n  Tu = /(?:ipad|iphone|ipod).*applewebkit/i.test(Jc),\n  ie = _,\n  eg = bu,\n  tg = Di,\n  Wn = B,\n  rg = fe,\n  Ou = D,\n  qn = xu,\n  ag = Qc,\n  Qn = Er,\n  ig = Zc,\n  ng = Tu,\n  sg = Ar,\n  Za = ie.setImmediate,\n  Ja = ie.clearImmediate,\n  og = ie.process,\n  ca = ie.Dispatch,\n  ug = ie.Function,\n  Kn = ie.MessageChannel,\n  lg = ie.String,\n  ga = 0,\n  bt = {},\n  Zn = \"onreadystatechange\",\n  Ot,\n  Ie,\n  da,\n  pa;\nOu(function () {\n  Ot = ie.location;\n});\nvar Li = function (a) {\n    if (rg(bt, a)) {\n      var e = bt[a];\n      delete bt[a], e();\n    }\n  },\n  ya = function (a) {\n    return function () {\n      Li(a);\n    };\n  },\n  Jn = function (a) {\n    Li(a.data);\n  },\n  es = function (a) {\n    ie.postMessage(lg(a), Ot.protocol + \"//\" + Ot.host);\n  };\n(!Za || !Ja) && (Za = function (e) {\n  ig(arguments.length, 1);\n  var t = Wn(e) ? e : ug(e),\n    r = ag(arguments, 1);\n  return bt[++ga] = function () {\n    eg(t, void 0, r);\n  }, Ie(ga), ga;\n}, Ja = function (e) {\n  delete bt[e];\n}, sg ? Ie = function (a) {\n  og.nextTick(ya(a));\n} : ca && ca.now ? Ie = function (a) {\n  ca.now(ya(a));\n} : Kn && !ng ? (da = new Kn(), pa = da.port2, da.port1.onmessage = Jn, Ie = tg(pa.postMessage, pa)) : ie.addEventListener && Wn(ie.postMessage) && !ie.importScripts && Ot && Ot.protocol !== \"file:\" && !Ou(es) ? (Ie = es, ie.addEventListener(\"message\", Jn, !1)) : Zn in Qn(\"script\") ? Ie = function (a) {\n  qn.appendChild(Qn(\"script\"))[Zn] = function () {\n    qn.removeChild(this), Li(a);\n  };\n} : Ie = function (a) {\n  setTimeout(ya(a), 0);\n});\nvar Su = {\n    set: Za,\n    clear: Ja\n  },\n  ts = _,\n  hg = he,\n  vg = Object.getOwnPropertyDescriptor,\n  fg = function (a) {\n    if (!hg) return ts[a];\n    var e = vg(ts, a);\n    return e && e.value;\n  },\n  Eu = function () {\n    this.head = null, this.tail = null;\n  };\nEu.prototype = {\n  add: function (a) {\n    var e = {\n        item: a,\n        next: null\n      },\n      t = this.tail;\n    t ? t.next = e : this.head = e, this.tail = e;\n  },\n  get: function () {\n    var a = this.head;\n    if (a) {\n      var e = this.head = a.next;\n      return e === null && (this.tail = null), a.item;\n    }\n  }\n};\nvar $u = Eu,\n  cg = wt,\n  gg = /ipad|iphone|ipod/i.test(cg) && typeof Pebble < \"u\",\n  dg = wt,\n  pg = /web0s(?!.*chrome)/i.test(dg),\n  at = _,\n  yg = fg,\n  rs = Di,\n  ma = Su.set,\n  mg = $u,\n  bg = Tu,\n  xg = gg,\n  Tg = pg,\n  ba = Ar,\n  as = at.MutationObserver || at.WebKitMutationObserver,\n  is = at.document,\n  ns = at.process,\n  Yt = at.Promise,\n  ei = yg(\"queueMicrotask\"),\n  Xe,\n  xa,\n  Ta,\n  Xt,\n  ss;\nif (!ei) {\n  var Wt = new mg(),\n    qt = function () {\n      var a, e;\n      for (ba && (a = ns.domain) && a.exit(); e = Wt.get();) try {\n        e();\n      } catch (t) {\n        throw Wt.head && Xe(), t;\n      }\n      a && a.enter();\n    };\n  !bg && !ba && !Tg && as && is ? (xa = !0, Ta = is.createTextNode(\"\"), new as(qt).observe(Ta, {\n    characterData: !0\n  }), Xe = function () {\n    Ta.data = xa = !xa;\n  }) : !xg && Yt && Yt.resolve ? (Xt = Yt.resolve(void 0), Xt.constructor = Yt, ss = rs(Xt.then, Xt), Xe = function () {\n    ss(qt);\n  }) : ba ? Xe = function () {\n    ns.nextTick(qt);\n  } : (ma = rs(ma, at), Xe = function () {\n    ma(qt);\n  }), ei = function (a) {\n    Wt.head || Xe(), Wt.add(a);\n  };\n}\nvar Og = ei,\n  Sg = function (a, e) {\n    try {\n      arguments.length === 1 ? console.error(a) : console.error(a, e);\n    } catch {}\n  },\n  ki = function (a) {\n    try {\n      return {\n        error: !1,\n        value: a()\n      };\n    } catch (e) {\n      return {\n        error: !0,\n        value: e\n      };\n    }\n  },\n  Eg = _,\n  Nr = Eg.Promise,\n  $g = _,\n  xt = Nr,\n  wg = B,\n  Cg = lu,\n  Ag = Ai,\n  Pg = z,\n  os = hu,\n  Oa = Si;\nxt && xt.prototype;\nvar Rg = Pg(\"species\"),\n  ti = !1,\n  wu = wg($g.PromiseRejectionEvent),\n  Ng = Cg(\"Promise\", function () {\n    var a = Ag(xt),\n      e = a !== String(xt);\n    if (!e && Oa === 66) return !0;\n    if (!Oa || Oa < 51 || !/native code/.test(a)) {\n      var t = new xt(function (n) {\n          n(1);\n        }),\n        r = function (n) {\n          n(function () {}, function () {});\n        },\n        i = t.constructor = {};\n      if (i[Rg] = r, ti = t.then(function () {}) instanceof r, !ti) return !0;\n    }\n    return !e && (os === \"BROWSER\" || os === \"DENO\") && !wu;\n  }),\n  Pt = {\n    CONSTRUCTOR: Ng,\n    REJECTION_EVENT: wu,\n    SUBCLASSING: ti\n  },\n  ut = {},\n  us = Te,\n  Ig = TypeError,\n  Mg = function (a) {\n    var e, t;\n    this.promise = new a(function (r, i) {\n      if (e !== void 0 || t !== void 0) throw new Ig(\"Bad Promise constructor\");\n      e = r, t = i;\n    }), this.resolve = us(e), this.reject = us(t);\n  };\nut.f = function (a) {\n  return new Mg(a);\n};\nvar _g = ee,\n  pr = Ar,\n  we = _,\n  Vg = Gf,\n  it = Y,\n  ls = Ue,\n  hs = vu,\n  Dg = Pr,\n  Lg = fc,\n  kg = Te,\n  lr = B,\n  Bg = ae,\n  jg = dc,\n  Fg = yu,\n  Cu = Su.set,\n  Bi = Og,\n  Ug = Sg,\n  Gg = ki,\n  zg = $u,\n  Au = wr,\n  yr = Nr,\n  ji = Pt,\n  Pu = ut,\n  Ir = \"Promise\",\n  Ru = ji.CONSTRUCTOR,\n  Hg = ji.REJECTION_EVENT,\n  Yg = ji.SUBCLASSING,\n  Sa = Au.getterFor(Ir),\n  Xg = Au.set,\n  qe = yr && yr.prototype,\n  Le = yr,\n  Qt = qe,\n  Nu = we.TypeError,\n  ri = we.document,\n  Fi = we.process,\n  ai = Pu.f,\n  Wg = ai,\n  qg = !!(ri && ri.createEvent && we.dispatchEvent),\n  Iu = \"unhandledrejection\",\n  Qg = \"rejectionhandled\",\n  vs = 0,\n  Mu = 1,\n  Kg = 2,\n  Ui = 1,\n  _u = 2,\n  Kt,\n  fs,\n  Vu,\n  cs,\n  Du = function (a) {\n    var e;\n    return Bg(a) && lr(e = a.then) ? e : !1;\n  },\n  Lu = function (a, e) {\n    var t = e.value,\n      r = e.state === Mu,\n      i = r ? a.ok : a.fail,\n      n = a.resolve,\n      o = a.reject,\n      s = a.domain,\n      u,\n      l,\n      h;\n    try {\n      i ? (r || (e.rejection === _u && Jg(e), e.rejection = Ui), i === !0 ? u = t : (s && s.enter(), u = i(t), s && (s.exit(), h = !0)), u === a.promise ? o(new Nu(\"Promise-chain cycle\")) : (l = Du(u)) ? it(l, u, n, o) : n(u)) : o(t);\n    } catch (f) {\n      s && !h && s.exit(), o(f);\n    }\n  },\n  ku = function (a, e) {\n    a.notified || (a.notified = !0, Bi(function () {\n      for (var t = a.reactions, r; r = t.get();) Lu(r, a);\n      a.notified = !1, e && !a.rejection && Zg(a);\n    }));\n  },\n  Bu = function (a, e, t) {\n    var r, i;\n    qg ? (r = ri.createEvent(\"Event\"), r.promise = e, r.reason = t, r.initEvent(a, !1, !0), we.dispatchEvent(r)) : r = {\n      promise: e,\n      reason: t\n    }, !Hg && (i = we[\"on\" + a]) ? i(r) : a === Iu && Ug(\"Unhandled promise rejection\", t);\n  },\n  Zg = function (a) {\n    it(Cu, we, function () {\n      var e = a.facade,\n        t = a.value,\n        r = gs(a),\n        i;\n      if (r && (i = Gg(function () {\n        pr ? Fi.emit(\"unhandledRejection\", t, e) : Bu(Iu, e, t);\n      }), a.rejection = pr || gs(a) ? _u : Ui, i.error)) throw i.value;\n    });\n  },\n  gs = function (a) {\n    return a.rejection !== Ui && !a.parent;\n  },\n  Jg = function (a) {\n    it(Cu, we, function () {\n      var e = a.facade;\n      pr ? Fi.emit(\"rejectionHandled\", e) : Bu(Qg, e, a.value);\n    });\n  },\n  Ze = function (a, e, t) {\n    return function (r) {\n      a(e, r, t);\n    };\n  },\n  et = function (a, e, t) {\n    a.done || (a.done = !0, t && (a = t), a.value = e, a.state = Kg, ku(a, !0));\n  },\n  ii = function (a, e, t) {\n    if (!a.done) {\n      a.done = !0, t && (a = t);\n      try {\n        if (a.facade === e) throw new Nu(\"Promise can't be resolved itself\");\n        var r = Du(e);\n        r ? Bi(function () {\n          var i = {\n            done: !1\n          };\n          try {\n            it(r, e, Ze(ii, i, a), Ze(et, i, a));\n          } catch (n) {\n            et(i, n, a);\n          }\n        }) : (a.value = e, a.state = Mu, ku(a, !1));\n      } catch (i) {\n        et({\n          done: !1\n        }, i, a);\n      }\n    }\n  };\nif (Ru && (Le = function (e) {\n  jg(this, Qt), kg(e), it(Kt, this);\n  var t = Sa(this);\n  try {\n    e(Ze(ii, t), Ze(et, t));\n  } catch (r) {\n    et(t, r);\n  }\n}, Qt = Le.prototype, Kt = function (e) {\n  Xg(this, {\n    type: Ir,\n    done: !1,\n    notified: !1,\n    parent: !1,\n    reactions: new zg(),\n    rejection: !1,\n    state: vs,\n    value: null\n  });\n}, Kt.prototype = ls(Qt, \"then\", function (e, t) {\n  var r = Sa(this),\n    i = ai(Fg(this, Le));\n  return r.parent = !0, i.ok = lr(e) ? e : !0, i.fail = lr(t) && t, i.domain = pr ? Fi.domain : void 0, r.state === vs ? r.reactions.add(i) : Bi(function () {\n    Lu(i, r);\n  }), i.promise;\n}), fs = function () {\n  var a = new Kt(),\n    e = Sa(a);\n  this.promise = a, this.resolve = Ze(ii, e), this.reject = Ze(et, e);\n}, Pu.f = ai = function (a) {\n  return a === Le || a === Vu ? new fs(a) : Wg(a);\n}, lr(yr) && qe !== Object.prototype)) {\n  cs = qe.then, Yg || ls(qe, \"then\", function (e, t) {\n    var r = this;\n    return new Le(function (i, n) {\n      it(cs, r, i, n);\n    }).then(e, t);\n  }, {\n    unsafe: !0\n  });\n  try {\n    delete qe.constructor;\n  } catch {}\n  hs && hs(qe, Qt);\n}\n_g({\n  global: !0,\n  constructor: !0,\n  wrap: !0,\n  forced: Ru\n}, {\n  Promise: Le\n});\nVu = Vg.Promise;\nDg(Le, Ir, !1);\nLg(Ir);\nvar Rt = {},\n  ed = z,\n  td = Rt,\n  rd = ed(\"iterator\"),\n  ad = Array.prototype,\n  id = function (a) {\n    return a !== void 0 && (td.Array === a || ad[rd] === a);\n  },\n  nd = _i,\n  ds = st,\n  sd = xr,\n  od = Rt,\n  ud = z,\n  ld = ud(\"iterator\"),\n  ju = function (a) {\n    if (!sd(a)) return ds(a, ld) || ds(a, \"@@iterator\") || od[nd(a)];\n  },\n  hd = Y,\n  vd = Te,\n  fd = J,\n  cd = Or,\n  gd = ju,\n  dd = TypeError,\n  pd = function (a, e) {\n    var t = arguments.length < 2 ? gd(a) : e;\n    if (vd(t)) return fd(hd(t, a));\n    throw new dd(cd(a) + \" is not iterable\");\n  },\n  yd = Y,\n  ps = J,\n  md = st,\n  bd = function (a, e, t) {\n    var r, i;\n    ps(a);\n    try {\n      if (r = md(a, \"return\"), !r) {\n        if (e === \"throw\") throw t;\n        return t;\n      }\n      r = yd(r, a);\n    } catch (n) {\n      i = !0, r = n;\n    }\n    if (e === \"throw\") throw t;\n    if (i) throw r;\n    return ps(r), t;\n  },\n  xd = Di,\n  Td = Y,\n  Od = J,\n  Sd = Or,\n  Ed = id,\n  $d = Ii,\n  ys = Tr,\n  wd = pd,\n  Cd = ju,\n  ms = bd,\n  Ad = TypeError,\n  hr = function (a, e) {\n    this.stopped = a, this.result = e;\n  },\n  bs = hr.prototype,\n  Fu = function (a, e, t) {\n    var r = t && t.that,\n      i = !!(t && t.AS_ENTRIES),\n      n = !!(t && t.IS_RECORD),\n      o = !!(t && t.IS_ITERATOR),\n      s = !!(t && t.INTERRUPTED),\n      u = xd(e, r),\n      l,\n      h,\n      f,\n      c,\n      v,\n      g,\n      d,\n      p = function (x) {\n        return l && ms(l, \"normal\"), new hr(!0, x);\n      },\n      y = function (x) {\n        return i ? (Od(x), s ? u(x[0], x[1], p) : u(x[0], x[1])) : s ? u(x, p) : u(x);\n      };\n    if (n) l = a.iterator;else if (o) l = a;else {\n      if (h = Cd(a), !h) throw new Ad(Sd(a) + \" is not iterable\");\n      if (Ed(h)) {\n        for (f = 0, c = $d(a); c > f; f++) if (v = y(a[f]), v && ys(bs, v)) return v;\n        return new hr(!1);\n      }\n      l = wd(a, h);\n    }\n    for (g = n ? a.next : l.next; !(d = Td(g, l)).done;) {\n      try {\n        v = y(d.value);\n      } catch (x) {\n        ms(l, \"throw\", x);\n      }\n      if (typeof v == \"object\" && v && ys(bs, v)) return v;\n    }\n    return new hr(!1);\n  },\n  Pd = z,\n  Uu = Pd(\"iterator\"),\n  Gu = !1;\ntry {\n  var Rd = 0,\n    xs = {\n      next: function () {\n        return {\n          done: !!Rd++\n        };\n      },\n      return: function () {\n        Gu = !0;\n      }\n    };\n  xs[Uu] = function () {\n    return this;\n  }, Array.from(xs, function () {\n    throw 2;\n  });\n} catch {}\nvar Nd = function (a, e) {\n    try {\n      if (!e && !Gu) return !1;\n    } catch {\n      return !1;\n    }\n    var t = !1;\n    try {\n      var r = {};\n      r[Uu] = function () {\n        return {\n          next: function () {\n            return {\n              done: t = !0\n            };\n          }\n        };\n      }, a(r);\n    } catch {}\n    return t;\n  },\n  Id = Nr,\n  Md = Nd,\n  _d = Pt.CONSTRUCTOR,\n  zu = _d || !Md(function (a) {\n    Id.all(a).then(void 0, function () {});\n  }),\n  Vd = ee,\n  Dd = Y,\n  Ld = Te,\n  kd = ut,\n  Bd = ki,\n  jd = Fu,\n  Fd = zu;\nVd({\n  target: \"Promise\",\n  stat: !0,\n  forced: Fd\n}, {\n  all: function (e) {\n    var t = this,\n      r = kd.f(t),\n      i = r.resolve,\n      n = r.reject,\n      o = Bd(function () {\n        var s = Ld(t.resolve),\n          u = [],\n          l = 0,\n          h = 1;\n        jd(e, function (f) {\n          var c = l++,\n            v = !1;\n          h++, Dd(s, t, f).then(function (g) {\n            v || (v = !0, u[c] = g, --h || i(u));\n          }, n);\n        }), --h || i(u);\n      });\n    return o.error && n(o.value), r.promise;\n  }\n});\nvar Ud = ee,\n  Gd = Pt.CONSTRUCTOR,\n  ni = Nr,\n  zd = Fe,\n  Hd = B,\n  Yd = Ue,\n  Ts = ni && ni.prototype;\nUd({\n  target: \"Promise\",\n  proto: !0,\n  forced: Gd,\n  real: !0\n}, {\n  catch: function (a) {\n    return this.then(void 0, a);\n  }\n});\nif (Hd(ni)) {\n  var Os = zd(\"Promise\").prototype.catch;\n  Ts.catch !== Os && Yd(Ts, \"catch\", Os, {\n    unsafe: !0\n  });\n}\nvar Xd = ee,\n  Wd = Y,\n  qd = Te,\n  Qd = ut,\n  Kd = ki,\n  Zd = Fu,\n  Jd = zu;\nXd({\n  target: \"Promise\",\n  stat: !0,\n  forced: Jd\n}, {\n  race: function (e) {\n    var t = this,\n      r = Qd.f(t),\n      i = r.reject,\n      n = Kd(function () {\n        var o = qd(t.resolve);\n        Zd(e, function (s) {\n          Wd(o, t, s).then(r.resolve, i);\n        });\n      });\n    return n.error && i(n.value), r.promise;\n  }\n});\nvar ep = ee,\n  tp = ut,\n  rp = Pt.CONSTRUCTOR;\nep({\n  target: \"Promise\",\n  stat: !0,\n  forced: rp\n}, {\n  reject: function (e) {\n    var t = tp.f(this),\n      r = t.reject;\n    return r(e), t.promise;\n  }\n});\nvar ap = J,\n  ip = ae,\n  np = ut,\n  sp = function (a, e) {\n    if (ap(a), ip(e) && e.constructor === a) return e;\n    var t = np.f(a),\n      r = t.resolve;\n    return r(e), t.promise;\n  },\n  op = ee,\n  up = Fe,\n  lp = Pt.CONSTRUCTOR,\n  hp = sp;\nup(\"Promise\");\nop({\n  target: \"Promise\",\n  stat: !0,\n  forced: lp\n}, {\n  resolve: function (e) {\n    return hp(this, e);\n  }\n});\nfunction Ss(a, e, t, r, i, n, o) {\n  try {\n    var s = a[n](o),\n      u = s.value;\n  } catch (l) {\n    return void t(l);\n  }\n  s.done ? e(u) : Promise.resolve(u).then(r, i);\n}\nfunction xe(a) {\n  return function () {\n    var e = this,\n      t = arguments;\n    return new Promise(function (r, i) {\n      var n = a.apply(e, t);\n      function o(u) {\n        Ss(n, r, i, o, s, \"next\", u);\n      }\n      function s(u) {\n        Ss(n, r, i, o, s, \"throw\", u);\n      }\n      o(void 0);\n    });\n  };\n}\nvar vp = _i,\n  fp = String,\n  pe = function (a) {\n    if (vp(a) === \"Symbol\") throw new TypeError(\"Cannot convert a Symbol value to a string\");\n    return fp(a);\n  },\n  cp = J,\n  Hu = function () {\n    var a = cp(this),\n      e = \"\";\n    return a.hasIndices && (e += \"d\"), a.global && (e += \"g\"), a.ignoreCase && (e += \"i\"), a.multiline && (e += \"m\"), a.dotAll && (e += \"s\"), a.unicode && (e += \"u\"), a.unicodeSets && (e += \"v\"), a.sticky && (e += \"y\"), e;\n  },\n  Gi = D,\n  gp = _,\n  zi = gp.RegExp,\n  Hi = Gi(function () {\n    var a = zi(\"a\", \"y\");\n    return a.lastIndex = 2, a.exec(\"abcd\") !== null;\n  }),\n  dp = Hi || Gi(function () {\n    return !zi(\"a\", \"y\").sticky;\n  }),\n  pp = Hi || Gi(function () {\n    var a = zi(\"^r\", \"gy\");\n    return a.lastIndex = 2, a.exec(\"str\") !== null;\n  }),\n  Yu = {\n    BROKEN_CARET: pp,\n    MISSED_STICKY: dp,\n    UNSUPPORTED_Y: Hi\n  },\n  Xu = {},\n  yp = ou,\n  mp = Mi,\n  bp = Object.keys || function (e) {\n    return yp(e, mp);\n  },\n  xp = he,\n  Tp = Jo,\n  Op = Oe,\n  Sp = J,\n  Ep = $t,\n  $p = bp;\nXu.f = xp && !Tp ? Object.defineProperties : function (e, t) {\n  Sp(e);\n  for (var r = Ep(t), i = $p(t), n = i.length, o = 0, s; n > o;) Op.f(e, s = i[o++], r[s]);\n  return e;\n};\nvar wp = J,\n  Cp = Xu,\n  Es = Mi,\n  Ap = Ri,\n  Pp = xu,\n  Rp = Er,\n  Np = Pi,\n  $s = \">\",\n  ws = \"<\",\n  si = \"prototype\",\n  oi = \"script\",\n  Wu = Np(\"IE_PROTO\"),\n  Ea = function () {},\n  qu = function (a) {\n    return ws + oi + $s + a + ws + \"/\" + oi + $s;\n  },\n  Cs = function (a) {\n    a.write(qu(\"\")), a.close();\n    var e = a.parentWindow.Object;\n    return a = null, e;\n  },\n  Ip = function () {\n    var a = Rp(\"iframe\"),\n      e = \"java\" + oi + \":\",\n      t;\n    return a.style.display = \"none\", Pp.appendChild(a), a.src = String(e), t = a.contentWindow.document, t.open(), t.write(qu(\"document.F=Object\")), t.close(), t.F;\n  },\n  Zt,\n  vr = function () {\n    try {\n      Zt = new ActiveXObject(\"htmlfile\");\n    } catch {}\n    vr = typeof document < \"u\" ? document.domain && Zt ? Cs(Zt) : Ip() : Cs(Zt);\n    for (var a = Es.length; a--;) delete vr[si][Es[a]];\n    return vr();\n  };\nAp[Wu] = !0;\nvar Yi = Object.create || function (e, t) {\n    var r;\n    return e !== null ? (Ea[si] = wp(e), r = new Ea(), Ea[si] = null, r[Wu] = e) : r = vr(), t === void 0 ? r : Cp.f(r, t);\n  },\n  Mp = D,\n  _p = _,\n  Vp = _p.RegExp,\n  Dp = Mp(function () {\n    var a = Vp(\".\", \"s\");\n    return !(a.dotAll && a.test(`\n`) && a.flags === \"s\");\n  }),\n  Lp = D,\n  kp = _,\n  Bp = kp.RegExp,\n  jp = Lp(function () {\n    var a = Bp(\"(?<a>b)\", \"g\");\n    return a.exec(\"b\").groups.a !== \"b\" || \"b\".replace(a, \"$<a>c\") !== \"bc\";\n  }),\n  Je = Y,\n  Mr = L,\n  Fp = pe,\n  Up = Hu,\n  Gp = Yu,\n  zp = wi,\n  Hp = Yi,\n  Yp = wr.get,\n  Xp = Dp,\n  Wp = jp,\n  qp = zp(\"native-string-replace\", String.prototype.replace),\n  mr = RegExp.prototype.exec,\n  ui = mr,\n  Qp = Mr(\"\".charAt),\n  Kp = Mr(\"\".indexOf),\n  Zp = Mr(\"\".replace),\n  $a = Mr(\"\".slice),\n  li = function () {\n    var a = /a/,\n      e = /b*/g;\n    return Je(mr, a, \"a\"), Je(mr, e, \"a\"), a.lastIndex !== 0 || e.lastIndex !== 0;\n  }(),\n  Qu = Gp.BROKEN_CARET,\n  hi = /()??/.exec(\"\")[1] !== void 0,\n  Jp = li || hi || Qu || Xp || Wp;\nJp && (ui = function (e) {\n  var t = this,\n    r = Yp(t),\n    i = Fp(e),\n    n = r.raw,\n    o,\n    s,\n    u,\n    l,\n    h,\n    f,\n    c;\n  if (n) return n.lastIndex = t.lastIndex, o = Je(ui, n, i), t.lastIndex = n.lastIndex, o;\n  var v = r.groups,\n    g = Qu && t.sticky,\n    d = Je(Up, t),\n    p = t.source,\n    y = 0,\n    x = i;\n  if (g && (d = Zp(d, \"y\", \"\"), Kp(d, \"g\") === -1 && (d += \"g\"), x = $a(i, t.lastIndex), t.lastIndex > 0 && (!t.multiline || t.multiline && Qp(i, t.lastIndex - 1) !== `\n`) && (p = \"(?: \" + p + \")\", x = \" \" + x, y++), s = new RegExp(\"^(?:\" + p + \")\", d)), hi && (s = new RegExp(\"^\" + p + \"$(?!\\\\s)\", d)), li && (u = t.lastIndex), l = Je(mr, g ? s : t, x), g ? l ? (l.input = $a(l.input, y), l[0] = $a(l[0], y), l.index = t.lastIndex, t.lastIndex += l[0].length) : t.lastIndex = 0 : li && l && (t.lastIndex = t.global ? l.index + l[0].length : u), hi && l && l.length > 1 && Je(qp, l[0], s, function () {\n    for (h = 1; h < arguments.length - 2; h++) arguments[h] === void 0 && (l[h] = void 0);\n  }), l && v) for (l.groups = f = Hp(null), h = 0; h < v.length; h++) c = v[h], f[c[0]] = l[c[1]];\n  return l;\n});\nvar Xi = ui,\n  ey = ee,\n  As = Xi;\ney({\n  target: \"RegExp\",\n  proto: !0,\n  forced: /./.exec !== As\n}, {\n  exec: As\n});\nvar Ps = Y,\n  Rs = Ue,\n  ty = Xi,\n  Ns = D,\n  Ku = z,\n  ry = Ct,\n  ay = Ku(\"species\"),\n  wa = RegExp.prototype,\n  Wi = function (a, e, t, r) {\n    var i = Ku(a),\n      n = !Ns(function () {\n        var l = {};\n        return l[i] = function () {\n          return 7;\n        }, \"\"[a](l) !== 7;\n      }),\n      o = n && !Ns(function () {\n        var l = !1,\n          h = /a/;\n        return a === \"split\" && (h = {}, h.constructor = {}, h.constructor[ay] = function () {\n          return h;\n        }, h.flags = \"\", h[i] = /./[i]), h.exec = function () {\n          return l = !0, null;\n        }, h[i](\"\"), !l;\n      });\n    if (!n || !o || t) {\n      var s = /./[i],\n        u = e(i, \"\"[a], function (l, h, f, c, v) {\n          var g = h.exec;\n          return g === ty || g === wa.exec ? n && !v ? {\n            done: !0,\n            value: Ps(s, h, f, c)\n          } : {\n            done: !0,\n            value: Ps(l, f, h, c)\n          } : {\n            done: !1\n          };\n        });\n      Rs(String.prototype, a, u[0]), Rs(wa, i, u[1]);\n    }\n    r && ry(wa[i], \"sham\", !0);\n  },\n  qi = L,\n  iy = Cr,\n  ny = pe,\n  sy = ve,\n  oy = qi(\"\".charAt),\n  Is = qi(\"\".charCodeAt),\n  uy = qi(\"\".slice),\n  Ms = function (a) {\n    return function (e, t) {\n      var r = ny(sy(e)),\n        i = iy(t),\n        n = r.length,\n        o,\n        s;\n      return i < 0 || i >= n ? a ? \"\" : void 0 : (o = Is(r, i), o < 55296 || o > 56319 || i + 1 === n || (s = Is(r, i + 1)) < 56320 || s > 57343 ? a ? oy(r, i) : o : a ? uy(r, i, i + 2) : (o - 55296 << 10) + (s - 56320) + 65536);\n    };\n  },\n  ly = {\n    // `String.prototype.codePointAt` method\n    // https://tc39.es/ecma262/#sec-string.prototype.codepointat\n    codeAt: Ms(!1),\n    // `String.prototype.at` method\n    // https://github.com/mathiasbynens/String.prototype.at\n    charAt: Ms(!0)\n  },\n  hy = ly.charAt,\n  Qi = function (a, e, t) {\n    return e + (t ? hy(a, e).length : 1);\n  },\n  vy = _,\n  fy = D,\n  _s = vy.RegExp,\n  cy = !fy(function () {\n    var a = !0;\n    try {\n      _s(\".\", \"d\");\n    } catch {\n      a = !1;\n    }\n    var e = {},\n      t = \"\",\n      r = a ? \"dgimsy\" : \"gimsy\",\n      i = function (u, l) {\n        Object.defineProperty(e, u, {\n          get: function () {\n            return t += l, !0;\n          }\n        });\n      },\n      n = {\n        dotAll: \"s\",\n        global: \"g\",\n        ignoreCase: \"i\",\n        multiline: \"m\",\n        sticky: \"y\"\n      };\n    a && (n.hasIndices = \"d\");\n    for (var o in n) i(o, n[o]);\n    var s = Object.getOwnPropertyDescriptor(_s.prototype, \"flags\").get.call(e);\n    return s !== r || t !== r;\n  }),\n  gy = {\n    correct: cy\n  },\n  dy = Y,\n  py = fe,\n  yy = Tr,\n  Vs = gy,\n  my = Hu,\n  by = RegExp.prototype,\n  Ki = Vs.correct ? function (a) {\n    return a.flags;\n  } : function (a) {\n    return !Vs.correct && yy(by, a) && !py(a, \"flags\") ? dy(my, a) : a.flags;\n  },\n  Ds = Y,\n  xy = J,\n  Ty = B,\n  Oy = je,\n  Sy = Xi,\n  Ey = TypeError,\n  Zi = function (a, e) {\n    var t = a.exec;\n    if (Ty(t)) {\n      var r = Ds(t, a, e);\n      return r !== null && xy(r), r;\n    }\n    if (Oy(a) === \"RegExp\") return Ds(Sy, a, e);\n    throw new Ey(\"RegExp#exec called on incompatible receiver\");\n  },\n  $y = Y,\n  wy = L,\n  Cy = Wi,\n  Ay = J,\n  Py = ae,\n  Ry = ot,\n  Jt = pe,\n  Ny = ve,\n  Iy = st,\n  My = Qi,\n  _y = Ki,\n  Ls = Zi,\n  ks = wy(\"\".indexOf);\nCy(\"match\", function (a, e, t) {\n  return [\n  // `String.prototype.match` method\n  // https://tc39.es/ecma262/#sec-string.prototype.match\n  function (i) {\n    var n = Ny(this),\n      o = Py(i) ? Iy(i, a) : void 0;\n    return o ? $y(o, i, n) : new RegExp(i)[a](Jt(n));\n  },\n  // `RegExp.prototype[@@match]` method\n  // https://tc39.es/ecma262/#sec-regexp.prototype-@@match\n  function (r) {\n    var i = Ay(this),\n      n = Jt(r),\n      o = t(e, i, n);\n    if (o.done) return o.value;\n    var s = Jt(_y(i));\n    if (ks(s, \"g\") === -1) return Ls(i, n);\n    var u = ks(s, \"u\") !== -1;\n    i.lastIndex = 0;\n    for (var l = [], h = 0, f; (f = Ls(i, n)) !== null;) {\n      var c = Jt(f[0]);\n      l[h] = c, c === \"\" && (i.lastIndex = My(n, Ry(i.lastIndex), u)), h++;\n    }\n    return h === 0 ? null : l;\n  }];\n});\nvar Ji = L,\n  Vy = Sr,\n  Dy = Math.floor,\n  Ca = Ji(\"\".charAt),\n  Ly = Ji(\"\".replace),\n  Aa = Ji(\"\".slice),\n  ky = /\\$([$&'`]|\\d{1,2}|<[^>]*>)/g,\n  By = /\\$([$&'`]|\\d{1,2})/g,\n  jy = function (a, e, t, r, i, n) {\n    var o = t + a.length,\n      s = r.length,\n      u = By;\n    return i !== void 0 && (i = Vy(i), u = ky), Ly(n, u, function (l, h) {\n      var f;\n      switch (Ca(h, 0)) {\n        case \"$\":\n          return \"$\";\n        case \"&\":\n          return a;\n        case \"`\":\n          return Aa(e, 0, t);\n        case \"'\":\n          return Aa(e, o);\n        case \"<\":\n          f = i[Aa(h, 1, -1)];\n          break;\n        default:\n          var c = +h;\n          if (c === 0) return l;\n          if (c > s) {\n            var v = Dy(c / 10);\n            return v === 0 ? l : v <= s ? r[v - 1] === void 0 ? Ca(h, 1) : r[v - 1] + Ca(h, 1) : l;\n          }\n          f = r[c - 1];\n      }\n      return f === void 0 ? \"\" : f;\n    });\n  },\n  Fy = bu,\n  Bs = Y,\n  _r = L,\n  Uy = Wi,\n  Gy = D,\n  zy = J,\n  Hy = B,\n  Yy = ae,\n  Xy = Cr,\n  Wy = ot,\n  Me = pe,\n  qy = ve,\n  Qy = Qi,\n  Ky = st,\n  Zy = jy,\n  Jy = Ki,\n  em = Zi,\n  tm = z,\n  vi = tm(\"replace\"),\n  rm = Math.max,\n  am = Math.min,\n  im = _r([].concat),\n  Pa = _r([].push),\n  er = _r(\"\".indexOf),\n  js = _r(\"\".slice),\n  nm = function (a) {\n    return a === void 0 ? a : String(a);\n  },\n  sm = function () {\n    return \"a\".replace(/./, \"$0\") === \"$0\";\n  }(),\n  Fs = function () {\n    return /./[vi] ? /./[vi](\"a\", \"$0\") === \"\" : !1;\n  }(),\n  om = !Gy(function () {\n    var a = /./;\n    return a.exec = function () {\n      var e = [];\n      return e.groups = {\n        a: \"7\"\n      }, e;\n    }, \"\".replace(a, \"$<a>\") !== \"7\";\n  });\nUy(\"replace\", function (a, e, t) {\n  var r = Fs ? \"$\" : \"$0\";\n  return [\n  // `String.prototype.replace` method\n  // https://tc39.es/ecma262/#sec-string.prototype.replace\n  function (n, o) {\n    var s = qy(this),\n      u = Yy(n) ? Ky(n, vi) : void 0;\n    return u ? Bs(u, n, s, o) : Bs(e, Me(s), n, o);\n  },\n  // `RegExp.prototype[@@replace]` method\n  // https://tc39.es/ecma262/#sec-regexp.prototype-@@replace\n  function (i, n) {\n    var o = zy(this),\n      s = Me(i);\n    if (typeof n == \"string\" && er(n, r) === -1 && er(n, \"$<\") === -1) {\n      var u = t(e, o, s, n);\n      if (u.done) return u.value;\n    }\n    var l = Hy(n);\n    l || (n = Me(n));\n    var h = Me(Jy(o)),\n      f = er(h, \"g\") !== -1,\n      c;\n    f && (c = er(h, \"u\") !== -1, o.lastIndex = 0);\n    for (var v = [], g; g = em(o, s), !(g === null || (Pa(v, g), !f));) {\n      var d = Me(g[0]);\n      d === \"\" && (o.lastIndex = Qy(s, Wy(o.lastIndex), c));\n    }\n    for (var p = \"\", y = 0, x = 0; x < v.length; x++) {\n      g = v[x];\n      for (var b = Me(g[0]), T = rm(am(Xy(g.index), s.length), 0), $ = [], E, O = 1; O < g.length; O++) Pa($, nm(g[O]));\n      var C = g.groups;\n      if (l) {\n        var P = im([b], $, T, s);\n        C !== void 0 && Pa(P, C), E = Me(Fy(n, void 0, P));\n      } else E = Zy(b, s, T, $, C, n);\n      T >= y && (p += js(s, y, T) + E, y = T + b.length);\n    }\n    return p + js(s, y);\n  }];\n}, !om || !sm || Fs);\nvar um = ae,\n  lm = je,\n  hm = z,\n  vm = hm(\"match\"),\n  fm = function (a) {\n    var e;\n    return um(a) && ((e = a[vm]) !== void 0 ? !!e : lm(a) === \"RegExp\");\n  },\n  cm = fm,\n  gm = TypeError,\n  en = function (a) {\n    if (cm(a)) throw new gm(\"The method doesn't accept regular expressions\");\n    return a;\n  },\n  dm = z,\n  pm = dm(\"match\"),\n  tn = function (a) {\n    var e = /./;\n    try {\n      \"/./\"[a](e);\n    } catch {\n      try {\n        return e[pm] = !1, \"/./\"[a](e);\n      } catch {}\n    }\n    return !1;\n  },\n  ym = ee,\n  mm = Rr,\n  bm = Et.f,\n  xm = ot,\n  Us = pe,\n  Tm = en,\n  Om = ve,\n  Sm = tn,\n  Em = mm(\"\".slice),\n  $m = Math.min,\n  Zu = Sm(\"startsWith\"),\n  wm = !Zu && !!function () {\n    var a = bm(String.prototype, \"startsWith\");\n    return a && !a.writable;\n  }();\nym({\n  target: \"String\",\n  proto: !0,\n  forced: !wm && !Zu\n}, {\n  startsWith: function (e) {\n    var t = Us(Om(this));\n    Tm(e);\n    var r = xm($m(arguments.length > 1 ? arguments[1] : void 0, t.length)),\n      i = Us(e);\n    return Em(t, r, r + i.length) === i;\n  }\n});\nvar Cm = z,\n  Am = Yi,\n  Pm = Oe.f,\n  fi = Cm(\"unscopables\"),\n  ci = Array.prototype;\nci[fi] === void 0 && Pm(ci, fi, {\n  configurable: !0,\n  value: Am(null)\n});\nvar Rm = function (a) {\n    ci[fi][a] = !0;\n  },\n  Nm = D,\n  Im = !Nm(function () {\n    function a() {}\n    return a.prototype.constructor = null, Object.getPrototypeOf(new a()) !== a.prototype;\n  }),\n  Mm = fe,\n  _m = B,\n  Vm = Sr,\n  Dm = Pi,\n  Lm = Im,\n  Gs = Dm(\"IE_PROTO\"),\n  gi = Object,\n  km = gi.prototype,\n  Ju = Lm ? gi.getPrototypeOf : function (a) {\n    var e = Vm(a);\n    if (Mm(e, Gs)) return e[Gs];\n    var t = e.constructor;\n    return _m(t) && e instanceof t ? t.prototype : e instanceof gi ? km : null;\n  },\n  Bm = D,\n  jm = B,\n  Fm = ae,\n  zs = Ju,\n  Um = Ue,\n  Gm = z,\n  di = Gm(\"iterator\"),\n  el = !1,\n  ke,\n  Ra,\n  Na;\n[].keys && (Na = [].keys(), \"next\" in Na ? (Ra = zs(zs(Na)), Ra !== Object.prototype && (ke = Ra)) : el = !0);\nvar zm = !Fm(ke) || Bm(function () {\n  var a = {};\n  return ke[di].call(a) !== a;\n});\nzm && (ke = {});\njm(ke[di]) || Um(ke, di, function () {\n  return this;\n});\nvar tl = {\n    IteratorPrototype: ke,\n    BUGGY_SAFARI_ITERATORS: el\n  },\n  Hm = tl.IteratorPrototype,\n  Ym = Yi,\n  Xm = Oi,\n  Wm = Pr,\n  qm = Rt,\n  Qm = function () {\n    return this;\n  },\n  Km = function (a, e, t, r) {\n    var i = e + \" Iterator\";\n    return a.prototype = Ym(Hm, {\n      next: Xm(+!r, t)\n    }), Wm(a, i, !1), qm[i] = Qm, a;\n  },\n  Zm = ee,\n  Jm = Y,\n  rl = $r,\n  e0 = B,\n  t0 = Km,\n  Hs = Ju,\n  Ys = vu,\n  r0 = Pr,\n  a0 = Ct,\n  Ia = Ue,\n  i0 = z,\n  n0 = Rt,\n  al = tl,\n  s0 = rl.PROPER,\n  o0 = rl.CONFIGURABLE,\n  Xs = al.IteratorPrototype,\n  tr = al.BUGGY_SAFARI_ITERATORS,\n  ct = i0(\"iterator\"),\n  Ws = \"keys\",\n  gt = \"values\",\n  qs = \"entries\",\n  u0 = function () {\n    return this;\n  },\n  l0 = function (a, e, t, r, i, n, o) {\n    t0(t, e, r);\n    var s = function (y) {\n        if (y === i && c) return c;\n        if (!tr && y && y in h) return h[y];\n        switch (y) {\n          case Ws:\n            return function () {\n              return new t(this, y);\n            };\n          case gt:\n            return function () {\n              return new t(this, y);\n            };\n          case qs:\n            return function () {\n              return new t(this, y);\n            };\n        }\n        return function () {\n          return new t(this);\n        };\n      },\n      u = e + \" Iterator\",\n      l = !1,\n      h = a.prototype,\n      f = h[ct] || h[\"@@iterator\"] || i && h[i],\n      c = !tr && f || s(i),\n      v = e === \"Array\" && h.entries || f,\n      g,\n      d,\n      p;\n    if (v && (g = Hs(v.call(new a())), g !== Object.prototype && g.next && (Hs(g) !== Xs && (Ys ? Ys(g, Xs) : e0(g[ct]) || Ia(g, ct, u0)), r0(g, u, !0))), s0 && i === gt && f && f.name !== gt && (o0 ? a0(h, \"name\", gt) : (l = !0, c = function () {\n      return Jm(f, this);\n    })), i) if (d = {\n      values: s(gt),\n      keys: n ? c : s(Ws),\n      entries: s(qs)\n    }, o) for (p in d) (tr || l || !(p in h)) && Ia(h, p, d[p]);else Zm({\n      target: e,\n      proto: !0,\n      forced: tr || l\n    }, d);\n    return h[ct] !== c && Ia(h, ct, c, {\n      name: i\n    }), n0[e] = c, d;\n  },\n  h0 = function (a, e) {\n    return {\n      value: a,\n      done: e\n    };\n  },\n  v0 = $t,\n  rn = Rm,\n  Qs = Rt,\n  il = wr,\n  f0 = Oe.f,\n  c0 = l0,\n  rr = h0,\n  g0 = he,\n  nl = \"Array Iterator\",\n  d0 = il.set,\n  p0 = il.getterFor(nl),\n  y0 = c0(Array, \"Array\", function (a, e) {\n    d0(this, {\n      type: nl,\n      target: v0(a),\n      // target\n      index: 0,\n      // next index\n      kind: e\n      // kind\n    });\n  }, function () {\n    var a = p0(this),\n      e = a.target,\n      t = a.index++;\n    if (!e || t >= e.length) return a.target = null, rr(void 0, !0);\n    switch (a.kind) {\n      case \"keys\":\n        return rr(t, !1);\n      case \"values\":\n        return rr(e[t], !1);\n    }\n    return rr([t, e[t]], !1);\n  }, \"values\"),\n  Ks = Qs.Arguments = Qs.Array;\nrn(\"keys\");\nrn(\"values\");\nrn(\"entries\");\nif (g0 && Ks.name !== \"values\") try {\n  f0(Ks, \"name\", {\n    value: \"values\"\n  });\n} catch {}\nvar m0 = {\n    CSSRuleList: 0,\n    CSSStyleDeclaration: 0,\n    CSSValueList: 0,\n    ClientRectList: 0,\n    DOMRectList: 0,\n    DOMStringList: 0,\n    DOMTokenList: 1,\n    DataTransferItemList: 0,\n    FileList: 0,\n    HTMLAllCollection: 0,\n    HTMLCollection: 0,\n    HTMLFormElement: 0,\n    HTMLSelectElement: 0,\n    MediaList: 0,\n    MimeTypeArray: 0,\n    NamedNodeMap: 0,\n    NodeList: 1,\n    PaintRequestList: 0,\n    Plugin: 0,\n    PluginArray: 0,\n    SVGLengthList: 0,\n    SVGNumberList: 0,\n    SVGPathSegList: 0,\n    SVGPointList: 0,\n    SVGStringList: 0,\n    SVGTransformList: 0,\n    SourceBufferList: 0,\n    StyleSheetList: 0,\n    TextTrackCueList: 0,\n    TextTrackList: 0,\n    TouchList: 0\n  },\n  b0 = Er,\n  Ma = b0(\"span\").classList,\n  Zs = Ma && Ma.constructor && Ma.constructor.prototype,\n  x0 = Zs === Object.prototype ? void 0 : Zs,\n  Js = _,\n  sl = m0,\n  T0 = x0,\n  pt = y0,\n  eo = Ct,\n  O0 = Pr,\n  S0 = z,\n  _a = S0(\"iterator\"),\n  Va = pt.values,\n  ol = function (a, e) {\n    if (a) {\n      if (a[_a] !== Va) try {\n        eo(a, _a, Va);\n      } catch {\n        a[_a] = Va;\n      }\n      if (O0(a, e, !0), sl[e]) {\n        for (var t in pt) if (a[t] !== pt[t]) try {\n          eo(a, t, pt[t]);\n        } catch {\n          a[t] = pt[t];\n        }\n      }\n    }\n  };\nfor (var Da in sl) ol(Js[Da] && Js[Da].prototype, Da);\nol(T0, \"DOMTokenList\");\nfunction E0(a, e) {\n  if (Ha(a) != \"object\" || !a) return a;\n  var t = a[Symbol.toPrimitive];\n  if (t !== void 0) {\n    var r = t.call(a, e || \"default\");\n    if (Ha(r) != \"object\") return r;\n    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n  }\n  return (e === \"string\" ? String : Number)(a);\n}\nfunction $0(a) {\n  var e = E0(a, \"string\");\n  return Ha(e) == \"symbol\" ? e : e + \"\";\n}\nfunction an(a, e, t) {\n  return (e = $0(e)) in a ? Object.defineProperty(a, e, {\n    value: t,\n    enumerable: !0,\n    configurable: !0,\n    writable: !0\n  }) : a[e] = t, a;\n}\nvar w0 = Te,\n  C0 = Sr,\n  A0 = zo,\n  P0 = Ii,\n  to = TypeError,\n  ro = \"Reduce of empty array with no initial value\",\n  ao = function (a) {\n    return function (e, t, r, i) {\n      var n = C0(e),\n        o = A0(n),\n        s = P0(n);\n      if (w0(t), s === 0 && r < 2) throw new to(ro);\n      var u = a ? s - 1 : 0,\n        l = a ? -1 : 1;\n      if (r < 2) for (;;) {\n        if (u in o) {\n          i = o[u], u += l;\n          break;\n        }\n        if (u += l, a ? u < 0 : s <= u) throw new to(ro);\n      }\n      for (; a ? u >= 0 : s > u; u += l) u in o && (i = t(i, o[u], u, n));\n      return i;\n    };\n  },\n  R0 = {\n    // `Array.prototype.reduce` method\n    // https://tc39.es/ecma262/#sec-array.prototype.reduce\n    left: ao(!1),\n    // `Array.prototype.reduceRight` method\n    // https://tc39.es/ecma262/#sec-array.prototype.reduceright\n    right: ao(!0)\n  },\n  N0 = D,\n  ul = function (a, e) {\n    var t = [][a];\n    return !!t && N0(function () {\n      t.call(null, e || function () {\n        return 1;\n      }, 1);\n    });\n  },\n  I0 = ee,\n  M0 = R0.left,\n  _0 = ul,\n  io = Si,\n  V0 = Ar,\n  D0 = !V0 && io > 79 && io < 83,\n  L0 = D0 || !_0(\"reduce\");\nI0({\n  target: \"Array\",\n  proto: !0,\n  forced: L0\n}, {\n  reduce: function (e) {\n    var t = arguments.length;\n    return M0(this, e, t, t > 1 ? arguments[1] : void 0);\n  }\n});\nvar k0 = ee,\n  B0 = Rr,\n  j0 = Et.f,\n  F0 = ot,\n  no = pe,\n  U0 = en,\n  G0 = ve,\n  z0 = tn,\n  H0 = B0(\"\".slice),\n  Y0 = Math.min,\n  ll = z0(\"endsWith\"),\n  X0 = !ll && !!function () {\n    var a = j0(String.prototype, \"endsWith\");\n    return a && !a.writable;\n  }();\nk0({\n  target: \"String\",\n  proto: !0,\n  forced: !X0 && !ll\n}, {\n  endsWith: function (e) {\n    var t = no(G0(this));\n    U0(e);\n    var r = arguments.length > 1 ? arguments[1] : void 0,\n      i = t.length,\n      n = r === void 0 ? i : Y0(F0(r), i),\n      o = no(e);\n    return H0(t, n - o.length, n) === o;\n  }\n});\nvar La = Y,\n  hl = L,\n  W0 = Wi,\n  q0 = J,\n  Q0 = ae,\n  K0 = ve,\n  Z0 = yu,\n  J0 = Qi,\n  eb = ot,\n  so = pe,\n  tb = st,\n  oo = Zi,\n  rb = Yu,\n  ab = D,\n  We = rb.UNSUPPORTED_Y,\n  ib = 4294967295,\n  nb = Math.min,\n  ka = hl([].push),\n  Ba = hl(\"\".slice),\n  sb = !ab(function () {\n    var a = /(?:)/,\n      e = a.exec;\n    a.exec = function () {\n      return e.apply(this, arguments);\n    };\n    var t = \"ab\".split(a);\n    return t.length !== 2 || t[0] !== \"a\" || t[1] !== \"b\";\n  }),\n  uo = \"abbc\".split(/(b)*/)[1] === \"c\" ||\n  // eslint-disable-next-line regexp/no-empty-group -- required for testing\n  \"test\".split(/(?:)/, -1).length !== 4 || \"ab\".split(/(?:ab)*/).length !== 2 || \".\".split(/(.?)(.?)/).length !== 4 ||\n  // eslint-disable-next-line regexp/no-empty-capturing-group, regexp/no-empty-group -- required for testing\n  \".\".split(/()()/).length > 1 || \"\".split(/.?/).length;\nW0(\"split\", function (a, e, t) {\n  var r = \"0\".split(void 0, 0).length ? function (i, n) {\n    return i === void 0 && n === 0 ? [] : La(e, this, i, n);\n  } : e;\n  return [\n  // `String.prototype.split` method\n  // https://tc39.es/ecma262/#sec-string.prototype.split\n  function (n, o) {\n    var s = K0(this),\n      u = Q0(n) ? tb(n, a) : void 0;\n    return u ? La(u, n, s, o) : La(r, so(s), n, o);\n  },\n  // `RegExp.prototype[@@split]` method\n  // https://tc39.es/ecma262/#sec-regexp.prototype-@@split\n  //\n  // NOTE: This cannot be properly polyfilled in engines that don't support\n  // the 'y' flag.\n  function (i, n) {\n    var o = q0(this),\n      s = so(i);\n    if (!uo) {\n      var u = t(r, o, s, n, r !== e);\n      if (u.done) return u.value;\n    }\n    var l = Z0(o, RegExp),\n      h = o.unicode,\n      f = (o.ignoreCase ? \"i\" : \"\") + (o.multiline ? \"m\" : \"\") + (o.unicode ? \"u\" : \"\") + (We ? \"g\" : \"y\"),\n      c = new l(We ? \"^(?:\" + o.source + \")\" : o, f),\n      v = n === void 0 ? ib : n >>> 0;\n    if (v === 0) return [];\n    if (s.length === 0) return oo(c, s) === null ? [s] : [];\n    for (var g = 0, d = 0, p = []; d < s.length;) {\n      c.lastIndex = We ? 0 : d;\n      var y = oo(c, We ? Ba(s, d) : s),\n        x;\n      if (y === null || (x = nb(eb(c.lastIndex + (We ? d : 0)), s.length)) === g) d = J0(s, d, h);else {\n        if (ka(p, Ba(s, g, d)), p.length === v) return p;\n        for (var b = 1; b <= y.length - 1; b++) if (ka(p, y[b]), p.length === v) return p;\n        d = g = x;\n      }\n    }\n    return ka(p, Ba(s, g)), p;\n  }];\n}, uo || !sb, We);\nvar Vr = {\n    exports: {}\n  },\n  yt = {\n    exports: {}\n  };\n(function () {\n  var a, e, t, r, i, n;\n  typeof performance < \"u\" && performance !== null && performance.now ? yt.exports = function () {\n    return performance.now();\n  } : typeof process < \"u\" && process !== null && process.hrtime ? (yt.exports = function () {\n    return (a() - i) / 1e6;\n  }, e = process.hrtime, a = function () {\n    var o;\n    return o = e(), o[0] * 1e9 + o[1];\n  }, r = a(), n = process.uptime() * 1e9, i = r - n) : Date.now ? (yt.exports = function () {\n    return Date.now() - t;\n  }, t = Date.now()) : (yt.exports = function () {\n    return ( /* @__PURE__ */new Date()).getTime() - t;\n  }, t = ( /* @__PURE__ */new Date()).getTime());\n}).call(Qe);\nvar ob = yt.exports,\n  ub = ob,\n  be = typeof window > \"u\" ? Qe : window,\n  ar = [\"moz\", \"webkit\"],\n  tt = \"AnimationFrame\",\n  nt = be[\"request\" + tt],\n  St = be[\"cancel\" + tt] || be[\"cancelRequest\" + tt];\nfor (var dt = 0; !nt && dt < ar.length; dt++) nt = be[ar[dt] + \"Request\" + tt], St = be[ar[dt] + \"Cancel\" + tt] || be[ar[dt] + \"CancelRequest\" + tt];\nif (!nt || !St) {\n  var ja = 0,\n    lo = 0,\n    _e = [],\n    lb = 1e3 / 60;\n  nt = function (a) {\n    if (_e.length === 0) {\n      var e = ub(),\n        t = Math.max(0, lb - (e - ja));\n      ja = t + e, setTimeout(function () {\n        var r = _e.slice(0);\n        _e.length = 0;\n        for (var i = 0; i < r.length; i++) if (!r[i].cancelled) try {\n          r[i].callback(ja);\n        } catch (n) {\n          setTimeout(function () {\n            throw n;\n          }, 0);\n        }\n      }, Math.round(t));\n    }\n    return _e.push({\n      handle: ++lo,\n      callback: a,\n      cancelled: !1\n    }), lo;\n  }, St = function (a) {\n    for (var e = 0; e < _e.length; e++) _e[e].handle === a && (_e[e].cancelled = !0);\n  };\n}\nVr.exports = function (a) {\n  return nt.call(be, a);\n};\nVr.exports.cancel = function () {\n  St.apply(be, arguments);\n};\nVr.exports.polyfill = function (a) {\n  a || (a = be), a.requestAnimationFrame = nt, a.cancelAnimationFrame = St;\n};\nvar hb = Vr.exports;\nconst Fa = /* @__PURE__ */Lo(hb);\nvar vl = `\t\n\\v\\f\\r Â áââââââââââââ¯âã\\u2028\\u2029\\uFEFF`,\n  vb = L,\n  fb = ve,\n  cb = pe,\n  pi = vl,\n  ho = vb(\"\".replace),\n  gb = RegExp(\"^[\" + pi + \"]+\"),\n  db = RegExp(\"(^|[^\" + pi + \"])[\" + pi + \"]+$\"),\n  Ua = function (a) {\n    return function (e) {\n      var t = cb(fb(e));\n      return a & 1 && (t = ho(t, gb, \"\")), a & 2 && (t = ho(t, db, \"$1\")), t;\n    };\n  },\n  pb = {\n    // `String.prototype.{ trimLeft, trimStart }` methods\n    // https://tc39.es/ecma262/#sec-string.prototype.trimstart\n    start: Ua(1),\n    // `String.prototype.{ trimRight, trimEnd }` methods\n    // https://tc39.es/ecma262/#sec-string.prototype.trimend\n    end: Ua(2),\n    // `String.prototype.trim` method\n    // https://tc39.es/ecma262/#sec-string.prototype.trim\n    trim: Ua(3)\n  },\n  yb = $r.PROPER,\n  mb = D,\n  vo = vl,\n  fo = \"âÂá \",\n  bb = function (a) {\n    return mb(function () {\n      return !!vo[a]() || fo[a]() !== fo || yb && vo[a].name !== a;\n    });\n  },\n  xb = ee,\n  Tb = pb.trim,\n  Ob = bb;\nxb({\n  target: \"String\",\n  proto: !0,\n  forced: Ob(\"trim\")\n}, {\n  trim: function () {\n    return Tb(this);\n  }\n});\nvar Sb = function (a) {\n  this.ok = !1, this.alpha = 1, a.charAt(0) == \"#\" && (a = a.substr(1, 6)), a = a.replace(/ /g, \"\"), a = a.toLowerCase();\n  var e = {\n    aliceblue: \"f0f8ff\",\n    antiquewhite: \"faebd7\",\n    aqua: \"00ffff\",\n    aquamarine: \"7fffd4\",\n    azure: \"f0ffff\",\n    beige: \"f5f5dc\",\n    bisque: \"ffe4c4\",\n    black: \"000000\",\n    blanchedalmond: \"ffebcd\",\n    blue: \"0000ff\",\n    blueviolet: \"8a2be2\",\n    brown: \"a52a2a\",\n    burlywood: \"deb887\",\n    cadetblue: \"5f9ea0\",\n    chartreuse: \"7fff00\",\n    chocolate: \"d2691e\",\n    coral: \"ff7f50\",\n    cornflowerblue: \"6495ed\",\n    cornsilk: \"fff8dc\",\n    crimson: \"dc143c\",\n    cyan: \"00ffff\",\n    darkblue: \"00008b\",\n    darkcyan: \"008b8b\",\n    darkgoldenrod: \"b8860b\",\n    darkgray: \"a9a9a9\",\n    darkgreen: \"006400\",\n    darkkhaki: \"bdb76b\",\n    darkmagenta: \"8b008b\",\n    darkolivegreen: \"556b2f\",\n    darkorange: \"ff8c00\",\n    darkorchid: \"9932cc\",\n    darkred: \"8b0000\",\n    darksalmon: \"e9967a\",\n    darkseagreen: \"8fbc8f\",\n    darkslateblue: \"483d8b\",\n    darkslategray: \"2f4f4f\",\n    darkturquoise: \"00ced1\",\n    darkviolet: \"9400d3\",\n    deeppink: \"ff1493\",\n    deepskyblue: \"00bfff\",\n    dimgray: \"696969\",\n    dodgerblue: \"1e90ff\",\n    feldspar: \"d19275\",\n    firebrick: \"b22222\",\n    floralwhite: \"fffaf0\",\n    forestgreen: \"228b22\",\n    fuchsia: \"ff00ff\",\n    gainsboro: \"dcdcdc\",\n    ghostwhite: \"f8f8ff\",\n    gold: \"ffd700\",\n    goldenrod: \"daa520\",\n    gray: \"808080\",\n    green: \"008000\",\n    greenyellow: \"adff2f\",\n    honeydew: \"f0fff0\",\n    hotpink: \"ff69b4\",\n    indianred: \"cd5c5c\",\n    indigo: \"4b0082\",\n    ivory: \"fffff0\",\n    khaki: \"f0e68c\",\n    lavender: \"e6e6fa\",\n    lavenderblush: \"fff0f5\",\n    lawngreen: \"7cfc00\",\n    lemonchiffon: \"fffacd\",\n    lightblue: \"add8e6\",\n    lightcoral: \"f08080\",\n    lightcyan: \"e0ffff\",\n    lightgoldenrodyellow: \"fafad2\",\n    lightgrey: \"d3d3d3\",\n    lightgreen: \"90ee90\",\n    lightpink: \"ffb6c1\",\n    lightsalmon: \"ffa07a\",\n    lightseagreen: \"20b2aa\",\n    lightskyblue: \"87cefa\",\n    lightslateblue: \"8470ff\",\n    lightslategray: \"778899\",\n    lightsteelblue: \"b0c4de\",\n    lightyellow: \"ffffe0\",\n    lime: \"00ff00\",\n    limegreen: \"32cd32\",\n    linen: \"faf0e6\",\n    magenta: \"ff00ff\",\n    maroon: \"800000\",\n    mediumaquamarine: \"66cdaa\",\n    mediumblue: \"0000cd\",\n    mediumorchid: \"ba55d3\",\n    mediumpurple: \"9370d8\",\n    mediumseagreen: \"3cb371\",\n    mediumslateblue: \"7b68ee\",\n    mediumspringgreen: \"00fa9a\",\n    mediumturquoise: \"48d1cc\",\n    mediumvioletred: \"c71585\",\n    midnightblue: \"191970\",\n    mintcream: \"f5fffa\",\n    mistyrose: \"ffe4e1\",\n    moccasin: \"ffe4b5\",\n    navajowhite: \"ffdead\",\n    navy: \"000080\",\n    oldlace: \"fdf5e6\",\n    olive: \"808000\",\n    olivedrab: \"6b8e23\",\n    orange: \"ffa500\",\n    orangered: \"ff4500\",\n    orchid: \"da70d6\",\n    palegoldenrod: \"eee8aa\",\n    palegreen: \"98fb98\",\n    paleturquoise: \"afeeee\",\n    palevioletred: \"d87093\",\n    papayawhip: \"ffefd5\",\n    peachpuff: \"ffdab9\",\n    peru: \"cd853f\",\n    pink: \"ffc0cb\",\n    plum: \"dda0dd\",\n    powderblue: \"b0e0e6\",\n    purple: \"800080\",\n    rebeccapurple: \"663399\",\n    red: \"ff0000\",\n    rosybrown: \"bc8f8f\",\n    royalblue: \"4169e1\",\n    saddlebrown: \"8b4513\",\n    salmon: \"fa8072\",\n    sandybrown: \"f4a460\",\n    seagreen: \"2e8b57\",\n    seashell: \"fff5ee\",\n    sienna: \"a0522d\",\n    silver: \"c0c0c0\",\n    skyblue: \"87ceeb\",\n    slateblue: \"6a5acd\",\n    slategray: \"708090\",\n    snow: \"fffafa\",\n    springgreen: \"00ff7f\",\n    steelblue: \"4682b4\",\n    tan: \"d2b48c\",\n    teal: \"008080\",\n    thistle: \"d8bfd8\",\n    tomato: \"ff6347\",\n    turquoise: \"40e0d0\",\n    violet: \"ee82ee\",\n    violetred: \"d02090\",\n    wheat: \"f5deb3\",\n    white: \"ffffff\",\n    whitesmoke: \"f5f5f5\",\n    yellow: \"ffff00\",\n    yellowgreen: \"9acd32\"\n  };\n  a = e[a] || a;\n  for (var t = [{\n      re: /^rgba\\((\\d{1,3}),\\s*(\\d{1,3}),\\s*(\\d{1,3}),\\s*((?:\\d?\\.)?\\d)\\)$/,\n      example: [\"rgba(123, 234, 45, 0.8)\", \"rgba(255,234,245,1.0)\"],\n      process: function (u) {\n        return [parseInt(u[1]), parseInt(u[2]), parseInt(u[3]), parseFloat(u[4])];\n      }\n    }, {\n      re: /^rgb\\((\\d{1,3}),\\s*(\\d{1,3}),\\s*(\\d{1,3})\\)$/,\n      example: [\"rgb(123, 234, 45)\", \"rgb(255,234,245)\"],\n      process: function (u) {\n        return [parseInt(u[1]), parseInt(u[2]), parseInt(u[3])];\n      }\n    }, {\n      re: /^([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/,\n      example: [\"#00ff00\", \"336699\"],\n      process: function (u) {\n        return [parseInt(u[1], 16), parseInt(u[2], 16), parseInt(u[3], 16)];\n      }\n    }, {\n      re: /^([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,\n      example: [\"#fb0\", \"f0f\"],\n      process: function (u) {\n        return [parseInt(u[1] + u[1], 16), parseInt(u[2] + u[2], 16), parseInt(u[3] + u[3], 16)];\n      }\n    }], r = 0; r < t.length; r++) {\n    var i = t[r].re,\n      n = t[r].process,\n      o = i.exec(a);\n    if (o) {\n      var s = n(o);\n      this.r = s[0], this.g = s[1], this.b = s[2], s.length > 3 && (this.alpha = s[3]), this.ok = !0;\n    }\n  }\n  this.r = this.r < 0 || isNaN(this.r) ? 0 : this.r > 255 ? 255 : this.r, this.g = this.g < 0 || isNaN(this.g) ? 0 : this.g > 255 ? 255 : this.g, this.b = this.b < 0 || isNaN(this.b) ? 0 : this.b > 255 ? 255 : this.b, this.alpha = this.alpha < 0 ? 0 : this.alpha > 1 || isNaN(this.alpha) ? 1 : this.alpha, this.toRGB = function () {\n    return \"rgb(\" + this.r + \", \" + this.g + \", \" + this.b + \")\";\n  }, this.toRGBA = function () {\n    return \"rgba(\" + this.r + \", \" + this.g + \", \" + this.b + \", \" + this.alpha + \")\";\n  }, this.toHex = function () {\n    var u = this.r.toString(16),\n      l = this.g.toString(16),\n      h = this.b.toString(16);\n    return u.length == 1 && (u = \"0\" + u), l.length == 1 && (l = \"0\" + l), h.length == 1 && (h = \"0\" + h), \"#\" + u + l + h;\n  }, this.getHelpXML = function () {\n    for (var u = new Array(), l = 0; l < t.length; l++) for (var h = t[l].example, f = 0; f < h.length; f++) u[u.length] = h[f];\n    for (var c in e) u[u.length] = c;\n    var v = document.createElement(\"ul\");\n    v.setAttribute(\"id\", \"rgbcolor-examples\");\n    for (var l = 0; l < u.length; l++) try {\n      var g = document.createElement(\"li\"),\n        d = new RGBColor(u[l]),\n        p = document.createElement(\"div\");\n      p.style.cssText = \"margin: 3px; border: 1px solid black; background:\" + d.toHex() + \"; color:\" + d.toHex(), p.appendChild(document.createTextNode(\"test\"));\n      var y = document.createTextNode(\" \" + u[l] + \" -> \" + d.toRGB() + \" -> \" + d.toHex());\n      g.appendChild(p), g.appendChild(y), v.appendChild(g);\n    } catch {}\n    return v;\n  };\n};\nconst yi = /* @__PURE__ */Lo(Sb);\nvar Eb = ee,\n  $b = Rr,\n  wb = su.indexOf,\n  Cb = ul,\n  mi = $b([].indexOf),\n  fl = !!mi && 1 / mi([1], 1, -0) < 0,\n  Ab = fl || !Cb(\"indexOf\");\nEb({\n  target: \"Array\",\n  proto: !0,\n  forced: Ab\n}, {\n  indexOf: function (e) {\n    var t = arguments.length > 1 ? arguments[1] : void 0;\n    return fl ? mi(this, e, t) || 0 : wb(this, e, t);\n  }\n});\nvar Pb = ee,\n  Rb = L,\n  Nb = en,\n  Ib = ve,\n  co = pe,\n  Mb = tn,\n  _b = Rb(\"\".indexOf);\nPb({\n  target: \"String\",\n  proto: !0,\n  forced: !Mb(\"includes\")\n}, {\n  includes: function (e) {\n    return !!~_b(co(Ib(this)), co(Nb(e)), arguments.length > 1 ? arguments[1] : void 0);\n  }\n});\nvar Vb = je,\n  Db = Array.isArray || function (e) {\n    return Vb(e) === \"Array\";\n  },\n  Lb = ee,\n  kb = L,\n  Bb = Db,\n  jb = kb([].reverse),\n  go = [1, 2];\nLb({\n  target: \"Array\",\n  proto: !0,\n  forced: String(go) === String(go.reverse())\n}, {\n  reverse: function () {\n    return Bb(this) && (this.length = this.length), jb(this);\n  }\n});\n/*! *****************************************************************************\nCopyright (c) Microsoft Corporation.\n\nPermission to use, copy, modify, and/or distribute this software for any\npurpose with or without fee is hereby granted.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\nPERFORMANCE OF THIS SOFTWARE.\n***************************************************************************** */\nvar cl = function (a, e) {\n  return (cl = Object.setPrototypeOf || {\n    __proto__: []\n  } instanceof Array && function (t, r) {\n    t.__proto__ = r;\n  } || function (t, r) {\n    for (var i in r) Object.prototype.hasOwnProperty.call(r, i) && (t[i] = r[i]);\n  })(a, e);\n};\nfunction gl(a, e) {\n  if (typeof e != \"function\" && e !== null) throw new TypeError(\"Class extends value \" + String(e) + \" is not a constructor or null\");\n  function t() {\n    this.constructor = a;\n  }\n  cl(a, e), a.prototype = e === null ? Object.create(e) : (t.prototype = e.prototype, new t());\n}\nfunction Fb(a) {\n  var e = \"\";\n  Array.isArray(a) || (a = [a]);\n  for (var t = 0; t < a.length; t++) {\n    var r = a[t];\n    if (r.type === m.CLOSE_PATH) e += \"z\";else if (r.type === m.HORIZ_LINE_TO) e += (r.relative ? \"h\" : \"H\") + r.x;else if (r.type === m.VERT_LINE_TO) e += (r.relative ? \"v\" : \"V\") + r.y;else if (r.type === m.MOVE_TO) e += (r.relative ? \"m\" : \"M\") + r.x + \" \" + r.y;else if (r.type === m.LINE_TO) e += (r.relative ? \"l\" : \"L\") + r.x + \" \" + r.y;else if (r.type === m.CURVE_TO) e += (r.relative ? \"c\" : \"C\") + r.x1 + \" \" + r.y1 + \" \" + r.x2 + \" \" + r.y2 + \" \" + r.x + \" \" + r.y;else if (r.type === m.SMOOTH_CURVE_TO) e += (r.relative ? \"s\" : \"S\") + r.x2 + \" \" + r.y2 + \" \" + r.x + \" \" + r.y;else if (r.type === m.QUAD_TO) e += (r.relative ? \"q\" : \"Q\") + r.x1 + \" \" + r.y1 + \" \" + r.x + \" \" + r.y;else if (r.type === m.SMOOTH_QUAD_TO) e += (r.relative ? \"t\" : \"T\") + r.x + \" \" + r.y;else {\n      if (r.type !== m.ARC) throw new Error('Unexpected command type \"' + r.type + '\" at index ' + t + \".\");\n      e += (r.relative ? \"a\" : \"A\") + r.rX + \" \" + r.rY + \" \" + r.xRot + \" \" + +r.lArcFlag + \" \" + +r.sweepFlag + \" \" + r.x + \" \" + r.y;\n    }\n  }\n  return e;\n}\nfunction bi(a, e) {\n  var t = a[0],\n    r = a[1];\n  return [t * Math.cos(e) - r * Math.sin(e), t * Math.sin(e) + r * Math.cos(e)];\n}\nfunction ue() {\n  for (var a = [], e = 0; e < arguments.length; e++) a[e] = arguments[e];\n  for (var t = 0; t < a.length; t++) if (typeof a[t] != \"number\") throw new Error(\"assertNumbers arguments[\" + t + \"] is not a number. \" + typeof a[t] + \" == typeof \" + a[t]);\n  return !0;\n}\nvar Ee = Math.PI;\nfunction Ga(a, e, t) {\n  a.lArcFlag = a.lArcFlag === 0 ? 0 : 1, a.sweepFlag = a.sweepFlag === 0 ? 0 : 1;\n  var r = a.rX,\n    i = a.rY,\n    n = a.x,\n    o = a.y;\n  r = Math.abs(a.rX), i = Math.abs(a.rY);\n  var s = bi([(e - n) / 2, (t - o) / 2], -a.xRot / 180 * Ee),\n    u = s[0],\n    l = s[1],\n    h = Math.pow(u, 2) / Math.pow(r, 2) + Math.pow(l, 2) / Math.pow(i, 2);\n  1 < h && (r *= Math.sqrt(h), i *= Math.sqrt(h)), a.rX = r, a.rY = i;\n  var f = Math.pow(r, 2) * Math.pow(l, 2) + Math.pow(i, 2) * Math.pow(u, 2),\n    c = (a.lArcFlag !== a.sweepFlag ? 1 : -1) * Math.sqrt(Math.max(0, (Math.pow(r, 2) * Math.pow(i, 2) - f) / f)),\n    v = r * l / i * c,\n    g = -i * u / r * c,\n    d = bi([v, g], a.xRot / 180 * Ee);\n  a.cX = d[0] + (e + n) / 2, a.cY = d[1] + (t + o) / 2, a.phi1 = Math.atan2((l - g) / i, (u - v) / r), a.phi2 = Math.atan2((-l - g) / i, (-u - v) / r), a.sweepFlag === 0 && a.phi2 > a.phi1 && (a.phi2 -= 2 * Ee), a.sweepFlag === 1 && a.phi2 < a.phi1 && (a.phi2 += 2 * Ee), a.phi1 *= 180 / Ee, a.phi2 *= 180 / Ee;\n}\nfunction po(a, e, t) {\n  ue(a, e, t);\n  var r = a * a + e * e - t * t;\n  if (0 > r) return [];\n  if (r === 0) return [[a * t / (a * a + e * e), e * t / (a * a + e * e)]];\n  var i = Math.sqrt(r);\n  return [[(a * t + e * i) / (a * a + e * e), (e * t - a * i) / (a * a + e * e)], [(a * t - e * i) / (a * a + e * e), (e * t + a * i) / (a * a + e * e)]];\n}\nvar U,\n  ye = Math.PI / 180;\nfunction yo(a, e, t) {\n  return (1 - t) * a + t * e;\n}\nfunction mo(a, e, t, r) {\n  return a + Math.cos(r / 180 * Ee) * e + Math.sin(r / 180 * Ee) * t;\n}\nfunction bo(a, e, t, r) {\n  var i = 1e-6,\n    n = e - a,\n    o = t - e,\n    s = 3 * n + 3 * (r - t) - 6 * o,\n    u = 6 * (o - n),\n    l = 3 * n;\n  return Math.abs(s) < i ? [-l / u] : function (h, f, c) {\n    c === void 0 && (c = 1e-6);\n    var v = h * h / 4 - f;\n    if (v < -c) return [];\n    if (v <= c) return [-h / 2];\n    var g = Math.sqrt(v);\n    return [-h / 2 - g, -h / 2 + g];\n  }(u / s, l / s, i);\n}\nfunction xo(a, e, t, r, i) {\n  var n = 1 - i;\n  return a * (n * n * n) + e * (3 * n * n * i) + t * (3 * n * i * i) + r * (i * i * i);\n}\n(function (a) {\n  function e() {\n    return i(function (s, u, l) {\n      return s.relative && (s.x1 !== void 0 && (s.x1 += u), s.y1 !== void 0 && (s.y1 += l), s.x2 !== void 0 && (s.x2 += u), s.y2 !== void 0 && (s.y2 += l), s.x !== void 0 && (s.x += u), s.y !== void 0 && (s.y += l), s.relative = !1), s;\n    });\n  }\n  function t() {\n    var s = NaN,\n      u = NaN,\n      l = NaN,\n      h = NaN;\n    return i(function (f, c, v) {\n      return f.type & m.SMOOTH_CURVE_TO && (f.type = m.CURVE_TO, s = isNaN(s) ? c : s, u = isNaN(u) ? v : u, f.x1 = f.relative ? c - s : 2 * c - s, f.y1 = f.relative ? v - u : 2 * v - u), f.type & m.CURVE_TO ? (s = f.relative ? c + f.x2 : f.x2, u = f.relative ? v + f.y2 : f.y2) : (s = NaN, u = NaN), f.type & m.SMOOTH_QUAD_TO && (f.type = m.QUAD_TO, l = isNaN(l) ? c : l, h = isNaN(h) ? v : h, f.x1 = f.relative ? c - l : 2 * c - l, f.y1 = f.relative ? v - h : 2 * v - h), f.type & m.QUAD_TO ? (l = f.relative ? c + f.x1 : f.x1, h = f.relative ? v + f.y1 : f.y1) : (l = NaN, h = NaN), f;\n    });\n  }\n  function r() {\n    var s = NaN,\n      u = NaN;\n    return i(function (l, h, f) {\n      if (l.type & m.SMOOTH_QUAD_TO && (l.type = m.QUAD_TO, s = isNaN(s) ? h : s, u = isNaN(u) ? f : u, l.x1 = l.relative ? h - s : 2 * h - s, l.y1 = l.relative ? f - u : 2 * f - u), l.type & m.QUAD_TO) {\n        s = l.relative ? h + l.x1 : l.x1, u = l.relative ? f + l.y1 : l.y1;\n        var c = l.x1,\n          v = l.y1;\n        l.type = m.CURVE_TO, l.x1 = ((l.relative ? 0 : h) + 2 * c) / 3, l.y1 = ((l.relative ? 0 : f) + 2 * v) / 3, l.x2 = (l.x + 2 * c) / 3, l.y2 = (l.y + 2 * v) / 3;\n      } else s = NaN, u = NaN;\n      return l;\n    });\n  }\n  function i(s) {\n    var u = 0,\n      l = 0,\n      h = NaN,\n      f = NaN;\n    return function (c) {\n      if (isNaN(h) && !(c.type & m.MOVE_TO)) throw new Error(\"path must start with moveto\");\n      var v = s(c, u, l, h, f);\n      return c.type & m.CLOSE_PATH && (u = h, l = f), c.x !== void 0 && (u = c.relative ? u + c.x : c.x), c.y !== void 0 && (l = c.relative ? l + c.y : c.y), c.type & m.MOVE_TO && (h = u, f = l), v;\n    };\n  }\n  function n(s, u, l, h, f, c) {\n    return ue(s, u, l, h, f, c), i(function (v, g, d, p) {\n      var y = v.x1,\n        x = v.x2,\n        b = v.relative && !isNaN(p),\n        T = v.x !== void 0 ? v.x : b ? 0 : g,\n        $ = v.y !== void 0 ? v.y : b ? 0 : d;\n      function E(se) {\n        return se * se;\n      }\n      v.type & m.HORIZ_LINE_TO && u !== 0 && (v.type = m.LINE_TO, v.y = v.relative ? 0 : d), v.type & m.VERT_LINE_TO && l !== 0 && (v.type = m.LINE_TO, v.x = v.relative ? 0 : g), v.x !== void 0 && (v.x = v.x * s + $ * l + (b ? 0 : f)), v.y !== void 0 && (v.y = T * u + v.y * h + (b ? 0 : c)), v.x1 !== void 0 && (v.x1 = v.x1 * s + v.y1 * l + (b ? 0 : f)), v.y1 !== void 0 && (v.y1 = y * u + v.y1 * h + (b ? 0 : c)), v.x2 !== void 0 && (v.x2 = v.x2 * s + v.y2 * l + (b ? 0 : f)), v.y2 !== void 0 && (v.y2 = x * u + v.y2 * h + (b ? 0 : c));\n      var O = s * h - u * l;\n      if (v.xRot !== void 0 && (s !== 1 || u !== 0 || l !== 0 || h !== 1)) if (O === 0) delete v.rX, delete v.rY, delete v.xRot, delete v.lArcFlag, delete v.sweepFlag, v.type = m.LINE_TO;else {\n        var C = v.xRot * Math.PI / 180,\n          P = Math.sin(C),\n          V = Math.cos(C),\n          j = 1 / E(v.rX),\n          R = 1 / E(v.rY),\n          X = E(V) * j + E(P) * R,\n          W = 2 * P * V * (j - R),\n          G = E(P) * j + E(V) * R,\n          q = X * h * h - W * u * h + G * u * u,\n          H = W * (s * h + u * l) - 2 * (X * l * h + G * s * u),\n          Q = X * l * l - W * s * l + G * s * s,\n          N = (Math.atan2(H, q - Q) + Math.PI) % Math.PI / 2,\n          M = Math.sin(N),\n          K = Math.cos(N);\n        v.rX = Math.abs(O) / Math.sqrt(q * E(K) + H * M * K + Q * E(M)), v.rY = Math.abs(O) / Math.sqrt(q * E(M) - H * M * K + Q * E(K)), v.xRot = 180 * N / Math.PI;\n      }\n      return v.sweepFlag !== void 0 && 0 > O && (v.sweepFlag = +!v.sweepFlag), v;\n    });\n  }\n  function o() {\n    return function (s) {\n      var u = {};\n      for (var l in s) u[l] = s[l];\n      return u;\n    };\n  }\n  a.ROUND = function (s) {\n    function u(l) {\n      return Math.round(l * s) / s;\n    }\n    return s === void 0 && (s = 1e13), ue(s), function (l) {\n      return l.x1 !== void 0 && (l.x1 = u(l.x1)), l.y1 !== void 0 && (l.y1 = u(l.y1)), l.x2 !== void 0 && (l.x2 = u(l.x2)), l.y2 !== void 0 && (l.y2 = u(l.y2)), l.x !== void 0 && (l.x = u(l.x)), l.y !== void 0 && (l.y = u(l.y)), l.rX !== void 0 && (l.rX = u(l.rX)), l.rY !== void 0 && (l.rY = u(l.rY)), l;\n    };\n  }, a.TO_ABS = e, a.TO_REL = function () {\n    return i(function (s, u, l) {\n      return s.relative || (s.x1 !== void 0 && (s.x1 -= u), s.y1 !== void 0 && (s.y1 -= l), s.x2 !== void 0 && (s.x2 -= u), s.y2 !== void 0 && (s.y2 -= l), s.x !== void 0 && (s.x -= u), s.y !== void 0 && (s.y -= l), s.relative = !0), s;\n    });\n  }, a.NORMALIZE_HVZ = function (s, u, l) {\n    return s === void 0 && (s = !0), u === void 0 && (u = !0), l === void 0 && (l = !0), i(function (h, f, c, v, g) {\n      if (isNaN(v) && !(h.type & m.MOVE_TO)) throw new Error(\"path must start with moveto\");\n      return u && h.type & m.HORIZ_LINE_TO && (h.type = m.LINE_TO, h.y = h.relative ? 0 : c), l && h.type & m.VERT_LINE_TO && (h.type = m.LINE_TO, h.x = h.relative ? 0 : f), s && h.type & m.CLOSE_PATH && (h.type = m.LINE_TO, h.x = h.relative ? v - f : v, h.y = h.relative ? g - c : g), h.type & m.ARC && (h.rX === 0 || h.rY === 0) && (h.type = m.LINE_TO, delete h.rX, delete h.rY, delete h.xRot, delete h.lArcFlag, delete h.sweepFlag), h;\n    });\n  }, a.NORMALIZE_ST = t, a.QT_TO_C = r, a.INFO = i, a.SANITIZE = function (s) {\n    s === void 0 && (s = 0), ue(s);\n    var u = NaN,\n      l = NaN,\n      h = NaN,\n      f = NaN;\n    return i(function (c, v, g, d, p) {\n      var y = Math.abs,\n        x = !1,\n        b = 0,\n        T = 0;\n      if (c.type & m.SMOOTH_CURVE_TO && (b = isNaN(u) ? 0 : v - u, T = isNaN(l) ? 0 : g - l), c.type & (m.CURVE_TO | m.SMOOTH_CURVE_TO) ? (u = c.relative ? v + c.x2 : c.x2, l = c.relative ? g + c.y2 : c.y2) : (u = NaN, l = NaN), c.type & m.SMOOTH_QUAD_TO ? (h = isNaN(h) ? v : 2 * v - h, f = isNaN(f) ? g : 2 * g - f) : c.type & m.QUAD_TO ? (h = c.relative ? v + c.x1 : c.x1, f = c.relative ? g + c.y1 : c.y2) : (h = NaN, f = NaN), c.type & m.LINE_COMMANDS || c.type & m.ARC && (c.rX === 0 || c.rY === 0 || !c.lArcFlag) || c.type & m.CURVE_TO || c.type & m.SMOOTH_CURVE_TO || c.type & m.QUAD_TO || c.type & m.SMOOTH_QUAD_TO) {\n        var $ = c.x === void 0 ? 0 : c.relative ? c.x : c.x - v,\n          E = c.y === void 0 ? 0 : c.relative ? c.y : c.y - g;\n        b = isNaN(h) ? c.x1 === void 0 ? b : c.relative ? c.x : c.x1 - v : h - v, T = isNaN(f) ? c.y1 === void 0 ? T : c.relative ? c.y : c.y1 - g : f - g;\n        var O = c.x2 === void 0 ? 0 : c.relative ? c.x : c.x2 - v,\n          C = c.y2 === void 0 ? 0 : c.relative ? c.y : c.y2 - g;\n        y($) <= s && y(E) <= s && y(b) <= s && y(T) <= s && y(O) <= s && y(C) <= s && (x = !0);\n      }\n      return c.type & m.CLOSE_PATH && y(v - d) <= s && y(g - p) <= s && (x = !0), x ? [] : c;\n    });\n  }, a.MATRIX = n, a.ROTATE = function (s, u, l) {\n    u === void 0 && (u = 0), l === void 0 && (l = 0), ue(s, u, l);\n    var h = Math.sin(s),\n      f = Math.cos(s);\n    return n(f, h, -h, f, u - u * f + l * h, l - u * h - l * f);\n  }, a.TRANSLATE = function (s, u) {\n    return u === void 0 && (u = 0), ue(s, u), n(1, 0, 0, 1, s, u);\n  }, a.SCALE = function (s, u) {\n    return u === void 0 && (u = s), ue(s, u), n(s, 0, 0, u, 0, 0);\n  }, a.SKEW_X = function (s) {\n    return ue(s), n(1, 0, Math.atan(s), 1, 0, 0);\n  }, a.SKEW_Y = function (s) {\n    return ue(s), n(1, Math.atan(s), 0, 1, 0, 0);\n  }, a.X_AXIS_SYMMETRY = function (s) {\n    return s === void 0 && (s = 0), ue(s), n(-1, 0, 0, 1, s, 0);\n  }, a.Y_AXIS_SYMMETRY = function (s) {\n    return s === void 0 && (s = 0), ue(s), n(1, 0, 0, -1, 0, s);\n  }, a.A_TO_C = function () {\n    return i(function (s, u, l) {\n      return m.ARC === s.type ? function (h, f, c) {\n        var v, g, d, p;\n        h.cX || Ga(h, f, c);\n        for (var y = Math.min(h.phi1, h.phi2), x = Math.max(h.phi1, h.phi2) - y, b = Math.ceil(x / 90), T = new Array(b), $ = f, E = c, O = 0; O < b; O++) {\n          var C = yo(h.phi1, h.phi2, O / b),\n            P = yo(h.phi1, h.phi2, (O + 1) / b),\n            V = P - C,\n            j = 4 / 3 * Math.tan(V * ye / 4),\n            R = [Math.cos(C * ye) - j * Math.sin(C * ye), Math.sin(C * ye) + j * Math.cos(C * ye)],\n            X = R[0],\n            W = R[1],\n            G = [Math.cos(P * ye), Math.sin(P * ye)],\n            q = G[0],\n            H = G[1],\n            Q = [q + j * Math.sin(P * ye), H - j * Math.cos(P * ye)],\n            N = Q[0],\n            M = Q[1];\n          T[O] = {\n            relative: h.relative,\n            type: m.CURVE_TO\n          };\n          var K = function (se, ge) {\n            var Se = bi([se * h.rX, ge * h.rY], h.xRot),\n              ze = Se[0],\n              It = Se[1];\n            return [h.cX + ze, h.cY + It];\n          };\n          v = K(X, W), T[O].x1 = v[0], T[O].y1 = v[1], g = K(N, M), T[O].x2 = g[0], T[O].y2 = g[1], d = K(q, H), T[O].x = d[0], T[O].y = d[1], h.relative && (T[O].x1 -= $, T[O].y1 -= E, T[O].x2 -= $, T[O].y2 -= E, T[O].x -= $, T[O].y -= E), $ = (p = [T[O].x, T[O].y])[0], E = p[1];\n        }\n        return T;\n      }(s, s.relative ? 0 : u, s.relative ? 0 : l) : s;\n    });\n  }, a.ANNOTATE_ARCS = function () {\n    return i(function (s, u, l) {\n      return s.relative && (u = 0, l = 0), m.ARC === s.type && Ga(s, u, l), s;\n    });\n  }, a.CLONE = o, a.CALCULATE_BOUNDS = function () {\n    var s = function (c) {\n        var v = {};\n        for (var g in c) v[g] = c[g];\n        return v;\n      },\n      u = e(),\n      l = r(),\n      h = t(),\n      f = i(function (c, v, g) {\n        var d = h(l(u(s(c))));\n        function p(M) {\n          M > f.maxX && (f.maxX = M), M < f.minX && (f.minX = M);\n        }\n        function y(M) {\n          M > f.maxY && (f.maxY = M), M < f.minY && (f.minY = M);\n        }\n        if (d.type & m.DRAWING_COMMANDS && (p(v), y(g)), d.type & m.HORIZ_LINE_TO && p(d.x), d.type & m.VERT_LINE_TO && y(d.y), d.type & m.LINE_TO && (p(d.x), y(d.y)), d.type & m.CURVE_TO) {\n          p(d.x), y(d.y);\n          for (var x = 0, b = bo(v, d.x1, d.x2, d.x); x < b.length; x++) 0 < (N = b[x]) && 1 > N && p(xo(v, d.x1, d.x2, d.x, N));\n          for (var T = 0, $ = bo(g, d.y1, d.y2, d.y); T < $.length; T++) 0 < (N = $[T]) && 1 > N && y(xo(g, d.y1, d.y2, d.y, N));\n        }\n        if (d.type & m.ARC) {\n          p(d.x), y(d.y), Ga(d, v, g);\n          for (var E = d.xRot / 180 * Math.PI, O = Math.cos(E) * d.rX, C = Math.sin(E) * d.rX, P = -Math.sin(E) * d.rY, V = Math.cos(E) * d.rY, j = d.phi1 < d.phi2 ? [d.phi1, d.phi2] : -180 > d.phi2 ? [d.phi2 + 360, d.phi1 + 360] : [d.phi2, d.phi1], R = j[0], X = j[1], W = function (M) {\n              var K = M[0],\n                se = M[1],\n                ge = 180 * Math.atan2(se, K) / Math.PI;\n              return ge < R ? ge + 360 : ge;\n            }, G = 0, q = po(P, -O, 0).map(W); G < q.length; G++) (N = q[G]) > R && N < X && p(mo(d.cX, O, P, N));\n          for (var H = 0, Q = po(V, -C, 0).map(W); H < Q.length; H++) {\n            var N;\n            (N = Q[H]) > R && N < X && y(mo(d.cY, C, V, N));\n          }\n        }\n        return c;\n      });\n    return f.minX = 1 / 0, f.maxX = -1 / 0, f.minY = 1 / 0, f.maxY = -1 / 0, f;\n  };\n})(U || (U = {}));\nvar oe,\n  dl = function () {\n    function a() {}\n    return a.prototype.round = function (e) {\n      return this.transform(U.ROUND(e));\n    }, a.prototype.toAbs = function () {\n      return this.transform(U.TO_ABS());\n    }, a.prototype.toRel = function () {\n      return this.transform(U.TO_REL());\n    }, a.prototype.normalizeHVZ = function (e, t, r) {\n      return this.transform(U.NORMALIZE_HVZ(e, t, r));\n    }, a.prototype.normalizeST = function () {\n      return this.transform(U.NORMALIZE_ST());\n    }, a.prototype.qtToC = function () {\n      return this.transform(U.QT_TO_C());\n    }, a.prototype.aToC = function () {\n      return this.transform(U.A_TO_C());\n    }, a.prototype.sanitize = function (e) {\n      return this.transform(U.SANITIZE(e));\n    }, a.prototype.translate = function (e, t) {\n      return this.transform(U.TRANSLATE(e, t));\n    }, a.prototype.scale = function (e, t) {\n      return this.transform(U.SCALE(e, t));\n    }, a.prototype.rotate = function (e, t, r) {\n      return this.transform(U.ROTATE(e, t, r));\n    }, a.prototype.matrix = function (e, t, r, i, n, o) {\n      return this.transform(U.MATRIX(e, t, r, i, n, o));\n    }, a.prototype.skewX = function (e) {\n      return this.transform(U.SKEW_X(e));\n    }, a.prototype.skewY = function (e) {\n      return this.transform(U.SKEW_Y(e));\n    }, a.prototype.xSymmetry = function (e) {\n      return this.transform(U.X_AXIS_SYMMETRY(e));\n    }, a.prototype.ySymmetry = function (e) {\n      return this.transform(U.Y_AXIS_SYMMETRY(e));\n    }, a.prototype.annotateArcs = function () {\n      return this.transform(U.ANNOTATE_ARCS());\n    }, a;\n  }(),\n  Ub = function (a) {\n    return a === \" \" || a === \"\t\" || a === \"\\r\" || a === `\n`;\n  },\n  To = function (a) {\n    return \"0\".charCodeAt(0) <= a.charCodeAt(0) && a.charCodeAt(0) <= \"9\".charCodeAt(0);\n  },\n  Gb = function (a) {\n    function e() {\n      var t = a.call(this) || this;\n      return t.curNumber = \"\", t.curCommandType = -1, t.curCommandRelative = !1, t.canParseCommandOrComma = !0, t.curNumberHasExp = !1, t.curNumberHasExpDigits = !1, t.curNumberHasDecimal = !1, t.curArgs = [], t;\n    }\n    return gl(e, a), e.prototype.finish = function (t) {\n      if (t === void 0 && (t = []), this.parse(\" \", t), this.curArgs.length !== 0 || !this.canParseCommandOrComma) throw new SyntaxError(\"Unterminated command at the path end.\");\n      return t;\n    }, e.prototype.parse = function (t, r) {\n      var i = this;\n      r === void 0 && (r = []);\n      for (var n = function (f) {\n          r.push(f), i.curArgs.length = 0, i.canParseCommandOrComma = !0;\n        }, o = 0; o < t.length; o++) {\n        var s = t[o],\n          u = !(this.curCommandType !== m.ARC || this.curArgs.length !== 3 && this.curArgs.length !== 4 || this.curNumber.length !== 1 || this.curNumber !== \"0\" && this.curNumber !== \"1\"),\n          l = To(s) && (this.curNumber === \"0\" && s === \"0\" || u);\n        if (!To(s) || l) {\n          if (s !== \"e\" && s !== \"E\") {\n            if (s !== \"-\" && s !== \"+\" || !this.curNumberHasExp || this.curNumberHasExpDigits) {\n              if (s !== \".\" || this.curNumberHasExp || this.curNumberHasDecimal || u) {\n                if (this.curNumber && this.curCommandType !== -1) {\n                  var h = Number(this.curNumber);\n                  if (isNaN(h)) throw new SyntaxError(\"Invalid number ending at \" + o);\n                  if (this.curCommandType === m.ARC) {\n                    if (this.curArgs.length === 0 || this.curArgs.length === 1) {\n                      if (0 > h) throw new SyntaxError('Expected positive number, got \"' + h + '\" at index \"' + o + '\"');\n                    } else if ((this.curArgs.length === 3 || this.curArgs.length === 4) && this.curNumber !== \"0\" && this.curNumber !== \"1\") throw new SyntaxError('Expected a flag, got \"' + this.curNumber + '\" at index \"' + o + '\"');\n                  }\n                  this.curArgs.push(h), this.curArgs.length === zb[this.curCommandType] && (m.HORIZ_LINE_TO === this.curCommandType ? n({\n                    type: m.HORIZ_LINE_TO,\n                    relative: this.curCommandRelative,\n                    x: h\n                  }) : m.VERT_LINE_TO === this.curCommandType ? n({\n                    type: m.VERT_LINE_TO,\n                    relative: this.curCommandRelative,\n                    y: h\n                  }) : this.curCommandType === m.MOVE_TO || this.curCommandType === m.LINE_TO || this.curCommandType === m.SMOOTH_QUAD_TO ? (n({\n                    type: this.curCommandType,\n                    relative: this.curCommandRelative,\n                    x: this.curArgs[0],\n                    y: this.curArgs[1]\n                  }), m.MOVE_TO === this.curCommandType && (this.curCommandType = m.LINE_TO)) : this.curCommandType === m.CURVE_TO ? n({\n                    type: m.CURVE_TO,\n                    relative: this.curCommandRelative,\n                    x1: this.curArgs[0],\n                    y1: this.curArgs[1],\n                    x2: this.curArgs[2],\n                    y2: this.curArgs[3],\n                    x: this.curArgs[4],\n                    y: this.curArgs[5]\n                  }) : this.curCommandType === m.SMOOTH_CURVE_TO ? n({\n                    type: m.SMOOTH_CURVE_TO,\n                    relative: this.curCommandRelative,\n                    x2: this.curArgs[0],\n                    y2: this.curArgs[1],\n                    x: this.curArgs[2],\n                    y: this.curArgs[3]\n                  }) : this.curCommandType === m.QUAD_TO ? n({\n                    type: m.QUAD_TO,\n                    relative: this.curCommandRelative,\n                    x1: this.curArgs[0],\n                    y1: this.curArgs[1],\n                    x: this.curArgs[2],\n                    y: this.curArgs[3]\n                  }) : this.curCommandType === m.ARC && n({\n                    type: m.ARC,\n                    relative: this.curCommandRelative,\n                    rX: this.curArgs[0],\n                    rY: this.curArgs[1],\n                    xRot: this.curArgs[2],\n                    lArcFlag: this.curArgs[3],\n                    sweepFlag: this.curArgs[4],\n                    x: this.curArgs[5],\n                    y: this.curArgs[6]\n                  })), this.curNumber = \"\", this.curNumberHasExpDigits = !1, this.curNumberHasExp = !1, this.curNumberHasDecimal = !1, this.canParseCommandOrComma = !0;\n                }\n                if (!Ub(s)) if (s === \",\" && this.canParseCommandOrComma) this.canParseCommandOrComma = !1;else if (s !== \"+\" && s !== \"-\" && s !== \".\") {\n                  if (l) this.curNumber = s, this.curNumberHasDecimal = !1;else {\n                    if (this.curArgs.length !== 0) throw new SyntaxError(\"Unterminated command at index \" + o + \".\");\n                    if (!this.canParseCommandOrComma) throw new SyntaxError('Unexpected character \"' + s + '\" at index ' + o + \". Command cannot follow comma\");\n                    if (this.canParseCommandOrComma = !1, s !== \"z\" && s !== \"Z\") {\n                      if (s === \"h\" || s === \"H\") this.curCommandType = m.HORIZ_LINE_TO, this.curCommandRelative = s === \"h\";else if (s === \"v\" || s === \"V\") this.curCommandType = m.VERT_LINE_TO, this.curCommandRelative = s === \"v\";else if (s === \"m\" || s === \"M\") this.curCommandType = m.MOVE_TO, this.curCommandRelative = s === \"m\";else if (s === \"l\" || s === \"L\") this.curCommandType = m.LINE_TO, this.curCommandRelative = s === \"l\";else if (s === \"c\" || s === \"C\") this.curCommandType = m.CURVE_TO, this.curCommandRelative = s === \"c\";else if (s === \"s\" || s === \"S\") this.curCommandType = m.SMOOTH_CURVE_TO, this.curCommandRelative = s === \"s\";else if (s === \"q\" || s === \"Q\") this.curCommandType = m.QUAD_TO, this.curCommandRelative = s === \"q\";else if (s === \"t\" || s === \"T\") this.curCommandType = m.SMOOTH_QUAD_TO, this.curCommandRelative = s === \"t\";else {\n                        if (s !== \"a\" && s !== \"A\") throw new SyntaxError('Unexpected character \"' + s + '\" at index ' + o + \".\");\n                        this.curCommandType = m.ARC, this.curCommandRelative = s === \"a\";\n                      }\n                    } else r.push({\n                      type: m.CLOSE_PATH\n                    }), this.canParseCommandOrComma = !0, this.curCommandType = -1;\n                  }\n                } else this.curNumber = s, this.curNumberHasDecimal = s === \".\";\n              } else this.curNumber += s, this.curNumberHasDecimal = !0;\n            } else this.curNumber += s;\n          } else this.curNumber += s, this.curNumberHasExp = !0;\n        } else this.curNumber += s, this.curNumberHasExpDigits = this.curNumberHasExp;\n      }\n      return r;\n    }, e.prototype.transform = function (t) {\n      return Object.create(this, {\n        parse: {\n          value: function (r, i) {\n            i === void 0 && (i = []);\n            for (var n = 0, o = Object.getPrototypeOf(this).parse.call(this, r); n < o.length; n++) {\n              var s = o[n],\n                u = t(s);\n              Array.isArray(u) ? i.push.apply(i, u) : i.push(u);\n            }\n            return i;\n          }\n        }\n      });\n    }, e;\n  }(dl),\n  m = function (a) {\n    function e(t) {\n      var r = a.call(this) || this;\n      return r.commands = typeof t == \"string\" ? e.parse(t) : t, r;\n    }\n    return gl(e, a), e.prototype.encode = function () {\n      return e.encode(this.commands);\n    }, e.prototype.getBounds = function () {\n      var t = U.CALCULATE_BOUNDS();\n      return this.transform(t), t;\n    }, e.prototype.transform = function (t) {\n      for (var r = [], i = 0, n = this.commands; i < n.length; i++) {\n        var o = t(n[i]);\n        Array.isArray(o) ? r.push.apply(r, o) : r.push(o);\n      }\n      return this.commands = r, this;\n    }, e.encode = function (t) {\n      return Fb(t);\n    }, e.parse = function (t) {\n      var r = new Gb(),\n        i = [];\n      return r.parse(t, i), r.finish(i), i;\n    }, e.CLOSE_PATH = 1, e.MOVE_TO = 2, e.HORIZ_LINE_TO = 4, e.VERT_LINE_TO = 8, e.LINE_TO = 16, e.CURVE_TO = 32, e.SMOOTH_CURVE_TO = 64, e.QUAD_TO = 128, e.SMOOTH_QUAD_TO = 256, e.ARC = 512, e.LINE_COMMANDS = e.LINE_TO | e.HORIZ_LINE_TO | e.VERT_LINE_TO, e.DRAWING_COMMANDS = e.HORIZ_LINE_TO | e.VERT_LINE_TO | e.LINE_TO | e.CURVE_TO | e.SMOOTH_CURVE_TO | e.QUAD_TO | e.SMOOTH_QUAD_TO | e.ARC, e;\n  }(dl),\n  zb = ((oe = {})[m.MOVE_TO] = 2, oe[m.LINE_TO] = 2, oe[m.HORIZ_LINE_TO] = 1, oe[m.VERT_LINE_TO] = 1, oe[m.CLOSE_PATH] = 0, oe[m.QUAD_TO] = 4, oe[m.SMOOTH_QUAD_TO] = 2, oe[m.CURVE_TO] = 6, oe[m.SMOOTH_CURVE_TO] = 4, oe[m.ARC] = 7, oe),\n  Hb = $r.PROPER,\n  Yb = Ue,\n  Xb = J,\n  Oo = pe,\n  Wb = D,\n  qb = Ki,\n  nn = \"toString\",\n  pl = RegExp.prototype,\n  yl = pl[nn],\n  Qb = Wb(function () {\n    return yl.call({\n      source: \"a\",\n      flags: \"b\"\n    }) !== \"/a/b\";\n  }),\n  Kb = Hb && yl.name !== nn;\n(Qb || Kb) && Yb(pl, nn, function () {\n  var e = Xb(this),\n    t = Oo(e.source),\n    r = Oo(qb(e));\n  return \"/\" + t + \"/\" + r;\n}, {\n  unsafe: !0\n});\nfunction fr(a) {\n  \"@babel/helpers - typeof\";\n\n  return typeof Symbol == \"function\" && typeof Symbol.iterator == \"symbol\" ? fr = function (e) {\n    return typeof e;\n  } : fr = function (e) {\n    return e && typeof Symbol == \"function\" && e.constructor === Symbol && e !== Symbol.prototype ? \"symbol\" : typeof e;\n  }, fr(a);\n}\nfunction Zb(a, e) {\n  if (!(a instanceof e)) throw new TypeError(\"Cannot call a class as a function\");\n}\nvar Jb = [512, 512, 456, 512, 328, 456, 335, 512, 405, 328, 271, 456, 388, 335, 292, 512, 454, 405, 364, 328, 298, 271, 496, 456, 420, 388, 360, 335, 312, 292, 273, 512, 482, 454, 428, 405, 383, 364, 345, 328, 312, 298, 284, 271, 259, 496, 475, 456, 437, 420, 404, 388, 374, 360, 347, 335, 323, 312, 302, 292, 282, 273, 265, 512, 497, 482, 468, 454, 441, 428, 417, 405, 394, 383, 373, 364, 354, 345, 337, 328, 320, 312, 305, 298, 291, 284, 278, 271, 265, 259, 507, 496, 485, 475, 465, 456, 446, 437, 428, 420, 412, 404, 396, 388, 381, 374, 367, 360, 354, 347, 341, 335, 329, 323, 318, 312, 307, 302, 297, 292, 287, 282, 278, 273, 269, 265, 261, 512, 505, 497, 489, 482, 475, 468, 461, 454, 447, 441, 435, 428, 422, 417, 411, 405, 399, 394, 389, 383, 378, 373, 368, 364, 359, 354, 350, 345, 341, 337, 332, 328, 324, 320, 316, 312, 309, 305, 301, 298, 294, 291, 287, 284, 281, 278, 274, 271, 268, 265, 262, 259, 257, 507, 501, 496, 491, 485, 480, 475, 470, 465, 460, 456, 451, 446, 442, 437, 433, 428, 424, 420, 416, 412, 408, 404, 400, 396, 392, 388, 385, 381, 377, 374, 370, 367, 363, 360, 357, 354, 350, 347, 344, 341, 338, 335, 332, 329, 326, 323, 320, 318, 315, 312, 310, 307, 304, 302, 299, 297, 294, 292, 289, 287, 285, 282, 280, 278, 275, 273, 271, 269, 267, 265, 263, 261, 259],\n  e1 = [9, 11, 12, 13, 13, 14, 14, 15, 15, 15, 15, 16, 16, 16, 16, 17, 17, 17, 17, 17, 17, 17, 18, 18, 18, 18, 18, 18, 18, 18, 18, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24];\nfunction t1(a, e, t, r, i) {\n  if (typeof a == \"string\" && (a = document.getElementById(a)), !a || fr(a) !== \"object\" || !(\"getContext\" in a)) throw new TypeError(\"Expecting canvas with `getContext` method in processCanvasRGB(A) calls!\");\n  var n = a.getContext(\"2d\");\n  try {\n    return n.getImageData(e, t, r, i);\n  } catch (o) {\n    throw new Error(\"unable to access image data: \" + o);\n  }\n}\nfunction r1(a, e, t, r, i, n) {\n  if (!(isNaN(n) || n < 1)) {\n    n |= 0;\n    var o = t1(a, e, t, r, i);\n    o = a1(o, e, t, r, i, n), a.getContext(\"2d\").putImageData(o, e, t);\n  }\n}\nfunction a1(a, e, t, r, i, n) {\n  for (var o = a.data, s = 2 * n + 1, u = r - 1, l = i - 1, h = n + 1, f = h * (h + 1) / 2, c = new So(), v = c, g, d = 1; d < s; d++) v = v.next = new So(), d === h && (g = v);\n  v.next = c;\n  for (var p = null, y = null, x = 0, b = 0, T = Jb[n], $ = e1[n], E = 0; E < i; E++) {\n    v = c;\n    for (var O = o[b], C = o[b + 1], P = o[b + 2], V = o[b + 3], j = 0; j < h; j++) v.r = O, v.g = C, v.b = P, v.a = V, v = v.next;\n    for (var R = 0, X = 0, W = 0, G = 0, q = h * O, H = h * C, Q = h * P, N = h * V, M = f * O, K = f * C, se = f * P, ge = f * V, Se = 1; Se < h; Se++) {\n      var ze = b + ((u < Se ? u : Se) << 2),\n        It = o[ze],\n        un = o[ze + 1],\n        ln = o[ze + 2],\n        hn = o[ze + 3],\n        Mt = h - Se;\n      M += (v.r = It) * Mt, K += (v.g = un) * Mt, se += (v.b = ln) * Mt, ge += (v.a = hn) * Mt, R += It, X += un, W += ln, G += hn, v = v.next;\n    }\n    p = c, y = g;\n    for (var jr = 0; jr < r; jr++) {\n      var Fr = ge * T >>> $;\n      if (o[b + 3] = Fr, Fr !== 0) {\n        var Ur = 255 / Fr;\n        o[b] = (M * T >>> $) * Ur, o[b + 1] = (K * T >>> $) * Ur, o[b + 2] = (se * T >>> $) * Ur;\n      } else o[b] = o[b + 1] = o[b + 2] = 0;\n      M -= q, K -= H, se -= Q, ge -= N, q -= p.r, H -= p.g, Q -= p.b, N -= p.a;\n      var Ae = jr + n + 1;\n      Ae = x + (Ae < u ? Ae : u) << 2, R += p.r = o[Ae], X += p.g = o[Ae + 1], W += p.b = o[Ae + 2], G += p.a = o[Ae + 3], M += R, K += X, se += W, ge += G, p = p.next;\n      var _t = y,\n        vn = _t.r,\n        fn = _t.g,\n        cn = _t.b,\n        gn = _t.a;\n      q += vn, H += fn, Q += cn, N += gn, R -= vn, X -= fn, W -= cn, G -= gn, y = y.next, b += 4;\n    }\n    x += r;\n  }\n  for (var He = 0; He < r; He++) {\n    b = He << 2;\n    var Pe = o[b],\n      Re = o[b + 1],\n      Ne = o[b + 2],\n      te = o[b + 3],\n      Gr = h * Pe,\n      zr = h * Re,\n      Hr = h * Ne,\n      Yr = h * te,\n      Vt = f * Pe,\n      Dt = f * Re,\n      Lt = f * Ne,\n      kt = f * te;\n    v = c;\n    for (var dn = 0; dn < h; dn++) v.r = Pe, v.g = Re, v.b = Ne, v.a = te, v = v.next;\n    for (var pn = r, Xr = 0, Wr = 0, qr = 0, Qr = 0, Bt = 1; Bt <= n; Bt++) {\n      b = pn + He << 2;\n      var jt = h - Bt;\n      Vt += (v.r = Pe = o[b]) * jt, Dt += (v.g = Re = o[b + 1]) * jt, Lt += (v.b = Ne = o[b + 2]) * jt, kt += (v.a = te = o[b + 3]) * jt, Qr += Pe, Xr += Re, Wr += Ne, qr += te, v = v.next, Bt < l && (pn += r);\n    }\n    b = He, p = c, y = g;\n    for (var Kr = 0; Kr < i; Kr++) {\n      var re = b << 2;\n      o[re + 3] = te = kt * T >>> $, te > 0 ? (te = 255 / te, o[re] = (Vt * T >>> $) * te, o[re + 1] = (Dt * T >>> $) * te, o[re + 2] = (Lt * T >>> $) * te) : o[re] = o[re + 1] = o[re + 2] = 0, Vt -= Gr, Dt -= zr, Lt -= Hr, kt -= Yr, Gr -= p.r, zr -= p.g, Hr -= p.b, Yr -= p.a, re = He + ((re = Kr + h) < l ? re : l) * r << 2, Vt += Qr += p.r = o[re], Dt += Xr += p.g = o[re + 1], Lt += Wr += p.b = o[re + 2], kt += qr += p.a = o[re + 3], p = p.next, Gr += Pe = y.r, zr += Re = y.g, Hr += Ne = y.b, Yr += te = y.a, Qr -= Pe, Xr -= Re, Wr -= Ne, qr -= te, y = y.next, b += r;\n    }\n  }\n  return a;\n}\nvar So =\n/**\n * Set properties.\n */\nfunction a() {\n  Zb(this, a), this.r = 0, this.g = 0, this.b = 0, this.a = 0, this.next = null;\n};\nfunction i1() {\n  var {\n      DOMParser: a\n    } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {},\n    e = {\n      window: null,\n      ignoreAnimation: !0,\n      ignoreMouse: !0,\n      DOMParser: a,\n      createCanvas(t, r) {\n        return new OffscreenCanvas(t, r);\n      },\n      createImage(t) {\n        return xe(function* () {\n          var r = yield fetch(t),\n            i = yield r.blob(),\n            n = yield createImageBitmap(i);\n          return n;\n        })();\n      }\n    };\n  return (typeof DOMParser < \"u\" || typeof a > \"u\") && Reflect.deleteProperty(e, \"DOMParser\"), e;\n}\nfunction n1(a) {\n  var {\n    DOMParser: e,\n    canvas: t,\n    fetch: r\n  } = a;\n  return {\n    window: null,\n    ignoreAnimation: !0,\n    ignoreMouse: !0,\n    DOMParser: e,\n    fetch: r,\n    createCanvas: t.createCanvas,\n    createImage: t.loadImage\n  };\n}\nvar y2 = /* @__PURE__ */Object.freeze({\n  __proto__: null,\n  offscreen: i1,\n  node: n1\n});\nfunction lt(a) {\n  return a.replace(/(?!\\u3000)\\s+/gm, \" \");\n}\nfunction s1(a) {\n  return a.replace(/^[\\n \\t]+/, \"\");\n}\nfunction o1(a) {\n  return a.replace(/[\\n \\t]+$/, \"\");\n}\nfunction ne(a) {\n  var e = (a || \"\").match(/-?(\\d+(?:\\.\\d*(?:[eE][+-]?\\d+)?)?|\\.\\d+)(?=\\D|$)/gm) || [];\n  return e.map(parseFloat);\n}\nvar u1 = /^[A-Z-]+$/;\nfunction l1(a) {\n  return u1.test(a) ? a.toLowerCase() : a;\n}\nfunction ml(a) {\n  var e = /url\\(('([^']+)'|\"([^\"]+)\"|([^'\")]+))\\)/.exec(a) || [];\n  return e[2] || e[3] || e[4];\n}\nfunction h1(a) {\n  if (!a.startsWith(\"rgb\")) return a;\n  var e = 3,\n    t = a.replace(/\\d+(\\.\\d+)?/g, (r, i) => e-- && i ? String(Math.round(parseFloat(r))) : r);\n  return t;\n}\nvar v1 = /(\\[[^\\]]+\\])/g,\n  f1 = /(#[^\\s+>~.[:]+)/g,\n  c1 = /(\\.[^\\s+>~.[:]+)/g,\n  g1 = /(::[^\\s+>~.[:]+|:first-line|:first-letter|:before|:after)/gi,\n  d1 = /(:[\\w-]+\\([^)]*\\))/gi,\n  p1 = /(:[^\\s+>~.[:]+)/g,\n  y1 = /([^\\s+>~.[:]+)/g;\nfunction Ve(a, e) {\n  var t = e.exec(a);\n  return t ? [a.replace(e, \" \"), t.length] : [a, 0];\n}\nfunction m1(a) {\n  var e = [0, 0, 0],\n    t = a.replace(/:not\\(([^)]*)\\)/g, \"     $1 \").replace(/{[\\s\\S]*/gm, \" \"),\n    r = 0;\n  return [t, r] = Ve(t, v1), e[1] += r, [t, r] = Ve(t, f1), e[0] += r, [t, r] = Ve(t, c1), e[1] += r, [t, r] = Ve(t, g1), e[2] += r, [t, r] = Ve(t, d1), e[1] += r, [t, r] = Ve(t, p1), e[1] += r, t = t.replace(/[*\\s+>~]/g, \" \").replace(/[#.]/g, \" \"), [t, r] = Ve(t, y1), e[2] += r, e.join(\"\");\n}\nvar rt = 1e-8;\nfunction Eo(a) {\n  return Math.sqrt(Math.pow(a[0], 2) + Math.pow(a[1], 2));\n}\nfunction xi(a, e) {\n  return (a[0] * e[0] + a[1] * e[1]) / (Eo(a) * Eo(e));\n}\nfunction $o(a, e) {\n  return (a[0] * e[1] < a[1] * e[0] ? -1 : 1) * Math.acos(xi(a, e));\n}\nfunction wo(a) {\n  return a * a * a;\n}\nfunction Co(a) {\n  return 3 * a * a * (1 - a);\n}\nfunction Ao(a) {\n  return 3 * a * (1 - a) * (1 - a);\n}\nfunction Po(a) {\n  return (1 - a) * (1 - a) * (1 - a);\n}\nfunction Ro(a) {\n  return a * a;\n}\nfunction No(a) {\n  return 2 * a * (1 - a);\n}\nfunction Io(a) {\n  return (1 - a) * (1 - a);\n}\nlet S = /*#__PURE__*/(() => {\n  class S {\n    constructor(e, t, r) {\n      this.document = e, this.name = t, this.value = r, this.isNormalizedColor = !1;\n    }\n    static empty(e) {\n      return new S(e, \"EMPTY\", \"\");\n    }\n    split() {\n      var e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : \" \",\n        {\n          document: t,\n          name: r\n        } = this;\n      return lt(this.getString()).trim().split(e).map(i => new S(t, r, i));\n    }\n    hasValue(e) {\n      var {\n        value: t\n      } = this;\n      return t !== null && t !== \"\" && (e || t !== 0) && typeof t < \"u\";\n    }\n    isString(e) {\n      var {\n          value: t\n        } = this,\n        r = typeof t == \"string\";\n      return !r || !e ? r : e.test(t);\n    }\n    isUrlDefinition() {\n      return this.isString(/^url\\(/);\n    }\n    isPixels() {\n      if (!this.hasValue()) return !1;\n      var e = this.getString();\n      switch (!0) {\n        case e.endsWith(\"px\"):\n        case /^[0-9]+$/.test(e):\n          return !0;\n        default:\n          return !1;\n      }\n    }\n    setValue(e) {\n      return this.value = e, this;\n    }\n    getValue(e) {\n      return typeof e > \"u\" || this.hasValue() ? this.value : e;\n    }\n    getNumber(e) {\n      if (!this.hasValue()) return typeof e > \"u\" ? 0 : parseFloat(e);\n      var {\n          value: t\n        } = this,\n        r = parseFloat(t);\n      return this.isString(/%$/) && (r /= 100), r;\n    }\n    getString(e) {\n      return typeof e > \"u\" || this.hasValue() ? typeof this.value > \"u\" ? \"\" : String(this.value) : String(e);\n    }\n    getColor(e) {\n      var t = this.getString(e);\n      return this.isNormalizedColor || (this.isNormalizedColor = !0, t = h1(t), this.value = t), t;\n    }\n    getDpi() {\n      return 96;\n    }\n    getRem() {\n      return this.document.rootEmSize;\n    }\n    getEm() {\n      return this.document.emSize;\n    }\n    getUnits() {\n      return this.getString().replace(/[0-9.-]/g, \"\");\n    }\n    getPixels(e) {\n      var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1;\n      if (!this.hasValue()) return 0;\n      var [r, i] = typeof e == \"boolean\" ? [void 0, e] : [e],\n        {\n          viewPort: n\n        } = this.document.screen;\n      switch (!0) {\n        case this.isString(/vmin$/):\n          return this.getNumber() / 100 * Math.min(n.computeSize(\"x\"), n.computeSize(\"y\"));\n        case this.isString(/vmax$/):\n          return this.getNumber() / 100 * Math.max(n.computeSize(\"x\"), n.computeSize(\"y\"));\n        case this.isString(/vw$/):\n          return this.getNumber() / 100 * n.computeSize(\"x\");\n        case this.isString(/vh$/):\n          return this.getNumber() / 100 * n.computeSize(\"y\");\n        case this.isString(/rem$/):\n          return this.getNumber() * this.getRem();\n        case this.isString(/em$/):\n          return this.getNumber() * this.getEm();\n        case this.isString(/ex$/):\n          return this.getNumber() * this.getEm() / 2;\n        case this.isString(/px$/):\n          return this.getNumber();\n        case this.isString(/pt$/):\n          return this.getNumber() * this.getDpi() * (1 / 72);\n        case this.isString(/pc$/):\n          return this.getNumber() * 15;\n        case this.isString(/cm$/):\n          return this.getNumber() * this.getDpi() / 2.54;\n        case this.isString(/mm$/):\n          return this.getNumber() * this.getDpi() / 25.4;\n        case this.isString(/in$/):\n          return this.getNumber() * this.getDpi();\n        case this.isString(/%$/) && i:\n          return this.getNumber() * this.getEm();\n        case this.isString(/%$/):\n          return this.getNumber() * n.computeSize(r);\n        default:\n          {\n            var o = this.getNumber();\n            return t && o < 1 ? o * n.computeSize(r) : o;\n          }\n      }\n    }\n    getMilliseconds() {\n      return this.hasValue() ? this.isString(/ms$/) ? this.getNumber() : this.getNumber() * 1e3 : 0;\n    }\n    getRadians() {\n      if (!this.hasValue()) return 0;\n      switch (!0) {\n        case this.isString(/deg$/):\n          return this.getNumber() * (Math.PI / 180);\n        case this.isString(/grad$/):\n          return this.getNumber() * (Math.PI / 200);\n        case this.isString(/rad$/):\n          return this.getNumber();\n        default:\n          return this.getNumber() * (Math.PI / 180);\n      }\n    }\n    getDefinition() {\n      var e = this.getString(),\n        t = /#([^)'\"]+)/.exec(e);\n      return t && (t = t[1]), t || (t = e), this.document.definitions[t];\n    }\n    getFillStyleDefinition(e, t) {\n      var r = this.getDefinition();\n      if (!r) return null;\n      if (typeof r.createGradient == \"function\") return r.createGradient(this.document.ctx, e, t);\n      if (typeof r.createPattern == \"function\") {\n        if (r.getHrefAttribute().hasValue()) {\n          var i = r.getAttribute(\"patternTransform\");\n          r = r.getHrefAttribute().getDefinition(), i.hasValue() && r.getAttribute(\"patternTransform\", !0).setValue(i.value);\n        }\n        return r.createPattern(this.document.ctx, e, t);\n      }\n      return null;\n    }\n    getTextBaseline() {\n      return this.hasValue() ? S.textBaselineMapping[this.getString()] : null;\n    }\n    addOpacity(e) {\n      for (var t = this.getColor(), r = t.length, i = 0, n = 0; n < r && (t[n] === \",\" && i++, i !== 3); n++);\n      if (e.hasValue() && this.isString() && i !== 3) {\n        var o = new yi(t);\n        o.ok && (o.alpha = e.getNumber(), t = o.toRGBA());\n      }\n      return new S(this.document, this.name, t);\n    }\n  }\n  S.textBaselineMapping = {\n    baseline: \"alphabetic\",\n    \"before-edge\": \"top\",\n    \"text-before-edge\": \"top\",\n    middle: \"middle\",\n    central: \"middle\",\n    \"after-edge\": \"bottom\",\n    \"text-after-edge\": \"bottom\",\n    ideographic: \"ideographic\",\n    alphabetic: \"alphabetic\",\n    hanging: \"hanging\",\n    mathematical: \"alphabetic\"\n  };\n  return S;\n})();\nclass b1 {\n  constructor() {\n    this.viewPorts = [];\n  }\n  clear() {\n    this.viewPorts = [];\n  }\n  setCurrent(e, t) {\n    this.viewPorts.push({\n      width: e,\n      height: t\n    });\n  }\n  removeCurrent() {\n    this.viewPorts.pop();\n  }\n  getCurrent() {\n    var {\n      viewPorts: e\n    } = this;\n    return e[e.length - 1];\n  }\n  get width() {\n    return this.getCurrent().width;\n  }\n  get height() {\n    return this.getCurrent().height;\n  }\n  computeSize(e) {\n    return typeof e == \"number\" ? e : e === \"x\" ? this.width : e === \"y\" ? this.height : Math.sqrt(Math.pow(this.width, 2) + Math.pow(this.height, 2)) / Math.sqrt(2);\n  }\n}\nclass k {\n  constructor(e, t) {\n    this.x = e, this.y = t;\n  }\n  static parse(e) {\n    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0,\n      [r = t, i = t] = ne(e);\n    return new k(r, i);\n  }\n  static parseScale(e) {\n    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1,\n      [r = t, i = r] = ne(e);\n    return new k(r, i);\n  }\n  static parsePath(e) {\n    for (var t = ne(e), r = t.length, i = [], n = 0; n < r; n += 2) i.push(new k(t[n], t[n + 1]));\n    return i;\n  }\n  angleTo(e) {\n    return Math.atan2(e.y - this.y, e.x - this.x);\n  }\n  applyTransform(e) {\n    var {\n        x: t,\n        y: r\n      } = this,\n      i = t * e[0] + r * e[2] + e[4],\n      n = t * e[1] + r * e[3] + e[5];\n    this.x = i, this.y = n;\n  }\n}\nclass x1 {\n  constructor(e) {\n    this.screen = e, this.working = !1, this.events = [], this.eventElements = [], this.onClick = this.onClick.bind(this), this.onMouseMove = this.onMouseMove.bind(this);\n  }\n  isWorking() {\n    return this.working;\n  }\n  start() {\n    if (!this.working) {\n      var {\n          screen: e,\n          onClick: t,\n          onMouseMove: r\n        } = this,\n        i = e.ctx.canvas;\n      i.onclick = t, i.onmousemove = r, this.working = !0;\n    }\n  }\n  stop() {\n    if (this.working) {\n      var e = this.screen.ctx.canvas;\n      this.working = !1, e.onclick = null, e.onmousemove = null;\n    }\n  }\n  hasEvents() {\n    return this.working && this.events.length > 0;\n  }\n  runEvents() {\n    if (this.working) {\n      var {\n          screen: e,\n          events: t,\n          eventElements: r\n        } = this,\n        {\n          style: i\n        } = e.ctx.canvas;\n      i && (i.cursor = \"\"), t.forEach((n, o) => {\n        for (var {\n            run: s\n          } = n, u = r[o]; u;) s(u), u = u.parent;\n      }), this.events = [], this.eventElements = [];\n    }\n  }\n  checkPath(e, t) {\n    if (!(!this.working || !t)) {\n      var {\n        events: r,\n        eventElements: i\n      } = this;\n      r.forEach((n, o) => {\n        var {\n          x: s,\n          y: u\n        } = n;\n        !i[o] && t.isPointInPath && t.isPointInPath(s, u) && (i[o] = e);\n      });\n    }\n  }\n  checkBoundingBox(e, t) {\n    if (!(!this.working || !t)) {\n      var {\n        events: r,\n        eventElements: i\n      } = this;\n      r.forEach((n, o) => {\n        var {\n          x: s,\n          y: u\n        } = n;\n        !i[o] && t.isPointInBox(s, u) && (i[o] = e);\n      });\n    }\n  }\n  mapXY(e, t) {\n    for (var {\n        window: r,\n        ctx: i\n      } = this.screen, n = new k(e, t), o = i.canvas; o;) n.x -= o.offsetLeft, n.y -= o.offsetTop, o = o.offsetParent;\n    return r.scrollX && (n.x += r.scrollX), r.scrollY && (n.y += r.scrollY), n;\n  }\n  onClick(e) {\n    var {\n      x: t,\n      y: r\n    } = this.mapXY(e.clientX, e.clientY);\n    this.events.push({\n      type: \"onclick\",\n      x: t,\n      y: r,\n      run(i) {\n        i.onClick && i.onClick();\n      }\n    });\n  }\n  onMouseMove(e) {\n    var {\n      x: t,\n      y: r\n    } = this.mapXY(e.clientX, e.clientY);\n    this.events.push({\n      type: \"onmousemove\",\n      x: t,\n      y: r,\n      run(i) {\n        i.onMouseMove && i.onMouseMove();\n      }\n    });\n  }\n}\nvar bl = typeof window < \"u\" ? window : null,\n  xl = typeof fetch < \"u\" ? fetch.bind(void 0) : null;\nlet Dr = /*#__PURE__*/(() => {\n  class Dr {\n    constructor(e) {\n      var {\n        fetch: t = xl,\n        window: r = bl\n      } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n      this.ctx = e, this.FRAMERATE = 30, this.MAX_VIRTUAL_PIXELS = 3e4, this.CLIENT_WIDTH = 800, this.CLIENT_HEIGHT = 600, this.viewPort = new b1(), this.mouse = new x1(this), this.animations = [], this.waits = [], this.frameDuration = 0, this.isReadyLock = !1, this.isFirstRender = !0, this.intervalId = null, this.window = r, this.fetch = t;\n    }\n    wait(e) {\n      this.waits.push(e);\n    }\n    ready() {\n      return this.readyPromise ? this.readyPromise : Promise.resolve();\n    }\n    isReady() {\n      if (this.isReadyLock) return !0;\n      var e = this.waits.every(t => t());\n      return e && (this.waits = [], this.resolveReady && this.resolveReady()), this.isReadyLock = e, e;\n    }\n    setDefaults(e) {\n      e.strokeStyle = \"rgba(0,0,0,0)\", e.lineCap = \"butt\", e.lineJoin = \"miter\", e.miterLimit = 4;\n    }\n    setViewBox(e) {\n      var {\n          document: t,\n          ctx: r,\n          aspectRatio: i,\n          width: n,\n          desiredWidth: o,\n          height: s,\n          desiredHeight: u,\n          minX: l = 0,\n          minY: h = 0,\n          refX: f,\n          refY: c,\n          clip: v = !1,\n          clipX: g = 0,\n          clipY: d = 0\n        } = e,\n        p = lt(i).replace(/^defer\\s/, \"\"),\n        [y, x] = p.split(\" \"),\n        b = y || \"xMidYMid\",\n        T = x || \"meet\",\n        $ = n / o,\n        E = s / u,\n        O = Math.min($, E),\n        C = Math.max($, E),\n        P = o,\n        V = u;\n      T === \"meet\" && (P *= O, V *= O), T === \"slice\" && (P *= C, V *= C);\n      var j = new S(t, \"refX\", f),\n        R = new S(t, \"refY\", c),\n        X = j.hasValue() && R.hasValue();\n      if (X && r.translate(-O * j.getPixels(\"x\"), -O * R.getPixels(\"y\")), v) {\n        var W = O * g,\n          G = O * d;\n        r.beginPath(), r.moveTo(W, G), r.lineTo(n, G), r.lineTo(n, s), r.lineTo(W, s), r.closePath(), r.clip();\n      }\n      if (!X) {\n        var q = T === \"meet\" && O === E,\n          H = T === \"slice\" && C === E,\n          Q = T === \"meet\" && O === $,\n          N = T === \"slice\" && C === $;\n        b.startsWith(\"xMid\") && (q || H) && r.translate(n / 2 - P / 2, 0), b.endsWith(\"YMid\") && (Q || N) && r.translate(0, s / 2 - V / 2), b.startsWith(\"xMax\") && (q || H) && r.translate(n - P, 0), b.endsWith(\"YMax\") && (Q || N) && r.translate(0, s - V);\n      }\n      switch (!0) {\n        case b === \"none\":\n          r.scale($, E);\n          break;\n        case T === \"meet\":\n          r.scale(O, O);\n          break;\n        case T === \"slice\":\n          r.scale(C, C);\n          break;\n      }\n      r.translate(-l, -h);\n    }\n    start(e) {\n      var {\n          enableRedraw: t = !1,\n          ignoreMouse: r = !1,\n          ignoreAnimation: i = !1,\n          ignoreDimensions: n = !1,\n          ignoreClear: o = !1,\n          forceRedraw: s,\n          scaleWidth: u,\n          scaleHeight: l,\n          offsetX: h,\n          offsetY: f\n        } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {},\n        {\n          FRAMERATE: c,\n          mouse: v\n        } = this,\n        g = 1e3 / c;\n      if (this.frameDuration = g, this.readyPromise = new Promise(b => {\n        this.resolveReady = b;\n      }), this.isReady() && this.render(e, n, o, u, l, h, f), !!t) {\n        var d = Date.now(),\n          p = d,\n          y = 0,\n          x = () => {\n            d = Date.now(), y = d - p, y >= g && (p = d - y % g, this.shouldUpdate(i, s) && (this.render(e, n, o, u, l, h, f), v.runEvents())), this.intervalId = Fa(x);\n          };\n        r || v.start(), this.intervalId = Fa(x);\n      }\n    }\n    stop() {\n      this.intervalId && (Fa.cancel(this.intervalId), this.intervalId = null), this.mouse.stop();\n    }\n    shouldUpdate(e, t) {\n      if (!e) {\n        var {\n            frameDuration: r\n          } = this,\n          i = this.animations.reduce((n, o) => o.update(r) || n, !1);\n        if (i) return !0;\n      }\n      return !!(typeof t == \"function\" && t() || !this.isReadyLock && this.isReady() || this.mouse.hasEvents());\n    }\n    render(e, t, r, i, n, o, s) {\n      var {\n          CLIENT_WIDTH: u,\n          CLIENT_HEIGHT: l,\n          viewPort: h,\n          ctx: f,\n          isFirstRender: c\n        } = this,\n        v = f.canvas;\n      h.clear(), v.width && v.height ? h.setCurrent(v.width, v.height) : h.setCurrent(u, l);\n      var g = e.getStyle(\"width\"),\n        d = e.getStyle(\"height\");\n      !t && (c || typeof i != \"number\" && typeof n != \"number\") && (g.hasValue() && (v.width = g.getPixels(\"x\"), v.style && (v.style.width = \"\".concat(v.width, \"px\"))), d.hasValue() && (v.height = d.getPixels(\"y\"), v.style && (v.style.height = \"\".concat(v.height, \"px\"))));\n      var p = v.clientWidth || v.width,\n        y = v.clientHeight || v.height;\n      if (t && g.hasValue() && d.hasValue() && (p = g.getPixels(\"x\"), y = d.getPixels(\"y\")), h.setCurrent(p, y), typeof o == \"number\" && e.getAttribute(\"x\", !0).setValue(o), typeof s == \"number\" && e.getAttribute(\"y\", !0).setValue(s), typeof i == \"number\" || typeof n == \"number\") {\n        var x = ne(e.getAttribute(\"viewBox\").getString()),\n          b = 0,\n          T = 0;\n        if (typeof i == \"number\") {\n          var $ = e.getStyle(\"width\");\n          $.hasValue() ? b = $.getPixels(\"x\") / i : isNaN(x[2]) || (b = x[2] / i);\n        }\n        if (typeof n == \"number\") {\n          var E = e.getStyle(\"height\");\n          E.hasValue() ? T = E.getPixels(\"y\") / n : isNaN(x[3]) || (T = x[3] / n);\n        }\n        b || (b = T), T || (T = b), e.getAttribute(\"width\", !0).setValue(i), e.getAttribute(\"height\", !0).setValue(n);\n        var O = e.getStyle(\"transform\", !0, !0);\n        O.setValue(\"\".concat(O.getString(), \" scale(\").concat(1 / b, \", \").concat(1 / T, \")\"));\n      }\n      r || f.clearRect(0, 0, p, y), e.render(f), c && (this.isFirstRender = !1);\n    }\n  }\n  Dr.defaultWindow = bl;\n  Dr.defaultFetch = xl;\n  return Dr;\n})();\nvar {\n    defaultFetch: T1\n  } = Dr,\n  O1 = typeof DOMParser < \"u\" ? DOMParser : null;\nclass za {\n  constructor() {\n    var {\n      fetch: e = T1,\n      DOMParser: t = O1\n    } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};\n    this.fetch = e, this.DOMParser = t;\n  }\n  parse(e) {\n    var t = this;\n    return xe(function* () {\n      return e.startsWith(\"<\") ? t.parseFromString(e) : t.load(e);\n    })();\n  }\n  parseFromString(e) {\n    var t = new this.DOMParser();\n    try {\n      return this.checkDocument(t.parseFromString(e, \"image/svg+xml\"));\n    } catch {\n      return this.checkDocument(t.parseFromString(e, \"text/xml\"));\n    }\n  }\n  checkDocument(e) {\n    var t = e.getElementsByTagName(\"parsererror\")[0];\n    if (t) throw new Error(t.textContent);\n    return e;\n  }\n  load(e) {\n    var t = this;\n    return xe(function* () {\n      var r = yield t.fetch(e),\n        i = yield r.text();\n      return t.parseFromString(i);\n    })();\n  }\n}\nclass S1 {\n  constructor(e, t) {\n    this.type = \"translate\", this.point = null, this.point = k.parse(t);\n  }\n  apply(e) {\n    var {\n      x: t,\n      y: r\n    } = this.point;\n    e.translate(t || 0, r || 0);\n  }\n  unapply(e) {\n    var {\n      x: t,\n      y: r\n    } = this.point;\n    e.translate(-1 * t || 0, -1 * r || 0);\n  }\n  applyToPoint(e) {\n    var {\n      x: t,\n      y: r\n    } = this.point;\n    e.applyTransform([1, 0, 0, 1, t || 0, r || 0]);\n  }\n}\nclass E1 {\n  constructor(e, t, r) {\n    this.type = \"rotate\", this.angle = null, this.originX = null, this.originY = null, this.cx = 0, this.cy = 0;\n    var i = ne(t);\n    this.angle = new S(e, \"angle\", i[0]), this.originX = r[0], this.originY = r[1], this.cx = i[1] || 0, this.cy = i[2] || 0;\n  }\n  apply(e) {\n    var {\n        cx: t,\n        cy: r,\n        originX: i,\n        originY: n,\n        angle: o\n      } = this,\n      s = t + i.getPixels(\"x\"),\n      u = r + n.getPixels(\"y\");\n    e.translate(s, u), e.rotate(o.getRadians()), e.translate(-s, -u);\n  }\n  unapply(e) {\n    var {\n        cx: t,\n        cy: r,\n        originX: i,\n        originY: n,\n        angle: o\n      } = this,\n      s = t + i.getPixels(\"x\"),\n      u = r + n.getPixels(\"y\");\n    e.translate(s, u), e.rotate(-1 * o.getRadians()), e.translate(-s, -u);\n  }\n  applyToPoint(e) {\n    var {\n        cx: t,\n        cy: r,\n        angle: i\n      } = this,\n      n = i.getRadians();\n    e.applyTransform([1, 0, 0, 1, t || 0, r || 0\n    // this.p.y\n    ]), e.applyTransform([Math.cos(n), Math.sin(n), -Math.sin(n), Math.cos(n), 0, 0]), e.applyTransform([1, 0, 0, 1, -t || 0, -r || 0\n    // -this.p.y\n    ]);\n  }\n}\nclass $1 {\n  constructor(e, t, r) {\n    this.type = \"scale\", this.scale = null, this.originX = null, this.originY = null;\n    var i = k.parseScale(t);\n    (i.x === 0 || i.y === 0) && (i.x = rt, i.y = rt), this.scale = i, this.originX = r[0], this.originY = r[1];\n  }\n  apply(e) {\n    var {\n        scale: {\n          x: t,\n          y: r\n        },\n        originX: i,\n        originY: n\n      } = this,\n      o = i.getPixels(\"x\"),\n      s = n.getPixels(\"y\");\n    e.translate(o, s), e.scale(t, r || t), e.translate(-o, -s);\n  }\n  unapply(e) {\n    var {\n        scale: {\n          x: t,\n          y: r\n        },\n        originX: i,\n        originY: n\n      } = this,\n      o = i.getPixels(\"x\"),\n      s = n.getPixels(\"y\");\n    e.translate(o, s), e.scale(1 / t, 1 / r || t), e.translate(-o, -s);\n  }\n  applyToPoint(e) {\n    var {\n      x: t,\n      y: r\n    } = this.scale;\n    e.applyTransform([t || 0, 0, 0, r || 0, 0, 0]);\n  }\n}\nclass Tl {\n  constructor(e, t, r) {\n    this.type = \"matrix\", this.matrix = [], this.originX = null, this.originY = null, this.matrix = ne(t), this.originX = r[0], this.originY = r[1];\n  }\n  apply(e) {\n    var {\n        originX: t,\n        originY: r,\n        matrix: i\n      } = this,\n      n = t.getPixels(\"x\"),\n      o = r.getPixels(\"y\");\n    e.translate(n, o), e.transform(i[0], i[1], i[2], i[3], i[4], i[5]), e.translate(-n, -o);\n  }\n  unapply(e) {\n    var {\n        originX: t,\n        originY: r,\n        matrix: i\n      } = this,\n      n = i[0],\n      o = i[2],\n      s = i[4],\n      u = i[1],\n      l = i[3],\n      h = i[5],\n      f = 0,\n      c = 0,\n      v = 1,\n      g = 1 / (n * (l * v - h * c) - o * (u * v - h * f) + s * (u * c - l * f)),\n      d = t.getPixels(\"x\"),\n      p = r.getPixels(\"y\");\n    e.translate(d, p), e.transform(g * (l * v - h * c), g * (h * f - u * v), g * (s * c - o * v), g * (n * v - s * f), g * (o * h - s * l), g * (s * u - n * h)), e.translate(-d, -p);\n  }\n  applyToPoint(e) {\n    e.applyTransform(this.matrix);\n  }\n}\nclass Ol extends Tl {\n  constructor(e, t, r) {\n    super(e, t, r), this.type = \"skew\", this.angle = null, this.angle = new S(e, \"angle\", t);\n  }\n}\nclass w1 extends Ol {\n  constructor(e, t, r) {\n    super(e, t, r), this.type = \"skewX\", this.matrix = [1, 0, Math.tan(this.angle.getRadians()), 1, 0, 0];\n  }\n}\nclass C1 extends Ol {\n  constructor(e, t, r) {\n    super(e, t, r), this.type = \"skewY\", this.matrix = [1, Math.tan(this.angle.getRadians()), 0, 1, 0, 0];\n  }\n}\nfunction A1(a) {\n  return lt(a).trim().replace(/\\)([a-zA-Z])/g, \") $1\").replace(/\\)(\\s?,\\s?)/g, \") \").split(/\\s(?=[a-z])/);\n}\nfunction P1(a) {\n  var [e, t] = a.split(\"(\");\n  return [e.trim(), t.trim().replace(\")\", \"\")];\n}\nlet Be = /*#__PURE__*/(() => {\n  class Be {\n    constructor(e, t, r) {\n      this.document = e, this.transforms = [];\n      var i = A1(t);\n      i.forEach(n => {\n        if (n !== \"none\") {\n          var [o, s] = P1(n),\n            u = Be.transformTypes[o];\n          typeof u < \"u\" && this.transforms.push(new u(this.document, s, r));\n        }\n      });\n    }\n    static fromElement(e, t) {\n      var r = t.getStyle(\"transform\", !1, !0),\n        [i, n = i] = t.getStyle(\"transform-origin\", !1, !0).split(),\n        o = [i, n];\n      return r.hasValue() ? new Be(e, r.getString(), o) : null;\n    }\n    apply(e) {\n      for (var {\n          transforms: t\n        } = this, r = t.length, i = 0; i < r; i++) t[i].apply(e);\n    }\n    unapply(e) {\n      for (var {\n          transforms: t\n        } = this, r = t.length, i = r - 1; i >= 0; i--) t[i].unapply(e);\n    }\n    // TODO: applyToPoint unused ... remove?\n    applyToPoint(e) {\n      for (var {\n          transforms: t\n        } = this, r = t.length, i = 0; i < r; i++) t[i].applyToPoint(e);\n    }\n  }\n  Be.transformTypes = {\n    translate: S1,\n    rotate: E1,\n    scale: $1,\n    matrix: Tl,\n    skewX: w1,\n    skewY: C1\n  };\n  return Be;\n})();\nlet I = /*#__PURE__*/(() => {\n  class I {\n    constructor(e, t) {\n      var r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !1;\n      if (this.document = e, this.node = t, this.captureTextNodes = r, this.attributes = /* @__PURE__ */Object.create(null), this.styles = /* @__PURE__ */Object.create(null), this.stylesSpecificity = /* @__PURE__ */Object.create(null), this.animationFrozen = !1, this.animationFrozenValue = \"\", this.parent = null, this.children = [], !(!t || t.nodeType !== 1)) {\n        if (Array.from(t.attributes).forEach(s => {\n          var u = l1(s.nodeName);\n          this.attributes[u] = new S(e, u, s.value);\n        }), this.addStylesFromStyleDefinition(), this.getAttribute(\"style\").hasValue()) {\n          var i = this.getAttribute(\"style\").getString().split(\";\").map(s => s.trim());\n          i.forEach(s => {\n            if (s) {\n              var [u, l] = s.split(\":\").map(h => h.trim());\n              this.styles[u] = new S(e, u, l);\n            }\n          });\n        }\n        var {\n            definitions: n\n          } = e,\n          o = this.getAttribute(\"id\");\n        o.hasValue() && (n[o.getString()] || (n[o.getString()] = this)), Array.from(t.childNodes).forEach(s => {\n          if (s.nodeType === 1) this.addChild(s);else if (r && (s.nodeType === 3 || s.nodeType === 4)) {\n            var u = e.createTextNode(s);\n            u.getText().length > 0 && this.addChild(u);\n          }\n        });\n      }\n    }\n    getAttribute(e) {\n      var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1,\n        r = this.attributes[e];\n      if (!r && t) {\n        var i = new S(this.document, e, \"\");\n        return this.attributes[e] = i, i;\n      }\n      return r || S.empty(this.document);\n    }\n    getHrefAttribute() {\n      for (var e in this.attributes) if (e === \"href\" || e.endsWith(\":href\")) return this.attributes[e];\n      return S.empty(this.document);\n    }\n    getStyle(e) {\n      var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1,\n        r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !1,\n        i = this.styles[e];\n      if (i) return i;\n      var n = this.getAttribute(e);\n      if (n != null && n.hasValue()) return this.styles[e] = n, n;\n      if (!r) {\n        var {\n          parent: o\n        } = this;\n        if (o) {\n          var s = o.getStyle(e);\n          if (s != null && s.hasValue()) return s;\n        }\n      }\n      if (t) {\n        var u = new S(this.document, e, \"\");\n        return this.styles[e] = u, u;\n      }\n      return i || S.empty(this.document);\n    }\n    render(e) {\n      if (!(this.getStyle(\"display\").getString() === \"none\" || this.getStyle(\"visibility\").getString() === \"hidden\")) {\n        if (e.save(), this.getStyle(\"mask\").hasValue()) {\n          var t = this.getStyle(\"mask\").getDefinition();\n          t && (this.applyEffects(e), t.apply(e, this));\n        } else if (this.getStyle(\"filter\").getValue(\"none\") !== \"none\") {\n          var r = this.getStyle(\"filter\").getDefinition();\n          r && (this.applyEffects(e), r.apply(e, this));\n        } else this.setContext(e), this.renderChildren(e), this.clearContext(e);\n        e.restore();\n      }\n    }\n    setContext(e) {}\n    applyEffects(e) {\n      var t = Be.fromElement(this.document, this);\n      t && t.apply(e);\n      var r = this.getStyle(\"clip-path\", !1, !0);\n      if (r.hasValue()) {\n        var i = r.getDefinition();\n        i && i.apply(e);\n      }\n    }\n    clearContext(e) {}\n    renderChildren(e) {\n      this.children.forEach(t => {\n        t.render(e);\n      });\n    }\n    addChild(e) {\n      var t = e instanceof I ? e : this.document.createElement(e);\n      t.parent = this, I.ignoreChildTypes.includes(t.type) || this.children.push(t);\n    }\n    matchesSelector(e) {\n      var t,\n        {\n          node: r\n        } = this;\n      if (typeof r.matches == \"function\") return r.matches(e);\n      var i = (t = r.getAttribute) === null || t === void 0 ? void 0 : t.call(r, \"class\");\n      return !i || i === \"\" ? !1 : i.split(\" \").some(n => \".\".concat(n) === e);\n    }\n    addStylesFromStyleDefinition() {\n      var {\n        styles: e,\n        stylesSpecificity: t\n      } = this.document;\n      for (var r in e) if (!r.startsWith(\"@\") && this.matchesSelector(r)) {\n        var i = e[r],\n          n = t[r];\n        if (i) for (var o in i) {\n          var s = this.stylesSpecificity[o];\n          typeof s > \"u\" && (s = \"000\"), n >= s && (this.styles[o] = i[o], this.stylesSpecificity[o] = n);\n        }\n      }\n    }\n    removeStyles(e, t) {\n      var r = t.reduce((i, n) => {\n        var o = e.getStyle(n);\n        if (!o.hasValue()) return i;\n        var s = o.getString();\n        return o.setValue(\"\"), [...i, [n, s]];\n      }, []);\n      return r;\n    }\n    restoreStyles(e, t) {\n      t.forEach(r => {\n        var [i, n] = r;\n        e.getStyle(i, !0).setValue(n);\n      });\n    }\n    isFirstChild() {\n      var e;\n      return ((e = this.parent) === null || e === void 0 ? void 0 : e.children.indexOf(this)) === 0;\n    }\n  }\n  I.ignoreChildTypes = [\"title\"];\n  return I;\n})();\nclass R1 extends I {\n  constructor(e, t, r) {\n    super(e, t, r);\n  }\n}\nfunction N1(a) {\n  var e = a.trim();\n  return /^('|\")/.test(e) ? e : '\"'.concat(e, '\"');\n}\nfunction I1(a) {\n  return typeof process > \"u\" ? a : a.trim().split(\",\").map(N1).join(\",\");\n}\nfunction M1(a) {\n  if (!a) return \"\";\n  var e = a.trim().toLowerCase();\n  switch (e) {\n    case \"normal\":\n    case \"italic\":\n    case \"oblique\":\n    case \"inherit\":\n    case \"initial\":\n    case \"unset\":\n      return e;\n    default:\n      return /^oblique\\s+(-|)\\d+deg$/.test(e) ? e : \"\";\n  }\n}\nfunction _1(a) {\n  if (!a) return \"\";\n  var e = a.trim().toLowerCase();\n  switch (e) {\n    case \"normal\":\n    case \"bold\":\n    case \"lighter\":\n    case \"bolder\":\n    case \"inherit\":\n    case \"initial\":\n    case \"unset\":\n      return e;\n    default:\n      return /^[\\d.]+$/.test(e) ? e : \"\";\n  }\n}\nlet Z = /*#__PURE__*/(() => {\n  class Z {\n    constructor(e, t, r, i, n, o) {\n      var s = o ? typeof o == \"string\" ? Z.parse(o) : o : {};\n      this.fontFamily = n || s.fontFamily, this.fontSize = i || s.fontSize, this.fontStyle = e || s.fontStyle, this.fontWeight = r || s.fontWeight, this.fontVariant = t || s.fontVariant;\n    }\n    static parse() {\n      var e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : \"\",\n        t = arguments.length > 1 ? arguments[1] : void 0,\n        r = \"\",\n        i = \"\",\n        n = \"\",\n        o = \"\",\n        s = \"\",\n        u = lt(e).trim().split(\" \"),\n        l = {\n          fontSize: !1,\n          fontStyle: !1,\n          fontWeight: !1,\n          fontVariant: !1\n        };\n      return u.forEach(h => {\n        switch (!0) {\n          case !l.fontStyle && Z.styles.includes(h):\n            h !== \"inherit\" && (r = h), l.fontStyle = !0;\n            break;\n          case !l.fontVariant && Z.variants.includes(h):\n            h !== \"inherit\" && (i = h), l.fontStyle = !0, l.fontVariant = !0;\n            break;\n          case !l.fontWeight && Z.weights.includes(h):\n            h !== \"inherit\" && (n = h), l.fontStyle = !0, l.fontVariant = !0, l.fontWeight = !0;\n            break;\n          case !l.fontSize:\n            h !== \"inherit\" && ([o] = h.split(\"/\")), l.fontStyle = !0, l.fontVariant = !0, l.fontWeight = !0, l.fontSize = !0;\n            break;\n          default:\n            h !== \"inherit\" && (s += h);\n        }\n      }), new Z(r, i, n, o, s, t);\n    }\n    toString() {\n      return [M1(this.fontStyle), this.fontVariant, _1(this.fontWeight), this.fontSize,\n      // Wrap fontFamily only on nodejs and only for canvas.ctx\n      I1(this.fontFamily)].join(\" \").trim();\n    }\n  }\n  Z.styles = \"normal|italic|oblique|inherit\";\n  Z.variants = \"normal|small-caps|inherit\";\n  Z.weights = \"normal|bold|bolder|lighter|100|200|300|400|500|600|700|800|900|inherit\";\n  return Z;\n})();\nclass ce {\n  constructor() {\n    var e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : Number.NaN,\n      t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : Number.NaN,\n      r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : Number.NaN,\n      i = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : Number.NaN;\n    this.x1 = e, this.y1 = t, this.x2 = r, this.y2 = i, this.addPoint(e, t), this.addPoint(r, i);\n  }\n  get x() {\n    return this.x1;\n  }\n  get y() {\n    return this.y1;\n  }\n  get width() {\n    return this.x2 - this.x1;\n  }\n  get height() {\n    return this.y2 - this.y1;\n  }\n  addPoint(e, t) {\n    typeof e < \"u\" && ((isNaN(this.x1) || isNaN(this.x2)) && (this.x1 = e, this.x2 = e), e < this.x1 && (this.x1 = e), e > this.x2 && (this.x2 = e)), typeof t < \"u\" && ((isNaN(this.y1) || isNaN(this.y2)) && (this.y1 = t, this.y2 = t), t < this.y1 && (this.y1 = t), t > this.y2 && (this.y2 = t));\n  }\n  addX(e) {\n    this.addPoint(e, null);\n  }\n  addY(e) {\n    this.addPoint(null, e);\n  }\n  addBoundingBox(e) {\n    if (e) {\n      var {\n        x1: t,\n        y1: r,\n        x2: i,\n        y2: n\n      } = e;\n      this.addPoint(t, r), this.addPoint(i, n);\n    }\n  }\n  sumCubic(e, t, r, i, n) {\n    return Math.pow(1 - e, 3) * t + 3 * Math.pow(1 - e, 2) * e * r + 3 * (1 - e) * Math.pow(e, 2) * i + Math.pow(e, 3) * n;\n  }\n  bezierCurveAdd(e, t, r, i, n) {\n    var o = 6 * t - 12 * r + 6 * i,\n      s = -3 * t + 9 * r - 9 * i + 3 * n,\n      u = 3 * r - 3 * t;\n    if (s === 0) {\n      if (o === 0) return;\n      var l = -u / o;\n      0 < l && l < 1 && (e ? this.addX(this.sumCubic(l, t, r, i, n)) : this.addY(this.sumCubic(l, t, r, i, n)));\n      return;\n    }\n    var h = Math.pow(o, 2) - 4 * u * s;\n    if (!(h < 0)) {\n      var f = (-o + Math.sqrt(h)) / (2 * s);\n      0 < f && f < 1 && (e ? this.addX(this.sumCubic(f, t, r, i, n)) : this.addY(this.sumCubic(f, t, r, i, n)));\n      var c = (-o - Math.sqrt(h)) / (2 * s);\n      0 < c && c < 1 && (e ? this.addX(this.sumCubic(c, t, r, i, n)) : this.addY(this.sumCubic(c, t, r, i, n)));\n    }\n  }\n  // from http://blog.hackers-cafe.net/2009/06/how-to-calculate-bezier-curves-bounding.html\n  addBezierCurve(e, t, r, i, n, o, s, u) {\n    this.addPoint(e, t), this.addPoint(s, u), this.bezierCurveAdd(!0, e, r, n, s), this.bezierCurveAdd(!1, t, i, o, u);\n  }\n  addQuadraticCurve(e, t, r, i, n, o) {\n    var s = e + 0.6666666666666666 * (r - e),\n      u = t + 2 / 3 * (i - t),\n      l = s + 1 / 3 * (n - e),\n      h = u + 1 / 3 * (o - t);\n    this.addBezierCurve(e, t, s, l, u, h, n, o);\n  }\n  isPointInBox(e, t) {\n    var {\n      x1: r,\n      y1: i,\n      x2: n,\n      y2: o\n    } = this;\n    return r <= e && e <= n && i <= t && t <= o;\n  }\n}\nclass w extends m {\n  constructor(e) {\n    super(e.replace(/([+\\-.])\\s+/gm, \"$1\").replace(/[^MmZzLlHhVvCcSsQqTtAae\\d\\s.,+-].*/g, \"\")), this.control = null, this.start = null, this.current = null, this.command = null, this.commands = this.commands, this.i = -1, this.previousCommand = null, this.points = [], this.angles = [];\n  }\n  reset() {\n    this.i = -1, this.command = null, this.previousCommand = null, this.start = new k(0, 0), this.control = new k(0, 0), this.current = new k(0, 0), this.points = [], this.angles = [];\n  }\n  isEnd() {\n    var {\n      i: e,\n      commands: t\n    } = this;\n    return e >= t.length - 1;\n  }\n  next() {\n    var e = this.commands[++this.i];\n    return this.previousCommand = this.command, this.command = e, e;\n  }\n  getPoint() {\n    var e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : \"x\",\n      t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : \"y\",\n      r = new k(this.command[e], this.command[t]);\n    return this.makeAbsolute(r);\n  }\n  getAsControlPoint(e, t) {\n    var r = this.getPoint(e, t);\n    return this.control = r, r;\n  }\n  getAsCurrentPoint(e, t) {\n    var r = this.getPoint(e, t);\n    return this.current = r, r;\n  }\n  getReflectedControlPoint() {\n    var e = this.previousCommand.type;\n    if (e !== m.CURVE_TO && e !== m.SMOOTH_CURVE_TO && e !== m.QUAD_TO && e !== m.SMOOTH_QUAD_TO) return this.current;\n    var {\n        current: {\n          x: t,\n          y: r\n        },\n        control: {\n          x: i,\n          y: n\n        }\n      } = this,\n      o = new k(2 * t - i, 2 * r - n);\n    return o;\n  }\n  makeAbsolute(e) {\n    if (this.command.relative) {\n      var {\n        x: t,\n        y: r\n      } = this.current;\n      e.x += t, e.y += r;\n    }\n    return e;\n  }\n  addMarker(e, t, r) {\n    var {\n      points: i,\n      angles: n\n    } = this;\n    r && n.length > 0 && !n[n.length - 1] && (n[n.length - 1] = i[i.length - 1].angleTo(r)), this.addMarkerAngle(e, t ? t.angleTo(e) : null);\n  }\n  addMarkerAngle(e, t) {\n    this.points.push(e), this.angles.push(t);\n  }\n  getMarkerPoints() {\n    return this.points;\n  }\n  getMarkerAngles() {\n    for (var {\n        angles: e\n      } = this, t = e.length, r = 0; r < t; r++) if (!e[r]) {\n      for (var i = r + 1; i < t; i++) if (e[i]) {\n        e[r] = e[i];\n        break;\n      }\n    }\n    return e;\n  }\n}\nclass Ge extends I {\n  constructor() {\n    super(...arguments), this.modifiedEmSizeStack = !1;\n  }\n  calculateOpacity() {\n    for (var e = 1, t = this; t;) {\n      var r = t.getStyle(\"opacity\", !1, !0);\n      r.hasValue(!0) && (e *= r.getNumber()), t = t.parent;\n    }\n    return e;\n  }\n  setContext(e) {\n    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1;\n    if (!t) {\n      var r = this.getStyle(\"fill\"),\n        i = this.getStyle(\"fill-opacity\"),\n        n = this.getStyle(\"stroke\"),\n        o = this.getStyle(\"stroke-opacity\");\n      if (r.isUrlDefinition()) {\n        var s = r.getFillStyleDefinition(this, i);\n        s && (e.fillStyle = s);\n      } else if (r.hasValue()) {\n        r.getString() === \"currentColor\" && r.setValue(this.getStyle(\"color\").getColor());\n        var u = r.getColor();\n        u !== \"inherit\" && (e.fillStyle = u === \"none\" ? \"rgba(0,0,0,0)\" : u);\n      }\n      if (i.hasValue()) {\n        var l = new S(this.document, \"fill\", e.fillStyle).addOpacity(i).getColor();\n        e.fillStyle = l;\n      }\n      if (n.isUrlDefinition()) {\n        var h = n.getFillStyleDefinition(this, o);\n        h && (e.strokeStyle = h);\n      } else if (n.hasValue()) {\n        n.getString() === \"currentColor\" && n.setValue(this.getStyle(\"color\").getColor());\n        var f = n.getString();\n        f !== \"inherit\" && (e.strokeStyle = f === \"none\" ? \"rgba(0,0,0,0)\" : f);\n      }\n      if (o.hasValue()) {\n        var c = new S(this.document, \"stroke\", e.strokeStyle).addOpacity(o).getString();\n        e.strokeStyle = c;\n      }\n      var v = this.getStyle(\"stroke-width\");\n      if (v.hasValue()) {\n        var g = v.getPixels();\n        e.lineWidth = g || rt;\n      }\n      var d = this.getStyle(\"stroke-linecap\"),\n        p = this.getStyle(\"stroke-linejoin\"),\n        y = this.getStyle(\"stroke-miterlimit\"),\n        x = this.getStyle(\"stroke-dasharray\"),\n        b = this.getStyle(\"stroke-dashoffset\");\n      if (d.hasValue() && (e.lineCap = d.getString()), p.hasValue() && (e.lineJoin = p.getString()), y.hasValue() && (e.miterLimit = y.getNumber()), x.hasValue() && x.getString() !== \"none\") {\n        var T = ne(x.getString());\n        typeof e.setLineDash < \"u\" ? e.setLineDash(T) : typeof e.webkitLineDash < \"u\" ? e.webkitLineDash = T : typeof e.mozDash < \"u\" && !(T.length === 1 && T[0] === 0) && (e.mozDash = T);\n        var $ = b.getPixels();\n        typeof e.lineDashOffset < \"u\" ? e.lineDashOffset = $ : typeof e.webkitLineDashOffset < \"u\" ? e.webkitLineDashOffset = $ : typeof e.mozDashOffset < \"u\" && (e.mozDashOffset = $);\n      }\n    }\n    if (this.modifiedEmSizeStack = !1, typeof e.font < \"u\") {\n      var E = this.getStyle(\"font\"),\n        O = this.getStyle(\"font-style\"),\n        C = this.getStyle(\"font-variant\"),\n        P = this.getStyle(\"font-weight\"),\n        V = this.getStyle(\"font-size\"),\n        j = this.getStyle(\"font-family\"),\n        R = new Z(O.getString(), C.getString(), P.getString(), V.hasValue() ? \"\".concat(V.getPixels(!0), \"px\") : \"\", j.getString(), Z.parse(E.getString(), e.font));\n      O.setValue(R.fontStyle), C.setValue(R.fontVariant), P.setValue(R.fontWeight), V.setValue(R.fontSize), j.setValue(R.fontFamily), e.font = R.toString(), V.isPixels() && (this.document.emSize = V.getPixels(), this.modifiedEmSizeStack = !0);\n    }\n    t || (this.applyEffects(e), e.globalAlpha = this.calculateOpacity());\n  }\n  clearContext(e) {\n    super.clearContext(e), this.modifiedEmSizeStack && this.document.popEmSize();\n  }\n}\nclass A extends Ge {\n  constructor(e, t, r) {\n    super(e, t, r), this.type = \"path\", this.pathParser = null, this.pathParser = new w(this.getAttribute(\"d\").getString());\n  }\n  path(e) {\n    var {\n        pathParser: t\n      } = this,\n      r = new ce();\n    for (t.reset(), e && e.beginPath(); !t.isEnd();) switch (t.next().type) {\n      case w.MOVE_TO:\n        this.pathM(e, r);\n        break;\n      case w.LINE_TO:\n        this.pathL(e, r);\n        break;\n      case w.HORIZ_LINE_TO:\n        this.pathH(e, r);\n        break;\n      case w.VERT_LINE_TO:\n        this.pathV(e, r);\n        break;\n      case w.CURVE_TO:\n        this.pathC(e, r);\n        break;\n      case w.SMOOTH_CURVE_TO:\n        this.pathS(e, r);\n        break;\n      case w.QUAD_TO:\n        this.pathQ(e, r);\n        break;\n      case w.SMOOTH_QUAD_TO:\n        this.pathT(e, r);\n        break;\n      case w.ARC:\n        this.pathA(e, r);\n        break;\n      case w.CLOSE_PATH:\n        this.pathZ(e, r);\n        break;\n    }\n    return r;\n  }\n  getBoundingBox(e) {\n    return this.path();\n  }\n  getMarkers() {\n    var {\n        pathParser: e\n      } = this,\n      t = e.getMarkerPoints(),\n      r = e.getMarkerAngles(),\n      i = t.map((n, o) => [n, r[o]]);\n    return i;\n  }\n  renderChildren(e) {\n    this.path(e), this.document.screen.mouse.checkPath(this, e);\n    var t = this.getStyle(\"fill-rule\");\n    e.fillStyle !== \"\" && (t.getString(\"inherit\") !== \"inherit\" ? e.fill(t.getString()) : e.fill()), e.strokeStyle !== \"\" && (this.getAttribute(\"vector-effect\").getString() === \"non-scaling-stroke\" ? (e.save(), e.setTransform(1, 0, 0, 1, 0, 0), e.stroke(), e.restore()) : e.stroke());\n    var r = this.getMarkers();\n    if (r) {\n      var i = r.length - 1,\n        n = this.getStyle(\"marker-start\"),\n        o = this.getStyle(\"marker-mid\"),\n        s = this.getStyle(\"marker-end\");\n      if (n.isUrlDefinition()) {\n        var u = n.getDefinition(),\n          [l, h] = r[0];\n        u.render(e, l, h);\n      }\n      if (o.isUrlDefinition()) for (var f = o.getDefinition(), c = 1; c < i; c++) {\n        var [v, g] = r[c];\n        f.render(e, v, g);\n      }\n      if (s.isUrlDefinition()) {\n        var d = s.getDefinition(),\n          [p, y] = r[i];\n        d.render(e, p, y);\n      }\n    }\n  }\n  static pathM(e) {\n    var t = e.getAsCurrentPoint();\n    return e.start = e.current, {\n      point: t\n    };\n  }\n  pathM(e, t) {\n    var {\n        pathParser: r\n      } = this,\n      {\n        point: i\n      } = A.pathM(r),\n      {\n        x: n,\n        y: o\n      } = i;\n    r.addMarker(i), t.addPoint(n, o), e && e.moveTo(n, o);\n  }\n  static pathL(e) {\n    var {\n        current: t\n      } = e,\n      r = e.getAsCurrentPoint();\n    return {\n      current: t,\n      point: r\n    };\n  }\n  pathL(e, t) {\n    var {\n        pathParser: r\n      } = this,\n      {\n        current: i,\n        point: n\n      } = A.pathL(r),\n      {\n        x: o,\n        y: s\n      } = n;\n    r.addMarker(n, i), t.addPoint(o, s), e && e.lineTo(o, s);\n  }\n  static pathH(e) {\n    var {\n        current: t,\n        command: r\n      } = e,\n      i = new k((r.relative ? t.x : 0) + r.x, t.y);\n    return e.current = i, {\n      current: t,\n      point: i\n    };\n  }\n  pathH(e, t) {\n    var {\n        pathParser: r\n      } = this,\n      {\n        current: i,\n        point: n\n      } = A.pathH(r),\n      {\n        x: o,\n        y: s\n      } = n;\n    r.addMarker(n, i), t.addPoint(o, s), e && e.lineTo(o, s);\n  }\n  static pathV(e) {\n    var {\n        current: t,\n        command: r\n      } = e,\n      i = new k(t.x, (r.relative ? t.y : 0) + r.y);\n    return e.current = i, {\n      current: t,\n      point: i\n    };\n  }\n  pathV(e, t) {\n    var {\n        pathParser: r\n      } = this,\n      {\n        current: i,\n        point: n\n      } = A.pathV(r),\n      {\n        x: o,\n        y: s\n      } = n;\n    r.addMarker(n, i), t.addPoint(o, s), e && e.lineTo(o, s);\n  }\n  static pathC(e) {\n    var {\n        current: t\n      } = e,\n      r = e.getPoint(\"x1\", \"y1\"),\n      i = e.getAsControlPoint(\"x2\", \"y2\"),\n      n = e.getAsCurrentPoint();\n    return {\n      current: t,\n      point: r,\n      controlPoint: i,\n      currentPoint: n\n    };\n  }\n  pathC(e, t) {\n    var {\n        pathParser: r\n      } = this,\n      {\n        current: i,\n        point: n,\n        controlPoint: o,\n        currentPoint: s\n      } = A.pathC(r);\n    r.addMarker(s, o, n), t.addBezierCurve(i.x, i.y, n.x, n.y, o.x, o.y, s.x, s.y), e && e.bezierCurveTo(n.x, n.y, o.x, o.y, s.x, s.y);\n  }\n  static pathS(e) {\n    var {\n        current: t\n      } = e,\n      r = e.getReflectedControlPoint(),\n      i = e.getAsControlPoint(\"x2\", \"y2\"),\n      n = e.getAsCurrentPoint();\n    return {\n      current: t,\n      point: r,\n      controlPoint: i,\n      currentPoint: n\n    };\n  }\n  pathS(e, t) {\n    var {\n        pathParser: r\n      } = this,\n      {\n        current: i,\n        point: n,\n        controlPoint: o,\n        currentPoint: s\n      } = A.pathS(r);\n    r.addMarker(s, o, n), t.addBezierCurve(i.x, i.y, n.x, n.y, o.x, o.y, s.x, s.y), e && e.bezierCurveTo(n.x, n.y, o.x, o.y, s.x, s.y);\n  }\n  static pathQ(e) {\n    var {\n        current: t\n      } = e,\n      r = e.getAsControlPoint(\"x1\", \"y1\"),\n      i = e.getAsCurrentPoint();\n    return {\n      current: t,\n      controlPoint: r,\n      currentPoint: i\n    };\n  }\n  pathQ(e, t) {\n    var {\n        pathParser: r\n      } = this,\n      {\n        current: i,\n        controlPoint: n,\n        currentPoint: o\n      } = A.pathQ(r);\n    r.addMarker(o, n, n), t.addQuadraticCurve(i.x, i.y, n.x, n.y, o.x, o.y), e && e.quadraticCurveTo(n.x, n.y, o.x, o.y);\n  }\n  static pathT(e) {\n    var {\n        current: t\n      } = e,\n      r = e.getReflectedControlPoint();\n    e.control = r;\n    var i = e.getAsCurrentPoint();\n    return {\n      current: t,\n      controlPoint: r,\n      currentPoint: i\n    };\n  }\n  pathT(e, t) {\n    var {\n        pathParser: r\n      } = this,\n      {\n        current: i,\n        controlPoint: n,\n        currentPoint: o\n      } = A.pathT(r);\n    r.addMarker(o, n, n), t.addQuadraticCurve(i.x, i.y, n.x, n.y, o.x, o.y), e && e.quadraticCurveTo(n.x, n.y, o.x, o.y);\n  }\n  static pathA(e) {\n    var {\n        current: t,\n        command: r\n      } = e,\n      {\n        rX: i,\n        rY: n,\n        xRot: o,\n        lArcFlag: s,\n        sweepFlag: u\n      } = r,\n      l = o * (Math.PI / 180),\n      h = e.getAsCurrentPoint(),\n      f = new k(Math.cos(l) * (t.x - h.x) / 2 + Math.sin(l) * (t.y - h.y) / 2, -Math.sin(l) * (t.x - h.x) / 2 + Math.cos(l) * (t.y - h.y) / 2),\n      c = Math.pow(f.x, 2) / Math.pow(i, 2) + Math.pow(f.y, 2) / Math.pow(n, 2);\n    c > 1 && (i *= Math.sqrt(c), n *= Math.sqrt(c));\n    var v = (s === u ? -1 : 1) * Math.sqrt((Math.pow(i, 2) * Math.pow(n, 2) - Math.pow(i, 2) * Math.pow(f.y, 2) - Math.pow(n, 2) * Math.pow(f.x, 2)) / (Math.pow(i, 2) * Math.pow(f.y, 2) + Math.pow(n, 2) * Math.pow(f.x, 2)));\n    isNaN(v) && (v = 0);\n    var g = new k(v * i * f.y / n, v * -n * f.x / i),\n      d = new k((t.x + h.x) / 2 + Math.cos(l) * g.x - Math.sin(l) * g.y, (t.y + h.y) / 2 + Math.sin(l) * g.x + Math.cos(l) * g.y),\n      p = $o([1, 0], [(f.x - g.x) / i, (f.y - g.y) / n]),\n      y = [(f.x - g.x) / i, (f.y - g.y) / n],\n      x = [(-f.x - g.x) / i, (-f.y - g.y) / n],\n      b = $o(y, x);\n    return xi(y, x) <= -1 && (b = Math.PI), xi(y, x) >= 1 && (b = 0), {\n      currentPoint: h,\n      rX: i,\n      rY: n,\n      sweepFlag: u,\n      xAxisRotation: l,\n      centp: d,\n      a1: p,\n      ad: b\n    };\n  }\n  pathA(e, t) {\n    var {\n        pathParser: r\n      } = this,\n      {\n        currentPoint: i,\n        rX: n,\n        rY: o,\n        sweepFlag: s,\n        xAxisRotation: u,\n        centp: l,\n        a1: h,\n        ad: f\n      } = A.pathA(r),\n      c = 1 - s ? 1 : -1,\n      v = h + c * (f / 2),\n      g = new k(l.x + n * Math.cos(v), l.y + o * Math.sin(v));\n    if (r.addMarkerAngle(g, v - c * Math.PI / 2), r.addMarkerAngle(i, v - c * Math.PI), t.addPoint(i.x, i.y), e && !isNaN(h) && !isNaN(f)) {\n      var d = n > o ? n : o,\n        p = n > o ? 1 : n / o,\n        y = n > o ? o / n : 1;\n      e.translate(l.x, l.y), e.rotate(u), e.scale(p, y), e.arc(0, 0, d, h, h + f, !!(1 - s)), e.scale(1 / p, 1 / y), e.rotate(-u), e.translate(-l.x, -l.y);\n    }\n  }\n  static pathZ(e) {\n    e.current = e.start;\n  }\n  pathZ(e, t) {\n    A.pathZ(this.pathParser), e && t.x1 !== t.x2 && t.y1 !== t.y2 && e.closePath();\n  }\n}\nclass Sl extends A {\n  constructor(e, t, r) {\n    super(e, t, r), this.type = \"glyph\", this.horizAdvX = this.getAttribute(\"horiz-adv-x\").getNumber(), this.unicode = this.getAttribute(\"unicode\").getString(), this.arabicForm = this.getAttribute(\"arabic-form\").getString();\n  }\n}\nclass Ce extends Ge {\n  constructor(e, t, r) {\n    super(e, t, new.target === Ce ? !0 : r), this.type = \"text\", this.x = 0, this.y = 0, this.measureCache = -1;\n  }\n  setContext(e) {\n    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1;\n    super.setContext(e, t);\n    var r = this.getStyle(\"dominant-baseline\").getTextBaseline() || this.getStyle(\"alignment-baseline\").getTextBaseline();\n    r && (e.textBaseline = r);\n  }\n  initializeCoordinates() {\n    this.x = 0, this.y = 0, this.leafTexts = [], this.textChunkStart = 0, this.minX = Number.POSITIVE_INFINITY, this.maxX = Number.NEGATIVE_INFINITY;\n  }\n  getBoundingBox(e) {\n    if (this.type !== \"text\") return this.getTElementBoundingBox(e);\n    this.initializeCoordinates(), this.adjustChildCoordinatesRecursive(e);\n    var t = null;\n    return this.children.forEach((r, i) => {\n      var n = this.getChildBoundingBox(e, this, this, i);\n      t ? t.addBoundingBox(n) : t = n;\n    }), t;\n  }\n  getFontSize() {\n    var {\n        document: e,\n        parent: t\n      } = this,\n      r = Z.parse(e.ctx.font).fontSize,\n      i = t.getStyle(\"font-size\").getNumber(r);\n    return i;\n  }\n  getTElementBoundingBox(e) {\n    var t = this.getFontSize();\n    return new ce(this.x, this.y - t, this.x + this.measureText(e), this.y);\n  }\n  getGlyph(e, t, r) {\n    var i = t[r],\n      n = null;\n    if (e.isArabic) {\n      var o = t.length,\n        s = t[r - 1],\n        u = t[r + 1],\n        l = \"isolated\";\n      if ((r === 0 || s === \" \") && r < o - 1 && u !== \" \" && (l = \"terminal\"), r > 0 && s !== \" \" && r < o - 1 && u !== \" \" && (l = \"medial\"), r > 0 && s !== \" \" && (r === o - 1 || u === \" \") && (l = \"initial\"), typeof e.glyphs[i] < \"u\") {\n        var h = e.glyphs[i];\n        n = h instanceof Sl ? h : h[l];\n      }\n    } else n = e.glyphs[i];\n    return n || (n = e.missingGlyph), n;\n  }\n  getText() {\n    return \"\";\n  }\n  getTextFromNode(e) {\n    var t = e || this.node,\n      r = Array.from(t.parentNode.childNodes),\n      i = r.indexOf(t),\n      n = r.length - 1,\n      o = lt(\n      // textNode.value\n      // || textNode.text\n      t.textContent || \"\");\n    return i === 0 && (o = s1(o)), i === n && (o = o1(o)), o;\n  }\n  renderChildren(e) {\n    if (this.type !== \"text\") {\n      this.renderTElementChildren(e);\n      return;\n    }\n    this.initializeCoordinates(), this.adjustChildCoordinatesRecursive(e), this.children.forEach((r, i) => {\n      this.renderChild(e, this, this, i);\n    });\n    var {\n      mouse: t\n    } = this.document.screen;\n    t.isWorking() && t.checkBoundingBox(this, this.getBoundingBox(e));\n  }\n  renderTElementChildren(e) {\n    var {\n        document: t,\n        parent: r\n      } = this,\n      i = this.getText(),\n      n = r.getStyle(\"font-family\").getDefinition();\n    if (n) {\n      for (var {\n          unitsPerEm: o\n        } = n.fontFace, s = Z.parse(t.ctx.font), u = r.getStyle(\"font-size\").getNumber(s.fontSize), l = r.getStyle(\"font-style\").getString(s.fontStyle), h = u / o, f = n.isRTL ? i.split(\"\").reverse().join(\"\") : i, c = ne(r.getAttribute(\"dx\").getString()), v = f.length, g = 0; g < v; g++) {\n        var d = this.getGlyph(n, f, g);\n        e.translate(this.x, this.y), e.scale(h, -h);\n        var p = e.lineWidth;\n        e.lineWidth = e.lineWidth * o / u, l === \"italic\" && e.transform(1, 0, 0.4, 1, 0, 0), d.render(e), l === \"italic\" && e.transform(1, 0, -0.4, 1, 0, 0), e.lineWidth = p, e.scale(1 / h, -1 / h), e.translate(-this.x, -this.y), this.x += u * (d.horizAdvX || n.horizAdvX) / o, typeof c[g] < \"u\" && !isNaN(c[g]) && (this.x += c[g]);\n      }\n      return;\n    }\n    var {\n      x: y,\n      y: x\n    } = this;\n    e.fillStyle && e.fillText(i, y, x), e.strokeStyle && e.strokeText(i, y, x);\n  }\n  applyAnchoring() {\n    if (!(this.textChunkStart >= this.leafTexts.length)) {\n      var e = this.leafTexts[this.textChunkStart],\n        t = e.getStyle(\"text-anchor\").getString(\"start\"),\n        r = !1,\n        i = 0;\n      t === \"start\" && !r || t === \"end\" && r ? i = e.x - this.minX : t === \"end\" && !r || t === \"start\" && r ? i = e.x - this.maxX : i = e.x - (this.minX + this.maxX) / 2;\n      for (var n = this.textChunkStart; n < this.leafTexts.length; n++) this.leafTexts[n].x += i;\n      this.minX = Number.POSITIVE_INFINITY, this.maxX = Number.NEGATIVE_INFINITY, this.textChunkStart = this.leafTexts.length;\n    }\n  }\n  adjustChildCoordinatesRecursive(e) {\n    this.children.forEach((t, r) => {\n      this.adjustChildCoordinatesRecursiveCore(e, this, this, r);\n    }), this.applyAnchoring();\n  }\n  adjustChildCoordinatesRecursiveCore(e, t, r, i) {\n    var n = r.children[i];\n    n.children.length > 0 ? n.children.forEach((o, s) => {\n      t.adjustChildCoordinatesRecursiveCore(e, t, n, s);\n    }) : this.adjustChildCoordinates(e, t, r, i);\n  }\n  adjustChildCoordinates(e, t, r, i) {\n    var n = r.children[i];\n    if (typeof n.measureText != \"function\") return n;\n    e.save(), n.setContext(e, !0);\n    var o = n.getAttribute(\"x\"),\n      s = n.getAttribute(\"y\"),\n      u = n.getAttribute(\"dx\"),\n      l = n.getAttribute(\"dy\"),\n      h = n.getStyle(\"font-family\").getDefinition(),\n      f = !!h && h.isRTL;\n    i === 0 && (o.hasValue() || o.setValue(n.getInheritedAttribute(\"x\")), s.hasValue() || s.setValue(n.getInheritedAttribute(\"y\")), u.hasValue() || u.setValue(n.getInheritedAttribute(\"dx\")), l.hasValue() || l.setValue(n.getInheritedAttribute(\"dy\")));\n    var c = n.measureText(e);\n    return f && (t.x -= c), o.hasValue() ? (t.applyAnchoring(), n.x = o.getPixels(\"x\"), u.hasValue() && (n.x += u.getPixels(\"x\"))) : (u.hasValue() && (t.x += u.getPixels(\"x\")), n.x = t.x), t.x = n.x, f || (t.x += c), s.hasValue() ? (n.y = s.getPixels(\"y\"), l.hasValue() && (n.y += l.getPixels(\"y\"))) : (l.hasValue() && (t.y += l.getPixels(\"y\")), n.y = t.y), t.y = n.y, t.leafTexts.push(n), t.minX = Math.min(t.minX, n.x, n.x + c), t.maxX = Math.max(t.maxX, n.x, n.x + c), n.clearContext(e), e.restore(), n;\n  }\n  getChildBoundingBox(e, t, r, i) {\n    var n = r.children[i];\n    if (typeof n.getBoundingBox != \"function\") return null;\n    var o = n.getBoundingBox(e);\n    return o ? (n.children.forEach((s, u) => {\n      var l = t.getChildBoundingBox(e, t, n, u);\n      o.addBoundingBox(l);\n    }), o) : null;\n  }\n  renderChild(e, t, r, i) {\n    var n = r.children[i];\n    n.render(e), n.children.forEach((o, s) => {\n      t.renderChild(e, t, n, s);\n    });\n  }\n  measureText(e) {\n    var {\n      measureCache: t\n    } = this;\n    if (~t) return t;\n    var r = this.getText(),\n      i = this.measureTargetText(e, r);\n    return this.measureCache = i, i;\n  }\n  measureTargetText(e, t) {\n    if (!t.length) return 0;\n    var {\n        parent: r\n      } = this,\n      i = r.getStyle(\"font-family\").getDefinition();\n    if (i) {\n      for (var n = this.getFontSize(), o = i.isRTL ? t.split(\"\").reverse().join(\"\") : t, s = ne(r.getAttribute(\"dx\").getString()), u = o.length, l = 0, h = 0; h < u; h++) {\n        var f = this.getGlyph(i, o, h);\n        l += (f.horizAdvX || i.horizAdvX) * n / i.fontFace.unitsPerEm, typeof s[h] < \"u\" && !isNaN(s[h]) && (l += s[h]);\n      }\n      return l;\n    }\n    if (!e.measureText) return t.length * 10;\n    e.save(), this.setContext(e, !0);\n    var {\n      width: c\n    } = e.measureText(t);\n    return this.clearContext(e), e.restore(), c;\n  }\n  /**\n   * Inherits positional attributes from {@link TextElement} parent(s). Attributes\n   * are only inherited from a parent to its first child.\n   * @param name - The attribute name.\n   * @returns The attribute value or null.\n   */\n  getInheritedAttribute(e) {\n    for (var t = this; t instanceof Ce && t.isFirstChild();) {\n      var r = t.parent.getAttribute(e);\n      if (r.hasValue(!0)) return r.getValue(\"0\");\n      t = t.parent;\n    }\n    return null;\n  }\n}\nclass Lr extends Ce {\n  constructor(e, t, r) {\n    super(e, t, new.target === Lr ? !0 : r), this.type = \"tspan\", this.text = this.children.length > 0 ? \"\" : this.getTextFromNode();\n  }\n  getText() {\n    return this.text;\n  }\n}\nclass V1 extends Lr {\n  constructor() {\n    super(...arguments), this.type = \"textNode\";\n  }\n}\nclass Nt extends Ge {\n  constructor() {\n    super(...arguments), this.type = \"svg\", this.root = !1;\n  }\n  setContext(e) {\n    var t,\n      {\n        document: r\n      } = this,\n      {\n        screen: i,\n        window: n\n      } = r,\n      o = e.canvas;\n    if (i.setDefaults(e), o.style && typeof e.font < \"u\" && n && typeof n.getComputedStyle < \"u\") {\n      e.font = n.getComputedStyle(o).getPropertyValue(\"font\");\n      var s = new S(r, \"fontSize\", Z.parse(e.font).fontSize);\n      s.hasValue() && (r.rootEmSize = s.getPixels(\"y\"), r.emSize = r.rootEmSize);\n    }\n    this.getAttribute(\"x\").hasValue() || this.getAttribute(\"x\", !0).setValue(0), this.getAttribute(\"y\").hasValue() || this.getAttribute(\"y\", !0).setValue(0);\n    var {\n      width: u,\n      height: l\n    } = i.viewPort;\n    this.getStyle(\"width\").hasValue() || this.getStyle(\"width\", !0).setValue(\"100%\"), this.getStyle(\"height\").hasValue() || this.getStyle(\"height\", !0).setValue(\"100%\"), this.getStyle(\"color\").hasValue() || this.getStyle(\"color\", !0).setValue(\"black\");\n    var h = this.getAttribute(\"refX\"),\n      f = this.getAttribute(\"refY\"),\n      c = this.getAttribute(\"viewBox\"),\n      v = c.hasValue() ? ne(c.getString()) : null,\n      g = !this.root && this.getStyle(\"overflow\").getValue(\"hidden\") !== \"visible\",\n      d = 0,\n      p = 0,\n      y = 0,\n      x = 0;\n    v && (d = v[0], p = v[1]), this.root || (u = this.getStyle(\"width\").getPixels(\"x\"), l = this.getStyle(\"height\").getPixels(\"y\"), this.type === \"marker\" && (y = d, x = p, d = 0, p = 0)), i.viewPort.setCurrent(u, l), this.node && (!this.parent || ((t = this.node.parentNode) === null || t === void 0 ? void 0 : t.nodeName) === \"foreignObject\") && this.getStyle(\"transform\", !1, !0).hasValue() && !this.getStyle(\"transform-origin\", !1, !0).hasValue() && this.getStyle(\"transform-origin\", !0, !0).setValue(\"50% 50%\"), super.setContext(e), e.translate(this.getAttribute(\"x\").getPixels(\"x\"), this.getAttribute(\"y\").getPixels(\"y\")), v && (u = v[2], l = v[3]), r.setViewBox({\n      ctx: e,\n      aspectRatio: this.getAttribute(\"preserveAspectRatio\").getString(),\n      width: i.viewPort.width,\n      desiredWidth: u,\n      height: i.viewPort.height,\n      desiredHeight: l,\n      minX: d,\n      minY: p,\n      refX: h.getValue(),\n      refY: f.getValue(),\n      clip: g,\n      clipX: y,\n      clipY: x\n    }), v && (i.viewPort.removeCurrent(), i.viewPort.setCurrent(u, l));\n  }\n  clearContext(e) {\n    super.clearContext(e), this.document.screen.viewPort.removeCurrent();\n  }\n  /**\n   * Resize SVG to fit in given size.\n   * @param width\n   * @param height\n   * @param preserveAspectRatio\n   */\n  resize(e) {\n    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : e,\n      r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !1,\n      i = this.getAttribute(\"width\", !0),\n      n = this.getAttribute(\"height\", !0),\n      o = this.getAttribute(\"viewBox\"),\n      s = this.getAttribute(\"style\"),\n      u = i.getNumber(0),\n      l = n.getNumber(0);\n    if (r) if (typeof r == \"string\") this.getAttribute(\"preserveAspectRatio\", !0).setValue(r);else {\n      var h = this.getAttribute(\"preserveAspectRatio\");\n      h.hasValue() && h.setValue(h.getString().replace(/^\\s*(\\S.*\\S)\\s*$/, \"$1\"));\n    }\n    if (i.setValue(e), n.setValue(t), o.hasValue() || o.setValue(\"0 0 \".concat(u || e, \" \").concat(l || t)), s.hasValue()) {\n      var f = this.getStyle(\"width\"),\n        c = this.getStyle(\"height\");\n      f.hasValue() && f.setValue(\"\".concat(e, \"px\")), c.hasValue() && c.setValue(\"\".concat(t, \"px\"));\n    }\n  }\n}\nclass El extends A {\n  constructor() {\n    super(...arguments), this.type = \"rect\";\n  }\n  path(e) {\n    var t = this.getAttribute(\"x\").getPixels(\"x\"),\n      r = this.getAttribute(\"y\").getPixels(\"y\"),\n      i = this.getStyle(\"width\", !1, !0).getPixels(\"x\"),\n      n = this.getStyle(\"height\", !1, !0).getPixels(\"y\"),\n      o = this.getAttribute(\"rx\"),\n      s = this.getAttribute(\"ry\"),\n      u = o.getPixels(\"x\"),\n      l = s.getPixels(\"y\");\n    if (o.hasValue() && !s.hasValue() && (l = u), s.hasValue() && !o.hasValue() && (u = l), u = Math.min(u, i / 2), l = Math.min(l, n / 2), e) {\n      var h = 4 * ((Math.sqrt(2) - 1) / 3);\n      e.beginPath(), n > 0 && i > 0 && (e.moveTo(t + u, r), e.lineTo(t + i - u, r), e.bezierCurveTo(t + i - u + h * u, r, t + i, r + l - h * l, t + i, r + l), e.lineTo(t + i, r + n - l), e.bezierCurveTo(t + i, r + n - l + h * l, t + i - u + h * u, r + n, t + i - u, r + n), e.lineTo(t + u, r + n), e.bezierCurveTo(t + u - h * u, r + n, t, r + n - l + h * l, t, r + n - l), e.lineTo(t, r + l), e.bezierCurveTo(t, r + l - h * l, t + u - h * u, r, t + u, r), e.closePath());\n    }\n    return new ce(t, r, t + i, r + n);\n  }\n  getMarkers() {\n    return null;\n  }\n}\nclass D1 extends A {\n  constructor() {\n    super(...arguments), this.type = \"circle\";\n  }\n  path(e) {\n    var t = this.getAttribute(\"cx\").getPixels(\"x\"),\n      r = this.getAttribute(\"cy\").getPixels(\"y\"),\n      i = this.getAttribute(\"r\").getPixels();\n    return e && i > 0 && (e.beginPath(), e.arc(t, r, i, 0, Math.PI * 2, !1), e.closePath()), new ce(t - i, r - i, t + i, r + i);\n  }\n  getMarkers() {\n    return null;\n  }\n}\nclass L1 extends A {\n  constructor() {\n    super(...arguments), this.type = \"ellipse\";\n  }\n  path(e) {\n    var t = 4 * ((Math.sqrt(2) - 1) / 3),\n      r = this.getAttribute(\"rx\").getPixels(\"x\"),\n      i = this.getAttribute(\"ry\").getPixels(\"y\"),\n      n = this.getAttribute(\"cx\").getPixels(\"x\"),\n      o = this.getAttribute(\"cy\").getPixels(\"y\");\n    return e && r > 0 && i > 0 && (e.beginPath(), e.moveTo(n + r, o), e.bezierCurveTo(n + r, o + t * i, n + t * r, o + i, n, o + i), e.bezierCurveTo(n - t * r, o + i, n - r, o + t * i, n - r, o), e.bezierCurveTo(n - r, o - t * i, n - t * r, o - i, n, o - i), e.bezierCurveTo(n + t * r, o - i, n + r, o - t * i, n + r, o), e.closePath()), new ce(n - r, o - i, n + r, o + i);\n  }\n  getMarkers() {\n    return null;\n  }\n}\nclass k1 extends A {\n  constructor() {\n    super(...arguments), this.type = \"line\";\n  }\n  getPoints() {\n    return [new k(this.getAttribute(\"x1\").getPixels(\"x\"), this.getAttribute(\"y1\").getPixels(\"y\")), new k(this.getAttribute(\"x2\").getPixels(\"x\"), this.getAttribute(\"y2\").getPixels(\"y\"))];\n  }\n  path(e) {\n    var [{\n      x: t,\n      y: r\n    }, {\n      x: i,\n      y: n\n    }] = this.getPoints();\n    return e && (e.beginPath(), e.moveTo(t, r), e.lineTo(i, n)), new ce(t, r, i, n);\n  }\n  getMarkers() {\n    var [e, t] = this.getPoints(),\n      r = e.angleTo(t);\n    return [[e, r], [t, r]];\n  }\n}\nclass $l extends A {\n  constructor(e, t, r) {\n    super(e, t, r), this.type = \"polyline\", this.points = [], this.points = k.parsePath(this.getAttribute(\"points\").getString());\n  }\n  path(e) {\n    var {\n        points: t\n      } = this,\n      [{\n        x: r,\n        y: i\n      }] = t,\n      n = new ce(r, i);\n    return e && (e.beginPath(), e.moveTo(r, i)), t.forEach(o => {\n      var {\n        x: s,\n        y: u\n      } = o;\n      n.addPoint(s, u), e && e.lineTo(s, u);\n    }), n;\n  }\n  getMarkers() {\n    var {\n        points: e\n      } = this,\n      t = e.length - 1,\n      r = [];\n    return e.forEach((i, n) => {\n      n !== t && r.push([i, i.angleTo(e[n + 1])]);\n    }), r.length > 0 && r.push([e[e.length - 1], r[r.length - 1][1]]), r;\n  }\n}\nclass B1 extends $l {\n  constructor() {\n    super(...arguments), this.type = \"polygon\";\n  }\n  path(e) {\n    var t = super.path(e),\n      [{\n        x: r,\n        y: i\n      }] = this.points;\n    return e && (e.lineTo(r, i), e.closePath()), t;\n  }\n}\nclass j1 extends I {\n  constructor() {\n    super(...arguments), this.type = \"pattern\";\n  }\n  createPattern(e, t, r) {\n    var i = this.getStyle(\"width\").getPixels(\"x\", !0),\n      n = this.getStyle(\"height\").getPixels(\"y\", !0),\n      o = new Nt(this.document, null);\n    o.attributes.viewBox = new S(this.document, \"viewBox\", this.getAttribute(\"viewBox\").getValue()), o.attributes.width = new S(this.document, \"width\", \"\".concat(i, \"px\")), o.attributes.height = new S(this.document, \"height\", \"\".concat(n, \"px\")), o.attributes.transform = new S(this.document, \"transform\", this.getAttribute(\"patternTransform\").getValue()), o.children = this.children;\n    var s = this.document.createCanvas(i, n),\n      u = s.getContext(\"2d\"),\n      l = this.getAttribute(\"x\"),\n      h = this.getAttribute(\"y\");\n    l.hasValue() && h.hasValue() && u.translate(l.getPixels(\"x\", !0), h.getPixels(\"y\", !0)), r.hasValue() ? this.styles[\"fill-opacity\"] = r : Reflect.deleteProperty(this.styles, \"fill-opacity\");\n    for (var f = -1; f <= 1; f++) for (var c = -1; c <= 1; c++) u.save(), o.attributes.x = new S(this.document, \"x\", f * s.width), o.attributes.y = new S(this.document, \"y\", c * s.height), o.render(u), u.restore();\n    var v = e.createPattern(s, \"repeat\");\n    return v;\n  }\n}\nclass F1 extends I {\n  constructor() {\n    super(...arguments), this.type = \"marker\";\n  }\n  render(e, t, r) {\n    if (t) {\n      var {\n          x: i,\n          y: n\n        } = t,\n        o = this.getAttribute(\"orient\").getString(\"auto\"),\n        s = this.getAttribute(\"markerUnits\").getString(\"strokeWidth\");\n      e.translate(i, n), o === \"auto\" && e.rotate(r), s === \"strokeWidth\" && e.scale(e.lineWidth, e.lineWidth), e.save();\n      var u = new Nt(this.document, null);\n      u.type = this.type, u.attributes.viewBox = new S(this.document, \"viewBox\", this.getAttribute(\"viewBox\").getValue()), u.attributes.refX = new S(this.document, \"refX\", this.getAttribute(\"refX\").getValue()), u.attributes.refY = new S(this.document, \"refY\", this.getAttribute(\"refY\").getValue()), u.attributes.width = new S(this.document, \"width\", this.getAttribute(\"markerWidth\").getValue()), u.attributes.height = new S(this.document, \"height\", this.getAttribute(\"markerHeight\").getValue()), u.attributes.overflow = new S(this.document, \"overflow\", this.getAttribute(\"overflow\").getValue()), u.attributes.fill = new S(this.document, \"fill\", this.getAttribute(\"fill\").getColor(\"black\")), u.attributes.stroke = new S(this.document, \"stroke\", this.getAttribute(\"stroke\").getValue(\"none\")), u.children = this.children, u.render(e), e.restore(), s === \"strokeWidth\" && e.scale(1 / e.lineWidth, 1 / e.lineWidth), o === \"auto\" && e.rotate(-r), e.translate(-i, -n);\n    }\n  }\n}\nclass U1 extends I {\n  constructor() {\n    super(...arguments), this.type = \"defs\";\n  }\n  render() {}\n}\nclass sn extends Ge {\n  constructor() {\n    super(...arguments), this.type = \"g\";\n  }\n  getBoundingBox(e) {\n    var t = new ce();\n    return this.children.forEach(r => {\n      t.addBoundingBox(r.getBoundingBox(e));\n    }), t;\n  }\n}\nclass wl extends I {\n  constructor(e, t, r) {\n    super(e, t, r), this.attributesToInherit = [\"gradientUnits\"], this.stops = [];\n    var {\n      stops: i,\n      children: n\n    } = this;\n    n.forEach(o => {\n      o.type === \"stop\" && i.push(o);\n    });\n  }\n  getGradientUnits() {\n    return this.getAttribute(\"gradientUnits\").getString(\"objectBoundingBox\");\n  }\n  createGradient(e, t, r) {\n    var i = this;\n    this.getHrefAttribute().hasValue() && (i = this.getHrefAttribute().getDefinition(), this.inheritStopContainer(i));\n    var {\n        stops: n\n      } = i,\n      o = this.getGradient(e, t);\n    if (!o) return this.addParentOpacity(r, n[n.length - 1].color);\n    if (n.forEach(p => {\n      o.addColorStop(p.offset, this.addParentOpacity(r, p.color));\n    }), this.getAttribute(\"gradientTransform\").hasValue()) {\n      var {\n          document: s\n        } = this,\n        {\n          MAX_VIRTUAL_PIXELS: u,\n          viewPort: l\n        } = s.screen,\n        [h] = l.viewPorts,\n        f = new El(s, null);\n      f.attributes.x = new S(s, \"x\", -u / 3), f.attributes.y = new S(s, \"y\", -u / 3), f.attributes.width = new S(s, \"width\", u), f.attributes.height = new S(s, \"height\", u);\n      var c = new sn(s, null);\n      c.attributes.transform = new S(s, \"transform\", this.getAttribute(\"gradientTransform\").getValue()), c.children = [f];\n      var v = new Nt(s, null);\n      v.attributes.x = new S(s, \"x\", 0), v.attributes.y = new S(s, \"y\", 0), v.attributes.width = new S(s, \"width\", h.width), v.attributes.height = new S(s, \"height\", h.height), v.children = [c];\n      var g = s.createCanvas(h.width, h.height),\n        d = g.getContext(\"2d\");\n      return d.fillStyle = o, v.render(d), d.createPattern(g, \"no-repeat\");\n    }\n    return o;\n  }\n  inheritStopContainer(e) {\n    this.attributesToInherit.forEach(t => {\n      !this.getAttribute(t).hasValue() && e.getAttribute(t).hasValue() && this.getAttribute(t, !0).setValue(e.getAttribute(t).getValue());\n    });\n  }\n  addParentOpacity(e, t) {\n    if (e.hasValue()) {\n      var r = new S(this.document, \"color\", t);\n      return r.addOpacity(e).getColor();\n    }\n    return t;\n  }\n}\nclass G1 extends wl {\n  constructor(e, t, r) {\n    super(e, t, r), this.type = \"linearGradient\", this.attributesToInherit.push(\"x1\", \"y1\", \"x2\", \"y2\");\n  }\n  getGradient(e, t) {\n    var r = this.getGradientUnits() === \"objectBoundingBox\",\n      i = r ? t.getBoundingBox(e) : null;\n    if (r && !i) return null;\n    !this.getAttribute(\"x1\").hasValue() && !this.getAttribute(\"y1\").hasValue() && !this.getAttribute(\"x2\").hasValue() && !this.getAttribute(\"y2\").hasValue() && (this.getAttribute(\"x1\", !0).setValue(0), this.getAttribute(\"y1\", !0).setValue(0), this.getAttribute(\"x2\", !0).setValue(1), this.getAttribute(\"y2\", !0).setValue(0));\n    var n = r ? i.x + i.width * this.getAttribute(\"x1\").getNumber() : this.getAttribute(\"x1\").getPixels(\"x\"),\n      o = r ? i.y + i.height * this.getAttribute(\"y1\").getNumber() : this.getAttribute(\"y1\").getPixels(\"y\"),\n      s = r ? i.x + i.width * this.getAttribute(\"x2\").getNumber() : this.getAttribute(\"x2\").getPixels(\"x\"),\n      u = r ? i.y + i.height * this.getAttribute(\"y2\").getNumber() : this.getAttribute(\"y2\").getPixels(\"y\");\n    return n === s && o === u ? null : e.createLinearGradient(n, o, s, u);\n  }\n}\nclass z1 extends wl {\n  constructor(e, t, r) {\n    super(e, t, r), this.type = \"radialGradient\", this.attributesToInherit.push(\"cx\", \"cy\", \"r\", \"fx\", \"fy\", \"fr\");\n  }\n  getGradient(e, t) {\n    var r = this.getGradientUnits() === \"objectBoundingBox\",\n      i = t.getBoundingBox(e);\n    if (r && !i) return null;\n    this.getAttribute(\"cx\").hasValue() || this.getAttribute(\"cx\", !0).setValue(\"50%\"), this.getAttribute(\"cy\").hasValue() || this.getAttribute(\"cy\", !0).setValue(\"50%\"), this.getAttribute(\"r\").hasValue() || this.getAttribute(\"r\", !0).setValue(\"50%\");\n    var n = r ? i.x + i.width * this.getAttribute(\"cx\").getNumber() : this.getAttribute(\"cx\").getPixels(\"x\"),\n      o = r ? i.y + i.height * this.getAttribute(\"cy\").getNumber() : this.getAttribute(\"cy\").getPixels(\"y\"),\n      s = n,\n      u = o;\n    this.getAttribute(\"fx\").hasValue() && (s = r ? i.x + i.width * this.getAttribute(\"fx\").getNumber() : this.getAttribute(\"fx\").getPixels(\"x\")), this.getAttribute(\"fy\").hasValue() && (u = r ? i.y + i.height * this.getAttribute(\"fy\").getNumber() : this.getAttribute(\"fy\").getPixels(\"y\"));\n    var l = r ? (i.width + i.height) / 2 * this.getAttribute(\"r\").getNumber() : this.getAttribute(\"r\").getPixels(),\n      h = this.getAttribute(\"fr\").getPixels();\n    return e.createRadialGradient(s, u, h, n, o, l);\n  }\n}\nclass H1 extends I {\n  constructor(e, t, r) {\n    super(e, t, r), this.type = \"stop\";\n    var i = Math.max(0, Math.min(1, this.getAttribute(\"offset\").getNumber())),\n      n = this.getStyle(\"stop-opacity\"),\n      o = this.getStyle(\"stop-color\", !0);\n    o.getString() === \"\" && o.setValue(\"#000\"), n.hasValue() && (o = o.addOpacity(n)), this.offset = i, this.color = o.getColor();\n  }\n}\nclass on extends I {\n  constructor(e, t, r) {\n    super(e, t, r), this.type = \"animate\", this.duration = 0, this.initialValue = null, this.initialUnits = \"\", this.removed = !1, this.frozen = !1, e.screen.animations.push(this), this.begin = this.getAttribute(\"begin\").getMilliseconds(), this.maxDuration = this.begin + this.getAttribute(\"dur\").getMilliseconds(), this.from = this.getAttribute(\"from\"), this.to = this.getAttribute(\"to\"), this.values = new S(e, \"values\", null);\n    var i = this.getAttribute(\"values\");\n    i.hasValue() && this.values.setValue(i.getString().split(\";\"));\n  }\n  getProperty() {\n    var e = this.getAttribute(\"attributeType\").getString(),\n      t = this.getAttribute(\"attributeName\").getString();\n    return e === \"CSS\" ? this.parent.getStyle(t, !0) : this.parent.getAttribute(t, !0);\n  }\n  calcValue() {\n    var {\n        initialUnits: e\n      } = this,\n      {\n        progress: t,\n        from: r,\n        to: i\n      } = this.getProgress(),\n      n = r.getNumber() + (i.getNumber() - r.getNumber()) * t;\n    return e === \"%\" && (n *= 100), \"\".concat(n).concat(e);\n  }\n  update(e) {\n    var {\n        parent: t\n      } = this,\n      r = this.getProperty();\n    if (this.initialValue || (this.initialValue = r.getString(), this.initialUnits = r.getUnits()), this.duration > this.maxDuration) {\n      var i = this.getAttribute(\"fill\").getString(\"remove\");\n      if (this.getAttribute(\"repeatCount\").getString() === \"indefinite\" || this.getAttribute(\"repeatDur\").getString() === \"indefinite\") this.duration = 0;else if (i === \"freeze\" && !this.frozen) this.frozen = !0, t.animationFrozen = !0, t.animationFrozenValue = r.getString();else if (i === \"remove\" && !this.removed) return this.removed = !0, r.setValue(t.animationFrozen ? t.animationFrozenValue : this.initialValue), !0;\n      return !1;\n    }\n    this.duration += e;\n    var n = !1;\n    if (this.begin < this.duration) {\n      var o = this.calcValue(),\n        s = this.getAttribute(\"type\");\n      if (s.hasValue()) {\n        var u = s.getString();\n        o = \"\".concat(u, \"(\").concat(o, \")\");\n      }\n      r.setValue(o), n = !0;\n    }\n    return n;\n  }\n  getProgress() {\n    var {\n        document: e,\n        values: t\n      } = this,\n      r = {\n        progress: (this.duration - this.begin) / (this.maxDuration - this.begin)\n      };\n    if (t.hasValue()) {\n      var i = r.progress * (t.getValue().length - 1),\n        n = Math.floor(i),\n        o = Math.ceil(i);\n      r.from = new S(e, \"from\", parseFloat(t.getValue()[n])), r.to = new S(e, \"to\", parseFloat(t.getValue()[o])), r.progress = (i - n) / (o - n);\n    } else r.from = this.from, r.to = this.to;\n    return r;\n  }\n}\nclass Y1 extends on {\n  constructor() {\n    super(...arguments), this.type = \"animateColor\";\n  }\n  calcValue() {\n    var {\n        progress: e,\n        from: t,\n        to: r\n      } = this.getProgress(),\n      i = new yi(t.getColor()),\n      n = new yi(r.getColor());\n    if (i.ok && n.ok) {\n      var o = i.r + (n.r - i.r) * e,\n        s = i.g + (n.g - i.g) * e,\n        u = i.b + (n.b - i.b) * e;\n      return \"rgb(\".concat(Math.floor(o), \", \").concat(Math.floor(s), \", \").concat(Math.floor(u), \")\");\n    }\n    return this.getAttribute(\"from\").getColor();\n  }\n}\nclass X1 extends on {\n  constructor() {\n    super(...arguments), this.type = \"animateTransform\";\n  }\n  calcValue() {\n    var {\n        progress: e,\n        from: t,\n        to: r\n      } = this.getProgress(),\n      i = ne(t.getString()),\n      n = ne(r.getString()),\n      o = i.map((s, u) => {\n        var l = n[u];\n        return s + (l - s) * e;\n      }).join(\" \");\n    return o;\n  }\n}\nclass W1 extends I {\n  constructor(e, t, r) {\n    super(e, t, r), this.type = \"font\", this.glyphs = /* @__PURE__ */Object.create(null), this.horizAdvX = this.getAttribute(\"horiz-adv-x\").getNumber();\n    var {\n        definitions: i\n      } = e,\n      {\n        children: n\n      } = this;\n    for (var o of n) switch (o.type) {\n      case \"font-face\":\n        {\n          this.fontFace = o;\n          var s = o.getStyle(\"font-family\");\n          s.hasValue() && (i[s.getString()] = this);\n          break;\n        }\n      case \"missing-glyph\":\n        this.missingGlyph = o;\n        break;\n      case \"glyph\":\n        {\n          var u = o;\n          u.arabicForm ? (this.isRTL = !0, this.isArabic = !0, typeof this.glyphs[u.unicode] > \"u\" && (this.glyphs[u.unicode] = /* @__PURE__ */Object.create(null)), this.glyphs[u.unicode][u.arabicForm] = u) : this.glyphs[u.unicode] = u;\n          break;\n        }\n    }\n  }\n  render() {}\n}\nclass q1 extends I {\n  constructor(e, t, r) {\n    super(e, t, r), this.type = \"font-face\", this.ascent = this.getAttribute(\"ascent\").getNumber(), this.descent = this.getAttribute(\"descent\").getNumber(), this.unitsPerEm = this.getAttribute(\"units-per-em\").getNumber();\n  }\n}\nclass Q1 extends A {\n  constructor() {\n    super(...arguments), this.type = \"missing-glyph\", this.horizAdvX = 0;\n  }\n}\nclass K1 extends Ce {\n  constructor() {\n    super(...arguments), this.type = \"tref\";\n  }\n  getText() {\n    var e = this.getHrefAttribute().getDefinition();\n    if (e) {\n      var t = e.children[0];\n      if (t) return t.getText();\n    }\n    return \"\";\n  }\n}\nclass Z1 extends Ce {\n  constructor(e, t, r) {\n    super(e, t, r), this.type = \"a\";\n    var {\n        childNodes: i\n      } = t,\n      n = i[0],\n      o = i.length > 0 && Array.from(i).every(s => s.nodeType === 3);\n    this.hasText = o, this.text = o ? this.getTextFromNode(n) : \"\";\n  }\n  getText() {\n    return this.text;\n  }\n  renderChildren(e) {\n    if (this.hasText) {\n      super.renderChildren(e);\n      var {\n          document: t,\n          x: r,\n          y: i\n        } = this,\n        {\n          mouse: n\n        } = t.screen,\n        o = new S(t, \"fontSize\", Z.parse(t.ctx.font).fontSize);\n      n.isWorking() && n.checkBoundingBox(this, new ce(r, i - o.getPixels(\"y\"), r + this.measureText(e), i));\n    } else if (this.children.length > 0) {\n      var s = new sn(this.document, null);\n      s.children = this.children, s.parent = this, s.render(e);\n    }\n  }\n  onClick() {\n    var {\n      window: e\n    } = this.document;\n    e && e.open(this.getHrefAttribute().getString());\n  }\n  onMouseMove() {\n    var e = this.document.ctx;\n    e.canvas.style.cursor = \"pointer\";\n  }\n}\nfunction Mo(a, e) {\n  var t = Object.keys(a);\n  if (Object.getOwnPropertySymbols) {\n    var r = Object.getOwnPropertySymbols(a);\n    e && (r = r.filter(function (i) {\n      return Object.getOwnPropertyDescriptor(a, i).enumerable;\n    })), t.push.apply(t, r);\n  }\n  return t;\n}\nfunction ir(a) {\n  for (var e = 1; e < arguments.length; e++) {\n    var t = arguments[e] != null ? arguments[e] : {};\n    e % 2 ? Mo(Object(t), !0).forEach(function (r) {\n      an(a, r, t[r]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(a, Object.getOwnPropertyDescriptors(t)) : Mo(Object(t)).forEach(function (r) {\n      Object.defineProperty(a, r, Object.getOwnPropertyDescriptor(t, r));\n    });\n  }\n  return a;\n}\nclass J1 extends Ce {\n  constructor(e, t, r) {\n    super(e, t, r), this.type = \"textPath\", this.textWidth = 0, this.textHeight = 0, this.pathLength = -1, this.glyphInfo = null, this.letterSpacingCache = [], this.measuresCache = /* @__PURE__ */new Map([[\"\", 0]]);\n    var i = this.getHrefAttribute().getDefinition();\n    this.text = this.getTextFromNode(), this.dataArray = this.parsePathData(i);\n  }\n  getText() {\n    return this.text;\n  }\n  path(e) {\n    var {\n      dataArray: t\n    } = this;\n    e && e.beginPath(), t.forEach(r => {\n      var {\n        type: i,\n        points: n\n      } = r;\n      switch (i) {\n        case w.LINE_TO:\n          e && e.lineTo(n[0], n[1]);\n          break;\n        case w.MOVE_TO:\n          e && e.moveTo(n[0], n[1]);\n          break;\n        case w.CURVE_TO:\n          e && e.bezierCurveTo(n[0], n[1], n[2], n[3], n[4], n[5]);\n          break;\n        case w.QUAD_TO:\n          e && e.quadraticCurveTo(n[0], n[1], n[2], n[3]);\n          break;\n        case w.ARC:\n          {\n            var [o, s, u, l, h, f, c, v] = n,\n              g = u > l ? u : l,\n              d = u > l ? 1 : u / l,\n              p = u > l ? l / u : 1;\n            e && (e.translate(o, s), e.rotate(c), e.scale(d, p), e.arc(0, 0, g, h, h + f, !!(1 - v)), e.scale(1 / d, 1 / p), e.rotate(-c), e.translate(-o, -s));\n            break;\n          }\n        case w.CLOSE_PATH:\n          e && e.closePath();\n          break;\n      }\n    });\n  }\n  renderChildren(e) {\n    this.setTextData(e), e.save();\n    var t = this.parent.getStyle(\"text-decoration\").getString(),\n      r = this.getFontSize(),\n      {\n        glyphInfo: i\n      } = this,\n      n = e.fillStyle;\n    t === \"underline\" && e.beginPath(), i.forEach((o, s) => {\n      var {\n        p0: u,\n        p1: l,\n        rotation: h,\n        text: f\n      } = o;\n      e.save(), e.translate(u.x, u.y), e.rotate(h), e.fillStyle && e.fillText(f, 0, 0), e.strokeStyle && e.strokeText(f, 0, 0), e.restore(), t === \"underline\" && (s === 0 && e.moveTo(u.x, u.y + r / 8), e.lineTo(l.x, l.y + r / 5));\n    }), t === \"underline\" && (e.lineWidth = r / 20, e.strokeStyle = n, e.stroke(), e.closePath()), e.restore();\n  }\n  getLetterSpacingAt() {\n    var e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;\n    return this.letterSpacingCache[e] || 0;\n  }\n  findSegmentToFitChar(e, t, r, i, n, o, s, u, l) {\n    var h = o,\n      f = this.measureText(e, u);\n    u === \" \" && t === \"justify\" && r < i && (f += (i - r) / n), l > -1 && (h += this.getLetterSpacingAt(l));\n    var c = this.textHeight / 20,\n      v = this.getEquidistantPointOnPath(h, c, 0),\n      g = this.getEquidistantPointOnPath(h + f, c, 0),\n      d = {\n        p0: v,\n        p1: g\n      },\n      p = v && g ? Math.atan2(g.y - v.y, g.x - v.x) : 0;\n    if (s) {\n      var y = Math.cos(Math.PI / 2 + p) * s,\n        x = Math.cos(-p) * s;\n      d.p0 = ir(ir({}, v), {}, {\n        x: v.x + y,\n        y: v.y + x\n      }), d.p1 = ir(ir({}, g), {}, {\n        x: g.x + y,\n        y: g.y + x\n      });\n    }\n    return h += f, {\n      offset: h,\n      segment: d,\n      rotation: p\n    };\n  }\n  measureText(e, t) {\n    var {\n        measuresCache: r\n      } = this,\n      i = t || this.getText();\n    if (r.has(i)) return r.get(i);\n    var n = this.measureTargetText(e, i);\n    return r.set(i, n), n;\n  }\n  // This method supposes what all custom fonts already loaded.\n  // If some font will be loaded after this method call, <textPath> will not be rendered correctly.\n  // You need to call this method manually to update glyphs cache.\n  setTextData(e) {\n    if (!this.glyphInfo) {\n      var t = this.getText(),\n        r = t.split(\"\"),\n        i = t.split(\" \").length - 1,\n        n = this.parent.getAttribute(\"dx\").split().map(T => T.getPixels(\"x\")),\n        o = this.parent.getAttribute(\"dy\").getPixels(\"y\"),\n        s = this.parent.getStyle(\"text-anchor\").getString(\"start\"),\n        u = this.getStyle(\"letter-spacing\"),\n        l = this.parent.getStyle(\"letter-spacing\"),\n        h = 0;\n      !u.hasValue() || u.getValue() === \"inherit\" ? h = l.getPixels() : u.hasValue() && u.getValue() !== \"initial\" && u.getValue() !== \"unset\" && (h = u.getPixels());\n      var f = [],\n        c = t.length;\n      this.letterSpacingCache = f;\n      for (var v = 0; v < c; v++) f.push(typeof n[v] < \"u\" ? n[v] : h);\n      var g = f.reduce((T, $, E) => E === 0 ? 0 : T + $ || 0, 0),\n        d = this.measureText(e),\n        p = Math.max(d + g, 0);\n      this.textWidth = d, this.textHeight = this.getFontSize(), this.glyphInfo = [];\n      var y = this.getPathLength(),\n        x = this.getStyle(\"startOffset\").getNumber(0) * y,\n        b = 0;\n      (s === \"middle\" || s === \"center\") && (b = -p / 2), (s === \"end\" || s === \"right\") && (b = -p), b += x, r.forEach((T, $) => {\n        var {\n          offset: E,\n          segment: O,\n          rotation: C\n        } = this.findSegmentToFitChar(e, s, p, y, i, b, o, T, $);\n        b = E, !(!O.p0 || !O.p1) && this.glyphInfo.push({\n          // transposeX: midpoint.x,\n          // transposeY: midpoint.y,\n          text: r[$],\n          p0: O.p0,\n          p1: O.p1,\n          rotation: C\n        });\n      });\n    }\n  }\n  parsePathData(e) {\n    if (this.pathLength = -1, !e) return [];\n    var t = [],\n      {\n        pathParser: r\n      } = e;\n    for (r.reset(); !r.isEnd();) {\n      var {\n          current: i\n        } = r,\n        n = i ? i.x : 0,\n        o = i ? i.y : 0,\n        s = r.next(),\n        u = s.type,\n        l = [];\n      switch (s.type) {\n        case w.MOVE_TO:\n          this.pathM(r, l);\n          break;\n        case w.LINE_TO:\n          u = this.pathL(r, l);\n          break;\n        case w.HORIZ_LINE_TO:\n          u = this.pathH(r, l);\n          break;\n        case w.VERT_LINE_TO:\n          u = this.pathV(r, l);\n          break;\n        case w.CURVE_TO:\n          this.pathC(r, l);\n          break;\n        case w.SMOOTH_CURVE_TO:\n          u = this.pathS(r, l);\n          break;\n        case w.QUAD_TO:\n          this.pathQ(r, l);\n          break;\n        case w.SMOOTH_QUAD_TO:\n          u = this.pathT(r, l);\n          break;\n        case w.ARC:\n          l = this.pathA(r);\n          break;\n        case w.CLOSE_PATH:\n          A.pathZ(r);\n          break;\n      }\n      s.type !== w.CLOSE_PATH ? t.push({\n        type: u,\n        points: l,\n        start: {\n          x: n,\n          y: o\n        },\n        pathLength: this.calcLength(n, o, u, l)\n      }) : t.push({\n        type: w.CLOSE_PATH,\n        points: [],\n        pathLength: 0\n      });\n    }\n    return t;\n  }\n  pathM(e, t) {\n    var {\n      x: r,\n      y: i\n    } = A.pathM(e).point;\n    t.push(r, i);\n  }\n  pathL(e, t) {\n    var {\n      x: r,\n      y: i\n    } = A.pathL(e).point;\n    return t.push(r, i), w.LINE_TO;\n  }\n  pathH(e, t) {\n    var {\n      x: r,\n      y: i\n    } = A.pathH(e).point;\n    return t.push(r, i), w.LINE_TO;\n  }\n  pathV(e, t) {\n    var {\n      x: r,\n      y: i\n    } = A.pathV(e).point;\n    return t.push(r, i), w.LINE_TO;\n  }\n  pathC(e, t) {\n    var {\n      point: r,\n      controlPoint: i,\n      currentPoint: n\n    } = A.pathC(e);\n    t.push(r.x, r.y, i.x, i.y, n.x, n.y);\n  }\n  pathS(e, t) {\n    var {\n      point: r,\n      controlPoint: i,\n      currentPoint: n\n    } = A.pathS(e);\n    return t.push(r.x, r.y, i.x, i.y, n.x, n.y), w.CURVE_TO;\n  }\n  pathQ(e, t) {\n    var {\n      controlPoint: r,\n      currentPoint: i\n    } = A.pathQ(e);\n    t.push(r.x, r.y, i.x, i.y);\n  }\n  pathT(e, t) {\n    var {\n      controlPoint: r,\n      currentPoint: i\n    } = A.pathT(e);\n    return t.push(r.x, r.y, i.x, i.y), w.QUAD_TO;\n  }\n  pathA(e) {\n    var {\n      rX: t,\n      rY: r,\n      sweepFlag: i,\n      xAxisRotation: n,\n      centp: o,\n      a1: s,\n      ad: u\n    } = A.pathA(e);\n    return i === 0 && u > 0 && (u -= 2 * Math.PI), i === 1 && u < 0 && (u += 2 * Math.PI), [o.x, o.y, t, r, s, u, n, i];\n  }\n  calcLength(e, t, r, i) {\n    var n = 0,\n      o = null,\n      s = null,\n      u = 0;\n    switch (r) {\n      case w.LINE_TO:\n        return this.getLineLength(e, t, i[0], i[1]);\n      case w.CURVE_TO:\n        for (n = 0, o = this.getPointOnCubicBezier(0, e, t, i[0], i[1], i[2], i[3], i[4], i[5]), u = 0.01; u <= 1; u += 0.01) s = this.getPointOnCubicBezier(u, e, t, i[0], i[1], i[2], i[3], i[4], i[5]), n += this.getLineLength(o.x, o.y, s.x, s.y), o = s;\n        return n;\n      case w.QUAD_TO:\n        for (n = 0, o = this.getPointOnQuadraticBezier(0, e, t, i[0], i[1], i[2], i[3]), u = 0.01; u <= 1; u += 0.01) s = this.getPointOnQuadraticBezier(u, e, t, i[0], i[1], i[2], i[3]), n += this.getLineLength(o.x, o.y, s.x, s.y), o = s;\n        return n;\n      case w.ARC:\n        {\n          n = 0;\n          var l = i[4],\n            h = i[5],\n            f = i[4] + h,\n            c = Math.PI / 180;\n          if (Math.abs(l - f) < c && (c = Math.abs(l - f)), o = this.getPointOnEllipticalArc(i[0], i[1], i[2], i[3], l, 0), h < 0) for (u = l - c; u > f; u -= c) s = this.getPointOnEllipticalArc(i[0], i[1], i[2], i[3], u, 0), n += this.getLineLength(o.x, o.y, s.x, s.y), o = s;else for (u = l + c; u < f; u += c) s = this.getPointOnEllipticalArc(i[0], i[1], i[2], i[3], u, 0), n += this.getLineLength(o.x, o.y, s.x, s.y), o = s;\n          return s = this.getPointOnEllipticalArc(i[0], i[1], i[2], i[3], f, 0), n += this.getLineLength(o.x, o.y, s.x, s.y), n;\n        }\n    }\n    return 0;\n  }\n  getPointOnLine(e, t, r, i, n) {\n    var o = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : t,\n      s = arguments.length > 6 && arguments[6] !== void 0 ? arguments[6] : r,\n      u = (n - r) / (i - t + rt),\n      l = Math.sqrt(e * e / (1 + u * u));\n    i < t && (l *= -1);\n    var h = u * l,\n      f = null;\n    if (i === t) f = {\n      x: o,\n      y: s + h\n    };else if ((s - r) / (o - t + rt) === u) f = {\n      x: o + l,\n      y: s + h\n    };else {\n      var c = 0,\n        v = 0,\n        g = this.getLineLength(t, r, i, n);\n      if (g < rt) return null;\n      var d = (o - t) * (i - t) + (s - r) * (n - r);\n      d /= g * g, c = t + d * (i - t), v = r + d * (n - r);\n      var p = this.getLineLength(o, s, c, v),\n        y = Math.sqrt(e * e - p * p);\n      l = Math.sqrt(y * y / (1 + u * u)), i < t && (l *= -1), h = u * l, f = {\n        x: c + l,\n        y: v + h\n      };\n    }\n    return f;\n  }\n  getPointOnPath(e) {\n    var t = this.getPathLength(),\n      r = 0,\n      i = null;\n    if (e < -5e-5 || e - 5e-5 > t) return null;\n    var {\n      dataArray: n\n    } = this;\n    for (var o of n) {\n      if (o && (o.pathLength < 5e-5 || r + o.pathLength + 5e-5 < e)) {\n        r += o.pathLength;\n        continue;\n      }\n      var s = e - r,\n        u = 0;\n      switch (o.type) {\n        case w.LINE_TO:\n          i = this.getPointOnLine(s, o.start.x, o.start.y, o.points[0], o.points[1], o.start.x, o.start.y);\n          break;\n        case w.ARC:\n          {\n            var l = o.points[4],\n              h = o.points[5],\n              f = o.points[4] + h;\n            if (u = l + s / o.pathLength * h, h < 0 && u < f || h >= 0 && u > f) break;\n            i = this.getPointOnEllipticalArc(o.points[0], o.points[1], o.points[2], o.points[3], u, o.points[6]);\n            break;\n          }\n        case w.CURVE_TO:\n          u = s / o.pathLength, u > 1 && (u = 1), i = this.getPointOnCubicBezier(u, o.start.x, o.start.y, o.points[0], o.points[1], o.points[2], o.points[3], o.points[4], o.points[5]);\n          break;\n        case w.QUAD_TO:\n          u = s / o.pathLength, u > 1 && (u = 1), i = this.getPointOnQuadraticBezier(u, o.start.x, o.start.y, o.points[0], o.points[1], o.points[2], o.points[3]);\n          break;\n      }\n      if (i) return i;\n      break;\n    }\n    return null;\n  }\n  getLineLength(e, t, r, i) {\n    return Math.sqrt((r - e) * (r - e) + (i - t) * (i - t));\n  }\n  getPathLength() {\n    return this.pathLength === -1 && (this.pathLength = this.dataArray.reduce((e, t) => t.pathLength > 0 ? e + t.pathLength : e, 0)), this.pathLength;\n  }\n  getPointOnCubicBezier(e, t, r, i, n, o, s, u, l) {\n    var h = u * wo(e) + o * Co(e) + i * Ao(e) + t * Po(e),\n      f = l * wo(e) + s * Co(e) + n * Ao(e) + r * Po(e);\n    return {\n      x: h,\n      y: f\n    };\n  }\n  getPointOnQuadraticBezier(e, t, r, i, n, o, s) {\n    var u = o * Ro(e) + i * No(e) + t * Io(e),\n      l = s * Ro(e) + n * No(e) + r * Io(e);\n    return {\n      x: u,\n      y: l\n    };\n  }\n  getPointOnEllipticalArc(e, t, r, i, n, o) {\n    var s = Math.cos(o),\n      u = Math.sin(o),\n      l = {\n        x: r * Math.cos(n),\n        y: i * Math.sin(n)\n      };\n    return {\n      x: e + (l.x * s - l.y * u),\n      y: t + (l.x * u + l.y * s)\n    };\n  }\n  // TODO need some optimisations. possibly build cache only for curved segments?\n  buildEquidistantCache(e, t) {\n    var r = this.getPathLength(),\n      i = t || 0.25,\n      n = e || r / 100;\n    if (!this.equidistantCache || this.equidistantCache.step !== n || this.equidistantCache.precision !== i) {\n      this.equidistantCache = {\n        step: n,\n        precision: i,\n        points: []\n      };\n      for (var o = 0, s = 0; s <= r; s += i) {\n        var u = this.getPointOnPath(s),\n          l = this.getPointOnPath(s + i);\n        !u || !l || (o += this.getLineLength(u.x, u.y, l.x, l.y), o >= n && (this.equidistantCache.points.push({\n          x: u.x,\n          y: u.y,\n          distance: s\n        }), o -= n));\n      }\n    }\n  }\n  getEquidistantPointOnPath(e, t, r) {\n    if (this.buildEquidistantCache(t, r), e < 0 || e - this.getPathLength() > 5e-5) return null;\n    var i = Math.round(e / this.getPathLength() * (this.equidistantCache.points.length - 1));\n    return this.equidistantCache.points[i] || null;\n  }\n}\nvar e2 = /^\\s*data:(([^/,;]+\\/[^/,;]+)(?:;([^,;=]+=[^,;=]+))?)?(?:;(base64))?,(.*)$/i;\nclass t2 extends Ge {\n  constructor(e, t, r) {\n    super(e, t, r), this.type = \"image\", this.loaded = !1;\n    var i = this.getHrefAttribute().getString();\n    if (i) {\n      var n = i.endsWith(\".svg\") || /^\\s*data:image\\/svg\\+xml/i.test(i);\n      e.images.push(this), n ? this.loadSvg(i) : this.loadImage(i), this.isSvg = n;\n    }\n  }\n  loadImage(e) {\n    var t = this;\n    return xe(function* () {\n      try {\n        var r = yield t.document.createImage(e);\n        t.image = r;\n      } catch (i) {\n        console.error('Error while loading image \"'.concat(e, '\":'), i);\n      }\n      t.loaded = !0;\n    })();\n  }\n  loadSvg(e) {\n    var t = this;\n    return xe(function* () {\n      var r = e2.exec(e);\n      if (r) {\n        var i = r[5];\n        r[4] === \"base64\" ? t.image = atob(i) : t.image = decodeURIComponent(i);\n      } else try {\n        var n = yield t.document.fetch(e),\n          o = yield n.text();\n        t.image = o;\n      } catch (s) {\n        console.error('Error while loading image \"'.concat(e, '\":'), s);\n      }\n      t.loaded = !0;\n    })();\n  }\n  renderChildren(e) {\n    var {\n        document: t,\n        image: r,\n        loaded: i\n      } = this,\n      n = this.getAttribute(\"x\").getPixels(\"x\"),\n      o = this.getAttribute(\"y\").getPixels(\"y\"),\n      s = this.getStyle(\"width\").getPixels(\"x\"),\n      u = this.getStyle(\"height\").getPixels(\"y\");\n    if (!(!i || !r || !s || !u)) {\n      if (e.save(), e.translate(n, o), this.isSvg) {\n        var l = t.canvg.forkString(e, this.image, {\n          ignoreMouse: !0,\n          ignoreAnimation: !0,\n          ignoreDimensions: !0,\n          ignoreClear: !0,\n          offsetX: 0,\n          offsetY: 0,\n          scaleWidth: s,\n          scaleHeight: u\n        });\n        l.document.documentElement.parent = this, l.render();\n      } else {\n        var h = this.image;\n        t.setViewBox({\n          ctx: e,\n          aspectRatio: this.getAttribute(\"preserveAspectRatio\").getString(),\n          width: s,\n          desiredWidth: h.width,\n          height: u,\n          desiredHeight: h.height\n        }), this.loaded && (typeof h.complete > \"u\" || h.complete) && e.drawImage(h, 0, 0);\n      }\n      e.restore();\n    }\n  }\n  getBoundingBox() {\n    var e = this.getAttribute(\"x\").getPixels(\"x\"),\n      t = this.getAttribute(\"y\").getPixels(\"y\"),\n      r = this.getStyle(\"width\").getPixels(\"x\"),\n      i = this.getStyle(\"height\").getPixels(\"y\");\n    return new ce(e, t, e + r, t + i);\n  }\n}\nclass r2 extends Ge {\n  constructor() {\n    super(...arguments), this.type = \"symbol\";\n  }\n  render(e) {}\n}\nclass a2 {\n  constructor(e) {\n    this.document = e, this.loaded = !1, e.fonts.push(this);\n  }\n  load(e, t) {\n    var r = this;\n    return xe(function* () {\n      try {\n        var {\n            document: i\n          } = r,\n          n = yield i.canvg.parser.load(t),\n          o = n.getElementsByTagName(\"font\");\n        Array.from(o).forEach(s => {\n          var u = i.createElement(s);\n          i.definitions[e] = u;\n        });\n      } catch (s) {\n        console.error('Error while loading font \"'.concat(t, '\":'), s);\n      }\n      r.loaded = !0;\n    })();\n  }\n}\nlet Cl = /*#__PURE__*/(() => {\n  class Cl extends I {\n    constructor(e, t, r) {\n      super(e, t, r), this.type = \"style\";\n      var i = lt(Array.from(t.childNodes).map(o => o.textContent).join(\"\").replace(/(\\/\\*([^*]|[\\r\\n]|(\\*+([^*/]|[\\r\\n])))*\\*+\\/)|(^[\\s]*\\/\\/.*)/gm, \"\").replace(/@import.*;/g, \"\")\n        // remove imports\n        ),\n        n = i.split(\"}\");\n      n.forEach(o => {\n        var s = o.trim();\n        if (s) {\n          var u = s.split(\"{\"),\n            l = u[0].split(\",\"),\n            h = u[1].split(\";\");\n          l.forEach(f => {\n            var c = f.trim();\n            if (c) {\n              var v = e.styles[c] || {};\n              if (h.forEach(p => {\n                var y = p.indexOf(\":\"),\n                  x = p.substr(0, y).trim(),\n                  b = p.substr(y + 1, p.length - y).trim();\n                x && b && (v[x] = new S(e, x, b));\n              }), e.styles[c] = v, e.stylesSpecificity[c] = m1(c), c === \"@font-face\") {\n                var g = v[\"font-family\"].getString().replace(/\"|'/g, \"\"),\n                  d = v.src.getString().split(\",\");\n                d.forEach(p => {\n                  if (p.indexOf('format(\"svg\")') > 0) {\n                    var y = ml(p);\n                    y && new a2(e).load(g, y);\n                  }\n                });\n              }\n            }\n          });\n        }\n      });\n    }\n  }\n  Cl.parseExternalUrl = ml;\n  return Cl;\n})();\nclass i2 extends Ge {\n  constructor() {\n    super(...arguments), this.type = \"use\";\n  }\n  setContext(e) {\n    super.setContext(e);\n    var t = this.getAttribute(\"x\"),\n      r = this.getAttribute(\"y\");\n    t.hasValue() && e.translate(t.getPixels(\"x\"), 0), r.hasValue() && e.translate(0, r.getPixels(\"y\"));\n  }\n  path(e) {\n    var {\n      element: t\n    } = this;\n    t && t.path(e);\n  }\n  renderChildren(e) {\n    var {\n      document: t,\n      element: r\n    } = this;\n    if (r) {\n      var i = r;\n      if (r.type === \"symbol\" && (i = new Nt(t, null), i.attributes.viewBox = new S(t, \"viewBox\", r.getAttribute(\"viewBox\").getString()), i.attributes.preserveAspectRatio = new S(t, \"preserveAspectRatio\", r.getAttribute(\"preserveAspectRatio\").getString()), i.attributes.overflow = new S(t, \"overflow\", r.getAttribute(\"overflow\").getString()), i.children = r.children, r.styles.opacity = new S(t, \"opacity\", this.calculateOpacity())), i.type === \"svg\") {\n        var n = this.getStyle(\"width\", !1, !0),\n          o = this.getStyle(\"height\", !1, !0);\n        n.hasValue() && (i.attributes.width = new S(t, \"width\", n.getString())), o.hasValue() && (i.attributes.height = new S(t, \"height\", o.getString()));\n      }\n      var s = i.parent;\n      i.parent = this, i.render(e), i.parent = s;\n    }\n  }\n  getBoundingBox(e) {\n    var {\n      element: t\n    } = this;\n    return t ? t.getBoundingBox(e) : null;\n  }\n  elementTransform() {\n    var {\n      document: e,\n      element: t\n    } = this;\n    return Be.fromElement(e, t);\n  }\n  get element() {\n    return this.cachedElement || (this.cachedElement = this.getHrefAttribute().getDefinition()), this.cachedElement;\n  }\n}\nfunction nr(a, e, t, r, i, n) {\n  return a[t * r * 4 + e * 4 + n];\n}\nfunction sr(a, e, t, r, i, n, o) {\n  a[t * r * 4 + e * 4 + n] = o;\n}\nfunction F(a, e, t) {\n  var r = a[e];\n  return r * t;\n}\nfunction me(a, e, t, r) {\n  return e + Math.cos(a) * t + Math.sin(a) * r;\n}\nclass Al extends I {\n  constructor(e, t, r) {\n    super(e, t, r), this.type = \"feColorMatrix\";\n    var i = ne(this.getAttribute(\"values\").getString());\n    switch (this.getAttribute(\"type\").getString(\"matrix\")) {\n      case \"saturate\":\n        {\n          var n = i[0];\n          i = [0.213 + 0.787 * n, 0.715 - 0.715 * n, 0.072 - 0.072 * n, 0, 0, 0.213 - 0.213 * n, 0.715 + 0.285 * n, 0.072 - 0.072 * n, 0, 0, 0.213 - 0.213 * n, 0.715 - 0.715 * n, 0.072 + 0.928 * n, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1];\n          break;\n        }\n      case \"hueRotate\":\n        {\n          var o = i[0] * Math.PI / 180;\n          i = [me(o, 0.213, 0.787, -0.213), me(o, 0.715, -0.715, -0.715), me(o, 0.072, -0.072, 0.928), 0, 0, me(o, 0.213, -0.213, 0.143), me(o, 0.715, 0.285, 0.14), me(o, 0.072, -0.072, -0.283), 0, 0, me(o, 0.213, -0.213, -0.787), me(o, 0.715, -0.715, 0.715), me(o, 0.072, 0.928, 0.072), 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1];\n          break;\n        }\n      case \"luminanceToAlpha\":\n        i = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0.2125, 0.7154, 0.0721, 0, 0, 0, 0, 0, 0, 1];\n        break;\n    }\n    this.matrix = i, this.includeOpacity = this.getAttribute(\"includeOpacity\").hasValue();\n  }\n  apply(e, t, r, i, n) {\n    for (var {\n        includeOpacity: o,\n        matrix: s\n      } = this, u = e.getImageData(0, 0, i, n), l = 0; l < n; l++) for (var h = 0; h < i; h++) {\n      var f = nr(u.data, h, l, i, n, 0),\n        c = nr(u.data, h, l, i, n, 1),\n        v = nr(u.data, h, l, i, n, 2),\n        g = nr(u.data, h, l, i, n, 3),\n        d = F(s, 0, f) + F(s, 1, c) + F(s, 2, v) + F(s, 3, g) + F(s, 4, 1),\n        p = F(s, 5, f) + F(s, 6, c) + F(s, 7, v) + F(s, 8, g) + F(s, 9, 1),\n        y = F(s, 10, f) + F(s, 11, c) + F(s, 12, v) + F(s, 13, g) + F(s, 14, 1),\n        x = F(s, 15, f) + F(s, 16, c) + F(s, 17, v) + F(s, 18, g) + F(s, 19, 1);\n      o && (d = 0, p = 0, y = 0, x *= g / 255), sr(u.data, h, l, i, n, 0, d), sr(u.data, h, l, i, n, 1, p), sr(u.data, h, l, i, n, 2, y), sr(u.data, h, l, i, n, 3, x);\n    }\n    e.clearRect(0, 0, i, n), e.putImageData(u, 0, 0);\n  }\n}\nlet kr = /*#__PURE__*/(() => {\n  class kr extends I {\n    constructor() {\n      super(...arguments), this.type = \"mask\";\n    }\n    apply(e, t) {\n      var {\n          document: r\n        } = this,\n        i = this.getAttribute(\"x\").getPixels(\"x\"),\n        n = this.getAttribute(\"y\").getPixels(\"y\"),\n        o = this.getStyle(\"width\").getPixels(\"x\"),\n        s = this.getStyle(\"height\").getPixels(\"y\");\n      if (!o && !s) {\n        var u = new ce();\n        this.children.forEach(g => {\n          u.addBoundingBox(g.getBoundingBox(e));\n        }), i = Math.floor(u.x1), n = Math.floor(u.y1), o = Math.floor(u.width), s = Math.floor(u.height);\n      }\n      var l = this.removeStyles(t, kr.ignoreStyles),\n        h = r.createCanvas(i + o, n + s),\n        f = h.getContext(\"2d\");\n      r.screen.setDefaults(f), this.renderChildren(f), new Al(r, {\n        nodeType: 1,\n        childNodes: [],\n        attributes: [{\n          nodeName: \"type\",\n          value: \"luminanceToAlpha\"\n        }, {\n          nodeName: \"includeOpacity\",\n          value: \"true\"\n        }]\n      }).apply(f, 0, 0, i + o, n + s);\n      var c = r.createCanvas(i + o, n + s),\n        v = c.getContext(\"2d\");\n      r.screen.setDefaults(v), t.render(v), v.globalCompositeOperation = \"destination-in\", v.fillStyle = f.createPattern(h, \"no-repeat\"), v.fillRect(0, 0, i + o, n + s), e.fillStyle = v.createPattern(c, \"no-repeat\"), e.fillRect(0, 0, i + o, n + s), this.restoreStyles(t, l);\n    }\n    render(e) {}\n  }\n  kr.ignoreStyles = [\"mask\", \"transform\", \"clip-path\"];\n  return kr;\n})();\nvar _o = () => {};\nclass n2 extends I {\n  constructor() {\n    super(...arguments), this.type = \"clipPath\";\n  }\n  apply(e) {\n    var {\n        document: t\n      } = this,\n      r = Reflect.getPrototypeOf(e),\n      {\n        beginPath: i,\n        closePath: n\n      } = e;\n    r && (r.beginPath = _o, r.closePath = _o), Reflect.apply(i, e, []), this.children.forEach(o => {\n      if (!(typeof o.path > \"u\")) {\n        var s = typeof o.elementTransform < \"u\" ? o.elementTransform() : null;\n        s || (s = Be.fromElement(t, o)), s && s.apply(e), o.path(e), r && (r.closePath = n), s && s.unapply(e);\n      }\n    }), Reflect.apply(n, e, []), e.clip(), r && (r.beginPath = i, r.closePath = n);\n  }\n  render(e) {}\n}\nlet Br = /*#__PURE__*/(() => {\n  class Br extends I {\n    constructor() {\n      super(...arguments), this.type = \"filter\";\n    }\n    apply(e, t) {\n      var {\n          document: r,\n          children: i\n        } = this,\n        n = t.getBoundingBox(e);\n      if (n) {\n        var o = 0,\n          s = 0;\n        i.forEach(y => {\n          var x = y.extraFilterDistance || 0;\n          o = Math.max(o, x), s = Math.max(s, x);\n        });\n        var u = Math.floor(n.width),\n          l = Math.floor(n.height),\n          h = u + 2 * o,\n          f = l + 2 * s;\n        if (!(h < 1 || f < 1)) {\n          var c = Math.floor(n.x),\n            v = Math.floor(n.y),\n            g = this.removeStyles(t, Br.ignoreStyles),\n            d = r.createCanvas(h, f),\n            p = d.getContext(\"2d\");\n          r.screen.setDefaults(p), p.translate(-c + o, -v + s), t.render(p), i.forEach(y => {\n            typeof y.apply == \"function\" && y.apply(p, 0, 0, h, f);\n          }), e.drawImage(d, 0, 0, h, f, c - o, v - s, h, f), this.restoreStyles(t, g);\n        }\n      }\n    }\n    render(e) {}\n  }\n  Br.ignoreStyles = [\"filter\", \"transform\", \"clip-path\"];\n  return Br;\n})();\nclass s2 extends I {\n  constructor(e, t, r) {\n    super(e, t, r), this.type = \"feDropShadow\", this.addStylesFromStyleDefinition();\n  }\n  apply(e, t, r, i, n) {}\n}\nclass o2 extends I {\n  constructor() {\n    super(...arguments), this.type = \"feMorphology\";\n  }\n  apply(e, t, r, i, n) {}\n}\nclass u2 extends I {\n  constructor() {\n    super(...arguments), this.type = \"feComposite\";\n  }\n  apply(e, t, r, i, n) {}\n}\nclass l2 extends I {\n  constructor(e, t, r) {\n    super(e, t, r), this.type = \"feGaussianBlur\", this.blurRadius = Math.floor(this.getAttribute(\"stdDeviation\").getNumber()), this.extraFilterDistance = this.blurRadius;\n  }\n  apply(e, t, r, i, n) {\n    var {\n        document: o,\n        blurRadius: s\n      } = this,\n      u = o.window ? o.window.document.body : null,\n      l = e.canvas;\n    l.id = o.getUniqueId(), u && (l.style.display = \"none\", u.appendChild(l)), r1(l, t, r, i, n, s), u && u.removeChild(l);\n  }\n}\nclass h2 extends I {\n  constructor() {\n    super(...arguments), this.type = \"title\";\n  }\n}\nclass v2 extends I {\n  constructor() {\n    super(...arguments), this.type = \"desc\";\n  }\n}\nvar f2 = {\n  svg: Nt,\n  rect: El,\n  circle: D1,\n  ellipse: L1,\n  line: k1,\n  polyline: $l,\n  polygon: B1,\n  path: A,\n  pattern: j1,\n  marker: F1,\n  defs: U1,\n  linearGradient: G1,\n  radialGradient: z1,\n  stop: H1,\n  animate: on,\n  animateColor: Y1,\n  animateTransform: X1,\n  font: W1,\n  \"font-face\": q1,\n  \"missing-glyph\": Q1,\n  glyph: Sl,\n  text: Ce,\n  tspan: Lr,\n  tref: K1,\n  a: Z1,\n  textPath: J1,\n  image: t2,\n  g: sn,\n  symbol: r2,\n  style: Cl,\n  use: i2,\n  mask: kr,\n  clipPath: n2,\n  filter: Br,\n  feDropShadow: s2,\n  feMorphology: o2,\n  feComposite: u2,\n  feColorMatrix: Al,\n  feGaussianBlur: l2,\n  title: h2,\n  desc: v2\n};\nfunction Vo(a, e) {\n  var t = Object.keys(a);\n  if (Object.getOwnPropertySymbols) {\n    var r = Object.getOwnPropertySymbols(a);\n    e && (r = r.filter(function (i) {\n      return Object.getOwnPropertyDescriptor(a, i).enumerable;\n    })), t.push.apply(t, r);\n  }\n  return t;\n}\nfunction c2(a) {\n  for (var e = 1; e < arguments.length; e++) {\n    var t = arguments[e] != null ? arguments[e] : {};\n    e % 2 ? Vo(Object(t), !0).forEach(function (r) {\n      an(a, r, t[r]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(a, Object.getOwnPropertyDescriptors(t)) : Vo(Object(t)).forEach(function (r) {\n      Object.defineProperty(a, r, Object.getOwnPropertyDescriptor(t, r));\n    });\n  }\n  return a;\n}\nfunction g2(a, e) {\n  var t = document.createElement(\"canvas\");\n  return t.width = a, t.height = e, t;\n}\nfunction d2(a) {\n  return Ti.apply(this, arguments);\n}\nfunction Ti() {\n  return Ti = xe(function* (a) {\n    var e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1,\n      t = document.createElement(\"img\");\n    return e && (t.crossOrigin = \"Anonymous\"), new Promise((r, i) => {\n      t.onload = () => {\n        r(t);\n      }, t.onerror = (n, o, s, u, l) => {\n        i(l);\n      }, t.src = a;\n    });\n  }), Ti.apply(this, arguments);\n}\nlet $e = /*#__PURE__*/(() => {\n  class $e {\n    constructor(e) {\n      var {\n        rootEmSize: t = 12,\n        emSize: r = 12,\n        createCanvas: i = $e.createCanvas,\n        createImage: n = $e.createImage,\n        anonymousCrossOrigin: o\n      } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n      this.canvg = e, this.definitions = /* @__PURE__ */Object.create(null), this.styles = /* @__PURE__ */Object.create(null), this.stylesSpecificity = /* @__PURE__ */Object.create(null), this.images = [], this.fonts = [], this.emSizeStack = [], this.uniqueId = 0, this.screen = e.screen, this.rootEmSize = t, this.emSize = r, this.createCanvas = i, this.createImage = this.bindCreateImage(n, o), this.screen.wait(this.isImagesLoaded.bind(this)), this.screen.wait(this.isFontsLoaded.bind(this));\n    }\n    bindCreateImage(e, t) {\n      return typeof t == \"boolean\" ? (r, i) => e(r, typeof i == \"boolean\" ? i : t) : e;\n    }\n    get window() {\n      return this.screen.window;\n    }\n    get fetch() {\n      return this.screen.fetch;\n    }\n    get ctx() {\n      return this.screen.ctx;\n    }\n    get emSize() {\n      var {\n        emSizeStack: e\n      } = this;\n      return e[e.length - 1];\n    }\n    set emSize(e) {\n      var {\n        emSizeStack: t\n      } = this;\n      t.push(e);\n    }\n    popEmSize() {\n      var {\n        emSizeStack: e\n      } = this;\n      e.pop();\n    }\n    getUniqueId() {\n      return \"canvg\".concat(++this.uniqueId);\n    }\n    isImagesLoaded() {\n      return this.images.every(e => e.loaded);\n    }\n    isFontsLoaded() {\n      return this.fonts.every(e => e.loaded);\n    }\n    createDocumentElement(e) {\n      var t = this.createElement(e.documentElement);\n      return t.root = !0, t.addStylesFromStyleDefinition(), this.documentElement = t, t;\n    }\n    createElement(e) {\n      var t = e.nodeName.replace(/^[^:]+:/, \"\"),\n        r = $e.elementTypes[t];\n      return typeof r < \"u\" ? new r(this, e) : new R1(this, e);\n    }\n    createTextNode(e) {\n      return new V1(this, e);\n    }\n    setViewBox(e) {\n      this.screen.setViewBox(c2({\n        document: this\n      }, e));\n    }\n  }\n  $e.createCanvas = g2;\n  $e.createImage = d2;\n  $e.elementTypes = f2;\n  return $e;\n})();\nfunction Do(a, e) {\n  var t = Object.keys(a);\n  if (Object.getOwnPropertySymbols) {\n    var r = Object.getOwnPropertySymbols(a);\n    e && (r = r.filter(function (i) {\n      return Object.getOwnPropertyDescriptor(a, i).enumerable;\n    })), t.push.apply(t, r);\n  }\n  return t;\n}\nfunction De(a) {\n  for (var e = 1; e < arguments.length; e++) {\n    var t = arguments[e] != null ? arguments[e] : {};\n    e % 2 ? Do(Object(t), !0).forEach(function (r) {\n      an(a, r, t[r]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(a, Object.getOwnPropertyDescriptors(t)) : Do(Object(t)).forEach(function (r) {\n      Object.defineProperty(a, r, Object.getOwnPropertyDescriptor(t, r));\n    });\n  }\n  return a;\n}\nclass mt {\n  /**\n   * Main constructor.\n   * @param ctx - Rendering context.\n   * @param svg - SVG Document.\n   * @param options - Rendering options.\n   */\n  constructor(e, t) {\n    var r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};\n    this.parser = new za(r), this.screen = new Dr(e, r), this.options = r;\n    var i = new $e(this, r),\n      n = i.createDocumentElement(t);\n    this.document = i, this.documentElement = n;\n  }\n  /**\n   * Create Canvg instance from SVG source string or URL.\n   * @param ctx - Rendering context.\n   * @param svg - SVG source string or URL.\n   * @param options - Rendering options.\n   * @returns Canvg instance.\n   */\n  static from(e, t) {\n    var r = arguments;\n    return xe(function* () {\n      var i = r.length > 2 && r[2] !== void 0 ? r[2] : {},\n        n = new za(i),\n        o = yield n.parse(t);\n      return new mt(e, o, i);\n    })();\n  }\n  /**\n   * Create Canvg instance from SVG source string.\n   * @param ctx - Rendering context.\n   * @param svg - SVG source string.\n   * @param options - Rendering options.\n   * @returns Canvg instance.\n   */\n  static fromString(e, t) {\n    var r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {},\n      i = new za(r),\n      n = i.parseFromString(t);\n    return new mt(e, n, r);\n  }\n  /**\n   * Create new Canvg instance with inherited options.\n   * @param ctx - Rendering context.\n   * @param svg - SVG source string or URL.\n   * @param options - Rendering options.\n   * @returns Canvg instance.\n   */\n  fork(e, t) {\n    var r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};\n    return mt.from(e, t, De(De({}, this.options), r));\n  }\n  /**\n   * Create new Canvg instance with inherited options.\n   * @param ctx - Rendering context.\n   * @param svg - SVG source string.\n   * @param options - Rendering options.\n   * @returns Canvg instance.\n   */\n  forkString(e, t) {\n    var r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};\n    return mt.fromString(e, t, De(De({}, this.options), r));\n  }\n  /**\n   * Document is ready promise.\n   * @returns Ready promise.\n   */\n  ready() {\n    return this.screen.ready();\n  }\n  /**\n   * Document is ready value.\n   * @returns Is ready or not.\n   */\n  isReady() {\n    return this.screen.isReady();\n  }\n  /**\n   * Render only first frame, ignoring animations and mouse.\n   * @param options - Rendering options.\n   */\n  render() {\n    var e = arguments,\n      t = this;\n    return xe(function* () {\n      var r = e.length > 0 && e[0] !== void 0 ? e[0] : {};\n      t.start(De({\n        enableRedraw: !0,\n        ignoreAnimation: !0,\n        ignoreMouse: !0\n      }, r)), yield t.ready(), t.stop();\n    })();\n  }\n  /**\n   * Start rendering.\n   * @param options - Render options.\n   */\n  start() {\n    var e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {},\n      {\n        documentElement: t,\n        screen: r,\n        options: i\n      } = this;\n    r.start(t, De(De({\n      enableRedraw: !0\n    }, i), e));\n  }\n  /**\n   * Stop rendering.\n   */\n  stop() {\n    this.screen.stop();\n  }\n  /**\n   * Resize SVG to fit in given size.\n   * @param width\n   * @param height\n   * @param preserveAspectRatio\n   */\n  resize(e) {\n    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : e,\n      r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !1;\n    this.documentElement.resize(e, t, r);\n  }\n}\nexport { Z1 as AElement, Y1 as AnimateColorElement, on as AnimateElement, X1 as AnimateTransformElement, ce as BoundingBox, wo as CB1, Co as CB2, Ao as CB3, Po as CB4, mt as Canvg, D1 as CircleElement, n2 as ClipPathElement, U1 as DefsElement, v2 as DescElement, $e as Document, I as Element, L1 as EllipseElement, Al as FeColorMatrixElement, u2 as FeCompositeElement, s2 as FeDropShadowElement, l2 as FeGaussianBlurElement, o2 as FeMorphologyElement, Br as FilterElement, Z as Font, W1 as FontElement, q1 as FontFaceElement, sn as GElement, Sl as GlyphElement, wl as GradientElement, t2 as ImageElement, k1 as LineElement, G1 as LinearGradientElement, F1 as MarkerElement, kr as MaskElement, Tl as Matrix, Q1 as MissingGlyphElement, x1 as Mouse, rt as PSEUDO_ZERO, za as Parser, A as PathElement, w as PathParser, j1 as PatternElement, k as Point, B1 as PolygonElement, $l as PolylineElement, S as Property, Ro as QB1, No as QB2, Io as QB3, z1 as RadialGradientElement, El as RectElement, Ge as RenderedElement, E1 as Rotate, Nt as SVGElement, a2 as SVGFontLoader, $1 as Scale, Dr as Screen, Ol as Skew, w1 as SkewX, C1 as SkewY, H1 as StopElement, Cl as StyleElement, r2 as SymbolElement, K1 as TRefElement, Lr as TSpanElement, Ce as TextElement, J1 as TextPathElement, h2 as TitleElement, Be as Transform, S1 as Translate, R1 as UnknownElement, i2 as UseElement, b1 as ViewPort, lt as compressSpaces, mt as default, m1 as getSelectorSpecificity, l1 as normalizeAttributeName, h1 as normalizeColor, ml as parseExternalUrl, y2 as presets, ne as toNumbers, s1 as trimLeft, o1 as trimRight, Eo as vectorMagnitude, $o as vectorsAngle, xi as vectorsRatio };",
  "map": null,
  "metadata": {},
  "sourceType": "module",
  "externalDependencies": []
}
