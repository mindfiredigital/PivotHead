{
  "ast": null,
  "code": "import { PivotEngine, FieldService } from '@mindfiredigital/pivothead';\nfunction renderSwitch(host) {\n  const mode = host.getAttribute('mode') || 'default';\n  if (mode === 'none') {\n    if (host.shadowRoot) {\n      host.shadowRoot.innerHTML = `<style>:host { display:block; }</style>`;\n    }\n  } else if (mode === 'minimal') {\n    if (host.shadowRoot) {\n      host.shadowRoot.innerHTML = `\n        <style>\n        :host { display: block; font-family: inherit; }\n        [data-pivot-root] {\n          display: grid;\n          border: 1px solid #d8dde2; border-radius: 6px; background: #fcfdff;\n        }\n        [data-pivot-header], [data-pivot-body] {\n          padding: 0.3em 0.5em;\n        }\n        [data-pivot-header] {\n          background: #f4f7fa;\n          border-bottom: 1px solid #e2e7ed;\n          font-weight: bold;\n        }\n        </style>\n        <div role=\"grid\" data-pivot-root>\n          <div role=\"rowgroup\" data-pivot-header><slot name=\"header\"></slot></div>\n          <div role=\"rowgroup\" data-pivot-body><slot name=\"body\"></slot></div>\n        </div>\n      `;\n    }\n  } else {\n    host._showRawData ? host.renderRawTable() : host.renderFullUI();\n  }\n}\nfunction handleEngineStateChange(host, state) {\n  host.dispatchEvent(new CustomEvent('stateChange', {\n    detail: state,\n    bubbles: true,\n    composed: true\n  }));\n  host.calculatePaginationForCurrentView();\n  const mode = host.getAttribute('mode');\n  if (mode === 'none') {\n    if (host.shadowRoot) host.shadowRoot.innerHTML = `<style>:host { display:block; }</style>`;\n  } else if (mode === 'minimal') {\n    if (host.shadowRoot) {\n      host.shadowRoot.innerHTML = `\n        <style>\n        :host { display: block; font-family: inherit; }\n        [data-pivot-root] {\n          display: grid;\n          border: 1px solid #d8dde2; border-radius: 6px; background: #fcfdff;\n        }\n        [data-pivot-header], [data-pivot-body] {\n          padding: 0.3em 0.5em;\n        }\n        [data-pivot-header] {\n          background: #f4f7fa;\n          border-bottom: 1px solid #e2e7ed;\n          font-weight: bold;\n        }\n        </style>\n        <div role=\"grid\" data-pivot-root>\n          <div role=\"rowgroup\" data-pivot-header><slot name=\"header\"></slot></div>\n          <div role=\"rowgroup\" data-pivot-body><slot name=\"body\"></slot></div>\n        </div>\n      `;\n    }\n  } else {\n    host._showRawData ? host.renderRawTable() : host.renderFullUI();\n  }\n}\nfunction renderFullUI(host) {\n  const engine = host.engine;\n  if (!engine) {\n    if (host.shadowRoot) host.shadowRoot.innerHTML = '';\n    return;\n  }\n  const state = engine.getState();\n  if (!state.processedData) {\n    console.error('No processed data available');\n    return;\n  }\n  const rowField = host._options.rows?.[0];\n  const columnField = host._options.columns?.[0];\n  const measures = host._options.measures || [];\n  if (!rowField || !columnField || !measures.length) {\n    console.error('Missing row, column, or measures configuration');\n    return;\n  }\n  host.calculatePaginationForCurrentView();\n  let html = `\n      <style>\n        :host { display: block; font-family: inherit; }\n        .controls-container { margin-bottom: 20px; display: flex; flex-wrap: wrap; gap: 10px; align-items: center; }\n        .filter-container, .pagination-container { display: flex; gap: 10px; align-items: center; }\n        table { width: 100%; border-collapse: collapse; background: #ffffff; border: 1px solid #dee2e6; margin-top: 20px; }\n        th, td { border: 1px solid #dee2e6; padding: 8px; text-align: left; }\n        th { background-color: #f8f9fa; cursor: grab; font-weight: 600; }\n        .sortable-header { cursor: pointer; position: relative; }\n        .sort-icon { margin-left: 5px; font-size: 12px; color: #6c757d; opacity: 0.5; }\n        .sort-icon.active { color: #007bff; opacity: 1; }\n        .corner-cell { background-color: #f8f9fa !important; border-bottom: 2px solid #dee2e6; border-right: 1px solid #dee2e6; }\n        .column-header { background-color: #f8f9fa !important; border-bottom: 2px solid #dee2e6; text-align: center; cursor: move; }\n        .measure-header { background-color: #f8f9fa !important; border-bottom: 2px solid #dee2e6; cursor: pointer; }\n        .row-cell { font-weight: bold; background-color: #f8f9fa; }\n        tr[draggable=\"true\"] { cursor: grab; }\n        .dragging { opacity: 0.5; }\n        .drag-over { outline: 2px dashed #2672dd; background: #f3f8fd !important; }\n        tbody tr:nth-child(even) td { background: #f8fafc; }\n        button { padding: 5px 10px; background-color: #4CAF50; color: white; border: none; border-radius: 4px; cursor: pointer; }\n        button:hover { background-color: #45a049; }\n        button:disabled { background-color: #cccccc; cursor: not-allowed; }\n        select, input { padding: 5px; border-radius: 4px; border: 1px solid #ddd; }\n        \n        /* Drill-down styles */\n        .drill-down-cell { cursor: pointer; }\n        .drill-down-cell:hover { background-color: #e3f2fd !important; }\n        \n        /* Modal styles for drill-down details */\n        .drill-down-modal {\n            position: fixed;\n            top: 0;\n            left: 0;\n            width: 100%;\n            height: 100%;\n            background-color: rgba(0, 0, 0, 0.5);\n            display: flex;\n            justify-content: center;\n            align-items: center;\n            z-index: 1000;\n            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;\n        }\n\n        .drill-down-content {\n            background: white;\n            border-radius: 8px;\n            padding: 20px;\n            width: 90%;\n            max-width: 800px;\n            max-height: 80%;\n            overflow: auto;\n            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);\n        }\n\n        .drill-down-header {\n            display: flex;\n            justify-content: space-between;\n            align-items: center;\n            margin-bottom: 20px;\n            padding-bottom: 10px;\n            border-bottom: 2px solid #e0e0e0;\n        }\n\n        .drill-down-title {\n            font-size: 18px;\n            font-weight: bold;\n            color: #333;\n        }\n\n        .drill-down-close {\n            background: #f44336;\n            color: white;\n            border: none;\n            border-radius: 50%;\n            width: 30px;\n            height: 30px;\n            cursor: pointer;\n            font-size: 16px;\n            display: flex;\n            align-items: center;\n            justify-content: center;\n        }\n\n        .drill-down-close:hover {\n            background: #d32f2f;\n        }\n\n        .drill-down-summary {\n            background: #f5f5f5;\n            padding: 10px;\n            border-radius: 4px;\n            margin-bottom: 15px;\n            font-size: 14px;\n            line-height: 1.4;\n        }\n\n        .drill-down-table {\n            width: 100%;\n            border-collapse: collapse;\n            margin-top: 10px;\n            font-size: 14px;\n        }\n\n        .drill-down-table th {\n            background: #f8f9fa;\n            padding: 8px;\n            border: 1px solid #dee2e6;\n            font-weight: bold;\n            text-align: left;\n        }\n\n        .drill-down-table td {\n            padding: 6px 8px;\n            border: 1px solid #dee2e6;\n        }\n\n        .drill-down-table tr:nth-child(even) {\n            background-color: #f9f9f9;\n        }\n\n        .drill-down-table tr:hover {\n            background-color: #e3f2fd;\n        }\n      </style>\n      <div class=\"controls-container\">\n        <div class=\"filter-container\">\n          <label>Filter:</label>\n          <select id=\"filterField\"></select>\n          <select id=\"filterOperator\">\n            <option value=\"equals\">Equals</option>\n            <option value=\"contains\">Contains</option>\n            <option value=\"greaterThan\">Greater Than</option>\n            <option value=\"lessThan\">Less Than</option>\n          </select>\n          <input type=\"text\" id=\"filterValue\" placeholder=\"Value\">\n          <button id=\"applyFilter\">Apply</button>\n          <button id=\"resetFilter\">Reset</button>\n        </div>\n        <div class=\"pagination-container\">\n          <label>Items per page:</label>\n          <select id=\"pageSize\">\n            <option value=\"5\">5</option>\n            <option value=\"10\">10</option>\n            <option value=\"25\">25</option>\n            <option value=\"50\">50</option>\n          </select>\n          <button id=\"prevPage\">Previous</button>\n          <span id=\"pageInfo\">Page ${host._pagination.currentPage} of ${host._pagination.totalPages}</span>\n          <button id=\"nextPage\">Next</button>\n        </div>\n        <button id=\"switchView\">Switch to Raw Data</button>\n        <button id=\"formatButton\">Format</button>\n        <button id=\"exportHTML\">Export HTML</button>\n        <button id=\"exportPDF\">Export PDF</button>\n        <button id=\"exportExcel\">Export Excel</button>\n        <button id=\"printTable\">Print</button>\n      </div>\n    `;\n  // Determine column labels using engine's custom column order if any\n  const groupedData = engine.getGroupedData();\n  let uniqueColumnValues = engine.getOrderedColumnValues() || [...new Set(groupedData.map(g => {\n    const keys = g.key ? g.key.split('|') : [];\n    return keys[1] || keys[0];\n  }))].filter(Boolean);\n  if (host._processedColumnOrder.length === 0) {\n    host._processedColumnOrder = [...uniqueColumnValues];\n  }\n  if (host._processedColumnOrder.length > 0) {\n    uniqueColumnValues = host._processedColumnOrder.filter(col => uniqueColumnValues.includes(col));\n  }\n  html += '<table role=\"grid\">';\n  html += '<thead>';\n  html += '<tr>';\n  html += `<th class=\"corner-cell\">${rowField.caption} / ${columnField.caption}</th>`;\n  uniqueColumnValues.forEach((colValue, index) => {\n    html += `<th class=\"column-header\" draggable=\"true\" data-column-index=\"${index}\" data-column-value=\"${colValue}\" colspan=\"${measures.length}\">${colValue}</th>`;\n  });\n  html += '</tr>';\n  html += '<tr>';\n  const rowSortIcon = host.createProcessedSortIcon(rowField.uniqueName);\n  html += `<th class=\"row-cell sortable-header\" data-field=\"${rowField.uniqueName}\">\n      ${rowField.caption}${rowSortIcon}\n    </th>`;\n  uniqueColumnValues.forEach(colValue => {\n    measures.forEach((measure, measureIndex) => {\n      const sortIcon = host.createProcessedSortIcon(measure.uniqueName);\n      html += `<th class=\"measure-header sortable-header\" data-measure-index=\"${measureIndex}\" data-field=\"${measure.uniqueName}\" data-column-value=\"${colValue}\">\n          ${measure.caption}${sortIcon}\n        </th>`;\n    });\n  });\n  html += '</tr>';\n  html += '</thead>';\n  html += '<tbody>';\n  // Prefer engine-provided ordered row values (custom or due to sorting)\n  const orderedFromEngine = engine.getOrderedRowValues() || [];\n  let uniqueRowValues = [...orderedFromEngine];\n  if (uniqueRowValues.length === 0) {\n    // Fallback: derive row values from all grouped data keys so we don't miss any groups\n    const allGroups = engine.getGroupedData();\n    uniqueRowValues = [...new Set(allGroups.map(g => {\n      const keys = g.key ? g.key.split('|') : [];\n      return keys[0];\n    }))].filter(Boolean);\n  }\n  const paginatedRowValues = host.getPaginatedData(uniqueRowValues);\n  paginatedRowValues.forEach((rowValue, rowIndex) => {\n    html += `<tr draggable=\"true\" data-row-index=\"${rowIndex}\" data-row-value=\"${rowValue}\">`;\n    html += `<td class=\"row-cell\">${rowValue}</td>`;\n    uniqueColumnValues.forEach(colValue => {\n      measures.forEach(measure => {\n        const matchingGroup = groupedData.find(g => {\n          const keys = g.key ? g.key.split('|') : [];\n          return keys[0] === rowValue && keys[1] === colValue;\n        });\n        const aggKey = measure.aggregation + '_' + measure.uniqueName;\n        const value = matchingGroup?.aggregates?.[aggKey];\n        let formattedValue = '0';\n        if (value !== undefined && value !== null) {\n          formattedValue = engine.formatValue(value, measure.uniqueName);\n        }\n        const hasData = value !== undefined && value !== null && Number(value) > 0;\n        const cellClass = hasData ? 'data-cell drill-down-cell' : 'data-cell';\n        const cellTitle = hasData ? `Double-click to see details for ${rowField.caption}: ${rowValue} - ${columnField.caption}: ${colValue}` : '';\n        const textAlign = engine.getFieldAlignment(measure.uniqueName);\n        html += `<td class=\"${cellClass}\" \n                      style=\"text-align: ${textAlign};\"\n                      title=\"${cellTitle}\"\n                      data-row-value=\"${rowValue}\" \n                      data-column-value=\"${colValue}\" \n                      data-measure-name=\"${measure.uniqueName}\"\n                      data-measure-caption=\"${measure.caption}\"\n                      data-row-field=\"${rowField.uniqueName}\"\n                      data-column-field=\"${columnField.uniqueName}\"\n                      data-aggregate-value=\"${value || 0}\">\n                      ${formattedValue}\n                   </td>`;\n      });\n    });\n    html += '</tr>';\n  });\n  html += '</tbody>';\n  html += '</table>';\n  if (host.shadowRoot) host.shadowRoot.innerHTML = html;\n  host.addDragListeners();\n  host.setupControls();\n}\nfunction renderRawTable(host) {\n  const engine = host.engine;\n  if (!engine) return;\n  const state = engine.getState();\n  // Prefer full rawData first; state.data could be limited by engine defaults\n  const allRawData = state.rawData || state.data || [];\n  if (!allRawData.length) return;\n  host.updatePaginationForData(allRawData);\n  const displayData = host.getPaginatedData(allRawData);\n  const originalHeaders = Object.keys(displayData[0] || allRawData[0]);\n  let headers;\n  if (host._rawDataColumnOrder && host._rawDataColumnOrder.length > 0) {\n    const missingHeaders = originalHeaders.filter(h => !host._rawDataColumnOrder.includes(h));\n    headers = [...host._rawDataColumnOrder, ...missingHeaders];\n  } else {\n    headers = originalHeaders;\n    host._rawDataColumnOrder = [...headers];\n  }\n  let html = `\n      <style>\n        :host { display: block; font-family: inherit; }\n        .controls-container { margin-bottom: 20px; display: flex; flex-wrap: wrap; gap: 10px; align-items: center; }\n        .filter-container, .pagination-container { display: flex; gap: 10px; align-items: center; }\n        table { width: 100%; border-collapse: collapse; background: #ffffff; border: 1px solid #e2e7ed; }\n        th, td { border: 1px solid #dde1e7; padding: 8px; text-align: left; }\n        th { background-color: #eaf2fa; cursor: grab; font-weight: 600; }\n        .sortable-header { cursor: pointer !important; position: relative; }\n        .sort-icon { margin-left: 5px; font-size: 12px; color: #6c757d; opacity: 0.5; }\n        .sort-icon.active { color: #007bff; opacity: 1; }\n        tr[draggable=\"true\"] { cursor: grab; }\n        .dragging { opacity: 0.5; }\n        .drag-over { outline: 2px dashed #2672dd; background: #f3f8fd !important; }\n        tbody tr:nth-child(even) td { background: #f8fafc; }\n        button { padding: 5px 10px; background-color: #4CAF50; color: white; border: none; border-radius: 4px; cursor: pointer; }\n        button:hover { background-color: #45a049; }\n        button:disabled { background-color: #cccccc; cursor: not-allowed; }\n        select, input { padding: 5px; border-radius: 4px; border: 1px solid #ddd; }\n      </style>\n      <div class=\"controls-container\">\n        <div class=\"filter-container\">\n          <label>Filter:</label>\n          <select id=\"filterField\"></select>\n          <select id=\"filterOperator\">\n            <option value=\"equals\">Equals</option>\n            <option value=\"contains\">Contains</option>\n            <option value=\"greaterThan\">Greater Than</option>\n            <option value=\"lessThan\">Less Than</option>\n          </select>\n          <input type=\"text\" id=\"filterValue\" placeholder=\"Value\">\n          <button id=\"applyFilter\">Apply</button>\n          <button id=\"resetFilter\">Reset</button>\n        </div>\n        <div class=\"pagination-container\">\n          <label>Items per page:</label>\n          <select id=\"pageSize\">\n            <option value=\"5\">5</option>\n            <option value=\"10\">10</option>\n            <option value=\"25\">25</option>\n            <option value=\"50\">50</option>\n          </select>\n          <button id=\"prevPage\">Previous</button>\n          <span id=\"pageInfo\">Page ${host._pagination.currentPage} of ${host._pagination.totalPages}</span>\n          <button id=\"nextPage\">Next</button>\n        </div>\n        <button id=\"switchView\">Switch to Processed Data</button>\n        <button id=\"formatButton\">Format</button>\n        <button id=\"exportHTML\">Export HTML</button>\n        <button id=\"exportPDF\">Export PDF</button>\n        <button id=\"exportExcel\">Export Excel</button>\n        <button id=\"printTable\">Print</button>\n      </div>\n    `;\n  html += '<table data-raw=\"true\">';\n  html += '<thead><tr>';\n  headers.forEach((header, index) => {\n    const sortIcon = host.createSortIcon(header);\n    html += `<th class=\"sortable-header\" draggable=\"true\" data-column-index=\"${index}\" data-field=\"${header}\">\n        ${header}${sortIcon}\n      </th>`;\n  });\n  html += '</tr></thead>';\n  html += '<tbody>';\n  displayData.forEach((row, rowIndex) => {\n    const pivotRow = row;\n    html += `<tr draggable=\"true\" data-row-index=\"${rowIndex}\">`;\n    headers.forEach(header => {\n      const cellValue = pivotRow[header];\n      let formattedValue = cellValue;\n      if (cellValue !== undefined && cellValue !== null) {\n        formattedValue = engine.formatValue(cellValue, header);\n      }\n      const textAlign = engine.getFieldAlignment(header);\n      html += `<td style=\"text-align: ${textAlign};\">${formattedValue}</td>`;\n    });\n    html += '</tr>';\n  });\n  html += '</tbody></table>';\n  if (host.shadowRoot) host.shadowRoot.innerHTML = html;\n  host.addDragListeners();\n  host.setupControls();\n}\n\n// Events: bindControls and updatePaginationInfo\nfunction bindControls(host) {\n  const filterField = host.shadowRoot?.getElementById('filterField');\n  if (filterField) {\n    if (host._showRawData) {\n      if (host._data.length > 0) {\n        filterField.innerHTML = Object.keys(host._data[0]).map(f => `<option value=\"${f}\">${f}</option>`).join('');\n      }\n    } else {\n      let options = '';\n      if (host._options.rows) {\n        host._options.rows.forEach(row => {\n          options += `<option value=\"${row.uniqueName}\">${row.caption}</option>`;\n        });\n      }\n      if (host._options.columns) {\n        host._options.columns.forEach(col => {\n          options += `<option value=\"${col.uniqueName}\">${col.caption}</option>`;\n        });\n      }\n      if (host._options.measures) {\n        host._options.measures.forEach(measure => {\n          const aggregatedKey = `${measure.aggregation}_${measure.uniqueName}`;\n          options += `<option value=\"${aggregatedKey}\">${measure.caption}</option>`;\n        });\n      }\n      filterField.innerHTML = options;\n    }\n  }\n  const filterValueInput = host.shadowRoot?.getElementById('filterValue');\n  if (filterValueInput && host._filters.length > 0) {\n    const currentFilter = host._filters[0];\n    if (currentFilter) {\n      const filterFieldElement = host.shadowRoot?.getElementById('filterField');\n      const filterOperatorElement = host.shadowRoot?.getElementById('filterOperator');\n      if (filterFieldElement) {\n        filterFieldElement.value = currentFilter.field;\n      }\n      if (filterOperatorElement) {\n        filterOperatorElement.value = currentFilter.operator;\n      }\n      filterValueInput.value = currentFilter.value;\n    }\n  }\n  const pageSizeSelect = host.shadowRoot?.getElementById('pageSize');\n  if (pageSizeSelect) {\n    Array.from(pageSizeSelect.options).forEach(option => {\n      option.removeAttribute('selected');\n      option.selected = false;\n    });\n    pageSizeSelect.value = host._pagination.pageSize.toString();\n    const selectedOption = pageSizeSelect.querySelector(`option[value=\"${host._pagination.pageSize}\"]`);\n    if (selectedOption) {\n      selectedOption.selected = true;\n      selectedOption.setAttribute('selected', 'selected');\n    }\n  }\n  const applyBtn = host.shadowRoot?.getElementById('applyFilter');\n  if (applyBtn) {\n    const newApplyBtn = applyBtn.cloneNode(true);\n    applyBtn.parentNode?.replaceChild(newApplyBtn, applyBtn);\n    newApplyBtn.addEventListener('click', () => {\n      const fieldElement = host.shadowRoot?.getElementById('filterField');\n      const operatorElement = host.shadowRoot?.getElementById('filterOperator');\n      const valueElement = host.shadowRoot?.getElementById('filterValue');\n      if (!fieldElement || !operatorElement || !valueElement) return;\n      const field = fieldElement.value;\n      const operator = operatorElement.value;\n      const value = valueElement.value;\n      if (!field || !operator || !value) return;\n      const filter = {\n        field,\n        operator: operator,\n        value\n      };\n      host.filters = [filter];\n    });\n  }\n  const resetBtn = host.shadowRoot?.getElementById('resetFilter');\n  if (resetBtn) {\n    const newResetBtn = resetBtn.cloneNode(true);\n    resetBtn.parentNode?.replaceChild(newResetBtn, resetBtn);\n    newResetBtn.addEventListener('click', () => {\n      host.reset();\n    });\n  }\n  const pageSizeSel = host.shadowRoot?.getElementById('pageSize');\n  if (pageSizeSel) {\n    const newPageSizeSel = pageSizeSel.cloneNode(true);\n    pageSizeSel.parentNode?.replaceChild(newPageSizeSel, pageSizeSel);\n    newPageSizeSel.addEventListener('change', e => {\n      const target = e.target;\n      host.setPageSize(Number(target.value));\n    });\n  }\n  const prevBtn = host.shadowRoot?.getElementById('prevPage');\n  if (prevBtn) {\n    const newPrevBtn = prevBtn.cloneNode(true);\n    prevBtn.parentNode?.replaceChild(newPrevBtn, prevBtn);\n    newPrevBtn.addEventListener('click', () => host.previousPage());\n  }\n  const nextBtn = host.shadowRoot?.getElementById('nextPage');\n  if (nextBtn) {\n    const newNextBtn = nextBtn.cloneNode(true);\n    nextBtn.parentNode?.replaceChild(newNextBtn, nextBtn);\n    newNextBtn.addEventListener('click', () => host.nextPage());\n  }\n  updatePaginationInfo(host);\n  const switchBtn = host.shadowRoot?.getElementById('switchView');\n  if (switchBtn) {\n    const newSwitchBtn = switchBtn.cloneNode(true);\n    switchBtn.parentNode?.replaceChild(newSwitchBtn, switchBtn);\n    newSwitchBtn.textContent = host._showRawData ? 'Switch to Processed Data' : 'Switch to Raw Data';\n    newSwitchBtn.addEventListener('click', () => {\n      host._showRawData = !host._showRawData;\n      try {\n        if (host.engine) {\n          host.engine.setDataHandlingMode(host._showRawData ? 'raw' : 'processed');\n          const currentFilters = host._showRawData ? host._rawFilters : host._processedFilters;\n          host.engine.applyFilters(currentFilters);\n          host.dispatchEvent(new CustomEvent('viewModeChange', {\n            detail: {\n              mode: host._showRawData ? 'raw' : 'processed'\n            },\n            bubbles: true,\n            composed: true\n          }));\n        }\n      } catch (error) {\n        console.error('Error during view switch:', error);\n      }\n    });\n  }\n  const exportHTML = host.shadowRoot?.getElementById('exportHTML');\n  if (exportHTML) {\n    const newExportHTML = exportHTML.cloneNode(true);\n    exportHTML.parentNode?.replaceChild(newExportHTML, exportHTML);\n    newExportHTML.addEventListener('click', () => host.exportToHTML());\n  }\n  const exportPDF = host.shadowRoot?.getElementById('exportPDF');\n  if (exportPDF) {\n    const newExportPDF = exportPDF.cloneNode(true);\n    exportPDF.parentNode?.replaceChild(newExportPDF, exportPDF);\n    newExportPDF.addEventListener('click', () => host.exportToPDF());\n  }\n  const exportExcel = host.shadowRoot?.getElementById('exportExcel');\n  if (exportExcel) {\n    const newExportExcel = exportExcel.cloneNode(true);\n    exportExcel.parentNode?.replaceChild(newExportExcel, exportExcel);\n    newExportExcel.addEventListener('click', () => host.exportToExcel());\n  }\n  const printBtn = host.shadowRoot?.getElementById('printTable');\n  if (printBtn) {\n    const newPrintBtn = printBtn.cloneNode(true);\n    printBtn.parentNode?.replaceChild(newPrintBtn, printBtn);\n    newPrintBtn.addEventListener('click', () => host.openPrintDialog());\n  }\n  const formatBtn = host.shadowRoot?.getElementById('formatButton');\n  if (formatBtn) {\n    const newFormatBtn = formatBtn.cloneNode(true);\n    formatBtn.parentNode?.replaceChild(newFormatBtn, formatBtn);\n    newFormatBtn.addEventListener('click', () => {\n      host.showFormatPopup();\n    });\n  }\n}\nfunction updatePaginationInfo(host) {\n  const pageInfo = host.shadowRoot?.getElementById('pageInfo');\n  if (pageInfo) {\n    const viewMode = host._showRawData ? 'Raw Data' : 'Processed Data';\n    pageInfo.textContent = `${viewMode} - Page ${host._pagination.currentPage} of ${host._pagination.totalPages}`;\n  }\n  const prevButton = host.shadowRoot?.getElementById('prevPage');\n  const nextButton = host.shadowRoot?.getElementById('nextPage');\n  if (prevButton) prevButton.disabled = host._pagination.currentPage <= 1;\n  if (nextButton) nextButton.disabled = host._pagination.currentPage >= host._pagination.totalPages;\n}\n// Drag & drill-down & sort handlers\nfunction addDragListeners(host) {\n  const headers = host.shadowRoot?.querySelectorAll('th[draggable=\"true\"]');\n  headers?.forEach(header => {\n    header.addEventListener('dragstart', e => {\n      handleColumnDragStart(host, e);\n    });\n    header.addEventListener('dragover', e => {\n      handleColumnDragOver(host, e);\n    });\n    header.addEventListener('dragleave', e => {\n      handleColumnDragLeave(host, e);\n    });\n    header.addEventListener('drop', e => {\n      handleColumnDrop(host, e);\n    });\n    header.addEventListener('dragend', () => {\n      handleColumnDragEnd(host);\n    });\n  });\n  const rows = host.shadowRoot?.querySelectorAll('tr[draggable=\"true\"]');\n  rows?.forEach(row => {\n    row.addEventListener('dragstart', e => {\n      handleRowDragStart(host, e);\n    });\n    row.addEventListener('dragover', e => {\n      handleRowDragOver(host, e);\n    });\n    row.addEventListener('dragleave', e => {\n      handleRowDragLeave(host, e);\n    });\n    row.addEventListener('drop', e => {\n      handleRowDrop(host, e);\n    });\n    row.addEventListener('dragend', () => {\n      handleRowDragEnd(host);\n    });\n  });\n  const sortableHeaders = host.shadowRoot?.querySelectorAll('.sortable-header');\n  sortableHeaders?.forEach(header => {\n    header.addEventListener('click', e => {\n      handleSortClick(host, e);\n    });\n  });\n  const drillDownCells = host.shadowRoot?.querySelectorAll('.drill-down-cell');\n  drillDownCells?.forEach(cell => {\n    cell.addEventListener('dblclick', e => {\n      handleDrillDownClick(host, e);\n    });\n  });\n}\nfunction handleSortClick(host, e) {\n  if (!host.engine) return;\n  const target = e.target;\n  const header = target.closest('.sortable-header');\n  if (!header) return;\n  const field = header.dataset.field;\n  if (!field) return;\n  // Calculate next direction based on current engine state\n  const state = host.engine.getState();\n  const current = state.sortConfig && state.sortConfig.length > 0 ? state.sortConfig[0] : null;\n  const nextDir = current && current.field === field && current.direction === 'asc' ? 'desc' : 'asc';\n  // In processed mode, clicking a measure header under a specific column\n  // should sort ROWS by that column's measure aggregate. We compute the row\n  // order and store it in the engine as a custom row order so rendering uses it.\n  if (!host._showRawData) {\n    const isMeasureHeader = header.hasAttribute('data-measure-index');\n    const columnValue = header.getAttribute('data-column-value') || '';\n    if (isMeasureHeader && columnValue) {\n      try {\n        const measures = host._options.measures || [];\n        const measureCfg = measures.find(m => m.uniqueName === field);\n        const aggregation = measureCfg?.aggregation || 'sum';\n        const aggKey = `${aggregation}_${field}`;\n        const groups = host.engine.getGroupedData();\n        // Build the full set of row values across ALL groups (not just those that appear for the selected column)\n        const allRowSet = new Set();\n        groups.forEach(g => {\n          const keys = g.key ? g.key.split('|') : [];\n          if (keys[0]) allRowSet.add(keys[0]);\n        });\n        const allRowValues = Array.from(allRowSet);\n        // Create [row, value] pairs for the target column; treat missing intersections as 0\n        const pairs = allRowValues.map(rv => {\n          const grp = groups.find(gr => {\n            const keys = gr.key ? gr.key.split('|') : [];\n            return keys[0] === rv && keys[1] === columnValue;\n          });\n          const aggregates = grp?.aggregates || {};\n          const val = Number(aggregates[aggKey] ?? 0);\n          return {\n            row: rv,\n            val: isFinite(val) ? val : 0\n          };\n        });\n        // Sort according to nextDir, keeping zero-value rows included\n        pairs.sort((a, b) => nextDir === 'asc' ? a.val - b.val : b.val - a.val);\n        const orderedRows = pairs.map(p => p.row);\n        const rowFieldName = host._options.rows?.[0]?.uniqueName || '';\n        if (rowFieldName && orderedRows.length > 0) {\n          host.engine.setCustomFieldOrder(rowFieldName, orderedRows, true);\n        }\n      } catch (err) {\n        console.error('Failed to compute/set custom row order for processed sort:', err);\n      }\n    } else {\n      // If sorting by the row dimension header, compute alphabetical order\n      const rowFieldName = host._options.rows?.[0]?.uniqueName || '';\n      if (rowFieldName && field === rowFieldName) {\n        try {\n          const groups = host.engine.getGroupedData();\n          const rowSet = new Set();\n          groups.forEach(g => {\n            const keys = g.key ? g.key.split('|') : [];\n            if (keys[0]) rowSet.add(keys[0]);\n          });\n          const rows = Array.from(rowSet);\n          rows.sort((a, b) => nextDir === 'asc' ? a.localeCompare(b) : b.localeCompare(a));\n          if (rows.length > 0) {\n            host.engine.setCustomFieldOrder(rowFieldName, rows, true);\n          }\n        } catch (err) {\n          console.error('Failed to set custom row order for dimension sort:', err);\n        }\n      }\n    }\n  }\n  // Also call engine.sort to update its sort state (icons) and internal groups\n  host.engine.sort(field, nextDir);\n}\nfunction handleDrillDownClick(host, e) {\n  if (!host.engine) return;\n  const cell = e.target.closest('.drill-down-cell');\n  if (!cell) return;\n  const rowValue = cell.getAttribute('data-row-value') || '';\n  const columnValue = cell.getAttribute('data-column-value') || '';\n  const measureName = cell.getAttribute('data-measure-name') || '';\n  const measureCaption = cell.getAttribute('data-measure-caption') || measureName;\n  const rowField = cell.getAttribute('data-row-field') || '';\n  const columnField = cell.getAttribute('data-column-field') || '';\n  const state = host.engine.getState();\n  const rawData = state.rawData || state.data || [];\n  const subset = rawData.filter(r => {\n    const rowOk = rowField ? String(r[rowField] ?? '') === String(rowValue) : true;\n    const colOk = columnField ? String(r[columnField] ?? '') === String(columnValue) : true;\n    return rowOk && colOk;\n  });\n  addModalStylesToDocument();\n  const overlay = document.createElement('div');\n  overlay.className = 'drill-down-modal';\n  const content = document.createElement('div');\n  content.className = 'drill-down-content';\n  content.innerHTML = `\n      <div class=\"drill-down-header\">\n        <div class=\"drill-down-title\">Details: ${rowField}: ${rowValue}${columnField ? `, ${columnField}: ${columnValue}` : ''}</div>\n        <button class=\"drill-down-close\" aria-label=\"Close\">&times;</button>\n      </div>\n      <div class=\"drill-down-summary\">\n        Records: ${subset.length}. Measure: ${measureCaption} (${measureName}).\n      </div>\n      <div class=\"drill-down-body\"></div>\n    `;\n  const bodyDiv = content.querySelector('.drill-down-body');\n  if (subset.length > 0) {\n    const headers = Object.keys(subset[0]);\n    const table = document.createElement('table');\n    table.className = 'drill-down-table';\n    const thead = document.createElement('thead');\n    const trh = document.createElement('tr');\n    headers.forEach(h => {\n      const th = document.createElement('th');\n      th.textContent = h;\n      trh.appendChild(th);\n    });\n    thead.appendChild(trh);\n    table.appendChild(thead);\n    const tbody = document.createElement('tbody');\n    subset.forEach(row => {\n      const tr = document.createElement('tr');\n      headers.forEach(h => {\n        const td = document.createElement('td');\n        const val = row[h];\n        td.textContent = val != null ? String(val) : '';\n        tr.appendChild(td);\n      });\n      tbody.appendChild(tr);\n    });\n    table.appendChild(tbody);\n    bodyDiv.appendChild(table);\n  } else {\n    bodyDiv.textContent = 'No matching records.';\n  }\n  overlay.appendChild(content);\n  document.body.appendChild(overlay);\n  const close = () => overlay.remove();\n  overlay.addEventListener('click', evt => {\n    if (evt.target === overlay) close();\n  });\n  const closeBtn = content.querySelector('.drill-down-close');\n  closeBtn?.addEventListener('click', close);\n}\nfunction addModalStylesToDocument() {\n  if (document.getElementById('pivot-head-modal-styles')) return;\n  const styleEl = document.createElement('style');\n  styleEl.id = 'pivot-head-modal-styles';\n  styleEl.textContent = `\n      .drill-down-modal {\n          position: fixed;\n          top: 0;\n          left: 0;\n          width: 100%;\n          height: 100%;\n          background-color: rgba(0, 0, 0, 0.5);\n          display: flex;\n          justify-content: center;\n          align-items: center;\n          z-index: 1000;\n          font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;\n      }\n      .drill-down-content {\n          background: white;\n          border-radius: 8px;\n          padding: 20px;\n          width: 90%;\n          max-width: 800px;\n          max-height: 80%;\n          overflow: auto;\n          box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);\n      }\n      .drill-down-header {\n          display: flex;\n          justify-content: space-between;\n          align-items: center;\n          margin-bottom: 20px;\n          padding-bottom: 10px;\n          border-bottom: 2px solid #e0e0e0;\n      }\n      .drill-down-title { font-size: 18px; font-weight: bold; color: #333; }\n      .drill-down-close {\n          background: #f44336;\n          color: white;\n          border: none;\n          border-radius: 50%;\n          width: 30px;\n          height: 30px;\n          cursor: pointer;\n          font-size: 16px;\n          display: flex;\n          align-items: center;\n          justify-content: center;\n      }\n      .drill-down-close:hover { background: #d32f2f; }\n      .drill-down-summary { background: #f5f5f5; padding: 10px; border-radius: 4px; margin-bottom: 15px; font-size: 14px; line-height: 1.4; }\n      .drill-down-table { width: 100%; border-collapse: collapse; margin-top: 10px; font-size: 14px; }\n      .drill-down-table th { background: #f8f9fa; padding: 8px; border: 1px solid #dee2e6; font-weight: bold; text-align: left; }\n      .drill-down-table td { padding: 6px 8px; border: 1px solid #dee2e6; }\n      .drill-down-table tr:nth-child(even) { background-color: #f9f9f9; }\n      .drill-down-table tr:hover { background-color: #e3f2fd; }\n    `;\n  document.head.appendChild(styleEl);\n}\n// Sort icons\nfunction createSortIcon(host, field) {\n  if (!host.engine) {\n    return '<span class=\"sort-icon\" title=\"Click to sort\">&#8693;</span>';\n  }\n  const state = host.engine.getState();\n  const sortConfig = state.sortConfig && state.sortConfig.length > 0 ? state.sortConfig[0] : null;\n  const isCurrentlySorted = !!(sortConfig && sortConfig.field === field);\n  if (isCurrentlySorted) {\n    if (sortConfig && sortConfig.direction === 'asc') {\n      return '<span class=\"sort-icon active\" title=\"Sorted ascending\">&#9650;</span>';\n    } else {\n      return '<span class=\"sort-icon active\" title=\"Sorted descending\">&#9660;</span>';\n    }\n  }\n  return '<span class=\"sort-icon\" title=\"Click to sort\">&#8693;</span>';\n}\nfunction createProcessedSortIcon(host, field) {\n  if (!host.engine) {\n    return '<span class=\"sort-icon\" title=\"Click to sort\">&#8693;</span>';\n  }\n  const state = host.engine.getState();\n  const sortConfig = state.sortConfig && state.sortConfig.length > 0 ? state.sortConfig[0] : null;\n  const isCurrentlySorted = !!(sortConfig && sortConfig.field === field);\n  if (isCurrentlySorted) {\n    if (sortConfig && sortConfig.direction === 'asc') {\n      return '<span class=\"sort-icon active\" title=\"Sorted ascending\">&#9650;</span>';\n    } else {\n      return '<span class=\"sort-icon active\" title=\"Sorted descending\">&#9660;</span>';\n    }\n  }\n  return '<span class=\"sort-icon\" title=\"Click to sort\">&#8693;</span>';\n}\nfunction handleColumnDragStart(host, e) {\n  host.draggedColumn = e.target;\n  if (e.dataTransfer) {\n    e.dataTransfer.effectAllowed = 'move';\n    e.dataTransfer.setData('text/plain', host.draggedColumn.dataset.columnIndex || '');\n  }\n  setTimeout(() => host.draggedColumn?.classList.add('dragging'), 0);\n}\nfunction handleColumnDragOver(host, e) {\n  e.preventDefault();\n  if (e.dataTransfer?.types.includes('text/plain')) {\n    const target = e.target;\n    if (target.tagName === 'TH' && target !== host.draggedColumn) {\n      target.classList.add('drag-over');\n    }\n  }\n}\nfunction handleColumnDragLeave(host, e) {\n  e.target.classList.remove('drag-over');\n}\nfunction handleColumnDrop(host, e) {\n  e.preventDefault();\n  const target = e.target;\n  target.classList.remove('drag-over');\n  if (host.draggedColumn && target.tagName === 'TH') {\n    const fromIndex = parseInt(host.draggedColumn.dataset.columnIndex || '0');\n    const toIndex = parseInt(target.dataset.columnIndex || '0');\n    if (fromIndex !== toIndex) host.swapColumns(fromIndex, toIndex);\n  }\n}\nfunction handleColumnDragEnd(host) {\n  host.draggedColumn?.classList.remove('dragging');\n  host.draggedColumn = null;\n  host.shadowRoot?.querySelectorAll('.drag-over').forEach(el => el.classList.remove('drag-over'));\n}\nfunction handleRowDragStart(host, e) {\n  host.draggedRow = e.target;\n  if (e.dataTransfer) {\n    e.dataTransfer.effectAllowed = 'move';\n    e.dataTransfer.setData('text/plain', host.draggedRow.dataset.rowIndex || '');\n  }\n  setTimeout(() => host.draggedRow?.classList.add('dragging'), 0);\n}\nfunction handleRowDragOver(host, e) {\n  e.preventDefault();\n  if (e.dataTransfer?.types.includes('text/plain')) {\n    const target = e.target;\n    const targetRow = target.closest('tr');\n    if (targetRow && targetRow.tagName === 'TR' && targetRow !== host.draggedRow) {\n      targetRow.classList.add('drag-over');\n    }\n  }\n}\nfunction handleRowDragLeave(host, e) {\n  const target = e.target;\n  const targetRow = target.closest('tr');\n  if (targetRow) targetRow.classList.remove('drag-over');\n}\nfunction handleRowDrop(host, e) {\n  e.preventDefault();\n  const target = e.target;\n  const targetRow = target.closest('tr');\n  if (targetRow) targetRow.classList.remove('drag-over');\n  if (host.draggedRow && targetRow && targetRow.tagName === 'TR') {\n    const fromIndex = parseInt(host.draggedRow.dataset.rowIndex || '0');\n    const toIndex = parseInt(targetRow.dataset.rowIndex || '0');\n    if (fromIndex !== toIndex) host.swapRows(fromIndex, toIndex);\n  }\n}\nfunction handleRowDragEnd(host) {\n  host.draggedRow?.classList.remove('dragging');\n  host.draggedRow = null;\n  host.shadowRoot?.querySelectorAll('.drag-over').forEach(el => el.classList.remove('drag-over'));\n}\nfunction tryInitializeEngine(host) {\n  const hasData = host._data && host._data.length > 0;\n  const hasOptions = host._options && Object.keys(host._options).length > 0;\n  if (!hasData || !hasOptions) return;\n  try {\n    const options = {\n      ...host._options\n    };\n    if (!options.rows || !Array.isArray(options.rows) || options.rows.length === 0) {\n      const firstRowField = host._data.length > 0 ? Object.keys(host._data[0])[0] : null;\n      if (firstRowField) {\n        options.rows = [{\n          uniqueName: firstRowField,\n          caption: firstRowField\n        }];\n      }\n    }\n    if (!options.columns || !Array.isArray(options.columns) || options.columns.length === 0) {\n      const keys = host._data.length > 0 ? Object.keys(host._data[0]) : [];\n      const colField = keys.length > 1 ? keys[1] : null;\n      if (colField) {\n        options.columns = [{\n          uniqueName: colField,\n          caption: colField\n        }];\n      }\n    }\n    if (!options.measures || !Array.isArray(options.measures) || options.measures.length === 0) {\n      const keys = host._data.length > 0 ? Object.keys(host._data[0]) : [];\n      const measureField = keys.find(k => typeof host._data[0][k] === 'number');\n      if (measureField) {\n        options.measures = [{\n          uniqueName: measureField,\n          caption: `Sum of ${measureField}`,\n          aggregation: 'sum'\n        }];\n      }\n    }\n    if (!options.groupConfig && options.rows && options.columns) {\n      options.groupConfig = {\n        rowFields: options.rows.map(r => r.uniqueName),\n        columnFields: options.columns.map(c => c.uniqueName),\n        grouper: item => {\n          return [...(options.rows?.map(r => item[r.uniqueName]) ?? []), ...(options.columns?.map(c => item[c.uniqueName]) ?? [])].join('|');\n        }\n      };\n    }\n    const config = {\n      data: host._data,\n      rawData: host._data,\n      dimensions: [],\n      defaultAggregation: 'sum',\n      rows: options.rows || [],\n      columns: options.columns || [],\n      measures: options.measures || [],\n      groupConfig: options.groupConfig\n    };\n    host.engine = new PivotEngine(config);\n    // Disable core engine pagination; the web component manages pagination itself\n    // Use a very large page size so engine never slices the data internally\n    host.engine.setPagination({\n      currentPage: 1,\n      pageSize: Number.MAX_SAFE_INTEGER,\n      totalPages: 1\n    });\n    host.engine.setDataHandlingMode(host._showRawData ? 'raw' : 'processed');\n    if (host._engineUnsubscribe) host._engineUnsubscribe();\n    host._engineUnsubscribe = host.engine.subscribe(state => {\n      host.handleEngineStateChange(state);\n    });\n    host._processedColumnOrder = [];\n    const currentFilters = host._showRawData ? host._rawFilters : host._processedFilters;\n    if (currentFilters.length > 0) {\n      host.engine.applyFilters(currentFilters);\n      return;\n    }\n  } catch (error) {\n    console.error('Error initializing PivotEngine:', error);\n  }\n}\nfunction parseAttributesIfNeeded(host) {\n  // Parse data attribute\n  const rawData = host.getAttribute('data');\n  if (rawData && !host._data.length) {\n    try {\n      host.data = JSON.parse(rawData);\n    } catch (error) {\n      console.error('Error parsing data attribute:', error);\n    }\n  }\n  // Parse options attribute\n  const rawOptions = host.getAttribute('options');\n  if (rawOptions && !Object.keys(host._options).length) {\n    try {\n      host.options = JSON.parse(rawOptions);\n    } catch (error) {\n      console.error('Error parsing options attribute:', error);\n    }\n  }\n  // Parse other attributes\n  parseOtherAttributes(host);\n}\nfunction parseOtherAttributes(host) {\n  // Parse filters\n  const rawFilters = host.getAttribute('filters');\n  if (rawFilters) {\n    try {\n      host.filters = JSON.parse(rawFilters);\n    } catch (error) {\n      console.error('Error parsing filters attribute:', error);\n    }\n  }\n  // Parse pagination\n  const rawPagination = host.getAttribute('pagination');\n  if (rawPagination) {\n    try {\n      host.pagination = {\n        ...host._pagination,\n        ...JSON.parse(rawPagination)\n      };\n    } catch (error) {\n      console.error('Error parsing pagination attribute:', error);\n    }\n  }\n}\nfunction attributeChanged(host, name, oldValue, newValue) {\n  if (oldValue === newValue) return;\n  if (name === 'mode') {\n    renderSwitch(host);\n    return;\n  }\n  switch (name) {\n    case 'data':\n      if (newValue) {\n        try {\n          host.data = JSON.parse(newValue);\n        } catch (error) {\n          console.error('Error parsing data attribute:', error);\n        }\n      }\n      break;\n    case 'options':\n      if (newValue) {\n        try {\n          host.options = JSON.parse(newValue);\n        } catch (error) {\n          console.error('Error parsing options attribute:', error);\n        }\n      }\n      break;\n    case 'filters':\n      if (newValue) {\n        try {\n          host.filters = JSON.parse(newValue);\n        } catch (error) {\n          console.error('Error parsing filters attribute:', error);\n        }\n      } else {\n        host.filters = [];\n      }\n      break;\n    case 'pagination':\n      if (newValue) {\n        try {\n          host.pagination = {\n            ...host._pagination,\n            ...JSON.parse(newValue)\n          };\n        } catch (error) {\n          console.error('Error parsing pagination attribute:', error);\n        }\n      } else {\n        host.pagination = {\n          currentPage: 1,\n          pageSize: 30,\n          totalPages: 1\n        };\n      }\n      break;\n  }\n}\nfunction calculatePaginationForCurrentView(host) {\n  if (host._showRawData) {\n    if (!host.engine) return;\n    const state = host.engine.getState();\n    // Use full rawData first; state.data may be limited\n    const allRawData = state.rawData || state.data || [];\n    updatePaginationForData(host, allRawData);\n  } else {\n    if (!host.engine) return;\n    const groupedData = host.engine.getGroupedData();\n    let uniqueRowValues = host.engine.getOrderedRowValues();\n    if (!uniqueRowValues) {\n      uniqueRowValues = [...new Set(groupedData.map(g => {\n        const keys = g.key ? g.key.split('|') : [];\n        return keys[0];\n      }))].filter(Boolean);\n    }\n    updatePaginationForData(host, uniqueRowValues);\n  }\n}\nfunction updatePaginationForData(host, data) {\n  const pageSize = host._pagination.pageSize;\n  const totalPages = Math.ceil(data.length / pageSize) || 1;\n  if (host._pagination.currentPage > totalPages) {\n    host._pagination.currentPage = Math.max(1, totalPages);\n  }\n  host._pagination.totalPages = totalPages;\n}\nfunction getPaginatedData(host, data) {\n  const start = (host._pagination.currentPage - 1) * host._pagination.pageSize;\n  const end = start + host._pagination.pageSize;\n  return data.slice(start, end);\n}\nfunction previousPage(host) {\n  if (host._pagination.currentPage > 1) {\n    host._pagination.currentPage--;\n    renderSwitch(host);\n    host.dispatchEvent(new CustomEvent('paginationChange', {\n      detail: {\n        ...host._pagination\n      },\n      bubbles: true,\n      composed: true\n    }));\n  }\n  updatePaginationInfo(host);\n}\nfunction nextPage(host) {\n  if (host._pagination.currentPage < host._pagination.totalPages) {\n    host._pagination.currentPage++;\n    renderSwitch(host);\n    host.dispatchEvent(new CustomEvent('paginationChange', {\n      detail: {\n        ...host._pagination\n      },\n      bubbles: true,\n      composed: true\n    }));\n  }\n  updatePaginationInfo(host);\n}\nfunction setPageSize(host, pageSize) {\n  if (pageSize > 0) {\n    host._pagination.pageSize = pageSize;\n    host._pagination.currentPage = 1;\n    calculatePaginationForCurrentView(host);\n    renderSwitch(host);\n    host.dispatchEvent(new CustomEvent('paginationChange', {\n      detail: {\n        ...host._pagination\n      },\n      bubbles: true,\n      composed: true\n    }));\n  }\n  updatePaginationInfo(host);\n}\nfunction goToPage(host, page) {\n  if (page >= 1 && page <= host._pagination.totalPages) {\n    host._pagination.currentPage = page;\n    renderSwitch(host);\n    host.dispatchEvent(new CustomEvent('paginationChange', {\n      detail: {\n        ...host._pagination\n      },\n      bubbles: true,\n      composed: true\n    }));\n  }\n  updatePaginationInfo(host);\n}\nfunction getState(host) {\n  if (!host.engine) {\n    throw new Error('Engine not initialized');\n  }\n  return host.engine.getState();\n}\nfunction sort(host, field, direction) {\n  if (!host.engine) {\n    console.error('Engine not initialized');\n    return;\n  }\n  host.engine.sort(field, direction);\n}\nfunction setMeasures(host, measures) {\n  if (!host.engine) {\n    console.error('Engine not initialized');\n    return;\n  }\n  host.engine.setMeasures(measures);\n}\nfunction setDimensions(host, dimensions) {\n  if (!host.engine) {\n    console.error('Engine not initialized');\n    return;\n  }\n  host.engine.setDimensions(dimensions);\n}\nfunction setGroupConfig(host, groupConfig) {\n  if (!host.engine) {\n    console.error('Engine not initialized');\n    return;\n  }\n  host.engine.setGroupConfig(groupConfig);\n}\nfunction setAggregation(host, type) {\n  if (!host.engine) {\n    console.error('Engine not initialized');\n    return;\n  }\n  host.engine.setAggregation(type);\n}\nfunction formatValue(host, value, field) {\n  if (!host.engine) {\n    console.error('Engine not initialized');\n    return String(value);\n  }\n  return host.engine.formatValue(value, field);\n}\nfunction getGroupedData(host) {\n  if (!host.engine) {\n    console.error('Engine not initialized');\n    return [];\n  }\n  return host.engine.getGroupedData();\n}\nfunction getData(host) {\n  if (!host.engine) {\n    console.error('Engine not initialized');\n    return [];\n  }\n  return host.engine.getState().rawData;\n}\nfunction getProcessedData(host) {\n  if (!host.engine) {\n    console.error('Engine not initialized');\n    return null;\n  }\n  return host.engine.getState().processedData;\n}\nfunction updateFieldFormatting(host, field, format) {\n  if (!host.engine) {\n    console.error('Engine not initialized');\n    return;\n  }\n  host.engine.updateFieldFormatting(field, format);\n}\nfunction getAvailableFields(host) {\n  return FieldService.getAvailableFields(host.engine);\n}\nfunction getSupportedAggregations() {\n  return FieldService.getSupportedAggregations();\n}\nfunction setMeasureAggregation(host, field, aggregation) {\n  FieldService.setMeasureAggregation(host.engine, field, aggregation);\n}\nfunction buildLayout(host, selection) {\n  const layout = FieldService.buildLayout(selection);\n  host._options.rows = layout.rows;\n  host._options.columns = layout.columns;\n  host._options.measures = layout.measures;\n}\nfunction getFieldAlignment(host, field) {\n  if (!host.engine) {\n    console.error('Engine not initialized');\n    return 'left';\n  }\n  return host.engine.getFieldAlignment(field);\n}\n\n// Filters\nfunction setFilters(host, value) {\n  console.log('Setting filters, current view mode:', host._showRawData ? 'RAW' : 'PROCESSED');\n  console.log('New filter value:', value);\n  if (host._showRawData) {\n    host._rawFilters = value || [];\n    console.log('Applied RAW filters:', host._rawFilters);\n  } else {\n    host._processedFilters = value || [];\n    console.log('Applied PROCESSED filters:', host._processedFilters);\n  }\n  if (host.engine) {\n    host.engine.setDataHandlingMode(host._showRawData ? 'raw' : 'processed');\n    host.engine.applyFilters(value || []);\n  }\n  host._filters = value || [];\n  host.setAttribute('filters', JSON.stringify(value));\n}\nfunction getFilters(host) {\n  if (host._showRawData) {\n    return host._rawFilters;\n  } else {\n    return host._processedFilters;\n  }\n}\n// Refresh/reset\nfunction refresh(host) {\n  if (!host.engine) {\n    console.error('Engine not initialized');\n    return;\n  }\n  host._filters = [];\n  host.removeAttribute('filters');\n  host.engine.reset();\n  const filterValueInput = host.shadowRoot?.getElementById('filterValue');\n  if (filterValueInput) {\n    filterValueInput.value = '';\n  }\n}\nfunction reset(host) {\n  if (!host.engine) {\n    console.error('Engine not initialized');\n    return;\n  }\n  host._rawFilters = [];\n  host._processedFilters = [];\n  host._filters = [];\n  host.removeAttribute('filters');\n  host._pagination.currentPage = 1;\n  host.engine.reset();\n  clearFilterUI(host);\n}\nfunction clearFilterUI(host) {\n  const filterValueInput = host.shadowRoot?.getElementById('filterValue');\n  if (filterValueInput) {\n    filterValueInput.value = '';\n  }\n  const filterFieldSelect = host.shadowRoot?.getElementById('filterField');\n  const filterOperatorSelect = host.shadowRoot?.getElementById('filterOperator');\n  if (filterFieldSelect) filterFieldSelect.selectedIndex = 0;\n  if (filterOperatorSelect) filterOperatorSelect.selectedIndex = 0;\n}\n\n// Exporting helpers\nfunction exportToHTML(host, fileName = 'pivot-table') {\n  if (!host.engine) {\n    console.error('Engine not initialized. Cannot export to HTML.');\n    return;\n  }\n  host.engine.exportToHTML(fileName);\n}\nfunction exportToPDF(host, fileName = 'pivot-table') {\n  if (!host.engine) {\n    console.error('Engine not initialized. Cannot export to PDF.');\n    return;\n  }\n  host.engine.exportToPDF(fileName);\n}\nfunction exportToExcel(host, fileName = 'pivot-table') {\n  if (!host.engine) {\n    console.error('Engine not initialized. Cannot export to Excel.');\n    return;\n  }\n  host.engine.exportToExcel(fileName);\n}\nfunction openPrintDialog(host) {\n  if (!host.engine) {\n    console.error('Engine not initialized. Cannot open print dialog.');\n    return;\n  }\n  host.engine.openPrintDialog();\n}\n// File I/O helpers\nfunction loadFromFile(host, file) {\n  return new Promise((resolve, reject) => {\n    const reader = new FileReader();\n    reader.onload = event => {\n      try {\n        const result = event.target?.result;\n        if (typeof result === 'string') {\n          const data = JSON.parse(result);\n          host.data = data;\n          resolve();\n        } else {\n          reject(new Error('Failed to read file as text'));\n        }\n      } catch (error) {\n        reject(error);\n      }\n    };\n    reader.onerror = () => reject(new Error('Failed to read file'));\n    reader.readAsText(file);\n  });\n}\nfunction loadFromUrl(host, url) {\n  return fetch(url).then(response => {\n    if (!response.ok) {\n      throw new Error(`Failed to fetch data from ${url}: ${response.status} ${response.statusText}`);\n    }\n    return response.json();\n  }).then(data => {\n    host.data = data;\n  });\n}\nfunction dragRow(host, fromIndex, toIndex) {\n  if (!host.engine) {\n    console.error('Engine not initialized');\n    return;\n  }\n  host.engine.dragRow(fromIndex, toIndex);\n}\nfunction dragColumn(host, fromIndex, toIndex) {\n  if (!host.engine) {\n    console.error('Engine not initialized');\n    return;\n  }\n  host.engine.dragColumn(fromIndex, toIndex);\n}\nfunction swapRows(host, fromIndex, toIndex) {\n  if (!host.engine) {\n    console.error('Engine not initialized');\n    return;\n  }\n  try {\n    if (host._showRawData) {\n      host.engine.swapRawDataRows(fromIndex, toIndex);\n    } else {\n      host.engine.swapDataRows(fromIndex, toIndex);\n    }\n  } catch (error) {\n    console.error('Row swap failed:', error);\n  }\n}\nfunction swapColumns(host, fromIndex, toIndex) {\n  if (!host.engine) {\n    console.error('Engine not initialized');\n    return;\n  }\n  try {\n    if (host._showRawData) {\n      const headers = host._data.length > 0 ? Object.keys(host._data[0]) : [];\n      if (fromIndex < 0 || toIndex < 0 || fromIndex >= headers.length || toIndex >= headers.length) {\n        console.error(`Invalid column indices for raw data swap: ${fromIndex}, ${toIndex}, total: ${headers.length}`);\n        return;\n      }\n      if (!host._rawDataColumnOrder || host._rawDataColumnOrder.length === 0) {\n        host._rawDataColumnOrder = [...headers];\n      }\n      const temp = host._rawDataColumnOrder[fromIndex];\n      host._rawDataColumnOrder[fromIndex] = host._rawDataColumnOrder[toIndex];\n      host._rawDataColumnOrder[toIndex] = temp;\n      host.renderRawTable();\n    } else {\n      host.engine.swapDataColumns(fromIndex, toIndex);\n      const newOrder = host.engine.getOrderedColumnValues();\n      if (newOrder) host._processedColumnOrder = [...newOrder];\n    }\n  } catch (error) {\n    console.error('Column swap failed:', error);\n  }\n}\nfunction swapRawDataColumns(host, fromIndex, toIndex) {\n  if (!host._data || host._data.length === 0) {\n    console.error('No raw data available for column swap');\n    return;\n  }\n  const headers = Object.keys(host._data[0]);\n  if (fromIndex < 0 || toIndex < 0 || fromIndex >= headers.length || toIndex >= headers.length) {\n    console.error(`Invalid column indices for raw data swap: ${fromIndex}, ${toIndex}, total: ${headers.length}`);\n    return;\n  }\n  if (fromIndex === toIndex) return;\n  if (!host._rawDataColumnOrder) host._rawDataColumnOrder = [...headers];\n  const temp = host._rawDataColumnOrder[fromIndex];\n  host._rawDataColumnOrder[fromIndex] = host._rawDataColumnOrder[toIndex];\n  host._rawDataColumnOrder[toIndex] = temp;\n  host.renderRawTable();\n}\nfunction setDragAndDropEnabled(host, enabled) {\n  const table = host.shadowRoot?.querySelector('table');\n  if (table) {\n    if (enabled) {\n      host.addDragListeners();\n    } else {\n      const draggableElements = table.querySelectorAll('[draggable=\"true\"]');\n      draggableElements.forEach(element => {\n        element.setAttribute('draggable', 'false');\n      });\n    }\n  }\n}\nfunction isDragAndDropEnabled(host) {\n  const firstDraggableElement = host.shadowRoot?.querySelector('[draggable=\"true\"]');\n  return !!firstDraggableElement;\n}\nfunction showFormatPopup(host) {\n  if (!host.engine) {\n    console.error('Engine not initialized');\n    return;\n  }\n  const state = host.engine.getState();\n  const availableMeasures = state.measures || [];\n  // Get available fields based on current mode - only numeric/measure fields\n  let availableFields = [];\n  if (host._showRawData) {\n    // For raw data, get only numeric fields (measures) from the data\n    if (state.rawData && state.rawData.length > 0) {\n      const allFields = Object.keys(state.rawData[0]);\n      // Filter to only include measure fields (price, discount, etc.)\n      availableFields = allFields.filter(field => {\n        const sampleValue = state.rawData[0][field];\n        return typeof sampleValue === 'number';\n      });\n    }\n  } else {\n    // For processed data, get measure names\n    availableFields = availableMeasures.map(measure => measure.caption || measure.uniqueName);\n  }\n  const overlay = document.createElement('div');\n  overlay.style.position = 'fixed';\n  overlay.style.top = '0';\n  overlay.style.left = '0';\n  overlay.style.width = '100%';\n  overlay.style.height = '100%';\n  overlay.style.backgroundColor = 'rgba(0, 0, 0, 0.5)';\n  overlay.style.display = 'flex';\n  overlay.style.justifyContent = 'center';\n  overlay.style.alignItems = 'center';\n  overlay.style.zIndex = '1000';\n  const popup = document.createElement('div');\n  popup.style.width = '400px';\n  popup.style.padding = '20px';\n  popup.style.backgroundColor = '#fff';\n  popup.style.borderRadius = '8px';\n  popup.style.boxShadow = '0 4px 8px rgba(0, 0, 0, 0.2)';\n  const header = document.createElement('h2');\n  header.textContent = 'Format cells';\n  header.style.margin = '0 0 10px 0';\n  header.style.textAlign = 'left';\n  const headerSeparator = document.createElement('hr');\n  headerSeparator.style.border = '0';\n  headerSeparator.style.height = '1px';\n  headerSeparator.style.backgroundColor = '#ccc';\n  headerSeparator.style.margin = '10px 0';\n  const formContainer = document.createElement('div');\n  // Form fields configuration\n  const fields = [{\n    name: 'Choose value',\n    options: ['Choose value', 'All values', ...availableFields]\n  }, {\n    name: 'Text align',\n    options: ['right', 'left', 'center']\n  }, {\n    name: 'Thousand separator',\n    options: ['(Space)', '(Comma)', '(None)', '(Dot)']\n  }, {\n    name: 'Decimal separator',\n    options: ['.', ',']\n  }, {\n    name: 'Decimal places',\n    options: ['None', '0', '1', '2', '3', '4', '5']\n  }, {\n    name: 'Currency symbol',\n    options: ['', '$', '', '', '']\n  }, {\n    name: 'Currency align',\n    options: ['left', 'right']\n  }, {\n    name: 'Null value',\n    options: ['', 'null', '0', 'N/A', '-']\n  }, {\n    name: 'Format as percent',\n    options: ['false', 'true']\n  }];\n  const formValues = {};\n  const dropdownElements = [];\n  fields.forEach((field, index) => {\n    const row = document.createElement('div');\n    row.style.display = 'flex';\n    row.style.alignItems = 'center';\n    row.style.marginBottom = '15px';\n    const label = document.createElement('label');\n    label.textContent = field.name;\n    label.style.flex = '1';\n    label.style.marginRight = '10px';\n    label.style.textAlign = 'left';\n    const dropdown = document.createElement('select');\n    dropdown.style.flex = '2';\n    dropdown.style.padding = '8px';\n    dropdown.style.borderRadius = '4px';\n    dropdown.style.border = '1px solid #ccc';\n    // Populate dropdown options\n    field.options.forEach(optionText => {\n      const option = document.createElement('option');\n      option.value = optionText;\n      option.textContent = optionText;\n      dropdown.appendChild(option);\n    });\n    // Set initial value\n    formValues[field.name] = field.options[0];\n    // Disable all fields except first one initially\n    if (index !== 0) {\n      dropdown.disabled = true;\n    }\n    // Handle change events\n    dropdown.addEventListener('change', e => {\n      const target = e.target;\n      formValues[field.name] = target.value;\n      // Enable/disable other fields based on first field\n      if (index === 0) {\n        const selectedValue = target.value;\n        dropdownElements.forEach((el, i) => {\n          if (i !== 0) {\n            el.disabled = selectedValue === 'Choose value';\n          }\n        });\n      }\n    });\n    row.appendChild(label);\n    row.appendChild(dropdown);\n    formContainer.appendChild(row);\n    dropdownElements.push(dropdown);\n  });\n  const buttonContainer = document.createElement('div');\n  buttonContainer.style.display = 'flex';\n  buttonContainer.style.justifyContent = 'flex-end';\n  buttonContainer.style.marginTop = '20px';\n  const applyButton = document.createElement('button');\n  applyButton.textContent = 'APPLY';\n  applyButton.style.padding = '10px 20px';\n  applyButton.style.backgroundColor = '#666';\n  applyButton.style.color = '#fff';\n  applyButton.style.border = 'none';\n  applyButton.style.borderRadius = '4px';\n  applyButton.style.cursor = 'pointer';\n  applyButton.style.marginRight = '10px';\n  const cancelButton = document.createElement('button');\n  cancelButton.textContent = 'CANCEL';\n  cancelButton.style.padding = '10px 20px';\n  cancelButton.style.backgroundColor = '#f5f5f5';\n  cancelButton.style.color = '#333';\n  cancelButton.style.border = '1px solid #ccc';\n  cancelButton.style.borderRadius = '4px';\n  cancelButton.style.cursor = 'pointer';\n  // Event handlers\n  cancelButton.addEventListener('click', () => {\n    document.body.removeChild(overlay);\n  });\n  applyButton.addEventListener('click', () => {\n    const selectedField = formValues['Choose value'];\n    if (selectedField && selectedField !== 'Choose value') {\n      // Map UI values to FormatOptions\n      const formatOptions = {};\n      // Text align\n      if (formValues['Text align']) {\n        formatOptions.align = formValues['Text align'];\n      }\n      // Thousand separator\n      const thousandSep = formValues['Thousand separator'];\n      if (thousandSep === '(Space)') formatOptions.thousandSeparator = ' ';else if (thousandSep === '(Comma)') formatOptions.thousandSeparator = ',';else if (thousandSep === '(None)') formatOptions.thousandSeparator = '';else if (thousandSep === '(Dot)') formatOptions.thousandSeparator = '.';\n      // Decimal separator\n      if (formValues['Decimal separator']) {\n        formatOptions.decimalSeparator = formValues['Decimal separator'];\n      }\n      // Decimal places\n      if (formValues['Decimal places'] && formValues['Decimal places'] !== 'None') {\n        formatOptions.decimals = parseInt(formValues['Decimal places'], 10);\n      }\n      // Currency\n      const currencySymbol = formValues['Currency symbol'];\n      if (currencySymbol) {\n        formatOptions.type = 'currency';\n        if (currencySymbol === '$') formatOptions.currency = 'USD';else if (currencySymbol === '') formatOptions.currency = 'INR';else if (currencySymbol === '') formatOptions.currency = 'EUR';else if (currencySymbol === '') formatOptions.currency = 'GBP';\n      }\n      // Currency align\n      if (formValues['Currency align']) {\n        formatOptions.currencyAlign = formValues['Currency align'];\n      }\n      // Null value\n      if (formValues['Null value']) {\n        formatOptions.nullValue = formValues['Null value'] === 'null' ? null : formValues['Null value'];\n      }\n      // Format as percent\n      if (formValues['Format as percent'] === 'true') {\n        formatOptions.percent = true;\n        formatOptions.type = 'percentage';\n      }\n      // Apply formatting\n      try {\n        if (host.engine) {\n          if (selectedField === 'All values') {\n            // Apply to all numeric fields\n            if (host._showRawData) {\n              // For raw data, apply to all numeric fields\n              if (state.rawData && state.rawData.length > 0) {\n                const allFields = Object.keys(state.rawData[0]);\n                const numericFields = allFields.filter(field => {\n                  const sampleValue = state.rawData[0][field];\n                  return typeof sampleValue === 'number';\n                });\n                numericFields.forEach(field => {\n                  if (host.engine) {\n                    host.engine.updateFieldFormatting(field, formatOptions);\n                  }\n                });\n                console.log('Applied formatting to all numeric fields:', numericFields);\n              }\n            } else {\n              // For processed data, apply to all measures\n              availableMeasures.forEach(measure => {\n                if (host.engine) {\n                  host.engine.updateFieldFormatting(measure.uniqueName, formatOptions);\n                }\n              });\n              console.log('Applied formatting to all measures:', availableMeasures.map(m => m.uniqueName));\n            }\n          } else {\n            // Apply to specific field\n            let fieldName = selectedField;\n            if (!host._showRawData) {\n              // For processed data, find the measure's uniqueName\n              const measure = availableMeasures.find(m => m.caption === selectedField || m.uniqueName === selectedField);\n              if (measure) {\n                fieldName = measure.uniqueName;\n              }\n            }\n            host.engine.updateFieldFormatting(fieldName, formatOptions);\n            console.log('Applied formatting:', formatOptions, 'to field:', fieldName);\n          }\n          // Trigger re-render\n          host._renderSwitch();\n        }\n      } catch (error) {\n        console.error('Error applying formatting:', error);\n      }\n    }\n    document.body.removeChild(overlay);\n  });\n  buttonContainer.appendChild(applyButton);\n  buttonContainer.appendChild(cancelButton);\n  popup.appendChild(header);\n  popup.appendChild(headerSeparator);\n  popup.appendChild(formContainer);\n  popup.appendChild(buttonContainer);\n  overlay.appendChild(popup);\n  document.body.appendChild(overlay);\n}\nclass PivotHeadElement extends HTMLElement {\n  static get observedAttributes() {\n    return ['data', 'options', 'filters', 'pagination', 'mode'];\n  }\n  constructor() {\n    super();\n    this._engineUnsubscribe = null;\n    this._data = [];\n    this._originalData = [];\n    this._options = {};\n    this._filters = [];\n    this._rawFilters = [];\n    this._processedFilters = [];\n    this._rowGroups = [];\n    this._columnGroups = [];\n    this._pagination = {\n      currentPage: 1,\n      pageSize: 10,\n      totalPages: 1\n    };\n    this._showRawData = false;\n    this._rawDataColumnOrder = [];\n    this._processedColumnOrder = [];\n    this.draggedColumn = null;\n    this.draggedRow = null;\n    this.attachShadow({\n      mode: 'open'\n    });\n  }\n  set data(value) {\n    this._data = value || [];\n    this._originalData = [...(value || [])];\n    this.tryInitializeEngine();\n  }\n  get data() {\n    return this._data;\n  }\n  set options(value) {\n    this._options = value || {};\n    this.tryInitializeEngine();\n  }\n  get options() {\n    return this._options;\n  }\n  set filters(value) {\n    setFilters(this, value);\n  }\n  get filters() {\n    return getFilters(this);\n  }\n  set pagination(value) {\n    this._pagination = {\n      ...this._pagination,\n      ...value\n    };\n    this.setAttribute('pagination', JSON.stringify(this._pagination));\n    this._renderSwitch();\n  }\n  get pagination() {\n    return this._pagination;\n  }\n  handleEngineStateChange(state) {\n    handleEngineStateChange(this, state);\n  }\n  tryInitializeEngine() {\n    tryInitializeEngine(this);\n  }\n  connectedCallback() {\n    if (!this._data.length && !Object.keys(this._options).length) {\n      parseAttributesIfNeeded(this);\n    }\n    this._renderSwitch();\n  }\n  parseAttributesIfNeeded() {\n    parseAttributesIfNeeded(this);\n  }\n  parseOtherAttributes() {\n    parseOtherAttributes(this);\n  }\n  attributeChangedCallback(name, oldValue, newValue) {\n    attributeChanged(this, name, oldValue, newValue);\n  }\n  _renderSwitch() {\n    renderSwitch(this);\n  }\n  renderFullUI() {\n    renderFullUI(this);\n  }\n  setupControls() {\n    bindControls(this);\n  }\n  updatePaginationInfo() {\n    updatePaginationInfo(this);\n  }\n  calculatePaginationForCurrentView() {\n    calculatePaginationForCurrentView(this);\n  }\n  updatePaginationForData(data) {\n    updatePaginationForData(this, data);\n  }\n  getPaginatedData(data) {\n    return getPaginatedData(this, data);\n  }\n  renderRawTable() {\n    renderRawTable(this);\n  }\n  createSortIcon(field) {\n    return createSortIcon(this, field);\n  }\n  createProcessedSortIcon(field) {\n    return createProcessedSortIcon(this, field);\n  }\n  addDragListeners() {\n    addDragListeners(this);\n  }\n  handleSortClick(e) {\n    handleSortClick(this, e);\n  }\n  handleDrillDownClick(e) {\n    handleDrillDownClick(this, e);\n  }\n  getRawData() {\n    return this._data;\n  }\n  getPagination() {\n    return this._pagination;\n  }\n  getState() {\n    return getState(this);\n  }\n  refresh() {\n    refresh(this);\n  }\n  reset() {\n    reset(this);\n  }\n  clearFilterUI() {\n    clearFilterUI(this);\n  }\n  sort(field, direction) {\n    sort(this, field, direction);\n  }\n  setMeasures(measures) {\n    setMeasures(this, measures);\n  }\n  setDimensions(dimensions) {\n    setDimensions(this, dimensions);\n  }\n  setGroupConfig(groupConfig) {\n    setGroupConfig(this, groupConfig);\n  }\n  setAggregation(type) {\n    setAggregation(this, type);\n  }\n  formatValue(value, field) {\n    return formatValue(this, value, field);\n  }\n  getGroupedData() {\n    return getGroupedData(this);\n  }\n  getFilters() {\n    return this._filters;\n  }\n  getData() {\n    return getData(this);\n  }\n  getProcessedData() {\n    return getProcessedData(this);\n  }\n  exportToHTML(fileName = 'pivot-table') {\n    exportToHTML(this, fileName);\n  }\n  exportToPDF(fileName = 'pivot-table') {\n    exportToPDF(this, fileName);\n  }\n  exportToExcel(fileName = 'pivot-table') {\n    exportToExcel(this, fileName);\n  }\n  openPrintDialog() {\n    openPrintDialog(this);\n  }\n  loadFromFile(file) {\n    return loadFromFile(this, file);\n  }\n  loadFromUrl(url) {\n    return loadFromUrl(this, url);\n  }\n  dragRow(fromIndex, toIndex) {\n    dragRow(this, fromIndex, toIndex);\n  }\n  dragColumn(fromIndex, toIndex) {\n    dragColumn(this, fromIndex, toIndex);\n  }\n  swapRows(fromIndex, toIndex) {\n    swapRows(this, fromIndex, toIndex);\n  }\n  swapColumns(fromIndex, toIndex) {\n    swapColumns(this, fromIndex, toIndex);\n  }\n  swapRawDataColumns(fromIndex, toIndex) {\n    swapRawDataColumns(this, fromIndex, toIndex);\n  }\n  setDragAndDropEnabled(enabled) {\n    setDragAndDropEnabled(this, enabled);\n  }\n  isDragAndDropEnabled() {\n    return isDragAndDropEnabled(this);\n  }\n  swapDataRowsByIndex(fromIndex, toIndex) {\n    this.swapRows(fromIndex, toIndex);\n  }\n  swapDataColumnsByIndex(fromIndex, toIndex) {\n    this.swapColumns(fromIndex, toIndex);\n  }\n  previousPage() {\n    previousPage(this);\n  }\n  nextPage() {\n    nextPage(this);\n  }\n  setPageSize(pageSize) {\n    setPageSize(this, pageSize);\n  }\n  goToPage(page) {\n    goToPage(this, page);\n  }\n  setViewMode(mode) {\n    const wantRaw = mode === 'raw';\n    if (this._showRawData === wantRaw) return;\n    this._showRawData = wantRaw;\n    if (!this.engine) return;\n    try {\n      this.engine.setDataHandlingMode(wantRaw ? 'raw' : 'processed');\n      const currentFilters = wantRaw ? this._rawFilters : this._processedFilters;\n      this.engine.applyFilters(currentFilters);\n      this.dispatchEvent(new CustomEvent('viewModeChange', {\n        detail: {\n          mode\n        },\n        bubbles: true,\n        composed: true\n      }));\n    } catch (err) {\n      console.error('Failed to set view mode:', err);\n    }\n  }\n  getViewMode() {\n    return this._showRawData ? 'raw' : 'processed';\n  }\n  updateFieldFormatting(field, format) {\n    updateFieldFormatting(this, field, format);\n  }\n  getFieldAlignment(field) {\n    return getFieldAlignment(this, field);\n  }\n  showFormatPopup() {\n    showFormatPopup(this);\n  }\n  /**\n   * Returns all fields inferred from the engine's raw data.\n   * Useful for building a UI for field selection.\n   */\n  getAvailableFields() {\n    return getAvailableFields(this);\n  }\n  /**\n   * Returns the list of supported aggregation types (e.g., 'sum', 'avg').\n   */\n  getSupportedAggregations() {\n    return getSupportedAggregations();\n  }\n  /**\n   * Changes the aggregation for a specific measure and refreshes the engine.\n   * @param field The unique name of the measure field.\n   * @param aggregation The new aggregation type.\n   */\n  setMeasureAggregation(field, aggregation) {\n    setMeasureAggregation(this, field, aggregation);\n  }\n  /**\n   * Builds and applies a complete layout (rows, columns, measures) from a selection object.\n   * This is the primary method for updating the pivot table structure from a UI.\n   * @param selection The layout selection object.\n   */\n  buildLayout(selection) {\n    buildLayout(this, selection);\n  }\n}\ncustomElements.define('pivot-head', PivotHeadElement);\nexport { PivotHeadElement };\n//# sourceMappingURL=pivot-head.mjs.map",
  "map": null,
  "metadata": {},
  "sourceType": "module",
  "externalDependencies": []
}
