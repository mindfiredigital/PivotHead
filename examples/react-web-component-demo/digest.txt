Directory structure:
‚îî‚îÄ‚îÄ react-web-component-demo/
    ‚îú‚îÄ‚îÄ README.md
    ‚îú‚îÄ‚îÄ CHANGELOG.md
    ‚îú‚îÄ‚îÄ eslint.config.js
    ‚îú‚îÄ‚îÄ index.html
    ‚îú‚îÄ‚îÄ package.json
    ‚îú‚îÄ‚îÄ vite.config.js
    ‚îú‚îÄ‚îÄ public/
    ‚îÇ   ‚îî‚îÄ‚îÄ wasm/
    ‚îÇ       ‚îî‚îÄ‚îÄ csvParser.wasm
    ‚îî‚îÄ‚îÄ src/
        ‚îú‚îÄ‚îÄ App.css
        ‚îú‚îÄ‚îÄ App.jsx
        ‚îú‚îÄ‚îÄ index.css
        ‚îú‚îÄ‚îÄ main.jsx
        ‚îú‚îÄ‚îÄ PivotHeadDemo.jsx
        ‚îî‚îÄ‚îÄ config/
            ‚îî‚îÄ‚îÄ config.js

================================================
FILE: README.md
================================================
# React + Vite

This template provides a minimal setup to get React working in Vite with HMR and some ESLint rules.

Currently, two official plugins are available:

- [@vitejs/plugin-react](https://github.com/vitejs/vite-plugin-react/blob/main/packages/plugin-react) uses [Babel](https://babeljs.io/) for Fast Refresh
- [@vitejs/plugin-react-swc](https://github.com/vitejs/vite-plugin-react/blob/main/packages/plugin-react-swc) uses [SWC](https://swc.rs/) for Fast Refresh

## Expanding the ESLint configuration

If you are developing a production application, we recommend using TypeScript with type-aware lint rules enabled. Check out the [TS template](https://github.com/vitejs/vite/tree/main/packages/create-vite/template-react-ts) for information on how to integrate TypeScript and [`typescript-eslint`](https://typescript-eslint.io) in your project.



================================================
FILE: CHANGELOG.md
================================================
# react-web-component-demo

## 0.0.2

### Patch Changes

- Updated dependencies []:
  - @mindfiredigital/pivothead-web-component@1.0.2

## 0.0.1

### Patch Changes

- Updated dependencies []:
  - @mindfiredigital/pivothead-web-component@1.0.1



================================================
FILE: eslint.config.js
================================================
import js from '@eslint/js';
import globals from 'globals';
import reactHooks from 'eslint-plugin-react-hooks';
import reactRefresh from 'eslint-plugin-react-refresh';

export default [
  { ignores: ['dist'] },
  {
    files: ['**/*.{js,jsx}'],
    languageOptions: {
      ecmaVersion: 2020,
      globals: globals.browser,
      parserOptions: {
        ecmaVersion: 'latest',
        ecmaFeatures: { jsx: true },
        sourceType: 'module',
      },
    },
    plugins: {
      'react-hooks': reactHooks,
      'react-refresh': reactRefresh,
    },
    rules: {
      ...js.configs.recommended.rules,
      ...reactHooks.configs.recommended.rules,
      'no-unused-vars': ['error', { varsIgnorePattern: '^[A-Z_]' }],
      'react-refresh/only-export-components': [
        'warn',
        { allowConstantExport: true },
      ],
    },
  },
];



================================================
FILE: index.html
================================================
<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <link rel="icon" type="image/svg+xml" href="/vite.svg" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Vite + React</title>
  </head>
  <body>
    <div id="root"></div>
    <script type="module" src="/src/main.jsx"></script>
  </body>
</html>



================================================
FILE: package.json
================================================
{
  "name": "react-web-component-demo",
  "private": true,
  "version": "0.0.2",
  "type": "module",
  "scripts": {
    "dev": "vite",
    "build": "vite build",
    "lint": "eslint .",
    "preview": "vite preview"
  },
  "dependencies": {
    "@mindfiredigital/pivothead-web-component": "workspace:*",
    "chart.js": "^4.4.1",
    "react": "^19.1.0",
    "react-dom": "^19.1.0"
  },
  "devDependencies": {
    "@eslint/js": "^9.25.0",
    "@types/react": "^19.1.2",
    "@types/react-dom": "^19.1.2",
    "@vitejs/plugin-react": "^4.4.1",
    "eslint": "^9.25.0",
    "eslint-plugin-react-hooks": "^5.2.0",
    "eslint-plugin-react-refresh": "^0.4.19",
    "globals": "^16.0.0",
    "vite": "^7.2.6"
  }
}



================================================
FILE: vite.config.js
================================================
import { defineConfig } from 'vite';
import react from '@vitejs/plugin-react';
import { resolve } from 'path';
import { copyFileSync, mkdirSync, existsSync } from 'fs';

// https://vite.dev/config/
export default defineConfig({
  plugins: [
    react(),
    {
      name: 'copy-wasm-files',
      buildStart() {
        // Copy WASM file from core package to public directory
        const wasmSource = resolve(
          __dirname,
          '../../packages/core/dist/wasm/csvParser.wasm'
        );
        const wasmDest = resolve(__dirname, 'public/wasm/csvParser.wasm');
        const wasmDir = resolve(__dirname, 'public/wasm');

        // Create directory if it doesn't exist
        if (!existsSync(wasmDir)) {
          mkdirSync(wasmDir, { recursive: true });
        }

        // Copy WASM file if source exists
        if (existsSync(wasmSource)) {
          copyFileSync(wasmSource, wasmDest);
          console.log('‚úÖ Copied WASM file to public/wasm/');
        } else {
          console.warn('‚ö†Ô∏è WASM file not found at:', wasmSource);
          console.warn('Run "pnpm build:wasm" in packages/core to generate it');
        }
      },
    },
  ],

  // Enable WASM support
  assetsInclude: ['**/*.wasm'],

  // Optimize dependencies to handle WASM files
  optimizeDeps: {
    exclude: ['@mindfiredigital/pivothead-web-component'],
  },

  server: {
    // Enable WASM MIME type
    headers: {
      'Cross-Origin-Embedder-Policy': 'require-corp',
      'Cross-Origin-Opener-Policy': 'same-origin',
    },
    fs: {
      strict: false,
      // Allow serving files from the packages directory
      allow: ['..'],
    },
  },
});



================================================
FILE: public/wasm/csvParser.wasm
================================================
[Non-text file]


================================================
FILE: src/App.css
================================================



================================================
FILE: src/App.jsx
================================================
import './App.css'
import PivotHeadDemo from './PivotHeadDemo'

function App() {

  return (
    <>
     <PivotHeadDemo />
    </>
  )
}

export default App



================================================
FILE: src/index.css
================================================



================================================
FILE: src/main.jsx
================================================
import { StrictMode } from 'react'
import { createRoot } from 'react-dom/client'
import './index.css'
import App from './App.jsx'

createRoot(document.getElementById('root')).render(
  <StrictMode>
    <App />
  </StrictMode>,
)



================================================
FILE: src/PivotHeadDemo.jsx
================================================
import React, { useEffect, useRef, useState, useCallback } from 'react';
import '@mindfiredigital/pivothead-web-component';
import { ChartService } from '@mindfiredigital/pivothead-web-component';
import { Chart, registerables } from 'chart.js';
import { data, options } from './config/config';

// Register Chart.js components
Chart.register(...registerables);

const PivotHeadDemo = () => {
  const pivotRef = useRef(null);
  const chartRef = useRef(null);
  const chartCanvasRef = useRef(null);
  const chartServiceRef = useRef(null);

  const [state, setState] = useState();
  const [showRawData, setShowRawData] = useState(false);
  const [currentPage, setCurrentPage] = useState(1);
  const [rowsPerPage] = useState(100); // Show 100 rows per page for large datasets
  const [isLoading, setIsLoading] = useState(false);
  const [loadingMessage, setLoadingMessage] = useState('');

  // Controlled filter state
  const [field, setField] = useState('product');
  const [operator, setOperator] = useState('equals');
  const [value, setValue] = useState('');

  // Chart state
  const [chartType, setChartType] = useState('none');
  const [showChart, setShowChart] = useState(false);
  const [chartFilterOptions, setChartFilterOptions] = useState({
    measures: [],
    rows: [],
    columns: []
  });
  const [selectedMeasure, setSelectedMeasure] = useState('');
  const [selectedRows, setSelectedRows] = useState([]);
  const [selectedColumns, setSelectedColumns] = useState([]);
  const [chartLimit, setChartLimit] = useState(5);

  // Chart colors
  const chartColors = [
    'rgba(54, 162, 235, 0.8)',
    'rgba(255, 99, 132, 0.8)',
    'rgba(75, 192, 192, 0.8)',
    'rgba(255, 206, 86, 0.8)',
    'rgba(153, 102, 255, 0.8)',
    'rgba(255, 159, 64, 0.8)',
    'rgba(46, 204, 113, 0.8)',
    'rgba(231, 76, 60, 0.8)',
    'rgba(52, 73, 94, 0.8)',
    'rgba(241, 196, 15, 0.8)',
  ];
  const chartBorderColors = chartColors.map(c => c.replace('0.8)', '1)'));

  useEffect(() => {
    const pivot = pivotRef.current;

    if (!pivot) return;

    // Wait for the component to be defined
    customElements.whenDefined('pivot-head').then(() => {
      console.log('Setting data and options programmatically...');
      
      // Set data and options via properties (this triggers the setters)
      pivot.data = data;
      pivot.options = options;

      // Add event listener for state changes
      const handleStateChange = (event) => {
        console.log('‚úÖ State changed:', event.detail);
        setState(event.detail);
      };

      pivot.addEventListener('stateChange', handleStateChange);

      // Poll for getState to become available (fallback)
      const interval = setInterval(() => {
        if (typeof pivot.getState === 'function') {
          try {
            const s = pivot.getState();
            console.log('‚úÖ Engine state from polling:', s);
            setState(s);
            clearInterval(interval);
          } catch {
            console.log('Engine not ready yet, continuing to poll...');
          }
        }
      }, 100);

      // Cleanup
      return () => {
        pivot.removeEventListener('stateChange', handleStateChange);
        clearInterval(interval);
      };
    });
  }, []);

  const handleFilter = () => {
    console.log('Filter Field:', field);
    console.log('Operator:', operator);
    console.log('Value:', value);

    const pivot = pivotRef.current;
    if (pivot && typeof pivot.applyFiltersWithEvent === 'function') {
      const filters = [{ field: field, operator: operator, value: value }];
      
      // Use the method that applies filters and dispatches events
      pivot.applyFiltersWithEvent(filters);
    } else {
      console.error('Pivot component or applyFiltersWithEvent method not available');
    }
  };

  const handleExport = () => {
    const pivot = pivotRef.current;
    if (pivot) {
      // Example: export to PDF
      if (typeof pivot.exportToPDF === 'function') {
        pivot.exportToPDF('pivot-export');
      }
    }
  };

  const handleReset = () => {
    const pivot = pivotRef.current;
    if (pivot && typeof pivot.refresh === 'function') {
      pivot.refresh();
      // Reset form fields
      setField('product');
      setOperator('equals');
      setValue('');
    }
  };

  const handleUploadCSV = async () => {
    const pivot = pivotRef.current;
    if (pivot && typeof pivot.connectToLocalFile === 'function') {
      try {
        console.log('Opening file picker for CSV/JSON upload...');
        setIsLoading(true);
        setLoadingMessage('Uploading file...');

        const result = await pivot.connectToLocalFile({
          maxFileSize: 1024 * 1024 * 1024, // 1GB max file size (supports 800MB files)
          onProgress: (progress) => {
            console.log(`Upload progress: ${progress}%`);
            setLoadingMessage(`Processing file... ${progress}%`);
          },
        });

        if (result.success) {
          console.log('File uploaded successfully:', result);
          console.log(`- File: ${result.fileName}`);
          console.log(`- Size: ${result.fileSize} bytes`);
          console.log(`- Records: ${result.recordCount}`);
          console.log(`- Performance Mode: ${result.performanceMode}`);

          // Update the state to refresh the table with new data
          console.log('üîÑ Refreshing state with uploaded data...');
          setLoadingMessage('Loading data into table...');

          // Wait a bit for the component to finish processing
          setTimeout(() => {
            if (typeof pivot.getState === 'function') {
              try {
                const newState = pivot.getState();
                console.log('‚úÖ State updated with uploaded data:', newState);
                console.log(`   - Data rows: ${newState.data?.length || 0}`);
                console.log(`   - Columns: ${newState.data?.[0] ? Object.keys(newState.data[0]).length : 0}`);
                setState(newState);
                setCurrentPage(1); // Reset to first page
                setIsLoading(false);
                setLoadingMessage('');

                alert(`File uploaded successfully!\n\nFile: ${result.fileName}\nRecords: ${result.recordCount}\nPerformance Mode: ${result.performanceMode}\n\nData loaded into table!`);
              } catch (error) {
                console.error('Failed to get state after upload:', error);
                setIsLoading(false);
                setLoadingMessage('');
                alert('File uploaded but failed to update table. Please try refreshing the page.');
              }
            } else {
              setIsLoading(false);
              setLoadingMessage('');
              alert('File uploaded but getState method not available. Please try refreshing the page.');
            }
          }, 500); // Wait 500ms for processing to complete
        } else {
          console.error('File upload failed:', result.error);
          setIsLoading(false);
          setLoadingMessage('');
          alert(`File upload failed: ${result.error}`);
        }
      } catch (error) {
        console.error('Error uploading file:', error);
        setIsLoading(false);
        setLoadingMessage('');
        alert(`Error uploading file: ${error.message}`);
      }
    } else {
      console.error('Pivot component or connectToLocalFile method not available');
      alert('Upload functionality is not available. Please ensure the component is fully loaded.');
    }
  };

  const handleProductSort = () => {
    const pivot = pivotRef.current;
    if (!pivot || typeof pivot.sortWithEvent !== 'function' || !state) return;
    
    const currentSortConfig = state.sortConfig?.[0];
    const direction = currentSortConfig?.field === 'product' && currentSortConfig?.direction === 'asc' ? 'desc' : 'asc';
    pivot.sortWithEvent('product', direction);
  };

  const handleMeasureSort = (measure) => {
    const pivot = pivotRef.current;
    if (!pivot || typeof pivot.sortWithEvent !== 'function' || !state) return;

    const currentSortConfig = state.sortConfig?.[0];
    const direction = currentSortConfig?.field === measure.uniqueName && currentSortConfig?.direction === 'asc' ? 'desc' : 'asc';
    pivot.sortWithEvent(measure.uniqueName, direction);
  };

  // Initialize ChartService when engine is ready
  const initializeChartService = useCallback(() => {
    const pivot = pivotRef.current;
    if (!pivot || !pivot.engine) return;

    try {
      chartServiceRef.current = new ChartService(pivot.engine);
      console.log('ChartService initialized successfully');

      // Get available filter options
      const filterOptions = chartServiceRef.current.getAvailableFilterOptions();
      setChartFilterOptions(filterOptions);

      // Set defaults
      if (filterOptions.measures.length > 0) {
        setSelectedMeasure(filterOptions.measures[0].uniqueName);
      }
      setSelectedRows(filterOptions.rows);
      setSelectedColumns(filterOptions.columns);
    } catch (error) {
      console.error('Failed to initialize ChartService:', error);
    }
  }, []);

  // Destroy existing chart
  const destroyChart = useCallback(() => {
    if (chartRef.current) {
      chartRef.current.destroy();
      chartRef.current = null;
    }
  }, []);

  // Render chart based on type
  const renderChartVisualization = useCallback(() => {
    if (!chartServiceRef.current || chartType === 'none' || !chartCanvasRef.current) {
      return;
    }

    // Set filters on ChartService
    chartServiceRef.current.setFilters({
      selectedMeasure,
      selectedRows,
      selectedColumns,
      limit: chartLimit
    });

    // Get chart data from ChartService
    const chartData = chartServiceRef.current.getChartData();
    if (!chartData || !chartData.labels || chartData.labels.length === 0) {
      console.warn('No chart data available');
      return;
    }

    destroyChart();

    const ctx = chartCanvasRef.current.getContext('2d');
    const { labels, datasets, rowFieldName, columnFieldName, selectedMeasure: measure } = chartData;

    // Build chart configuration based on type
    let chartConfig = {};

    switch (chartType) {
      case 'column':
        chartConfig = {
          type: 'bar',
          data: { labels, datasets },
          options: {
            responsive: true,
            maintainAspectRatio: true,
            plugins: {
              title: { display: true, text: `${measure?.caption || 'Value'} by ${rowFieldName}` },
              legend: { position: 'top' }
            }
          }
        };
        break;

      case 'bar':
        chartConfig = {
          type: 'bar',
          data: { labels, datasets },
          options: {
            indexAxis: 'y',
            responsive: true,
            maintainAspectRatio: true,
            plugins: {
              title: { display: true, text: `${measure?.caption || 'Value'} by ${rowFieldName}` },
              legend: { position: 'top' }
            }
          }
        };
        break;

      case 'line':
        chartConfig = {
          type: 'line',
          data: {
            labels,
            datasets: datasets.map((ds, idx) => ({
              ...ds,
              fill: false,
              tension: 0.1,
              borderColor: chartBorderColors[idx % chartBorderColors.length],
              backgroundColor: chartColors[idx % chartColors.length]
            }))
          },
          options: {
            responsive: true,
            maintainAspectRatio: true,
            plugins: {
              title: { display: true, text: `${measure?.caption || 'Value'} Trend by ${rowFieldName}` },
              legend: { position: 'top' }
            }
          }
        };
        break;

      case 'area':
        chartConfig = {
          type: 'line',
          data: {
            labels,
            datasets: datasets.map((ds, idx) => ({
              ...ds,
              fill: true,
              tension: 0.1,
              borderColor: chartBorderColors[idx % chartBorderColors.length],
              backgroundColor: chartColors[idx % chartColors.length].replace('0.8)', '0.4)')
            }))
          },
          options: {
            responsive: true,
            maintainAspectRatio: true,
            plugins: {
              title: { display: true, text: `${measure?.caption || 'Value'} Area by ${rowFieldName}` },
              legend: { position: 'top' }
            }
          }
        };
        break;

      case 'pie':
        // Aggregate data for pie chart
        const pieData = labels.map((label, idx) => {
          return datasets.reduce((sum, ds) => sum + (ds.data[idx] || 0), 0);
        });
        chartConfig = {
          type: 'pie',
          data: {
            labels,
            datasets: [{
              data: pieData,
              backgroundColor: chartColors.slice(0, labels.length),
              borderColor: chartBorderColors.slice(0, labels.length),
              borderWidth: 1
            }]
          },
          options: {
            responsive: true,
            maintainAspectRatio: true,
            plugins: {
              title: { display: true, text: `${measure?.caption || 'Value'} Distribution` },
              legend: { position: 'right' }
            }
          }
        };
        break;

      case 'doughnut':
        const doughnutData = labels.map((label, idx) => {
          return datasets.reduce((sum, ds) => sum + (ds.data[idx] || 0), 0);
        });
        chartConfig = {
          type: 'doughnut',
          data: {
            labels,
            datasets: [{
              data: doughnutData,
              backgroundColor: chartColors.slice(0, labels.length),
              borderColor: chartBorderColors.slice(0, labels.length),
              borderWidth: 1
            }]
          },
          options: {
            responsive: true,
            maintainAspectRatio: true,
            plugins: {
              title: { display: true, text: `${measure?.caption || 'Value'} Distribution` },
              legend: { position: 'right' }
            }
          }
        };
        break;

      case 'stackedColumn':
        chartConfig = {
          type: 'bar',
          data: { labels, datasets },
          options: {
            responsive: true,
            maintainAspectRatio: true,
            scales: { x: { stacked: true }, y: { stacked: true } },
            plugins: {
              title: { display: true, text: `${measure?.caption || 'Value'} Stacked by ${rowFieldName}` },
              legend: { position: 'top' }
            }
          }
        };
        break;

      case 'stackedBar':
        chartConfig = {
          type: 'bar',
          data: { labels, datasets },
          options: {
            indexAxis: 'y',
            responsive: true,
            maintainAspectRatio: true,
            scales: { x: { stacked: true }, y: { stacked: true } },
            plugins: {
              title: { display: true, text: `${measure?.caption || 'Value'} Stacked by ${rowFieldName}` },
              legend: { position: 'top' }
            }
          }
        };
        break;

      case 'stackedArea':
        chartConfig = {
          type: 'line',
          data: {
            labels,
            datasets: datasets.map((ds, idx) => ({
              ...ds,
              fill: true,
              tension: 0.1,
              borderColor: chartBorderColors[idx % chartBorderColors.length],
              backgroundColor: chartColors[idx % chartColors.length].replace('0.8)', '0.6)')
            }))
          },
          options: {
            responsive: true,
            maintainAspectRatio: true,
            scales: { x: { stacked: true }, y: { stacked: true } },
            plugins: {
              title: { display: true, text: `${measure?.caption || 'Value'} Stacked Area by ${rowFieldName}` },
              legend: { position: 'top' }
            }
          }
        };
        break;

      case 'comboBarLine':
        // First half as bars, second half as lines
        const halfIdx = Math.ceil(datasets.length / 2);
        chartConfig = {
          type: 'bar',
          data: {
            labels,
            datasets: datasets.map((ds, idx) => ({
              ...ds,
              type: idx >= halfIdx ? 'line' : 'bar',
              order: idx >= halfIdx ? 1 : 2,
              fill: false,
              tension: 0.1,
              borderColor: chartBorderColors[idx % chartBorderColors.length],
              backgroundColor: chartColors[idx % chartColors.length]
            }))
          },
          options: {
            responsive: true,
            maintainAspectRatio: true,
            plugins: {
              title: { display: true, text: `${measure?.caption || 'Value'} - Bar + Line Combo` },
              legend: { position: 'top' }
            }
          }
        };
        break;

      case 'comboAreaLine':
        const areaHalfIdx = Math.ceil(datasets.length / 2);
        chartConfig = {
          type: 'line',
          data: {
            labels,
            datasets: datasets.map((ds, idx) => ({
              ...ds,
              fill: idx < areaHalfIdx,
              tension: 0.1,
              borderColor: chartBorderColors[idx % chartBorderColors.length],
              backgroundColor: idx < areaHalfIdx
                ? chartColors[idx % chartColors.length].replace('0.8)', '0.3)')
                : chartColors[idx % chartColors.length]
            }))
          },
          options: {
            responsive: true,
            maintainAspectRatio: true,
            plugins: {
              title: { display: true, text: `${measure?.caption || 'Value'} - Area + Line Combo` },
              legend: { position: 'top' }
            }
          }
        };
        break;

      case 'scatter':
        // Convert data to scatter format
        const scatterDatasets = datasets.map((ds, idx) => ({
          label: ds.label,
          data: ds.data.map((val, i) => ({ x: i, y: val })),
          backgroundColor: chartColors[idx % chartColors.length],
          borderColor: chartBorderColors[idx % chartBorderColors.length],
          pointRadius: 6,
          pointHoverRadius: 8
        }));
        chartConfig = {
          type: 'scatter',
          data: { datasets: scatterDatasets },
          options: {
            responsive: true,
            maintainAspectRatio: true,
            plugins: {
              title: { display: true, text: `${measure?.caption || 'Value'} Scatter Plot` },
              legend: { position: 'top' }
            },
            scales: {
              x: { title: { display: true, text: 'Index' } },
              y: { title: { display: true, text: measure?.caption || 'Value' } }
            }
          }
        };
        break;

      case 'histogram':
        // Flatten all data and create histogram bins
        const allValues = datasets.flatMap(ds => ds.data).filter(v => v > 0);
        const minVal = Math.min(...allValues);
        const maxVal = Math.max(...allValues);
        const numBins = 10;
        const binSize = (maxVal - minVal) / numBins;
        const bins = Array(numBins).fill(0);
        const binLabels = [];

        for (let i = 0; i < numBins; i++) {
          const binStart = minVal + i * binSize;
          const binEnd = minVal + (i + 1) * binSize;
          binLabels.push(`${binStart.toFixed(0)}-${binEnd.toFixed(0)}`);
        }

        allValues.forEach(val => {
          const binIdx = Math.min(Math.floor((val - minVal) / binSize), numBins - 1);
          bins[binIdx]++;
        });

        chartConfig = {
          type: 'bar',
          data: {
            labels: binLabels,
            datasets: [{
              label: 'Frequency',
              data: bins,
              backgroundColor: chartColors[0],
              borderColor: chartBorderColors[0],
              borderWidth: 1
            }]
          },
          options: {
            responsive: true,
            maintainAspectRatio: true,
            plugins: {
              title: { display: true, text: `${measure?.caption || 'Value'} Distribution (Histogram)` },
              legend: { display: false }
            },
            scales: {
              x: { title: { display: true, text: 'Value Range' } },
              y: { title: { display: true, text: 'Frequency' } }
            }
          }
        };
        break;

      case 'heatmap':
        // Render as a grid of colored cells using bar chart as fallback
        // Create a matrix visualization using stacked horizontal bars
        chartConfig = {
          type: 'bar',
          data: {
            labels,
            datasets: datasets.map((ds, idx) => ({
              ...ds,
              backgroundColor: ds.data.map(val => {
                const maxVal = Math.max(...datasets.flatMap(d => d.data));
                const intensity = val / maxVal;
                return `rgba(54, 162, 235, ${0.2 + intensity * 0.8})`;
              }),
              borderColor: chartBorderColors[idx % chartBorderColors.length],
              borderWidth: 1
            }))
          },
          options: {
            indexAxis: 'y',
            responsive: true,
            maintainAspectRatio: true,
            plugins: {
              title: { display: true, text: `${measure?.caption || 'Value'} Heatmap` },
              legend: { position: 'top' }
            }
          }
        };
        break;

      case 'funnel':
        // Sort data descending for funnel effect
        const funnelData = labels.map((label, idx) => {
          const total = datasets.reduce((sum, ds) => sum + (ds.data[idx] || 0), 0);
          return { label, value: total };
        }).sort((a, b) => b.value - a.value);

        chartConfig = {
          type: 'bar',
          data: {
            labels: funnelData.map(d => d.label),
            datasets: [{
              label: measure?.caption || 'Value',
              data: funnelData.map(d => d.value),
              backgroundColor: funnelData.map((_, idx) => chartColors[idx % chartColors.length]),
              borderColor: funnelData.map((_, idx) => chartBorderColors[idx % chartBorderColors.length]),
              borderWidth: 1,
              barPercentage: 1,
              categoryPercentage: 0.9
            }]
          },
          options: {
            indexAxis: 'y',
            responsive: true,
            maintainAspectRatio: true,
            plugins: {
              title: { display: true, text: `Funnel: ${measure?.caption || 'Value'} by ${rowFieldName}` },
              legend: { display: false }
            },
            scales: {
              x: { display: true },
              y: { display: true }
            }
          }
        };
        break;

      case 'sankey':
        // Sankey requires special plugin, render as horizontal bar chart showing flows
        const sankeyData = [];
        labels.forEach((rowLabel, rowIdx) => {
          datasets.forEach((ds, colIdx) => {
            if (ds.data[rowIdx] > 0) {
              sankeyData.push({
                from: rowLabel,
                to: ds.label,
                value: ds.data[rowIdx]
              });
            }
          });
        });

        // Group by 'from' for visualization
        const sankeyGrouped = {};
        sankeyData.forEach(flow => {
          if (!sankeyGrouped[flow.from]) sankeyGrouped[flow.from] = 0;
          sankeyGrouped[flow.from] += flow.value;
        });

        chartConfig = {
          type: 'bar',
          data: {
            labels: Object.keys(sankeyGrouped),
            datasets: [{
              label: `Flow from ${rowFieldName}`,
              data: Object.values(sankeyGrouped),
              backgroundColor: Object.keys(sankeyGrouped).map((_, idx) => chartColors[idx % chartColors.length]),
              borderColor: Object.keys(sankeyGrouped).map((_, idx) => chartBorderColors[idx % chartBorderColors.length]),
              borderWidth: 1
            }]
          },
          options: {
            indexAxis: 'y',
            responsive: true,
            maintainAspectRatio: true,
            plugins: {
              title: { display: true, text: `Sankey: ${rowFieldName} ‚Üí ${columnFieldName} (Simplified)` },
              legend: { display: false },
              subtitle: {
                display: true,
                text: 'Note: Full Sankey diagram requires chartjs-chart-sankey plugin'
              }
            }
          }
        };
        break;

      default:
        chartConfig = {
          type: 'bar',
          data: { labels, datasets },
          options: {
            responsive: true,
            maintainAspectRatio: true,
            plugins: {
              title: { display: true, text: `${measure?.caption || 'Value'} by ${rowFieldName}` },
              legend: { position: 'top' }
            }
          }
        };
    }

    chartRef.current = new Chart(ctx, chartConfig);
  }, [chartType, selectedMeasure, selectedRows, selectedColumns, chartLimit, destroyChart, chartColors, chartBorderColors]);

  // Handle chart type change
  const handleChartTypeChange = (newType) => {
    setChartType(newType);
    if (newType === 'none') {
      setShowChart(false);
      destroyChart();
    } else {
      setShowChart(true);
      // Re-initialize filter options when showing chart
      if (!chartServiceRef.current) {
        initializeChartService();
      }
    }
  };

  // Handle apply chart filters
  const handleApplyChartFilters = () => {
    renderChartVisualization();
  };

  // Handle reset chart filters
  const handleResetChartFilters = () => {
    if (chartFilterOptions.measures.length > 0) {
      setSelectedMeasure(chartFilterOptions.measures[0].uniqueName);
    }
    setSelectedRows(chartFilterOptions.rows);
    setSelectedColumns(chartFilterOptions.columns);
    setChartLimit(5);
  };

  // Effect to render chart when type changes or data changes
  useEffect(() => {
    if (showChart && chartType !== 'none') {
      // Small delay to ensure canvas is rendered
      const timeoutId = setTimeout(() => {
        renderChartVisualization();
      }, 100);
      return () => clearTimeout(timeoutId);
    }
  }, [showChart, chartType, renderChartVisualization]);

  // Effect to initialize ChartService when state changes
  useEffect(() => {
    if (state && state.data && state.data.length > 0) {
      // Small delay to ensure engine is ready
      const timeoutId = setTimeout(() => {
        initializeChartService();
      }, 200);
      return () => clearTimeout(timeoutId);
    }
  }, [state, initializeChartService]);

  const renderFormattedTable = () => {
    if (!state || !state.data || state.data.length === 0) {
      return <div style={{color: 'red', padding: '20px'}}>No data available</div>;
    }

    const columns = Object.keys(state.data[0]);
    const totalRows = state.data.length;
    const totalPages = Math.ceil(totalRows / rowsPerPage);

    // Calculate pagination
    const startIndex = (currentPage - 1) * rowsPerPage;
    const endIndex = Math.min(startIndex + rowsPerPage, totalRows);
    const paginatedData = state.data.slice(startIndex, endIndex);

    // Detect numeric columns for aggregations
    const numericColumns = columns.filter(col => {
      const sampleValues = state.data.slice(0, 100).map(row => row[col]);
      return sampleValues.some(val => typeof val === 'number' || !isNaN(parseFloat(val)));
    });

    // Calculate aggregations for numeric columns
    const aggregations = {};
    numericColumns.forEach(col => {
      const values = state.data.map(row => {
        const val = row[col];
        return typeof val === 'number' ? val : parseFloat(val);
      }).filter(v => !isNaN(v));

      if (values.length > 0) {
        aggregations[col] = {
          sum: values.reduce((a, b) => a + b, 0),
          avg: values.reduce((a, b) => a + b, 0) / values.length,
          min: Math.min(...values),
          max: Math.max(...values),
          count: values.length
        };
      }
    });

    // Pagination controls
    const handlePrevPage = () => setCurrentPage(prev => Math.max(1, prev - 1));
    const handleNextPage = () => setCurrentPage(prev => Math.min(totalPages, prev + 1));
    const handleFirstPage = () => setCurrentPage(1);
    const handleLastPage = () => setCurrentPage(totalPages);
    const handlePageInput = (e) => {
      const page = parseInt(e.target.value);
      if (page >= 1 && page <= totalPages) setCurrentPage(page);
    };

    return (
      <div style={{ overflowX: 'auto' }}>
        <div style={{
          marginBottom: '15px',
          padding: '15px',
          backgroundColor: '#e7f3ff',
          border: '1px solid #0066cc',
          borderRadius: '5px'
        }}>
          <h4 style={{ margin: '0 0 10px 0', color: '#0066cc' }}>üìä Processed Data View</h4>
          <div style={{ display: 'grid', gridTemplateColumns: 'repeat(auto-fit, minmax(200px, 1fr))', gap: '10px' }}>
            <div>
              <strong>Total Records:</strong> {totalRows.toLocaleString()}
            </div>
            <div>
              <strong>Columns:</strong> {columns.length}
            </div>
            <div>
              <strong>Numeric Columns:</strong> {numericColumns.length}
            </div>
            <div>
              <strong>Current Page:</strong> {currentPage} / {totalPages.toLocaleString()}
            </div>
          </div>
        </div>

        {/* Aggregations Summary */}
        {numericColumns.length > 0 && (
          <div style={{
            marginBottom: '15px',
            padding: '15px',
            backgroundColor: '#f8f9fa',
            border: '1px solid #dee2e6',
            borderRadius: '5px'
          }}>
            <h5 style={{ margin: '0 0 10px 0' }}>üìà Statistical Summary</h5>
            <div style={{ overflowX: 'auto' }}>
              <table style={{ width: '100%', borderCollapse: 'collapse', fontSize: '14px' }}>
                <thead>
                  <tr>
                    <th style={{ padding: '8px', borderBottom: '2px solid #dee2e6', textAlign: 'left' }}>Column</th>
                    <th style={{ padding: '8px', borderBottom: '2px solid #dee2e6', textAlign: 'right' }}>Sum</th>
                    <th style={{ padding: '8px', borderBottom: '2px solid #dee2e6', textAlign: 'right' }}>Average</th>
                    <th style={{ padding: '8px', borderBottom: '2px solid #dee2e6', textAlign: 'right' }}>Min</th>
                    <th style={{ padding: '8px', borderBottom: '2px solid #dee2e6', textAlign: 'right' }}>Max</th>
                    <th style={{ padding: '8px', borderBottom: '2px solid #dee2e6', textAlign: 'right' }}>Count</th>
                  </tr>
                </thead>
                <tbody>
                  {numericColumns.map(col => (
                    <tr key={`agg-${col}`}>
                      <td style={{ padding: '8px', borderBottom: '1px solid #dee2e6', fontWeight: 'bold' }}>{col}</td>
                      <td style={{ padding: '8px', borderBottom: '1px solid #dee2e6', textAlign: 'right' }}>
                        {aggregations[col]?.sum.toLocaleString(undefined, { maximumFractionDigits: 2 })}
                      </td>
                      <td style={{ padding: '8px', borderBottom: '1px solid #dee2e6', textAlign: 'right' }}>
                        {aggregations[col]?.avg.toLocaleString(undefined, { maximumFractionDigits: 2 })}
                      </td>
                      <td style={{ padding: '8px', borderBottom: '1px solid #dee2e6', textAlign: 'right' }}>
                        {aggregations[col]?.min.toLocaleString(undefined, { maximumFractionDigits: 2 })}
                      </td>
                      <td style={{ padding: '8px', borderBottom: '1px solid #dee2e6', textAlign: 'right' }}>
                        {aggregations[col]?.max.toLocaleString(undefined, { maximumFractionDigits: 2 })}
                      </td>
                      <td style={{ padding: '8px', borderBottom: '1px solid #dee2e6', textAlign: 'right' }}>
                        {aggregations[col]?.count.toLocaleString()}
                      </td>
                    </tr>
                  ))}
                </tbody>
              </table>
            </div>
          </div>
        )}

        {/* Pagination Controls - Top */}
        <div style={{
          display: 'flex',
          justifyContent: 'space-between',
          alignItems: 'center',
          padding: '10px',
          backgroundColor: '#f8f9fa',
          borderRadius: '5px',
          marginBottom: '10px'
        }}>
          <div>
            <small>Showing rows {startIndex + 1} - {endIndex} of {totalRows.toLocaleString()}</small>
          </div>
          <div style={{ display: 'flex', gap: '5px', alignItems: 'center' }}>
            <button onClick={handleFirstPage} disabled={currentPage === 1}
              style={{ padding: '5px 10px', cursor: currentPage === 1 ? 'not-allowed' : 'pointer', opacity: currentPage === 1 ? 0.5 : 1 }}>
              ¬´
            </button>
            <button onClick={handlePrevPage} disabled={currentPage === 1}
              style={{ padding: '5px 10px', cursor: currentPage === 1 ? 'not-allowed' : 'pointer', opacity: currentPage === 1 ? 0.5 : 1 }}>
              ‚Äπ
            </button>
            <span style={{ padding: '0 10px' }}>
              Page
              <input type="number" min="1" max={totalPages} value={currentPage} onChange={handlePageInput}
                style={{ width: '60px', margin: '0 5px', padding: '3px', textAlign: 'center' }} />
              of {totalPages.toLocaleString()}
            </span>
            <button onClick={handleNextPage} disabled={currentPage === totalPages}
              style={{ padding: '5px 10px', cursor: currentPage === totalPages ? 'not-allowed' : 'pointer', opacity: currentPage === totalPages ? 0.5 : 1 }}>
              ‚Ä∫
            </button>
            <button onClick={handleLastPage} disabled={currentPage === totalPages}
              style={{ padding: '5px 10px', cursor: currentPage === totalPages ? 'not-allowed' : 'pointer', opacity: currentPage === totalPages ? 0.5 : 1 }}>
              ¬ª
            </button>
          </div>
        </div>

        {/* Data Table */}
        <table style={{
          width: '100%',
          borderCollapse: 'collapse',
          border: '1px solid #dee2e6'
        }}>
          <thead>
            <tr>
              <th style={{
                padding: '12px',
                backgroundColor: '#0066cc',
                color: 'white',
                borderBottom: '2px solid #004999',
                borderRight: '1px solid #004999',
                fontWeight: 'bold',
                position: 'sticky',
                top: 0,
                zIndex: 10
              }}>
                #
              </th>
              {columns.map((col, index) => (
                <th key={`col-${index}-${col}`}
                  style={{
                    padding: '12px',
                    backgroundColor: '#0066cc',
                    color: 'white',
                    borderBottom: '2px solid #004999',
                    borderRight: '1px solid #004999',
                    fontWeight: 'bold',
                    textAlign: numericColumns.includes(col) ? 'right' : 'left',
                    position: 'sticky',
                    top: 0,
                    zIndex: 10
                  }}>
                  {col}
                  {numericColumns.includes(col) && ' üìä'}
                </th>
              ))}
            </tr>
          </thead>
          <tbody>
            {paginatedData.map((row, rowIndex) => {
              const actualRowNumber = startIndex + rowIndex + 1;
              return (
                <tr key={`formatted-row-${actualRowNumber}`}
                  style={{ backgroundColor: rowIndex % 2 === 0 ? 'white' : '#f8f9fa' }}>
                  <td style={{
                    padding: '10px',
                    borderBottom: '1px solid #dee2e6',
                    borderRight: '1px solid #dee2e6',
                    fontWeight: 'bold',
                    backgroundColor: '#e9ecef'
                  }}>
                    {actualRowNumber}
                  </td>
                  {columns.map((col, colIndex) => {
                    const value = row[col];
                    const isNumeric = numericColumns.includes(col);
                    let displayValue = value;

                    // Format numeric values
                    if (isNumeric && (typeof value === 'number' || !isNaN(parseFloat(value)))) {
                      displayValue = parseFloat(value).toLocaleString(undefined, { maximumFractionDigits: 2 });
                    } else if (value === null || value === undefined || value === '') {
                      displayValue = '-';
                    }

                    return (
                      <td key={`formatted-cell-${actualRowNumber}-${colIndex}`}
                        style={{
                          padding: '10px',
                          borderBottom: '1px solid #dee2e6',
                          borderRight: '1px solid #dee2e6',
                          textAlign: isNumeric ? 'right' : 'left',
                          fontFamily: isNumeric ? 'monospace' : 'inherit'
                        }}>
                        {displayValue}
                      </td>
                    );
                  })}
                </tr>
              );
            })}
          </tbody>
        </table>

        {/* Pagination Controls - Bottom */}
        <div style={{
          display: 'flex',
          justifyContent: 'space-between',
          alignItems: 'center',
          padding: '10px',
          backgroundColor: '#f8f9fa',
          borderRadius: '5px',
          marginTop: '10px'
        }}>
          <div>
            <small>Showing rows {startIndex + 1} - {endIndex} of {totalRows.toLocaleString()}</small>
          </div>
          <div style={{ display: 'flex', gap: '5px' }}>
            <button onClick={handleFirstPage} disabled={currentPage === 1}
              style={{ padding: '5px 10px', cursor: currentPage === 1 ? 'not-allowed' : 'pointer', opacity: currentPage === 1 ? 0.5 : 1 }}>
              ¬´ First
            </button>
            <button onClick={handlePrevPage} disabled={currentPage === 1}
              style={{ padding: '5px 10px', cursor: currentPage === 1 ? 'not-allowed' : 'pointer', opacity: currentPage === 1 ? 0.5 : 1 }}>
              ‚Äπ Previous
            </button>
            <button onClick={handleNextPage} disabled={currentPage === totalPages}
              style={{ padding: '5px 10px', cursor: currentPage === totalPages ? 'not-allowed' : 'pointer', opacity: currentPage === totalPages ? 0.5 : 1 }}>
              Next ‚Ä∫
            </button>
            <button onClick={handleLastPage} disabled={currentPage === totalPages}
              style={{ padding: '5px 10px', cursor: currentPage === totalPages ? 'not-allowed' : 'pointer', opacity: currentPage === totalPages ? 0.5 : 1 }}>
              Last ¬ª
            </button>
          </div>
        </div>
      </div>
    );
  };

  const renderRawData = () => {
    if (!state || !state.data || state.data.length === 0) {
      return <div style={{color: 'red', padding: '20px'}}>No raw data available</div>;
    }

    const columns = Object.keys(state.data[0]);
    const totalRows = state.data.length;
    const totalPages = Math.ceil(totalRows / rowsPerPage);

    // Calculate pagination
    const startIndex = (currentPage - 1) * rowsPerPage;
    const endIndex = Math.min(startIndex + rowsPerPage, totalRows);
    const paginatedData = state.data.slice(startIndex, endIndex);

    // Pagination controls
    const handlePrevPage = () => {
      setCurrentPage(prev => Math.max(1, prev - 1));
    };

    const handleNextPage = () => {
      setCurrentPage(prev => Math.min(totalPages, prev + 1));
    };

    const handleFirstPage = () => {
      setCurrentPage(1);
    };

    const handleLastPage = () => {
      setCurrentPage(totalPages);
    };

    const handlePageInput = (e) => {
      const page = parseInt(e.target.value);
      if (page >= 1 && page <= totalPages) {
        setCurrentPage(page);
      }
    };

    return (
      <div style={{ overflowX: 'auto' }}>
        {/* Pagination Controls - Top */}
        <div style={{
          display: 'flex',
          justifyContent: 'space-between',
          alignItems: 'center',
          padding: '10px',
          backgroundColor: '#f8f9fa',
          borderRadius: '5px',
          marginBottom: '10px'
        }}>
          <div>
            <strong>Total Rows:</strong> {totalRows.toLocaleString()} |
            <strong> Columns:</strong> {columns.length} |
            <strong> Page:</strong> {currentPage} / {totalPages.toLocaleString()}
          </div>
          <div style={{ display: 'flex', gap: '5px', alignItems: 'center' }}>
            <button
              onClick={handleFirstPage}
              disabled={currentPage === 1}
              style={{
                padding: '5px 10px',
                cursor: currentPage === 1 ? 'not-allowed' : 'pointer',
                opacity: currentPage === 1 ? 0.5 : 1
              }}
            >
              ¬´
            </button>
            <button
              onClick={handlePrevPage}
              disabled={currentPage === 1}
              style={{
                padding: '5px 10px',
                cursor: currentPage === 1 ? 'not-allowed' : 'pointer',
                opacity: currentPage === 1 ? 0.5 : 1
              }}
            >
              ‚Äπ
            </button>
            <span style={{ padding: '0 10px' }}>
              Page
              <input
                type="number"
                min="1"
                max={totalPages}
                value={currentPage}
                onChange={handlePageInput}
                style={{
                  width: '60px',
                  margin: '0 5px',
                  padding: '3px',
                  textAlign: 'center'
                }}
              />
              of {totalPages.toLocaleString()}
            </span>
            <button
              onClick={handleNextPage}
              disabled={currentPage === totalPages}
              style={{
                padding: '5px 10px',
                cursor: currentPage === totalPages ? 'not-allowed' : 'pointer',
                opacity: currentPage === totalPages ? 0.5 : 1
              }}
            >
              ‚Ä∫
            </button>
            <button
              onClick={handleLastPage}
              disabled={currentPage === totalPages}
              style={{
                padding: '5px 10px',
                cursor: currentPage === totalPages ? 'not-allowed' : 'pointer',
                opacity: currentPage === totalPages ? 0.5 : 1
              }}
            >
              ¬ª
            </button>
          </div>
        </div>

        {/* Table */}
        <table style={{
          width: '100%',
          borderCollapse: 'collapse',
          border: '1px solid #dee2e6'
        }}>
          <thead>
            <tr>
              <th style={{
                padding: '12px',
                backgroundColor: '#f8f9fa',
                borderBottom: '2px solid #dee2e6',
                borderRight: '1px solid #dee2e6',
                fontWeight: 'bold',
                position: 'sticky',
                top: 0,
                zIndex: 10
              }}>
                #
              </th>
              {columns.map((col, index) => (
                <th
                  key={`col-${index}-${col}`}
                  style={{
                    padding: '12px',
                    backgroundColor: '#f8f9fa',
                    borderBottom: '2px solid #dee2e6',
                    borderRight: '1px solid #dee2e6',
                    fontWeight: 'bold',
                    textAlign: 'left',
                    position: 'sticky',
                    top: 0,
                    zIndex: 10
                  }}
                >
                  {col}
                </th>
              ))}
            </tr>
          </thead>
          <tbody>
            {paginatedData.map((row, rowIndex) => {
              const actualRowNumber = startIndex + rowIndex + 1;
              return (
                <tr key={`raw-row-${actualRowNumber}`}>
                  <td style={{
                    padding: '8px',
                    borderBottom: '1px solid #dee2e6',
                    borderRight: '1px solid #dee2e6',
                    fontWeight: 'bold',
                    backgroundColor: '#f8f9fa'
                  }}>
                    {actualRowNumber}
                  </td>
                  {columns.map((col, colIndex) => (
                    <td
                      key={`raw-cell-${actualRowNumber}-${colIndex}`}
                      style={{
                        padding: '8px',
                        borderBottom: '1px solid #dee2e6',
                        borderRight: '1px solid #dee2e6'
                      }}
                    >
                      {row[col] !== null && row[col] !== undefined ? String(row[col]) : '-'}
                    </td>
                  ))}
                </tr>
              );
            })}
          </tbody>
        </table>

        {/* Pagination Controls - Bottom */}
        <div style={{
          display: 'flex',
          justifyContent: 'space-between',
          alignItems: 'center',
          padding: '10px',
          backgroundColor: '#f8f9fa',
          borderRadius: '5px',
          marginTop: '10px'
        }}>
          <div>
            <small>
              Showing rows {startIndex + 1} - {endIndex} of {totalRows.toLocaleString()}
            </small>
          </div>
          <div style={{ display: 'flex', gap: '5px' }}>
            <button
              onClick={handleFirstPage}
              disabled={currentPage === 1}
              style={{
                padding: '5px 10px',
                cursor: currentPage === 1 ? 'not-allowed' : 'pointer',
                opacity: currentPage === 1 ? 0.5 : 1
              }}
            >
              ¬´
            </button>
            <button
              onClick={handlePrevPage}
              disabled={currentPage === 1}
              style={{
                padding: '5px 10px',
                cursor: currentPage === 1 ? 'not-allowed' : 'pointer',
                opacity: currentPage === 1 ? 0.5 : 1
              }}
            >
              ‚Äπ Previous
            </button>
            <button
              onClick={handleNextPage}
              disabled={currentPage === totalPages}
              style={{
                padding: '5px 10px',
                cursor: currentPage === totalPages ? 'not-allowed' : 'pointer',
                opacity: currentPage === totalPages ? 0.5 : 1
              }}
            >
              Next ‚Ä∫
            </button>
            <button
              onClick={handleLastPage}
              disabled={currentPage === totalPages}
              style={{
                padding: '5px 10px',
                cursor: currentPage === totalPages ? 'not-allowed' : 'pointer',
                opacity: currentPage === totalPages ? 0.5 : 1
              }}
            >
              ¬ª
            </button>
          </div>
        </div>
      </div>
    );
  };

  const renderTable = () => {
    if (!state || !state.data || state.data.length === 0) {
      return <div style={{color: 'red', padding: '20px'}}>No data available</div>;
    }

    // Check if this is a pivot table (has product/region) or generic CSV
    const hasPivotStructure = state.data[0]?.product !== undefined && state.data[0]?.region !== undefined;

    if (!hasPivotStructure) {
      // For uploaded CSVs without pivot structure, show a formatted table view
      return renderFormattedTable();
    }

    const uniqueRegions = [...new Set(state.data.map(item => item.region).filter(Boolean))];
    const uniqueProducts = [...new Set(state.data.map(item => item.product).filter(Boolean))];
    const currentSortConfig = state.sortConfig?.[0];

    return (
      <table style={{
        width: '100%',
        borderCollapse: 'collapse',
        marginTop: '20px',
        border: '1px solid #dee2e6'
      }}>
        <thead>
          <tr>
            <th style={{
              padding: '12px',
              backgroundColor: '#f8f9fa',
              borderBottom: '2px solid #dee2e6',
              borderRight: '1px solid #dee2e6'
            }}>
              Product / Region
            </th>
            {uniqueRegions.map((region, index) => (
              <th
                key={`header-region-${index}-${region}`}
                colSpan={state.measures.length}
                draggable="true"
                data-index={index + 1}
                style={{
                  padding: '12px',
                  backgroundColor: '#f8f9fa',
                  borderBottom: '2px solid #dee2e6',
                  borderRight: '1px solid #dee2e6',
                  textAlign: 'center',
                  cursor: 'move'
                }}
              >
                {region}
              </th>
            ))}
          </tr>
          
          <tr>
            <th
              onClick={handleProductSort}
              style={{
                padding: '12px',
                backgroundColor: '#f8f9fa',
                borderBottom: '2px solid #dee2e6',
                borderRight: '1px solid #dee2e6',
                cursor: 'pointer'
              }}
            >
              <div style={{
                display: 'flex',
                alignItems: 'center'
              }}>
                <span>Product</span>
                {currentSortConfig?.field === 'product' && (
                  <span style={{ marginLeft: '5px' }}>
                    {currentSortConfig.direction === 'asc' ? '‚ñ≤' : '‚ñº'}
                  </span>
                )}
              </div>
            </th>
            {uniqueRegions.flatMap(region =>
              state.measures.map(measure => (
                <th
                  key={`${region}-${measure.uniqueName}`}
                  onClick={() => handleMeasureSort(measure)}
                  style={{
                    padding: '12px',
                    backgroundColor: '#f8f9fa',
                    borderBottom: '2px solid #dee2e6',
                    borderRight: '1px solid #dee2e6',
                    cursor: 'pointer'
                  }}
                >
                  <div style={{
                    display: 'flex',
                    alignItems: 'center',
                    justifyContent: 'space-between'
                  }}>
                    <span>{measure.caption}</span>
                    {currentSortConfig?.field === measure.uniqueName && (
                      <span style={{ marginLeft: '5px' }}>
                        {currentSortConfig.direction === 'asc' ? '‚ñ≤' : '‚ñº'}
                      </span>
                    )}
                  </div>
                </th>
              ))
            )}
          </tr>
        </thead>
        
        <tbody>
          {uniqueProducts.map((product, rowIndex) => (
            <tr
              key={`row-${rowIndex}-${product}`}
              data-row-index={rowIndex}
              draggable="true"
              style={{ cursor: 'move' }}
            >
              <td style={{
                fontWeight: 'bold',
                padding: '8px',
                borderBottom: '1px solid #dee2e6'
              }}>
                {product}
              </td>
              {uniqueRegions.flatMap(region =>
                state.measures.map(measure => {
                  const filteredData = state.data.filter(
                    item => item.product === product && item.region === region
                  );

                  let value = 0;
                  if (filteredData.length > 0) {
                    switch (measure.aggregation) {
                      case 'sum':
                        value = filteredData.reduce((sum, item) => sum + (item[measure.uniqueName] || 0), 0);
                        break;
                      case 'avg':
                        if (measure.formula) {
                          value = filteredData.reduce((sum, item) => sum + measure.formula(item), 0) / filteredData.length;
                        } else {
                          value = filteredData.reduce((sum, item) => sum + (item[measure.uniqueName] || 0), 0) / filteredData.length;
                        }
                        break;
                      case 'max':
                        value = Math.max(...filteredData.map(item => item[measure.uniqueName] || 0));
                        break;
                      case 'min':
                        value = Math.min(...filteredData.map(item => item[measure.uniqueName] || 0));
                        break;
                      default:
                        value = 0;
                    }
                  }

                  let formattedValue = value;
                  if (measure.format) {
                    if (measure.format.type === 'currency') {
                      formattedValue = new Intl.NumberFormat(measure.format.locale, {
                        style: 'currency',
                        currency: measure.format.currency,
                        minimumFractionDigits: measure.format.decimals,
                        maximumFractionDigits: measure.format.decimals,
                      }).format(value);
                    } else if (measure.format.type === 'number') {
                      formattedValue = new Intl.NumberFormat(measure.format.locale, {
                        minimumFractionDigits: measure.format.decimals,
                        maximumFractionDigits: measure.format.decimals,
                      }).format(value);
                    }
                  }

                  let cellStyle = {
                    padding: '8px',
                    borderBottom: '1px solid #dee2e6',
                    borderRight: '1px solid #dee2e6',
                    textAlign: 'right'
                  };

                  return (
                    <td
                      key={`${product}-${region}-${measure.uniqueName}`}
                      style={cellStyle}
                    >
                      {formattedValue}
                    </td>
                  );
                })
              )}
            </tr>
          ))}
        </tbody>
      </table>
    );
  };

  console.log('Current state:', state);

  return (
    <div style={{ padding: '20px' }}>
      <h2>PivotHead React Demo</h2>

      {/* Filter handling */}
      <div style={{ marginBottom: '20px', padding: '15px', border: '1px solid #ddd', borderRadius: '5px' }}>
        <h3>Filters</h3>
        <div style={{ display: 'flex', gap: '10px', alignItems: 'center', flexWrap: 'wrap' }}>
          <select value={field} onChange={(e) => setField(e.target.value)} style={{ padding: '5px' }}>
            <option value="product">Product</option>
            <option value="region">Region</option>
            <option value="sales">Sales</option>
            <option value="quantity">Quantity</option>
            <option value="date">Date</option>
          </select>

          <select value={operator} onChange={(e) => setOperator(e.target.value)} style={{ padding: '5px' }}>
            <option value="equals">Equals</option>
            <option value="greater">Greater than</option>
            <option value="less">Less than</option>
            <option value="contains">Contains</option>
          </select>

          <input
            type="text"
            placeholder="Filter Value"
            value={value}
            onChange={(e) => setValue(e.target.value)}
            style={{ padding: '5px' }}
          />

          <button onClick={handleFilter} style={{ padding: '5px 15px' }}>Apply Filter</button>
        </div>
      </div>

      {/* File Upload handling */}
      <div style={{ marginBottom: '20px', padding: '15px', border: '1px solid #ddd', borderRadius: '5px' }}>
        <h3>Upload CSV/JSON File</h3>
        <div style={{ display: 'flex', gap: '10px', alignItems: 'center' }}>
          <button onClick={handleUploadCSV} style={{ padding: '10px 20px', backgroundColor: '#007bff', color: 'white', border: 'none', borderRadius: '3px', cursor: 'pointer' }}>
            Upload CSV/JSON File
          </button>
          <small style={{ color: '#666' }}>Supports large files up to 800 MB</small>
        </div>
      </div>

      {/* Export handling */}
      <div style={{ marginBottom: '20px', padding: '15px', border: '1px solid #ddd', borderRadius: '5px' }}>
        <h3>Export Options</h3>
        <div style={{ display: 'flex', gap: '10px', alignItems: 'center' }}>
          <select style={{ padding: '5px' }}>
            <option value="pdf">Export as PDF</option>
            <option value="html">Export as HTML</option>
            <option value="excel">Export as Excel</option>
          </select>

          <button onClick={handleExport} style={{ padding: '5px 15px' }}>Export</button>
        </div>
      </div>

      {/* Reset and View Toggle */}
      <div style={{ marginBottom: '20px', display: 'flex', gap: '10px' }}>
        <button onClick={handleReset} style={{ padding: '10px 20px', backgroundColor: '#dc3545', color: 'white', border: 'none', borderRadius: '3px', cursor: 'pointer' }}>
          Reset All
        </button>
        <button
          onClick={() => {
            setShowRawData(!showRawData);
            setCurrentPage(1); // Reset to first page when switching views
          }}
          style={{
            padding: '10px 20px',
            backgroundColor: showRawData ? '#28a745' : '#007bff',
            color: 'white',
            border: 'none',
            borderRadius: '3px',
            cursor: 'pointer'
          }}
        >
          {showRawData ? 'Show Processed Table' : 'Show Raw Data'}
        </button>
      </div>

      {/* Chart Visualization Section */}
      <div style={{ marginBottom: '20px', padding: '15px', border: '1px solid #ddd', borderRadius: '5px' }}>
        <h3>Data Visualization</h3>
        <div style={{ display: 'flex', gap: '10px', alignItems: 'center', flexWrap: 'wrap', marginBottom: '15px' }}>
          <label htmlFor="chartType">Chart Type:</label>
          <select
            id="chartType"
            value={chartType}
            onChange={(e) => handleChartTypeChange(e.target.value)}
            style={{ padding: '8px', borderRadius: '4px', border: '1px solid #ccc' }}
          >
            <option value="none">-- Select Chart Type --</option>
            <optgroup label="Basic Charts">
              <option value="column">Column Chart</option>
              <option value="bar">Bar Chart (Horizontal)</option>
              <option value="line">Line Chart</option>
              <option value="area">Area Chart</option>
            </optgroup>
            <optgroup label="Circular Charts">
              <option value="pie">Pie Chart</option>
              <option value="doughnut">Doughnut Chart</option>
            </optgroup>
            <optgroup label="Stacked Charts">
              <option value="stackedColumn">Stacked Column Chart</option>
              <option value="stackedBar">Stacked Bar Chart</option>
              <option value="stackedArea">Stacked Area Chart</option>
            </optgroup>
            <optgroup label="Combo Charts">
              <option value="comboBarLine">Combo Bar + Line</option>
              <option value="comboAreaLine">Combo Area + Line</option>
            </optgroup>
            <optgroup label="Statistical Charts">
              <option value="scatter">Scatter Chart</option>
              <option value="histogram">Histogram</option>
            </optgroup>
            <optgroup label="Specialized Charts">
              <option value="heatmap">Heatmap</option>
              <option value="funnel">Funnel Chart</option>
              <option value="sankey">Sankey Diagram</option>
            </optgroup>
          </select>

          {showChart && (
            <button
              onClick={() => handleChartTypeChange('none')}
              style={{
                padding: '8px 16px',
                backgroundColor: '#dc3545',
                color: 'white',
                border: 'none',
                borderRadius: '4px',
                cursor: 'pointer'
              }}
            >
              Hide Chart
            </button>
          )}
        </div>

        {/* Chart Filters - only show when chart is visible */}
        {showChart && (
          <div style={{
            padding: '15px',
            backgroundColor: '#f8f9fa',
            borderRadius: '5px',
            marginBottom: '15px'
          }}>
            <h4 style={{ margin: '0 0 15px 0' }}>Chart Filters</h4>
            <div style={{ display: 'grid', gridTemplateColumns: 'repeat(auto-fit, minmax(200px, 1fr))', gap: '15px' }}>
              {/* Measure Selection */}
              <div>
                <label style={{ display: 'block', marginBottom: '5px', fontWeight: 'bold' }}>Measure:</label>
                <select
                  value={selectedMeasure}
                  onChange={(e) => setSelectedMeasure(e.target.value)}
                  style={{ width: '100%', padding: '8px', borderRadius: '4px', border: '1px solid #ccc' }}
                >
                  {chartFilterOptions.measures.map((m) => (
                    <option key={m.uniqueName} value={m.uniqueName}>{m.caption || m.uniqueName}</option>
                  ))}
                </select>
              </div>

              {/* Row Selection */}
              <div>
                <label style={{ display: 'block', marginBottom: '5px', fontWeight: 'bold' }}>Rows:</label>
                <select
                  multiple
                  value={selectedRows}
                  onChange={(e) => setSelectedRows(Array.from(e.target.selectedOptions, opt => opt.value))}
                  style={{ width: '100%', padding: '8px', borderRadius: '4px', border: '1px solid #ccc', height: '100px' }}
                >
                  {chartFilterOptions.rows.map((row) => (
                    <option key={row} value={row}>{row}</option>
                  ))}
                </select>
              </div>

              {/* Column Selection */}
              <div>
                <label style={{ display: 'block', marginBottom: '5px', fontWeight: 'bold' }}>Columns:</label>
                <select
                  multiple
                  value={selectedColumns}
                  onChange={(e) => setSelectedColumns(Array.from(e.target.selectedOptions, opt => opt.value))}
                  style={{ width: '100%', padding: '8px', borderRadius: '4px', border: '1px solid #ccc', height: '100px' }}
                >
                  {chartFilterOptions.columns.map((col) => (
                    <option key={col} value={col}>{col}</option>
                  ))}
                </select>
              </div>

              {/* Limit Selection */}
              <div>
                <label style={{ display: 'block', marginBottom: '5px', fontWeight: 'bold' }}>Limit (Top N):</label>
                <select
                  value={chartLimit}
                  onChange={(e) => setChartLimit(parseInt(e.target.value, 10))}
                  style={{ width: '100%', padding: '8px', borderRadius: '4px', border: '1px solid #ccc' }}
                >
                  <option value="0">All</option>
                  <option value="5">Top 5</option>
                  <option value="10">Top 10</option>
                  <option value="15">Top 15</option>
                  <option value="20">Top 20</option>
                </select>
              </div>
            </div>

            {/* Filter Buttons */}
            <div style={{ marginTop: '15px', display: 'flex', gap: '10px' }}>
              <button
                onClick={handleApplyChartFilters}
                style={{
                  padding: '8px 20px',
                  backgroundColor: '#007bff',
                  color: 'white',
                  border: 'none',
                  borderRadius: '4px',
                  cursor: 'pointer'
                }}
              >
                Apply Filters
              </button>
              <button
                onClick={handleResetChartFilters}
                style={{
                  padding: '8px 20px',
                  backgroundColor: '#6c757d',
                  color: 'white',
                  border: 'none',
                  borderRadius: '4px',
                  cursor: 'pointer'
                }}
              >
                Reset Filters
              </button>
            </div>
          </div>
        )}

        {/* Chart Canvas */}
        {showChart && (
          <div style={{
            padding: '15px',
            backgroundColor: 'white',
            borderRadius: '5px',
            border: '1px solid #dee2e6',
            maxWidth: '700px',
            maxHeight: '400px',
            margin: '0 auto'
          }}>
            <canvas ref={chartCanvasRef} id="pivotChart" style={{ maxHeight: '350px' }}></canvas>
          </div>
        )}
      </div>

      {/* Loading Indicator */}
      {isLoading && (
        <div style={{
          marginBottom: '20px',
          padding: '20px',
          backgroundColor: '#fff3cd',
          border: '1px solid #ffc107',
          borderRadius: '5px',
          textAlign: 'center'
        }}>
          <div style={{ fontSize: '18px', fontWeight: 'bold', marginBottom: '10px' }}>
            {loadingMessage}
          </div>
          <div style={{
            width: '100%',
            height: '10px',
            backgroundColor: '#e9ecef',
            borderRadius: '5px',
            overflow: 'hidden'
          }}>
            <div style={{
              width: '100%',
              height: '100%',
              backgroundColor: '#ffc107',
              animation: 'pulse 1.5s ease-in-out infinite'
            }}></div>
          </div>
        </div>
      )}

      {/* Debug info */}
      <div style={{ marginBottom: '20px', padding: '10px', backgroundColor: '#f8f9fa', borderRadius: '5px' }}>
        <small>
          <strong>Debug:</strong> Engine initialized: {state ? 'Yes' : 'No'} |
          Data rows: {state?.data?.length?.toLocaleString() || 'N/A'} |
          Measures: {state?.measures?.length || 'N/A'}
        </small>
      </div>
      
      {/* The web component - hidden since we're rendering our own table */}
      <pivot-head
        ref={pivotRef}
        style={{ display: 'none' }}
      ></pivot-head>

      {showRawData ? renderRawData() : renderTable()}
    </div>
  );
};

export default PivotHeadDemo;


================================================
FILE: src/config/config.js
================================================
export const data = [
  {
    date: '2024-01-01',
    product: 'Widget A',
    region: 'North',
    sales: 1000,
    quantity: 50,
  },
  {
    date: '2024-01-01',
    product: 'Widget B',
    region: 'South',
    sales: 1500,
    quantity: 75,
  },
  {
    date: '2024-01-01',
    product: 'Widget D',
    region: 'North',
    sales: 1300,
    quantity: 70,
  },
  {
    date: '2024-01-02',
    product: 'Widget A',
    region: 'East',
    sales: 1200,
    quantity: 60,
  },
  {
    date: '2024-01-02',
    product: 'Widget A',
    region: 'East',
    sales: 100,
    quantity: 44,
  },
  {
    date: '2024-01-02',
    product: 'Widget C',
    region: 'West',
    sales: 800,
    quantity: 40,
  },
  {
    date: '2024-01-03',
    product: 'Widget B',
    region: 'North',
    sales: 1800,
    quantity: 90,
  },
  {
    date: '2024-01-03',
    product: 'Widget C',
    region: 'South',
    sales: 1100,
    quantity: 55,
  },
  {
    date: '2024-01-04',
    product: 'Widget A',
    region: 'West',
    sales: 1300,
    quantity: 65,
  },
  {
    date: '2024-01-04',
    product: 'Widget B',
    region: 'East',
    sales: 1600,
    quantity: 80,
  },
];

export const options = {
  rows: [{ uniqueName: 'product', caption: 'Product' }],
  columns: [{ uniqueName: 'region', caption: 'Region' }],
  measures: [
    {
      uniqueName: 'sales',
      caption: 'Total Sales',
      aggregation: 'sum',
      format: {
        type: 'currency',
        currency: 'USD',
        locale: 'en-US',
        decimals: 2,
      },
      sortable: true,
    },
    {
      uniqueName: 'quantity',
      caption: 'Total Quantity',
      aggregation: 'sum',
      format: {
        type: 'number',
        decimals: 0,
        locale: 'en-US',
      },
      sortable: false,
    },
    {
      uniqueName: 'averageSale',
      caption: 'Average Sale',
      aggregation: 'avg',
      format: {
        type: 'currency',
        currency: 'USD',
        locale: 'en-US',
        decimals: 2,
      },
      formula: item => item.sales / item.quantity,
      sortable: true,
    },
  ],
  dimensions: [
    { field: 'product', label: 'Product', type: 'string', sortable: true },
    { field: 'region', label: 'Region', type: 'string', sortable: false },
    { field: 'date', label: 'Date', type: 'date', sortable: true },
    { field: 'sales', label: 'Sales', type: 'number', sortable: true },
    { field: 'quantity', label: 'Quantity', type: 'number', sortable: false },
  ],
  defaultAggregation: 'sum',
  isResponsive: true,
  toolbar: true,
  initialSort: [
    {
      field: 'sales',
      direction: 'desc',
      type: 'measure',
      aggregation: 'sum',
    },
  ],
  groupConfig: {
    rowFields: ['product'],
    columnFields: ['region'],
    grouper: (item, fields) => fields.map(field => item[field]).join(' - '),
  },
  formatting: {
    sales: {
      type: 'currency',
      currency: 'USD',
      locale: 'en-US',
      decimals: 2,
    },
    quantity: {
      type: 'number',
      decimals: 0,
      locale: 'en-US',
    },
    averageSale: {
      type: 'currency',
      currency: 'USD',
      locale: 'en-US',
      decimals: 2,
    },
  },
  conditionalFormatting: [
    {
      value: {
        type: 'Number',
        operator: 'Greater than',
        value1: '1000',
        value2: '',
      },
      format: {
        font: 'Arial',
        size: '14px',
        color: '#ffffff',
        backgroundColor: '#4CAF50',
      },
    },
    {
      value: {
        type: 'Number',
        operator: 'Less than',
        value1: '500',
        value2: '',
      },
      format: {
        font: 'Arial',
        size: '14px',
        color: '#ffffff',
        backgroundColor: '#F44336',
      },
    },
  ],
};


