Directory structure:
└── src/
    ├── index.d.ts
    ├── index.ts
    ├── __test__/
    │   ├── aggregator.test.ts
    │   ├── draggable.test.ts
    │   ├── exportService.test.ts
    │   ├── filterPagination.test.ts
    │   ├── grouping.test.ts
    │   ├── pivotEngine.test.ts
    │   ├── sorter.test.ts
    │   └── errors/
    │       ├── BaseError.test.ts
    │       ├── InternalError.test.ts
    │       └── ValidationError.test.ts
    ├── config/
    │   └── constants.ts
    ├── engine/
    │   ├── aggregator.ts
    │   ├── dataProcessor.ts
    │   ├── exportService.ts
    │   ├── pivotEngine.ts
    │   └── sorter.ts
    ├── errors/
    │   └── ErrorHandler.ts
    └── types/
        ├── interfaces.ts
        └── plugin.ts

================================================
FILE: index.d.ts
================================================
export * from './types/interfaces';

export declare class PivotEngine<T extends Record<string, any>> {
  constructor(config: import('./types/interfaces').PivotTableConfig<T>);
  getState(): import('./types/interfaces').PivotTableState<T>;
  sort(field: string, direction: 'asc' | 'desc'): void;
  reset(): void;
  resizeRow(index: number, height: number): void;
  setGroupConfig(
    groupConfig: import('./types/interfaces').GroupConfig | null
  ): void;
  getGroupedData(): import('./types/interfaces').Group[];
  toggleRowExpansion(rowId: string): void;
  isRowExpanded(rowId: string): boolean;
}

// Declare the applySort function
export declare function applySort<T extends Record<string, any>>(
  data: T[],
  sortConfig: import('./types/interfaces').SortConfig
): T[];



================================================
FILE: index.ts
================================================
export { PivotEngine } from './engine/pivotEngine';
export * from './types/interfaces';

// Ensure all necessary types are exported
export type {
  PivotTableConfig,
  PivotTableState,
  Column,
  SortConfig,
  GroupConfig,
  Group,
  RowSize,
  Measure,
  Dimension,
  AggregationType,
  FormatOptions,
} from './types/interfaces';



================================================
FILE: __test__/aggregator.test.ts
================================================
import { calculateAggregates } from '../engine/aggregator';
import { Config, Row, AggregationType } from '../types/interfaces';

describe('processData', () => {
  const data: Row[] = [
    { col1: 10, col2: 20, col3: 30 },
    { col1: 15, col2: 25, col3: 35 },
    { col1: 20, col2: 30, col3: 40 },
  ];

  const config: Config = {
    data: data,
    columns: [
      { field: 'col1', label: 'Column 1', type: 'number' },
      { field: 'col2', label: 'Column 2', type: 'number' },
      { field: 'col3', label: 'Column 3', type: 'number' },
      { field: 'result', label: 'Result', type: 'number' },
    ],
  };

  it('should correctly calculate the sum of the numeric columns', () => {
    const result = calculateAggregates(
      data,
      'col1' as keyof Row,
      'sum' as AggregationType
    );
    expect(result).toBe(45); // 10 + 15 + 20 = 45

    const result2 = calculateAggregates(
      data,
      'col2' as keyof Row,
      'sum' as AggregationType
    );
    expect(result2).toBe(75); // 20 + 25 + 30 = 75

    const result3 = calculateAggregates(
      data,
      'col3' as keyof Row,
      'sum' as AggregationType
    );
    expect(result3).toBe(105); // 30 + 35 + 40 = 105
  });

  it('should correctly calculate the average of the numeric columns', () => {
    const result = calculateAggregates(
      data,
      'col1' as keyof Row,
      'avg' as AggregationType
    );
    expect(result).toBe(15); // (10 + 15 + 20) / 3 = 15

    const result2 = calculateAggregates(
      data,
      'col2' as keyof Row,
      'avg' as AggregationType
    );
    expect(result2).toBe(25); // (20 + 25 + 30) / 3 = 25

    const result3 = calculateAggregates(
      data,
      'col3' as keyof Row,
      'avg' as AggregationType
    );
    expect(result3).toBe(35); // (30 + 35 + 40) / 3 = 35
  });

  it('should correctly count the numeric columns', () => {
    const result = calculateAggregates(
      data,
      'col1' as keyof Row,
      'count' as AggregationType
    );
    expect(result).toBe(3); // Three values in col1

    const result2 = calculateAggregates(
      data,
      'col2' as keyof Row,
      'count' as AggregationType
    );
    expect(result2).toBe(3); // Three values in col2

    const result3 = calculateAggregates(
      data,
      'col3' as keyof Row,
      'count' as AggregationType
    );
    expect(result3).toBe(3); // Three values in col3
  });

  it('should correctly calculate the minimum value of the numeric columns', () => {
    const result = calculateAggregates(
      data,
      'col1' as keyof Row,
      'min' as AggregationType
    );
    expect(result).toBe(10); // min of col1 values = 10

    const result2 = calculateAggregates(
      data,
      'col2' as keyof Row,
      'min' as AggregationType
    );
    expect(result2).toBe(20); // min of col2 values = 20

    const result3 = calculateAggregates(
      data,
      'col3' as keyof Row,
      'min' as AggregationType
    );
    expect(result3).toBe(30); // min of col3 values = 30
  });

  it('should correctly calculate the maximum value of the numeric columns', () => {
    const result = calculateAggregates(
      data,
      'col1' as keyof Row,
      'max' as AggregationType
    );
    expect(result).toBe(20); // max of col1 values = 20

    const result2 = calculateAggregates(
      data,
      'col2' as keyof Row,
      'max' as AggregationType
    );
    expect(result2).toBe(30); // max of col2 values = 30

    const result3 = calculateAggregates(
      data,
      'col3' as keyof Row,
      'max' as AggregationType
    );
    expect(result3).toBe(40); // max of col3 values = 40
  });

  it('should handle null and undefined values', () => {
    const dataWithNulls: Row[] = [
      { col1: 10, col2: null, col3: 30 },
      { col1: null, col2: 25, col3: undefined },
      { col1: 20, col2: undefined, col3: 40 },
    ];

    const result = calculateAggregates(
      dataWithNulls,
      'col1' as keyof Row,
      'sum' as AggregationType
    );
    expect(result).toBe(30); // 10 + 20 = 30 (null ignored)

    const result2 = calculateAggregates(
      dataWithNulls,
      'col2' as keyof Row,
      'sum' as AggregationType
    );
    expect(result2).toBe(25); // 25 (null and undefined ignored)
  });

  it('should handle empty data array', () => {
    const emptyData: Row[] = [];
    const result = calculateAggregates(
      emptyData,
      'col1' as keyof Row,
      'sum' as AggregationType
    );
    expect(result).toBe(0);
  });

  it('should return 0 for unsupported operations', () => {
    const result = calculateAggregates(
      data,
      'col1' as keyof Row,
      'unsupported' as AggregationType
    );
    expect(result).toBe(0);
  });
});



================================================
FILE: __test__/draggable.test.ts
================================================
import { PivotEngine } from '../engine/pivotEngine';
import type { PivotTableConfig } from '../types/interfaces';

describe('PivotEngine Draggable Feature', () => {
  let engine: PivotEngine<any>;
  let config: PivotTableConfig<any>;

  beforeEach(() => {
    config = {
      data: [
        { id: 1, name: 'John', age: 30 },
        { id: 2, name: 'Jane', age: 25 },
        { id: 3, name: 'Bob', age: 35 },
        { id: 4, name: 'Alice', age: 28 },
      ],
      columns: [
        { uniqueName: 'id', caption: 'ID' },
        { uniqueName: 'name', caption: 'Name' },
        { uniqueName: 'age', caption: 'Age' },
      ],
      rows: [],
      measures: [],
      dimensions: [],
      defaultAggregation: 'sum',
    };
    engine = new PivotEngine(config);

    // Manually set up row and column groups for testing this specific feature
    const rowGroups = config.data.map((item, index) => ({
      key: `row-${index}`,
      items: [item],
      aggregates: {},
      level: 0,
    }));
    engine.setRowGroups(rowGroups);

    const columnGroups = config.columns.map((column, index) => ({
      key: `col-${index}`,
      items: [column],
      aggregates: {},
      level: 0,
    }));
    engine.setColumnGroups(columnGroups);
  });

  describe('dragRow', () => {
    it('should move a row group from one index to another', () => {
      // initial order of keys: row-0, row-1, row-2, row-3
      engine.dragRow(1, 3); // move row-1 to the end
      const state = engine.getState();

      // expected order of keys: row-0, row-2, row-3, row-1
      expect(state.rowGroups.map(g => g.key)).toEqual([
        'row-0',
        'row-2',
        'row-3',
        'row-1',
      ]);

      // For more robust testing, check the content
      expect(state.rowGroups).toEqual([
        {
          key: 'row-0',
          items: [{ id: 1, name: 'John', age: 30 }],
          aggregates: {},
          level: 0,
        },
        {
          key: 'row-2',
          items: [{ id: 3, name: 'Bob', age: 35 }],
          aggregates: {},
          level: 0,
        },
        {
          key: 'row-3',
          items: [{ id: 4, name: 'Alice', age: 28 }],
          aggregates: {},
          level: 0,
        },
        {
          key: 'row-1',
          items: [{ id: 2, name: 'Jane', age: 25 }],
          aggregates: {},
          level: 0,
        },
      ]);
    });

    it('should not change row groups when dragging to the same index', () => {
      const initialRowGroups = [...engine.getState().rowGroups];
      engine.dragRow(1, 1);
      const newRowGroups = engine.getState().rowGroups;
      expect(newRowGroups).toEqual(initialRowGroups);
    });

    it('should handle invalid indices gracefully', () => {
      const initialRowGroups = [...engine.getState().rowGroups];
      engine.dragRow(-1, 5);
      const newRowGroups = engine.getState().rowGroups;
      expect(newRowGroups).toEqual(initialRowGroups);
    });
  });

  describe('dragColumn', () => {
    it('should move a column group from one index to another', () => {
      // initial order of keys: col-0, col-1, col-2
      engine.dragColumn(0, 2); // move col-0 to the end
      const state = engine.getState();

      // expected order of keys: col-1, col-2, col-0
      expect(state.columnGroups.map(g => g.key)).toEqual([
        'col-1',
        'col-2',
        'col-0',
      ]);

      expect(state.columnGroups).toEqual([
        {
          key: 'col-1',
          items: [{ uniqueName: 'name', caption: 'Name' }],
          aggregates: {},
          level: 0,
        },
        {
          key: 'col-2',
          items: [{ uniqueName: 'age', caption: 'Age' }],
          aggregates: {},
          level: 0,
        },
        {
          key: 'col-0',
          items: [{ uniqueName: 'id', caption: 'ID' }],
          aggregates: {},
          level: 0,
        },
      ]);
    });

    it('should not change column groups when dragging to the same index', () => {
      const initialColumnGroups = [...engine.getState().columnGroups];
      engine.dragColumn(1, 1);
      const newColumnGroups = engine.getState().columnGroups;
      expect(newColumnGroups).toEqual(initialColumnGroups);
    });

    it('should handle invalid indices gracefully', () => {
      const initialColumnGroups = [...engine.getState().columnGroups];
      engine.dragColumn(-1, 5);
      const newColumnGroups = engine.getState().columnGroups;
      expect(newColumnGroups).toEqual(initialColumnGroups);
    });
  });

  describe('dragRow and dragColumn interaction', () => {
    it('should maintain correct row and column group order after multiple drags', () => {
      engine.dragRow(0, 3); // move row-0 to the end -> [1, 2, 3, 0]
      engine.dragColumn(1, 0); // move col-1 to the start -> [1, 0, 2]
      const state = engine.getState();

      expect(state.rowGroups.map(g => g.key)).toEqual([
        'row-1',
        'row-2',
        'row-3',
        'row-0',
      ]);
      expect(state.columnGroups.map(g => g.key)).toEqual([
        'col-1',
        'col-0',
        'col-2',
      ]);
    });
  });

  describe('edge cases', () => {
    it('should handle dragging row to start of the list', () => {
      // initial order of keys: row-0, row-1, row-2, row-3
      engine.dragRow(3, 0); // move row-3 to the start
      const state = engine.getState();

      // expected order of keys: row-3, row-0, row-1, row-2
      expect(state.rowGroups[0].key).toBe('row-3');
      expect(state.rowGroups[0].items[0].id).toBe(4);
    });

    it('should handle dragging column group to end of the list', () => {
      // initial order of keys: col-0, col-1, col-2
      engine.dragColumn(0, 2); // move col-0 to the end
      const state = engine.getState();

      // expected order of keys: col-1, col-2, col-0
      expect(state.columnGroups[2].key).toBe('col-0');
      expect(state.columnGroups[2].items[0].uniqueName).toBe('id');
    });
  });
});



================================================
FILE: __test__/exportService.test.ts
================================================
import { describe, it, expect, vi, beforeEach, afterEach } from 'vitest';
import { PivotExportService } from '../engine/exportService';
import * as XLSX from 'xlsx';
import { jsPDF } from 'jspdf';
import { PivotTableState } from '../types/interfaces';

// Mock dependencies
vi.mock('xlsx', () => ({
  utils: {
    aoa_to_sheet: vi.fn().mockReturnValue({}),
    book_new: vi.fn().mockReturnValue({}),
    book_append_sheet: vi.fn(),
    decode_range: vi.fn().mockReturnValue({ e: { c: 5 } }),
    encode_cell: vi
      .fn()
      .mockImplementation(
        ({ r, c }) => `${String.fromCharCode(65 + c)}${r + 1}`
      ),
  },
  writeFile: vi.fn(),
}));

vi.mock('jspdf', () => ({
  jsPDF: vi.fn().mockImplementation(() => ({
    setFontSize: vi.fn(),
    text: vi.fn(),
    save: vi.fn(),
    internal: {
      pageSize: {
        getWidth: vi.fn().mockReturnValue(210),
        getHeight: vi.fn().mockReturnValue(297),
      },
    },
  })),
}));

vi.mock('jspdf-autotable', () => ({
  autoTable: vi.fn(),
}));

describe('PivotExportService', () => {
  // Mock document methods
  beforeEach(() => {
    // Mock document methods
    document.createElement = vi.fn().mockImplementation(tag => {
      if (tag === 'a') {
        return {
          href: '',
          download: '',
          click: vi.fn(),
          style: {},
        };
      }
      if (tag === 'div') {
        return {
          style: {},
          innerHTML: '',
          querySelector: vi.fn().mockReturnValue({ style: {} }),
        };
      }
      return {};
    });
    document.body.appendChild = vi.fn();
    document.body.removeChild = vi.fn();
    URL.createObjectURL = vi.fn().mockReturnValue('blob:mock-url');
    URL.revokeObjectURL = vi.fn();
    window.open = vi.fn().mockReturnValue({
      document: {
        open: vi.fn(),
        write: vi.fn(),
        close: vi.fn(),
      },
      focus: vi.fn(),
      print: vi.fn(),
    });
  });

  afterEach(() => {
    vi.clearAllMocks();
  });

  // Sample state for testing - Properly typed with all required properties
  const createMockState = (isEmpty = false): PivotTableState<any> => ({
    data: isEmpty
      ? []
      : [
          { product: 'Product A', region: 'North', sales: 100, profit: 25 },
          { product: 'Product B', region: 'North', sales: 150, profit: 40 },
          { product: 'Product A', region: 'South', sales: 200, profit: 50 },
          { product: 'Product B', region: 'South', sales: 250, profit: 60 },
        ],
    processedData: {
      headers: ['Product', 'Region'],
      rows: [],
      totals: { sales: 700, profit: 175 },
    },
    rows: [{ uniqueName: 'product', caption: 'Product' }],
    columns: [{ uniqueName: 'region', caption: 'Region' }],
    measures: [
      { uniqueName: 'sales', caption: 'Sales', aggregation: 'sum' },
      { uniqueName: 'profit', caption: 'Profit', aggregation: 'sum' },
    ],
    selectedMeasures: [
      { uniqueName: 'sales', caption: 'Sales', aggregation: 'sum' },
      { uniqueName: 'profit', caption: 'Profit', aggregation: 'sum' },
    ],
    selectedDimensions: [],
    selectedAggregation: 'sum',
    formatting: {
      sales: { type: 'number', decimals: 0, locale: 'en-US' },
      profit: {
        type: 'currency',
        currency: 'USD',
        decimals: 2,
        locale: 'en-US',
      },
    },
    groups: [
      {
        key: 'Product A - North',
        items: [],
        aggregates: { sum_sales: 100, sum_profit: 25 },
      },
      {
        key: 'Product B - North',
        items: [],
        aggregates: { sum_sales: 150, sum_profit: 40 },
      },
      {
        key: 'Product A - South',
        items: [],
        aggregates: { sum_sales: 200, sum_profit: 50 },
      },
      {
        key: 'Product B - South',
        items: [],
        aggregates: { sum_sales: 250, sum_profit: 60 },
      },
    ],
    sortConfig: [],
    rowSizes: [],
    expandedRows: {},
    groupConfig: null,
    columnWidths: {},
    isResponsive: true,
    rowGroups: [],
    columnGroups: [],
    filterConfig: [],
    paginationConfig: {
      currentPage: 1,
      totalPages: 1,
      pageSize: 10,
    },
  });

  describe('convertToHtml', () => {
    it('should convert state to HTML representation', () => {
      const state = createMockState();
      const html = PivotExportService.convertToHtml(state);

      // Verify HTML structure
      expect(html).toContain('<table class="pivot-table">');
      expect(html).toContain(
        '<th rowspan="2" class="corner-header">Product /<br>Region</th>'
      );
      expect(html).toContain('North');
      expect(html).toContain('South');
      expect(html).toContain('Sales');
      expect(html).toContain('Profit');
    });

    it('should handle empty data', () => {
      const state = createMockState(true);
      const html = PivotExportService.convertToHtml(state);
      expect(html).toContain('No data to display');
    });

    it('should include pagination information', () => {
      const state = createMockState();
      state.paginationConfig.currentPage = 2;
      state.paginationConfig.totalPages = 5;

      const html = PivotExportService.convertToHtml(state);
      expect(html).toContain('Page 2 of 5');
    });
  });

  describe('exportToHTML', () => {
    it('should create a Blob and trigger download', () => {
      const state = createMockState();
      PivotExportService.exportToHTML(state, 'test-file');

      // Check if Blob was created
      expect(URL.createObjectURL).toHaveBeenCalled();

      expect(document.createElement).toHaveBeenCalledWith('a');

      expect(document.body.appendChild).toHaveBeenCalled();
      expect(document.body.removeChild).toHaveBeenCalled();
      expect(URL.revokeObjectURL).toHaveBeenCalled();
    });
  });

  describe('exportToPDF', () => {
    it('should create a PDF and save it', () => {
      const state = createMockState();
      PivotExportService.exportToPDF(state, 'test-file');

      // Check if container was created
      expect(document.createElement).toHaveBeenCalledWith('div');
      expect(document.body.appendChild).toHaveBeenCalled();

      // Check if jsPDF was initialized
      expect(jsPDF).toHaveBeenCalled();

      // Check if PDF was saved
      const mockJsPDF = jsPDF as unknown as ReturnType<typeof vi.fn>;
      const pdfInstance = mockJsPDF.mock.results[0].value;
      expect(pdfInstance.save).toHaveBeenCalledWith('test-file.pdf');

      // Check cleanup
      expect(document.body.removeChild).toHaveBeenCalled();
    });

    it('should handle case when table element is not found', () => {
      const state = createMockState();

      // Mock querySelector to return null
      document.createElement = vi.fn().mockImplementation(() => ({
        style: {},
        innerHTML: '',
        querySelector: vi.fn().mockReturnValue(null),
      }));

      // Mock console.error
      const originalConsoleError = console.error;
      console.error = vi.fn();

      PivotExportService.exportToPDF(state);

      expect(console.error).toHaveBeenCalledWith(
        'No table found in the generated HTML'
      );
      expect(document.body.removeChild).toHaveBeenCalled();

      // Restore console.error
      console.error = originalConsoleError;
    });
  });

  describe('exportToExcel', () => {
    it('should create an Excel file and save it', () => {
      const state = createMockState();
      PivotExportService.exportToExcel(state, 'test-file');

      // Check if Excel workbook was created
      expect(XLSX.utils.book_new).toHaveBeenCalled();
      expect(XLSX.utils.aoa_to_sheet).toHaveBeenCalled();
      expect(XLSX.utils.book_append_sheet).toHaveBeenCalled();

      // Check if file was saved
      expect(XLSX.writeFile).toHaveBeenCalledWith(
        expect.anything(),
        'test-file.xlsx'
      );
    });

    it('should handle empty data', () => {
      const state = createMockState(true);
      const consoleLogSpy = vi
        .spyOn(console, 'log')
        .mockImplementation(() => {});

      PivotExportService.exportToExcel(state);

      expect(console.log).toHaveBeenCalledWith('No data to export!');
      expect(XLSX.writeFile).not.toHaveBeenCalled();

      consoleLogSpy.mockRestore();
    });

    it('should handle missing dimension configuration', () => {
      const state = createMockState();
      state.rows = [];

      const consoleLogSpy = vi
        .spyOn(console, 'log')
        .mockImplementation(() => {});

      PivotExportService.exportToExcel(state);

      expect(console.log).toHaveBeenCalledWith(
        'Missing row or column dimension'
      );
      expect(XLSX.writeFile).not.toHaveBeenCalled();

      consoleLogSpy.mockRestore();
    });

    it('should apply correct formatting to Excel cells', () => {
      const state = createMockState();

      // Add a percentage measure
      state.measures.push({
        uniqueName: 'margin',
        caption: 'Margin',
        aggregation: 'sum',
      });
      state.selectedMeasures.push({
        uniqueName: 'margin',
        caption: 'Margin',
        aggregation: 'sum',
      });
      state.formatting.margin = { type: 'percentage', decimals: 2 };

      PivotExportService.exportToExcel(state);

      // Check cell formatting was applied
      // This is a bit tricky to test without deeper mocking
      expect(XLSX.utils.aoa_to_sheet).toHaveBeenCalled();
      expect(XLSX.utils.decode_range).toHaveBeenCalled();
    });
  });

  describe('openPrintDialog', () => {
    it('should open a new window with formatted content', () => {
      const state = createMockState();
      PivotExportService.openPrintDialog(state);

      // Check if window was opened
      expect(window.open).toHaveBeenCalled();
    });

    it('should handle error if window cannot be opened', () => {
      const state = createMockState();

      // Mock window.open to return null (blocked popup)
      window.open = vi.fn().mockReturnValue(null);

      // Mock console.error
      const originalConsoleError = console.error;
      console.error = vi.fn();

      PivotExportService.openPrintDialog(state);

      expect(console.error).toHaveBeenCalledWith('Failed to open print dialog');

      // Restore console.error
      console.error = originalConsoleError;
    });
  });
});



================================================
FILE: __test__/filterPagination.test.ts
================================================
import { PivotEngine } from '../engine/pivotEngine';
import { AggregationType } from '../types/interfaces';

describe('PivotEngine Filter and Pagination', () => {
  const sampleData = [
    { id: 1, sales: 1500, region: 'North' },
    { id: 2, sales: 800, region: 'South' },
    { id: 3, sales: 2000, region: 'North' },
    // ... more test data
  ];

  const config = {
    data: sampleData,
    rows: [{ uniqueName: 'region' }],
    columns: [{ uniqueName: 'sales' }],
    measures: [{ uniqueName: 'sales', aggregation: 'sum' as AggregationType }],
    dimensions: [
      {
        field: 'region',
        label: 'Region',
        type: 'string' as const,
      },
    ],
    defaultAggregation: 'sum' as AggregationType,
  };

  let pivotEngine: PivotEngine<any>;

  beforeEach(() => {
    pivotEngine = new PivotEngine(config);
  });

  test('Filtering works correctly', () => {
    pivotEngine.applyFilters([
      {
        field: 'sales',
        operator: 'greaterThan',
        value: 1000,
      },
    ]);

    const state = pivotEngine.getState();
    expect(state.processedData.rows.length).toBe(2); // Should only show sales > 1000
  });

  test('Pagination works correctly', () => {
    pivotEngine.setPagination({
      currentPage: 1,
      pageSize: 2,
      totalPages: 2,
    });

    const state = pivotEngine.getState();
    expect(state.processedData.rows.length).toBe(2); // Should show 2 items per page
  });
});



================================================
FILE: __test__/grouping.test.ts
================================================
import { describe, it, expect } from 'vitest';
import { PivotEngine } from '../engine/pivotEngine';
import { PivotTableConfig, GroupConfig } from '../types/interfaces';

describe('PivotEngine Grouping', () => {
  const sampleData = [
    {
      date: '2024-01-01',
      product: 'Widget A',
      region: 'North',
      sales: 1000,
      quantity: 50,
    },
    {
      date: '2024-01-01',
      product: 'Widget B',
      region: 'South',
      sales: 1500,
      quantity: 75,
    },
    {
      date: '2024-01-02',
      product: 'Widget A',
      region: 'East',
      sales: 1200,
      quantity: 60,
    },
    {
      date: '2024-01-02',
      product: 'Widget C',
      region: 'West',
      sales: 800,
      quantity: 40,
    },
    {
      date: '2024-01-03',
      product: 'Widget B',
      region: 'North',
      sales: 1800,
      quantity: 90,
    },
    {
      date: '2024-01-03',
      product: 'Widget C',
      region: 'South',
      sales: 1100,
      quantity: 55,
    },
  ];

  const config: PivotTableConfig<(typeof sampleData)[0]> = {
    data: sampleData,
    rows: [{ uniqueName: 'product', caption: 'Product' }],
    columns: [{ uniqueName: 'date', caption: 'Date' }],
    measures: [
      {
        uniqueName: 'sales',
        caption: 'Total Sales',
        aggregation: 'sum',
        format: { type: 'currency', currency: 'USD' },
      },
      {
        uniqueName: 'quantity',
        caption: 'Total Quantity',
        aggregation: 'sum',
        format: { type: 'number' },
      },
      {
        uniqueName: 'averageSale',
        caption: 'Average Sale',
        aggregation: 'avg',
        format: { type: 'currency', currency: 'USD' },
      },
    ],
    dimensions: [
      { field: 'product', label: 'Product', type: 'string' },
      { field: 'region', label: 'Region', type: 'string' },
      { field: 'date', label: 'Date', type: 'date' },
      { field: 'sales', label: 'Sales', type: 'string' },
      { field: 'quantity', label: 'Quantity', type: 'string' },
    ],
    defaultAggregation: 'sum',
    isResponsive: true,
    groupConfig: {
      rowFields: ['product'],
      columnFields: ['date'],
      grouper: (item, fields) => fields.map(field => item[field]).join(' - '),
    },
  };

  it('should group data by a single row field', () => {
    const engine = new PivotEngine(config);
    const groupConfig: GroupConfig = {
      rowFields: ['region'],
      columnFields: [],
      grouper: (item, fields) => fields.map(field => item[field]).join(' - '),
    };
    engine.setGroupConfig(groupConfig);

    const groups = engine.getGroupedData();
    expect(groups).toHaveLength(4); // North, South, East, West
    expect(groups[0].key).toBe('North');
    expect(groups[0].items).toHaveLength(2);
    expect(groups[1].key).toBe('South');
    expect(groups[1].items).toHaveLength(2);
    expect(groups[2].key).toBe('East');
    expect(groups[2].items).toHaveLength(1);
    expect(groups[3].key).toBe('West');
    expect(groups[3].items).toHaveLength(1);
  });

  it('should group data by multiple row fields', () => {
    const engine = new PivotEngine(config);
    const groupConfig: GroupConfig = {
      rowFields: ['date', 'region'],
      columnFields: [],
      grouper: (item, fields) => fields.map(field => item[field]).join(' - '),
    };
    engine.setGroupConfig(groupConfig);

    const groups = engine.getGroupedData();
    expect(groups).toHaveLength(6); // 6 unique date-region combinations

    // Check first date group (2024-01-01)
    expect(groups[0]?.key).toBe('2024-01-01 - North');
    expect(groups[0]?.items).toHaveLength(1);
    expect(groups[1]?.key).toBe('2024-01-01 - South');
    expect(groups[1]?.items).toHaveLength(1);

    // Check second date group (2024-01-02)
    expect(groups[2]?.key).toBe('2024-01-02 - East');
    expect(groups[2]?.items).toHaveLength(1);
    expect(groups[3]?.key).toBe('2024-01-02 - West');
    expect(groups[3]?.items).toHaveLength(1);

    // Check third date group (2024-01-03)
    expect(groups[4]?.key).toBe('2024-01-03 - North');
    expect(groups[4]?.items).toHaveLength(1);
    expect(groups[5]?.key).toBe('2024-01-03 - South');
    expect(groups[5]?.items).toHaveLength(1);
  });

  // it('should group data by row and column fields', () => {
  //   const engine = new PivotEngine(config);
  //   const groupConfig: GroupConfig = {
  //     rowFields: ['region'],
  //     columnFields: ['date'],
  //     grouper: (item, fields) => fields.map((field) => item[field]).join(' - '),
  //   };
  //   engine.setGroupConfig(groupConfig);

  //   const groups = engine.getGroupedData();
  //   expect(groups).toHaveLength(4); // 4 regions

  //   // Check row groups
  //   expect(groups[0].key).toBe('North');
  //   expect(groups[1].key).toBe('South');
  //   expect(groups[2].key).toBe('East');
  //   expect(groups[3].key).toBe('West');

  //   // Check for subgroups (columns)
  //   groups.forEach((group) => {
  //     expect(group.subgroups).toBeDefined();
  //     expect(group.subgroups?.length).toBe(3); // 3 dates
  //     expect(group.subgroups?.[0].key).toBe('2024-01-01');
  //     expect(group.subgroups?.[1].key).toBe('2024-01-02');
  //     expect(group.subgroups?.[2].key).toBe('2024-01-03');
  //   });
  // });

  it('should return ungrouped data when group config is null', () => {
    const engine = new PivotEngine({ ...config, groupConfig: null });

    const groups = engine.getGroupedData();
    expect(groups).toHaveLength(0);
    expect(engine.getState().rawData).toEqual(sampleData);
  });

  // it('should maintain grouping after sorting', () => {
  //   const engine = new PivotEngine(config);
  //   const groupConfig: GroupConfig = {
  //     rowFields: ['region'],
  //     columnFields: [],
  //     grouper: (item, fields) => fields.map((field) => item[field]).join(' - '),
  //   };
  //   engine.setGroupConfig(groupConfig);
  //   engine.sort('sales', 'desc');

  //   const groups = engine.getGroupedData();
  //   expect(groups).toHaveLength(4);
  //   expect(groups[0].key).toBe('North');
  //   expect(groups[0].items[0].sales).toBe(1800); // Highest sales in North
  //   expect(groups[1].key).toBe('South');
  //   expect(groups[1].items[0].sales).toBe(1500); // Highest sales in South
  // });

  it('should handle empty data set', () => {
    const emptyConfig: PivotTableConfig<(typeof sampleData)[0]> = {
      ...config,
      data: [],
    };
    const engine = new PivotEngine(emptyConfig);

    const groups = engine.getGroupedData();
    expect(groups).toHaveLength(0);
  });

  it('should handle grouping by non-existent field', () => {
    const engine = new PivotEngine(config);
    const groupConfig: GroupConfig = {
      rowFields: ['nonExistentField'],
      columnFields: [],
      grouper: (item, fields) =>
        fields.map(field => item[field] || 'N/A').join(' - '),
    };
    engine.setGroupConfig(groupConfig);

    const groups = engine.getGroupedData();
    expect(groups).toHaveLength(1);
    expect(groups[0].key).toBe('N/A');
    expect(groups[0].items).toHaveLength(sampleData.length);
  });

  it('should calculate aggregates for grouped data', () => {
    const engine = new PivotEngine(config);
    const groupConfig: GroupConfig = {
      rowFields: ['region'],
      columnFields: [],
      grouper: (item, fields) => fields.map(field => item[field]).join(' - '),
    };
    engine.setGroupConfig(groupConfig);

    const groups = engine.getGroupedData();
    expect(groups).toHaveLength(4);

    groups.forEach(group => {
      expect(group).toHaveProperty('aggregates');
      expect(group.aggregates).toHaveProperty('sum_sales');
      expect(group.aggregates).toHaveProperty('sum_quantity');
    });

    // Check specific aggregate values
    expect(groups[0].aggregates.sum_sales).toBe(2800); // North: 1000 + 1800
    expect(groups[0].aggregates.sum_quantity).toBe(140); // North: 50 + 90
    expect(groups[1].aggregates.sum_sales).toBe(2600); // South: 1500 + 1100
    expect(groups[1].aggregates.sum_quantity).toBe(130); // South: 75 + 55
  });
});



================================================
FILE: __test__/pivotEngine.test.ts
================================================
import { PivotEngine } from '../engine/pivotEngine';
import { PivotTableConfig } from '../types/interfaces';
import { vi } from 'vitest';

describe('PivotEngine', () => {
  const sampleData = [
    { id: 1, name: 'John', age: 30 },
    { id: 2, name: 'Jane', age: 25 },
    { id: 3, name: 'Bob', age: 35 },
  ];

  const config: PivotTableConfig<(typeof sampleData)[0]> = {
    data: sampleData,
    rows: [],
    columns: [
      { uniqueName: 'id', caption: 'ID' },
      { uniqueName: 'name', caption: 'Name' },
      { uniqueName: 'age', caption: 'Age' },
    ],
    measures: [],
    dimensions: [],
    defaultAggregation: 'sum',
  };

  it('should initialize with correct data and default row sizes', () => {
    const engine = new PivotEngine(config);
    const state = engine.getState();
    expect(state.rawData).toEqual(sampleData);
    expect(state.rowSizes).toEqual([
      { index: 0, height: 40 },
      { index: 1, height: 40 },
      { index: 2, height: 40 },
    ]);
  });

  it('should switch data handling mode and re-process data', () => {
    const engine = new PivotEngine(config);
    engine.setDataHandlingMode('raw');
    let state = engine.getState();
    expect(state.dataHandlingMode).toBe('raw');
    expect(state.processedData.headers).toEqual(['id', 'name', 'age']);

    engine.setDataHandlingMode('processed');
    state = engine.getState();
    expect(state.dataHandlingMode).toBe('processed');
    expect(state.processedData.headers).toEqual(['ID', 'Name', 'Age']);
  });

  it('should resize a row correctly', () => {
    const engine = new PivotEngine(config);
    engine.resizeRow(1, 60);
    const state = engine.getState();
    expect(state.rowSizes[1].height).toBe(60);
  });

  it('should not allow row height to be less than 20px', () => {
    const engine = new PivotEngine(config);
    engine.resizeRow(1, 10);
    const state = engine.getState();
    expect(state.rowSizes[1].height).toBe(20);
  });

  it('should maintain row sizes after sorting', () => {
    const engine = new PivotEngine(config);
    engine.resizeRow(1, 60);
    engine.sort('age', 'asc');
    const state = engine.getState();
    expect(state.rowSizes[1].height).toBe(60);
  });

  it('should handle resizing non-existent rows gracefully', () => {
    const engine = new PivotEngine(config);
    engine.resizeRow(10, 100); // Non-existent row
    const state = engine.getState();
    expect(state.rowSizes).toEqual([
      { index: 0, height: 40 },
      { index: 1, height: 40 },
      { index: 2, height: 40 },
    ]);
  });

  it('should handle resizing with decimal values', () => {
    const engine = new PivotEngine(config);
    engine.resizeRow(1, 55.5);
    const state = engine.getState();
    expect(state.rowSizes[1].height).toBe(55.5);
  });

  // Subscription System Tests
  describe('Subscription System', () => {
    it('should notify subscribers when state changes', () => {
      const engine = new PivotEngine(config);
      const mockCallback = vi.fn();

      // Subscribe to state changes (this will call immediately with current state)
      const unsubscribe = engine.subscribe(mockCallback);

      // Clear the initial call
      mockCallback.mockClear();

      // Trigger a state change using setDataHandlingMode (now should call _emit())
      engine.setDataHandlingMode('raw');

      // Verify callback was called with the new state
      expect(mockCallback).toHaveBeenCalled();
      const callArgs = mockCallback.mock.calls[0][0];
      expect(callArgs.dataHandlingMode).toBe('raw');

      unsubscribe();
    });

    it('should notify multiple subscribers', () => {
      const engine = new PivotEngine(config);
      const mockCallback1 = vi.fn();
      const mockCallback2 = vi.fn();

      // Subscribe multiple callbacks
      const unsubscribe1 = engine.subscribe(mockCallback1);
      const unsubscribe2 = engine.subscribe(mockCallback2);

      // Clear initial calls
      mockCallback1.mockClear();
      mockCallback2.mockClear();

      // Trigger a state change using resizeRow (now should call _emit())
      engine.resizeRow(0, 50);

      // Verify both callbacks were called
      expect(mockCallback1).toHaveBeenCalled();
      expect(mockCallback2).toHaveBeenCalled();

      unsubscribe1();
      unsubscribe2();
    });

    it('should stop notifying after unsubscribe', () => {
      const engine = new PivotEngine(config);
      const mockCallback = vi.fn();

      // Subscribe and then unsubscribe
      const unsubscribe = engine.subscribe(mockCallback);
      unsubscribe();

      // Clear any initial calls
      mockCallback.mockClear();

      // Trigger a state change using a method that calls _emit()
      engine.setMeasures([
        { uniqueName: 'id', caption: 'ID', aggregation: 'count' },
      ]);

      // Verify callback was not called
      expect(mockCallback).not.toHaveBeenCalled();
    });

    it('should handle subscribers with errors gracefully', () => {
      const engine = new PivotEngine(config);
      const errorCallback = vi.fn(() => {
        throw new Error('Subscriber error');
      });

      // Try to subscribe with an error callback - this should fail on subscription
      expect(() => engine.subscribe(errorCallback)).toThrow('Subscriber error');
    });

    it('should notify subscribers with current state after subscription', () => {
      const engine = new PivotEngine(config);
      const mockCallback = vi.fn();

      // Change state first using methods that call _emit()
      engine.setMeasures([
        { uniqueName: 'age', caption: 'Age', aggregation: 'sum' },
      ]);
      engine.setAggregation('avg');

      // Subscribe after state changes (should get immediate call with current state)
      engine.subscribe(mockCallback);

      // Verify callback receives the current state immediately
      expect(mockCallback).toHaveBeenCalled();
      const callArgs = mockCallback.mock.calls[0][0];
      expect(callArgs.selectedAggregation).toBe('avg');
      expect(callArgs.selectedMeasures).toHaveLength(1);
    });

    it('should emit state changes for all modified methods', () => {
      const engine = new PivotEngine(config);
      const mockCallback = vi.fn();

      // Subscribe to state changes
      const unsubscribe = engine.subscribe(mockCallback);
      mockCallback.mockClear();

      // Test setDataHandlingMode
      engine.setDataHandlingMode('raw');
      expect(mockCallback).toHaveBeenCalled();
      mockCallback.mockClear();

      // Test resizeRow
      engine.resizeRow(0, 50);
      expect(mockCallback).toHaveBeenCalled();
      mockCallback.mockClear();

      // Test toggleRowExpansion
      engine.toggleRowExpansion('test-row');
      expect(mockCallback).toHaveBeenCalled();
      mockCallback.mockClear();

      // Test setGroupConfig
      engine.setGroupConfig(null);
      expect(mockCallback).toHaveBeenCalled();
      mockCallback.mockClear();

      // Test reset
      engine.reset();
      expect(mockCallback).toHaveBeenCalled();

      unsubscribe();
    });
  });

  // Swapable and Unique Row Value Logic Tests
  describe('Swapable and Unique Row Value Logic', () => {
    const swapableData = [
      { category: 'A', subcategory: 'X', value: 10 },
      { category: 'A', subcategory: 'Y', value: 20 },
      { category: 'B', subcategory: 'X', value: 30 },
      { category: 'B', subcategory: 'Y', value: 40 },
      { category: 'A', subcategory: 'X', value: 15 }, // Duplicate combination
    ];

    const swapableConfig: PivotTableConfig<(typeof swapableData)[0]> = {
      data: swapableData,
      rawData: swapableData,
      rows: [
        { uniqueName: 'category', caption: 'Category' },
        { uniqueName: 'subcategory', caption: 'Subcategory' },
      ],
      columns: [],
      measures: [
        { uniqueName: 'value', caption: 'Sum of Value', aggregation: 'sum' },
      ],
      dimensions: [],
      defaultAggregation: 'sum',
    };

    it('should maintain unique row values after column swaps', () => {
      const engine = new PivotEngine(swapableConfig);
      const initialState = engine.getState();

      // Get initial processed data rows
      const initialRowValues = initialState.processedData.rows;
      const initialUniqueCategories = [
        ...new Set(initialRowValues.map(row => row[0])),
      ];
      const initialUniqueSubcategories = [
        ...new Set(initialRowValues.map(row => row[1])),
      ];

      // Verify unique values are correctly identified
      expect(initialUniqueCategories).toEqual(['A', 'B']);
      expect(initialUniqueSubcategories).toEqual(['X', 'Y']);

      // The engine processes each row individually, so we should see all rows
      // including duplicates until aggregation is applied
      expect(initialRowValues.length).toBeGreaterThan(0);

      // Check that the data contains the expected combinations
      const aCombinations = initialRowValues.filter(row => row[0] === 'A');
      const bCombinations = initialRowValues.filter(row => row[0] === 'B');

      expect(aCombinations.length).toBeGreaterThan(0);
      expect(bCombinations.length).toBeGreaterThan(0);
    });

    it('should handle row ordering with custom sort in processed mode', () => {
      const engine = new PivotEngine(swapableConfig);

      // Ensure we're in processed mode for this test
      engine.setDataHandlingMode('processed');

      // Sort by category descending
      engine.sort('category', 'desc');
      const sortedState = engine.getState();

      // Verify row order changed but unique values preserved
      const sortedRows = sortedState.processedData.rows;

      // In processed mode with grouping, we should have aggregated rows
      // First row should be the B category group (descending order)
      expect(sortedRows[0][0]).toBe('B');

      // Unique categories should still be preserved
      const uniqueCategories = [...new Set(sortedRows.map(row => row[0]))];
      expect(uniqueCategories.sort()).toEqual(['A', 'B']);

      // Test ascending sort as well
      engine.sort('category', 'asc');
      const ascSortedState = engine.getState();
      const ascSortedRows = ascSortedState.processedData.rows;
      expect(ascSortedRows[0][0]).toBe('A');
    });

    it('should maintain data integrity with mixed data types', () => {
      const mixedData = [
        { id: 1, name: 'Alpha', score: 85.5, active: true },
        { id: 2, name: 'Beta', score: 92.0, active: false },
        { id: 3, name: 'Alpha', score: 78.3, active: true }, // Duplicate name
        { id: 4, name: null, score: 0, active: false }, // Null value
      ];

      const mixedConfig: PivotTableConfig<(typeof mixedData)[0]> = {
        data: mixedData,
        rawData: mixedData,
        rows: [
          { uniqueName: 'name', caption: 'Name' },
          { uniqueName: 'active', caption: 'Active' },
        ],
        columns: [],
        measures: [
          { uniqueName: 'score', caption: 'Avg Score', aggregation: 'avg' },
        ],
        dimensions: [],
        defaultAggregation: 'avg',
      };

      const engine = new PivotEngine(mixedConfig);
      const state = engine.getState();
      const rows = state.processedData.rows;

      // Verify null values are handled
      const nullNameRows = rows.filter(row => row[0] === null);
      expect(nullNameRows).toHaveLength(1);

      // Verify boolean values are handled
      const activeRows = rows.filter(row => row[1] === true);
      const inactiveRows = rows.filter(row => row[1] === false);
      expect(activeRows.length).toBeGreaterThan(0);
      expect(inactiveRows.length).toBeGreaterThan(0);

      // Verify duplicate names are aggregated correctly
      const alphaRows = rows.filter(row => row[0] === 'Alpha');
      expect(alphaRows.length).toBeGreaterThanOrEqual(1); // Should be aggregated
    });

    it('should handle empty or single-row datasets', () => {
      // Test with empty data
      interface EmptyTestData {
        test?: string;
      }

      const emptyConfig: PivotTableConfig<EmptyTestData> = {
        data: [],
        rawData: [],
        rows: [{ uniqueName: 'test', caption: 'Test' }],
        columns: [],
        measures: [],
        dimensions: [],
        defaultAggregation: 'sum',
      };

      const emptyEngine = new PivotEngine(emptyConfig);
      const emptyState = emptyEngine.getState();
      expect(emptyState.processedData.rows).toEqual([]);

      // Test with single row
      interface SingleTestData {
        test: string;
        value: number;
      }

      const singleRowData: SingleTestData[] = [{ test: 'single', value: 42 }];
      const singleRowConfig: PivotTableConfig<SingleTestData> = {
        data: singleRowData,
        rawData: singleRowData,
        rows: [{ uniqueName: 'test', caption: 'Test' }],
        columns: [],
        measures: [
          { uniqueName: 'value', caption: 'Value', aggregation: 'sum' },
        ],
        dimensions: [],
        defaultAggregation: 'sum',
      };

      const singleEngine = new PivotEngine(singleRowConfig);
      const singleState = singleEngine.getState();
      expect(singleState.processedData.rows).toHaveLength(1);
      expect(singleState.processedData.rows[0]).toEqual(['single', 42]);
    });

    it('should preserve row order customizations through data updates', () => {
      const engine = new PivotEngine(swapableConfig);

      // Get initial state
      const initialState = engine.getState();
      const initialRowOrder = initialState.processedData.rows.map(row =>
        row.join('-')
      );

      // Trigger data re-processing
      engine.setDataHandlingMode('raw');
      engine.setDataHandlingMode('processed');

      // Verify row order is preserved through processing
      const reprocessedState = engine.getState();
      const reprocessedRowOrder = reprocessedState.processedData.rows.map(row =>
        row.join('-')
      );

      // Order should be consistent after reprocessing
      expect(reprocessedRowOrder).toEqual(initialRowOrder);
    });

    it('should support swapping data rows with swapDataRows method', () => {
      const engine = new PivotEngine(swapableConfig);

      // Get initial row field values
      const rowFieldName = engine.getRowFieldName();
      expect(rowFieldName).toBe('category');

      // Get unique values for the row field
      const uniqueRowValues = engine.getUniqueFieldValues('category');
      expect(uniqueRowValues).toEqual(['A', 'B']);

      // Get initial state to compare
      const initialRows = engine.getState().processedData.rows;
      const initialFirstCategory = initialRows[0][0];

      // Swap first and second category positions (A and B)
      engine.swapDataRows(0, 1);

      const swappedState = engine.getState();
      const swappedRows = swappedState.processedData.rows;

      // Check that the data was actually swapped
      // The category that was in position 1 should now be in position 0
      const swappedFirstCategory = swappedRows[0][0];

      // They should be different after the swap
      expect(swappedFirstCategory).not.toBe(initialFirstCategory);

      // Verify the swap worked by checking the first category is now what used to be second
      if (initialFirstCategory === 'A') {
        expect(swappedFirstCategory).toBe('B');
      } else {
        expect(swappedFirstCategory).toBe('A');
      }
    });

    it('should support swapping data columns with swapDataColumns method', () => {
      // Create config with columns
      const columnSwapData = [
        { product: 'Widget', region: 'North', sales: 100 },
        { product: 'Widget', region: 'South', sales: 150 },
        { product: 'Gadget', region: 'North', sales: 200 },
        { product: 'Gadget', region: 'South', sales: 250 },
      ];

      const columnSwapConfig: PivotTableConfig<(typeof columnSwapData)[0]> = {
        data: columnSwapData,
        rawData: columnSwapData,
        rows: [{ uniqueName: 'product', caption: 'Product' }],
        columns: [{ uniqueName: 'region', caption: 'Region' }],
        measures: [
          { uniqueName: 'sales', caption: 'Sales', aggregation: 'sum' },
        ],
        dimensions: [],
        defaultAggregation: 'sum',
      };

      const engine = new PivotEngine(columnSwapConfig);

      // Get initial column field values
      const columnFieldName = engine.getColumnFieldName();
      expect(columnFieldName).toBe('region');

      // Get unique values for the column field
      const uniqueColumnValues = engine.getUniqueFieldValues('region');
      expect(uniqueColumnValues).toEqual(['North', 'South']);

      // Test swapping columns (this should update internal column order)
      engine.swapDataColumns(0, 1);

      // Verify the swap operation completed without error
      const swappedState = engine.getState();
      expect(swappedState).toBeDefined();

      // Check if custom column order was set
      const customColumnOrder = engine.getOrderedColumnValues();
      if (customColumnOrder) {
        expect(customColumnOrder).toEqual(['South', 'North']);
      }
    });

    it('should handle edge cases in swapping operations', () => {
      const engine = new PivotEngine(swapableConfig);

      // Test swapping same indices (should be no-op)
      expect(() => engine.swapDataRows(0, 0)).not.toThrow();

      // Test swapping invalid indices
      expect(() => engine.swapDataRows(-1, 0)).not.toThrow();
      expect(() => engine.swapDataRows(0, 10)).not.toThrow();

      // Test with no row field configured
      interface NoRowData {
        category?: string;
        subcategory?: string;
        value?: number;
      }

      const noRowConfig: PivotTableConfig<NoRowData> = {
        data: swapableData,
        rawData: swapableData,
        rows: [], // No row fields
        columns: [],
        measures: [],
        dimensions: [],
        defaultAggregation: 'sum',
      };

      const noRowEngine = new PivotEngine(noRowConfig);
      expect(() => noRowEngine.swapDataRows(0, 1)).not.toThrow();
    });

    it('should handle large datasets efficiently', () => {
      // Generate a larger dataset for performance testing
      const largeData = Array.from({ length: 1000 }, (_, i) => ({
        group: `Group${i % 10}`,
        category: `Cat${i % 5}`,
        value: Math.random() * 100,
        index: i,
      }));

      const largeConfig: PivotTableConfig<(typeof largeData)[0]> = {
        data: largeData,
        rawData: largeData,
        rows: [
          { uniqueName: 'group', caption: 'Group' },
          { uniqueName: 'category', caption: 'Category' },
        ],
        columns: [],
        measures: [
          { uniqueName: 'value', caption: 'Sum of Value', aggregation: 'sum' },
        ],
        dimensions: [],
        defaultAggregation: 'sum',
      };

      const startTime = performance.now();
      const engine = new PivotEngine(largeConfig);
      const state = engine.getState();
      const endTime = performance.now();

      // Should process within reasonable time (less than 1 second)
      expect(endTime - startTime).toBeLessThan(1000);

      // Should produce correct number of rows (each row from original data is processed)
      // In a simple configuration without aggregation, we expect all 1000 rows
      expect(state.processedData.rows.length).toBe(1000);

      // Verify unique combinations exist
      const uniqueCombinations = new Set(
        state.processedData.rows.map(row => `${row[0]}-${row[1]}`)
      );
      // With 10 groups and 5 categories, we should see 10 different unique combinations
      expect(uniqueCombinations.size).toBeLessThanOrEqual(50); // At most 50, but could be fewer
    });
  });

  // Filtering Tests for Processed Data
  describe('Filtering on Aggregated Values in Processed Mode', () => {
    const filterTestData = [
      { country: 'USA', product: 'A', price: 100, discount: 10 },
      { country: 'USA', product: 'B', price: 200, discount: 20 },
      { country: 'Canada', product: 'A', price: 150, discount: 15 },
      { country: 'Canada', product: 'B', price: 250, discount: 25 },
      { country: 'Mexico', product: 'A', price: 80, discount: 8 },
      { country: 'Mexico', product: 'B', price: 120, discount: 12 },
    ];

    const filterTestConfig: PivotTableConfig<(typeof filterTestData)[0]> = {
      data: filterTestData,
      rawData: filterTestData,
      rows: [{ uniqueName: 'country', caption: 'Country' }],
      columns: [],
      measures: [
        { uniqueName: 'price', caption: 'Sum of Price', aggregation: 'sum' },
        {
          uniqueName: 'discount',
          caption: 'Sum of Discount',
          aggregation: 'sum',
        },
      ],
      dimensions: [],
      defaultAggregation: 'sum',
    };

    it('should filter on aggregated price values in processed mode', () => {
      const engine = new PivotEngine(filterTestConfig);
      engine.setDataHandlingMode('processed');

      // Set the default aggregation to sum to match our measures
      engine.setAggregation('sum');

      // Set up grouping by country to enable aggregation
      engine.setGroupConfig({
        rowFields: ['country'],
        columnFields: [],
        grouper: (item: (typeof filterTestData)[0], fields: string[]) => {
          return fields
            .map(field => item[field as keyof typeof item])
            .join('-');
        },
      });

      // Filter for countries with sum of price greater than 250
      // USA: 300 (100+200), Canada: 400 (150+250), Mexico: 200 (80+120)
      // Should include USA and Canada, exclude Mexico
      engine.applyFilters([
        {
          field: 'sum_price',
          operator: 'greaterThan',
          value: 250,
        },
      ]);

      const state = engine.getState();
      const processedRows = state.processedData.rows;

      // Should have 4 rows (2 from USA + 2 from Canada) after filtering out Mexico
      expect(processedRows.length).toBe(4);

      // Verify the countries are correct (should only have USA and Canada rows)
      const countries = processedRows.map(row => row[0]);
      expect(countries).toContain('USA');
      expect(countries).toContain('Canada');
      expect(countries).not.toContain('Mexico');

      // Verify we have 2 USA rows and 2 Canada rows
      const usaRows = processedRows.filter(row => row[0] === 'USA');
      const canadaRows = processedRows.filter(row => row[0] === 'Canada');
      expect(usaRows.length).toBe(2);
      expect(canadaRows.length).toBe(2);
    });

    it('should filter on aggregated discount values in processed mode', () => {
      const engine = new PivotEngine(filterTestConfig);
      engine.setDataHandlingMode('processed');

      // Set the default aggregation to sum to match our measures
      engine.setAggregation('sum');

      // Set up grouping by country to enable aggregation
      engine.setGroupConfig({
        rowFields: ['country'],
        columnFields: [],
        grouper: (item: (typeof filterTestData)[0], fields: string[]) => {
          return fields
            .map(field => item[field as keyof typeof item])
            .join('-');
        },
      });

      // Filter for countries with sum of discount less than 25
      // USA: 30 (10+20), Canada: 40 (15+25), Mexico: 20 (8+12)
      // Should include only Mexico
      engine.applyFilters([
        {
          field: 'sum_discount',
          operator: 'lessThan',
          value: 25,
        },
      ]);

      const state = engine.getState();
      const processedRows = state.processedData.rows;

      // Should have 2 rows (only Mexico's 2 items)
      expect(processedRows.length).toBe(2);
      expect(processedRows[0][0]).toBe('Mexico');
      expect(processedRows[1][0]).toBe('Mexico');
    });

    it('should handle multiple aggregated filters in processed mode', () => {
      const engine = new PivotEngine(filterTestConfig);
      engine.setDataHandlingMode('processed');

      // Set the default aggregation to sum to match our measures
      engine.setAggregation('sum');

      // Set up grouping by country to enable aggregation
      engine.setGroupConfig({
        rowFields: ['country'],
        columnFields: [],
        grouper: (item: (typeof filterTestData)[0], fields: string[]) => {
          return fields
            .map(field => item[field as keyof typeof item])
            .join('-');
        },
      });

      // Filter for countries with sum of price greater than 250 AND sum of discount greater than 25
      // USA: price=300, discount=30 (matches both)
      // Canada: price=400, discount=40 (matches both)
      // Mexico: price=200, discount=20 (matches neither)
      engine.applyFilters([
        {
          field: 'sum_price',
          operator: 'greaterThan',
          value: 250,
        },
        {
          field: 'sum_discount',
          operator: 'greaterThan',
          value: 25,
        },
      ]);

      const state = engine.getState();
      const processedRows = state.processedData.rows;

      // Should have 4 rows (2 from USA + 2 from Canada)
      expect(processedRows.length).toBe(4);

      const countries = processedRows.map(row => row[0]);
      expect(countries).toContain('USA');
      expect(countries).toContain('Canada');
      expect(countries).not.toContain('Mexico');

      // Verify we have 2 USA rows and 2 Canada rows
      const usaRows = processedRows.filter(row => row[0] === 'USA');
      const canadaRows = processedRows.filter(row => row[0] === 'Canada');
      expect(usaRows.length).toBe(2);
      expect(canadaRows.length).toBe(2);
    });

    it('should handle mixed regular and aggregated filters in processed mode', () => {
      const engine = new PivotEngine(filterTestConfig);
      engine.setDataHandlingMode('processed');

      // Set the default aggregation to sum to match our measures
      engine.setAggregation('sum');

      // Set up grouping by country to enable aggregation
      engine.setGroupConfig({
        rowFields: ['country'],
        columnFields: [],
        grouper: (item: (typeof filterTestData)[0], fields: string[]) => {
          return fields
            .map(field => item[field as keyof typeof item])
            .join('-');
        },
      });

      // Filter for countries containing "a" AND with sum of price greater than 250
      // USA: contains "a" (in USA), price=300 (matches both)
      // Canada: contains "a" (in Canada), price=400 (matches both)
      // Mexico: doesn't contain "a", price=200 (matches neither)
      engine.applyFilters([
        {
          field: 'country',
          operator: 'contains',
          value: 'a',
        },
        {
          field: 'sum_price',
          operator: 'greaterThan',
          value: 250,
        },
      ]);

      const state = engine.getState();
      const processedRows = state.processedData.rows;

      // Should have 4 rows (2 from USA + 2 from Canada)
      expect(processedRows.length).toBe(4);

      const countries = processedRows.map(row => row[0]);
      expect(countries).toContain('USA');
      expect(countries).toContain('Canada');
      expect(countries).not.toContain('Mexico');
    });

    it('should return empty results when no aggregated values match filter', () => {
      const engine = new PivotEngine(filterTestConfig);
      engine.setDataHandlingMode('processed');

      // Set the default aggregation to sum to match our measures
      engine.setAggregation('sum');

      // Set up grouping by country to enable aggregation
      engine.setGroupConfig({
        rowFields: ['country'],
        columnFields: [],
        grouper: (item: (typeof filterTestData)[0], fields: string[]) => {
          return fields
            .map(field => item[field as keyof typeof item])
            .join('-');
        },
      });

      // Filter for countries with sum of price greater than 1000 (none match)
      engine.applyFilters([
        {
          field: 'sum_price',
          operator: 'greaterThan',
          value: 1000,
        },
      ]);

      const state = engine.getState();
      const processedRows = state.processedData.rows;

      // Should have no results
      expect(processedRows.length).toBe(0);
    });

    it('should maintain correct sorting after applying aggregated filters', () => {
      const engine = new PivotEngine(filterTestConfig);
      engine.setDataHandlingMode('processed');

      // Set the default aggregation to sum to match our measures
      engine.setAggregation('sum');

      // Set up grouping by country to enable aggregation
      engine.setGroupConfig({
        rowFields: ['country'],
        columnFields: [],
        grouper: (item: (typeof filterTestData)[0], fields: string[]) => {
          return fields
            .map(field => item[field as keyof typeof item])
            .join('-');
        },
      });

      // Sort by country descending
      engine.sort('country', 'desc');

      // Filter for countries with sum of price greater than 250
      engine.applyFilters([
        {
          field: 'sum_price',
          operator: 'greaterThan',
          value: 250,
        },
      ]);

      const state = engine.getState();
      const processedRows = state.processedData.rows;

      // Should have 4 rows (2 from USA + 2 from Canada), sorted in descending order
      expect(processedRows.length).toBe(4);

      // Since we sorted by country descending, USA should come before Canada
      expect(processedRows[0][0]).toBe('USA');
      expect(processedRows[1][0]).toBe('USA');
      expect(processedRows[2][0]).toBe('Canada');
      expect(processedRows[3][0]).toBe('Canada');
    });
  });
});



================================================
FILE: __test__/sorter.test.ts
================================================
import { applySort } from '../engine/sorter';
import { SortConfig } from '../types/interfaces';

describe('applySort', () => {
  const testData = [
    { id: 1, name: 'John', age: 30 },
    { id: 2, name: 'Alice', age: 25 },
    { id: 3, name: 'Bob', age: 35 },
  ];

  it('should sort data in ascending order', () => {
    const sortConfig: SortConfig = { field: 'age', direction: 'asc' };
    const sortedData = applySort(testData, [sortConfig]);
    expect(sortedData).toEqual([
      { id: 2, name: 'Alice', age: 25 },
      { id: 1, name: 'John', age: 30 },
      { id: 3, name: 'Bob', age: 35 },
    ]);
  });

  it('should sort data in descending order', () => {
    const sortConfig: SortConfig = { field: 'age', direction: 'desc' };
    const sortedData = applySort(testData, [sortConfig]);
    expect(sortedData).toEqual([
      { id: 3, name: 'Bob', age: 35 },
      { id: 1, name: 'John', age: 30 },
      { id: 2, name: 'Alice', age: 25 },
    ]);
  });

  it('should sort data by string field', () => {
    const sortConfig: SortConfig = { field: 'name', direction: 'asc' };
    const sortedData = applySort(testData, [sortConfig]);
    expect(sortedData).toEqual([
      { id: 2, name: 'Alice', age: 25 },
      { id: 3, name: 'Bob', age: 35 },
      { id: 1, name: 'John', age: 30 },
    ]);
  });

  it('should return original data if sort field does not exist', () => {
    const sortConfig: SortConfig = { field: 'invalidField', direction: 'asc' };
    const sortedData = applySort(testData, [sortConfig]);
    expect(sortedData).toEqual(testData);
  });
});



================================================
FILE: __test__/errors/BaseError.test.ts
================================================
import { BaseError } from '../../errors/ErrorHandler';

describe('BaseError', () => {
  it('should create a BaseError with correct properties', () => {
    const error = new BaseError('Test error', 'TEST_ERROR', 400, {
      detail: 'Some metadata',
    });

    expect(error.message).toBe('Test error');
    expect(error.code).toBe('TEST_ERROR');
    expect(error.statusCode).toBe(400);
    expect(error.metadata).toEqual({ detail: 'Some metadata' });
  });

  it('should capture stack trace', () => {
    const error = new BaseError('Stack trace test', 'STACK_TEST', 500);

    expect(error.stack).toContain('BaseError');
  });
});



================================================
FILE: __test__/errors/InternalError.test.ts
================================================
import { InternalError } from '../../errors/ErrorHandler';

describe('InternalError', () => {
  it('should create an InternalError with default code and statusCode', () => {
    const error = new InternalError('Internal server error');

    expect(error.message).toBe('Internal server error');
    expect(error.code).toBe('INTERNAL_ERROR');
    expect(error.statusCode).toBe(500);
  });

  it('should allow custom code and metadata', () => {
    const error = new InternalError(
      'Custom internal error',
      'CUSTOM_INTERNAL',
      { service: 'auth' }
    );

    expect(error.code).toBe('CUSTOM_INTERNAL');
    expect(error.metadata).toEqual({ service: 'auth' });
  });
});



================================================
FILE: __test__/errors/ValidationError.test.ts
================================================
import { ValidationError } from '../../errors/ErrorHandler';

describe('ValidationError', () => {
  it('should create a ValidationError with default code and statusCode', () => {
    const error = new ValidationError('Validation failed');

    expect(error.message).toBe('Validation failed');
    expect(error.code).toBe('VALIDATION_ERROR');
    expect(error.statusCode).toBe(400);
  });

  it('should allow custom code and metadata', () => {
    const error = new ValidationError(
      'Custom validation error',
      'CUSTOM_CODE',
      { field: 'email' }
    );

    expect(error.code).toBe('CUSTOM_CODE');
    expect(error.metadata).toEqual({ field: 'email' });
  });
});



================================================
FILE: config/constants.ts
================================================
export const ERROR_MESSAGES = {
  INVALID_PIVOT_DATA: 'Invalid pivot data provided',
  CHART_RENDERER_ERROR: 'Chart rendering failed',
  INVALID_CONTAINER: 'A valid container is required to render the chart',
};

export const ERROR_CODES = {
  INVALID_PIVOT_DATA: '1001',
  CHART_RENDER_ERROR: '1002',
  INVALID_CONTAINER: '1003',
};



================================================
FILE: engine/aggregator.ts
================================================
import type { AggregationType } from '../types/interfaces';

export function calculateAggregates<T>(
  items: T[],
  field: keyof T,
  type: AggregationType
): number {
  if (!items || items.length === 0) return 0;

  const values = items.map(item => Number(item[field]) || 0);

  switch (type) {
    case 'sum':
      return values.reduce((sum, val) => sum + val, 0);
    case 'avg':
      return values.reduce((sum, val) => sum + val, 0) / values.length;
    case 'min':
      return Math.min(...values);
    case 'max':
      return Math.max(...values);
    case 'count':
      return values.length;
    default:
      return 0;
  }
}



================================================
FILE: engine/dataProcessor.ts
================================================
import {
  GroupConfig,
  PivotTableConfig,
  SortConfig,
  Group,
  ProcessedDataResult,
} from '../types/interfaces';
import { applySort } from './sorter';

export function processData<T extends Record<string, any>>(
  config: PivotTableConfig<T>,
  sortConfig: SortConfig | null = null,
  groupConfig: GroupConfig | null = null
): ProcessedDataResult<T> {
  let processedData = [...(config.data || [])];
  if (sortConfig) {
    processedData = applySort(processedData, [sortConfig]);
  }

  let groups: Group[] = [];

  if (groupConfig) {
    const { rowFields, columnFields, grouper } = groupConfig;
    const fields = [...rowFields, ...columnFields];
    groups = createGroups(processedData, fields, grouper);
  }

  return { rawData: processedData, groups };
}

function createGroups<T extends Record<string, any>>(
  data: T[],
  fields: string[],
  grouper: (item: T, fields: string[]) => string
): Group[] {
  if (!fields || fields.length === 0) {
    return [{ key: 'All', items: data, subgroups: [], aggregates: {} }];
  }

  const groups: { [key: string]: Group } = {};

  data.forEach(item => {
    const key = grouper(item, fields);
    if (!groups[key]) {
      groups[key] = { key, items: [], subgroups: [], aggregates: {} };
    }
    groups[key].items.push(item);
  });

  if (fields.length > 1) {
    Object.values(groups).forEach(group => {
      group.subgroups = createGroups(group.items, fields.slice(1), grouper);
    });
  }

  return Object.values(groups);
}



================================================
FILE: engine/exportService.ts
================================================
/* eslint-disable @typescript-eslint/no-explicit-any */
import * as XLSX from 'xlsx';
import { jsPDF } from 'jspdf';
import { autoTable } from 'jspdf-autotable';
import { PivotTableState } from '../types/interfaces';

/**
 * Service class for handling export operations for the PivotEngine
 */
export class PivotExportService {
  /**
   * Converts the pivot table data to HTML
   * @param {PivotTableState<T>} state - The current state of the pivot table
   * @returns {string} HTML string representation of the pivot table
   */
  public static convertToHtml<T extends Record<string, any>>(
    state: PivotTableState<T>
  ): string {
    const { rows, columns, selectedMeasures, formatting, groups, data } = state;

    if (data.length === 0) {
      return '<div>No data to display</div>';
    }

    if (!rows.length || !columns.length) {
      return '<div>No data to display</div>';
    }

    // Get unique column values
    const uniqueColumns = [
      ...new Set(
        data.map((item: { [x: string]: any }) => item[columns[0].uniqueName])
      ),
    ];

    // Get unique row values
    const uniqueRows = [
      ...new Set(
        data.map((item: { [x: string]: any }) => item[rows[0].uniqueName])
      ),
    ];

    const formatValue = (value: any, formatConfig: any): string => {
      if (value === 0) return '$0.00';
      if (!value && value !== 0) return '';

      if (formatConfig.type === 'currency') {
        return new Intl.NumberFormat(formatConfig.locale, {
          style: 'currency',
          currency: formatConfig.currency,
          minimumFractionDigits: formatConfig.decimals,
          maximumFractionDigits: formatConfig.decimals,
        }).format(value);
      } else if (formatConfig.type === 'number') {
        return new Intl.NumberFormat(formatConfig.locale, {
          minimumFractionDigits: formatConfig.decimals,
          maximumFractionDigits: formatConfig.decimals,
        }).format(value);
      }

      return String(value);
    };

    // Determine cell background based on conditional formatting (placeholder function)
    const getCellStyle = (value: any, measureName: string): string => {
      return '';
    };

    // Create HTML string
    let html = `
  <div class="pivot-export">
    <style>
      .pivot-table {
        border-collapse: collapse;
        width: 100%;
        font-family: Arial, sans-serif;
      }
      .pivot-table th, .pivot-table td {
        border: 1px solid #ddd;
        padding: 8px;
        text-align: right;
      }
      .pivot-table th {
        background-color: #f2f2f2;
        font-weight: bold;
        text-align: center;
        position: relative;
      }
      .pivot-table .sort-icon::after {
        content: "↕";
        position: absolute;
        right: 4px;
        opacity: 0.5;
      }
      .pivot-table th.region-header {
        border-bottom: none;
      }
      .pivot-table th.measure-header {
        border-top: none;
      }
      .pivot-table .row-header {
        text-align: left;
        font-weight: bold;
        background-color: #f9f9f9;
      }
      .pivot-table .corner-header {
        background-color: #f2f2f2;
        border-bottom: 1px solid #ddd;
      }
      .pagination {
        margin-top: 15px;
        font-family: Arial, sans-serif;
      }
      .export-info {
        margin-top: 15px;
        font-size: 0.8em;
        color: #666;
        font-family: Arial, sans-serif;
      }
    </style>
    
    <table class="pivot-table">
      <thead>
        <tr>
          <th rowspan="2" class="corner-header">${
            rows[0]?.caption || rows[0]?.uniqueName || ''
          } /<br>Region</th>`;

    // Add region headers
    uniqueColumns.forEach(column => {
      html += `<th colspan="${selectedMeasures.length}" class="region-header">${column}</th>`;
    });

    html += `
        </tr>
        <tr>`;

    // Add measure headers under each region
    uniqueColumns.forEach(column => {
      selectedMeasures.forEach(measure => {
        html += `<th class="measure-header sort-icon">${
          measure.caption || measure.uniqueName
        }</th>`;
      });
    });

    html += `
        </tr>
      </thead>
      <tbody>`;

    // Add data rows
    uniqueRows.forEach(row => {
      html += `<tr>
      <td class="row-header">${row}</td>`;

      // Add cells for each column (region)
      uniqueColumns.forEach(column => {
        // Find the group that matches this row and column
        const group = groups.find(g => g.key === `${row} - ${column}`);

        selectedMeasures.forEach(measure => {
          const measureKey = `sum_${measure.uniqueName}`;
          let value = group ? group.aggregates[measureKey] : 0;

          // Apply conditional formatting
          const cellStyle = getCellStyle(value, measure.uniqueName);

          // Format value according to measure settings
          const formattedValue = formatValue(
            value,
            formatting[measure.uniqueName]
          );

          html += `<td${cellStyle}>${formattedValue}</td>`;
        });
      });

      html += `</tr>`;
    });

    html += `
      </tbody>
    </table>
    
    <div class="pagination">
      Page ${state.paginationConfig?.currentPage || 1} of ${
        state.paginationConfig?.totalPages || 1
      }
    </div>
    
    <div class="export-info">
      <p>Generated: ${new Date().toLocaleString()}</p>
    </div>
  </div>`;

    return html;
  }

  /**
   * Exports the pivot table data to HTML and downloads the file
   * @param {PivotTableState<T>} state - The current state of the pivot table
   * @param {string} fileName - The name of the downloaded file (without extension)
   */
  public static exportToHTML<T extends Record<string, any>>(
    state: PivotTableState<T>,
    fileName = 'pivot-table'
  ): void {
    const htmlContent = PivotExportService.convertToHtml(state);

    const blob = new Blob([htmlContent], { type: 'text/html' });
    const url = URL.createObjectURL(blob);

    const a = document.createElement('a');
    a.href = url;
    a.download = `${fileName}.html`;
    document.body.appendChild(a);
    a.click();

    document.body.removeChild(a);
    URL.revokeObjectURL(url);
  }

  /**
   * Exports the pivot table data to PDF and downloads the file
   * @param {PivotTableState<T>} state - The current state of the pivot table
   * @param {string} fileName - The name of the downloaded file (without extension)
   */
  public static exportToPDF<T extends Record<string, any>>(
    state: PivotTableState<T>,
    fileName = 'pivot-table'
  ): void {
    // Convert pivot data to an HTML table
    const htmlContent = PivotExportService.convertToHtml(state);

    // Create a temporary container for the HTML
    const container = document.createElement('div');
    container.style.position = 'absolute';
    container.style.left = '-9999px'; // Hide off-screen
    container.innerHTML = htmlContent;
    document.body.appendChild(container);

    // Extract the table from the container
    const tableElement = container.querySelector('table');

    if (!tableElement) {
      console.error('No table found in the generated HTML');
      document.body.removeChild(container);
      return;
    }

    try {
      // Create a new PDF document
      const pdf = new jsPDF();

      // Add title
      pdf.setFontSize(16);
      pdf.text(fileName, pdf.internal.pageSize.getWidth() / 2, 15, {
        align: 'center',
      });

      // Use autoTable to convert the HTML table to PDF
      autoTable(pdf, {
        html: tableElement,
        startY: 25,
        styles: {
          fontSize: 10,
          cellPadding: 3,
          overflow: 'linebreak',
        },
        headStyles: {
          fillColor: [66, 139, 202],
          textColor: 255,
          fontStyle: 'bold',
        },
        columnStyles: {},
        margin: { top: 25, right: 15, bottom: 25, left: 15 },
        didDrawPage: (data: { pageNumber: number }) => {
          pdf.setFontSize(10);
          pdf.text(
            `Page ${data.pageNumber}`,
            pdf.internal.pageSize.getWidth() - 20,
            pdf.internal.pageSize.getHeight() - 10
          );
        },
      });

      // Save the PDF
      pdf.save(`${fileName}.pdf`);

      // Clean up
      document.body.removeChild(container);
    } catch (error) {
      console.error('Error exporting to PDF:', error);
      document.body.removeChild(container);
    }
  }

  /**
   * Exports the pivot table data to Excel and downloads the file
   * @param {PivotTableState<T>} state - The current state of the pivot table
   * @param {string} fileName - The name of the downloaded file (without extension)
   */
  public static exportToExcel<T extends Record<string, any>>(
    state: PivotTableState<T>,
    fileName = 'pivot-table'
  ): void {
    try {
      PivotExportService.generateExcel(state, fileName);
    } catch (error) {
      console.error('Error exporting to Excel:', error);
    }
  }

  /**
   * Generates an Excel file from the pivot table data
   * @param {PivotTableState<T>} state - The current state of the pivot table
   * @param {string} fileName - The name of the downloaded file (without extension)
   */
  private static generateExcel<T extends Record<string, any>>(
    state: PivotTableState<T>,
    fileName: string
  ): void {
    if (!state.data || state.data.length === 0) {
      console.log('No data to export!');
      return;
    }

    // Get dimension and measure configurations
    const rows = state.rows || [];
    const columns = state.columns || [];
    const measures = state.measures || [];

    // Extract unique dimension values
    const rowDimension = rows[0]?.uniqueName;
    const colDimension = columns[0]?.uniqueName;

    if (!rowDimension || !colDimension) {
      console.log('Missing row or column dimension');
      return;
    }

    const uniqueRowValues = [
      ...new Set(
        state.data.map((item: { [x: string]: any }) => item[rowDimension])
      ),
    ];
    const uniqueColValues = [
      ...new Set(
        state.data.map((item: { [x: string]: any }) => item[colDimension])
      ),
    ];

    // Create header rows
    const headerRow = [
      rows[0]?.caption || 'Dimension',
      ...uniqueColValues.flatMap(colValue =>
        measures.map(
          measure => `${colValue} - ${measure.caption || measure.uniqueName}`
        )
      ),
    ];

    // Create data rows
    const dataRows = uniqueRowValues.map(rowValue => {
      const row = [rowValue];

      uniqueColValues.forEach(colValue => {
        measures.forEach(measure => {
          // Filter data for this row and column intersection
          const filteredData = state.data.filter(
            (item: { [x: string]: unknown }) =>
              item[rowDimension] === rowValue && item[colDimension] === colValue
          );

          // Calculate the aggregated value
          let value = 0;
          if (filteredData.length > 0) {
            switch (measure.aggregation) {
              case 'sum':
                value = filteredData.reduce(
                  (sum: any, item: { [x: string]: any }) =>
                    sum + (item[measure.uniqueName] || 0),
                  0
                );
                break;
              case 'avg':
                if (
                  measure?.formula &&
                  typeof measure.formula === 'function' &&
                  filteredData.length > 0
                ) {
                  value =
                    filteredData.reduce(
                      (sum: number, item: any) =>
                        sum + (measure.formula?.(item) || 0),
                      0
                    ) / filteredData.length;
                } else {
                  value =
                    filteredData.reduce(
                      (sum: any, item: { [x: string]: any }) =>
                        sum + (item[measure.uniqueName] || 0),
                      0
                    ) / filteredData.length;
                }
                break;
              case 'max':
                value = Math.max(
                  ...filteredData.map(
                    (item: { [x: string]: any }) =>
                      item[measure.uniqueName] || 0
                  )
                );
                break;
              case 'min':
                value = Math.min(
                  ...filteredData.map(
                    (item: { [x: string]: any }) =>
                      item[measure.uniqueName] || 0
                  )
                );
                break;
              case 'count':
                value = filteredData.length;
                break;
              default:
                value = 0;
            }
          }

          // For Excel, we keep the raw numeric value
          row.push(value);
        });
      });

      return row;
    });

    // Add a totals row if available
    if (state.processedData && state.processedData.totals) {
      const totalsRow = ['Total'];

      uniqueColValues.forEach(colValue => {
        measures.forEach(measure => {
          // Get total for this measure across all data
          const totalValue =
            state.processedData.totals[measure.uniqueName] || 0;
          totalsRow.push(totalValue?.toString());
        });
      });

      dataRows.push(totalsRow);
    }

    // Combine header and data rows
    const allRows = [headerRow, ...dataRows];

    // Create worksheet
    const ws = XLSX.utils.aoa_to_sheet(allRows);

    // Apply some basic styling
    const range = XLSX.utils.decode_range(ws['!ref'] ?? 'A1:A1');

    // Set column widths
    const colWidths = [];
    for (let i = 0; i <= range.e.c; i++) {
      colWidths[i] = { wch: i === 0 ? 15 : 12 }; // First column wider, data columns standard
    }
    ws['!cols'] = colWidths;

    // Apply number formatting for data cells
    for (let row = 1; row <= dataRows.length; row++) {
      for (
        let col = 1;
        col <= uniqueColValues.length * measures.length;
        col++
      ) {
        const cellAddress = XLSX.utils.encode_cell({ r: row, c: col });

        // Find the measure for this column
        const measureIndex = (col - 1) % measures.length;
        const measure = measures[measureIndex];

        if (measure && measure.format && ws[cellAddress]) {
          if (measure.format.type === 'currency') {
            // Apply currency format
            ws[cellAddress].z =
              measure.format.currency === 'USD'
                ? '"$"#,##0.00'
                : `"${measure.format.currency}"#,##0.00`;
          } else if (
            measure.format.type === 'number' &&
            measure.format.decimals !== undefined
          ) {
            // Apply decimal format
            const format =
              '#,##0' +
              (measure.format.decimals > 0
                ? '.' + '0'.repeat(measure.format.decimals)
                : '');
            ws[cellAddress].z = format;
          } else if (measure.format.type === 'percentage') {
            ws[cellAddress].z = '0.00%';
            // Convert decimal to percentage for display
            if (typeof ws[cellAddress].v === 'number') {
              ws[cellAddress].v = ws[cellAddress].v / 100;
            }
          }
        }
      }
    }

    // Create workbook and add worksheet
    const wb = XLSX.utils.book_new();
    XLSX.utils.book_append_sheet(wb, ws, 'Pivot Table');

    // Generate Excel file and download
    XLSX.writeFile(wb, `${fileName}.xlsx`);
  }

  /**
   * Opens a print dialog with formatted pivot table content
   * @param {PivotTableState<T>} state - The current state of the pivot table
   * @param {string} title - Optional title for the printed page
   */
  public static openPrintDialog<T extends Record<string, any>>(
    state: PivotTableState<T>
  ): void {
    const htmlContent = PivotExportService.convertToHtml(state);

    const printWindow = window.open('', '_blank');
    if (!printWindow) {
      console.error('Failed to open print dialog');
      return;
    }

    printWindow.document.write(htmlContent);
    printWindow.document.close();
    printWindow.print();
  }
}



================================================
FILE: engine/pivotEngine.ts
================================================
/* eslint-disable @typescript-eslint/no-explicit-any */
import {
  AggregationType,
  Dimension,
  Group,
  GroupConfig,
  MeasureConfig,
  PivotTableConfig,
  PivotTableState,
  ProcessedData,
  RowSize,
  SortConfig,
  FilterConfig,
  PaginationConfig,
  DataHandlingMode,
} from '../types/interfaces';
import { calculateAggregates } from './aggregator';
import { processData } from './dataProcessor';
import { PivotExportService } from './exportService';
// import { applySort, sortGroups } from './sorter';

/**
 * Creates an instance of PivotEngine.
 * @param {PivotTableConfig<T>} config - The configuration for the pivot table.
 */
export class PivotEngine<T extends Record<string, any>> {
  private config: PivotTableConfig<T>;
  private state: PivotTableState<T>;
  private filterConfig: FilterConfig[] = [];
  private paginationConfig: PaginationConfig = {
    currentPage: 1,
    pageSize: 10,
    totalPages: 1,
  };

  // Add cache for expensive calculations
  // private cache: Map<string, any> = new Map();

  constructor(config: PivotTableConfig<T>) {
    // Validate required config properties
    if (!this.validateConfig(config)) {
      throw new Error('Invalid pivot table configuration');
    }

    this.config = {
      ...config,
      defaultAggregation: config.defaultAggregation || 'sum',
      isResponsive: config.isResponsive ?? true,
    };

    this.state = this.initializeState(config);
    this.loadData();
  }

  private validateConfig(config: PivotTableConfig<T>): boolean {
    // Add validation logic
    if (!config) return false;
    if (config.dataSource) {
      const { type, url, file } = config.dataSource;
      if (type === 'remote' && !url) return false;
      if (type === 'file' && !file) return false;
    }
    return true;
  }

  private initializeState(config: PivotTableConfig<T>): PivotTableState<T> {
    return {
      data: config.data || [],
      dataHandlingMode: 'processed',
      rawData: config.data || [],
      processedData: { headers: [], rows: [], totals: {} },
      rows: config.rows || [],
      columns: config.columns || [],
      measures: config.measures || [],
      sortConfig: [],
      rowSizes: this.initializeRowSizes(config.data || []),
      expandedRows: {},
      groupConfig: config.groupConfig || null,
      groups: [],
      selectedMeasures: config.measures || [],
      selectedDimensions: config.dimensions || [],
      selectedAggregation: config.defaultAggregation || 'sum',
      formatting: config.formatting || {},
      columnWidths: {},
      isResponsive: config.isResponsive ?? true,
      rowGroups: [],

      columnGroups: [],
      filterConfig: [],
      paginationConfig: {
        currentPage: 1,
        pageSize: config.pageSize || 10,
        totalPages: 1,
      },
    };
  }
  /**
   * Loads data from a file or URL.
   **/
  private async loadData() {
    if (this.config.dataSource) {
      const { type, url, file } = this.config.dataSource;
      if (type === 'remote' && url) {
        this.state.rawData = await this.fetchRemoteData(url);
      } else if (type === 'file' && file) {
        this.state.rawData = await this.readFileData(file);
      } else {
        console.error('Invalid data source configuration');
      }
    } else if (this.config.data) {
      this.state.rawData = this.config.data;
    }

    // Initialize row sizes
    this.state.rowSizes = this.initializeRowSizes(this.state.rawData);

    // Process data after loading
    this.state.processedData = this.generateProcessedDataForDisplay();

    if (this.state.groupConfig) {
      this.applyGrouping();
    }
  }

  public setDataHandlingMode(mode: DataHandlingMode) {
    this.state.dataHandlingMode = mode;
    this.refreshData();
    this._emit(); // Notify subscribers after state change
  }

  /**
   * Gets the current data handling mode
   * @returns {DataHandlingMode}
   * @public
   */
  public getDataHandlingMode(): DataHandlingMode {
    return this.state.dataHandlingMode;
  }

  /**
   * Updates the engine's data source and applies current filters
   * This method allows external components to update the data while preserving filtering
   * @param {T[]} newData - The new data to use as the source
   * @public
   */
  public updateDataSource(newData: T[]) {
    // Update the config data (original source)
    this.config.data = [...newData];

    // Update the state data
    this.state.data = [...newData];
    this.state.rawData = [...newData];

    // Refresh with current filters applied
    this.refreshData();
    this._emit(); // Notify subscribers after state change
  }

  /**
   * Loads data from a file or URL.
   * @param {File | string} source - The file or URL to load data from.
   * @public
   * @returns {Promise<void>} A promise that resolves when the data is loaded.
   **/
  private async fetchRemoteData(url: string): Promise<T[]> {
    try {
      const response = await fetch(url);

      if (!response.ok) {
        throw new Error(`Failed to fetch data from ${url}`);
      }
      return await response.json();
    } catch (error) {
      console.error('Error fetching remote data:', error);
      return [];
    }
  }

  /**
   *  Process the data to be displayed in the table.
   * @param {T[]} data - The data to process.
   * @returns {ProcessedData} The processed data including headers, rows, and totals.
   * @private
   **/
  private async readFileData(file: File): Promise<T[]> {
    return new Promise((resolve, reject) => {
      const reader = new FileReader();
      reader.onload = event => {
        try {
          const data = JSON.parse(event.target?.result as string);
          resolve(data);
        } catch (error) {
          reject(error);
        }
      };
      reader.onerror = error => reject(error);
      reader.readAsText(file);
    });
  }

  /**
   * Initializes row sizes for the pivot table.
   * @param {T[]} data - The data to initialize row sizes for.
   * @returns {RowSize[]} An array of row sizes.
   * @private
   */
  private initializeRowSizes(data: T[]): RowSize[] {
    return data.map((_, index) => ({ index, height: 40 }));
  }

  /**
   * Processes the data for the pivot table.
   * @param {T[]} data - The data to process.
   * @returns {ProcessedData} The processed data including headers, rows, and totals.
   * @private
   */
  private generateProcessedDataForDisplay(): ProcessedData {
    // For processed data mode, use sorted data if available
    let dataToUse = this.state.rawData;

    // If we're in processed mode and have a sort config, ensure data is sorted
    if (
      this.state.dataHandlingMode === 'processed' &&
      this.state.sortConfig.length > 0
    ) {
      const sortConfig = this.state.sortConfig[0];

      // If we have groups (which is common in processed mode),
      // extract data from sorted groups to respect the sorted order
      if (this.state.groups.length > 0) {
        // Extract data from sorted groups in the correct order
        dataToUse = this.state.groups.flatMap(group => group.items);
      } else {
        // If no groups, sort the raw data directly
        dataToUse = this.sortData(this.state.rawData, sortConfig);
      }
    }

    return {
      headers: this.generateHeaders(),
      rows: this.generateRows(dataToUse),
      totals: this.calculateTotals(dataToUse),
    };
  }

  /**
   * Generates headers for the pivot table.
   * @returns {string[]} An array of header strings.
   * @private
   */
  private generateHeaders(): string[] {
    const useUniqueName = this.state.dataHandlingMode === 'raw';

    const rowHeaders = this.state.rows
      ? this.state.rows.map(r =>
          useUniqueName ? r.uniqueName : r.caption || r.uniqueName
        )
      : [];
    const columnHeaders = this.state.columns
      ? this.state.columns.map(c =>
          useUniqueName ? c.uniqueName : c.caption || c.uniqueName
        )
      : [];
    return [...rowHeaders, ...columnHeaders];
  }

  /**
   * Generates rows for the pivot table.
   * @param {T[]} data - The data to generate rows from.
   * @returns {any[][]} A 2D array representing the rows.
   * @private
   */
  private generateRows(data: T[]): any[][] {
    if (!data || !this.state.rows || !this.state.columns) {
      return [];
    }
    return data.map(item => [
      ...this.state.rows.map(r => item[r.uniqueName]),
      ...this.state.columns.map(c => item[c.uniqueName]),
      ...this.state.measures.map(m => this.calculateMeasureValue(item, m)),
    ]);
  }

  /**
   * Calculates the value for a specific measure.
   * @param {T} item - The data item.
   * @param {MeasureConfig} measure - The measure configuration.
   * @returns {number} The calculated measure value.
   * @private
   */
  private calculateMeasureValue(item: T, measure: MeasureConfig): number {
    if (measure.formula && typeof measure.formula === 'function') {
      return measure.formula(item);
    }
    return item[measure.uniqueName] || 0;
  }

  /**
   * Calculates totals for each measure in the pivot table.
   * @param {T[]} data - The data to calculate totals from.
   * @returns {Record<string, number>} An object with measure names as keys and their totals as values.
   * @private
   */
  private calculateTotals(data: T[]): Record<string, number> {
    const totals: Record<string, number> = {};

    this.state.measures.forEach(measure => {
      const { uniqueName, aggregation } = measure;
      let total = 0;

      if (aggregation === 'sum') {
        total = data.reduce((sum, item) => sum + (item[uniqueName] || 0), 0);
      } else if (aggregation === 'avg') {
        total =
          data.reduce((sum, item) => sum + (item[uniqueName] || 0), 0) /
          data.length;
      } else if (aggregation === 'max') {
        total = Math.max(...data.map(item => item[uniqueName] || 0));
      } else if (aggregation === 'min') {
        total = Math.min(...data.map(item => item[uniqueName] || 0));
      } else if (aggregation === 'count') {
        total = data.length;
      }

      totals[uniqueName] = total;
    });

    return totals;
  }

  // --- SUBSCRIPTION SYSTEM ---
  private listeners: Set<(state: PivotTableState<T>) => void> = new Set();
  /**
   * Subscribe to state changes. Returns an unsubscribe function.
   */
  public subscribe(fn: (state: PivotTableState<T>) => void): () => void {
    this.listeners.add(fn);
    fn(this.getState()); // Immediately call with current state
    return () => this.listeners.delete(fn);
  }
  /**
   * Emit state changes to all subscribers.
   */
  private _emit() {
    this.listeners.forEach(fn => fn(this.getState()));
  }

  /**
   * Sets the measures for the pivot table.
   * @param {MeasureConfig[]} measureFields - The measure configurations to set.
   * @public
   */
  public setMeasures(measureFields: MeasureConfig[]) {
    this.state.selectedMeasures = measureFields;
    this.state.processedData = this.generateProcessedDataForDisplay();
    this.updateAggregates();
    this._emit(); // Notify subscribers after state change
  }

  /**
   * Sets the dimensions for the pivot table.
   * @param {Dimension[]} dimensionFields - The dimension configurations to set.
   * @public
   */
  public setDimensions(dimensionFields: Dimension[]) {
    this.state.selectedDimensions = dimensionFields;
    this.state.processedData = this.generateProcessedDataForDisplay();
    this.updateAggregates();
    this.refreshData();
    this._emit(); // Notify subscribers after state change
  }

  /**
   * Sets the aggregation type for the pivot table.
   * @param {AggregationType} type - The aggregation type to set.
   * @public
   */
  public setAggregation(type: AggregationType) {
    this.state.selectedAggregation = type;
    this.state.processedData = this.generateProcessedDataForDisplay();
    this.updateAggregates();
    this.refreshData();
    this._emit(); // Notify subscribers after state change
  }

  /**
   * Sets the row groups for the pivot table.
   * @param {Group[]} rowGroups - The row groups to set.
   * @public
   */
  public setRowGroups(rowGroups: Group[]) {
    this.state.rowGroups = rowGroups;
    this.state.processedData = this.generateProcessedDataForDisplay();
    this.updateAggregates();
    this._emit(); // Notify subscribers after state change
  }

  /**
   * Sets the column groups for the pivot table.
   * @param {Group[]} columnGroups - The column groups to set.
   * @public
   */
  public setColumnGroups(columnGroups: Group[]) {
    this.state.columnGroups = columnGroups;
    this.state.processedData = this.generateProcessedDataForDisplay();
    this.updateAggregates();
    this._emit(); // Notify subscribers after state change
  }

  /**
   * Formats a value based on the specified field's format.
   * @param {any} value - The value to format.
   * @param {string} field - The field name to use for formatting.
   * @returns {string} The formatted value as a string.
   * @public
   */
  public formatValue(value: any, field: string): string {
    const format = this.state.formatting[field];
    if (!format) return String(value);

    try {
      switch (format.type) {
        case 'currency':
          return new Intl.NumberFormat(format.locale || 'en-US', {
            style: 'currency',
            currency: format.currency || 'USD',
            minimumFractionDigits: format.decimals || 0,
            maximumFractionDigits: format.decimals || 0,
          }).format(value);
        case 'number':
          return new Intl.NumberFormat(format.locale || 'en-US', {
            minimumFractionDigits: format.decimals || 0,
            maximumFractionDigits: format.decimals || 0,
          }).format(value);
        case 'percentage':
          return new Intl.NumberFormat(format.locale || 'en-US', {
            style: 'percent',
            minimumFractionDigits: format.decimals || 0,
          }).format(value);
        case 'date':
          return new Date(value).toLocaleDateString(format.locale || 'en-US', {
            dateStyle: 'medium',
          });
        default:
          return String(value);
      }
    } catch (error) {
      console.error(`Error formatting value for field ${field}:`, error);
      return String(value);
    }
  }

  /**
   * Sorts the pivot table data based on the specified field and direction.
   * @param {string} field - The field to sort by.
   * @param {'asc' | 'desc'} direction - The sort direction.
   * @public
   */
  public sort(field: string, direction: 'asc' | 'desc') {
    const measure = this.state.measures.find(m => m.uniqueName === field);

    const newSortConfig: SortConfig = {
      field,
      direction,
      type: measure ? 'measure' : 'dimension',
      aggregation: measure?.aggregation,
    };

    this.state.sortConfig = [newSortConfig];
    this.applySort();
  }

  private applySort() {
    if (this.state.dataHandlingMode === 'raw') {
      // Sort raw data
      const sortedData = this.sortData(
        this.state.rawData,
        this.state.sortConfig[0]
      );

      // Update both data and rawData for consistency
      this.state.data = sortedData;
      this.state.rawData = sortedData;

      this.state.processedData = this.generateProcessedDataForDisplay();
      this.updateAggregates();
    } else {
      // For processed data mode
      if (this.state.groups.length > 0) {
        // If we have groups, sort the grouped data
        this.state.groups = this.sortGroups(
          this.state.groups,
          this.state.sortConfig[0]
        );

        // Regenerate processed data to reflect the sorted groups
        this.state.processedData = this.generateProcessedDataForDisplay();
        this.updateAggregates();
      } else {
        // If we don't have groups, but we're in processed mode,
        // we need to sort the raw data and then regenerate processed data
        const sortedData = this.sortData(
          this.state.rawData,
          this.state.sortConfig[0]
        );
        this.state.data = sortedData;
        this.state.rawData = sortedData;

        // Regenerate processed data to reflect the sorted data
        this.state.processedData = this.generateProcessedDataForDisplay();
        this.updateAggregates();
      }
    }

    this._emit(); // Notify subscribers of state change
  }

  private sortData(data: T[], sortConfig: SortConfig): T[] {
    return [...data].sort((a, b) => {
      let aValue = this.getFieldValue(a, sortConfig);
      let bValue = this.getFieldValue(b, sortConfig);

      // Handle different data types for raw data sorting
      if (typeof aValue === 'string') aValue = aValue.toLowerCase();
      if (typeof bValue === 'string') bValue = bValue.toLowerCase();

      if (aValue < bValue) return sortConfig.direction === 'asc' ? -1 : 1;
      if (aValue > bValue) return sortConfig.direction === 'asc' ? 1 : -1;
      return 0;
    });
  }

  private getFieldValue(item: T, sortConfig: SortConfig): any {
    if (sortConfig.type === 'measure') {
      const measure = this.state.measures.find(
        m => m.uniqueName === sortConfig.field
      );
      if (measure && measure.formula) {
        return measure.formula(item);
      }
    }
    return item[sortConfig.field];
  }

  private sortGroups(groups: Group[], sortConfig: SortConfig): Group[] {
    return [...groups].sort((a, b) => {
      let aValue: any;
      let bValue: any;

      if (sortConfig.type === 'measure') {
        // Sort by aggregated measure values
        aValue =
          a.aggregates[`${sortConfig.aggregation}_${sortConfig.field}`] || 0;
        bValue =
          b.aggregates[`${sortConfig.aggregation}_${sortConfig.field}`] || 0;
      } else {
        // Sort by dimension values (e.g., row field names like country, product, etc.)
        // Extract the dimension value from the group key
        const keys = a.key ? a.key.split('|') : [];
        const bKeys = b.key ? b.key.split('|') : [];

        // For row field sorting, use the first key (row field value)
        // For column field sorting, use the second key (column field value)
        const rowField = this.state.rows?.[0]?.uniqueName;
        const columnField = this.state.columns?.[0]?.uniqueName;

        if (sortConfig.field === rowField) {
          aValue = keys[0] || '';
          bValue = bKeys[0] || '';
        } else if (sortConfig.field === columnField) {
          aValue = keys[1] || '';
          bValue = bKeys[1] || '';
        } else {
          // Fallback: try to find the field in the first item of each group
          aValue = a.items[0]?.[sortConfig.field] || '';
          bValue = b.items[0]?.[sortConfig.field] || '';
        }

        // Handle string comparison
        if (typeof aValue === 'string') aValue = aValue.toLowerCase();
        if (typeof bValue === 'string') bValue = bValue.toLowerCase();
      }

      if (aValue < bValue) return sortConfig.direction === 'asc' ? -1 : 1;
      if (aValue > bValue) return sortConfig.direction === 'asc' ? 1 : -1;
      return 0;
    });
  }

  /**
   * Updates aggregates for all groups in the pivot table.
   * @private
   */
  private updateAggregates() {
    const updateGroupAggregates = (group: Group) => {
      this.state.measures.forEach(measure => {
        const aggregateKey = `${this.state.selectedAggregation}_${measure.uniqueName}`;
        if (measure.formula && typeof measure.formula === 'function') {
          // Handle custom measures
          const formulaResults = group.items.map(item =>
            measure.formula ? measure.formula(item) : 0
          );
          group.aggregates[aggregateKey] = calculateAggregates(
            formulaResults.map(value => ({ value })),
            'value' as keyof { value: number },
            measure.aggregation ||
              (this.state.selectedAggregation as AggregationType)
          );
        } else {
          group.aggregates[aggregateKey] = calculateAggregates(
            group.items,
            measure.uniqueName as keyof T,
            (measure.aggregation as AggregationType) ||
              (this.state.selectedAggregation as AggregationType)
          );
        }
      });

      if (group.subgroups) {
        group.subgroups.forEach(updateGroupAggregates);
      }
    };

    this.state.groups.forEach(updateGroupAggregates);
  }

  /**
   * Applies grouping to the pivot table data.
   * @private
   */
  private applyGrouping(dataOverride?: T[]) {
    if (!this.state.groupConfig) return;

    const { rowFields, columnFields, grouper } = this.state.groupConfig;

    if (!rowFields || !columnFields || !grouper) {
      console.error('Invalid groupConfig:', this.state.groupConfig);
      return;
    }

    // Use provided data or fall back to config data
    const dataToUse = dataOverride || this.config.data || [];

    const tempConfig = {
      ...this.config,
      data: dataToUse,
    };

    const { rawData, groups } = processData(
      tempConfig,
      this.state.sortConfig[0] || null,
      this.state.groupConfig
    );

    this.state.rawData = rawData;
    this.state.groups = groups;
    this.updateAggregates();

    this.state.processedData = this.generateProcessedDataForDisplay();
  }

  /**
   * Sets the group configuration for the pivot table.
   * @param {GroupConfig | null} groupConfig - The group configuration to set.
   * @public
   */
  public setGroupConfig(groupConfig: GroupConfig | null) {
    this.state.groupConfig = groupConfig;
    if (groupConfig) {
      this.applyGrouping();
    } else {
      this.state.groups = [];
      this.state.processedData = this.generateProcessedDataForDisplay();
    }
    this._emit(); // Notify subscribers after state change
  }

  /**
   * Returns the grouped data.
   * @returns {Group[]} An array of grouped data.
   * @public
   */
  public getGroupedData(): Group[] {
    return this.state.groups;
  }

  /**
   * Returns the current state of the pivot table.
   * @returns {PivotTableState<T>} The current state of the pivot table.
   * @public
   */
  public getState(): PivotTableState<T> {
    return { ...this.state };
  }

  /**
   * Resets the pivot table to its initial state.
   * @public
   */
  public reset() {
    this.state = {
      ...this.state,
      rawData: this.config.data || [],
      processedData: this.generateProcessedDataForDisplay(),
      sortConfig: [],
      rowSizes: this.initializeRowSizes(this.config.data || []),
      expandedRows: {},
      groupConfig: this.config.groupConfig || null,
      groups: [],
    };

    if (this.state.groupConfig) {
      this.applyGrouping();
    }
    this._emit(); // Notify subscribers after state change
  }

  /**
   * Resizes a specific row in the pivot table.
   * @param {number} index - The index of the row to resize.
   * @param {number} height - The new height for the row.
   * @public
   */
  public resizeRow(index: number, height: number) {
    const rowIndex = this.state.rowSizes.findIndex(row => row.index === index);
    if (rowIndex !== -1) {
      this.state.rowSizes[rowIndex].height = Math.max(20, height);
      this._emit(); // Notify subscribers after state change
    }
  }

  /**
   * Toggles the expansion state of a row.
   * @param {string} rowId - The ID of the row to toggle.
   * @public
   */
  public toggleRowExpansion(rowId: string) {
    this.state.expandedRows[rowId] = !this.state.expandedRows[rowId];
    this._emit(); // Notify subscribers after state change
  }

  /**
   * Checks if a row is expanded.
   * @param {string} rowId - The ID of the row to check.
   * @returns {boolean} True if the row is expanded, false otherwise.
   * @public
   */
  public isRowExpanded(rowId: string): boolean {
    return !!this.state.expandedRows[rowId];
  }

  /**
   * Handles dragging a row to a new position.
   * This method now correctly operates on state.rowGroups.
   * @param {number} fromIndex - The original index of the row.
   * @param {number} toIndex - The new index for the row.
   * @public
   */
  public dragRow(fromIndex: number, toIndex: number) {
    // Validate indices against the rowGroups array
    if (
      !this.validateDragOperation(
        fromIndex,
        toIndex,
        this.state.rowGroups.length
      )
    ) {
      // The validateDragOperation already logs a warning, so we can just return.
      return;
    }

    // Create a new array from the existing row groups to avoid direct mutation
    const newRowGroups = [...this.state.rowGroups];

    // Remove the item from its original position
    const [movedGroup] = newRowGroups.splice(fromIndex, 1);

    // Insert the removed item into its new position
    newRowGroups.splice(toIndex, 0, movedGroup);

    // Update the state with the newly ordered array
    this.state.rowGroups = newRowGroups;

    // Optional: Call the onRowDragEnd callback if it's defined in the config
    if (typeof this.config.onRowDragEnd === 'function') {
      this.config.onRowDragEnd(fromIndex, toIndex, this.state.rowGroups);
    }

    this._emit(); // Notify subscribers after state change
  }

  /**
   * Handles dragging a column to a new position.
   * This method now correctly operates on state.columnGroups.
   * @param {number} fromIndex - The original index of the column.
   * @param {number} toIndex - The new index for the column.
   * @public
   */
  public dragColumn(fromIndex: number, toIndex: number): void {
    // Validate indices against the columnGroups array
    if (
      !this.validateDragOperation(
        fromIndex,
        toIndex,
        this.state.columnGroups.length
      )
    ) {
      return;
    }

    try {
      // Create a new array from the existing column groups
      const newColumnGroups = [...this.state.columnGroups];

      // Remove the group from its original position
      const [movedColumn] = newColumnGroups.splice(fromIndex, 1);

      // Insert the removed group into its new position
      newColumnGroups.splice(toIndex, 0, movedColumn);

      // Update the state with the newly ordered array
      this.state.columnGroups = newColumnGroups;

      // Call callback if provided
      if (typeof this.config.onColumnDragEnd === 'function') {
        // Map Group[] to { uniqueName, caption }[] before passing to callback
        const mappedColumnGroups = newColumnGroups.map(group => ({
          uniqueName: (group as any).uniqueName ?? group.key ?? '',
          caption: (group as any).caption ?? group.key ?? '',
        }));
        this.config.onColumnDragEnd(fromIndex, toIndex, mappedColumnGroups);
      }

      this._emit(); // Notify subscribers after state change
    } catch (error) {
      console.error('Error during column drag operation:', error);
    }
  }

  // Ensure this validation method also prevents dragging to the same spot
  private validateDragOperation(
    fromIndex: number,
    toIndex: number,
    length: number
  ): boolean {
    if (fromIndex === toIndex) {
      return false; // No operation needed, not an error
    }
    const isValid =
      fromIndex >= 0 && toIndex >= 0 && fromIndex < length && toIndex < length;
    if (!isValid) {
      console.warn(
        `Invalid drag indices: from ${fromIndex} to ${toIndex} with length ${length}`
      );
    }
    return isValid;
  }

  /**
   * Applies filters to the data
   * @param {FilterConfig[]} filters - Array of filter configurations
   * @public
   */
  public applyFilters(filters: FilterConfig[]) {
    this.filterConfig = filters;
    this.refreshData();
    this._emit(); // Notify subscribers after state change
  }

  /**
   * Sets pagination configuration
   * @param {PaginationConfig} config - Pagination configuration
   * @public
   */
  public setPagination(config: PaginationConfig) {
    this.paginationConfig = {
      ...this.paginationConfig,
      ...config,
    };

    this.refreshData();
    this._emit(); // Notify subscribers after state change
  }

  /**
   * Returns the current pagination configuration
   * @returns {PaginationConfig}
   * @public
   */
  public getPagination(): PaginationConfig {
    return this.paginationConfig;
  }

  /**
   * Refreshes data with current filters and pagination
   * @private
   */
  private refreshData() {
    // Get the appropriate data source based on data handling mode
    const originalData = this.getDataForCurrentMode();

    let filteredData: T[];

    // Check if we're filtering on aggregated measures in processed mode
    if (
      this.state.dataHandlingMode === 'processed' &&
      this.hasAggregatedFilters()
    ) {
      // For aggregated filters, we need to filter the grouped data, not raw data
      filteredData = this.filterProcessedData(originalData);
    } else {
      // For regular field filters, apply normal filtering
      filteredData = this.filterData(originalData);
    }

    // Update total pages based on filtered data
    this.paginationConfig.totalPages = Math.ceil(
      filteredData.length / this.paginationConfig.pageSize
    );

    // Apply pagination
    filteredData = this.paginateData(filteredData);

    // Update state based on data handling mode
    if (this.state.dataHandlingMode === 'raw') {
      // For raw mode, update the raw data directly
      this.state.data = filteredData;
      this.state.rawData = filteredData;
      // Still need to regenerate processed data for display (headers depend on mode)
      this.state.processedData = this.generateProcessedDataForDisplay();
    } else {
      // For processed mode, update the data and regenerate processed data
      this.state.data = filteredData;
      this.state.rawData = filteredData;
      if (this.state.groupConfig) {
        // Pass the filtered data to grouping instead of using config
        this.applyGrouping(filteredData);
      }
      this.state.processedData = this.generateProcessedDataForDisplay();
    }
  }

  /**
   * Gets the appropriate data source based on the current data handling mode
   * @private
   */
  private getDataForCurrentMode(): T[] {
    // Always start from the original data stored in config
    return [...(this.config.data || [])];
  }

  /**
   * Filters data based on filter configuration
   * @param {T[]} data - Data to filter
   * @private
   */
  private filterData(data: T[]): T[] {
    if (!this.filterConfig.length) return data;

    return data.filter(item =>
      this.filterConfig.every(filter => {
        const value = item[filter.field];
        const filterValue =
          typeof value === 'number' ? Number(filter.value) : filter.value;

        switch (filter.operator) {
          case 'equals':
            return value === filterValue;
          case 'contains':
            return String(value)
              .toLowerCase()
              .includes(String(filterValue).toLowerCase());
          case 'greaterThan':
            return Number(value) > Number(filterValue);
          case 'lessThan':
            return Number(value) < Number(filterValue);
          case 'between':
            return value >= filterValue[0] && value <= filterValue[1];
          default:
            return true;
        }
      })
    );
  }

  /**
   * Paginates data based on pagination configuration
   * @param {T[]} data - Data to paginate
   * @private
   */
  private paginateData(data: T[]): T[] {
    const { currentPage, pageSize } = this.paginationConfig;
    const start = (currentPage - 1) * pageSize;
    return data.slice(start, start + pageSize);
  }

  /**
   * Gets current pagination state
   * @returns {PaginationConfig} Current pagination configuration
   * @public
   */
  public getPaginationState(): PaginationConfig {
    return { ...this.paginationConfig };
  }

  /**
   * Gets current filter state
   * @returns {FilterConfig[]} Current filter configuration
   * @public
   */
  public getFilterState(): FilterConfig[] {
    return [...this.filterConfig];
  }

  /**
   * Exports the pivot table data to HTML and downloads the file.
   * @param {string} fileName - The name of the downloaded file (without extension).
   * @public
   */
  public exportToHTML(fileName = 'pivot-table'): void {
    PivotExportService.exportToHTML(this.getState(), fileName);
  }

  /**
   * Exports the pivot table data to PDF and downloads the file.
   * @param {string} fileName - The name of the downloaded file (without extension).
   * @public
   */
  public exportToPDF(fileName = 'pivot-table'): void {
    PivotExportService.exportToPDF(this.getState(), fileName);
  }

  /**
   * Exports the pivot table data to Excel and downloads the file.
   * @param {string} fileName - The name of the downloaded file (without extension).
   * @public
   */
  public exportToExcel(fileName = 'pivot-table'): void {
    PivotExportService.exportToExcel(this.getState(), fileName);
  }

  /**
   * Opens a print dialog with the formatted pivot table.
   * @public
   */
  public openPrintDialog(): void {
    PivotExportService.openPrintDialog(this.getState());
  }

  // Add these methods to your PivotEngine class to fix drag functionality

  /**
   * Handles dragging a data row (product) to a new position
   * This method operates on the actual data items, not groups
   * @param {number} fromIndex - The original index of the product in unique products list
   * @param {number} toIndex - The new index for the product in unique products list
   * @public
   */
  public dragDataRow(fromIndex: number, toIndex: number): void {
    // Get unique products with proper type casting
    const uniqueProducts = [
      ...new Set(this.state.data.map((item: { product: any }) => item.product)),
    ].filter((product): product is string => typeof product === 'string');

    if (
      !this.validateDragOperation(fromIndex, toIndex, uniqueProducts.length)
    ) {
      return;
    }

    try {
      // Get the product names being moved
      const fromProduct = uniqueProducts[fromIndex];
      const toProduct = uniqueProducts[toIndex];

      console.log(`Reordering products: ${fromProduct} -> ${toProduct}`);

      // Create a new data array with reordered products
      const newData = [...this.state.data];

      // Create a mapping of desired product order
      const reorderedProducts = [...uniqueProducts];
      const [movedProduct] = reorderedProducts.splice(fromIndex, 1);
      reorderedProducts.splice(toIndex, 0, movedProduct);

      // Sort the data array based on the new product order
      newData.sort((a, b) => {
        const aIndex = reorderedProducts.indexOf(a.product as string);
        const bIndex = reorderedProducts.indexOf(b.product as string);
        return aIndex - bIndex;
      });

      // Update the state
      this.state.data = newData;
      this.state.rawData = newData;

      // Regenerate processed data
      this.state.processedData = this.generateProcessedDataForDisplay();

      // Update aggregates if groups exist
      if (this.state.groups.length > 0) {
        this.updateAggregates();
      }

      // Call callback if provided
      if (typeof this.config.onRowDragEnd === 'function') {
        this.config.onRowDragEnd(fromIndex, toIndex, this.state.rowGroups);
      }
    } catch (error) {
      console.error('Error during data row drag operation:', error);
    }
  }

  /**
   * Handles dragging a data column (region) to a new position
   * This method operates on the actual data structure, not groups
   * @param {number} fromIndex - The original index of the region
   * @param {number} toIndex - The new index for the region
   * @public
   */
  public dragDataColumn(fromIndex: number, toIndex: number): void {
    // Get unique regions with proper type casting
    const uniqueRegions = [
      ...new Set(this.state.data.map((item: { region: any }) => item.region)),
    ].filter((region): region is string => typeof region === 'string');

    if (!this.validateDragOperation(fromIndex, toIndex, uniqueRegions.length)) {
      return;
    }

    try {
      // Get the region names being moved
      // Create a new data array with reordered regions
      const newData = [...this.state.data];

      // Create a mapping of desired region order
      const reorderedRegions = [...uniqueRegions];
      const [movedRegion] = reorderedRegions.splice(fromIndex, 1);
      reorderedRegions.splice(toIndex, 0, movedRegion);

      // Update columns configuration if it exists
      if (this.state.columns && this.state.columns.length > 0) {
        const newColumns = [...this.state.columns];
        // Find and reorder column configurations that match regions
        newColumns.sort((a, b) => {
          const aIndex = reorderedRegions.indexOf(a.uniqueName);
          const bIndex = reorderedRegions.indexOf(b.uniqueName);
          if (aIndex === -1) return 1;
          if (bIndex === -1) return -1;
          return aIndex - bIndex;
        });
        this.state.columns = newColumns;
      }

      // Update the state
      this.state.data = newData;
      this.state.rawData = newData;

      // Regenerate processed data
      this.state.processedData = this.generateProcessedDataForDisplay();

      // Update aggregates if groups exist
      if (this.state.groups.length > 0) {
        this.updateAggregates();
      }

      // Call callback if provided
      if (typeof this.config.onColumnDragEnd === 'function') {
        const mappedColumns: { uniqueName: string; caption: string }[] =
          reorderedRegions.map(region => ({
            uniqueName: region,
            caption: region,
          }));
        this.config.onColumnDragEnd(fromIndex, toIndex, mappedColumns);
      }
    } catch (error) {
      console.error('Error during data column drag operation:', error);
    }
  }

  /**
   * Alternative method: Reorder products by their names directly
   * This is more direct for your UI implementation
   * @param {string} fromProduct - Name of the product being moved
   * @param {string} toProduct - Name of the product to move before/after
   * @param {'before' | 'after'} position - Whether to place before or after target
   * @public
   */
  public reorderProductsByName(
    fromProduct: string,
    toProduct: string,
    position: 'before' | 'after' = 'before'
  ): void {
    try {
      const uniqueProducts = [
        ...new Set(
          this.state.data.map((item: { product: any }) => item.product)
        ),
      ];
      const fromIndex = uniqueProducts.indexOf(fromProduct);
      const toIndex = uniqueProducts.indexOf(toProduct);

      if (fromIndex === -1 || toIndex === -1) {
        console.warn('Invalid product names for reordering:', {
          fromProduct,
          toProduct,
        });
        return;
      }

      // Calculate the actual target index based on position
      const actualToIndex = position === 'after' ? toIndex + 1 : toIndex;

      // Use the existing dragDataRow method
      this.dragDataRow(fromIndex, actualToIndex);
    } catch (error) {
      console.error('Error reordering products by name:', error);
    }
  }

  //swap logic

  // Also add a method to get the custom region order:
  public getCustomRegionOrder(): string[] | null {
    return (this.state as any).customRegionOrder || null;
  }

  // GENERIC CORE ENGINE METHODS - Works with any field names



/**
 * Generic method to swap data rows based on the configured row field
 * Works with any field name (product, country, customer, etc.)
 */
public swapDataRows(fromIndex: number, toIndex: number): void {
  // Get the row field configuration
  const rowField =
    this.state.rows && this.state.rows.length > 0
      ? this.state.rows[0] // Use first row field
      : null;

  if (!rowField) {
    console.warn('No row field configured for swapping');
    return;
  }

  const rowFieldName = rowField.uniqueName;

  // Get unique values for the row field from FULL DATASET - use current custom order if it exists
  const customRowOrder = (this.state as any).customRowOrder;
  let uniqueRowValues: string[];

  if (
    customRowOrder &&
    customRowOrder.fieldName === rowFieldName &&
    customRowOrder.order
  ) {
    // Use the current custom order
    uniqueRowValues = [...customRowOrder.order];
  } else {
    // Use original FULL data order - THIS IS THE KEY FIX
    uniqueRowValues = [
      ...new Set(
        (this.config.data || []).map(
          (item: { [x: string]: any }) => item[rowFieldName]
        )
      ),
    ].filter(
      (value): value is string =>
        typeof value === 'string' && value !== null && value !== undefined
    );
  }

  console.log(`Row swap validation: ${rowFieldName} has ${uniqueRowValues.length} unique values:`, uniqueRowValues);

  if (
    fromIndex < 0 ||
    toIndex < 0 ||
    fromIndex >= uniqueRowValues.length ||
    toIndex >= uniqueRowValues.length
  ) {
    console.warn(`Invalid indices for row swap operation:`, {
      fromIndex,
      toIndex,
      totalRows: uniqueRowValues.length,
      fieldName: rowFieldName,
    });
    return;
  }

  if (fromIndex === toIndex) {
    return; // No swap needed
  }

  try {
    // Get the values to swap
    const fromValue = uniqueRowValues[fromIndex];
    const toValue = uniqueRowValues[toIndex];

    // Create new data array with swapped order - use FULL dataset
    const newData = [...(this.config.data || [])];

    // Create swapped value order
    const swappedValues = [...uniqueRowValues];
    swappedValues[fromIndex] = toValue;
    swappedValues[toIndex] = fromValue;

    // Store the custom row order
    (this.state as any).customRowOrder = {
      fieldName: rowFieldName,
      order: swappedValues,
    };

    // Sort data according to the new value order
    newData.sort((a, b) => {
      const aIndex = swappedValues.indexOf(a[rowFieldName] as string);
      const bIndex = swappedValues.indexOf(b[rowFieldName] as string);
      return aIndex - bIndex;
    });

    // Update the config data (source of truth)
    this.config.data = newData;

    // Update the state with full data, then let pagination handle the subset
    this.state.rawData = newData;
    this.state.data = newData; // This will be re-paginated by refreshData

    // Regenerate processed data
    this.state.processedData = this.generateProcessedDataForDisplay();

    // Update aggregates if groups exist
    if (this.state.groups.length > 0) {
      this.updateAggregates();
    }

    // Call callback if provided
    if (typeof this.config.onRowDragEnd === 'function') {
      this.config.onRowDragEnd(fromIndex, toIndex, this.state.rowGroups);
    }

    console.log(`Row swap completed successfully for field: ${rowFieldName}`);

    // Emit state change to notify subscribers
    this._emit();
  } catch (error) {
    console.error('Error during row swap operation:', error);
  }
}

/**
 * Generic method to swap data columns based on the configured column field
 * Works with any field name (region, category, department, etc.)
 */
public swapDataColumns(fromIndex: number, toIndex: number): void {
  // Get the column field configuration
  const columnField =
    this.state.columns && this.state.columns.length > 0
      ? this.state.columns[0] // Use first column field
      : null;

  if (!columnField) {
    console.warn('No column field configured for swapping');
    return;
  }

  const columnFieldName = columnField.uniqueName;

  // Get unique values for the column field from FULL DATASET - use current custom order if it exists
  const customColumnOrder = (this.state as any).customColumnOrder;
  let uniqueColumnValues: string[];

  if (
    customColumnOrder &&
    customColumnOrder.fieldName === columnFieldName &&
    customColumnOrder.order
  ) {
    // Use the current custom order
    uniqueColumnValues = [...customColumnOrder.order];
  } else {
    // Use original FULL data order - THIS IS THE KEY FIX
    uniqueColumnValues = [
      ...new Set(
        (this.config.data || []).map(
          (item: { [x: string]: any }) => item[columnFieldName]
        )
      ),
    ].filter(
      (value): value is string =>
        typeof value === 'string' && value !== null && value !== undefined
    );
  }

  console.log(`Column swap validation: ${columnFieldName} has ${uniqueColumnValues.length} unique values:`, uniqueColumnValues);

  if (
    fromIndex < 0 ||
    toIndex < 0 ||
    fromIndex >= uniqueColumnValues.length ||
    toIndex >= uniqueColumnValues.length
  ) {
    console.warn(`Invalid indices for column swap operation:`, {
      fromIndex,
      toIndex,
      totalColumns: uniqueColumnValues.length,
      fieldName: columnFieldName,
    });
    return;
  }

  if (fromIndex === toIndex) {
    return; // No swap needed
  }

  try {
    // Get the values to swap
    const fromValue = uniqueColumnValues[fromIndex];
    const toValue = uniqueColumnValues[toIndex];

    // Create swapped value order
    const swappedValues = [...uniqueColumnValues];
    swappedValues[fromIndex] = toValue;
    swappedValues[toIndex] = fromValue;

    // Update columns configuration if it exists
    if (this.state.columns && this.state.columns.length > 0) {
      const newColumns = [...this.state.columns];

      // Find and swap the column configurations
      const fromColumnIndex = newColumns.findIndex(
        col => col.uniqueName === fromValue
      );
      const toColumnIndex = newColumns.findIndex(
        col => col.uniqueName === toValue
      );

      if (fromColumnIndex !== -1 && toColumnIndex !== -1) {
        // Swap the column configurations
        [newColumns[fromColumnIndex], newColumns[toColumnIndex]] = [
          newColumns[toColumnIndex],
          newColumns[fromColumnIndex],
        ];
        this.state.columns = newColumns;
        console.log('Updated column configurations');
      }
    }

    // Store the custom column order
    (this.state as any).customColumnOrder = {
      fieldName: columnFieldName,
      order: swappedValues,
    };

    // Regenerate processed data with new column order
    this.state.processedData = this.generateProcessedDataForDisplay();

    // Update aggregates if groups exist
    if (this.state.groups.length > 0) {
      this.updateAggregates();
    }

    // Call callback if provided
    if (typeof this.config.onColumnDragEnd === 'function') {
      const mappedColumns: { uniqueName: string; caption: string }[] =
        swappedValues.map(value => ({
          uniqueName: value,
          caption: value,
        }));
      this.config.onColumnDragEnd(fromIndex, toIndex, mappedColumns);
    }

    console.log(`Column swap completed successfully for field: ${columnFieldName}`);

    // Emit state change to notify subscribers
    this._emit();
  } catch (error) {
    console.error('Error during column swap operation:', error);
  }
}


/**
 * Generic method to get unique values for any field
 * Uses the original config data, not the paginated state data
 * Utility method for UI components
 */
public getUniqueFieldValues(fieldName: string): string[] {
  // Use the original config data, not the paginated state data
  const dataSource = this.config.data || [];
  
  console.log(`Getting unique values for field: ${fieldName} from ${dataSource.length} total items`);
  
  const uniqueValues = [
    ...new Set(
      dataSource.map((item: { [x: string]: any }) => item[fieldName])
    ),
  ].filter(
    (value): value is string =>
      typeof value === 'string' && value !== null && value !== undefined
  );
  
  console.log(`Found ${uniqueValues.length} unique values for ${fieldName}:`, uniqueValues);
  
  return uniqueValues;
}

// Also add this method to get unique values in their current custom order:
/**
 * Get unique field values respecting any custom order that has been set
 */
public getOrderedUniqueFieldValues(fieldName: string, isRowField = false): string[] {
  // Check if there's a custom order for this field
  const customOrderKey = isRowField ? 'customRowOrder' : 'customColumnOrder';
  const customOrder = (this.state as any)[customOrderKey];
  
  if (customOrder && customOrder.fieldName === fieldName && customOrder.order) {
    console.log(`Using custom order for ${fieldName}:`, customOrder.order);
    return customOrder.order;
  }
  
  // Fall back to natural order from full dataset
  return this.getUniqueFieldValues(fieldName);
}

  /**
   * Generic method to get the configured row field name
   */
  public getRowFieldName(): string | null {
    return this.state.rows && this.state.rows.length > 0
      ? this.state.rows[0].uniqueName
      : null;
  }

  /**
   * Generic method to get the configured column field name
   */
  public getColumnFieldName(): string | null {
    return this.state.columns && this.state.columns.length > 0
      ? this.state.columns[0].uniqueName
      : null;
  }

  /**
   * Generic method to set custom field order
   * Can be used by UI to store custom arrangements
   */
  public setCustomFieldOrder(
    fieldName: string,
    order: string[],
    isRowField = true
  ): void {
    const customKey = isRowField ? 'customRowOrder' : 'customColumnOrder';
    (this.state as any)[customKey] = {
      fieldName,
      order,
    };

    // Regenerate processed data
    this.state.processedData = this.generateProcessedDataForDisplay();
    this._emit(); // Notify subscribers after state change
  }

  /**
   * Get ordered column values if custom order exists
   */
  public getOrderedColumnValues(): string[] | null {
    const customColumnOrder = (this.state as any).customColumnOrder;
    if (
      customColumnOrder &&
      customColumnOrder.order &&
      customColumnOrder.order.length > 0
    ) {
      console.log(
        'Engine returning custom column order:',
        customColumnOrder.order
      );
      return customColumnOrder.order;
    }
    console.log('Engine has no custom column order');
    return null;
  }

  /**
   * Get ordered row values if custom order exists
   */
  public getOrderedRowValues(): string[] | null {
    const customRowOrder = (this.state as any).customRowOrder;
    if (
      customRowOrder &&
      customRowOrder.order &&
      customRowOrder.order.length > 0
    ) {
      console.log('Engine returning custom row order:', customRowOrder.order);
      return customRowOrder.order;
    }
    console.log('Engine has no custom row order');
    return null;
  }

  /**
   * Method to swap raw data rows by index
   * This works directly with the raw data array regardless of pivot configuration
   */
  public swapRawDataRows(fromIndex: number, toIndex: number): void {
    if (!this.state.data || this.state.data.length === 0) {
      console.warn('No data available for raw row swap');
      return;
    }

    if (
      fromIndex < 0 ||
      toIndex < 0 ||
      fromIndex >= this.state.data.length ||
      toIndex >= this.state.data.length
    ) {
      console.warn(`Invalid indices for raw row swap operation:`, {
        fromIndex,
        toIndex,
        totalRows: this.state.data.length,
      });
      return;
    }

    if (fromIndex === toIndex) {
      return; // No swap needed
    }

    try {
      // Create a new data array with swapped rows
      const newData = [...this.state.data];
      const temp = newData[fromIndex];
      newData[fromIndex] = newData[toIndex];
      newData[toIndex] = temp;

      // Update the state
      this.state.data = newData;
      this.state.rawData = newData;

      // Regenerate processed data if needed
      if (this.state.dataHandlingMode === 'raw') {
        this.state.processedData = this.generateProcessedDataForDisplay();
      } else {
        // For processed mode, regenerate the pivot table
        this.state.processedData = this.generateProcessedDataForDisplay();
      }

      // Emit state change to notify subscribers
      this._emit();
    } catch (error) {
      console.error('Error during raw row swap operation:', error);
    }
  }

  /**
   * Checks if any of the current filters are for aggregated measures
   * @private
   */
  private hasAggregatedFilters(): boolean {
    return this.filterConfig.some(filter => {
      // Check if the filter field is an aggregated measure (e.g., "sum_price", "avg_sales")
      return (
        filter.field.includes('_') &&
        this.state.measures.some(
          measure =>
            filter.field === `${measure.aggregation}_${measure.uniqueName}`
        )
      );
    });
  }

  /**
   * Filters processed data based on aggregated values
   * @private
   */
  private filterProcessedData(originalData: T[]): T[] {
    // First, ensure we have grouped data for filtering
    if (this.state.groupConfig) {
      this.applyGrouping(originalData);
    }

    // Get all aggregated filters and regular field filters
    const aggregatedFilters = this.filterConfig.filter(
      filter =>
        filter.field.includes('_') &&
        this.state.measures.some(
          measure =>
            filter.field === `${measure.aggregation}_${measure.uniqueName}`
        )
    );

    const regularFilters = this.filterConfig.filter(
      filter =>
        !filter.field.includes('_') ||
        !this.state.measures.some(
          measure =>
            filter.field === `${measure.aggregation}_${measure.uniqueName}`
        )
    );

    // Apply regular field filters to raw data first
    let filteredData = originalData;
    if (regularFilters.length > 0) {
      filteredData = filteredData.filter(item =>
        regularFilters.every(filter => {
          const value = item[filter.field];
          const filterValue =
            typeof value === 'number' ? Number(filter.value) : filter.value;

          switch (filter.operator) {
            case 'equals':
              return value === filterValue;
            case 'contains':
              return String(value)
                .toLowerCase()
                .includes(String(filterValue).toLowerCase());
            case 'greaterThan':
              return Number(value) > Number(filterValue);
            case 'lessThan':
              return Number(value) < Number(filterValue);
            case 'between':
              return value >= filterValue[0] && value <= filterValue[1];
            default:
              return true;
          }
        })
      );
    }

    // If we have aggregated filters, we need to filter based on grouped data
    if (aggregatedFilters.length > 0) {
      // Re-apply grouping to the filtered data
      if (this.state.groupConfig) {
        this.applyGrouping(filteredData);
      }

      // Filter groups based on aggregated values
      const filteredGroups = this.state.groups.filter(group =>
        aggregatedFilters.every(filter => {
          const aggregateValue = group.aggregates[filter.field];
          const filterValue =
            typeof filter.value === 'string'
              ? Number(filter.value)
              : filter.value;

          switch (filter.operator) {
            case 'equals':
              return aggregateValue === filterValue;
            case 'greaterThan':
              return aggregateValue > (filterValue as number);
            case 'lessThan':
              return aggregateValue < (filterValue as number);
            case 'between': {
              const values = Array.isArray(filterValue)
                ? filterValue
                : [filterValue, filterValue];
              return (
                aggregateValue >= Number(values[0]) &&
                aggregateValue <= Number(values[1])
              );
            }
            default:
              return true;
          }
        })
      );

      // Extract the filtered data from the filtered groups
      filteredData = filteredGroups.flatMap(group => group.items);
    }

    return filteredData;
  }
}


================================================
FILE: engine/sorter.ts
================================================
import type { SortConfig, GroupConfig, Group } from '../types/interfaces';

export function applySort<T extends Record<string, any>>(
  data: T[],
  sortConfig: SortConfig[],
  groupConfig?: GroupConfig | null
): T[] {
  if (!sortConfig || sortConfig.length === 0) return data;

  return [...data].sort((a, b) => {
    for (const config of sortConfig) {
      const { field, direction, type, aggregation } = config;

      if (type === 'measure') {
        const valueA = calculateMeasureValue(a, field, aggregation);
        const valueB = calculateMeasureValue(b, field, aggregation);

        if (valueA !== valueB) {
          return direction === 'asc' ? valueA - valueB : valueB - valueA;
        }
      } else {
        const valueA = a[field];
        const valueB = b[field];

        if (valueA !== valueB) {
          return direction === 'asc'
            ? valueA < valueB
              ? -1
              : 1
            : valueA > valueB
            ? -1
            : 1;
        }
      }
    }
    return 0;
  });
}

function calculateMeasureValue(
  item: Record<string, any>,
  field: string,
  aggregation?: string
): number {
  const value = Number(item[field]) || 0;
  return value;
}

export function sortGroups(groups: Group[], sortConfig: SortConfig[]): Group[] {
  if (!sortConfig || sortConfig.length === 0) return groups;

  return [...groups].sort((a, b) => {
    for (const config of sortConfig) {
      const { field, direction } = config;
      const aggregateKeyA = `${config.aggregation || 'sum'}_${field}`;
      const aggregateKeyB = `${config.aggregation || 'sum'}_${field}`;

      const valueA = a.aggregates[aggregateKeyA] || 0;
      const valueB = b.aggregates[aggregateKeyB] || 0;

      if (valueA !== valueB) {
        return direction === 'asc' ? valueA - valueB : valueB - valueA;
      }
    }
    return 0;
  });
}



================================================
FILE: errors/ErrorHandler.ts
================================================
export class BaseError extends Error {
  public code: string;
  public statusCode: number;
  public metadata: Record<string, unknown>;

  constructor(
    message: string,
    code: string,
    statusCode: number,
    metadata: Record<string, unknown> = {}
  ) {
    super(message);
    this.name = this.constructor.name;
    this.code = code;
    this.statusCode = statusCode;
    this.metadata = metadata;
    Error.captureStackTrace(this, this.constructor);
  }
}

export class ValidationError extends BaseError {
  constructor(
    message: string,
    code = 'VALIDATION_ERROR',
    metadata: Record<string, unknown> = {}
  ) {
    super(message, code, 400, metadata);
  }
}

export class InternalError extends BaseError {
  constructor(
    message: string,
    code = 'INTERNAL_ERROR',
    metadata: Record<string, unknown> = {}
  ) {
    super(message, code, 500, metadata);
  }
}



================================================
FILE: types/interfaces.ts
================================================
export interface AxisConfig {
  uniqueName: string;
  caption?: string;
  sortOrder?: 'asc' | 'desc';
}

export interface DataSourceConfig {
  type: 'local' | 'remote' | 'file';
  url?: string; // For remote data source
  file?: File; // For file data source
}
export interface Column {
  field: string;
  label: string;
  type?: 'string' | 'number' | 'date';
}

export interface SortConfig {
  field: string;
  direction: 'asc' | 'desc';
  type?: 'measure' | 'dimension';
  aggregation?: AggregationType;
}

export interface RowSize {
  index: number;
  height: number;
}

// Define the structure for expanded rows
export interface ExpandedState {
  [key: string]: boolean;
}

// Define the configuration for grouping
export interface GroupConfig {
  rowFields: string[];
  columnFields: string[];
  grouper: (item: any, fields: string[]) => string;
}

// Define the structure for a group
export interface Group {
  key: string;
  items: any[];
  subgroups?: Group[];
  aggregates: { [key: string]: number };
  level?: number;
}

// Data formatting configuration
export interface FormatOptions {
  type: 'currency' | 'number' | 'percentage' | 'date';
  locale?: string;
  currency?: string;
  decimals?: number;
  dateFormat?: string;
}

// Supported aggregation types
export type AggregationType = 'sum' | 'avg' | 'count' | 'min' | 'max';

// Measure definition
export interface Measure {
  field: string;
  label: string;
  type: 'number';
  format?: FormatOptions;
  aggregation?: AggregationType;
}

// Dimension definition
export interface Dimension {
  field: string;
  label: string;
  type: 'string' | 'date';
  format?: FormatOptions;
}

export interface FilterConfig {
  field: string;
  operator: 'equals' | 'contains' | 'greaterThan' | 'lessThan' | 'between';
  value: any;
}

export interface PaginationConfig {
  currentPage: number;
  pageSize: number;
  totalPages: number;
}

export type DataHandlingMode = 'raw' | 'processed';

export interface PivotTableState<T> {
  data: any;
  dataHandlingMode: DataHandlingMode;
  rawData: T[];
  processedData: ProcessedData;
  sortConfig: SortConfig[];
  rows: AxisConfig[];
  columns: AxisConfig[];
  measures: MeasureConfig[];
  rowSizes: RowSize[];
  expandedRows: ExpandedState;
  groupConfig: GroupConfig | null;
  groups: Group[];
  selectedMeasures: MeasureConfig[];
  selectedDimensions: Dimension[];
  selectedAggregation: AggregationType;
  formatting: { [key: string]: FormatOptions };
  columnWidths: { [key: string]: number };
  isResponsive: boolean;
  rowGroups: Group[];
  columnGroups: Group[];
  filterConfig: FilterConfig[];
  paginationConfig: PaginationConfig;
  cellFormats?: Map<string, CellFormatConfig>;
  selectedCells?: Set<string>;
}

export interface PivotTableConfig<T> {
  data: any;
  rawData: T[];
  dataSource?: DataSourceConfig;
  rows: AxisConfig[];
  columns: AxisConfig[];
  measures: MeasureConfig[];
  dimensions: Dimension[];
  groupConfig?: GroupConfig | null;
  formatting?: { [key: string]: FormatOptions };
  defaultAggregation: AggregationType;
  isResponsive?: boolean;
  initialSort?: SortConfig[];
  pageSize?: number;
  // onRowDragEnd?: (fromIndex: number, toIndex: number, newData: T[]) => void;
  onRowDragEnd?: (
    fromIndex: number,
    toIndex: number,
    newOrder: Group[]
  ) => void;
  onColumnDragEnd?: (
    fromIndex: number,
    toIndex: number,
    newColumns: { uniqueName: string; caption: string }[]
  ) => void;
}

export interface MeasureConfig {
  uniqueName: string;
  caption?: string;
  aggregation: AggregationType;
  format?: FormatOptions;
  formula?: (item: any) => number;
  sortabled?: boolean;
}

export interface ProcessedData {
  headers: string[];
  rows: any[][];
  totals: Record<string, number>;
}

export interface ProcessedDataResult<T> {
  rawData: T[];
  groups: Group[];
}

// Chart types supported
export type ChartType = 'bar' | 'line' | 'pie' | 'scatter';

// Pivot data structure
export interface PivotData {
  [key: string]: string | number;
}

export type Row = {
  [key: string]: any;
};

export type Config = {
  columns: Column[];
  data: Row[];
};

export interface CellFormatConfig {
  // Text formatting
  textAlign?: 'left' | 'center' | 'right';
  fontWeight?: 'normal' | 'bold';
  fontStyle?: 'normal' | 'italic';
  fontSize?: string;
  fontFamily?: string;
  color?: string;
  backgroundColor?: string;

  // Number formatting
  chooseValue?: 'none' | 'currency' | 'number' | 'percentage' | 'text' | 'date';
  thousandSeparator?: string;
  decimalSeparator?: string;
  decimalPlaces?: number;

  // Currency formatting
  currencySymbol?: string;
  currencyAlign?: 'left' | 'right';

  // Special formatting
  nullValue?: string;
  formatAsPercent?: boolean;
}

export interface CellPosition {
  row: number;
  col: number;
  field?: string;
}



================================================
FILE: types/plugin.ts
================================================


